<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__32">Глава 32</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____">Ф'ючерси та конкурентність</h1>
<div class="paragraph"><p>Один з наслідків розповсюдження багатоядерних процесорів був збільшена зацікавленість до конкуренції. Java провадить підтримку конкуренції, побудовану коло розділеної пам'яті та блокування. Хоча ця підтримка є достатньою, цей підхід виявився досить складним, щоб зрозуміти його на практиці. Стандартна бібліотека Scala пропонує альтернативу, що уникає ціх складностей, через фокусування на асинхронних трансофрмаціях незмінного стану: <code>Future</code>.</p></div>
<div class="paragraph"><p>Хоча Java також пропонує <code>Future</code>, воно дуже різне від Scala. Обоє представляють результат асинхронного обчислення, але Java <code>Future</code> потребує, щоб ви отримували доступ до результату через блокуючий метод <code>get</code>. Хоча ви можете викликати <code>isDone</code> для визначення, чи Java <code>Future</code> завершилось, перед викликом <code>get</code>, і так уникнути блокування, ви маєте чекати, доки Java <code>Future</code> буде завершене, перед продовженням любих обчислень, що використовують цей результат.</p></div>
<div class="paragraph"><p>Для конрасту, ви можете вказати трансформації на Scala <code>Future</code>, чи воно завершилось, чи ні. Кожна трансформація має результатом новий <code>Future</code>, що представляє асинхронний результат оригінального <code>Future</code>, трансформованого функцією. Потік, що виконує обчислення, визначається неявно запровадженим контекстом виконання. Це дозволяє вам описати асинхронні обчислення як серії трансформацій незмінних значень, без потреби розмірковувати про розділену пам'ять та блокування.</p></div>
<div class="sect1">
<h2 id="_32_1___">32.1 Проблеми в раю</h2>
<div class="sectionbody">
<div class="paragraph"><p>На Java платформі кожний об'єкт асоційований з логічним монітором, що може бути використаний для контролю багато поточного доступу до даних. Щоб використовувати цю модель, ви вирішуєте, які дані будуть розділені між декількома потоками, та відмічаєте як <code>synchronized</code> розділи коду, що мають доступ, або контролюють доступ до розділених даних. Рантайм Java задіє механізм для переконання, що тільки один потік в момент часу заходить в синхронізовані розділи, захищені тим самим блокуванням, і таким чином дозволяючи вам оркеструвати багато поточним доступом до розділених даних.</p></div>
<div class="paragraph"><p>З причин сумісності Scala провадить доступ до примітивів конкурентності Java. Методи <code>wait</code>, <code>notify</code> та <code>notifyAll</code> можуть бути викликані в Scala, і вони мають те саме значення, що і в Java. Scala технічно не має ключового слова <code>synchronized</code>, але вона включає передвизначений метод <code>synchronized</code>, що може бути викликаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">synchronized</span> <span class="o">{</span>
  <span class="c1">// один потік в кожний момент часу</span>
  <span class="n">counter</span> <span class="k">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нажаль, програмісти визнали дуже складним побудувати надійні багато-поточні застосування з використанням розділених даних та моделі блокування, особливо як застовування зростають в розмірі та складності. Проблема в тому, що в кожній точці в програмі ви маєте продумувати щодо того, які дані змінені або мають доступ, що можуть бути модифіковані або мати доступ з інших потоків, та які блокування утримуються. На кожному виклику метода, ви маєте продумувати щодо того, які блокування була спроба захопити, та переконувати себе, що не виникає глухого блокування під час отримати їх. Ускладнюючи проблему, блокування, про які ви розмірковуєте, не зафіксовані під час компіляції, оскільки програма вільна створювати нові блокування під час виконання, по мірі просування.</p></div>
<div class="paragraph"><p>Що робить речі гуршими, тестування ненадійне з багато-поточним кодом. Оскільки потоки недетерміновані, ви можете успішно тестувати програму тисячу раз, та програма може все ще бути помилковою перший раз, коли вона використовується на машині клієнта. З розділеними даними та блокуваннями ви маєте зробити програму коректною через самі міркування.</p></div>
<div class="paragraph"><p>Більше того, ви не можете рішити проблему через пере-синхронізацію, також. Це буде так само проблематично синхронізувати геть усе, як взагалі не синхронізувати нічого. Хоча нові операції блокуваня можуть видалити можливості стану гонок, вони одночасно додають можливості глихого блокування. Коректна програма, що використовує блокування, повинна не мати одночасно ні станів гонки, ані глухих блокувань, так що ви не можете грати безпечно через надміру в жодному напрямку.</p></div>
<div class="paragraph"><p>Бібліотека <code>java.util.concurrent</code> провадить вищий рівень абстракції для конкурентного програмування. Використовуючи конкуренті утілити можна зробити багато-поточне програмування значно менш схильним до помилок, ніж розвертаючи ваші власні абстракції з низькорівневими примітивами синхронізації Java. Тим не менш, конкурентні утіліти також базовані на розділених даних та моделі блокувань, та як результат не вирішують фундаментальні складності використання цієї моделі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_32_2____try">32.2 Асинхронне використання та Try</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча це і не срібна куля, Scala <code>Future</code> пропонує один спосіб мати справу з конкурентністю, що може зменьшити, а часто і видалити потребу думати про розділені дані та блокування. Коли це включає Scala метод, він виконує обчислення "доки ви очікуєте", та повертає результат. Якщо результат є <code>Future</code>, цей <code>Future</code> представляє інше обчислення, що має бути виконане асинхронно, часто в зовсім іншому потоці. Як результат, багато операцій на <code>Future</code> потребують неявного контексту виконання, що провадить стратегію для виконання функцій асинхронно. Наприклад, якщо ви спробуєте створити ф'ючерс через метод фабрики <code>Future.apply</code> без надання неявного контексту виконання, примірника <code>scala.concurrent.ExecutionContext</code>, ви отримаєте помилку компілятора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">find</span> <span class="kt">an</span> <span class="kt">implicit</span> <span class="kt">ExecutionContext.</span>
    <span class="kt">You</span> <span class="kt">might</span> <span class="kt">pass</span> <span class="kt">an</span> <span class="o">(</span><span class="kt">implicit</span> <span class="kt">ec:</span> <span class="kt">ExecutionContext</span><span class="o">)</span>
    <span class="kt">parameter</span> <span class="kt">to</span> <span class="kt">your</span> <span class="kt">method</span> <span class="kt">or</span> <span class="kt">import</span>
    <span class="n">scala</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="nc">Implicits</span><span class="o">.</span><span class="n">global</span><span class="o">.</span>
        <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
                         <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Повідомлення про помилку дає вам один шлях вирішити цю проблему: імпортування глобального контексту виконання, що провадить сама Scala. На JVM глобальний контекст використовує пул потоків.<span class="footnote"><br />[На Scala.js глобальний контекст виконання покладає завдання на чергу подій JavaScript.]<br /></span> Коли ви занесли неявний контекст виконання в поле зору, ви можете створири ф'ючерс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Ф'ючерс, створений в попередньому прикладі, асинхронно виконує блок коду, використовуючи глобальний контекст виконання, що завершується зі значенням 42. Як тільки він розпочинає виконання, цей потік буде спати протягом десяти секунд. Таким чином, ф'ючерс буде забирати щонайменьше десять секунд на завершення.</p></div>
<div class="paragraph"><p>Два методи на <code>Future</code> дозволяють вам опитання: <code>isCompleted</code> та <code>value</code>. Коли виконується на ф'ючерсі, що ще не завершений, <code>isCompleted</code> буде повертати <code>false</code>, та <code>value</code> буде повертати <code>None</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">isCompleted</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ф'ючерс завершиться (в цьому випадку коли пройде щонайменш десять секунд), <code>isCompleted</code> буде повертати <code>true</code>, та значення буде повертати <code>Some</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">isCompleted</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Опція, що повертається <code>value</code>, містить <code>Try</code>. Як показано на Малюнку 32.1, <code>Try</code> є або <code>Success</code>, що містить значення типу <code>T</code>, або <code>Failure</code>, що містить виключення ( примірник <code>java.lang.Throwable</code>). Призначення <code>Try</code> є провадити асинхронні обчислення, що вираз <code>try</code> провадить для синхронних обчислень: він дозволяє вам мати справу з можливістю, що обчислення буде закінчено неспродівано з виключенням, скоріше ніж поверне результат.footnotes:[Зауважте, що Java <code>Future</code> також має спосіб мати справу з потенційними виключеннями, що були закинуті асинхронними виключеннями: його метод <code>get</code> буде закидати це виключення, огорнуте в <code>ExecutionException</code>.]</p></div>
<div class="paragraph"><p>Малюнок 32.1 - Ієрархія класів для <code>Try</code>.</p></div>
<div class="paragraph"><p>Для синхронних обчислень ви можете використати <code>try</code>/<code>catch</code> для переконання, що потік, який викликає метод, перехоплює та обробляє виключення, закинуті методом. Однак для асинхронних обчислень потік, що ініціює обчислення, часто переходить до інших завдань. Пізніше, якшо це асинхронно обчислення схибить з виключенням,оригінальний потік буде більше не в змозі обробити виключення в твердженні <code>catch</code>. Таким чином, коли робите з <code>Future</code> що представляє асинхронну активність, ви використовуєте <code>Try</code> щоб мати справу з можливістю, що активність схибить видати значення, та замість цього завершиться несподівано як виключення. Ось приклад, що показує, що відбувається, коли асинхронна активність схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Поітм, через десять секунд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_32_3____">32.3 Робота з ф'ючерсами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala <code>Future</code> дозволяє вам вказати трансформації на результаті <code>Future</code>, та отримати новий ф'ючерс, що представляє композицію двох асинхронних обчислень: оригінального та трансформації.</p></div>
<div class="sect2">
<h3 id="__code_futures_code___code_map_code">Трансформація <code>Futures</code> за допомогою <code>map</code></h3>
<div class="paragraph"><p>Сама фундаментальна така операція є <code>map</code>. Замість блокування, та потім продовження з іншим обчисленням, ви можете просто відобразити наступне обчислення на ф'ючерс. Результатом буде новий ф'ючерс, що представляє оригінальний, асинхронно обчислений результат, асинхронно трансформований функцією, переданою до <code>map</code>.</p></div>
<div class="paragraph"><p>Наприклад, наступний ф'ючерс буде завершений через десять секунд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Відображення цього ф'ючерса функцією, що збільшує на одиницю, буде давати інший ф'ючерс. Цей новий ф'ючерс буде представляти обчислення, що складається з оригінального додавання, за яким слідує наступне збільшення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">fut</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">result</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Як тільки оригінальний ф'ючерс завершується, та функція буде застосована до його результату, ф'ючерс, що повертається з <code>map</code>, буде завершено:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">43</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що операція, виконана в цьому прикладі, створення ф'ючерса, обчислення суми <code>21 + 21</code>, та інкремент <code>42 + 1</code>, може бути виконана в трьох різних потоках.</p></div>
</div>
<div class="sect2">
<h3 id="__code_future_code____code_for_code">Трансформування <code>Future</code> за допомогою виразів <code>for</code></h3>
<div class="paragraph"><p>Оскільки ф'ючерс Scala також декларує метод <code>flatMap</code>, ви можете трансформувати ф'ючерси з використанням виразу <code>for</code>. Наприклад, розглянемо наступні два ф'ючерса, що будуть через десять секунд виробляти <code>42</code> та <code>46</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut1</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut1</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut2</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">23</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">}</span>
<span class="n">fut2</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці два ф'ючерси, ви можете отримати новий ф'ючерс, що представляє асинхронну суму їх результатів, як це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">{</span>
          <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">fut1</span>
          <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">fut2</span>
       <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Як тільки оригінальні ф'ючерси будуть завершені, та завершиться наступна сума, ви будете в змозі побачити результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res7</span><span class="o">.</span><span class="n">value</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>for</code> вирази серіалізують їх перетворення,footnotes:[Вираз <code>for</code>, показаний в цьому прикладі, буде переписаний як виклик до <code>fut1.flatMap</code>, переданий до функції, що викликає <code>fut2.map</code>: <code>fut1.flatMap(x =&gt; fut2.map(y =&gt; x + y))</code>.] якщо ви не створите ф'ючерси пере виразом, вони не будуть робити паралельно. Наприклад, хоча попередній <code>for</code> вираз потребує близько десяти секунд для завершення, наступний вираз <code>for</code> потребує щонайменьше двадцять секунд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">{</span>
        <span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
        <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">23</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">}</span>
       <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span><span class="o">.</span><span class="n">value</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// буде потребувати щонайменьше 20 секунд для завершення</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span><span class="o">.</span><span class="n">value</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_future_code_code_future_failed_code_future_successful_code_future_fromtry_code__promise">Створення <code>Future</code>: <code>Future.failed</code>,` Future.successful`, <code>Future.fromTry</code>, та Promise</h3>
<div class="paragraph"><p>Окрім метода <code>apply</code>, використаного в попередніх прикладах для створення ф'ючерсів, об'єкт компанйон <code>Future</code> також включає три метода фабрики для створення вже завершених ф'ючерсів: <code>successful</code>, <code>failed</code> та <code>fromTry</code>. Ці методи фабрики не потребують <code>ExecutionContext</code>.</p></div>
<div class="paragraph"><p>Метод фабрика <code>successful</code> створює ф'ючерс, що вже успішний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>failed</code> створює ф'ючерс, що вже схибив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">failed</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;bummer!&quot;</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>fromTry</code> створює вже завершений ф'ючерс на основі <code>Try</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span><span class="nc">Failure</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">Success</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">})</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;bummer!&quot;</span><span class="o">)))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний спосіб створити ф'ючерс це використати <code>Promise</code>. Маючи проміс ви можете отримати ф'ючерс, що контрольований цім промісом. Ф'ючерс буде завершено, коли ви завершите проміс. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pro</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">pro</span><span class="k">:</span> <span class="kt">scala.concurrent.Promise</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="n">pro</span><span class="o">.</span><span class="n">future</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете завершити проміс за допомогою методів на ім'я <code>success</code>, <code>failure</code> та <code>complete</code>. Ці методи на <code>Promise</code> подібні до таких, описаних до цього для конструювання вже завершеного ф'ючерса. Наприклад, метод <code>success</code> буде завершувати ф'ючерс успішно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">pro</span><span class="o">.</span><span class="n">success</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">pro.</span><span class="k">type</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>failure</code> приймає виключення, що змусить ф'ючерс схибити з цім виключенням. Метод <code>complete</code> приймає <code>Try</code>. Метод <code>completeWith</code>, що приймає ф'ючерс, також існує; ф'ючерс промісу буде таким чином відображувати статус ф'ючерса, що ви передали до <code>completeWith</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__code_filter_code__code_collect_code">Фільтрування: <code>filter</code> та <code>collect</code></h3>
<div class="paragraph"><p>Ф'ючерси Scala пропонують два методи, <code>filter</code> та <code>collect</code>, що дозволяють вам переконатись, що властивість дотримується <code>true</code> щодо значень ф'ючерса. Метод <code>filter</code> валідує результат ф'ючерса, залишаючи його тим самим, якщо він валідний. Ось приклад, що переконується, що <code>Int</code> є додатним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">valid</span> <span class="k">=</span> <span class="n">fut</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">valid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо значення ф'ючерса невалідне, ф'ючерс буде хибити з <code>NoSuchElementException</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">invalid</span> <span class="k">=</span> <span class="n">fut</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">invalid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">invalid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
  <span class="kt">Future.filter</span> <span class="kt">predicate</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">satisfied</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>Future</code> також пропонує метод <code>withFilter</code>, ви можете виконати таку саму операцію з фільтрами <code>for</code> виразів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">valid</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">fut</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">yield</span> <span class="n">res</span>
<span class="n">valid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">invalid</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">fut</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">yield</span> <span class="n">res</span>
<span class="n">invalid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">invalid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
  <span class="kt">Future.filter</span> <span class="kt">predicate</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">satisfied</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>Future</code> дозволяє вам валідувати ф'ючерс, та трансформувати це в одну операцію. Якщо часткова функція, передана до <code>collect</code>, визначена на результаті ф'ючерса, ф'ючерс, що повертає <code>collect</code>, буде успішним зі значенням, що трансформований функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">valid</span> <span class="k">=</span>
         <span class="n">fut</span> <span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">46</span> <span class="o">}</span>
<span class="n">valid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Інакше ф'ючерс буде хибити з <code>NoSuchElementException</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">invalid</span> <span class="k">=</span><span class="n">fut</span> <span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">46</span> <span class="o">}</span>
<span class="n">invalid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">invalid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
<span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
<span class="kt">Future.collect</span> <span class="kt">partial</span> <span class="kt">function</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">defined</span> <span class="kt">at:</span> <span class="err">42</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_failed_code_code_fallbackto_code_code_recover_code__code_recoverwith_code">Робота з збоями: <code>failed</code>, <code>fallBackTo</code>, <code>recover</code> та <code>recoverWith</code></h3>
<div class="paragraph"><p>Ф'ючерси Scala провадять спосіб робити з ф'ючерсами, що схибили, включаючи <code>failed</code>, <code>fallBackTo</code>, <code>recover</code>,та <code>recoverWith</code>. Метод <code>failed</code> буде трансформувати невдалий ф'ючерс любого типу в <code>successfulFuture[Throwable]</code>, що містить вираз, що спричинив сбій. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">failure</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">}</span>
<span class="n">failure</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">failure</span><span class="o">.</span><span class="n">value</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">expectedFailure</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">failed</span>
<span class="n">expectedFailure</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">expectedFailure</span><span class="o">.</span><span class="n">value</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ф'ючерс, на якому викликаний метод <code>failed</code>, кінець кінцем буде успішним, ф'ючерс, повернутий <code>failed</code> сам буде хибити з <code>NoSuchElementException</code>. Метод <code>failed</code>, таким чином, доречний тільки коли ви очікуєте, що ф'ючерс схибить. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">success</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">/</span> <span class="mi">1</span> <span class="o">}</span>
<span class="n">success</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">success</span><span class="o">.</span><span class="n">value</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">unexpectedSuccess</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">failed</span>
<span class="n">unexpectedSuccess</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">unexpectedSuccess</span><span class="o">.</span><span class="n">value</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
<span class="kt">Future.failed</span> <span class="kt">not</span> <span class="kt">completed</span> <span class="kt">with</span> <span class="kt">a</span> <span class="kt">throwable.</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>fallbackTo</code> дозволяє вам провадити альтернативний ф'ючерс, для використання в випадку, коли ф'ючерс, на якому ви викликаєте <code>fallbackTo</code>, схибить. Ось приклад, в якому збійний ф'ючерс відкочується до вдалого ф'ючерса:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fallback</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">fallbackTo</span><span class="o">(</span><span class="n">success</span><span class="o">)</span>
<span class="n">fallback</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fallback</span><span class="o">.</span><span class="n">value</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо оригінальний ф'ючерс, на якому викликається <code>fallbackTo</code>, схибить, збій ф'ючерса, переданого до <code>fallbackTo</code>, просто ігнорується. Ф'ючерс, повернутий <code>fallbackTo</code>, буде хибити з початковим виключенням. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">failedFallback</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">fallbackTo</span><span class="o">(</span>
        <span class="nc">Future</span> <span class="o">{</span> <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="mi">42</span><span class="o">;</span> <span class="n">require</span><span class="o">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">);</span> <span class="n">res</span> <span class="o">}</span>
       <span class="o">)</span>
<span class="n">failedFallback</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">failedFallback</span><span class="o">.</span><span class="n">value</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
<span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>recover</code> дозволяє вам трансформувати вам невдалий ф'ючерс в успішний, дозволяючи результату вдалого ф'ючерса проходити без змін. Наприклад, на ф'ючерсі, що схибив з <code>ArithmeticException</code>, ви можете використати метод <code>recover</code>, щоб трансформувати збій в успіх, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">failedFallback</span> <span class="n">recover</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ArithmeticException</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">}</span>
<span class="n">recovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">recovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(-</span><span class="mi">1</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо оригінальний ф'ючерс не схибить, ф'ючерс, що повертається з <code>recover</code>, буде завершений з тим самим значенням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">unrecovered</span> <span class="k">=</span> <span class="n">fallback</span> <span class="n">recover</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ArithmeticException</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">}</span>
<span class="n">unrecovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">unrecovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібним чином, якщо часткова функція, передана до <code>recover</code>, не визначена на виключенні, з яким оригінальний ф'ючерс кінець кінцем схибив, цей оригінальний збій буде передано без змін:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">alsoUnrecovered</span> <span class="k">=</span> <span class="n">failedFallback</span> <span class="n">recover</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">IllegalArgumentException</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">2</span>
        <span class="o">}</span>
<span class="n">alsoUnrecovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">alsoUnrecovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>recoverWith</code> подібний до <code>recover</code>, за винятком того, що замість відновлення до значення, як в <code>recover</code>, метод <code>recoverWith</code> дозволяє вам відновити до значення ф'ючерса. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">alsoRecovered</span> <span class="k">=</span> <span class="n">failedFallback</span> <span class="n">recoverWith</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ArithmeticException</span> <span class="o">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">+</span> <span class="mi">46</span> <span class="o">}</span>
        <span class="o">}</span>
<span class="n">alsoRecovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">alsoRecovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і з <code>recover</code>, якщо оригінальний ф'ючерс не схибив, або часткова функція, передана до <code>recoverWith</code> не визначена на виключенні, з яким схибив оригінальний ф'ючерс, оригінальний успіх (або збій) будуть передані наскрізь до ф'ючерса, що повертається <code>recoverWith</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____code_transform_code">Відображення обох можливостей: <code>transform</code></h3>
<div class="paragraph"><p>Метод <code>Future</code> <code>transform</code> приймає дві функції, якими він трансформує ф'ючерс: одну для використання в разі вдачі, та іншу для випадку невдачі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">first</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span>
          <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span>
          <span class="n">ex</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
        <span class="o">)</span>
<span class="n">first</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ф'ючерс успішний використовується перша функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">.</span><span class="n">value</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(-</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ф'ючерс зазнає невдачі використовується друга функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span>
          <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span>
          <span class="n">ex</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
        <span class="o">)</span>
<span class="n">second</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">value</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">see</span> <span class="kt">cause</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що за допомогою метода <code>transform</code>, показаного в попередніх прикладах, ви не можете змінити успішний ф'ючерс на невдалий, так само як неможете перетворити невдалий на успішний. Щоб зробити цей різновид трансформації простішим, Scala 2.12 вводить альтернативну перевантажену форму <code>transform</code>, що приймає функцію з <code>Try</code> до <code>Try</code>. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">firstCase</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">))</span>
        <span class="o">}</span>
<span class="n">first</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">firstCase</span><span class="o">.</span><span class="n">value</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(-</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">secondCase</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">))</span>
        <span class="o">}</span>
<span class="n">secondCase</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">secondCase</span><span class="o">.</span><span class="n">value</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">see</span> <span class="kt">cause</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад використання нового метода <code>transform</code> для трансформації невдачі до успіху:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nonNegative</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">abs</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
        <span class="o">}</span>
<span class="n">nonNegative</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">nonNegative</span><span class="o">.</span><span class="n">value</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_zip_code_code_future_fold_code_code_future_reduce_code_code_future_sequence_code__code_future_traverse_code">Комбінування ф'ючерсів: <code>zip</code>, <code>Future.fold</code>, <code>Future.reduce</code>, <code>Future.sequence</code> та <code>Future.traverse</code></h3>
<div class="paragraph"><p><code>Future</code> та його об'єкт компанйон пропонує методи, що дозволяють вам комбінувати декілька ф'ючерсів. Метод <code>zip</code> буде трансформувати два успішні ф'ючерса в тапл ф'ючерсів з обох значень. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zippedSuccess</span> <span class="k">=</span> <span class="n">success</span> <span class="n">zip</span> <span class="n">recovered</span>
<span class="n">zippedSuccess</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">zippedSuccess</span><span class="o">.</span><span class="n">value</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">((</span><span class="mi">42</span><span class="o">,-</span><span class="mi">1</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо любий з ф'ючерсів схибить, ф'ючерс, що повертається з <code>zip</code> також бути хибним з тим самим виключенням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zippedFailure</span> <span class="k">=</span> <span class="n">success</span> <span class="n">zip</span> <span class="n">failure</span>
<span class="n">zippedFailure</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">zippedFailure</span><span class="o">.</span><span class="n">value</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо обоє з ф'ючерсів невдалі, невдалий ф'ючерс буде містити виключення, що зберігається в початковому ф'ючерсі, тому, на якому був викликаний <code>zip</code>.</p></div>
<div class="paragraph"><p>Об'єкт компанйон пропонує метод <code>fold</code>, що  дозволяє вам акумулювати результати по <code>TraversableOnce</code> колекції ф'ючерсів, отримуючи результуючий ф'ючерс. Якщо всі ф'ючерси в колекції успішні, результуючий ф'ючерс буде успішний з акумульованим результатом. Якщо любий ф'ючерс в колекції схибить, результуючий ф'ючерс буде невдалим. Якщо схиблять декілька ф'ючерсів, результат буде мати невдачу з тим самим виключенням, з яким схибив перший ф'ючерс (більш ранішній в колекції <code>TraversableOnce</code>). Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortyTwo</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fortyTwo</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortySix</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">23</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">}</span>
<span class="n">fortySix</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futureNums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">fortyTwo</span><span class="o">,</span> <span class="n">fortySix</span><span class="o">)</span>
<span class="n">futureNums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">folded</span> <span class="k">=</span>
      <span class="nc">Future</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">futureNums</span><span class="o">)(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">acc</span> <span class="o">+</span> <span class="n">num</span>
      <span class="o">}</span>
<span class="n">folded</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">folded</span><span class="o">.</span><span class="n">value</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>Future.reduce</code> виконує <code>fold</code> без нуля, використовуючи початковий результат ф'ючерса як стартове значення. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">reduced</span> <span class="k">=</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">futureNums</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">acc</span> <span class="o">+</span> <span class="n">num</span>
        <span class="o">}</span>
<span class="n">reduced</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">reduced</span><span class="o">.</span><span class="n">value</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви передасте порожню колекцію до <code>reduce</code>, отриманий ф'ючерс буде хибити з <code>NoSuchElementException</code>.</p></div>
<div class="paragraph"><p>Метод <code>Future.sequence</code> трансформує колекцію <code>TraversableOnce</code> ф'ючерсів в ф'ючерс <code>TraversableOnce</code> зі значень. Наприклад, в неступному прикладі послідовність використовується до трансформації <code>List[Future[Int]]</code> до <code>Future[List[Int]]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futureList</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">futureNums</span><span class="o">)</span>
<span class="n">futureList</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">futureList</span><span class="o">.</span><span class="n">value</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">46</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>Future.traverse</code> буде змінювати <code>TraversableOnce</code> з любим типом елементів до <code>TraversableOnce</code> ф'ючерсів, та "послідовність" в ф'ючерс <code>TraversableOnce</code> зі значень. Наприклад, ось <code>List[Int]</code>, що трансформований до <code>Future[List[Int]]</code> через <code>Future.traverse</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">traversed</span> <span class="k">=</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">}</span>
<span class="n">traversed</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">traversed</span><span class="o">.</span><span class="n">value</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_foreach_code_code_oncomplete_code__code_andthen_code">Виконання побічних ефектів: <code>foreach</code>, <code>onComplete</code> та <code>andThen</code></h3>
<div class="paragraph"><p>Іноді вам буває потрібно виконати побічних ефект після закунчення ф'ючерса. <code>Future</code> провадить декілька методів для ціх цілей. Найбільш базовий метод є <code>foreach</code>, що буде виконувати побічний ефект, якщо ф'ючерс закінчився успішно. Наприклад, в наступному прикладі <code>println</code> не виконується в випадку невдалого ф'ючерса, тільки в випадку вдалого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">failure</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">ex</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">success</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">))</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>for</code> без <code>yield</code> буде переписане до виклика <code>foreach</code>, ви також можете досягти того самого ефекту з використанням <code>for</code> виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">failure</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">success</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Future</code> також пропонує два методи для реєстрації функцій "зворотнього виклику". Метод <code>onComplete</code> буде виконаний кожного разу, коли ф'ючерс нарешті завершується, вдало або невдало. Функції буде переданий <code>Try</code> — <code>Success</code>, що буде містити результат, якщо ф'ючерс успішний, інакше <code>Failure</code>, що міститиме виключення, що призвело до збою ф'ючерса. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">success</span> <span class="n">onComplete</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
      <span class="o">}</span>
<span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">failure</span> <span class="n">onComplete</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
        <span class="o">}</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Future</code> не гарантує жодний порядок виконання для функцій зворотнього виклику, зареєстрованих за допомогою <code>onComplete</code>. Якщо ви бажаєте примусити порядок для функцій зворотнього виклику, замість цього ви маєте використовувати <code>andThen</code>. Метод <code>andThen</code> повертає новий ф'ючерс, що відображує (успіхом або невдачею в той же спосіб) оригінальний ф'ючерс на те що ви викликаєте <code>andThen</code>, але він не завершується, доки функція зворотнього виклику не буде повністю виконаний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">newFuture</span> <span class="k">=</span> <span class="n">success</span> <span class="n">andThen</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
        <span class="o">}</span>
<span class="mi">42</span>
<span class="n">newFuture</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">newFuture</span><span class="o">.</span><span class="n">value</span>
<span class="n">res76</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо функція зворотнього виклику, передана до <code>andThen</code>, при виконанні закидає виключення, це виключення не буде просуватись до наступних зворотніх викликів, або повідомлятись через отриманий ф'ючерс.</p></div>
</div>
<div class="sect2">
<h3 id="_____2_12_code_flatten_code_code_zipwith_code__code_transformwith_code">Інші методи, додані в 2.12: <code>flatten</code>, <code>zipWith</code> та <code>transformWith</code></h3>
<div class="paragraph"><p>Метод <code>flatten</code>, доданий в 2.12, трансформує <code>Future</code>, вкладене до іншого <code>Future</code> на <code>Future</code> вкладеного типу. Наприклад, <code>flatten</code> може трансформувати <code>Future[Future[Int]]</code> на <code>Future[Int]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nestedFuture</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">}</span> <span class="o">}</span>
<span class="n">nestedFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">flattened</span> <span class="k">=</span> <span class="n">nestedFuture</span><span class="o">.</span><span class="n">flatten</span> <span class="c1">// Scala 2.12</span>
<span class="n">flattened</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>zipWith</code>, доданий в 2.12, в основному поєднує два <code>Future</code> разом, потім виконує <code>map</code> на результуючому таплі. Ось приклад двокрокового процесу, <code>zip</code>, за яким іде <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futNum</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">futNum</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futStr</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="s">&quot;ans&quot;</span> <span class="o">+</span> <span class="s">&quot;wer&quot;</span> <span class="o">}</span>
<span class="n">futStr</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zipped</span> <span class="k">=</span> <span class="n">futNum</span> <span class="n">zip</span> <span class="n">futStr</span>
<span class="n">zipped</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mapped</span> <span class="k">=</span> <span class="n">zipped</span> <span class="n">map</span> <span class="o">{</span>
          <span class="k">case</span> <span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&quot;</span><span class="si">$num</span><span class="s"> is the </span><span class="si">$str</span><span class="s">&quot;</span>
        <span class="o">}</span>
<span class="n">mapped</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mapped</span><span class="o">.</span><span class="n">value</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span> <span class="n">is</span> <span class="n">the</span> <span class="n">answer</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>zipWith</code> дозволяє вам виконати ту ж операцію в один крок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="n">futNum</span><span class="o">.</span><span class="n">zipWith</span><span class="o">(</span><span class="n">futStr</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&quot;</span><span class="si">$num</span><span class="s"> is the </span><span class="si">$str</span><span class="s">&quot;</span>
        <span class="o">}</span>
<span class="n">zipWithed</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span> <span class="n">is</span> <span class="n">the</span> <span class="n">answer</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Future</code> також отримав метод <code>transformWith</code> в Scala 2.12, що дозволяє вам трансформувати ф'ючерс, використовуючи функцію від <code>Try</code> до <code>Future</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">flipped</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">transformWith</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">Future</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span> <span class="o">}</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
        <span class="o">}</span>
<span class="n">flipped</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">flipped</span><span class="o">.</span><span class="n">value</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="err">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>transformWith</code> подібний до нового, перевантаженого метода <code>transform</code>, доданого в Scala 2.12, за винятком, що замість видачі <code>Try</code> в вашу передану функцію як в <code>transform</code>, <code>transformWith</code> дозволяє вам видати функцію.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_32_4___">32.4 Тестування ф'ючерсів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна перевага ф'ючерсів Scala в тому, що вони допомагають уникати блокування. На більшості JVM реалізацій після створення тільки декількох тисяч потоків, вартість перемикання між потоками буде деградувати продкутивність до неприйнятного рівня. Через уникнення блокування ви можете підтримувати скінчене число потоків, які ви вважаєте необхідними для напруженої роботи. Тим не менш Scala дозволяє вам блокувати на результаті ф'ючерса, якщо вам потрібно. Об'єкт Scala <code>Await</code> спрощує блокування для очікування результату ф'ючерса. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">fut</span><span class="o">,</span> <span class="mf">15.</span><span class="n">seconds</span><span class="o">)</span> <span class="c1">// blocks</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Await.result</code> приймає <code>Future</code> та <code>Duration</code>. <code>Duration</code> вказує, як довго <code>Await.result</code> має чекати завершення <code>Future</code> перед таймаутом. В цьому прикладі для <code>Duration</code> було вказано 15 секунд. Таким чином, метод <code>Await.result</code> не повинен вийти в таймаут перед завершенням функції, що обчислює значення <code>42</code>.</p></div>
<div class="paragraph"><p>Одне місце, де блокування загалом прийнятне, це в тестах асинхронного коду. Коли цей <code>Await.result</code> повертається, ви можете виконувати обчислення з використанням результату, як твердження в тесті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">org.scalatest.Matchers._</span>
<span class="k">import</span> <span class="nn">org.scalatest.Matchers._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">org.scalatest.Assertion</span> <span class="o">=</span> <span class="nc">Succeeded</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно, ви можете використовувати блокуючі конструкції, що провадить ScalaTest трейт <code>ScalaFutures</code>. Наприклад, метод <code>futureValue</code>, неявно доданий до <code>Future</code> через <code>ScalaFutures</code>, буде блокувати, доки ф'ючерс не завершиться. Якщо ф'ючерс схибить, <code>futureValue</code> буде закидати <code>TestFailedException</code>, що описує проблему. Якщо ф'ючерс успішний, <code>futureValue</code> буде повертати успішний результат ф'ючерса, так що ви можете виконати твердження для значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">org.scalatest.concurrent.ScalaFutures._</span>
<span class="k">import</span> <span class="nn">org.scalatest.concurrent.ScalaFutures._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">futureValue</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="c1">// futureValue блокується</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">org.scalatest.Assertion</span> <span class="o">=</span> <span class="nc">Succeeded</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча блокування в тестах часто гарне, ScalaTest 3.0 додає "асинхронні" стилі тестування, що дозволяють вам тестувати ф'ючерсси без блокування. Маючи ф'ючерс, замість блокування і виконання тверджень на результаті, ви можете відображити твердження напряму на цей ф'ючерс, та повернути результуючий <code>Future[Assertion]</code> до ScalaTest.</p></div>
<div class="paragraph"><p>Приклад показаний на Лістингу 32.1. Коли твердження ф'ючерса завершиться, ScalaTest запустить події (тест успішний, тест схибив, тощо) то доповідача тестів асинхронно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.AsyncFunSpec</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">class</span> <span class="nc">AddSpec</span> <span class="k">extends</span> <span class="nc">AsyncFunSpec</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addSoon</span><span class="o">(</span><span class="n">addends</span><span class="k">:</span> <span class="kt">Int*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Future</span> <span class="o">{</span> <span class="n">addends</span><span class="o">.</span><span class="n">sum</span> <span class="o">}</span>

  <span class="n">describe</span><span class="o">(</span><span class="s">&quot;addSoon&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">it</span><span class="o">(</span><span class="s">&quot;will eventually compute a sum of passed Ints&quot;</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">futureSum</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">addSoon</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
      <span class="c1">// Ви можете відобразити твердежння на Future, потім</span>
      <span class="c1">// повернути отриманий Future[Assertion] до ScalaTest:</span>
      <span class="n">futureSum</span> <span class="n">map</span> <span class="o">{</span> <span class="n">sum</span> <span class="k">=&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 32.1 - Повернення ф'ючерного твердження до <code>ScalaTest</code>.</p></div>
<div class="paragraph"><p>Випадок використання асинхронного тестування ілюструє загальний принцип для роботи з ф'ючерсами: опинившись у "ф'ючерному космосі", намагайтесь залишатись у ф'ючерному космосі. Не блокуйте на ф'ючерсі, та потім не продовжуйте обчислення з результатом. Залишайтесь асинхронним через виконання серій трансформацій, кожна з яких повертає новий ф'ючерс до <code>transform</code>. Щоб отримати результати з ф'ючерного космосу, реєструйте побічні ефекти, що будуть виконуватись асинхронно, коли ф'ючерс завершиться. Цей підхід допоможе вам максимально задіяти ваші потоки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_32_5_">32.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Конкуренте програмування надає вам велику силу. Воно дозволяє вам отримати перевагу від декількох процесорів. На невдачу, що найбільш широко застосовувані конкурентні примітиви, потоки, блокування та монітори, є таким мінним полем з глухих блокувань та станів гонок. Ф'ючерси провадять спосіб виходу з цього мінного поля, дозволяючи вам писати конкурентні програми без великого ризику глухих блокувань та станів гонок. Ця глава ввела декіклька фундаментальних конструкцій для роботи зі ф'ючерсами в Scala, включаючи як створити ф'ючерси, як трансормувати їх, та як їх протестувати, крім інших дрібниць. Вона також показала вам, як використовувати ці конструкції, як частину загального стилю ф'ючерсів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-22 04:48:42 EEST
</div>
</div>
</body>
</html>
