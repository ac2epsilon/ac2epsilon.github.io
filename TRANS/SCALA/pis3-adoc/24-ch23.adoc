include::headers.adoc[]

Глава 23
--------

Ще раз про вирази `for`
=======================

Глава 16 продемонструвала, що функції вищих порядків, такі як `map`, `flatMap`, та `filter`, провадять потужні конструкції для роботи зі списками. Але іноді рівень абстракції, що потребують ці функції, робить програми трохи складними для розуміння.

Ось приклад. Скажімо, ви отримали список людей, кожний визначений як примірник класу  `Person`. Клас `Person` має поля, де вказані ім'я, стать, та перелік дітей.

Ось визначення класу:
[source,scala]
----
scala> case class Person(name: String,
                         isMale: Boolean,
                         children: Person*)
----
Ось приклад декількох записів:
[source,scala]
----
val lara = Person("Lara", false)
val bob = Person("Bob", true)
val julie = Person("Julie", false, lara, bob)
val persons = List(lara, bob, julie)
----
Тепер, скажімо, ми бажаємо знайти всі пари імен матерів та їх дітей в цьому списку. Використовуючи `map`, `flatMap` та `filter` ви можете зформулювати наступний запит:
[source,scala]
----
scala> persons filter (p => !p.isMale) flatMap (p =>
            (p.children map (c => (p.name, c.name))))
res0: List[(String, String)] = List((Julie,Lara),
    (Julie,Bob))
----
Ви можете трохи оптимізувати цей приклад, використавши виклик `withFilter` замість `filter`. Це дозволить уникнути створення проміжної структури даних для жінок:
[source,scala]
----
scala> persons withFilter (p => !p.isMale) flatMap (p =>
    (p.children map (c => (p.name, c.name))))
res1: List[(String, String)] = List((Julie,Lara),
    (Julie,Bob))
----
Ці запити роблять свою роботу, але вони не дуже тривіальні для написання та розуміння. Чи є простіший спосіб? Фактично, так. Згадайте вирази `for` в Розділі 7.3? Використовуючи вирази `for`, той самий приклад може бути записаний наступним чином:
[source,scala]
----
scala> for (p <- persons; if !p.isMale; c <- p.children)
      yield (p.name, c.name)
res2: List[(String, String)] = List((Julie,Lara),
    (Julie,Bob))
----
Результат цього виразу точно такий самий, що і результат попереднього виразу. Більше того, більшість читачів коду вірогідно знайде, що вирази `for` значно ясніші, ніж попередні запити, що використовують функції вищих порядків, `map`, `flatMap`, та `withFilter`.

Однак, останні два запити не настільки різноманітні, як може виглядати. Фактично, з'ясовується, що компілятор Scala буде транслювати другий запит в перший. Більш загально, всі вирази `for`, що видають результат, транслюються компілятором в комбінації викликів методів вищого порядку, `map`, `flatMap`, та `withFilter`. Всі `for` цикли без `yield` транслюються в меньший набір функцій вищого порядку: тільки `withFilter` та `foreach`.

В цій главі ви з'ясуєте для початку щодо точних правил написання виразів. Після цього ви побачите, як вони можуть зробити комбінаторні проблеми простішими для вирішення. Нарешті, ви вивчите, як транслюються `for` вирази, і як результат, `for` вирази можуть допомогти вам "виростити" мову Scala в нових доменах застосування.

23.1 Вирази `for`
-----------------
Загалом, `for` вираз має форму:
[source,scala]
----
for ( seq ) yield expr
----
Тут `seq` є послідовність генераторів, визначень та фільтрів, розділені крапкою з комою між послідовними елементами. Приклад для `for` виразу:
[source,scala]
----
for (p <- persons; n = p.name; if (n startsWith "To"))
yield n
----
Цей `for` вираз містить один генератор, одне визначення та один фільтр. Як зазначалось в Розділі 7.3, ви також можете оточити послідовність в фігурні дужки замість звичайних. Тоді крапки з комою стають опціональними:
[source,scala]
----
for {
  p <- persons           // генератор
  n = p.name             // визначення
  if (n startsWith "To") // фільтр
} yield n
----
Генератор має форму:
[source,scala]
----
pat <- expr
----
Вираз `expr` типово повертає список, навіть якщо, як ви побачите пізніше, це може бути узагальнено. Шаблон `pat` співпадає один-до-одного з усіма елементами цього списку. Якщо співпадіння успішне, змінні в шаблоні прив'язуються до відповідних частин елементу, в той самий спосіб, як описане в Главі 15. Але якщо співпадіння схибить, виключення `MatchError` не виникне. Замість цього елемент просто відкидається з ітерації.

В самому загальному випадку шаблон `pat` є тільки змінна `x`, як в `x <- expr`. В цьому випадку змінна `x` просто ітерує по всіх елементах, що повертає `expr`.

Визначення має форму:
[source,scala]
----
pat = expr
----
Це визначення прив'язує шаблон `pat` до значення `expr`, так що це має той самий ефект, що і визначення `val`:
[source,scala]
----
val x = expr
----
Найбільш загальний випадок знову коли шаблон є простою змінною `x` (тобто, `x = expr`). Це визначає `x` як ім'я для значення `expr`.

Фільтр має таку форму:
[source,scala]
----
if expr
----
Тут `expr` є вираз типу `Boolean`. Фільтр відкидає з ітерації всі елементи, для яких `expr` повертає `false`.

Кожний `for` вираз починається з генератора. Якщо є декілька генераторів в виразі `for`, пізніші генератори змінюються більш швидко, ніж ранішні. Ви можете просто це перевірити за допомогою наступного простого тесту:
[source,scala]
----
scala> for (x <- List(1, 2); y <- List("one", "two"))
        yield (x, y)
res3: List[(Int, String)] =
  List((1,one), (1,two), (2,one), (2,two))
----
23.2 Проблема N ферзів
----------------------
Особливо придатною областю застосування `for` виразів є комбінаторні головоломки. Прикладом такої головоломки є проблема 8-ми ферзів: маючи стандартну шахову дошку, розмістити вісім ферзів, так, щоб жодний не шахував іншого (ферзь шахує іншу фігуру, якщо стоїть на тому самому рядку, лінії або диагоналі). Щоб знайти рішення цієї проблеми, насправді легше узагальнити її для шахових дошок довільного розміру. Таким чином, проблема є розмістити N ферзів на шахівниці з `N x N` клітин, де розмір `N` довільний. Ми почнемо нумерування клітин з одного, так що верхня-ліва клітина на дошці `N x N` має координати `(1, 1)`, та нижня-права клітина має координати `(N, N)`.

Щоб вирішити проблему `N` ферзів, зауважте, що вам треба розмістити ферзя на кожному рядку. Так що ви можете ставити ферзів в послідовних рядках, кожний раз перевіряючи, що новий розміщений ферзь не шахується жодним іншим ферзем, що вже на дошці. По ходу цього пошуку, може статись, що ферзь, який треба поставити на рядок `k`, шахується у всіх полях цього рядка з ферзями на рядках від `1` до `k-1`. В цьому випадку вам треба перервати цю частину пошуку, щоб продовжити з іншою конфігурацією ферзів в стовпчиках від `1` до `k-1`.

Імперативне рішення цієї проблеми буде ставити ферзів один по одному, рухаючи їх по дошці. Але це виглядає складним запропонувати схему, що насправді спробує всі можливості. Більш функціональний підхід представляє рішення напряму, як значення. Рішення складається зі списку координат, по одній для кожного ферзя на дошці. Однак занотуйте, що повне рішення не може бути знайдене за один крок. Рішення має бути побудоване поступово, через захоплення послідовних рядків ферзями.

Це підказує рекурсивний алгоритм. Уявімо, що ви вже згенерували всі рішення, розмістивши  `k` ферзів на дошці розміром `N x N`, до `k` меньше ніж `N`. Кожне таке рішення може бути презентовано як список довжиною `k` координат `(row, column)`, де обидва, `row` та `column` є числами в диапазоні від `1` до `N`. Зручно розглядати ці часткові списки рішень як стеки, де координати ферзя на рядку `k` ідуть першими в списку, за яким ідуть координати ферзя в рядку `k-1`, і так далі. Знизу стека є координати ферзя, розміщеного на першому рядку дошки. Всі рішення разом представлені як список списків, з одним елементом для кожного ферзя.

Тепер, щоб поставити наступного ферзя в рядок `k+1`, згенеруйте всі можливі розширення кожного попереднього рішення ще на одного ферзя. Це дає інший список рішень, на цей раз довжини `k+1`. Продовжуйте процес доки ви не отримаєте всі рішення розміру шахівниці N.

Ця алгоритмична ідея втілена в функціональне `placeQueens` нижче:
[source,scala]
----
def queens(n: Int): List[List[(Int, Int)]] = {
  def placeQueens(k: Int): List[List[(Int, Int)]] =
    if (k == 0)
      List(List())
    else
      for {
        queens <- placeQueens(k - 1)
        column <- 1 to n
        queen = (k, column)
        if isSafe(queen, queens)
      } yield queen :: queens

  placeQueens(n)
}
----
Зовнішня функція `queens` в програмі вище просто викликає `placeQueens` з розміром дошки `n` в якості аргумента. Завдання функції `placeQueens(k)` є генерація всіх часткових рішень довжини `k` в списку. Кожний елемент списку є одним рішенням, представлений списком довжини `k`. Так що `placeQueens` повертає список списків.

Якщо параметр `k` до `placeQueens` є `0`, це означає, що треба згенерувати всі рішення, розмістивши нуль ферзів на нулі рядків. Існує тільки одне таке рішення: не розташовувати ферзів взагалі. Це рішення представлене порожнім списком. Так що якщо `k` є нуль,`placeQueens` повертає `List(List())`, список складається з єдиного елемента, що є порожнім списком. Зауважте, що це доволі відрізняється від порожнього списку `List()`.

Якщо `placeQueens` повертає `List()`, це означає відсутність рішень, замість єдиного рішення, що складається з відсутності розміщених ферзів.

В іншому випадку, коли `k` не нуль, вся робота `placeQueens` виконується в `for` виразі. Перший генератор цього `for` виразу ітерує по всіх рішеннях, розміщуючи `k - 1` ферзів на дошці. Другий генератор ітерує по всіх можливих стовпчиках, на яких може бути розміщений  `k`-тий ферзь. Третя частина `for` виразу визначає новітньо розглянуту позицію ферзя, що буде парою з рядка `k` та кожного стовпчика. Четверта частина виразу `for` є фільтром, що перевіряє за допомогою `isSafe`, чи новий ферзь є вільний від шаху всіма існуючими ферзями (визначення `isSafe` буде розглянута трохи пізніше).

Якщо новий ферзь не має шахів від жодного з інших ферзів, він може формувати частину часткового рішення, так що `placeQueens` генерує нове рішення за допомогою `queen :: queens`. Якщо новий ферзь не вільний від шаху, фільтр повертає `false`, так що рішення не генерується.

Один фрагмент, що залишився, це метод `isSafe`, що використовується для перевірки, чи даний ферзь шахується любим іншим елементом в списку ферзів. Ось його визначення:
[source,scala]
----
def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =
  queens forall (q => !inCheck(queen, q))

def inCheck(q1: (Int, Int), q2: (Int, Int)) =
  q1._1 == q2._1 || // той самий рядок
  q1._2 == q2._2 || // той самий стовпчик
  (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // на диагоналі
----
Метод `isSafe` виражає, що ферзь безпечний у відношенні до інших ферзів, якщо він не шахується іншим ферзем. Метод `inCheck` виражає, що ферзі `q1` та `q2` взаємно шахуються. Він повертає `true` в одному з трьох випадків:

1. Якщо два ферзя мають ту саму координату рядка,
2. Якщо два ферзя мають ту саму координату стовбчика,
3. Якщо два ферзя на тій самій диагоналі (тобто, різниця між рядками і різниця між стовпчиками ті самі).

Перший випадок, коли два ферзя мають ту саму координату, не може трапитись в застосуванні, бо `placeQueens` вже потурбувався про розіщення кожного ферзя на окремому рядку. Так що ви можете видалити цю перевірку без зміни функціональності програми.

23.3 Запити за допомогою `for` виразів
--------------------------------------
The for notation is essentially equivalent to common operations of database query languages. For instance, say you are given a database named books, represented as a list of books, whereBook is defined as follows:
[source,scala]
----
case class Book(title: String, authors: String*)
----
Here is a small example database represented as an in-memory list:
[source,scala]
----
val books: List[Book] =
  List(
    Book(
      "Structure and Interpretation of Computer Programs",
      "Abelson, Harold", "Sussman, Gerald J."
    ),
    Book(
      "Principles of Compiler Design",
      "Aho, Alfred", "Ullman, Jeffrey"
    ),
    Book(
      "Programming in Modula-2",
      "Wirth, Niklaus"
    ),
    Book(
      "Elements of ML Programming",
      "Ullman, Jeffrey"
    ),
    Book(
      "The Java Language Specification", "Gosling, James",
      "Joy, Bill", "Steele, Guy", "Bracha, Gilad"
    )
  )
----  
To find the titles of all books whose author's last name is "Gosling":
[source,scala]
----
scala> for (b <- books; a <- b.authors
            if a startsWith "Gosling")
       yield b.title
res4: List[String] = List(The Java Language Specification)
----
Or to find the titles of all books that have the string "Program" in their title:
[source,scala]
----
scala> for (b <- books if (b.title indexOf "Program") >= 0)
       yield b.title
res5: List[String] = List(Structure and Interpretation of
  Computer Programs, Programming in Modula-2, Elements of ML
    Programming)
----
Or to find the names of all authors who have written at least two books in the database:
[source,scala]
----
scala> for (b1 <- books; b2 <- books if b1 != b2;
           a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
       yield a1
res6: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)
----
The last solution is still not perfect because authors will appear several times in the list of results. You still need to remove duplicate authors from result lists. This can be achieved with the following function:
[source,scala]
----
scala> def removeDuplicates[A](xs: List[A]): List[A] = {
         if (xs.isEmpty) xs
         else
           xs.head :: removeDuplicates(
             xs.tail filter (x => x != xs.head)
           )
       }
removeDuplicates: [A](xs: List[A])List[A]

scala> removeDuplicates(res6)
res7: List[String] = List(Ullman, Jeffrey)
----
It's worth noting that the last expression in method removeDuplicates can be equivalently expressed using a for expression:
[source,scala]
----
xs.head :: removeDuplicates(
  for (x <- xs.tail if x != xs.head) yield x
)
----
23.4 Трансляція `for` виразів
-----------------------------
Every for expression can be expressed in terms of the three higher-order functions map,flatMap, and withFilter. This section describes the translation scheme, which is also used by the Scala compiler.

Трансляція `for` виразів одним генератором
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
First, assume you have a simple for expression:
[source,scala]
----
for (null <- expr_1) yield expr_2
----
where x is a variable. Such an expression is translated to:
[source,scala]
----
expr_1.map(null => expr_2)
----
Трансляція `for` виразів починаючи з генератора та фільтра
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Now, consider for expressions that combine a leading generator with some other elements.

Afor expression of the form:
[source,scala]
----
for (null <- expr_1 if expr_2) yield expr_3
----
is translated to:
[source,scala]
----
for (null <- expr_1 withFilter (null => expr_2)) yield expr_3
----
This translation gives another for expression that is shorter by one element than the original, because an if element is transformed into an application of withFilter on the first generator expression. The translation then continues with this second expression, so in the end you obtain:
[source,scala]
----
expr_1 withFilter (null => expr_2) map (null => expr_3)
----
The same translation scheme also applies if there are further elements following the filter. Ifseq is an arbitrary sequence of generators, definitions, and filters, then:
[source,scala]
----
for (null <- expr_1 if expr_2; seq) yield expr_3
----
is translated to:
[source,scala]
----
for (null <- expr_1 withFilter expr_2; seq) yield expr_3
----
Then translation continues with the second expression, which is again shorter by one element than the original one.

Трансляція `for` виразів починаючи з двох генераторів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The next case handles for expressions that start with two generators, as in:
[source,scala]
----
for (null <- expr_1; null <- expr_2; seq) yield expr_3
----
Again, assume that seq is an arbitrary sequence of generators, definitions, and filters. In fact,seq might also be empty, and in that case there would not be a semicolon after expr_2. The translation scheme stays the same in each case. The for expression above is translated to an application of flatMap:
[source,scala]
----
expr_1.flatMap(null => for (null <- expr_2; seq) yield expr_3)
----
This time, there is another for expression in the function value passed to flatMap. That forexpression (which is again simpler by one element than the original) is in turn translated with the same rules. The three translation schemes given so far are sufficient to translate all for expressions that contain just generators and filters, and where generators bind only simple variables. Take, for instance, the query, "find all authors who have published at least two books," from Section 23.3:
[source,scala]
----
for (b1 <- books; b2 <- books if b1 != b2;
  a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
yield a1
----
This query translates to the following map/flatMap/filter combination:
[source,scala]
----
books flatMap (b1 =>
  books withFilter (b2 => b1 != b2) flatMap (b2 =>
    b1.authors flatMap (a1 =>
      b2.authors withFilter (a2 => a1 == a2) map (a2 =>
        a1))))
----
The translation scheme presented so far does not yet handle generators that bind whole patterns instead of simple variables. It also does not yet cover definitions. These two aspects will be explained in the next two sub-sections.

Трансляція шаблонів в генераторах
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The translation scheme becomes more complicated if the left hand side of generator is a pattern, pat, other than a simple variable. The case where the for expression binds a tuple of variables is still relatively easy to handle. In that case, almost the same scheme as for single variables applies.

A for expression of the form:
[source,scala]
----
for ((null, ..., null) <- expr_1) yield expr_2
----
translates to:
[source,scala]
----
expr_1.map { case (null, ..., null) => expr_2 }
----
Things become a bit more involved if the left hand side of the generator is an arbitrary pattern pat instead of a single variable or a tuple.

In this case:
[source,scala]
----
for (pat <- expr_1) yield expr_2
----
translates to:
[source,scala]
----
expr_1 withFilter {
  case pat => true
  case _ => false
} map {
  case pat => expr_2
}
----
That is, the generated items are first filtered and only those that match pat are mapped. Therefore, it's guaranteed that a pattern-matching generator will never throw a MatchError.

The scheme here only treated the case where the for expression contains a single pattern-matching generator. Analogous rules apply if the for expression contains other generators, filters or definitions. Because these additional rules don't add much new insight, they are omitted from discussion here. If you are interested, you can look them up in the Scala Language Specification [Ode11].

Трансляція визначень
~~~~~~~~~~~~~~~~~~~~
The last missing situation is where a for expression contains embedded definitions. Here's a typical case:
[source,scala]
----
for (null <- expr_1; null = expr_2; seq) yield expr_3
----
Assume again that seq is a (possibly empty) sequence of generators, definitions, and filters. This expression is translated to this one:
[source,scala]
----
for ((null, null) <- for (null <- expr_1) yield (null, expr_2); seq)
yield expr_3
----
So you see that expr_2 is evaluated each time there is a new x value being generated. This re-evaluation is necessary because expr_2 might refer to x and so needs to be re-evaluated for changing values of x. For you as a programmer, the conclusion is that it's probably not a good idea to have definitions embedded in for expressions that do not refer to variables bound by some preceding generator, because re-evaluating such expressions would be wasteful. For instance, instead of:
[source,scala]
----
for (x <- 1 to 1000; y = expensiveComputationNotInvolvingX)
yield x * y
----
it's usually better to write:
[source,scala]
----
val y = expensiveComputationNotInvolvingX
for (x <- 1 to 1000) yield x * y
----
Транслювання `for` циклів
~~~~~~~~~~~~~~~~~~~~~~~~~
The previous subsections showed how for expressions that contain a yield are translated.What about for loops that simply perform a side effect without returning anything? Their translation is similar, but simpler than for expressions. In principle, wherever the previous translation scheme used a map or a flatMap in the translation, the translation scheme for forloops uses just a foreach.

For instance, the expression:for (null <- expr_1) body translates to:
[source,scala]
----
expr_1 foreach (null => body)
----
A larger example is the expression:
[source,scala]
----
for (null <- expr_1; if expr_2; null <- expr_3) body
----
This expression translates to:
[source,scala]
----
expr_1 withFilter (null => expr_2) foreach (null =>
expr_3 foreach (null => body))
----
For example, the following expression sums up all elements of a matrix represented as a list of lists:
[source,scala]
----
var sum = 0
for (xs <- xss; x <- xs) sum += x
----
This loop is translated into two nested foreach applications:
[source,scala]
----
var sum = 0
  xss foreach (xs =>
    xs foreach (x =>
      sum += x))
----
23.5 Заходячи з іншого боку
---------------------------
The previous section showed that for expressions can be translated into applications of the higher-order functions map, flatMap, and withFilter. In fact, you could equally go the other way: Every application of a map, flatMap, or filter can be represented as a for expression.

Here are implementations of the three methods in terms of for expressions. The methods are contained in an object Demo to distinguish them from the standard operations on Lists. To be concrete, the three functions all take a List as parameter, but the translation scheme would work just as well with other collection types:
[source,scala]
----
object Demo {
  def map[A, B](xs: List[A], f: A => B): List[B] =
    for (x <- xs) yield f(x)
  
  def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
    for (x <- xs; y <- f(x)) yield y

  def filter[A](xs: List[A], p: A => Boolean): List[A] =
    for (x <- xs if p(x)) yield x
}
----
Not surprisingly, the translation of the for expression used in the body of Demo.map will produce a call to map in class List. Similarly, Demo.flatMap and Demo.filter translate to flatMap andwithFilter in class List. So this little demonstration shows that for expressions really are equivalent in their expressiveness to applications of the three functions map, flatMap, andwithFilter.

23.6 Узагальнюючи `for`
-----------------------
Because the translation of for expressions only relies on the presence of methods map, flatMap, and withFilter, it is possible to apply the for notation to a large class of data types.

You have already seen for expressions over lists and arrays. These are supported because lists, as well as arrays, define operations map, flatMap, and withFilter. Because they define aforeach method as well, for loops over these data types are also possible.

Besides lists and arrays, there are many other types in the Scala standard library that support the same four methods and therefore allow for expressions. Examples are ranges, iterators, streams, and all implementations of sets. It's also perfectly possible for your own data types to support for expressions by defining the necessary methods. To support the full range of forexpressions and for loops, you need to define map, flatMap, withFilter, and foreach as methods of your data type. But it's also possible to define a subset of these methods, and thereby support a subset of all possible for expressions or loops.

Here are the precise rules:
* If your type defines just map, it allows for expressions consisting of a single generator.
* If it defines flatMap as well as map, it allows for expressions consisting of several generators.
* If it defines foreach, it allows for loops (both with single and multiple generators).
* If it defines withFilter, it allows for filter expressions starting with an if in the for expression.

The translation of for expressions happens before type checking. This allows for maximum flexibility because the only requirement is that the result of expanding a for expression type checks. Scala defines no typing rules for the for expressions themselves, and does not require that methods map, flatMap, withFilter, or foreach have any particular type signatures.

Nevertheless, there is a typical setup that captures the most common intention of the higher order methods to which for expressions translate. Say you have a parameterized class, C, which typically would stand for some sort of collection. Then it's quite natural to pick the following type signatures for map, flatMap, withFilter, and foreach:
[source,scala]
----
abstract class C[A] {
  def map[B](f: A => B): C[B]
  def flatMap[B](f: A => C[B]): C[B]
  def withFilter(p: A => Boolean): C[A]
  def foreach(b: A => Unit): Unit
}
----
That is, the map function takes a function from the collection's element type A to some other type B. It produces a new collection of the same kind C, but with B as the element type. TheflatMap method takes a function f from A to some C-collection of Bs and produces a C-collection of Bs. The withFilter method takes a predicate function from the collection's element type A toBoolean. It produces a collection of the same type as the one on which it is invoked. Finally, theforeach method takes a function from A to Unit and produces a Unit result:

In class C above, the withFilter method produces a new collection of the same class. That means that every invocation of withFilter creates a new C object, just the same as filter would work. Now, in the translation of for expressions, any calls to withFilter are always followed by calls to one of the other three methods. Therefore, the object created by withFilter will be taken apart by one of the other methods immediately afterwards. If objects of class C are large (think long sequences), you might want to avoid the creation of such an intermediate object. A standard technique is to let withFilter return not a C object but just a wrapper object that "remembers" that elements need to be filtered before being processed further.

Concentrating on just the first three functions of class C, the following facts are noteworthy. In functional programming, there's a general concept called a monad, which can explain a large number of types with computations, ranging from collections, to computations with state and I/O, backtracking computations, and transactions, to name a few. You can formulate functions map, flatMap, and withFilter on a monad, and, if you do, they end up having exactly the types given here.

Furthermore, you can characterize every monad by map, flatMap, and withFilter, plus a "unit" constructor that produces a monad from an element value. In an object-oriented language, this "unit" constructor is simply an instance constructor or a factory method. Therefore, map,flatMap, and withFilter can be seen as an object-oriented version of the functional concept of monad. Because for expressions are equivalent to applications of these three methods, they can be seen as syntax for monads.

All this suggests that the concept of for expression is more general than just iteration over a collection, and indeed it is. For instance, for expressions also play an important role in asynchronous I/O, or as an alternative notation for optional values. Watch out in the Scala libraries for occurrences of map, flatMap, and withFilter—when they are present, for expressions suggest themselves as a concise way of manipulating elements of the type.

23.7 Висновок
-------------
В цій главі ви отримали можливість заглянути з лаштунки виразів `for` та циклів `for`. Ви вивчили, що вони транслюються в застосування стандартного набору методів вищого порядку. Як результат, ви побачили, що `for` вирази насправді значно більш загальні, ніж прості ітерації по колекціях, і що ви можете розробляти ваші власні класи для їх підтримки.