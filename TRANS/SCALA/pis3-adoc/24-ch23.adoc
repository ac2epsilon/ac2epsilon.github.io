include::headers.adoc[]

Глава 23
--------

Ще раз про вирази `for`
=======================

Глава 16 продемонструвала, що функції вищих порядків, такі як `map`, `flatMap`, та `filter`, провадять потужні конструкції для роботи зі списками. Але іноді рівень абстракції, що потребують ці функції, робить програми трохи складними для розуміння.

Ось приклад. Скажімо, ви отримали список людей, кожний визначений як примірник класу  `Person`. Клас `Person` має поля, де вказані ім'я, стать, та перелік дітей.

Ось визначення класу:
[source,scala]
----
scala> case class Person(name: String,
                         isMale: Boolean,
                         children: Person*)
----
Ось приклад декількох записів:
[source,scala]
----
val lara = Person("Lara", false)
val bob = Person("Bob", true)
val julie = Person("Julie", false, lara, bob)
val persons = List(lara, bob, julie)
----
Тепер, скажімо, ми бажаємо знайти всі пари імен матерів та їх дітей в цьому списку. Використовуючи `map`, `flatMap` та `filter` ви можете зформулювати наступний запит:
[source,scala]
----
scala> persons filter (p => !p.isMale) flatMap (p =>
            (p.children map (c => (p.name, c.name))))
res0: List[(String, String)] = List((Julie,Lara),
    (Julie,Bob))
----
Ви можете трохи оптимізувати цей приклад, використавши виклик `withFilter` замість `filter`. Це дозволить уникнути створення проміжної структури даних для жінок:
[source,scala]
----
scala> persons withFilter (p => !p.isMale) flatMap (p =>
    (p.children map (c => (p.name, c.name))))
res1: List[(String, String)] = List((Julie,Lara),
    (Julie,Bob))
----
Ці запити роблять свою роботу, але вони не дуже тривіальні для написання та розуміння. Чи є простіший спосіб? Фактично, так. Згадайте вирази `for` в Розділі 7.3? Використовуючи вирази `for`, той самий приклад може бути записаний наступним чином:
[source,scala]
----
scala> for (p <- persons; if !p.isMale; c <- p.children)
      yield (p.name, c.name)
res2: List[(String, String)] = List((Julie,Lara),
    (Julie,Bob))
----
Результат цього виразу точно такий самий, що і результат попереднього виразу. Більше того, більшість читачів коду вірогідно знайде, що вирази `for` значно ясніші, ніж попередні запити, що використовують функції вищих порядків, `map`, `flatMap`, та `withFilter`.

Однак, останні два запити не настільки різноманітні, як може виглядати. Фактично, з'ясовується, що компілятор Scala буде транслювати другий запит в перший. Більш загально, всі вирази `for`, що видають результат, транслюються компілятором в комбінації викликів методів вищого порядку, `map`, `flatMap`, та `withFilter`. Всі `for` цикли без `yield` транслюються в меньший набір функцій вищого порядку: тільки `withFilter` та `foreach`.

В цій главі ви з'ясуєте для початку щодо точних правил написання виразів. Після цього ви побачите, як вони можуть зробити комбінаторні проблеми простішими для вирішення. Нарешті, ви вивчите, як транслюються `for` вирази, і як результат, `for` вирази можуть допомогти вам "виростити" мову Scala в нових доменах застосування.

23.1 Вирази `for`
-----------------
Загалом, `for` вираз має форму:
[source,scala]
----
for ( seq ) yield expr
----
Тут `seq` є послідовність генераторів, визначень та фільтрів, розділені крапкою з комою між послідовними елементами. Приклад для `for` виразу:
[source,scala]
----
for (p <- persons; n = p.name; if (n startsWith "To"))
yield n
----
Цей `for` вираз містить один генератор, одне визначення та один фільтр. Як зазначалось в Розділі 7.3, ви також можете оточити послідовність в фігурні дужки замість звичайних. Тоді крапки з комою стають опціональними:
[source,scala]
----
for {
  p <- persons           // генератор
  n = p.name             // визначення
  if (n startsWith "To") // фільтр
} yield n
----
Генератор має форму:
[source,scala]
----
pat <- expr
----
Вираз `expr` типово повертає список, навіть якщо, як ви побачите пізніше, це може бути узагальнено. Шаблон `pat` співпадає один-до-одного з усіма елементами цього списку. Якщо співпадіння успішне, змінні в шаблоні прив'язуються до відповідних частин елементу, в той самий спосіб, як описане в Главі 15. Але якщо співпадіння схибить, виключення `MatchError` не виникне. Замість цього елемент просто відкидається з ітерації.

В самому загальному випадку шаблон `pat` є тільки змінна `x`, як в `x <- expr`. В цьому випадку змінна `x` просто ітерує по всіх елементах, що повертає `expr`.

Визначення має форму:
[source,scala]
----
pat = expr
----
Це визначення прив'язує шаблон `pat` до значення `expr`, так що це має той самий ефект, що і визначення `val`:
[source,scala]
----
val x = expr
----
Найбільш загальний випадок знову коли шаблон є простою змінною `x` (тобто, `x = expr`). Це визначає `x` як ім'я для значення `expr`.

Фільтр має таку форму:
[source,scala]
----
if expr
----
Тут `expr` є вираз типу `Boolean`. Фільтр відкидає з ітерації всі елементи, для яких `expr` повертає `false`.

Кожний `for` вираз починається з генератора. Якщо є декілька генераторів в виразі `for`, пізніші генератори змінюються більш швидко, ніж ранішні. Ви можете просто це перевірити за допомогою наступного простого тесту:
[source,scala]
----
scala> for (x <- List(1, 2); y <- List("one", "two"))
        yield (x, y)
res3: List[(Int, String)] =
  List((1,one), (1,two), (2,one), (2,two))
----
23.2 Проблема N ферзів
----------------------
Особливо придатною областю застосування `for` виразів є комбінаторні головоломки. Прикладом такої головоломки є проблема 8-ми ферзів: маючи стандартну шахову дошку, розмістити вісім ферзів, так, щоб жодний не шахував іншого (ферзь шахує іншу фігуру, якщо стоїть на тому самому рядку, лінії або диагоналі). Щоб знайти рішення цієї проблеми, насправді легше узагальнити її для шахових дошок довільного розміру. Таким чином, проблема є розмістити N ферзів на шахівниці з `N x N` клітин, де розмір `N` довільний. Ми почнемо нумерування клітин з одного, так що верхня-ліва клітина на дошці `N x N` має координати `(1, 1)`, та нижня-права клітина має координати `(N, N)`.

Щоб вирішити проблему `N` ферзів, зауважте, що вам треба розмістити ферзя на кожному рядку. Так що ви можете ставити ферзів в послідовних рядках, кожний раз перевіряючи, що новий розміщений ферзь не шахується жодним іншим ферзем, що вже на дошці. По ходу цього пошуку, може статись, що ферзь, який треба поставити на рядок `k`, шахується у всіх полях цього рядка з ферзями на рядках від `1` до `k-1`. В цьому випадку вам треба перервати цю частину пошуку, щоб продовжити з іншою конфігурацією ферзів в стовпчиках від `1` до `k-1`.

Імперативне рішення цієї проблеми буде ставити ферзів один по одному, рухаючи їх по дошці. Але це виглядає складним запропонувати схему, що насправді спробує всі можливості. Більш функціональний підхід представляє рішення напряму, як значення. Рішення складається зі списку координат, по одній для кожного ферзя на дошці. Однак занотуйте, що повне рішення не може бути знайдене за один крок. Рішення має бути побудоване поступово, через захоплення послідовних рядків ферзями.

Це підказує рекурсивний алгоритм. Уявімо, що ви вже згенерували всі рішення, розмістивши  `k` ферзів на дошці розміром `N x N`, до `k` меньше ніж `N`. Кожне таке рішення може бути презентовано як список довжиною `k` координат `(row, column)`, де обидва, `row` та `column` є числами в диапазоні від `1` до `N`. Зручно розглядати ці часткові списки рішень як стеки, де координати ферзя на рядку `k` ідуть першими в списку, за яким ідуть координати ферзя в рядку `k-1`, і так далі. Знизу стека є координати ферзя, розміщеного на першому рядку дошки. Всі рішення разом представлені як список списків, з одним елементом для кожного ферзя.

Тепер, щоб поставити наступного ферзя в рядок `k+1`, згенеруйте всі можливі розширення кожного попереднього рішення ще на одного ферзя. Це дає інший список рішень, на цей раз довжини `k+1`. Продовжуйте процес доки ви не отримаєте всі рішення розміру шахівниці N.

Ця алгоритмична ідея втілена в функціональне `placeQueens` нижче:
[source,scala]
----
def queens(n: Int): List[List[(Int, Int)]] = {
  def placeQueens(k: Int): List[List[(Int, Int)]] =
    if (k == 0)
      List(List())
    else
      for {
        queens <- placeQueens(k - 1)
        column <- 1 to n
        queen = (k, column)
        if isSafe(queen, queens)
      } yield queen :: queens

  placeQueens(n)
}
----
Зовнішня функція `queens` в програмі вище просто викликає `placeQueens` з розміром дошки `n` в якості аргумента. Завдання функції `placeQueens(k)` є генерація всіх часткових рішень довжини `k` в списку. Кожний елемент списку є одним рішенням, представлений списком довжини `k`. Так що `placeQueens` повертає список списків.

Якщо параметр `k` до `placeQueens` є `0`, це означає, що треба згенерувати всі рішення, розмістивши нуль ферзів на нулі рядків. Існує тільки одне таке рішення: не розташовувати ферзів взагалі. Це рішення представлене порожнім списком. Так що якщо `k` є нуль,`placeQueens` повертає `List(List())`, список складається з єдиного елемента, що є порожнім списком. Зауважте, що це доволі відрізняється від порожнього списку `List()`.

Якщо `placeQueens` повертає `List()`, це означає відсутність рішень, замість єдиного рішення, що складається з відсутності розміщених ферзів.

В іншому випадку, коли `k` не нуль, вся робота `placeQueens` виконується в `for` виразі. Перший генератор цього `for` виразу ітерує по всіх рішеннях, розміщуючи `k - 1` ферзів на дошці. Другий генератор ітерує по всіх можливих стовпчиках, на яких може бути розміщений  `k`-тий ферзь. Третя частина `for` виразу визначає новітньо розглянуту позицію ферзя, що буде парою з рядка `k` та кожного стовпчика. Четверта частина виразу `for` є фільтром, що перевіряє за допомогою `isSafe`, чи новий ферзь є вільний від шаху всіма існуючими ферзями (визначення `isSafe` буде розглянута трохи пізніше).

Якщо новий ферзь не має шахів від жодного з інших ферзів,
він може формувати частину часткового рішення, так що `placeQueens` генерує нове рішення за допомогою `queen :: queens`. Якщо новий ферзь не вільний від шаху, фільтр повертає `false`, так що рішення не генерується.

Один фрагмент, що залишився, це метод `isSafe`, що використовується для перевірки, чи даний ферзь шахується любим іншим елементом в списку ферзів. Ось його визначення:
[source,scala]
----
def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =
  queens forall (q => !inCheck(queen, q))

def inCheck(q1: (Int, Int), q2: (Int, Int)) =
  q1._1 == q2._1 || // той самий рядок
  q1._2 == q2._2 || // той самий стовпчик
  (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // на диагоналі
----
Метод `isSafe` виражає, що ферзь безпечний у відношенні до інших ферзів, якщо він не шахується іншим ферзем. Метод `inCheck` виражає, що ферзі `q1` та `q2` взаємно шахуються. Він повертає `true` в одному з трьох випадків:

1. Якщо два ферзя мають ту саму координату рядка,
2. Якщо два ферзя мають ту саму координату стовбчика,
3. Якщо два ферзя на тій самій диагоналі (тобто, різниця між рядками і різниця між стовпчиками ті самі).

Перший випадок, коли два ферзя мають ту саму координату, не може трапитись в застосуванні, бо `placeQueens` вже потурбувався про розіщення кожного ферзя на окремому рядку. Так що ви можете видалити цю перевірку без зміни функціональності програми.

23.3 Запити за допомогою `for` виразів
--------------------------------------
Нотація `for` в основному еквівалентна до загальних операцій мови запитів бази даних. Наприклад, скажімо, ви отримали базу даних на ім'я `books`, що представлена як спикок нижок, де кожна книжка `Book` визначена наступним чином:
[source,scala]
----
case class Book(title: String, authors: String*)
----
Ось малий приклад бази даних, представленої як список в пам'яті:
[source,scala]
----
val books: List[Book] =
  List(
    Book(
      "Structure and Interpretation of Computer Programs",
      "Abelson, Harold", "Sussman, Gerald J."
    ),
    Book(
      "Principles of Compiler Design",
      "Aho, Alfred", "Ullman, Jeffrey"
    ),
    Book(
      "Programming in Modula-2",
      "Wirth, Niklaus"
    ),
    Book(
      "Elements of ML Programming",
      "Ullman, Jeffrey"
    ),
    Book(
      "The Java Language Specification", "Gosling, James",
      "Joy, Bill", "Steele, Guy", "Bracha, Gilad"
    )
  )
----  
Щоб знайти назви всіх книжок, в яких останнє ім'я автора починається з `"Gosling"`:
[source,scala]
----
scala> for (b <- books; a <- b.authors
            if a startsWith "Gosling")
       yield b.title
res4: List[String] = List(The Java Language Specification)
----
Або щоб знайти назви всіх книжок, що мають рядок `"Program"` в своїй назаві:
[source,scala]
----
scala> for (b <- books if (b.title indexOf "Program") >= 0)
       yield b.title
res5: List[String] = List(Structure and Interpretation of
  Computer Programs, Programming in Modula-2, Elements of ML
    Programming)
----
Або щоб знайти в базі даних імена всіх авторів, що написали щонайменьше дві книжки:
[source,scala]
----
scala> for (b1 <- books; b2 <- books if b1 != b2;
           a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
       yield a1
res6: List[String] = List(Ullman, Jeffrey, Ullman, Jeffrey)
----
Останнє рішення все ще недосконале, оскільки автори будуть з'являтись декілька разів в списку результатів. Вам все ще треба видалити дублікати авторів з отриманих списків. Це можливо досягти з наступною функцією:
[source,scala]
----
scala> def removeDuplicates[A](xs: List[A]): List[A] = {
         if (xs.isEmpty) xs
         else
           xs.head :: removeDuplicates(
             xs.tail filter (x => x != xs.head)
           )
       }
removeDuplicates: [A](xs: List[A])List[A]

scala> removeDuplicates(res6)
res7: List[String] = List(Ullman, Jeffrey)
----
Варто відзначити, що останній вираз в методі `removeDuplicates` може бути виражений еквівалентно з використанням виразу:
[source,scala]
----
xs.head :: removeDuplicates(
  for (x <- xs.tail if x != xs.head) yield x
)
----
23.4 Трансляція `for` виразів
-----------------------------
Кожний `for` вираз може бути виражений в термінах трьох функцій вищого порядку: `map`, `flatMap`, та `withFilter`. Цей розділ описує схему трансляції, що також використовується компілятором Scala.

Трансляція `for` виразів з одним генератором
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Перше, уявімо ви маєте простий вираз `for`:
[source,scala]
----
for (null <- expr_1) yield expr_2
----
де `x` є змінною. Такий вираз транслюється до:
[source,scala]
----
expr_1.map(null => expr_2)
----
Трансляція `for` виразів, що починаються з генератора та фільтра
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Тепер розглянемо `for` вираз, що комбінує лідируючий генератор з деякими іншими елементами.

Вираз `for` наступної форми:
[source,scala]
----
for (null <- expr_1 if expr_2) yield expr_3
----
транслюється до:
[source,scala]
----
for (null <- expr_1 withFilter (null => expr_2)) yield expr_3
----
Ця трансляція дає наступний вираз `for`, що на один елемент коротший, ніж оригінал, бо елемент `if` трансформується в застосування `withFilter` на першому виразі генератора. Трансформація потім продовжується з цім другим виразом, так що в кінці ми отримаємо:
[source,scala]
----
expr_1 withFilter (null => expr_2) map (null => expr_3)
----
Така сама схема трансляції також застосовується, якщо після фільтра ідуть інші елементи. Якщо `seq` є довільною послідовністю генераторів, визначень та фільтрів, тоді:
[source,scala]
----
for (null <- expr_1 if expr_2; seq) yield expr_3
----
транслюється до:
[source,scala]
----
for (null <- expr_1 withFilter expr_2; seq) yield expr_3
----
Потім трансляція продовжується з другим виразом, що знову коротший на один елемент, ніж оригінальний.

Трансляція `for` виразів починаючи з двох генераторів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Наступний випадок обробляє `for` вирази, що починаються з двох генераторів, як тут:
[source,scala]
----
for (null <- expr_1; null <- expr_2; seq) yield expr_3
----
Знову, будемо вважати, що `seq` є довільною послідовністю генераторів, визначень та фільтрів. Фактично, `seq` може також бути порожнім, і в такому випадку після `expr_2` крапка з комою непотрібні. Схема трансляції залишається такою самою в кожному випадку. Вираз `for` вище транслюється до застосування `flatMap`:
[source,scala]
----
expr_1.flatMap(null => for (null <- expr_2; seq) yield expr_3)
----
На цей раз існує інший вираз `for` в функціональному значенні, переданого до `flatMap`. Цей вираз `for` (що знову на елемент простіший, ніж оригінал) в свою чергу транслюється за тими самими правилами. Три схеми трансляції, надані перед цім, достатні для транслювання всіх виразів, що містять тільки генератори та фільтри, та де генератори прив'язують тільки прості змінні. Візьмемо, наприклад, запит: "Знайти всіх авторів, що опубліковали щонайменьше дві книги", з Розділу 23.3:
[source,scala]
----
for (b1 <- books; b2 <- books if b1 != b2;
  a1 <- b1.authors; a2 <- b2.authors if a1 == a2)
yield a1
----
Цей запит транслюється до наступної комбінації `map`/`flatMap`/`filter`:
[source,scala]
----
books flatMap (b1 =>
  books withFilter (b2 => b1 != b2) flatMap (b2 =>
    b1.authors flatMap (a1 =>
      b2.authors withFilter (a2 => a1 == a2) map (a2 =>
        a1))))
----
Представлена дотепер схама трансляції ще не обробляє генератори, які прикріплюють цілі шаблони, замість простих змінних. Вона також досі не покриває визначення. Ці два аспекта будуть пояснені в наступних двох підсекціях.

Трансляція шаблонів в генераторах
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Схема трансляції стає більш складна, якщо ліва сторона генератора є шаблоном `pat`, іншим, ніж проста змінна. Випадок, коли вираз `for` зв'язує тапл змінних, є все ще простим для обробки. В цьому випадку діє майже та сама схема, що застосовується для окремих змінних.

`for` вираз такої форми:
[source,scala]
----
for ((null, ..., null) <- expr_1) yield expr_2
----
транслюється до:
[source,scala]
----
expr_1.map { case (null, ..., null) => expr_2 }
----
Це стає трохи складнішим, якщо ліва сторона генератора є довільним шаблоном `pat`, замість окремої змінної або тапла.

В цьому випадку:
[source,scala]
----
for (pat <- expr_1) yield expr_2
----
транслюється до наступного:
[source,scala]
----
expr_1 withFilter {
  case pat => true
  case _ => false
} map {
  case pat => expr_2
}
----
Тобто згенеровані елементи зпочатку фільтруються, і тільки ті, що співпадають з `pat`, відзеркалюються. Таким чином гарантовано, що генератор зі співпадінням шаблонів, ніколи не закидатиме `MatchError`.

Тут схема трактує тільки випадок, коли вираз `for` містить один генератор співпадіння шаблону. Аналогічні правила також застосовуються, якщо вираз `for` містить інші герератори, фільтри та визначення. Оскільки ці додаткові правила не додають багато нового розуміння, вони виключені тут з дискусії. Якщо ви зацікавлені, ви можете пошукати їх в _Scala Language Specification_ [Ode11].

Трансляція визначень
~~~~~~~~~~~~~~~~~~~~
Остання відсутня ситуація, це коли `for` вираз містить вбудовані визначення. Ось типовий випадок:
[source,scala]
----
for (null <- expr_1; null = expr_2; seq) yield expr_3
----
Знову вважатимемо, що `seq` є (можливо порожньою) послідовністю генераторів, визначень та фільтрів. Цей вираз транслюється до такого:
[source,scala]
----
for ((null, null) <- for (null <- expr_1) yield (null, expr_2); seq)
yield expr_3
----
Як ви бачите, це `expr_2` обчислюється кожного разу, коли генерується нове значення `x`. Це пере-обчислення потрібне, оскільки `expr_2` може посилатись на `x`, так що має пере-обчислюватись для зміни значень `x`. Для вас, як для програміста, висносок в тому, що це, можливо, не є гарною ідеєю мати вбудовані визначення в `for` виразах, що не посилються на значення, прив'язані деяким попереднім генератором, оскільки пере-обчислення таких виразів буде марним. Наприклад, замість:
[source,scala]
----
for (x <- 1 to 1000; y = expensiveComputationNotInvolvingX)
yield x * y
----
звичайно краще записати:
[source,scala]
----
val y = expensiveComputationNotInvolvingX
for (x <- 1 to 1000) yield x * y
----
Транслювання `for` циклів
~~~~~~~~~~~~~~~~~~~~~~~~~
Попередні субсекції показали, як транслюються `for` вирази, що містять `yield`. Як щодо циклів, що просто виконують побічні ефекти без повернення будь-чого? Їх трансляція подібна, але простіша ніж для `for` виразів. В принципі, коли попередня схема трансляції вкористовували `map` або `flatMap` в трансляції, схема трансляції для `for` циклів використовує тільки `foreach`.

Наприклад, вираз:
[source,scala]
----
for (null <- expr_1) body 
----
транслюється до:
[source,scala]
----
expr_1 foreach (null => body)
----
Більшим прикладом є вираз:
[source,scala]
----
for (null <- expr_1; if expr_2; null <- expr_3) body
----
Цей вираз транслюється до:
[source,scala]
----
expr_1 withFilter (null => expr_2) foreach (null =>
expr_3 foreach (null => body))
----
Наприклад, наступний вираз підсумовує всі елементи матриці, що представлена як список списків:
[source,scala]
----
var sum = 0
for (xs <- xss; x <- xs) sum += x
----
Цей цикл танслюється в два вкладених застосувань `foreach`:
[source,scala]
----
var sum = 0
  xss foreach (xs =>
    xs foreach (x =>
      sum += x))
----
23.5 Заходячи з іншого боку
---------------------------
Попередній розділ показав, що вирази `for` можуть бути трансльовані в застосування функцій вищого порядку: `map`, `flatMap`, та `withFilter`. Фактично, однаково ви можете іти іншим шляхом: кожне застосування `map`, `flatMap`, або `filter` може бути представлене як `for` вираз.

Ось реалізації трьох методів в термінах `for` виразів. Методи, що містяться в об'єкті `Demo` для відмінносі їх від стандартних операцій з `List`. Щоб бути конкретним, всі три функції приймають `List` як параметр, але схема трансляції робить так само гарно і з іншими типами колекцій:
[source,scala]
----
object Demo {
  def map[A, B](xs: List[A], f: A => B): List[B] =
    for (x <- xs) yield f(x)
  
  def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =
    for (x <- xs; y <- f(x)) yield y

  def filter[A](xs: List[A], p: A => Boolean): List[A] =
    for (x <- xs if p(x)) yield x
}
----
Не дивно, що трансляція `for` виразу, використана в тілі `Demo.map`, буде продукувати виклик до `map` в класі `List`. Подібним чином, `Demo.flatMap` та `Demo.filter` транслюються до `flatMap` та `withFilter` в класі `List`. Так що ця мала демонстрація показує, що `for` вирази еквівалентні по своїй виразності до застосування трьох функцій: `map`, `flatMap`, `withFilter`.

23.6 Узагальнюючи `for`
-----------------------
Оскільки трансляція `for` виразів покладається тільки на присутність методів `map`, `flatMap`, та `withFilter`, можливо застосувати `for` нотацію до широкого класу типів даних.

Ви вже бачили `for` вирази на списках та масивах. Вони підтримуються, тому що списки, так само, як масиви, визначають операції `map`, `flatMap` та `withFilter`. Оскільки вони визначають також метод `foreach`, також можливі цикли `for` по ціх типах даних.

Окрім списків та масивів, існує багато інших типів в стандартній бібліотеці Scala, які підтримують ті самі чотири методи, і, таким чином, дозволяють `for` вирази. Прикладами є диапазони, ітератори, потокі, і всі реалізації множин. Також чудово можливо для ваших власних типів даних підтримувати `for` вирази, через визначення потрібних методів. Для підтримки повного диапазону `for` виразів та `for` циклів, вам треба визначити `map`, `flatMap`, `withFilter`, та `foreach` як методи вашого типу даних. Але також можливо визначити підмножину ціх методів, і таким чином підтримати підмножину всіх можливих `for` виразів або циклів.

Ось точні правила:
* Якщо ваш тип визначає `map`, він дозволяє `for` виразам складатись з одного генератора.
* Якщо він визначає `flatMap` разом з `map`, це дозволяє `for` виразам складатись з декількох генераторів.
* Якщо він визначає `foreach`, він дозволяє цикли `for` (обоє, з одним та декількома генераторами).
* Якщо він визначає `withFilter`, він дозволяє вирази фільтрів, що починаються з `if` в `for` виразах.

Трансляція `for` виразів відбувається перед перевіркою типів. Це дозволяє максимальну гнучкість, оскільки єдиною вимогою є те, щоб результат розширення `for` виразу проходив перевірку типів. Scala не визначає правил типів для самих `for` виразів, та не потребує, щоб методи `map`, `flatMap`, `withFilter`, або `foreach` мали любу окрему сигнатуру типів.

Тим не менше, існує типове налаштування, що захоплює найбільш загальні наміри методів вищого порядку, до яких тринслюється `for` вираз. Скажімо, ви маєте параметризований клас `C`, що типово буде стояти за деяким типом колекції. Тоді досить природно обрати наступні сигнатури типу для `map`, `flatMap`, `withFilter`, та `foreach`:
[source,scala]
----
abstract class C[A] {
  def map[B](f: A => B): C[B]
  def flatMap[B](f: A => C[B]): C[B]
  def withFilter(p: A => Boolean): C[A]
  def foreach(b: A => Unit): Unit
}
----
Тобто, функція `map` приймає функцію від типу елементу колекції `A` до якось іншого типу `B`. Він продукує нову колекцію того ж типу, що і `C`, але з `B` в якості типу елементів. Метод `flatMap` приймає функцію `f` від `A` до деякої `C`-колекції з `B`, та продукує `C`-колекцію з `B`. Метод `withFilter` приймає функцію предикат від типу елементів колекції `A` до `Boolean`. Він продукує колекцію того самого типу, на якому він викликаний. Нарешті, метод `foreach` приймає функцію від `A` до `Unit`, та продукує результат `Unit`:

В класі `C` вище, метод `withFilter` продукує нову колекцію того самого класу. Це означає, що кожний виклик `withFilter` створює новий об'єкт `C`, так само, як має робити фільтр. Тепер, в трансляції `for` виразів, любі виклики до `withFilter` завжди закінчаться викликом до одного з трьох інших методів. Таким чином, об'єкт, створений `withFilter` буде розібраний по частинах одним з інших методів безпосередньо після цього. Якщо об'єкти класу `C` великі (подумайте про великі послідовності), ви можете побажати уникнути створення такого проміжного об'єкту. Стандартним прийомом є дозволити `withFilter` повертати на об'єкт `C`, але тільки об'єкт огортку, що "пам'ятає", що елементи треба відсортувати перед подальшою обробкою.

Концентруючись на трьох перших функціях класу `C` слід зауважити наступні факти. В функціональному програмуванні існує загальна концепція з назвою _монада_, що може пояснювати велике число типів з обчисленнями, від колекцій до обчислень зі станом та I/O, обчислення зворотнього виводу та транзакції, як для прикладу. Ви можете формулювати функції `map`, `flatMap`, та `withFilter` на монаді, та, якщо ви зробите це, вони в підсумку матимуть точно вказані тут типи.

Більше того, ви можете характеризувати кожну монаду через `map`, `flatMap`, та `withFilter`, плюс "юніт" конструктор, що продукує монаду зі значення елемента. В об'єктно-орієнтовній мові цей "юніт" є простим конструктором примірника, або методом фабрики. Таким чином на `map`, `flatMap`, та `withFilter` можна дивитись як на об'єктно-орієнтовну версію функціональної концепції монади. Оскільки `for` вирази еквівалентні до застосувань ціх трьох методів, вони можуть розглядатись як синтаксис для монад.

Все це натякає, що концепція `for` виразів більш загальна, ніж проста ітерація по колекції, і це дійсно так. Наприклад, `for` вирази також відіграють важливу роль в асинхронному I/O, або як альтернативна нотація для опціональних значень. Шукайте в бібліотеках Scala де зустрічаються `map`, `flatMap`, та `withFilter` — коли вони присутні, `for` вирази запропонують себе самі, як стислий спосіб маніпуляції елементами цього типу.

23.7 Висновок
-------------
В цій главі ви отримали можливість заглянути з лаштунки виразів `for` та циклів `for`. Ви вивчили, що вони транслюються в застосування стандартного набору методів вищого порядку. Як результат, ви побачили, що `for` вирази насправді значно більш загальні, ніж прості ітерації по колекціях, і що ви можете розробляти ваші власні класи для їх підтримки.