<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__10">Глава 10</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Композиція та наслідування</h1>
<div class="paragraph"><p>Глава 6 вводить деякі базові об'єктно-орієнтовні аспекти Scala. Ця глава підхоплює там, де полишила Глава 6, та занурюється в підтримку в Scala об'єктно-орієнтовного програмування в значно більших деталях. Ми будемо порівнювати два фундаментальні співвідношення між класами: композицію та наслідування. Композиція означає, що один клас зберігає посилання на інший, використовуючи цей клас для допомоги в виконанні своєї міссії. Наслідування є відношенням суперклас/субклас. На додаток до ціх тем, ми будемо обговорювати абстрактні класи, методи без параметрів, розширення класів, перекриття методів та полів, параметрічні поля, виклик конструкторів суперкласу, поліморфізм та динамічна прив'язка, фінальні члени та класи, та об'єкти та методи фабрик.</p></div>
<div class="sect1">
<h2 id="_10_1___">10.1 Бібліотека двохмірного розташування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як робочий приклад в цій главі ми створимо бібліотеку для побудови та відображення прямокутника, заповненого текстом. Для зручності бібліотека буде провадити методи фабрики на ім'я <code>elem</code>, що конструює елементи з переданих даних. Наприклад, ви будете в змозі створити елемент розташування, що містить рядок, використовуючи метод фабрики з наступною сігнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, елементи будуть змодельовані за допомогою типу на ім'я <code>Element</code>. Ви зможете викликати <code>above</code> або <code>beside</code> на <code>element</code>, передаючи другий елемент, щоб створити новий елемент, який є комбінацією двох. Наприклад, наступний вираз буде конструювати більший елемент, що складається з двох колонок, кожна висотою 2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">column1</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="n">above</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;***&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">column2</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;***&quot;</span><span class="o">)</span> <span class="n">above</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">)</span>
<span class="n">column1</span> <span class="n">beside</span> <span class="n">column2</span>
</pre></div></div></div>
<div class="paragraph"><p>Друк результате цього виразу буде давати вам таке:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hello ***
*** world</code></pre>
</div></div>
<div class="paragraph"><p>Елементи розташування є гарним прикладом системи, в якій об'єкти можуть бути сконструйовані з простих частин за допомогою оераторів композиції. В цій главі ми будемо визначати класи, що дозволять конструювання об'єктів-елементів з масивів, ліній та прямокутників. Ці базові об'єкти елементів будуть простими частинами. Ми також визначимо операції композиції <code>above</code> та <code>beside</code>. Такі компонуючі оператори також часто називають <em>комбінаторами</em>, оскікльи вони комбінують елементи в деякій галузі в нові елементи.</p></div>
<div class="paragraph"><p>Думаючи в термінах комбінаторів загалом гарний підхід розробки бібліотеки: це відплачується - думати про фундаментальні шляхи конструювання об'єктів в домені застосування. Що таке прості об'єкти? В який спосіб найбільш цікаві об'єкти можуть бути сконструйовані з простіших? Як комбінатори поводяться разом? Які комбінатори найбільш загальні? Чи вони задовільняють цікавим законам? Якщо ви маєте гарні відповіді на ці запитання, розробка вашої бібліотеки на вірному шляху.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_2__">10.2 Абстрактні класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наше перше завдання є визначити тип <code>Element</code>, що предаставляє елементи розташування. Оскільки елементи є двохвимірні прямокутники символів, має сенс включити член <code>contents</code>, що посалається на вміст елемента розташування. Цей <code>contents</code> може бути представлений як масив рядків, до кожний рядок представляє лінію. Таким чином, тип результата, що повертається <code>contents</code> буде <code>Array[String]</code>. Лістинг 10.1 показує, як це буде виглядати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.1 - Визначення абстрактного метода та класа.</p></div>
<div class="paragraph"><p>В цьому класі <code>contents</code> декларовано як метод, що не має реалізації. Іншими словами, метод є абстрактним членом класа <code>Element</code>. Клас з абстрактинми методами має сам бути визначений як абстрактний, що робиться додаванням модифікатора <code>abstract</code> перед ключовим словом <code>class</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>abstract</code> означає, що клас може мати абстрактні члени, що не мають реалізації. Як результат, ви не можете створити примірник абстрактного класу. Якщо ви спробуєте зробити це, ви отримаєте помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Element</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Element</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span>
    <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span>
       <span class="k">new</span> <span class="nc">Element</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Пізніше в цій главі ви побачите, як створити субкласи класа <code>Element</code>, для яких ви будете в змозі створити примірники, оскільки вони заповнюють відсутнє визначення дла <code>contents</code>.</p></div>
<div class="paragraph"><p>Зауважте, що метод <code>contents</code> в класі <code>Element</code> не має модифікатора <code>abstract</code>. Метод є абстрактним, якщо він не має реалізації (тобто знака рівності або тіла). На відміну від Java, для декларацій методів модифікатор <code>abstract</code> не потрібен (та не дозволений). Методи, що мають реалізцію, називаються <em>суцільними</em>.</p></div>
<div class="paragraph"><p>Інша частка термінології відрізняє декларації та визначення. Клас <code>Element</code> <em>декларує</em> абстрактний метод <code>contents</code>, але наразі не <em>визначає</em> конкретинх методів. Однак в наступному розділі ми розширимо <code>Element</code>, визначаючи деякі суцільні методи.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_3____">10.3 Визначення методів без параметрів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми додамо методи до <code>Element</code>, що з'ясовують його ширину та довжину, як показано в Лістингу 10.2. Метод <code>height</code> повертає число рядків в <code>contents</code>. Метод <code>width</code> повертає довжину першого рядка, або повертає нуль, якщо в елементі немає нічого. (Це означає, що ви не можете визначити елемент з висотою нуль, та ненульовою шириною.)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.2 - Визначення методів без параметрів, <code>width</code> та <code>height</code>.</p></div>
<div class="paragraph"><p>Зауважте, що жодний з трьох методів <code>Element</code> не має списку параметрів, навіть порожнього. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">width</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>метод визначений без дужок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Такі <em>безпараметричні</em> методи є досить загальними в Scala. На відміну, методи, визначені з порожніми дужками, такі як <code>def height(): Int</code>, називаються <em>методами з порожніми дужками</em>. Рекомендована домовленість є використовувати безпараметричні методи, коли немає параметрів, і метод отримує доступ до змінного стану тільки через читання полів містячого об'єкта (зокрема, він не змінює змінний стан). Ця домовленість підтримує принцип уніфіормного доступу,<span class="footnote"><br />[Meyer, Object-Oriented Software Construction [Mey00]]<br /></span> який каже, що клієнтський код не має зазнати впливу від рішення реалізувати атрибут як поле або метод.</p></div>
<div class="paragraph"><p>Наприклад, ми можемо реалізувати <code>width</code> та <code>height</code> елемента як поля, замість методів, просто змінивши <code>def</code> в кожному визначенні на <code>val</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">height</span> <span class="k">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">val</span> <span class="n">width</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дві пари визначень повністю еквівалентні з клієнтської точки зору. Єдине що відрізняється, це те, що доступ до поля може бути трохи швидший, ніж виклик метода, оскільки значення полів попередньо обчислені при ініціалізації класа, замість бути обчислені при кожному виклику метода. З іншого боку, поля потребують додаткового простору в пам'яті в кожному елементі <code>Element</code>. Так що це залежить від профілю використання класа, чи атрибут краще представляти як поле чи метод, і цей профіль використання може змінитись з часом. Суть в тому, що клієнти класа <code>Element</code> не мають зазнати впливу, коли змінюється внутрішнє представлення.</p></div>
<div class="paragraph"><p>Зокрема, клієнт класу <code>Element</code> не має бути переписаний, якщо поле цього класа буде змінено на функцію доступу, доки ця функція є чистою (тобто вона не має жодних побічних ефектів, та не залежить від змінного стану). Клієнт не має турбуватись в жодному випадку.</p></div>
<div class="paragraph"><p>Доки все гарно. Але все ще є невелике ускладнення, що має справу з тим, як Java обробляє речі. Проблема в тому, що Java не реалізує принцип уніформного доступу. Так що існує <code>string.length()</code> в Java, не <code>string.length</code>, навіть якщо <code>array.length</code>, не <code>array.length()</code>. Нічого і казати, що це дуже бентежить.</p></div>
<div class="paragraph"><p>Щоб полатати цю дірку, Scala є дуже ліберальною, коли доходить до міксування безпараметричних методів, та методів з порожніми дужками. Зокрема, ви можете перекрити безпараметричні методи методом порожніх дужок, та навпаки. Ви також можете відкинути порожні дужки при виклику функції, що не приймає аргументів. Наприклад, наступні два рядка обоє є легальними в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">toString</span>
<span class="s">&quot;abc&quot;</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>В принципі можливо відкинути всі порожні дужки в викликах функцій Scala. Однак все ще рекомендовано писати порожні дужки, коли викликаний метод представляє більше ніж властивість об'єкта отримувача. Наприклад, порожні дужки на місці, коли метод виконує I/O, записує переприсвоювані змінні (<code>var</code>), або читає <code>var</code> окрім полів отримувача, прямо або непрямо через використання змінних об'єктів. Таким чином, список параметрів діє як візуальна підказка, що виклик запускає деякі цікаві обчислення. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;hello&quot;</span><span class="o">.</span><span class="n">length</span> <span class="c1">// немає (), бо немає побічних ефектів</span>
<span class="n">println</span><span class="o">()</span> <span class="c1">// краще не відкидати ()</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб підсумувати, в Scala заохочується визначати методи, що не приймають параметрів, та не мають побічних ефектів, як безпараметричні методи (тобто відкидаючи порожні дужки). З іншого боку, вам ніколи не слід визначати метод, що має побічні ефекти, без дужок, оскільки виклики цього метода потім будуть виглядати як вибір поля. Так що ваші клієнти можуть бути здивовані, коли побачать побічні ефекти.</p></div>
<div class="paragraph"><p>Подібним чином, коли ви викликаєте функцію, що має побічний ефект, переконайтесь, що коли писали виклик включили порожні дужки. Інший спосіб думати про це: коли функція, що ви викликаєте, виконує операцію, використовуйте дужки. Але якщо вона просто провадить доступ до властивості, прибирайте дужки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_4__">10.4 Розширення класів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нам все ще треба бути в змозі створювати нові об'єкти елементів. Ви вже бачили, що <code>new Element</code> не може бути використаний для цього, оскільки <code>Element</code> є абстрактним. Таким чином, щоб створити примірник елемента, нам треба створити субклас, що розширює <code>Element</code>, та реалізує абстрактний метод <code>contents</code>. Лістинг 10.3 показує можливий спосіб зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.3 - Визначення <code>ArrayElement</code> як субкласа <code>Element</code>.</p></div>
<div class="paragraph"><p>Клас <code>ArrayElement</code> визначений для розширення класу <code>Element</code>. Так само, як в Java, ви використовуєте твердження <code>extends</code> після імені класу, щоб виразити цей факт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Малюнок 10.1 - Діаграма класів для <code>ArrayElement</code>.</p></div>
<div class="paragraph"><p>Таке твердження <code>extends</code> має два ефекти: це дає класу <code>ArrayElement</code> наслідувати всі неприватні члени від класу <code>Element</code>, та це робить тип <code>ArrayElement</code> субтипом типу <code>Element</code>. Зважаючи що <code>ArrayElement</code> розширює <code>Element</code>, клас <code>ArrayElement</code> називається субкласом класу <code>Element</code>. І навпаки, <code>Element</code> є суперкласом <code>ArrayElement</code>. Якщо ви приберете твердження <code>extends</code>, компілятор Scala неявно вважатиме, що ваш клас розширює <code>scala.AnyRef</code>, що на Java платформі є те саме, що і клас <code>java.lang.Object</code>. Таким чином, клас <code>Element</code> неявно розширює клас <code>AnyRef</code>. Ви можете бачити ці відношення наслідування на Малюнку 10.1.</p></div>
<div class="paragraph"><p>Наслідування означає, що всі члени суперкласа також є членами субкласу, з двома виключеннями. Перше, приватні члени суперкласу не наслідуються в субкласі. Друге, члени суперкласа не наслідуються, якщо член з таким же ім'ям та параметрами вже реалізовані в субкласі. В такому випадку ми кажемо, що субклас <em>перекриває</em> член в суперкласі. Якщо член субкласу є суцільним, та член суперкласу є абстрактним, ми також кажемо, що суцільний член реалізує абстрактний.</p></div>
<div class="paragraph"><p>Наприклад, метод <code>contents</code> в <code>ArrayElement</code> перекриває (або, альтернативно, реалізує) абстрактний метод <code>contents</code> в класі <code>Element</code>.<span class="footnote"><br />[Одна проріха в цьому дизайні в тому, що оскільки повернутий масив є змінним, клієнти можуть змінити його. Для книжки ми будемо підтримувати речі простими, але коли <code>ArrayElement</code> є частиною реального проекта, ви можете розглянути можливість повертати захисну копію масива замість цього. Інша проблема полягає в тому, що ми досі не переконались, що кожний елемент <code>String</code> масиву  <code>contents</code> має ту саму довжину. Це може бути вирішене через перевірку передумови в первинному конструкторі, за закиданні виключення, якщо вона порушується.]<br /></span> Для контрасту, клас <code>ArrayElement</code> наслідує методи <code>width</code> та <code>height</code> від класа <code>Element</code>. Наприклад, маючи <code>ArrayElement ae</code>, ви можете запитати його <code>width</code> використовуючи <code>ae.width</code>, так, якби <code>width</code> було визначене в класі <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ae</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">))</span>
<span class="n">ae</span><span class="k">:</span> <span class="kt">ArrayElement</span> <span class="o">=</span> <span class="nc">ArrayElement</span><span class="k">@</span><span class="mi">39274</span><span class="n">bf7</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ae</span><span class="o">.</span><span class="n">width</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p>Створення субтипів означає, що значення субкласу може бути використане, коли потрібне значення суперкласу. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна <code>e</code> визначена як тип <code>Element</code>, так що його значення ініціалізації також має бути <code>Element</code>. Фактично, значення ініціалізації є <code>ArrayElement</code>. Це OK, оскільки клас <code>ArrayElement</code> розширює клас <code>Element</code>, і як результат, тип <code>ArrayElement</code> сумісний з типом <code>Element</code>.<span class="footnote"><br />[Для додаткової перспективи на різницю між суперкласом та субкласом дивіться входження глассарію щодо субтипів.]<br /></span></p></div>
<div class="paragraph"><p>Малюнок 10.1 також показує порівняння відношень, що існують між <code>ArrayElement</code> та <code>Array[String]</code>. Це відношення називається композицією, та  клас <code>ArrayElement</code> є "скомпонований" з класу <code>Array[String]</code>, тому що компілятор Scala буде покладати в двійниковий клас, що він генерує для <code>ArrayElement</code>, поле, що містить посилання на переданий масив <code>conts</code>. Ми обговоримо деякі рішення дизайну композиції та наслідування далі в цій главі, в Розділі 10.11.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_5____">10.5 Перекриття методів та полей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Принцип уніформного доступу є тільки одним аспектом, коли Scala розглядає поля та методи в більш уніформний спосіб, ніж Java. Інша різниця в тому, що в Scala поля та методи належать до того самого простору імен. Це робить можливим для поля перекривати метод без параметрів. Наприклад, ви можете змінити реалізацію <code>contents</code> в класі <code>ArrayElement</code> з метода на поле, без модифікації визначення абстрактного метода <code>contents</code> в класі <code>Element</code>, як показано в Лістингу 10.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.4 - Перекриття метода без параметрів за допомогою поля.</p></div>
<div class="paragraph"><p>Поле <code>contents</code> (визначене як <code>val</code>) в цій версії <code>ArrayElement</code> є чудово гарною реалізацією метода без параметрів <code>contents</code> (декларований за допомогою <code>def</code>) в класі <code>Element</code>. З іншої сторони, в Scala заборонено визначати поле та метод з тим самим ім'ям в тому самому класі, хоча це дозволено в Java.</p></div>
<div class="paragraph"><p>Наприклад, цей Java клас буде чудово компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="kd">class</span> <span class="nc">CompilesFine</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але відповідний клас Scala не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WontCompile</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// Не буде компілюватись, оскільки поле</span>
  <span class="k">def</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">1</span>         <span class="c1">// та метод мають те саме ім&#39;я</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Загалом, Scala має лише два простору імен для визначень, на відміну від чотирьох в Java. Чотири простори імен в Java є поля, методи, типи та пакунки. На відміну в Scala лише два простори імен:</p></div>
<div class="ulist"><ul>
<li>
<p>
значення (поля, методи, пакунки та об'єкти синглтони)
</p>
</li>
<li>
<p>
types (імена класів та трейтів)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Причина, з якої Scala покладає поля та методи в той самий простір імен в точності та, щоб ви могли перекривати методи без параметірв за допомогою <code>val</code>, дещо, чого ви не можете робити в Java.<span class="footnote"><br />[Причина, з якої в Scala пакунки подіяють той самий простір імен, що поля і методи - бо це дозволяє вам імпортувати пакунки (на додаток до тільки імен типів) та поля і методи об'єктів синглтонів. Це знову дещо, чого ви не можете в Java. Це буде описане в Розділі 13.3.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_6___">10.6 Визначення параметричних полів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знову розглянемо визначення класу <code>ArrayElement</code>, показану в попередній главі. Він мав параметр <code>conts</code>, чиє єдине призначення є бути скопійованим в поле <code>contents</code>. Ім'я параметра <code>conts</code> було обране саме так, щоб воно могло виглядати подібно до імені поля  <code>contents</code>, насправді не перетинаючись з ним. Це "сморід коду," ознака, що може бути непотрібна надмірність або повторення у вашому коді.</p></div>
<div class="paragraph"><p>Ви можете уникнути сморіду коду, комбінуючи параметр та поле в одному визначенні параметричного коду, як показано в Лістингу 10.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.5 - Визначення <code>contents</code> як параметричного поля.</p></div>
<div class="paragraph"><p>Зауважте, що тепер параметр <code>contents</code> має перед собою <code>val</code>. Це скорочення, що одночасно визначеє параметр та поле з тим самим полем. Зокрема, клас <code>ArrayElement</code> тепер має (неперепризначуване) поле <code>contents</code>, до якого можна отримати з поза меж класу. Поле ініціалізоване значенням параметру. Це так, якби клас був написаний наступним чином, де <code>x123</code> є довільним свіжим ім'ям для параметру:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">x123</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">x123</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Також ви можете перед параметром класу поставити <code>var</code>, в якому випадку відповідне поле буде переприсвоюване. Нарешті, можливо додати модифікатори, такі як <code>private</code>, <code>protected</code>,<span class="footnote"><br />[Модифікатор <code>protected</code>, що надає доступ до субкласів, буде розкритий в деталях в Главі 13.]<br /></span> або <code>override</code> до ціх параметричних полів, так само, як ви можете зробити для любих інших членів методів. Наприклад, розгляньте визначення наступних класів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cat</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">dangerous</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Tiger</span> <span class="o">(</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">dangerous</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Cat</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначення <code>Tiger</code> є скороченням для наступного альтернативного визначення класу, з перекриттям члена <code>dangerous</code> та приватним членом <code>age</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tiger</span><span class="o">(</span><span class="n">param1</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">param2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Cat</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">dangerous</span> <span class="k">=</span> <span class="n">param1</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">age</span> <span class="k">=</span> <span class="n">param2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Обоє члени ініціалізовані від відповідних парамтрів. Ми довільно обираємо імена для ціх параметрів, <code>param1</code> та <code>param2</code>. Важлива річ була щоб вони не перетинались з іншими іменами в полі зору.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_7___">10.7 Виклик конструкторів суперкласу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви маєте повну систему, що складається з двох класів: абстрактного класу <code>Element</code>, що розширений суцільним класом <code>ArrayElement</code>. Ви можете також уявити собі для вираження елемента. Наприклад, клієнти можуть виявити бажання створити елемент розташування, що складається з однієї лінії, взятої як рядок. Об'єктно-орієнтовне програмування робить простим розширення системи за допомогою нових варіантів даних. Ви можете просто додавати субкласі. Наприклад, Лістинг 10.6 показує клас <code>LineElement</code>, що поширює <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.6 - Викликання конструктора суперкласа.</p></div>
<div class="paragraph"><p>Оскікльи <code>LineElement</code> розширює <code>ArrayElement</code>, та конструктор <code>ArrayElement</code> приймає параметр (<code>Array[String]</code>), <code>LineElement</code> потребує передати аргумент до первинного конструктора його суперкласу. Щоб викликати конструктор суперкласу, ви просто покладаєте аргумент або аргументи, що ви бажаєте передати, в дужках, що слідують за ім'ям суперкласу. Наприклад, клас <code>LineElement</code> передає <code>Array(s)</code> до первинного конструктора <code>ArrayElement</code>, покладаючи в його в дужки після імені суперкласа <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>З новим субкласом ієрархія наслідування для елементів розташування зараз виглядає, як показано на Малюнку 10.2.</p></div>
<div class="paragraph"><p>Малюнок 10.2 - Діаграма класів для <code>LineElement</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_8___override">10.8 Використання модифікатора override</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зауважте, що визначення <code>width</code> та <code>height</code> в <code>LineElement</code> має модифікатор <code>override</code>. В розділі 6.3 ви бачили цей модифікатор в визначенні метода <code>toString</code>. Scala потребує такого модифікатора для всіх членів, що перекривають суцільний метод в батьківському класі. Модифікатор є опціональним, якщо член реалізує абстрактний член з тим самим ім'ям. Модифікатор заборонений, якщо член не перекриває або не реалізує деякий член в базовому класі. Оскільки <code>height</code> та <code>width</code> в класі <code>LineElement</code> перекривають суцільні визначення в класі <code>Element</code>, <code>override</code> є обов'язковим.</p></div>
<div class="paragraph"><p>Це правило провадить корисну інформацію для компілятора, що допомагає уникати деяких складних для відлову помилок, та робить еволюцію безпечнішою. Наприклад, якщо ви випадково невірно назвали метод, або випадково дали йому інший список параметрів, компілятор відповість повідомленням про помилку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="nc">LineElement</span><span class="o">.</span><span class="n">scala</span>
<span class="o">.../</span><span class="nc">LineElement</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">50</span><span class="kt">:</span>
<span class="n">error</span><span class="k">:</span> <span class="kt">method</span> <span class="kt">hight</span> <span class="kt">overrides</span> <span class="kt">nothing</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hight</span> <span class="k">=</span> <span class="mi">1</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Домовленість перекриття навіть більше важливе, коли доходить до еволюції системи. Скажімо, ви визначаєте бібліотеку з методів малювання 2D. Ви зробили її публічно доступною, та вона широко уживана. В наступній версії бібліотеки ви бажаєте додати до вашого базового класа <code>Shape</code> новий метод з такою сигнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">hidden</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>Ваш новий метод буде використовуватись в різних методах малювання, щоб визначити, чи треба малювати фігуру. Це може призвести до значного прискорення, але ви не можете зробити це без ризику поламати клієнтській код. Кінець кінцем, клієнт міг вже визначити субклас <code>Shape</code> з іншою реалізацією <code>hidden</code>. Можливо, клієнській метод насправді робить отримуючий об'єкт зникаючим, замість перевіряти, чи об'єкт прихований. Оскільки дві версії <code>hidden</code> перекривають один одний, ваші методи малювання скінчать тим, що робитимуть об'єкти знікаючими, що напевне не те, чого ви бажаєте!</p></div>
<div class="paragraph"><p>Ці "випадкові перекриття" є найбільш загальною маніфестацією того, що називається проблемою "крихких базових класів". Проблема в тому, що якщо ви додаєте нові члени до базових класів (які ми звичайно називаємо суперкласами) в ієрархії класів, ми ризикуємо зламати клієнтській код. Scala не може повністю вирішити проблему крихкіх базових класів, але він покращує ситуацію, порівняно з Java.<span class="footnote"><br />[В Java 1.5 була введена анотація <code>@Override</code>, що робить подібно до модифікатор Scala <code>override</code>, але на відміну від Scala <code>override</code>, це не вимагається.]<br /></span> Якщо бібліотека малювання та її клієнти були написані на Scala, тоді оригінальна клієнтська реалізація <code>hidden</code> не може мати модифікатора  <code>override</code>, оскільки на той час немає іншого метода з цім ім'ям.</p></div>
<div class="paragraph"><p>Як тільки ви додасте метод <code>hidden</code> до другої версії вашого класу фігури, перекомпіляція клієнта буде давати помилку, подібну до наступної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">.../</span><span class="nc">Shapes</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">error</span> <span class="kt">overriding</span> <span class="kt">method</span>
     <span class="n">hidden</span> <span class="n">in</span> <span class="k">class</span> <span class="nc">Shape</span> <span class="n">of</span> <span class="k">type</span> <span class="o">()</span><span class="kt">Boolean</span><span class="o">;</span>
<span class="n">method</span> <span class="n">hidden</span> <span class="n">needs</span> <span class="err">`</span><span class="k">override</span><span class="err">&#39;</span> <span class="n">modifier</span>
<span class="k">def</span> <span class="n">hidden</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, замість помилкової поведінки ваш клієнт отримає помилку часу компіляції, що, зазвичай, значно краще.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_9_____">10.9 Поліморфізм та динамічне зв'язування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви бачили в Розділі 10.4, що змінна типу <code>Element</code> може посилатись на об'єкт типу <code>ArrayElement</code>. Ім'я цього феномену є <em>поліморфізм</em>, що означає "багато форм". В цьому випадку, об'єкти <code>Element</code> можуть мати багато форм.<span class="footnote"><br />[Цей різновид поліморфізму називається поліморфізмом субтипізації. Інший різновид поліморфізму в Scala називається універсальним поліморфізмом, та обговорюється в Главі 19.]<br /></span></p></div>
<div class="paragraph"><p>Доки ви бачили дві такі форми: <code>ArrayElement</code> та <code>LineElement</code>. Ви можете створити більше форм <code>Element</code>, через визначення нових субкласів <code>Element</code>. Наприклад, ви можете визначити нову форму <code>Element</code>, що має задані ширину та довжину, та повністю заповнений наданим символом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UniformElement</span><span class="o">(</span>
  <span class="n">ch</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">toString</span> <span class="o">*</span> <span class="n">width</span>
  <span class="k">def</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">height</span><span class="o">)(</span><span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ієрархія наслідування для класа <code>Element</code> тепер виглядає як показано на Малюнку 10.3. Як результат, Scala буде приймати всі наступні присвоєння, оскільки тип присвоюваних виразів відповідає до типу визначенної змінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">e1</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">))</span>
<span class="k">val</span> <span class="n">ae</span><span class="k">:</span> <span class="kt">ArrayElement</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LineElement</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="n">ae</span>
<span class="k">val</span> <span class="n">e3</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UniformElement</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви перевірите ієрархію наслідування, ви знайдете, що для кожного з ціх чотирьох визначень <code>val</code>, тип виразу зправа від знаку рівності нижче типу <code>val</code>, що ініціалізується зліва знаку рівності.</p></div>
<div class="paragraph"><p>Малюнок 10.3 - Ієрархія класу елементів розташування.</p></div>
<div class="paragraph"><p>Однак друга частина історії в тому, що виклики ціх методів не змінній і виразах зв'язані динамічно. Це означає, що справжня реалізація метода визначається під час виконання, на основі класу об'єкта, не на основі типу змінної або виразу. Щоб продемонструвати цю поведінку, ми тимчасово видалимо всі існуючі члени з нашого класу <code>Element</code>, та додамо в <code>Element</code> метод з назвою <code>demo</code>. Ми перекриємо <code>demo</code> в <code>ArrayElement</code> та <code>LineElement</code>, але не в <code>UniformElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Element&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ArrayElement</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;ArrayElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">LineElement</span> <span class="k">extends</span> <span class="nc">ArrayElement</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;LineElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// UniformElement наслідує demo від Element</span>
<span class="k">class</span> <span class="nc">UniformElement</span> <span class="k">extends</span> <span class="nc">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви введете цей код в інтерпретатор, потім ви можете визначитицей метод, що приймає <code>Element</code>, та викликає на ньому <code>demo</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="n">demo</span><span class="o">()</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви передасте <code>ArrayElement</code> до <code>invokeDemo</code>, ви побачите повідомлення, що вказує, що була викликана реалізація demo з ArrayElement, навіть хоча тип змінної <code>e</code>, на якому викликається demo, є <code>Element</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">)</span>
<span class="nc">ArrayElement</span><span class=" -Symbol">&#39;s</span> <span class="n">implementation</span> <span class="n">invoked</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, якщо ви передасте <code>LineElement</code> до <code>invokeDemo</code>, ви побачите повідомлення, що вказує, що була викликана реалізація <code>demo</code> з <code>LineElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="k">new</span> <span class="nc">LineElement</span><span class="o">)</span>
<span class="nc">LineElement</span><span class=" -Symbol">&#39;s</span> <span class="n">implementation</span> <span class="n">invoked</span>
</pre></div></div></div>
<div class="paragraph"><p>Поведінка коли передається <code>UniformElement</code> може зпочатку виглядати підозрілою, але вона коректна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="k">new</span> <span class="nc">UniformElement</span><span class="o">)</span>
<span class="nc">Element</span><span class=" -Symbol">&#39;s</span> <span class="n">implementation</span> <span class="n">invoked</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>UniformElement</code> не перекриває <code>demo</code>, він наслідує реалізацію <code>demo</code> від свого суперкласу, <code>Element</code>. Таким чином, реалізація <code>Element</code> є коректною реалізацією <code>demo</code>, коли клас об'єкта є <code>UniformElement</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_10___">10.10 Декларація фінальних членів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді, коли розробляється ієрархія наслідування, ви бажаєте переконатись, що член не може бути перекритий в субкласах. В Scala, як і в Java, ви робите це, додаючи модифікатор <code>final</code> до члена. Як показано в Лістингу 10.7, ви можете покласти модифікатор <code>final</code> на <code>demo</code> метод в <code>ArrayElement</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;ArrayElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.7 - Декларування фінального методу.</p></div>
<div class="paragraph"><p>Маючи цю версію <code>ArrayElement</code>, спроба перекрити <code>demo</code> в субкласі <code>LineElement</code> не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">18</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">error</span> <span class="kt">overriding</span> <span class="kt">method</span> <span class="kt">demo</span>
   <span class="n">in</span> <span class="k">class</span> <span class="nc">ArrayElement</span> <span class="n">of</span> <span class="k">type</span> <span class="o">()</span><span class="kt">Unit</span><span class="o">;</span>
<span class="n">method</span> <span class="n">demo</span> <span class="n">cannot</span> <span class="k">override</span> <span class="k">final</span> <span class="n">member</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
                 <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Також часом ви бажаєте переконатись, що цілий клас не може мати субкласів. Щоб зробити це, просто декларуйте цілий клас фінальним, додаючи модифікатор <code>final</code> до декларації класу. Наприклад, Лістинг 10.8 показує, як ви можете декларувати фінальний <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">class</span> <span class="nc">ArrayElement</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;ArrayElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.8 - Декларування фінального класу.</p></div>
<div class="paragraph"><p>З цією версією <code>ArrayElement</code>, люба спроба визначити субклас не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span> <span class="err">18</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">illegal</span> <span class="kt">inheritance</span> <span class="kt">from</span> <span class="kt">final</span> <span class="kt">class</span>
    <span class="nc">ArrayElement</span>
  <span class="k">class</span> <span class="nc">LineElement</span> <span class="k">extends</span> <span class="nc">ArrayElement</span> <span class="o">{</span>
                            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми видалимо модифікатор <code>final</code> та метод <code>demo</code>, та повернемось до ранішньої реалізації сімейства <code>Element</code>. В залишку глави ми зфокусуємо нашу увагу на завершенні робочої версії бібліотеки розташування.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_11____">10.11 Використання композиції та наслідування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Композиція та наслідування є двома шляхами визначити новий клас в термінах іншого існуючого класа. Якщо те, чого ви шукаєте, це просте повторне використання коду, ви маєте обрати композицію замість наслідування. Тільки наслідування потерпає від проблеми крихких базових класів, коли ви можете ненавмисно зашкодити субкласам через зміни в суперкласі.</p></div>
<div class="paragraph"><p>Одне питання, що ви можете запитати себе щодо відношення наслідування, чи моделює воно відношення "..є примірником..".<span class="footnote"><br />[Meyers, Effective C++ [Mey91]]<br /></span> Наприклад, це буде досить дотепним сказати, що <code>ArrayElement</code> <em>є примірником</em> <code>Element</code>. Інше питання, що ви можете запитати, це чи те, чи колись клієнти забажають використовувати тип субкласів як тип суперкласу.<span class="footnote"><br />[Eckel, Thinking in Java [Eck98]]<br /></span> В випадку <code>ArrayElement</code>, ми очевидно очікуємо, що клієнти бажатимуть використовувати <code>ArrayElement</code> як <code>Element</code>.</p></div>
<div class="paragraph"><p>Якщо ви задасте ці питання щодо відношень наслідування, показаних на Малюнку 10.3, чи якесь з відношень виглядає підозріло? Закрема, чи виглає це очевидним, що <code>LineElement</code> <em>є примірником</em> <code>ArrayElement</code>? Чи ви думаєте, що клієнтам колись знадобиться використовувати <code>LineElement</code> як <code>ArrayElement</code>?</p></div>
<div class="paragraph"><p>Фактично, ми визначили <code>LineElement</code> як субклас <code>ArrayElement</code> в основному для повторного використання визначення <code>contents</code> з <code>ArrayElement</code>. Можливо, було б краще визначити <code>LineElement</code> як прямий субклас <code>Element</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В попередній версії <code>LineElement</code> має відношення наслідування з <code>ArrayElement</code>, від якого він наслідує <code>contents</code>. Тепер він має відношення композиції з <code>Array</code>: він має посилання на масив з рядків зі свого власного поля <code>contents</code>.<span class="footnote"><br />[Клас <code>ArrayElement</code> також має відношення композиції з <code>Array</code>, оскільки його параметричне поле <code>contents</code> містить посилання на масив з рядків. Код для <code>ArrayElement</code> показаний в Лістингу 10.5. Його відношення композиції представлене на діаграмі класу як діамант, наприклад, як показано на Малюнку 10.1.]<br /></span> Маючи цю реалізацію <code>LineElement</code>, ієрархія наслідування для <code>Element</code> тепер виглядає так, як на Малюнку 10.4.</p></div>
<div class="paragraph"><p>Малюнок 10.4 - Ієрархія класів з переробленим <code>LineElement</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_12__code_above_code_code_beside_code__code_tostring_code">10.12 Реалізація <code>above</code>, <code>beside</code> та <code>toString</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми реалізуємо метод <code>above</code> в класі <code>Element</code>. Покладання одного елементу над іншим означає конкатенацію двох значень <code>contents</code> для елементів. Так що перша чернетка метода <code>above</code> може виглядати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Операція <code>++</code> конкатенує два масиви. Масиви в Scala представлені масивами Java, але підтримують значно більше методів. Більш точно, масиви в Scala можуть бути конвертовані в примірники класу <code>scala.Seq</code>, що представляє собою послідовність-подібні структуру, та містить декілька методів для доступу та перетворення послідовностей. Деякі інші методи масивів будуть пояснені в цій главі, та більш докладна дискусія буде надана в Главі 17.</p></div>
<div class="paragraph"><p>Фактично, попередньо показаний код не дуже достатній, оскільки він не дозволяє вам покладати вам елементи різної ширини один зверху іншого. Щоб утримувати речі в цьому розділі простими, ми залишимо це як є, та передаватимемо до <code>above</code> тільки елементи однієї ширини. В Розділі 10.14 ми зробимо покращення до <code>above</code>, так щоб клієнти могли використовувати його для комбінування елементів з різною шириною.</p></div>
<div class="paragraph"><p>Наступний метод, що треба реалізувати, є <code>beside</code>. Щоб покласти два елементи один поряд з іншим, ми створимо новий елемент, в якому кожна лінія утворюється від канкатенації відповідних ліній з двох елементів. Як і раніше, щоб утримувати речі простими, ми почнемо з припущення, що два елементи мають ту саму висоту. Це призводить до наступного дизайну метода <code>beside</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">contents</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">contents</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>beside</code> спочатку розміщує новий масив <code>contents</code>, та заповнює його вмістом відповідних елементів масива в <code>this.contents</code> та <code>that.contents</code>. В фіналі він продукує новий <code>ArrayElement</code>, що містить новий <code>contents</code>.</p></div>
<div class="paragraph"><p>Хоча ця реалізація <code>beside</code> робить, це імперативний стиль, промовистим знаком чого є цикл в якому ми проходимо по масиву. Альтернативно, метод може бути скорочений до одного вирау:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span>
  <span class="k">for</span> <span class="o">(</span>
        <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>
      <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут є два масива, <code>this.contents</code> та <code>that.contents</code>, що трансформуються в масив з пар (що називаютсья <code>Tuple2s</code>) використовуючи оператор <code>zip</code>. Оператор <code>zip</code> бере відповідні елементи зі своїх двох операндів, та формує масив з пар. Наприклад, цей вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">zip</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>обчислюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо один з двох масивів довший за інший, <code>zip</code> буде відкидати зайві елементи. В виразі вище третій елемент лівого операнда, <code>3</code>, не формує частину результату, оскільки він не має відповідного елемента в правому операнді.</p></div>
<div class="paragraph"><p>Після цього поєднаний масив ітерується в виразу <code>for</code>. Тут синтаксис <code>for ((line1, line2) &lt;- ...)</code> дозволяє вам назвати обоє елементи з пари в одному шаблоні (тобто, тепер <code>line1</code> тепер відповідає першому елементу з пари, та <code>line2</code> відповідає другому). Система співпадіння з шаблонами в Scala буде описана в деталях в Главі 15. Доки ви можете думати про це як про спосіб визначити дві <code>val</code>, <code>line1</code> та <code>line2</code>, на кожному кроці ітерації.</p></div>
<div class="paragraph"><p>Вираз <code>for</code> має частину <code>yield</code>, і, таким чином, видає результат. Результат буде того самого типу, що і вираз, по якому іде ітерація (тобто, це масив). Кожний елемент масиву є результатом конкатенації відповідних рядків, <code>line1</code> та <code>line2</code>. Так що ваш останній результат цього коду є той самий, що і в першій версії <code>beside</code>, але оскільки він уникає індексації масиву, цей результат отриманий в менш схильний до помилок спосіб.</p></div>
<div class="paragraph"><p>Вам все ще треба спосіб відображати елементи. Як звичайно, це робиться через визначення метода <code>toString</code>, що повертає елемент, відформатований як рядок. Ось визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація <code>toString</code> задіє <code>mkString</code>, що визначене для всіх послідовностей, включаючи масиви. Як ви бачили в Розділі 7.8, вирази, як <code>arr mkString sep</code> повертає рядок, що складається з усіх елементів масива <code>arr</code>. Кожний елемент відзеркалюється на рядок, через виклик для кожного елементу <code>toString</code>. Рядок роздільника, sep, вставляється між послідовними рядками елементів. Так що вираз <code>contents mkString "\n"</code> форматує масив <code>contents</code> як рядок, де кожний елемент масива з'являється на окремому рядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span><span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">(</span>
        <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>
      <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
    <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.9 - Клас <code>Element</code> з <code>above</code>, <code>beside</code> та <code>toString</code>.</p></div>
<div class="paragraph"><p>Зауважте, що <code>toString</code> не має порожнього списку параметрів. Це слідує рекомендаціям для принципа уніформного доступу, оскільки <code>toString</code> є чистим методом, що не приймає жодних параметрів. З додаванням ціх трьох методів, клас <code>Element</code> тепер виглядає як показано в Лістингу 10.9.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_13____">10.13 Визначення об'єкта фабрики</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви маєте ієрархію класів для елементів розташування. Ця ієрархія може бути представлена вашим клієнтам "як є", але ви також можете обрати приховати ієрархію за лаштунками об'єкта фабрики.</p></div>
<div class="paragraph"><p>Об'єкт фабрики містить методи, що конструюють інші об'єкти. Потім клієнти використовують ці методи фабрики, замість конструювання об'єктів напряму за допомогою <code>new</code>. Перевага цього підходу до створення об'єктів в тому, що створення об'єктів може бути централізоване, і деталі того, як об'єкти представлені класами може бути приховане. Це приховування одночасно зробить вашу бібліотеку простішою для розуміння клієнтами, оскільки показані меньше деталей, та провадить вам більше можливостей пізніше змінити реалізацію вашої бібліотеки, не руйнуючи код клієнта.</p></div>
<div class="paragraph"><p>Перше завдання в конструюванні фабрики для ваших об'єктів розташування є обрати, де мають бути розміщені методи фабрики. Чи мають вони бути членами об'єкта синглтона, або класа? Що повинно викликати містячий об'єкт або клас? Існую багато можливостей. Прямолінійне рішення є створити об'єкт компанйон класа <code>Element</code>, та зробити його об'єктом фабрикою для елементів розміщення. Таким чином, вам треба показати вашим клієнтам тільки комбінацію класа/об'єкта, та ви можете приховати три класа реалізації,<code>ArrayElement</code>, <code>LineElement</code>, та <code>UniformElement</code>.</p></div>
<div class="paragraph"><p>Лістинг 10.10 є дизайном об'єкта <code>Element</code>, що слідує цій схемі. Об'єкт  <code>Element</code> містить три перевантажені варіанти метода <code>elem</code>, та кожний конструює різний тип об'єкта розташування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">contents</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">chr</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">UniformElement</span><span class="o">(</span><span class="n">chr</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.10 - Об'єкт фабрики з методом фабрики.</p></div>
<div class="paragraph"><p>З появою ціх методів фабрик має сенс змінити реалізацію класа <code>Element</code>, так щоб він шов через методи фабрик <code>elem</code>, скоріше ніж створювати нові примірники <code>ArrayElement</code> напряму. Щоб викликати методи фабрик, не кваліфікуючи їх іменем об'єкта синглтона, <code>Element</code>, ми будемо імпортувати <code>Element.elem</code> на верхньому рівні джерельного файла. Іншими словами, замість виклику методів фабрик як <code>Element.elem</code> зсередини класу <code>Element</code>,ми імпортуємо <code>Element.elem</code>, так що ви можете просто викликати методи фабрик по їх простому імені, <code>elem</code>. Лістинг 10.11 показує, як буде виглядати клас Element після ціх змін.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="n">elem</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="n">elem</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">(</span>
        <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>
      <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
    <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.11 - Клас <code>Element</code> після рефакторинга з додавання методів фабрик.</p></div>
<div class="paragraph"><p>На додаток, маючи методи фабрик, тепер субкласи <code>ArrayElement</code>, <code>LineElement</code>, <code>UniformElement</code> можуть бути приватними, оскільки вони більше не мають отримувати доступ напряму від клієнтів. В Scala ви можете визначати класи та об'єкти синглтони. Один спосіб зробити субкласи <code>Element</code> приватними - це покласти їх в об'єкт синглтон <code>Element</code>, та декларувати їх там приватними. Класи будуть все ще доступні до трьох методах фабрик <code>elem</code>, де вони потрібні. Лістинг 10.12 показує, як це буде виглядати.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_14___">10.14 Підвищення та розширення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нам треба одне останнє покращення. Версія <code>Element</code>, показана в Лістингу 10.11, не є повністю достатньою, оскільки вона не дозволяє клієнтам покладати елементи з різною шириною один на одний, або класти поряд елементи з різною висотою. Наприклад, обчислення наступних виразів не буде робити коректно, оскільки другий рядок в комбінованому елементі довший, ніж в першому:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">))</span> <span class="n">above</span>
<span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;world!&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, обчислення наступного виразу не буде робити потрібним чином, оскільки перший <code>ArrayElement</code> має висоту два, а другий висоту один:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span> <span class="n">beside</span>
<span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.13 показує приватний допоміжний метод, <code>widen</code>, що приймає ширину, та повертає <code>Element</code> такої ширини. Результат містить вміст цього <code>Element</code>, відцентрований та вирівняний зліва та зправа додатковими проміжками, як треба щоб досягти потрібної ширини. Лістинг 10.13 також показує подібний метод, <code>heighten</code>, що виконує ту саму функцію в вертикальному напрямку. Метод <code>widen</code> викликається в <code>above</code>, щоб переконатись, що <code>Element</code>, покладений над будь-яким іншим, матиме ту саму ширину. Подібно до цього, метод <code>heighten</code> викликається в <code>beside</code>, щоб переконатись, що елементи, розташовані поряд, мають ту саму ширину. З такими змінами бібліотека розташування готова до використання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Element</span> <span class="o">{</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span>
      <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="o">}</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">UniformElement</span><span class="o">(</span>
      <span class="n">ch</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span>
      <span class="k">override</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
      <span class="k">override</span> <span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span>
    <span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
      <span class="k">private</span> <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">toString</span> <span class="o">*</span> <span class="n">width</span>
      <span class="k">def</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">height</span><span class="o">)(</span><span class="n">line</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">contents</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">chr</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nc">UniformElement</span><span class="o">(</span><span class="n">chr</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.12 - Приховування реалізації за допомогою приватних класів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">this1</span> <span class="k">=</span> <span class="k">this</span> <span class="n">widen</span> <span class="n">that</span><span class="o">.</span><span class="n">width</span>
    <span class="k">val</span> <span class="n">that1</span> <span class="k">=</span> <span class="n">that</span> <span class="n">widen</span> <span class="k">this</span><span class="o">.</span><span class="n">width</span>
    <span class="n">elem</span><span class="o">(</span><span class="n">this1</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that1</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">this1</span> <span class="k">=</span> <span class="k">this</span> <span class="n">heighten</span> <span class="n">that</span><span class="o">.</span><span class="n">height</span>
    <span class="k">val</span> <span class="n">that1</span> <span class="k">=</span> <span class="n">that</span> <span class="n">heighten</span> <span class="k">this</span><span class="o">.</span><span class="n">height</span>
    <span class="n">elem</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">((</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">this1</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that1</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
      <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">widen</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">width</span><span class="o">)</span> <span class="k">this</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">left</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">width</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">right</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">w</span> <span class="o">-</span> <span class="n">width</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
      <span class="n">left</span> <span class="n">beside</span> <span class="k">this</span> <span class="n">beside</span> <span class="n">right</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">heighten</span><span class="o">(</span><span class="n">h</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;=</span> <span class="n">height</span><span class="o">)</span> <span class="k">this</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">top</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">height</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">bot</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">height</span> <span class="o">-</span> <span class="n">top</span><span class="o">.</span><span class="n">height</span><span class="o">)</span>
      <span class="n">top</span> <span class="n">above</span> <span class="k">this</span> <span class="n">above</span> <span class="n">bot</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.13 - <code>Element</code> з методами <code>widen</code> та <code>heighten</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_15___">10.15 Складаємо все разом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цікавий спосіб потренуватись з майже всіма елементами бібліотеки розташування - це написати програму, що малює спіраль з заданим числом граней. Ця програма Spiral, показана в Лістингу 10.14, що робить саме це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">object</span> <span class="nc">Spiral</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">space</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">corner</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">spiral</span><span class="o">(</span><span class="n">nEdges</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">direction</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nEdges</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
      <span class="n">elem</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">sp</span> <span class="k">=</span> <span class="n">spiral</span><span class="o">(</span><span class="n">nEdges</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">direction</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span> <span class="o">%</span> <span class="mi">4</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">verticalBar</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;|&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">height</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">horizontalBar</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">(</span><span class="n">corner</span> <span class="n">beside</span> <span class="n">horizontalBar</span><span class="o">)</span> <span class="n">above</span> <span class="o">(</span><span class="n">sp</span> <span class="n">beside</span> <span class="n">space</span><span class="o">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">(</span><span class="n">sp</span> <span class="n">above</span> <span class="n">space</span><span class="o">)</span> <span class="n">beside</span> <span class="o">(</span><span class="n">corner</span> <span class="n">above</span> <span class="n">verticalBar</span><span class="o">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">(</span><span class="n">space</span> <span class="n">beside</span> <span class="n">sp</span><span class="o">)</span> <span class="n">above</span> <span class="o">(</span><span class="n">horizontalBar</span> <span class="n">beside</span> <span class="n">corner</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="o">(</span><span class="n">verticalBar</span> <span class="n">above</span> <span class="n">corner</span><span class="o">)</span> <span class="n">beside</span> <span class="o">(</span><span class="n">space</span> <span class="n">above</span> <span class="n">sp</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nSides</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toInt</span>
    <span class="n">println</span><span class="o">(</span><span class="n">spiral</span><span class="o">(</span><span class="n">nSides</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.14 - Застосування Spiral.</p></div>
<div class="paragraph"><p>Оскікльи <code>Spiral</code> є окремий об'єкт з методом <code>main</code> відповідної сигнатури, це застосування Scala. Spiral приймає один аргумент командного рядка як ціле, та малює спіраль з заданим числом граней. Наприклад, ви можете намалювати шісти-гранну спіраль, як показано зліва, та більші спіралі, які показані зправа.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala Spiral 6    $ scala Spiral 11   $ scala Spiral 17
+-----              +----------         +----------------
|                   |                   |
| +-+               | +------+          | +------------+
| + |               | |      |          | |            |
|   |               | | +--+ |          | | +--------+ |
+---+               | | |  | |          | | |        | |
                    | | ++ | |          | | | +----+ | |
                    | |    | |          | | | |    | | |
                    | +----+ |          | | | | ++ | | |
                    |        |          | | | |  | | | |
                    +--------+          | | | +--+ | | |
                                        | | |      | | |
                                        | | +------+ | |
                                        | |          | |
                                        | +----------+ |
                                        |              |
                                        +--------------+</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_16_">10.16 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цьому розділі ви бачили більше концепцій, пов'язаних з об'єктно-орієнтовним програмуванням в Scala. Поміж іншого, вам зустрілись абстрактні класи, наслідквання та субтипи, ієрархії класів, параметричні поля та перекриття методів. Ви мали розвинути відчуття конструювання нетривіальних ієрархій в Scala. Ми будемо знову робити з бібліотекою розташувань в Главі 14.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-12 13:17:12 EET
</div>
</div>
</body>
</html>
