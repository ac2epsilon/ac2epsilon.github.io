<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="paragraph"><p>Chapter 10
Composition and Inheritance
Chapter 6 introduced some basic object-oriented aspects of Scala. This chapter picks up where Chapter
6 left off and dives into Scala&#8217;s support for object-oriented programming in much greater detail.
We&#8217;ll compare two fundamental relationships between classes: composition and inheritance.
Composition means one class holds a reference to another, using the referenced class to help it fulfill its
mission. Inheritance is the superclass/subclass relationship.
In addition to these topics, we&#8217;ll discuss abstract classes, parameterless methods, extending classes,
overriding methods and fields, parametric fields, invoking superclass constructors, polymorphism and
dynamic binding, final members and classes, and factory objects and methods.
10.1 A TWO-DIMENSIONAL LAYOUT LIBRARY
As a running example in this chapter, we&#8217;ll create a library for building and rendering two-dimensional
layout elements. Each element will represent a rectangle filled with text. For convenience, the library
will provide factory methods named "elem" that construct new elements from passed data. For
example, you&#8217;ll be able to create a layout element containing a string using a factory method with the
following signature:
elem(s: String): Element
As you can see, elements will be modeled with a type named Element. You&#8217;ll be able to
call aboveor beside on an element, passing in a second element, to get a new element that combines the
two. For example, the following expression would construct a larger element consisting of two
columns, each with a height of two:
val column1 = elem("hello") above elem("<strong><strong>")
val column2 = elem("</strong></strong>") above elem("world")
column1 beside column2
Printing the result of this expression would give you:
hello <strong>*
</strong>* world
Layout elements are a good example of a system in which objects can be constructed from simple parts
with the aid of composing operators. In this chapter, we&#8217;ll define classes that enable element objects to
be constructed from arrays, lines, and rectangles. These basic element objects will be the simple parts.
We&#8217;ll also define composing operators above andbeside. Such composing operators are also often
called combinators because they combine elements of some domain into new elements.
Thinking in terms of combinators is generally a good way to approach library design: it pays to think
about the fundamental ways to construct objects in an application domain. What are the simple objects?In what ways can more interesting objects be constructed out of simpler ones? How do combinators
hang together? What are the most general combinations? Do they satisfy any interesting laws? If you
have good answers to these questions, your library design is on track.
10.2 ABSTRACT CLASSES
Our first task is to define type Element, which represents layout elements. Since elements are two
dimensional rectangles of characters, it makes sense to include a member, contents, that refers to the
contents of a layout element. The contents can be represented as an array of strings, where each string
represents a line. Hence, the type of the result returned by contentswill be Array[String]. Listing
10.1 shows what it will look like.
abstract class Element {
def contents: Array[String]
}
Listing 10.1 - Defining an abstract method and class.
In this class, contents is declared as a method that has no implementation. In other words, the method is
an abstract member of class Element. A class with abstract members must itself be declared abstract,
which is done by writing an abstract modifier in front of the class keyword:
abstract class Element &#8230;
The abstract modifier signifies that the class may have abstract members that do not have an
implementation. As a result, you cannot instantiate an abstract class. If you try to do so, you&#8217;ll get a
compiler error:
scala&gt; new Element
&lt;console&gt;:5: error: class Element is abstract;
cannot be instantiated
new Element
<sup>
Later in this chapter, you&#8217;ll see how to create subclasses of class Element, which you&#8217;ll be able to
instantiate because they fill in the missing definition for contents.
Note that the contents method in class Element does not carry an abstract modifier. A method is abstract
if it does not have an implementation (i.e., no equals sign or body). Unlike Java, no abstract modifier is
necessary (or allowed) on method declarations. Methods that have an implementation are
called concrete.
Another bit of terminology distinguishes between declarations and definitions.
Class Elementdeclares the abstract method contents, but currently defines no concrete methods. In the
next section, however, we&#8217;ll enhance Element by defining some concrete methods.10.3 DEFINING PARAMETERLESS METHODS
As a next step, we&#8217;ll add methods to Element that reveal its width and height, as shown inListing
10.2. The height method returns the number of lines in contents. The width method returns the length
of the first line, or if there are no lines in the element, returns zero. (This means you cannot define an
element with a height of zero and a non-zero width.)
abstract class Element {
def contents: Array[String]
def height: Int = contents.length
def width: Int = if (height == 0) 0 else contents(0).length
}
Listing 10.2 - Defining parameterless methods width and height.
Note that none of Element&#8217;s three methods has a parameter list, not even an empty one. For example,
instead of:
def width(): Int
the method is defined without parentheses:
def width: Int
Such parameterless methods are quite common in Scala. By contrast, methods defined with empty
parentheses, such as def height(): Int, are called empty-paren methods. The recommended convention is
to use a parameterless method whenever there are no parameters and the method accesses mutable state
only by reading fields of the containing object (in particular, it does not change mutable state). This
convention supports the uniform access principle,<span class="footnote"><br />[Meyer, Object-Oriented Software Construction [Mey00]]<br /></span> which says that client code should not be affected
by a decision to implement an attribute as a field or method.
For instance, we could implement width and height as fields, instead of methods, simply by changing
the def in each definition to a val:
abstract class Element {
def contents: Array[String]
val height = contents.length
val width =
if (height == 0) 0 else contents(0).length
}
The two pairs of definitions are completely equivalent from a client&#8217;s point of view. The only difference
is that field accesses might be slightly faster than method invocations because the field values are pre-
computed when the class is initialized, instead of being computed on each method call. On the other
hand, the fields require extra memory space in each Element object. So it depends on the usage profile
of a class whether an attribute is better represented as a field or method, and that usage profile might
change over time. The point is that clients of theElement class should not be affected when its internal
implementation changes.In particular, a client of class Element should not need to be rewritten if a field of that class gets
changed into an access function, so long as the access function is pure (i.e., it does not have any side
effects and does not depend on mutable state). The client should not need to care either way.
So far so good. But there&#8217;s still a slight complication that has to do with the way Java handles things.
The problem is that Java does not implement the uniform access principle. So it&#8217;sstring.length() in Java,
not string.length, even though it&#8217;s array.length, not array.length(). Needless to say, this is very
confusing.
To bridge that gap, Scala is very liberal when it comes to mixing parameterless and empty-paren
methods. In particular, you can override a parameterless method with an empty-paren method, and vice
versa. You can also leave off the empty parentheses on an invocation of any function that takes no
arguments. For instance, the following two lines are both legal in Scala:
Array(1, 2, 3).toString
"abc".length
In principle it&#8217;s possible to leave out all empty parentheses in Scala function calls. However, it&#8217;s still
recommended to write the empty parentheses when the invoked method represents more than a
property of its receiver object. For instance, empty parentheses are appropriate if the method performs
I/O, writes reassignable variables (vars), or reads vars other than the receiver&#8217;s fields, either directly or
indirectly by using mutable objects. That way, the parameter list acts as a visual clue that some
interesting computation is triggered by the call. For instance:
"hello".length
println()


To summarize, it is encouraged in Scala to define methods that take no parameters and have no side
effects as parameterless methods (i.e., leaving off the empty parentheses). On the other hand, you
should never define a method that has side-effects without parentheses, because invocations of that
method would then look like a field selection. So your clients might be surprised to see the side effects.
Similarly, whenever you invoke a function that has side effects, be sure to include the empty
parentheses when you write the invocation. Another way to think about this is if the function you&#8217;re
calling performs an operation, use the parentheses. But if it merely provides access to a property, leave
the parentheses off.
10.4 EXTENDING CLASSES
We still need to be able to create new element objects. You have already seen that "new Element"
cannot be used for this because class Element is abstract. To instantiate an element, therefore, we will
need to create a subclass that extends Element and implements the abstract contentsmethod. Listing
10.3 shows one possible way to do that:
class ArrayElement(conts: Array[String]) extends Element {
def contents: Array[String] = conts
}Listing 10.3 - Defining ArrayElement as a subclass of Element.
Class ArrayElement is defined to extend class Element. Just like in Java, you use an extends clause
after the class name to express this:
&#8230; extends Element &#8230;
Figure 10.1 - Class diagram for ArrayElement.
Such an extends clause has two effects: It makes class ArrayElement inherit all non-private members
from class Element, and it makes the type ArrayElement a subtype of the type Element.
Given ArrayElement extends Element, class ArrayElement is called a subclass of
class Element.Conversely, Element is a superclass of ArrayElement. If you leave out an extends clause,
the Scala compiler implicitly assumes your class extends from scala.AnyRef, which on the Java
platform is the same as class java.lang.Object. Thus, class Element implicitly extends class AnyRef.
You can see these inheritance relationships in Figure 10.1.
Inheritance means that all members of the superclass are also members of the subclass, with two
exceptions. First, private members of the superclass are not inherited in a subclass. Second, a member
of a superclass is not inherited if a member with the same name and parameters is already implemented
in the subclass. In that case we say the member of the subclass overrides the member of the superclass.
If the member in the subclass is concrete and the member of the superclass is abstract, we also say that
the concrete memberimplements the abstract one.
For example, the contents method in ArrayElement overrides (or alternatively: implements) abstract
method contents in class Element.<span class="footnote"><br />[One flaw with this design is that because the returned array is mutable, clients could change it. For the book we&#8217;ll keep things simple, but were ArrayElement part of a real project, you might consider returning a defensive copy of the array instead. Another problem is we aren&#8217;t currently ensuring that every String element of the contents array has the same length. This could be solved by checking the precondition in the primary constructor and throwing an exception if it is violated.]<br /></span> By contrast, class ArrayElement inherits
the widthand height methods from class Element. For example, given an ArrayElement ae, you can
query its width using ae.width, as if width were defined in class ArrayElement:
scala&gt; val ae = new ArrayElement(Array("hello", "world"))
ae: ArrayElement = <a href="mailto:ArrayElement@39274bf7">ArrayElement@39274bf7</a>
scala&gt; ae.width
res0: Int = 5Subtyping means that a value of the subclass can be used wherever a value of the superclass is
required. For example:
val e: Element = new ArrayElement(Array("hello"))
Variable e is defined to be of type Element, so its initializing value should also be an Element. In fact,
the initializing value&#8217;s type is ArrayElement. This is OK, because class ArrayElement extends
class Element, and as a result, the type ArrayElement is compatible with the type Element.<span class="footnote"><br />[For more perspective on the difference between subclass and subtype, see the glossary entry for subtype.]<br /></span>
Figure 10.1 also shows the composition relationship that exists
between ArrayElement andArray[String]. This relationship is called composition because
class ArrayElement is "composed" out of class Array[String], in that the Scala compiler will place into
the binary class it generates for ArrayElement a field that holds a reference to the passed conts array.
We&#8217;ll discuss some design considerations concerning composition and inheritance later in this chapter,
inSection 10.11.
10.5 OVERRIDING METHODS AND FIELDS
The uniform access principle is just one aspect where Scala treats fields and methods more uniformly
than Java. Another difference is that in Scala, fields and methods belong to the same namespace. This
makes it possible for a field to override a parameterless method. For instance, you could change the
implementation of contents in class ArrayElement from a method to a field without having to modify
the abstract method definition of contents in class Element, as shown in Listing 10.4:
class ArrayElement(conts: Array[String]) extends Element {
val contents: Array[String] = conts
}
Listing 10.4 - Overriding a parameterless method with a field.
Field contents (defined with a val) in this version of ArrayElement is a perfectly good implementation
of the parameterless method contents (declared with a def) in class Element. On the other hand, in
Scala it is forbidden to define a field and method with the same name in the same class, whereas this is
allowed in Java.
For example, this Java class would compile just fine:

class CompilesFine {
private int f = 0;
public int f() {
return 1;
}
}
But the corresponding Scala class would not compile:
class WontCompile {
private var f = 0 // Won&#8217;t compile, because a field
def f = 1

}Generally, Scala has just two namespaces for definitions in place of Java&#8217;s four. Java&#8217;s four namespaces
are fields, methods, types, and packages. By contrast, Scala&#8217;s two namespaces are:
• values (fields, methods, packages, and singleton objects)
• types (class and trait names)
The reason Scala places fields and methods into the same namespace is precisely so you can override a
parameterless method with a val, something you can&#8217;t do with Java.<span class="footnote"><br />[The reason that packages share the same namespace as fields and methods in Scala is to enable you to import packages (in addition to just the names of types) and the fields and methods of singleton objects. This is also something you can&#8217;t do in Java. It will be described in Section 13.3.]<br /></span>
10.6 DEFINING PARAMETRIC FIELDS
Consider again the definition of class ArrayElement shown in the previous section. It has
aparameter conts whose sole purpose is to be copied into the contents field. The name conts of the
parameter was chosen just so that it would look similar to the field name contents without actually
clashing with it. This is a "code smell," a sign that there may be some unnecessary redundancy and
repetition in your code.
You can avoid the code smell by combining the parameter and the field in a singleparametric
field definition, as shown in Listing 10.5:
class ArrayElement(
val contents: Array[String]
) extends Element
Listing 10.5 - Defining contents as a parametric field.
Note that now the contents parameter is prefixed by val. This is a shorthand that defines at the same
time a parameter and field with the same name. Specifically, class ArrayElement now has an
(unreassignable) field contents, which can be accessed from outside the class. The field is initialized
with the value of the parameter. It&#8217;s as if the class had been written as follows, where x123 is an
arbitrary fresh name for the parameter:
class ArrayElement(x123: Array[String]) extends Element {
val contents: Array[String] = x123
}
You can also prefix a class parameter with var, in which case the corresponding field would be
reassignable. Finally, it is possible to add modifiers, such as private, protected,<span class="footnote"><br />[The protected modifier, which grants access to subclasses, will be covered in detail inChapter 13.]<br /></span> or override to these
parametric fields, just as you can for any other class member. Consider, for instance, the following
class definitions:
class Cat {
val dangerous = false
}
class Tiger(
override val dangerous: Boolean,
private var age: Int
) extends CatTiger&#8217;s definition is a shorthand for the following alternate class definition with an overriding
member dangerous and a private member age:
class Tiger(param1: Boolean, param2: Int) extends Cat {
override val dangerous = param1
private var age = param2
}
Both members are initialized from the corresponding parameters. We chose the names of those
parameters, param1 and param2, arbitrarily. The important thing was that they not clash with any other
name in scope.
10.7 INVOKING SUPERCLASS CONSTRUCTORS
You now have a complete system consisting of two classes: an abstract class Element, which is
extended by a concrete class ArrayElement. You might also envision other ways to express an
element. For example, clients might want to create a layout element consisting of a single line given by
a string. Object-oriented programming makes it easy to extend a system with new data-variants. You
can simply add subclasses. For example, Listing 10.6 shows a LineElementclass that
extends ArrayElement:
class LineElement(s: String) extends ArrayElement(Array(s)) {
override def width = s.length
override def height = 1
}
Listing 10.6 - Invoking a superclass constructor.
Since LineElement extends ArrayElement, and ArrayElement&#8217;s constructor takes a parameter
(anArray[String]), LineElement needs to pass an argument to the primary constructor of its superclass.
To invoke a superclass constructor, you simply place the argument or arguments you want to pass in
parentheses following the name of the superclass. For example,
classLineElement passes Array(s) to ArrayElement&#8217;s primary constructor by placing it in parentheses
after the superclass ArrayElement&#8217;s name:
&#8230; extends ArrayElement(Array(s)) &#8230;
With the new subclass, the inheritance hierarchy for layout elements now looks as shown inFigure
10.2.Figure 10.2 - Class diagram for LineElement.
10.8 USING OVERRIDE MODIFIERS
Note that the definitions of width and height in LineElement carry an override modifier. In Section 6.3,
you saw this modifier in the definition of a toString method. Scala requires such a modifier for all
members that override a concrete member in a parent class. The modifier is optional if a member
implements an abstract member with the same name. The modifier is forbidden if a member does not
override or implement some other member in a base class. Since height and width in
class LineElement override concrete definitions in class Element, overrideis required.
This rule provides useful information for the compiler that helps avoid some hard-to-catch errors and
makes system evolution safer. For instance, if you happen to misspell the method or accidentally give it
a different parameter list, the compiler will respond with an error message:
$ scalac LineElement.scala
&#8230;/LineElement.scala:50:
error: method hight overrides nothing
override def hight = 1
</sup>
The override convention is even more important when it comes to system evolution. Say you defined a
library of 2D drawing methods. You made it publicly available, and it is widely used. In the next
version of the library you want to add to your base class Shape a new method with this signature:
def hidden(): Boolean
Your new method will be used by various drawing methods to determine whether a shape needs to be
drawn. This could lead to a significant speedup, but you cannot do this without the risk of breaking
client code. After all, a client could have defined a subclass of Shape with a different implementation
of hidden. Perhaps the client&#8217;s method actually makes the receiver object disappear instead of testing
whether the object is hidden. Because the two versions ofhidden override each other, your drawing
methods would end up making objects disappear, which is certainly not what you want!
These "accidental overrides" are the most common manifestation of what is called the "fragile base
class" problem. The problem is that if you add new members to base classes (which we usually callsuperclasses) in a class hierarchy, you risk breaking client code. Scala cannot completely solve the
fragile base class problem, but it improves on the situation compared to Java.<span class="footnote"><br />[In Java 1.5, an @Override annotation was introduced that works similarly to Scala&#8217;s overridemodifier, but unlike Scala&#8217;s override, is not required.]<br /></span> If the drawing library
and its clients were written in Scala, then the client&#8217;s original implementation of hidden could not have
had an override modifier, because at the time there was no other method with that name.
Once you add the hidden method to the second version of your shape class, a recompile of the client
would give an error like the following:
&#8230;/Shapes.scala:6: error: error overriding method
hidden in class Shape of type ()Boolean;
method hidden needs &#8216;override&#8217; modifier
def hidden(): Boolean =
<sup>
That is, instead of wrong behavior your client would get a compile-time error, which is usually much
preferable.
10.9 POLYMORPHISM AND DYNAMIC BINDING
You saw in Section 10.4 that a variable of type Element could refer to an object of typeArrayElement.
The name for this phenomenon is polymorphism, which means "many shapes" or "many forms." In this
case, Element objects can have many forms.<span class="footnote"><br />[This kind of polymorphism is called subtyping polymorphism. Another kind of polymorphism in Scala called universal polymorphism is discussed in Chapter 19.]<br /></span>
So far, you&#8217;ve seen two such forms: ArrayElement and LineElement. You can create more forms
ofElement by defining new Element subclasses. For example, you could define a new form
ofElement that has a given width and height, and is filled everywhere with a given character:
class UniformElement(
ch: Char,
override val width: Int,
override val height: Int
) extends Element {
private val line = ch.toString * width
def contents = Array.fill(height)(line)
}
The inheritance hierarchy for class Element now looks as shown in Figure 10.3. As a result, Scala will
accept all of the following assignments, because the type of the assigning expression conforms to the
type of the defined variable:
val
val
val
val
e1:
ae:
e2:
e3:
Element = new ArrayElement(Array("hello", "world"))
ArrayElement = new LineElement("hello")
Element = ae
Element = new UniformElement(<em>x</em>, 2, 3)
If you check the inheritance hierarchy, you&#8217;ll find that in each of these four val definitions, the type of
the expression to the right of the equals sign is below the type of the val being initialized to the left of
the equals sign.Figure 10.3 - Class hierarchy of layout elements.
The other half of the story, however, is that method invocations on variables and expressions
are dynamically bound. This means that the actual method implementation invoked is determined at run
time based on the class of the object, not the type of the variable or expression. To demonstrate this
behavior, we&#8217;ll temporarily remove all existing members from our Element classes and add a method
named demo to Element. We&#8217;ll override demo inArrayElement and LineElement, but not
in UniformElement:
abstract class Element {
def demo() = {
println("Element&#8217;s implementation invoked")
}
}
class ArrayElement extends Element {
override def demo() = {
println("ArrayElement&#8217;s implementation invoked")
}
}
class LineElement extends ArrayElement {
override def demo() = {
println("LineElement&#8217;s implementation invoked")
}
}

class UniformElement extends Element
If you enter this code into the interpreter, you can then define this method that takes anElement and
invokes demo on it:
def invokeDemo(e: Element) = {
e.demo()
}
If you pass an ArrayElement to invokeDemo, you&#8217;ll see a message indicating ArrayElement&#8217;s
implementation of demo was invoked, even though the type of the variable, e, on which demowas
invoked is Element:scala&gt; invokeDemo(new ArrayElement)
ArrayElement&#8217;s implementation invoked
Similarly, if you pass a LineElement to invokeDemo, you&#8217;ll see a message that
indicates LineElement&#8217;sdemo implementation was invoked:
scala&gt; invokeDemo(new LineElement)
LineElement&#8217;s implementation invoked
The behavior when passing a UniformElement may at first glance look suspicious, but it is correct:
scala&gt; invokeDemo(new UniformElement)
Element&#8217;s implementation invoked
Because UniformElement does not override demo, it inherits the implementation of demo from its
superclass, Element. Thus, Element&#8217;s implementation is the correct implementation of demo to invoke
when the class of the object is UniformElement.
10.10 DECLARING FINAL MEMBERS
Sometimes when designing an inheritance hierarchy, you want to ensure that a member cannot be
overridden by subclasses. In Scala, as in Java, you do this by adding a finalmodifier to the member. As
shown in Listing 10.7, you could place a final modifier onArrayElement&#8217;s demo method.
class ArrayElement extends Element {
final override def demo() = {
println("ArrayElement&#8217;s implementation invoked")
}
}
Listing 10.7 - Declaring a final method.
Given this version of ArrayElement, an attempt to override demo in its subclass, LineElement, would
not compile:
elem.scala:18: error: error overriding method demo
in class ArrayElement of type ()Unit;
method demo cannot override final member
override def demo() = {
</sup>
You may also at times want to ensure that an entire class not be subclassed. To do this you simply
declare the entire class final by adding a final modifier to the class declaration. For example, Listing
10.8 shows how you would declare ArrayElement final:
final class ArrayElement extends Element {
override def demo() = {
println("ArrayElement&#8217;s implementation invoked")
}
}Listing 10.8 - Declaring a final class.
With this version of ArrayElement, any attempt at defining a subclass would fail to compile:
elem.scala: 18: error: illegal inheritance from final class
ArrayElement
class LineElement extends ArrayElement {
^
We&#8217;ll now remove the final modifiers and demo methods, and go back to the earlier implementation of
the Element family. We&#8217;ll focus our attention in the remainder of this chapter to completing a working
version of the layout library.
10.11 USING COMPOSITION AND INHERITANCE
Composition and inheritance are two ways to define a new class in terms of another existing class. If
what you&#8217;re after is primarily code reuse, you should in general prefer composition to inheritance. Only
inheritance suffers from the fragile base class problem, in which you can inadvertently break subclasses
by changing a superclass.
One question you can ask yourself about an inheritance relationship is whether it models anis-
a relationship.<span class="footnote"><br />[Meyers, Effective C<code> [Mey91]]<br /></span> For example, it would be reasonable to say that ArrayElement is-an Element. Another
question you can ask is whether clients will want to use the subclass type as a superclass type.<span class="footnote"><br />[Eckel, Thinking in Java [Eck98]]<br /></span> In the
case of ArrayElement, we do indeed expect clients will want to use anArrayElement as an Element.
If you ask these questions about the inheritance relationships shown in Figure 10.3, do any of the
relationships seem suspicious? In particular, does it seem obvious to you that a LineElementis-
an ArrayElement? Do you think clients would ever need to use a LineElement as an ArrayElement?
In fact, we defined LineElement as a subclass of ArrayElement primarily to reuse ArrayElement&#8217;s
definition of contents. Perhaps it would be better, therefore, to define LineElement as a direct subclass
of Element, like this:
class LineElement(s: String) extends Element {
val contents = Array(s)
override def width = s.length
override def height = 1
}
In the previous version, LineElement had an inheritance relationship with ArrayElement, from which it
inherited contents. It now has a composition relationship with Array: it holds a reference to an array of
strings from its own contents field.<span class="footnote"><br />[Class ArrayElement also has a composition relationship with Array, because its parametriccontents field holds a reference to an array of strings. The code for ArrayElement is shown inListing 10.5 here. Its composition relationship is represented in class diagrams by a diamond, as shown, for example, in Figure 10.1 here.]<br /></span> Given this implementation ofLineElement, the inheritance
hierarchy for Element now looks as shown in Figure 10.4.Figure 10.4 - Class hierarchy with revised LineElement.
10.12 IMPLEMENTING ABOVE, BESIDE, AND TOSTRING
As a next step, we&#8217;ll implement method above in class Element. Putting one element above another
means concatenating the two contents values of the elements. So a first draft of method above could
look like this:
def above(that: Element): Element =
new ArrayElement(this.contents </code> that.contents)
The <code> operation concatenates two arrays. Arrays in Scala are represented as Java arrays, but support
many more methods. Specifically, arrays in Scala can be converted to instances of a class scala.Seq,
which represents sequence-like structures and contains a number of methods for accessing and
transforming sequences. Some other array methods will be explained in this chapter and a more
comprehensive discussion will be given in Chapter 17.
In fact, the code shown previously is not quite sufficient because it does not let you put elements of
different widths on top of each other. To keep things simple in this section, however, we&#8217;ll leave this as
is and only pass elements of the same length to above. In Section 10.14, we&#8217;ll make an enhancement
to above so that clients can use it to combine elements of different widths.
The next method to implement is beside. To put two elements beside each other, we&#8217;ll create a new
element in which every line results from concatenating corresponding lines of the two elements. As
before, to keep things simple, we&#8217;ll start by assuming the two elements have the same height. This leads
to the following design of method beside:
def beside(that: Element): Element = {
val contents = new Array[String](this.contents.length)
for (i &#8592; 0 until this.contents.length)
contents(i) = this.contents(i) + that.contents(i)
new ArrayElement(contents)
}
The beside method first allocates a new array, contents, and fills it with the concatenation of the
corresponding array elements in this.contents and that.contents. It finally produces a
newArrayElement containing the new contents.Although this implementation of beside works, it is in an imperative style, the telltale sign of which is
the loop in which we index through arrays. Alternatively, the method could be abbreviated to one
expression:
new ArrayElement(
for (
(line1, line2) &#8592; this.contents zip that.contents
) yield line1 + line2
)
Here, the two arrays, this.contents and that.contents, are transformed into an array of pairs (asTuple2s
are called) using the zip operator. The zip operator picks corresponding elements in its two operands
and forms an array of pairs. For instance, this expression:
Array(1, 2, 3) zip Array("a", "b")
will evaluate to:
Array1
If one of the two operand arrays is longer than the other, zip will drop the remaining elements. In the
expression above, the third element of the left operand, 3, does not form part of the result, because it
does not have a corresponding element in the right operand.
The zipped array is then iterated over by a for expression. Here, the syntax "for ((line1, line2) &#8592; &#8230;)"
allows you to name both elements of a pair in one pattern (i.e., line1stands now for the first element of
the pair, and line2 stands for the second). Scala&#8217;s pattern-matching system will be described in detail
in Chapter 15. For now, you can just think of this as a way to define two vals, line1 and line2, for each
step of the iteration.
The for expression has a yield part and therefore yields a result. The result is of the same kind as the
expression iterated over (i.e., it is an array). Each element of the array is the result of concatenating the
corresponding lines, line1 and line2. So the end result of this code is the same as in the first version
of beside, but because it avoids explicit array indexing, the result is obtained in a less error-prone way.
You still need a way to display elements. As usual, this is done by defining a toString method that
returns an element formatted as a string. Here is its definition:
override def toString = contents mkString "\n"
The implementation of toString makes use of mkString, which is defined for all sequences, including
arrays. As you saw in Section 7.8, an expression like "arr mkString sep" returns a string consisting of
all elements of the array arr. Each element is mapped to a string by calling its toString method. A
separator string sep is inserted between consecutive element strings. So the expression,
"contents mkString "\n"" formats the contents array as a string, where each array element appears on a
line by itself.
abstract class Element {def contents: Array[String]
def width: Int =
if (height == 0) 0 else contents(0).length
def height: Int = contents.length
def above(that: Element): Element =
new ArrayElement(this.contents </code> that.contents)
def beside(that: Element): Element =
new ArrayElement(
for (
(line1, line2) &#8592; this.contents zip that.contents
) yield line1 + line2
)
override def toString = contents mkString "\n"
}
Listing 10.9 - Class Element with above, beside, and toString.
Note that toString does not carry an empty parameter list. This follows the recommendations for the
uniform access principle, because toString is a pure method that does not take any parameters. With the
addition of these three methods, class Element now looks as shown inListing 10.9.
10.13 DEFINING A FACTORY OBJECT
You now have a hierarchy of classes for layout elements. This hierarchy could be presented to your
clients "as is," but you might also choose to hide the hierarchy behind a factory object.
A factory object contains methods that construct other objects. Clients would then use these factory
methods to construct objects, rather than constructing the objects directly with new. An advantage of
this approach is that object creation can be centralized and the details of how objects are represented
with classes can be hidden. This hiding will both make your library simpler for clients to understand,
because less detail is exposed, and provide you with more opportunities to change your library&#8217;s
implementation later without breaking client code.
The first task in constructing a factory for layout elements is to choose where the factory methods
should be located. Should they be members of a singleton object or of a class? What should the
containing object or class be called? There are many possibilities. A straightforward solution is to
create a companion object of class Element and make this the factory object for layout elements. That
way, you need to expose only the class/object combo of Element to your clients, and you can hide the
three implementation classes ArrayElement,LineElement, and UniformElement.
Listing 10.10 is a design of the Element object that follows this scheme. The Element object contains
three overloaded variants of an elem method and each constructs a different kind of layout object.
object Element {
def elem(contents: Array[String]): Element =
new ArrayElement(contents)def elem(chr: Char, width: Int, height: Int): Element =
new UniformElement(chr, width, height)
def elem(line: String): Element =
new LineElement(line)
}
Listing 10.10 - A factory object with factory methods.
With the advent of these factory methods, it makes sense to change the implementation of
class Element so that it goes through the elem factory methods rather than creating
newArrayElement instances explicitly. To call the factory methods without qualifying them
withElement, the name of the singleton object, we will import Element.elem at the top of the source
file. In other words, instead of invoking the factory methods with Element.elem inside classElement,
we&#8217;ll import Element.elem so we can just call the factory methods by their simple name,elem. Listing
10.11 shows what class Element will look like after these changes.
import Element.elem
abstract class Element {
def contents: Array[String]
def width: Int =
if (height == 0) 0 else contents(0).length
def height: Int = contents.length
def above(that: Element): Element =
elem(this.contents <code> that.contents)
def beside(that: Element): Element =
elem(
for (
(line1, line2) &#8592; this.contents zip that.contents
) yield line1 + line2
)
override def toString = contents mkString "\n"
}
Listing 10.11 - Class Element refactored to use factory methods.
In addition, given the factory methods, the subclasses, ArrayElement, LineElement,
andUniformElement, could now be private because they no longer need to be accessed directly by
clients. In Scala, you can define classes and singleton objects inside other classes and singleton
objects. One way to make the Element subclasses private is to place them inside theElement singleton
object and declare them private there. The classes will still be accessible to the three elem factory
methods, where they are needed. Listing 10.12 shows how that will look.10.14 HEIGHTEN AND WIDEN
We need one last enhancement. The version of Element shown in Listing 10.11 is not quite sufficient
because it does not allow clients to place elements of different widths on top of each other, or place
elements of different heights beside each other.
For example, evaluating the following expression won&#8217;t work correctly, because the second line in the
combined element is longer than the first:
new ArrayElement(Array("hello")) above
new ArrayElement(Array("world!"))
Similarly, evaluating the following expression would not work properly, because the
firstArrayElement has a height of two and the second a height of only one:
new ArrayElement(Array("one", "two")) beside
new ArrayElement(Array("one"))
Listing 10.13 shows a private helper method, widen, which takes a width and returns an Elementof that
width. The result contains the contents of this Element, centered, padded to the left and right by any
spaces needed to achieve the required width. Listing 10.13 also shows a similar method, heighten,
which performs the same function in the vertical direction. The widenmethod is invoked by above to
ensure that Elements placed above each other have the same width. Similarly, the heighten method is
invoked by beside to ensure that elements placed beside each other have the same height. With these
changes, the layout library is ready for use.
object Element {
private class ArrayElement(
val contents: Array[String]
) extends Element
private class LineElement(s: String) extends Element {
val contents = Array(s)
override def width = s.length
override def height = 1
}
private class UniformElement(
ch: Char,
override val width: Int,
override val height: Int
) extends Element {
private val line = ch.toString * width
def contents = Array.fill(height)(line)
}
def elem(contents: Array[String]): Element =
new ArrayElement(contents)
def elem(chr: Char, width: Int, height: Int): Element =
new UniformElement(chr, width, height)
def elem(line: String): Element =}
new LineElement(line)
Listing 10.12 - Hiding implementation with private classes.
import Element.elem
abstract class Element {
def contents: Array[String]
def width: Int = contents(0).length
def height: Int = contents.length
def above(that: Element): Element = {
val this1 = this widen that.width
val that1 = that widen this.width
elem(this1.contents </code> that1.contents)
}
def beside(that: Element): Element = {
val this1 = this heighten that.height
val that1 = that heighten this.height
elem(
for ((line1, line2) &#8592; this1.contents zip that1.contents)
yield line1 + line2)
}
def widen(w: Int): Element =
if (w &#8656; width) this
else {
val left = elem(' <em>, (w - width) / 2, height)
val right = elem(</em> <em>, w - width - left.width, height)
left beside this beside right
}
def heighten(h: Int): Element =
if (h &#8656; height) this
else {
val top = elem(</em> <em>, width, (h - height) / 2)
val bot = elem(</em> <em>, width, h - height - top.height)
top above this above bot
}
}
override def toString = contents mkString "\n"
Listing 10.13 - Element with widen and heighten methods.
10.15 PUTTING IT ALL TOGETHER
A fun way to exercise almost all elements of the layout library is to write a program that draws a spiral
with a given number of edges. This Spiral program, shown in Listing 10.14, will do just that.
import Element.elem
object Spiral {
val space = elem(" ")val corner = elem("<code>")
def spiral(nEdges: Int, direction: Int): Element = {
if (nEdges == 1)
elem("</code>")
else {
val sp = spiral(nEdges - 1, (direction + 3) % 4)
def verticalBar = elem(</em>|<em>, 1, sp.height)
def horizontalBar = elem(</em>-', sp.width, 1)
if (direction == 0)
(corner beside horizontalBar) above (sp beside space)
else if (direction == 1)
(sp above space) beside (corner above verticalBar)
else if (direction == 2)
(space beside sp) above (horizontalBar beside corner)
else
(verticalBar above corner) beside (space above sp)
}
}
def main(args: Array[String]) = {
val nSides = args(0).toInt
println(spiral(nSides, 0))
}
}
Listing 10.14 - The Spiral application.
Because Spiral is a standalone object with a main method with the proper signature, it is a Scala
application. Spiral takes one command-line argument, an integer, and draws a spiral with the specified
number of edges. For example, you could draw a six-edge spiral, as shown on the left, and larger
spirals, as shown on the right.
$ scala Spiral 6
<code>-----
|
| +-</code>
| + |
|
|
<code>---</code>
$ scala Spiral 11
<code>----------
|
| +------</code>
| |
|
| | <code>--</code> |
| | | | |
| | <code> | |
| |
| |
| <code>----</code> |
|
|
<code>--------</code>
$ scala Spiral 17
<code>----------------
|
| +------------</code>
| |
|
| | <code>--------</code> |
| | |
| |
| | | <code>----</code> | |
| | | |
| | |
| | | | </code> | | |
| | | | | | | |
| | | <code>--</code> | | |
| | |
| | |
| | <code>------</code> | |
| |
| |
| <code>----------</code> |
|
|
<code>--------------</code>
10.16 CONCLUSION
In this section, you saw more concepts related to object-oriented programming in Scala. Among others,
you encountered abstract classes, inheritance and subtyping, class hierarchies, parametric fields, andmethod overriding. You should have developed a feel for constructing a non-trivial class hierarchy in
Scala. We&#8217;ll work with the layout library again inChapter 14.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-28 00:25:38 EET
</div>
</div>
</body>
</html>
