include::headers.adoc[]

Глава 26
--------

Екстрактори
===========

Тепер ви, можливо, зростили бажання мати стислий спосіб, яким дані можуть бути декомпоновані і проаналізовані з використанням співпадіння шаблонів. Ця глава показує вам,як надалі узагальнити цю концепцію. До цього часу шаблони конструкторів були пов'язані з кейс класами. Наприклад, `Some(x)` є валідним шаблоном, оскільки `Some` є кейс класом. Іноді ви будете бажати створити шаблон як цей,  без створення асоційованого кейс класу. Фактично, ви можете побажати створити власний різновид шаблону. Екстрактори дають вам спосіб зробити це. Ця глава пояснює, що таке екстрактори, і як ви їх можете використовувати для визначення шаблонів, що відділені від репрезентації об'єкта.

26.1 Приклад: отриманння адреси електронної пошти
-------------------------------------------------
Щоб проілюструвати проблему, яку використовує екстрактор, уявімо, що вам треба проаналізувати рядкі, що представляють адреси електронної пошти. Беручи рядок, ви бажаєте вирішити, чи є це адреса електронної пошти, або ні, та, якщо це так, ви бажаєте отримати доступ до частин користувача та домена цієї адреси. Традиційний спосіб зробити це задіє три допоміжні функції:
[source,scala]
----
def isEMail(s: String): Boolean
def domain(s: String): String
def user(s: String): String
----
З ціма функціями ви можете розібрати наданий рядок таким чином:
[source,scala]
----
if (isEMail(s)) println(user(s) + " AT " + domain(s))
else println("not an email address")
----
Це робить, але дещо неоковирно. Що більше, речі ставатимуть складнішими, якщо вам треба зробити декілька такіх перевірок. Наприклад, ви можете побажати знайти дві послідовні рядки в списку, що обоє є адресами електрнної пошти з тим самим користувачем. Ви можете спробувати це самотужки, за допомогою попередньо визначених функцій доступу, щоб побачити, що для цього знадобиться.

Ви вже бачили в Главі 15, що порівняння шаблонів є ідеальним для атак на проблеми як ця. Давайте на мить уявімо, що ви можете порівняти рядок з шаблоном:
[source,scala]
----
EMail(user, domain)
----
Шаблон співпадатиме, якщо рядок містить символ `at` (`@`). В цьому випадку він може прикріпляти змінну `user` до частини рядка до `@`, та змінну `domain` до частини після нього. Постулюючи шаблон такого вигляду, попередній вираз може бути записаний більш ясно, ось так:
[source,scala]
----
s match {
  case EMail(user, domain) => println(user + " AT " + domain)
  case _ => println("not an email address")
}
----
Більш складна проблема пошуку двох послідовних адрес з тим же користувачем буде транслюватись в наступний шаблон:
[source,scala]
----
ss match {
  case EMail(u1, d1) :: EMail(u2, d2) :: _ if (u1 == u2) => ...
...
}
----
Це значно більш прийнятно, ніж будь-що, що може бути написане за допомогою функцій доступу. Однак проблема в тому, що рядкі не кейс класи; вони не мають репрезентації, що відповідає до `EMail(user, domain)`. Ось де з'являються екстрактори Scala: вони дозволяють вам визначити нові шаблони для вже визначених типів, де шаблон не має слідувати внутрішній репрезентації типу.

26.2 Екстрактори
----------------
Екстрактором в Scala є об'єкт, що має метод з назвою `unapply`в якості свого члена. Призначення метода `unapply` є порівнювати значення та розбивати його на частини. Часто об'єкт екстрактора також визначає парний метод `apply` для побудови значень, але це не вимагається. Як приклад, Лістинг 26.1 показує об'єкт екстрактора для адрес електронної пошти:
[source,scala]
----
object EMail { 
  // Метод ін'єкції (опціональний)
  def apply(user: String, domain: String) = user + "@" + domain

// Метод екстракції (обов'язковий)
  def unapply(str: String): Option[(String, String)] = {
    val parts = str split "@"
    if (parts.length == 2) Some(parts(0), parts(1)) else None
  }
}
----
Лістинг 26.1 - Рядковий об'єкт `EMail` екстрактора.

Цей об'єкт визначає одночасно методи `apply` та `unapply`. Метод `apply` має таке значення, як і завжди: він перетворює `EMail` в об'єкт, що може бути застосований до аргументів в дужках, в той же спосіб, як застосовуються методи. Так що ви можете написати `EMail("John", "epfl.ch")` для конструювання рядка `"John@epfl.ch"`. Щоб зробити це більш явним, ви можете також дозволити `EMail` наслідувати функціональний тип Scala, як тут: 
[source,scala]
----
object EMail extends ((String, String) => String) { ... }
----
NOTE: Частина `(String, String) => String` декларації попереднього об'єкта означає те саме, що і `Function2[String, String, String]`, що декларує абстрактний метод `apply`, що реалізує `EMail`. Як результат цієї декларації ви можете, наприклад, передати `EMail` до метода, що очікує `Function2[String, String, String]`.

Метод `unapply` це те, що перетворює `EMail` в екстрактор. В деякому сенсі він обератє процес конструктора в `apply`. Коли `apply` приймає два рядки, та формує на їх основі рядок адреси, `unapply` приймає рядок адреси, та потенційно повертає два рядка: `user` та `domain` цієї адреси. Але `unapply` має також обробляти випадок, коли наданий рядок не є електронною адресою. Ось чому `unapply` повертає тип `Option` для пари рядків. Його результат є або `Some(user, domain)`, якщо рядок `str` є адресою з певними частинами `user` та `domain`,footnote:[Як тут демонструється, де `Some` застосовується до тапла `(user, domain)`, ви можете полишити пару дужок, коли передаєте тапл до функції, що приймає один аргумент. Таким чином, `Some(user, domain)` означає те саме, що і `Some((user, domain))`.] або `None`, якщо `str` не є адресою електронної пошти. Ось деякі приклади:
[source,scala]
----
unapply("John@epfl.ch") equals Some("John", "epfl.ch")
unapply("John Doe") equals None
----
Тепер, коли порівняння шаблонів натрапляє на шаблон, що посилається на об'єкт екстрактора, він викликає метод екстрактора `unapply` на виразі селектора. Наприклад, виконання кода:
[source,scala]
----
selectorString match { case EMail(user, domain) => ... }
----
буде призводити до виклика:
[source,scala]
----
EMail.unapply(selectorString)
----
Як ви бачили до цього, цей виклик до `EMail.unapply` буде повертати або `None` або `Some(u, d)` для деяких значень, `u` для частини адреси `user`, та `d` для чистини `domain`. В випадку `None` шаблоне на співпадає, і система намагається порівняти інший шаблон, або схибить з виключенням `MatchError`. В випадку `Some(u, d)` шаблон співпадає, та його змінні прикріплюються до елементів повернутого значення. В попередньому порівнянні `user` буде зв'язано з `u`, та `domain` буде прив'язаний до `d`.

В прикладі з шаблоном порівняння `EMail` тип `String` виразу селектора, `selectorString`, відповідає до типу аргумента `unapply` (що в прикладі також був `String`). Це досить загальне, але не обов'язкове. Також можливо використовувати екстрактор `EMail` для порівняння `match` виразів для більш загальних типів. Наприклад, щоб знайти, чи довільне значення `x` є рядком адреси електронної пошти, ви можете записати:
[source,scala]
----
val x: Any = ...
x match { case EMail(user, domain) => ... }
----
Маючи цей код, порівнювач шаблонів зпочатку перевірить, чи надане значення `x` відповідає до `String`, тип параметру метода `EMail` `unapply`. Якщо він відповідає, значення приводиться до `String`, та співпадіння шаблонів продовжується як звичайно. Якщо він не відповідає, шаблон безпосередньо зазнає невдачі.

В об'єкті `EMail` метод `apply` називається ін'єкцією, оскільки він приймає деякі аргументи, та отримує елемент наданої множини (в нашому випадку множину рядків, що є інтернет адресами). Метод `unapply` називається екстракцією, оскільки він бере елемент з тієї ж множини, та екстрагує деякі з його частин (в нашому випадку субрядки `user` та `domain`). Ін'єкції та екстракції часто групіюються разом в одному об'єкті, оскільки ви можете використовувати ім'я об'єкта для обох, конструктора та шаблона, що симулює домовленість про порівняння шаблонів для кейс класів. Однак також можливо визначити екстракцію в об'єкті без відповідної ін'єкції. Сам об'єкт називається екстрактором, безвідносно, чи має чи ні метод `apply`.

Якщо метод ін'єкції включений, він має доповнювати метод екстракції. Наприклад, виклик:
[source,scala]
----
EMail.unapply(EMail.apply(user, domain)) 
----
повинен повертати:
[source,scala]
----
Some(user, domain)
----
тобто та сама послідовність аргументів, огорнена в `Some`. Ідучи в іншому напрямку означає спочатку викликати метод `unapply`, та потім `apply`, як показано в наступному коді:
[source,scala]
----
EMail.unapply(obj) match {
  case Some(u, d) => EMail.apply(u, d)
}
----
В уьому коді, якщо `match` на `obj` матиме успіх, ви очікуєте отримати той самий об'єкт від `apply`. Ці дві умови для дуальності `apply` та `unapply` є гарним принципом дизайну. Вони не примушуються Scala, але їх рекомендовано дотримуватись, коли розробляєте ваші екстрактори.

26.3 Шаблони з нулем або однією змінною
---------------------------------------
Метод `unapply` в попередньому прикладі повертає пару значень елемента в разі успіху. Це легко узагальнити до шаблонів з більш ніж двома змінними. Щоб прікрипити `N` змінних, `unapply` має повертати тапл з N елементів, огорнутий в `Some`.

Однак випадок, коли шаблон прикріплює лише одну змінну, трактується по-іншому. В Scala немає тапла з одним елементом. Щоб повернути тільки один елемент шаблону метод `unapply` просто огортає сам елемент в `Some`. Наприклад, об'єкт екстрактор, показаний на Лістингу 26.2, визначає `unapply` для рідків, що складається з деяких субрядків, з'являючись два рази поспіль:
[source,scala]
----
object Twice {
  def apply(s: String): String = s + s
  def unapply(s: String): Option[String] = {
    val length = s.length / 2
    val half = s.substring(0, length)
    if (half == s.substring(length)) Some(half) else None
  }
}
----
Лістинг 26.2 - Об'єкт екстрактора рядків `Twice`.

Також можливо, щоб шаблон екстрактора взагалі не прикріпляв жодних змінних. В цьому випадку відповідний метод `unapply` повертає логічне `true` для успіха, та `false` для невдачі. Наприклад, об'єкт екстрактора, показаний в Лістингу 26.3, характеризує рядкі, що складаються лише з великих літер:
[source,scala]
----
object UpperCase {
  def unapply(s: String): Boolean = s.toUpperCase == s
}
----
Лістинг 26.3 - Об'єкт екстрактора рядків `UpperCase`.

На це раз екстрактор тільки визначає `unapply`, але не `apply`. Не буде сенсу з визначення `apply`, бо нічого конструювати. Наступна функція `userTwiceUpper` застосовує всі попередньо визначені екстрактори разом в своєму коді співпадіння шаблонів:
[source,scala]
----
def userTwiceUpper(s: String) = s match {
  case EMail(Twice(x @ UpperCase()), domain) =>
    "match: " + x + " in domain " + domain
  case _ =>
    "no match"
}
----
Перший шаблон цієї функції співпадає з рядками, що є адресами електронної пошти, чия частина `user` складається з двох входжень того самого рядка великими літерами. Наприклад:
[source,scala]
----
scala> userTwiceUpper("DIDI@hotmail.com")
res0: String = match: DI in domain hotmail.com

scala> userTwiceUpper("DIDO@hotmail.com")
res1: String = no match

scala> userTwiceUpper("didi@hotmail.com")
res2: String = no match
----
Зауважте, що `UpperCase` в функції `userTwiceUpper` приймає порожній список параметрів. Цього неможливо оминути, бо тоді `match` буде тестувати на рівність з об'єктом `UpperCase`! Зауважте також, що хоча `UpperCase()` сам не прикріплює жодних змінних, все ще можливо асоціювати змінну з цілим шаблоном, що співпав. Щоб зробити це, ви використовуєте стантартну схему прикріплення змінних, пояснену в Розділі 15.2: форма `x @ UpperCase()` асоціює змінну з `x` шаблоном, співпавшим з `UpperCase()`. Наприклад, в першому виклику `userTwiceUpper` вище, `x` був прив'язаний до `"DI"`, оскільки це було значення, з яким порівнювався шаблон `UpperCase()`.

26.4 Екстрактори зі змінними аргументами
----------------------------------------
Попередні методи екстракторів для електронної пошти всі повертали фіксоване число значень елеменів. Іноді це недостатньо гнучко. Наприклад, ви можете бажати порівняти на рядку, що містить ім'я домені, так щоб кожна частина домену зберігалась в іншому субшаблоні. Це дозволить вам виразити такі шаблони:
[source,scala]
----
dom match {
  case Domain("org", "acm") => println("acm.org")
  case Domain("com", "sun", "java") => println("java.sun.com")
  case Domain("net", _*) => println("a .net domain")
}
----
В цьому прикладі речі аранжовані так, щоб домени витрачались в зворотньому порядку — від вищого рівня до субдоменів. Це зроблене так, щоб отримати більше вигод від шаблонів послідовностей. Ви бачили в Розділі 15.2, що шаблон підстановки послідовностей, `_*`, в кінці списку аргументів співпадає з любим залишком елементів в послідовності. Ця можливість більш корисна, якщо домени вищого рівня ідуть першими, оскільки тоді ви можете використовувати підстановки послідовностей для співпадіння субдоменів на довільну глибину.

Залишається питання, як екстрактор може підтримувати співпадіння `vararg`, як показано в попередньому прикладі, де шаблони можуть мати змінне число субшаблонів. Методи `unapply`, що ми зустрічали до цього, недостатні, оскільки кожний з них повертає фіксоване число субелементів в випадку успіху. Щоб обробити цей випадок, Scala дозволяє визначити інший метод екстрактора спеціально для vararg співпадіння. Цей метод має назву `unapplySeq`. Щоб побачити, як це записується, подивіться на екстрактор `Domain`, показаний в Лістингу 26.4:
[source,scala]
----
object Domain {
  // Метод ін'єкції (опціональний)
  def apply(parts: String*): String =
    parts.reverse.mkString(".")

  // Метод екстракції (обов'язковий)
  def unapplySeq(whole: String): Option[Seq[String]] =
    Some(whole.split("\\.").reverse)
}
----
Лістинг 26.4 - Об'єкт екстрактора рядків `Domain`.

Об'єкт `Domain` визначає метод `unapplySeq`, що зпочатку розбиває рядок на частини, розділені крапками. Це робиться за допомогою Java метода `split` на рядках, що приймає регулярний вираз в якості аргумента. Цей результат `split` є масивом субрядків. Результат `unapplySeq` є цей масив з усіма елементами, також огорнутий в `Some`.

Тип результату `unapplySeq` має відповідати до `Option[Seq[T]]`, де тип елемента `T` є довільним. Як ви бачили в Розділі 17.1, `Seq` є важливим класом в ієрархії колекцій Scala. Це загальний суперклас декількох класів, що описують різні типи послідовностей: `List`,`Array`, `WrappedString` та декілька інших.

Для симетрії `Domain` також має метод `apply`, що будує рядок домену зі списку параметрів частин домена, що починається з домену вищого рівня. Як завжди, метод `apply` є опціональним.

Ви можете використовувати естрактор `Domain` для отримання більш детальної інформації від адрес електронної пошти. Наприклад, щоб знайти всі адреси з ім'ям `"tom"` в деякому домені `".com"`, ви можете написати наступну функцію:
[source,scala]
----
def isTomInDotCom(s: String): Boolean = s match {
  case EMail("tom", Domain("com", _*)) => true
  case _ => false
}
----
Це дає очікувані результати:
[source,scala]
----
scala> isTomInDotCom("tom@sun.com")
res3: Boolean = true

scala> isTomInDotCom("peter@sun.com")
res4: Boolean = false

scala> isTomInDotCom("tom@acm.org")
res5: Boolean = false
----
Також можливо повернути деякі фіксовані елементи від `unapplySeq` разом зі змінною частиною. Це виражається через повернення всіх елементів в таплі, де змінна частина іде, як звичайно, останньою. Як приклад, Лістинг 26.5 показує новий екстрактор для адрес, де частина домена вже розширена в послідовність:
[source,scala]
----
object ExpandedEMail {
  def unapplySeq(email: String)
      : Option[(String, Seq[String])] = {
    val parts = email split "@"
    if (parts.length == 2)
      Some(parts(0), parts(1).split("\\.").reverse)
    else
      None
  }
}
----
Лістинг 26.5 - Об'єкт екстрактора `ExpandedEMail`.

Метод `unapplySeq` в `ExpandedEMail` повертає опціональне значення пари (`Tuple2`). Перший елемент в парі є частина `user`. Другий елемент є послідовність імен, що представляють домен. Ви можете зробити співпадіння на них, як звичайно:
[source,scala]
----
scala> val s = "tom@support.epfl.ch"
s: String = tom@support.epfl.ch

scala> val ExpandedEMail(name, topdom, subdoms @ _*) = s
name: String = tom
topdom: String = ch
subdoms: Seq[String] = WrappedArray(epfl, support)
----

26.5 Екстрактори та шаблони послідовностей
------------------------------------------
Ви бачили в Розділі 15.2, що ви можете отримати доступ до елементів списку або масива, використовуючи шаблони послідовностей, як тут:
[source,scala]
----
List()
List(x, y, _*)
Array(x, 0, 0, _)
----
Фактично, ці шаблони послідовностей всі реалізовані з використанням екстракторів в стандартній бібліотеці Scala. Наприклад, шаблони в формі `List(...)` стали можливі, оскільки об'єкт компанйон `scala.List` є екстрактором, що визначає метод `unapplySeq`. Лістинг 26.6 показує маючі відношення визначення:
[source,scala]
----
package scala
object List {
  def apply[T](elems: T*) = elems.toList
  def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
  ...
}
----
Лістинг 26.6 - Екстрактор, що визначає метод `unapplySeq`.

Об'єкт `List` містить метод `apply`, що приймає змінне число аргументів. Це те, що дозволяє вам писати вирази як цей:
[source,scala]
----
List()
List(1, 2, 3)
----
Він також містить метод `unapplySeq`, що повертає всі елементи зі списка як послідовність. Ось що підтримує шаблони `List(...)`. Дуже подібні визначення існують в об'єкті `scala.Array`. Вони підтримують ін'єкції та екстрактори для масивів.

26.6 Екстрактори проти кейс класів
----------------------------------
Навіть якщо вони і дуже корисні, кейс класи мають одне обмеження: вони демонструють дійсну репрезентацію даних. Це означає, що імя класу в шаблоні конструктора відповідає конкретній репрезентації типу об'єкта селектора. Якщо співпадіння з:
[source,scala]
----
case C(...)
----
успішне, ви знаєте, що вираз селектора є примірником класу `C`.

Екстрактори руйнують цей зв'язок між репрезентацією даних та шаблонами. Ви бачили в прикладах в цьому розділі, що вони дозволяють шаблони, що не мають нічого загального з типом даних об'єкта, що вибирається. Ця властивість називається незалежністю від репрезентації. В відкритих системах великого розміру незалежність від репрезентації дуже важлива, оскільки вона дозволяє вам змінити тип реалізації, що використовується в множині компонент, без впливу на клієнтів ціх компонент.

Якщо ваш компонент був визначений та експортований як набір кейс класів, ви будете прив'язані до них, оскільки клієнтській код завжди може містити порівняння шаблонів на ці кейс класи. Переіменування деяких кейс класів або змінення ієрархії класів буде впливати на клієнтський код. Екстрактори не поділяють цю проблему, оскільки вони представляють прошарок перенаправлення між репрезентацією даних та способом, як їх бачать клієнти. Ви все ще можете змінити конкретну репрезентацію типу, доки ви оновлюєте всі ваші екстрактори разом з цім.

Незалежність від репрезентації є важливою перевагою екстракторів над кейс класами. З іншого боку кейс класи також мають деякі переваги над екстракторами. Перше, вони значно простіші для встановлення та визначення, та вони потребують меньше коду. Друге, вони звичайно призводять до більш ефективного порівняння шаблонів, ніж екстрактори, оскільки компілятор Scala може оптимізувати шаблони по кейс класам значно краще, ніж по екстракторам. Це так тому, що механізми кейс класів фіксовані, тоді як методи `unapply` або `unapplySeq` в екстракторі можуть робити майже все. Третє, якщо ваші кейс класи наслідують від закоркованого базового класа, компілятор Scala буде перевіряти ваше співпадіння шаблонів на вичерпність, та буде скаржитись, якщо деяка комбінація можливих значень не покрита шаблоном. Для екстракторів така перевірка на вичерпність не доступна.

То який з двох методів ви маєте обрати для ваших порівнянь шаблонів? Це залежить від декількох факторів. Якщо ви пишете код для закритого застосування, кейс класи звичайно мають перевагу, завдяки їх стислості, швидкості та статичній перевірці. Якщо ви потім вирішите змінити вашу ієрархію класів, застосування буде вимагати рефакторингу, але це звичайно не проблема. З іншого боку, якщо вам треба показати клас невідомим клієнтам, екстрактори можуть переважити, оскільки вони підтримують незалежність від репрезентації.

Нащастя, вам не треба вирішувати прямо зараз. Ви можете в любому випадку почати з кейс класів, і потім, коли постане потреба, змінити їх на екстрактори. Оскільки шаблони по екстракторам та шаблони по кейс класах виглядають так само в Scala, порівняння шаблонів в ваших клієнтах буде продовжувати робити.

Звичайно, також існують ситуації, коли ясно з самого початку, що структура ваших шаблонів не співпадає з репрезентацією типу ваших даних. Обговорена адреса електронної пошти в цій главі є одним з таких прикладів. В такому випадку екстрактори є єдиним можливим вибором.

26.7 Регулярні вирази
---------------------
Одна виключено корисна оболасть застосування екстракторів є регулярні вирази. Як і Java, Scala провадить регулярні вирази через бібліотеку, але екстрактори роблять більш приємною взаємодію з ними.

Формування регулярних виразів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Scala наслідує синтаксис своїх регулярних виразів від Java, що, в свою чергу, наслідує більшість з можливостей від Perl. Ми вважатимемо, що ви вже знаєте синтаксис; якщо ні, існує багато доступних інструкцій, починаючи з документації Javadoc для класа `java.util.regex.Pattern`. Ось тільки деякі приклади, що повинні бути достатні для нагадування:
|===
|ab?|`'a'`, за яким можливо іде `'b'`.
|[1em] \d+| Число, що складається з одної або більше цифр, представлених `\d`.
|[a-dA-D]\w*|Слово, що починається з літери між `a` та `d` в верхньому або нижньому реєстрі, за яким іде послідовність з нуля або більше "слівних  символів", позначених `\w`. (Слівні символи це літери, цифри та підкреслення.)
|[1em](-)?(\d+)(\.\d*)?|Число, що складається з опціонального знаку мінуса, за яким слідує одна або більше цифр, за якими опціонально слідує крапка, та нуль або більше цифр. Число складається з трьох груп, тобто знаку мінусу, частини до десятичної крапки, та дрібної частини. Групи оточені дужками.
|===
Клас регулярних виразів Scala знаходиться в пакунку `scala.util.matching`.
[source,scala]
----
scala> import scala.util.matching.Regex
----
Значення нового регулярного виразу створено через передачу рядка до конструктора `Regex`. Наприклад:
[source,scala]
----
scala> val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
----
Зауважте, що порівняно з регулярним виразом для десятичних чисел, наданого перед цім, кожна зворотня коса надаєтся двічі в рядку вище. Це через те, що в Java та Scala поодинока зворотня коса є символом виключення в рядковому літералі, а не звичайним символом, що показується в рядку. Так що замість `'\'` вам треба писати `'\\'` щоб отримати поодиноку зворотню косу в рядку.

Якщо регулярний вираз містить багато зворотніх косих, це може бути болісним для написання та читання. Сирі рядки Scala провадять альтернативу. Як ви бачили в Розділі 5.2, сирий рядок є послідовність символів між потроєними лапками. Різниця між сиром та звичайним рядком в тому, що всі символи в сирому рядку з'являються саме так, як вони надрукувані. Це включає зворотні косі, що не трактуються як символи виключення. Так що ви можете і дещо більш зрозуміле:
[source,scala]
----
scala> val Decimal = new Regex("""(-)?(\d+)(\.\d*)?""")
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
----
Як ви бачите з виводу інтерпретатора, згенерований значення результату для `Decimal` точно таке, як і раніше. Інший, навіть коротший шлях написати регулярний вираз в Scala, є такий:
[source,scala]
----
scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
----
Іншими словами, просто додайте `.r` до рядка для отримання регулярного виразу. Це можливо, оскільки існує метод на ім'я `r` в класі `StringOps`, що конвертує рядок на регулярний вираз. Метод визначений як показано в Лістингу 26.7:
[source,scala]
----
package scala.runtime
import scala.util.matching.Regex

class StringOps(self: String) ... {
  ...
  def r = new Regex(self)
}
----
Лістинг 26.7 - Як метод `r` визначений в `StringOps`.

Пошук регулярних виразів
~~~~~~~~~~~~~~~~~~~~~~~~
Ви можете пошукати появи регулярного виразу в рядку, використовуючи різні оператори: 
----
regex findFirstIn str
----
Знаходить першу появу регулярного виразу `regex` в рядку `str`, повертаючи результат в типі `Option`.
----
regex findAllIn str
----
Знаходить всі появи регулярного виразу `regex` в рядку `str`, повертаючи результат як `Iterator`.
----
regex findPrefixOf str
----
Знаходить появу регулярного виразу `regex` на початку рядка `str`, повертаючи результат в типі `Option`. Наприклад, ви можете визначити вхідну послідовність нижче, та пошукати в ній десятичні числа:
[source,scala]
----
scala> val Decimal = """(-)?(\d+)(\.\d*)?""".r
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?

scala> val input = "for -1.0 to 99 by 3"
input: String = for -1.0 to 99 by 3

scala> for (s <- Decimal findAllIn input)
println(s)
-1.0
99
3

scala> Decimal findFirstIn input
res7: Option[String] = Some(-1.0)

scala> Decimal findPrefixOf input
res8: Option[String] = None
----

Екстракція за допомогою регулярних виразів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Більше того, кожний регулярний вираз в Scala визначає екстрактор. Екстрактор використовується для ідентифкації субрядків, що співпадають з групами регулярного виразу. Наприклад, ви можете декомпонувати рядок числа таким чином:
[source,scala]
----
scala> val Decimal(sign, integerpart, decimalpart) = "-1.23"
sign: String = -
integerpart: String = 1
decimalpart: String = .23
----
В цьому прикладі шаблон `Decimal(...)` використовується в визначенні `val`, як описано в Розділі 15.7. Що тут відбувається, це значення регулярного виразу `Decimal` визначає метод `unapplySeq`. Цей метод співпадає з кожним рядком, що відповідає до синтаксису регулярного виразу для десятичних чисел. Якщо рядок співпадає, частини відповідно до трьох груп в регулярному виразі `(-)?(\d+) (\.\d*)?` повертаються як елементи шаблону, та потім співпадають з трома змінними шаблону: `sign`, `integerpart` та `decimalpart`. Якщо група відсутня, значення встановлюється в `null`, як можна бачити в наступному прикладі:
[source,scala]
----
scala> val Decimal(sign, integerpart, decimalpart) = "1.0"
sign: String = null
integerpart: String = 1
decimalpart: String = .0
----
Також можливо міксувати екстрактори з пошуком регулярних виразів в  `for` виразах. Наприклад, наступний вираз декомпонує всі десятичні числа, що він знайде у вхідному рядку:
[source,scala]
----
scala> for (Decimal(s, i, d) <- Decimal findAllIn input)
          println("sign: " + s + ", integer: " +
              i + ", decimal: " + d)
sign: -, integer: 1, decimal: .0
sign: null, integer: 99, decimal: null
sign: null, integer: 3, decimal: null
----

Висновок
--------
В цій главі ви бачили, як узагальнити співпадіння шаблонів за допомогою екстракторів. Екстрактори дозволяють вам визначити ваші власні типи шаблонів, що не мають відповідати типу виразів, по яких ви робите вибірку. Це дає вам більше гнучкості в типах шаблонів, що ви можете використовувати для співпадіння. Ефективно це як мати різні можливі погляди на ті самі дані. Це також дає вам прошарок між репрезентацією типа, та тим, як клієнт бачить його. Це дозволяє вам робити порівняння шаблонів, при цьому підтримуючи незалежність репрезентації, властивість, що дуже корисна в великих програмних системах.

Екстрактори - це ще один елемент серед ваших інструментів, що дозволяє вам визначити гнучкі абстракції бібліотеки. Вони потужно використовуються в бібліотеках Scala, наприклад, для зручного порівняння регулярних виразів.
