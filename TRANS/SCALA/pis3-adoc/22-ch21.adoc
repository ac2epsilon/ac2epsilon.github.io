include::headers.adoc[]

Глава 21
--------

Неявні перетворення та параметри
================================

Існує фундаментальна відмінність між вашим кодом, та бібліотеками інших людей: ви можете змінити або розширити ваш власний код, як побажаєте, але якщо ви бажаєте використати чиюсь іншу бібліотеку, ви звичайно маєте сприймати її як є. В мовах з'явилось декілька конструкцій для полегчення цієї проблеми. Ruby має модулі, та Smalltalk дозволяє пакункам додавати до класів один одного. Вони дуже потужні, але також небезпечні, тому що ви можете модифікувати поведінку класу для всього застосування, деяки частини якого ви можете не знати. C# 3.0 має статичні методи розширення, які є більш локальними, але також більш обмежуючі, в тому, що ви можете лише добавляти до класа методи, не поля, та ви не можете змусити клас реалізувати нові інтерфейси.
 
Відповіддю Scala є неявні перетворення та параметри. Вони можуть зробити існуючі бібліотеки значно більше приємними у взаємодії, дозволяючі вам облишити за бортом нудні, очевидні деталі, що приховують цікаві частини вашого коду. Коли використовується зі смаком, це призводить до коду, що сфокусований на цікавих, нетривіальних частинах вашої програми. Ця глава показує вам, як неявні роблять, та вона презентує деякі з найбільш загальних шляхів їх використання.

21.1 Неявні перетворення
------------------------
Перед зануренням в деталі неявних перетворень, поглянемо на типовий приклад їх використання. Неявні перетворення часто корисні для роботи з двома тілами програмного забезпечення, що розроблялись без думки один про одне. Кожна бібліотека має свій власний шлях для кодування концепції, що насправді є однією річчю. Неявні перетворення допомагають через зменьшення числа явних перетворень, що потрібні від одного типу до іншого.

Java включає бібліотеку на ім'я Swing для реалізації крос-платформених користувацьких інтерфейсів. Одна з речей, що робить Swing, це обробка подій від операційної системи, конвертація їх до платформ-незалежних об'єктів подій, та передача ціх подій до частин застосування, що називаються слухачами подій.

Якщо б Swing був написаний зі Scala на думці, слухачі подій мали б, можливо, бути представлені як функціональний тип. Викликачі можуть потім використовувати синтаксис фінкціональних літералів, як легковажний шлях вказати, що має відбуватись для певного класу подій. Оскільки Java не має функціональних літералів, Swing використовує наступну кращу річ, внутрішній клас, що реалізує одно-методний інтерфейс. В випадку слухачів подій, інтерфейсом є `ActionListener`.

Без використання неявних перетворень, програма Scala, що використовує Swing, має використовувати внутрішній клас, так само як в Java. Ось приклад що створює кнопку, та підвішує на неї слухача подій. Слухач подій викликається кожного разу, коли кнопка натискається, і в цій точці він друкує рядок `"pressed!"`:
[source,scala]
----
val button = new JButton
button.addActionListener(
  new ActionListener {
    def actionPerformed(event: ActionEvent) = {
     println("pressed!")
    }
  }
)
----
Цей код має багато неінформативного шаблону. Факт, що цей слухач є `ActionListener`, факт, що це метод зворотнього виклику на ім'я `actionPerformed`, та факт, що аргументом є `ActionEvent` - все це мається на увазі для кожного аргументу `addActionListener`. Єдина нова інформація тут є код, що буде виконаний, а саме виклик `println`. Ця нова інформація тоне в шаблонному коді. Той, хто читає цей код, повинен мати гострий зір, щоб пробитись крізь шум та знайти інформативну частину.

Більш Scala-дружня версія приймає функцію як аргумент, значно зменьшуючи кількість шаблоного коду:
[source,scala]
----
button.addActionListener( // Неспівпадіння типів!
  (_: ActionEvent) => println("pressed!")
)
----
Але так, як він написаний, цей код не робить.footnote:[Як буде пояснено в Розділі 31.5, це робить в Scala 2.12.] Метод `addActionListener` бажає слухача подій, але отримує функцію. З неявними перетвореннями цей код, однак, може бути зроблений робочим.

Перший крок є написання неявного перетворення між двома типами. Ось неявне перетворення від функцій до слухачів подій:
[source,scala]
----
implicit def function2ActionListener(f: ActionEvent => Unit) =
  new ActionListener {
    def actionPerformed(event: ActionEvent) = f(event)
  }
----
Це одно-аргументний метод, що приймає функцію, та повертає слухача подій. Як любий інший одно-аргументний метод, він може бути викликаний напряму, та має свій результат переданий далі в інший вираз:
[source,scala]
----
button.addActionListener(
  function2ActionListener(
    (_: ActionEvent) => println("pressed!")
  )
)
----
Це вже покращення, в порівняні з версією з внутрішнім класом. Зауважте, як довільні маси шаблонного коду були замінені функціональним літералом та викликом метода. Однак з неявними перетвореннями це стає ще краще. Оскільки `function2ActionListener` помічена як `implicit`, вона може бути прибрана, і компілятор буде вставляти її автоматично. Ось результат:
[source,scala]
----
// Тепер це робить
button.addActionListener(
  (_: ActionEvent) => println("pressed!")
)
----
Шлях, яким цей код робить, полягає в тому, що компілятор спочатку компілює його як є, але він бачить помилку типу. Перед тим як здатись, він шукає неявне перетворення, що може владнати проблему. В цьому випадку він знаходить `function2ActionListener`. Він випробовує метод перетворення, бачить що він робить, та рухається далі. Компілятор виконує тяжку роботу, так що розробник може ігнорувати ще одну дрібну деталь. Слухач подій? Функція обробки подій? Обоє будуть робити — використовуйте те, що більш зручно.

В цьому розділі ми ілюструємо деякі з потужностей неявних перетворень, та як вони дозволяють вам причипурити існуючі бібліотеки. В наступних розділах ви вивчите правила, що визначають, коли неявні перетворення будуть спробувані, та як вони будуть шукатись.

21.2 Правила для неявних визначень
----------------------------------
Визначення `implicit` є такими, що дозволяються компілятору для вставки в програму, щоб поладнати любі з його помилок типів. Наприклад, якщо `x + y` не проходить перевірку типів,компілятор може змінити його на `convert(x) + y`, де `convert` є деяке доступне `implicit` перетворення. Якщо `convert` змінює `x` на дещо, що має метод `+`, тоді ця зміна може поладнати програму, так що вона пройде перевірку типів та виконається коректно. Якщо `convert` насправді тільки проста функція перетворення, тоді прибирання її з джерельного коду може бути очищенням.

Неявні перетворення регулюються наступними загальними правилами:

*Правило маркування: доступні тільки визначення, відмічені як `implicit`.* Ключове слово `implicit` використовується як маркер, які декларації може використовувати компілятор для неявних перетворень. Ви можете використовувати його для маркування визначення змінної, функції або об'єкта. Ось приклад визначення неявної функції:footnote:[Змінні та об'єкти синглтони, відмічені як `implicit`, можуть бути використані як неявні параметри. Цей спосіб використання буде описаний пізніше в цій главі.]
[source,scala]
----
implicit def intToString(x: Int) = x.toString
----
Компілятор буде змінювати `x + y` до `convert(x) + y`, тільки якщо `convert` відмічений як `implicit`. Таким чином, ви уникаєте плутанини, коли компілятор обиратиме випадкові функції, що трапляються в полі зору, та вставляє їх як "перетворення". Компілятор буде обирати тільки між визначеннями, що ви явно відмітили як `implicit`.

*Правило поля зору: вставлене неявне перетворення має бути в полі зору як єдиний ідентифікатор, або бути асоційоване з типом джерела або цілі перетворення.* Компілятор Scala буде розглядати тільки неявні перетворення, що знаходяться в полі зору. Таким чином, щоб зробити неявне перетворення доступним, ви повинні деяким чином занести його в поле зору. Більше того, з один виключенням, неявне перетворення має бути в полі зору як _єдиний ідентифікатор_. Компілятор не буде вставляти перетворення в формі `someVariable.convert`. Наприклад, він не буде розширювати `x + y` до `someVariable.convert(x) + y`. Якщо ви бажаєте зробити `someVariable.convert` доступним як `implicit`, вам треба імпортувати його, що робитиме його доступним як єдиний ідентифікатор. Як тільки той імпортований, компілятор буде вільний застосувати його як `convert(x) + y`. Фактично, є загальним для бібліотек включати об'єкт `Preamble`, що включає декілька корисних неявних перетворень. Код, що використовує бібліотеку, потім може зробити один `import Preamble._` для доступу до неявних перетворень бібліотеки.

Існує одне виключення до правила "єдиного ідентифікатора". Компілятор також буде дивитись неявні перетворення в об'єкті компанйоні джерела або очікуваного типів перетворення. Наприклад, якщо ви намагаєтесь передати об'єкт `Dollar` до метода, що приймає `Euro`, типом джерела є `Dollar`, та тип цілі є `Euro`. Таким чином, ви можете запакувати неявне перетворення від `Dollar` до `Euro` в об'єкт компанйон любого класу, `Dollar` або `Euro`.

Ось приклад, в якому визначення `implicit` покладене в об'єкт компанйон `Dollar`:
[source,scala]
----
object Dollar {
  implicit def dollarToEuro(x: Dollar): Euro = ...
}
class Dollar { ... }
----
В цьому випадку кажуть, що перетворення `dollarToEuro` _асоційоване_ з типом `Dollar`. Компілятор буде шукати такі асоційовані перетворення кожний раз, коли йому треба перетворити з примірника типу `Dollar`. Немає потреби окремо імпортувати перетворення в вашу програму.

Правило поля зору допомогає з модульним сприяттям. Коли ви читаєте код в файлі, єдині речі, що вам треба брати до уваги з інших файлів, це тільки те, що або імпортоване, або явно посилається через повністю кваліфіковане ім'я. Ця перевага щонайменьше така ж важлива для неявних, як і для явно написаного коду. Якщо неявні визначення отримали б ефект в маштабах системи, тоді для розуміння файла вам би знадобилось знати щодо кожного неявного перетворення, визначеного будь-де в програмі!

*Правило один-за-раз: буде вставлене тільки одне неявне перетворення.* Компілятор ніколи не буде переписувати `x + y` до `convert1(convert2(x)) + y`. Якщо робити це, час компіляції драматично збільшиться для помилкового коду, та це збільшить різницю між тим, що пише програміст, та що програма насправді робить. Заради збереження здорового глузду, компілятор не вставляє подальші неявні перетворення, коли він вже на середині спроби іншого неявного перетворення. Однак можливо обійти це обмеження, маючи неявні перетворювачі, що приймають неявні параметри, які будуть описані пізніше в цій главі.

*Правило явні-перші: якщо код проходить перевірку типів як він є, жодні неявні не будуть спробувані.* Компілятор не буде змінювати код, що вже робить. Наслідок з цього правила є такий, що ви завжди можете замінити неявні ідентифікатори на явні, таким чином роблячи код довшим, але з менш вірогідною двозначністю. Ви можете балансувати між ціма виборами на основі випадку-до-випадка. Кожного разу, коли ви бачите код, що виглядає повторюваним та балакучим, неявні перетворення можуть допомогти зменшити нудьгу. Кожного разу, коли ви бачите, що код виглядає скороченим до точки незрозумілості, ви можете вставити явні перетворення. Кількість неявних перетворень, що ви залишите для вставки компілятором, кінець кінцем є предметом стилю.

Іменування неявного перетворення
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Неявні перетворення можуть мати довільні імена. Ім'я неявного перетворення має значення тільки в двох ситуаціях: якщо ви бажаєте написати його явно в застосуванні метода, та для визначення, які перетворення доступні в любій точці програми. Щоб проілюструвати другу точку, скажімо, ви маєте об'єкт з двома неявними перетвореннями:
[source,scala]
----
object MyConversions {
  implicit def stringWrapper(s: String):
    IndexedSeq[Char] = ...
  implicit def intToString(x: Int): String = ...
}
----
В вашому застосуванні ви бажаєте використати перетворення `stringWrapper`, але ви не бажаєте, щоб цілі автоматично перетворювались на рядки за допомогою `intToString`. Ви можете досягти цього через імпорт тільки одного перетворення, але не іншого:
[source,scala]
----
import MyConversions.stringWrapper
... // код, що використовує stringWrapper
----
В цьому прикладі було важливо, щоб неявні перетворення мали імена, оскільки тільки таким чином ви вибірково імпортуєте одні, та не імпортуєте інші.

Де будуть спробувані неявні декларації 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Існує три місця, де в мові використовуються неявні декларації: перетворення до очікуваного типу, перетворення отримувача вибору, та неявні параметри. Неявні перетворення до очікуваного типу дозволяють вам використовувати один тип в контексті, де очікуєтья інший тип. Наприклад, ви можете мати `String`, та бажати передати його в метод, що потребує `IndexedSeq[Char]`. Перетворення отримувача дозволяє вам адаптувати отримувач виклику метода (тобто об'єкт, на якому викликається метод), якщо метод не застосований на оригінальному типі. Прикладом є `"abc".exists`, що конвертований до `stringWrapper("abc").exists`, оскільки метод `exists` не доступний на `String`, але доступний на `IndexedSeq`. Неявні параметри, з іншого боку, звичайно використовуються для провадження додаткової інформації до викликаної функції, щодо того, що хоче викликач. Неявні параметри особливо корисні з дженерік функціями, коли визивана функція може інакше взагалі нічого не знати щодо типів одного або більше аргументів. Ми будемо досліджувати кожний з ціх трьох різновидів неявних в наступніх розділах.

21.3 Неявні перетворення до очікуваного типу
--------------------------------------------
Неявне перетворення до очікуваного типу є перше місце, де компілятор буде використовувати неявні. Це правило просте. Кожного разу, коли компілятор бачить `X`, але потребує `Y`, він буде шукати `implicit` функцію, що конвертує `X` до `Y`. Наприклад, звичайно число подвійної точності не може бути використане як ціле, бо воно втратить точність:
[source,scala]
----
scala> val i: Int = 3.5
<console>:7: error: type mismatch;
  found   : Double(3.5)
  required: Int
        val i: Int = 3.5
                     ^
----
Однак ви можете визначити неявне перетворення, щоб згладити це питання:
[source,scala]
----
scala> implicit def doubleToInt(x: Double) = x.toInt
doubleToInt: (x: Double)Int

scala> val i: Int = 3.5
i: Int = 3
----
Що тут відбувається, це коли компілятор бачить `Double`, зокрема `3.5`, в контексті де має бути `Int`. Доки компілятор бачить тільки звичайну помилку типу. Однак перед тим як здатись, він шукає неявне перетворення від `Double` до `Int`. В цьому випадку він знаходить таке: `doubleToInt`, оскільки `doubleToInt` є в полі зору як єдиний ідентифікатор. (За межами інтерпретатора ви можете занести `doubleToInt` в поле зору через імпорт, або, можливо, через наслідування). Потім компілятор автоматично вставляє виклик до `doubleToInt`. За лаштунками код стає такий:
[source,scala]
----
val i: Int = doubleToInt(3.5)
----
Це буквально _неявне_ перетворення. Ви явно не просили про перетворення. Замість цього ви відмітили `doubleToInt` як доступне неявне перетворення, через занесення його в поле зору як єдиний ідентифікатор, та потім компілятор автоматично використовує його коли треба для конвертації від `Double` до `Int`.

Конвертація `Double` до `Int` може декого здивувати, оскільки є сумнівною ідеєю мати дещо, що спричиняє втрату точності, що відбувається невидимо. Так що це насправді не те перетворення, яке ми рекомендуємо. Це має значно більше сенсу, якщо пійти в зворотньому напрямку, від якогось більш обмеженого типу до більш загального. Наприклад, `Int` може бути конвертований без страти точності на `Double`, так що неявне перетворення від `Int` до `Double` має сенс. Фактично, це саме те, що відбувається. Об'єкт `scala.Predef`, що неявно імпортований в кожну Scala програму, визначає неявне перетворення, що конвертує "меньші" числові типи на "більші". Наприклад, ви знайдете в `Predef` наступне перетворення:
[source,scala]
----
implicit def int2double(x: Int): Double = x.toDouble
----
Ось чому в Scala значення `Int` може бути збережене в змінних типу `Double`. Для цього немає особливого правила в системі типів; це просто неявне перетворення, що застосовується при нагоді.footnote:[Однак бекенд Scala компілятора буде трактувати перетворення особливим чином, транслюючи його в особливий байткод `i2d`. Так що скомпільований образ буде такий самий, як в Java.]

21.4 Перетворення отримувача
----------------------------
Неявні перетворення також застосовуються до отримувача виклику метода, об'єкт, на якому викликається метод. Цей різновид неявного перетворення має два головні застосування. Перше, перетворення отримувача дозволяє гладшу інтеграцію нових класів в існуючу ієрархію класів. Та друге, вони підтримують написання домен-специфічних мов (DSL) всередині мови.

Щоб побачити, як це робить, уявімо, що ви пишете `obj.doIt`, та `obj` не має члена на ім'я `doIt`. Компілятор буде намагатись вставити перетворення, перед тим як здатись. В цьому випадку перетворення треба застосувати до отримувача `obj`. Компілятор буде діяти так, якби очікуваний "тип" `obj` мав член на ім'я `doIt`. Цей "має `doIt`" тип не є звичайним типом Scala, але концептуально він тут, і ось чому компілятор буде вставляти неявне перетворення в цьому випадку.

Взаємодія з новими типами
~~~~~~~~~~~~~~~~~~~~~~~~~
Як вже зазначалось перед цім, одне головне застосування конвертації отримувача є дозволити гладшу інтеграцію нових типів з існуючими типами. Зокрема, вони дозволяють вам дозволити програмістам клієнтів використовувати примірники існуючих типів, так, якби вони були би примірниками нових типів. Візьмемо, наприклад, клас `Rational`, показаний в Лістингу 6.5. Ось фрагмент цього класу:
[source,scala]
----
class Rational(n: Int, d: Int) {
...
  def + (that: Rational): Rational = ...
  def + (that: Int): Rational = ...
}
----
Клас `Rational` має два перевантажені варіанта метода `+`, що приймає `Rational` та `Int`,відповідно, в якості аргументів. Так що ви можете або додавати раціональні числа, або раціональне та ціле:
[source,scala]
----
scala> val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2

scala> oneHalf + oneHalf
res0: Rational = 1/1

scala> oneHalf + 1
res1: Rational = 3/2
----
Як щодо виразів, як `1 + oneHalf`? Цей вираз хитрий, оскільки отримувач, `1`, не має підходящого метода `+`. Так що наступне дасть помилку:
[source,scala]
----
scala> 1 + oneHalf
<console>:6: error: overloaded method value + with
alternatives (Double)Double <and> ... cannot be applied
to (Rational)
      1 + oneHalf
        ^
----
Щоб дозволити цей різновид змішаної арифметики, вам треба визначити неявне перетворення від `Int` до `Rational`: 
[source,scala]
----
scala> implicit def intToRational(x: Int) =
new Rational(x, 1)
intToRational: (x: Int)Rational
----
Коли це перетворення на місці, конвертація отримувача робить цей трюк:
[source,scala]
----
scala> 1 + oneHalf
res2: Rational = 3/2
----
Що тут відбувається за лаштунками сцени, це те, що компілятор Scala спочатку намагається перевірити тип варазу  `1 + oneHalf` як він є. Це схибить, оскільки `Int` має декілька методів `+`, але жодного, що приймає аргумент `Rational`. Далі, компілятор шукає неявне перетворення від `Int` до іншого типу, що має метод `+`, який може бути застосований до `Rational`. Він находить ваше перетворення, та застосовує його, що дає таке:
[source,scala]
----
intToRational(1) + oneHalf
----
В цьому випадку компілятор знайшов функцію неявного перетворення, оскільки ви ввели його визначення в інтерпретатор, що занесло його поле зору до кінця сессії інтерпретатора.

Симуляція нового синтаксису
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Інше головне застосування неявних перетворень це симуляція додавання нового синтаксису. Згадайте, що ви можете створити `Map`, використовуючи такий синтаксис:
[source,scala]
----
Map(1 -> "one", 2 -> "two", 3 -> "three")
-----
Чи ви не здивувались, як підтримується `->`? Це не синтаксис! Замість цього `->` є методом класу `ArrowAssoc`, класу, визначеного в стандартній преамбулі Scala (`scala.Predef`). Преамбула також визначає неявне перетворення з `Any` до `ArrowAssoc`. Коли ви пишете `1 -> "one"`, компілятор вставляє перетворення від `1` до `ArrowAssoc` так що метод `->` може бути знайдений. Ось відповідні визначення:
[source,scala]
----
package scala

object Predef {
  class ArrowAssoc[A](x: A) {
    def -> [B](y: B): Tuple2[A, B] = Tuple2(x, y)
  }
  implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] =
    new ArrowAssoc(x)
...
}
----
Цей шаблон "багатих огорток" загальний в бібліотеках, що провадять до мови синтаксо-подібні розширення, так що ви повинні бути готові розпізнати шаблон, коли ви бачите його. Кожного разу, коли ви бачите ,як дехто викликає методи, що не існують в класі отримувачі, вони вірогідно використовують неявні перетворення. Подібно до цього, якщо ви бачите клас, названий `RichSomething` (тобто, `RichInt` або `RichBoolean`), виглядає що цей клас додає синтакс-подібні методи до типу `Something`.

Ви вже бачили цей шаблон багатих огорток для базових типів, описаних в Главі 5. Як ви можете бачити, ці багаті огортки застосовуються більш широко, часто дозволяючи вам отримати внутрішінй DSL, визначений як бібліотека, коли програмісти на інших мовах відчувають потребу в зовнішньому DSL.

Неявні класи
------------
Неявні класи були додані в Scala 2.10, щоб спростити написання багатих класів огорток. Неявний клас є клас, перед яким стоїть ключове слово `implicit`. Для любого такого класу компілятор генерує неявне перетворення від параметру конструктора класу до самого класу. Таке перетворення є саме тим, що вам треба, якщо ви плануєте використовувати клас для шаблону багатих огорток.

Наприклад, уявімо, що ви маєте клас на ім'я `Rectangle` для представлення ширини та висоти прямокутника на екрані:
[source,scala]
----
case class Rectangle(width: Int, height: Int)
----
Якщо ви використовуєте цей клас дуже часто, ви можете побажати використати шаблон багатої огортки, так щоб ви могли конструювати його більш просто. Ось один спосіб зробити це.
[source,scala]
----
implicit class RectangleMaker(width: Int) {
  def x(height: Int) = Rectangle(width, height)
}
----
Визначення вище визначає клас `RectangleMaker` в звичайній манері. На додаток, він спричиняє автоматичну генерацію наступного перетворення:
[source,scala]
----
// Автоматично згенеровано
implicit def RectangleMaker(width: Int) =new RectangleMaker(width)
----
Як результат, ви можете створити точки через покладання `x` між двома цілими:
[source,scala]
----
scala> val myRectangle = 3 x 4
myRectangle: Rectangle = Rectangle(3,4)
----
Ось як це робить: оскільки тип `Int` не має метода на ім'я `x`, компілятор буде шукати неявне перетворення від `Int` до чогось, що має. Він знайде згенероване перетворення `RectangleMaker`, та `RectangleMaker` має метод на ім'я `x`. Компілятор вставляє виклик для цього перетворення, після чого виклик `x` проходить перевірку типів, і робить те, що задумане.

Як засторога для відчайдушних, може бути спокусливо думати, що кожний клас може мати поставлений перед собою `implicit`. Це не так. Неявний клас не може бути кейс класом, та його конструктор повинен мати рівно один параметр. Також неявний клас мусить розміщуватись в деякому іншому об'єкті, класі або трейті. На практиці, доки ви використовуєте неявні класи як багаті огортки для додавання нових методів в існуючі класи, ці обмеження не повинні мати значення.

21.5 Неявні параметри
---------------------
Останнє місце, де компілятор вставляє неявні, є спискі аргументів. Компілятор буде іноді замінювати `someCall(a)` на `someCall(a)(b)`, або `new SomeClass(a)` на `new SomeClass(a)(b)`, таким чином додаючи відсутній список параметрів для завершення виклику функції. Те, що додається є цілим останнім карованим списком параметрів, не просто останній параметр. Наприклад, якщо `someCall` не вистачає останнього списку параметрів, що приймає три параметра, компілятор може замінити `someCall(a)` на `someCall(a)(b, c, d)`. Для цього використання не просто вставлені ідентифікатори, такі як `b`, `c`, та `d` в `(b, c, d)`, бути відмічені як неявні там, де вони визначені, але також останній список параметрів в  визначенні `someCall` або `someClass` має бути маркований як `implicit`.

Ось простий приклад. Уявімо, що ви маєте клас `PreferredPrompt`, що енкапсулює рядок підказки оболонки (такий як, скажімо `"$ "` або `"> "`), який обирає користувач:
[source,scala]
----
class PreferredPrompt(val preference: String)
----
Також, уявімо, ви маєте об'єкт `Greeter` з методом `greet`, що приймає два списка параметрів. Перший список параметрів приймає ім'я користувача як рядок, та другий список параметрів приймає `PreferredPrompt`:
[source,scala]
----
object Greeter {
  def greet(name: String)(implicit prompt: PreferredPrompt) = {
    println("Welcome, " + name + ". The system is ready.")
    println(prompt.preference)
  }
}
----
Останній список параметрів відмічений як `implicit`, що означає, що він може бути наданий неявно. Але ви можете все ще провадити підказку явно, ось так:
[source,scala]
----
scala> val bobsPrompt = new PreferredPrompt("relax> ")
bobsPrompt: PreferredPrompt = PreferredPrompt@714d36d6scala> 
Greeter.greet("Bob")(bobsPrompt)
Welcome, Bob. The system is ready.
relax>
----
Щоб дозволити компілятору надавати параметр неявно, вам треба зпочатку визначити змінну очікуваного типу, що в цьому випадку є `PreferredPrompt`. Ви можете зробити це, наприклад, в об'єкті користувацькіх налаштувань:
[source,scala]
----
object JoesPrefs {
  implicit val prompt = new PreferredPrompt("Yes, master> ")
}
---- 
Зауважте, що сама `val` відмічена як `implicit`. Якщо ні, компілятор не буде використовувати її для надання відсутнього списку параметрів. Він також не буде використовувати її, якщо вона не в полі зору як єдиний ідентифікатор, як показано в цьому прикладі:
[source,scala]
----
scala> Greeter.greet("Joe")
<console>:13: error: could not find implicit value for
parameter prompt: PreferredPrompt
              Greeter.greet("Joe")
                           ^
----
Однак коли ви занесете її в поле зору через імпорт, вона буде використана для надання відсутнього списку параметрів:
[source,scala]
----
scala> import JoesPrefs._
import JoesPrefs._

scala> Greeter.greet("Joe")
Welcome, Joe. The system is ready.
Yes, master>
----
Зауважне, що ключове слово `implicit` стосується до цілього списку параметрів, не до індивідуальних параметрів. Лістинг 21.1 показує приклад, в якому останній список параметрів метода `Greeter` `greet`, що знову визначений `implicit`, має два параметри: `prompt` (типу `PreferredPrompt`), та `drink` (типу `PreferredDrink`).

Об'єкт синглтон `JoesPrefs` декларує дві неявні `val`, `prompt` типу `PreferredPrompt`, та `drink` типу `PreferredDrink`. Однак як і раніше, доки воні не в полі зору як прості ідентифікатори, вони не будуть використані для заповнення відсутнього списку параметрів для `greet`:
[source,scala]
----
scala> Greeter.greet("Joe")
<console>:19: error: could not find implicit value for
parameter prompt: PreferredPrompt
              Greeter.greet("Joe")
                           ^
----
Ви можете занести обі неявні `val` в поле зору за допомогою `import`:
[source,scala]
----
scala> import JoesPrefs._
import JoesPrefs._
----
Оскільки обоє, `prompt` та `drink` тепер в полі зору як єдині ідентифікатори, ви можете використовувати їх для явного надання останнього списку параметрів, ось так:
[source,scala]
----
scala> Greeter.greet("Joe")(prompt, drink)
Welcome, Joe. The system is ready.
But while you work, why not enjoy a cup of tea?
Yes, master>
----
Але оскільки тепер задовільняються всі правила для неявних параметрів, альтернативно ви можете дозволити компілятору Scala надати `prompt` та `drink` для вас, відкинувши останній список параметрів:
[source,scala]
----
scala> Greeter.greet("Joe")
Welcome, Joe. The system is ready.
But while you work, why not enjoy a cup of tea?
Yes, master>

class PreferredPrompt(val preference: String)
class PreferredDrink(val preference: String)

object Greeter {
  def greet(name: String)(implicit prompt: PreferredPrompt,
      drink: PreferredDrink) = {
    
    println("Welcome, " + name + ". The system is ready.")
    print("But while you work, ")
    println("why not enjoy a cup of " + drink.preference + "?")
    println(prompt.preference)
  }
}

object JoesPrefs {
  implicit val prompt = new PreferredPrompt("Yes, master> ")
  implicit val drink = new PreferredDrink("tea")
}
----
Лістинг 21.1 - Неявний список параметрів з декількома параметрами.

Одна річ, яку треба відмітити щодо попередніх прикладів, є те, що ми не використовуємо `String` як тип для `prompt` або `drink`, навіть якщо кінець кінцем це буде `String`, що отримають обоє через поля `preference`. Оскільки компілятор обирає неявні параметри через порівняння типів параметрів з типами змінних в полі зору, неявні параметри звичайно мають досить "рідкі" або "специфічні" типи, щоб зробити випадкове співпадіння маловірогідним. Наприклад, типи `PreferredPrompt` та `PreferredDrink` в Лістингу 21.1 були визначені єдино служити як типи неявних параметрів. Як результат, маловірогідно, що неявні змінні ціх типів будуть в полі зору, якщо вони не призначені для використання як неявні параметри для `Greeter.greet`.

Інша річ, що треба знати щодо неявних параметрів, є те, що вони найбільш часто використовуються для провадження інформації щодо типу, вказаного _явно_ в ранішньому списку пармаетрів, подібно до класів типу в Haskell.

Як приклад, розглянемо функцію `maxListOrdering`, показану в Лістингу 21.2, що повертає максимальний елемент переданого списку.
[source,scala]
----
def maxListOrdering[T](elements: List[T])
      (ordering: Ordering[T]): T =
  elements match {
    case List() =>
      throw new IllegalArgumentException("empty list!")
    case List(x) => x
    case x :: rest =>
      val maxRest = maxListOrdering(rest)(ordering)
      if (ordering.gt(x, maxRest)) x
      else maxRest
}
----
Лістинг 21.2 - Функція з верхньою межею.

Сигнатура `maxListOrdering` подібна до `orderedMergeSort`, показаного в Лістингу 19.12: він приймає `List[T]` в якості аргумента, але зараз він приймає додатковий аргумент типу `Ordering[T]`. Цей додатковий аргумент специфікує, який `ordering` використовувати при порівнянні елементів типу `T`. Як така, ця версія може бути використана для типів, що не мають вбудованого спорядкування. Додатково, ця версія може бути використана для типів, що мають вбудоване впорядкування, але для яких ви час від часу бажаєте викорстовувати деякий інший порядок.

Ця версія більш загальна, але вона також більш заплутана в використанні. Тепер викликач має вказувати явний порядок, навіть якщо `T` щось подібне до `String` або `Int`, що має явно визначений порядок. Щоб зробити цей новий метод більш зручним, допоможе зробити другий аргумент неявним. Цей підхід показаний в Лістингу 21.3.

Параметр `ordering` в цьому прикладі використаний для описання впорядкування `T`. В тілі `maxListImpParm` цей `ordering` використовується в двох місцях: в рекурсивному виклику до `maxListImpParm`, та виразі `if`, що перевіряє, що голова цього списку більша, ніж максимальний елемент в залишку списка.
[source,scala]
----
def maxListImpParm[T](elements: List[T])
      (implicit ordering: Ordering[T]): T =

  elements match {
    case List() =>
      throw new IllegalArgumentException("empty list!")
    case List(x) => x
    case x :: rest =>
      val maxRest = maxListImpParm(rest)(ordering)
      if (ordering.gt(x, maxRest)) x
      else maxRest
  }
----
Лістинг 21.3 - Функція з неявним параметром.

Функція `maxListImpParm` є прикладом неявного параметра, використаного для провадження додаткової інформації щодо типу, явно вказаного в попередньому списку параметрів. Більш точно, неявний параметр `ordering` типу `Ordering[T]` провадить більше інформації щодо типу T — в цьому випадку як впорядковувати `T`. Тип `T`, згаданий в `List[T]` як параметр типу елементів, з'являється в попередньому списку параметрів. Оскільки елементи мають завжди бути проваджені явно в любому виклику до `maxListImpParm`, компілятор буде знати `T` під час компіляції, і, таким чином, може визначити, чи доступне неявне визначення типу `Ordering[T]`. Якщо це так, він може передати другий список параметрів, `ordering`, неявно.

Цей шаблон такий загальний, що стандартна бібліотека Scala провадить неявні методи `ordering` для багатьох загальних типів. Таким чином ви можете використовувати цей метод `maxListImpParm` з різними типами:
[source,scala]
----
scala> maxListImpParm(List(1,5,10,3))
res9: Int = 10

scala> maxListImpParm(List(1.5, 5.2, 10.7, 3.14159))
res10: Double = 10.7

scala> maxListImpParm(List("one", "two", "three"))
res11: String = two
----
В першому випадку компілятор вставляє `ordering` для `Int`; в другому випадку для `Double`; в третьому випадку для `String`.

Правило стиля для неявних параметрів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Як правило стилю, є кращим використовувати власні імена типів в типах неявних параметрів. Наприклад, типи `prompt` та `drink` в попередньому прикладі не були `String`, але  `PreferredPrompt` та `PreferredDrink`, відповідно. Як контрприклад розглянемо функцію `maxListImpParm`, що може так само бути написаний з наступною сигнатурою типу:
[source,scala]
----
def maxListPoorStyle[T](elements: List[T])
      (implicit orderer: (T, T) => Boolean): T
----
Однак щоб використати цю версію функції, викликач має надати параметр `orderer` типу `(T, T) => Boolean`. Це досить загальний тип, що включає любу функцію з двох `T` до `Boolean`. Він зовсім нічого не вказує щодо того, для чого призначений цей тип; він може бути перевіркою на рівність, перевіркою на менше-ніж, перевіркою на більше-ніж, або повністю чимось іншим.

Справжній код для `maxListImpParm`, наданий в Лістингу 21.3, показує кращий стиль. Він використовує параметр `ordering` типу `Ordering[T]`. Слово `Ordering` в цьому типі точно вказує, для чого призначений неявний параметр: він призначений для впорядкування елементів `T`. Оскільки цей тип `ordering` більш явний, немає проблем з додаванням неявних провайдерів для цього типу в стандартній бібліотеці. Для контрасту, уявіть хаос, що настав би, якщо б ви додали неявний тип `(T, T) => Boolean` в стантартну бібліотеку, і компілятор почав би зрошувати їм людський код. Ви б скінчили з кодом, що компілюється та виконується, але що робить досить довільні тести з парами елементів! Від цього випливає правило стилю: використовуйте щонайменьше одне роль-визначаюче ім'я в типі неявного параметру.

21.6 Межі контексту
-------------------
Попередній приклад мав показати можливості використання неявних, але ні. Зауважте, що коли ви застосовуєте неявне як параметр, не тільки компілятор спробує надати цей параметр через неявне значення, але компілятор також буде використовувати цей параметр як доступне неявне в тілі метода!

Таким чином, перше використання `ordering` в тілі метода може бути відкинуте.
[source,scala]
----
def maxList[T](elements: List[T])
      (implicit ordering: Ordering[T]): T =

  elements match {
    case List() =>
      throw new IllegalArgumentException("empty list!")
    case List(x) => x
    case x :: rest =>
      val maxRest = maxList(rest)    // (ordering) неявне
      if (ordering.gt(x, maxRest)) x // але це ordering
      else maxRest                   // все ще явне
}
----
Лістинг 21.4 - Функція, що використовує неявний параметр внутрішньо.

Коли компілятор перевіряє код в Лістингу 21.4, він буде бачити, що типи не співпадають. Вираз `maxList(rest)` надає тільки один список параметрів, але `maxList` потребує два. Оскільки другий список параметрів є неявний, компілятор не здається зразу після перевірки типів. Замість цього він шукає неявний параметр відповідного типу, в цьому випадку `Ordering[T]`. В цьому випадку він находить такий, та переписує виклик на `maxList(rest)(ordering)`, після чого код проходить перевірку типів.

Є також спосіб уникнути другого використання `ordering`. Він задіє наступний метод, визначений в стандартній бібліотеки:
[source,scala]
----
def implicitly[T](implicit t: T) = t
----
Ефект виклику `implicitly[Foo]` в тому, що компілятор буде шукати неявне визначення типу `Foo`. Потім він буде викликати неявний метод з цім об'єктом, що, в свою чергу, повертає назад об'єкт. Таким чином ви можете записати `implicitly[Foo]` кожного разу, коли ви бажаєте найти неявний об'єкт типу `Foo` в поточньому полі зору. Наприклад, Лістинг 21.5 показує використання `implicitly[Ordering[T]]` для отримання параметра `ordering` по його типу.

Подивіться уважніше на цю останню версію `maxList`. Тут немає жодного спомину параметру `ordering` в тексті метода. Другий параметр може так само бути названий `comparator`:
[source,scala]
----
def maxList[T](elements: List[T])
  (implicit comparator: Ordering[T]): T = // те саме тіло...

  def maxList[T](elements: List[T])
        (implicit ordering: Ordering[T]): T =

    elements match {
      case List() =>
        throw new IllegalArgumentException("empty list!")
      case List(x) => x
      case x :: rest =>
        val maxRest = maxList(rest)
        if (implicitly[Ordering[T]].gt(x, maxRest)) x
        else maxRest
    }
----
Лістинг 21.5 - Функція, що використовує `implicitly`.

З цієї причини ця версія бути робити так само:
[source,scala]
----
def maxList[T](elements: List[T])
(implicit iceCream: Ordering[T]): T = // тіло те саме...
----
Оскільки цей шаблон є загальним, Scala дозволяє вам пропустити ім'я цього параметру, та скоротити заголовок метода через використання межі контексту. Використання межі контексту дозволяє вам записати сигнатуру `maxList` як показано на Лістингу 21.6. Синтаксис `[T : Ordering]` є межою контексту, і він робить дві речі. Перше, він вводить параметр типу `T`, як звичайно. Друге, він додає неявний параметр типу `Ordering[T]`. В попередніх версіях `maxList`, цей параметр був названий `ordering`, але коли використовується межа контексту, ви не знаєте, що викликається параметром. Як показано раніше, часто вам не треба знати, що викликається параметром.

Інтуітивно ви можете думати про межу контаксту, як сказати дещо про параметр типу. Коли ви пишете `[T <: Ordered[T]]` ви кажете, що `T` є `Ordered[T]`. Для контрасту, коли ви пишете `[T : Ordering]` ви не кажете багато про те, що є `T`; скоріше, ви кажете, що існує деяка форма впорядкування, асоційована з `T`. Таким чином межа контексту досить гнучка. Це дозволяє вам використовувати код, що потребує впорядкування — або любу іншу властивість типу — без потреби змінювати визначення цього типу.
[source,scala]
----
def maxList[T : Ordering](elements: List[T]): T =
  elements match {
    case List() =>
      throw new IllegalArgumentException("empty list!")
    case List(x) => x
    case x :: rest =>
      val maxRest = maxList(rest)
      if (implicitly[Ordering[T]].gt(x, maxRest)) x
      else maxRest
  }
----  
Лістинг 21.6 - Функція з межею контекста.

21.7 Коли застосовуються декілька конверсій
-------------------------------------------
Може трапитись, що в полі зору знаходяться декілька неявних перетворень, і кожне може робити. В великій мірі Scala відмовляється вставляти перетворення в такому випадку. Неявні роблять гарно, коли перетворення, що відкидається, повністю очевидне та чистий шаблон. Якщо застосовуються декілька перетворень, вибір вже не такий і очевидний, кінець кінцем.

Ось простий приклад. Існує метод, що приймає послідовність, перетворення, що обертає ціле на диапазон, та перетворення, що обертає ціле на список цифр:
[source,scala]
----
scala> def printLength(seq: Seq[Int]) = println(seq.length)
printLength: (seq: Seq[Int])Unit

scala> implicit def intToRange(i: Int) = 1 to i
intToRange: (i:
Int)scala.collection.immutable.Range.Inclusive

scala> implicit def intToDigits(i: Int) =
i.toString.toList.map(_.toInt)
intToDigits: (i: Int)List[Int]

scala> printLength(12)
<console>:26: error: type mismatch;
found   : Int(12)
required: Seq[Int]
Note that implicit conversions are not applicable because
they are ambiguous:
  both method intToRange of type (i:
Int)scala.collection.immutable.Range.Inclusive
  and method intToDigits of type (i: Int)List[Int]
  are possible conversion functions from Int(12) to Seq[Int]
               printLength(12)
                           ^
----
Неоднозначність тут є реальною. Перетворення цілого на послідовність цифр повністю відрізняється від перетворення його на диапазон. В цьому випадку програміст має вказати, який варіант потрібен, та бути явним. До Scala 2.7 це було кінцем історії. Кожного разу, коли застосовуються декілька неявних перетворень, компілятор відмовляється обирати між ними. Ситуація була така сама, що і з перевантаженням методів. Якщо ви спробуєте викликати `foo(null)`, і є два різні перевантаження `foo`, що приймають `null`, компілятор відмовиться обирати. Він скаже, що ціль виклику метода неоднозначна.

Scala 2.8 послаблює це правило. Якщо одне з доступних перетворень явно більш специфічне, ніж інші, тоді компілятор буде обирати більш специфічний варіант. Ідея в тому, що коли є причина повірити програмісту, що маємо завжди обирати один перетворювач ніж інші, не вимагати від програміста записувати це явно. Кінець кінцем, перевантаження методів має те саме послаблення. Продовжуючи попередній приклад, якщо один з доступних методів `foo` приймає `String`, тоді як інший приймає `Any`, тоді буде обрана версія з `String`. Це вочевидь більш специфічне.

Щоб бути більш точним, неявне перетворення є більш специфічним, якщо відбувається одне з наступного:

* Тип аргументу першого є субтипом другого.
* Обоє перетворення є методами, та оточуючий клас першого розширює оточуючий клас другого.

Мотивацією для перегляду цього питання та ревізії правила було покращення взаємодії між Java колекціями, Scala колекціями, та рядками.

Ось простий приклад:
[source,scala]
----
val cba = "abc".reverse
----
Який тип, що буде виведений для `cba`? Інтуітивно, типом має бути `String`. Реверс рядка має давати рядок, вірно? Однак в Scala 2.7 відбувається те, що `"abc"` було перетворене на Scala колекцію. Реверс Scala колекції дає Scala колекцію, так що тип `cba` має бути колекцією. Також є неявне перетворення назад до рядка, але це не латає жодних проблем. Наприклад, в версії до Scala 2.8 `"abc" == "abc".reverse.reverse` було `false`!

В Scala 2.8 тип `cba` є `String`. Старе неявне перетворення до Scala колекції (тепер названої `WrappedString`) залишилось. Однак тепер є більш специфічне перетворення, від  `String` до нового типу, названого `StringOps`. `StringOps` має багато методів, таких як `reverse`, але замість повернення колекцій вони повертають `String`. Перетворення до `StringOps` визначено напряму в `Predef`, тоді як перетворення до Scala колекцій визначено в новому класі, `LowPriorityImplicits`, що розширений `Predef`. Коли існує вибір між ціма двома перетвореннями, компілятор обере перетворення до `StringOps`, оскільки він визначений в субкласі класу, де визначене інше перетворення.

21.8 Зневадження неявних
------------------------
Неявні є потужною можливістю в Scala, але те, що іноді важко зрозуміти. Цей розділ містить декілька підказок зі зневадження неявних.

Іноді ви можете дивуватись, чому компілятор не знайшов неявне перетворення, яке, як ви сподівались, мало б бути застосоване. В такому випадку допоможе записати це перетворення явно. Якщо  це також видає повідомлення про помилку, тоді ви знатимете, чому компілятор не застосував ваше неявне.

Наприклад, уявімо, що ви помилково взяли `wrapString` в якості перетворення від `Strings`  до `List`, замість `IndexedSeqs`. Ви можете здивуватись, чому наступний код не робить:
[source,scala]
----
scala> val chars: List[Char] = "xyz"
<console>:24: error: type mismatch;
found   : String("xyz")
required: List[Char]
      val chars: List[Char] = "xyz"
                              ^
----                              
Знову, допоможе написати перетворення `wrapString` явно, щоб знайти, що іде не так:
[source,scala]
----
scala> val chars: List[Char] = wrapString("xyz")
<console>:24: error: type mismatch;
found   : scala.collection.immutable.WrappedString
required: List[Char]
      val chars: List[Char] = wrapString("xyz")
                                        ^
----                                        
Маючи це, ви знаходите те що спричинило помилку: `wrapString` має помилковий тип повернення. З іншого боку, також можливо, що явне вставлення перетворення призведе до зникнення помилки. В цьому випадку ви знаєте, що одне з інших правил (таке як Правило поля зору) перешкоджає застосуванню неявного перетворення.

Коли ви зневаджуєте програму, іноді може допомогти побачити, яке неявне перетворення вставляє компілятор. Для цього корисна опція компілятора `-Xprint:typer`. Якщо ви виконуєте `scalac` з цією опецією, компілятор буде показувати вам, як буде виглядати код після всіх неявних перетворень, що були додані перевіркою типів. Приклад показаний в Лістингу 21.7 та Лістингу 21.8. Якщо ви подивитесь на останній вираз в кожному лістингу, ви побачите, що другий список параметрів `enjoy`, що випущений в коді Лістинга 21.7, `enjoy("reader")` був доданий компілятором, як показано в Лістингу 21.8:
[source,scala]
----
Mocha.this.enjoy("reader")(Mocha.this.pref)
----
Якщо ви хоробрий, спробуйте `scala -Xprint:typer` щоб отримати інтерактивну оболонку, що роздруковує пост-типізований код, що використовується внутрішньо. Якщо ви зробите це, будьте готові побачити величезну кількість шаблонного обвісу, що оточує м'ясо вашого коду.
[source,scala]
----
object Mocha extends App {

  class PreferredDrink(val preference: String)

  implicit val pref = new PreferredDrink("mocha")

  def enjoy(name: String)(implicit drink: PreferredDrink) = {
    print("Welcome, " + name)
    print(". Enjoy a ")
    print(drink.preference)
    println("!")
  }
}
enjoy("reader")
----
Лістинг 21.7 - Код прикладу, що використовує неявний параметр.

[source,scala]
----
$ scalac -Xprint:typer mocha.scala
[[syntax trees at end of typer]]
// Scala source: mocha.scala
package <empty> {
  final object Mocha extends java.lang.Object with Application
    with ScalaObject {

// ...

    private[this] val pref: Mocha.PreferredDrink =
     new Mocha.this.PreferredDrink("mocha");
    implicit <stable> <accessor>
      def pref: Mocha.PreferredDrink = Mocha.this.pref;
    def enjoy(name: String)
       (implicit drink: Mocha.PreferredDrink): Unit = {
      scala.this.Predef.print("Welcome, ".+(name));
      scala.this.Predef.print(". Enjoy a ");
      scala.this.Predef.print(drink.preference);
      scala.this.Predef.println("!")
    };
    Mocha.this.enjoy("reader")(Mocha.this.pref)
  }
}
----
Лістинг 21.8 - Код прикладу після перевірки типів та вставки `implicit`.

21.9 Висновок
-------------
Неявні є потужною, кодо-стискаючою можливістю Scala. Ця глава показала вам правила Scala щодо неявних, та декілька загальних програмних ситуацій, коли ви можете отримати вигоди від використання неявних. Як слово застереження, неявні можуть зробити код збентежливим, якщо ви використовуєте їх дуже часто. Таким чином, перед додаванням неявного перетворення, спочатку запитайте, чи ви можете досягти подібного ефекту через інші засоби, такі як наслідування, композиція міксінів або перевантаження методів. Однак якщо все це схибить, і ви відчуваєте, що більшість вашого коду досі нудна та зайва, тоді неявні можуть допомогти вам знайти вихід.
