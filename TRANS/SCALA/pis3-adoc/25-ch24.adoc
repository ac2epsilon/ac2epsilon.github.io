include::headers.adoc[]

Глава 24
--------

Колекції: докладно
==================

Scala включає елегантну та потужну бібліотеку колекцій. Навіть якщо вважати, що API колекцій тонкий на перший погляд, зміни, які він може спровокувати в вашому стилі програмування можуть бути грунтовними. Досить часто це так, якби ви робили на вищому рівні з базовими будівельними блоками програми, що є цілими колекціями, ніж їх елементами. Цей новий стиль програмування потребує деякої адаптації. Нащастя, адаптації допомагють декілька милих властивостей Scala колекцій. Вони прості в використанні, стислі, безпечні, швидкі та універсальні.

* *Простота в використанні:* Невеликого словника з двадцяти до сорока методів, досить для вирішення більшості проблем колекцій в парі операцій. Намає потреби огортати вашу голову кругом складних циклічних структур або рекурсій. Стійкі колекції вільні від операцій з побічними ефектами, що означає, що вам не треба хвилюватись про випадкове руйнування існуючих колекцій новими даними. Взаємодію між ітераторами та оновленнями колекцій ліквідовано.

* *Стислість:* Ви можете досягти за допомогою одного слова те, що раніше займало один або декілька циклів. Ви можете виразити функціональні операції за допомогою легковажного синтаксису та без зусиль комбінувати операції так що результат відчувається як власна алгебра.

* *Безпечність:* Щоб зрозуміти це, треба мати досвід. Статична типізація та функціональна природа Scala колекцій означає, що переважна більшість помилок, які ви можете зробити, відловлюються під час компіляції. Причини цього в тому, що (1) операції колекцій самі часто використовуються, і таким чином, гарно протестовані. (2) використання операцій з колекціями робить входи та виходи явними, як параметри функції та результати. (3) Ці явні входи та виходи є предметом перевірки статичних типів. Підсумок всього цього в тому, що велика більшість хибних використань будуть заявляти про себе як помилки типів. Взагалі не є рідкістю мати програми з декількох сотень рядків, що роблять з першої спроби.

* *Швидкість:* Операції з колекціями настроєні і оптимізовані в бібліотеках. Як результат, використання колекцій типово досить ефективне. Ви можете бути в змозі зробити все трохи краще, через уважно налаштовані структури даних та операції, але ви також можете зробити все значно гірше, по ходу справи прийнявши якісь неоптимальні рішення з реалізації. Більше того, колекції були адаптовані до паралельної виконання на декількох ядрах. Паралельні колекції підтримують ті самі операції, що і послідовні так що не треба вивчати нові операції та переписувати код. Ви можете перетворити послідовну колекцію в паралельну, просто викликавши метод `par`.

* *Універсальність:* Колекції провадять ті самі операції на любому типі, коли це має сенс робити. Так що ви можете багато чого досягти з досить малим словником операцій. Наприклад, рядок концептуально є послідовністю символів. Відповідно, в Scala колекціях рядок підтримує всі операції послідовностей. Те саме дійсне і для масивів.

Ця глава поглиблено описує API для класів колекцій Scala з перспективи користувача. Ви вже бачили швидкий тур по бібліотеці колекцій в Главі 17. Ця глава запрошує вас в більш детальний тур, показуючи всі класи колекцій, і всі методи, що вони визначають так що вона включає все, що вам треба знати для використання Scala колекцій. Дивлячись наперед, Глава 25 буде сконцентрована на архитектурі та аспектах розширюваності бібліотеки, для людей, що реалізують нови типи колекцій.

24.1 Змінні та незмінні колекції
--------------------------------
Як ви вже знаєте, Scala колекції систематично відрізняють змінні та незмінні колекції. Змінні колекції можуть бути оновлені або розширені на місці. Це означає, що ви можете змінювати, додавати, або видаляти елементи колекції як побічний ефект. Незмінні колекції, для контрасту, ніколи не змінюються. Ви все ще маєте операції, що симулюють додавання, видалення або оновлення, але ці операції будуть в любому випадку повертати нову колекцію та залишати стару колекцію незмінною.

Всі класи колекцій знаходяться в пакунку `scala.collection`, або одному з його субпакунків: `mutable`, `immutable` та `generic`. Більшість класів колекцій, що потрібні клієнтському коду, існують в трьох варіантах, кожний з яких має різні характеристики з точки зору змінності. Три варіанти розміщені в пакунках `scala.collection`, `scala.collection.immutable` та `scala.collection.mutable`.

Колекція в пакунку `scala.collection.immutable` гарантовано буде незмінною для будь-кого. Така колекція ніколи не буде змінюватись після її створення. Таким чином, ви можете покладатись на факт, що отримуєте доступ до значення тієї самої колекції постійно, і в різних точках часу будете завжди мати колекцію з тими самими елементами.

Колекція в пакунку `scala.collection.mutable` знана що має деякі операції, що змінюють колекцію на місці. Ці операції дозволяють вам писати код для зміни колекції самотужки. Однак ви маєте бути уважним, щоб розуміти та захищатись від любих оновлень, що виконують інші частини кодової бази.

Колекція в пакунку `scala.collection` може бути або змінною, або незмінною. Наприклад,`scala.collection.IndexedSeq[T]` є супертрейтом обох, `scala.collection.immutable.IndexedSeq[T]` та її родички, `scala.collection.mutable.IndexedSeq[T]`. Загалом, кореневі колекції в пакунку `scala.collection` визначають той самий інтерфейс, що і незмінні колекції. І типово, змінні колекції в пакунку `scala.collection.mutable` додають деякі модифікації з побічним ефектом до цього незмінного інтерфейсу.

Різниця між кореневими колекціями та незмінними колекціями в тому, що клієнти назмінних колекцій мають гарантію, що ніхто не може змінити колекцію, коли як клієнти кореневих колекцій знають тільки, що вони самі не можуть змінити колекцію. Навіть зважаючи, що статичний тип такої колекції не провадить операцій для модифікації колекції, все ще може бути можливим, щоб тип часу виконання був змінною колекцією, що може бути змінена іншими клієнтами.

По замовчанню Scala завжди обирає незмінні колекції. Наприклад, якщо ви просто пишете `Set` без жодного префіксу, або без імпорту будь-чого, ви отримаєте незмінну множину, і якщо ви напишете `Iterable`, ви отримаєте незмінне ітерабельне, оскільки ці прив'язки по замовчанню імпортуються з пакунка `scala`. Щоб отримати змінні версії по замовчанню, вам треба написати явно `collection.mutable.Set`, або `collection.mutable.Iterable`.

Останній пакунок в ієрархії колекцій є `collection.generic`. Цей пакунок містить будівельні блоки для реалізації колекцій. Типово, класи колекцій відкладають реалізації деяких зі своїх операцій до класів в `generic`. З іншого боку, щоденні користувачі фреймворку колекцій мають потребу посилатись на класи в `generic` тільки за виключних обставин.

Ієрархія колекцій.
~~~~~~~~~~~~~~~~~~
----
Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4
----            

24.2 Узгодженість колекцій
--------------------------
Найбільш важливі класи колекцій показані на Малюнку 24.1. Є досить загального, що поділяють ці класи. Наприклад, кожний різновид колекції може бути створений за однаковим уніформним синтаксисом, записуючи ім'я класу колекції, за яким ідуть його елементи:
[source,scala]
----
Traversable(1, 2, 3)
Iterable("x", "y", "z")
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(Color.Red, Color.Green, Color.Blue)
SortedSet("hello", "world")
Buffer(x, y, z)
IndexedSeq(1.0, 2.0)
LinearSeq(a, b, c)
----
Той самий принцип також стосується специфічних реалізацій колекцій:
[source,scala]
----
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)
----
Метод `toString` для всіх колекцій продукує вивід, записаний як вище, з іменем типу, за яким в дужках ідуть елементи колекції. Всі колекції підтримують API, що провадить `Traversable`, але їх методи всі повертають їх власний клас, скоріше ніж кореневий клас  `Traversable`. Наприклад, метод `map` на `List` має тип повернення `List`, тоді як метод `map` на `Set` має тип повернення `Set`. Таким чином, статичний тип повернення ціх методів досить точний:
[source,scala]
----
scala> List(1, 2, 3) map (_ + 1)
res0: List[Int] = List(2, 3, 4)

scala> Set(1, 2, 3) map (_ * 2)
res1: scala.collection.immutable.Set[Int] = Set(2, 4, 6)
----
Еквівалентність також організована одноманітно для всіх класів колекцій; більше про це в Розділі 24.13.

Більшість класів на Малюнку 24.1 існують в трьох варіантах: `root`, `mutable` та `immutable`. Одне виключення є трейт `Buffer`, що існує тільки як змінна колекція.

В залишку цієї глави ми будемо переглядати ці класи один за одним.

24.3 Трейт `Traversable`
------------------------
На вершині ієрархії колекцій стоїть трейт `Traversable` (_прохідний_). Його єдина операція є `foreach`:
[source,scala]
----
def foreach[U](f: Elem => U)
----
Класам колекцій, що реалізують `Traversable`, просто потрібно визначити цей метод; всі інші методи можуть бути наслідувані від `Traversable`.

Метод `foreach` призначений для обходу всіх елементів колекції та застосування наданої операції `f` до кожного елементу. Тип операції `Elem => U`, де `Elem` є типом елементів колекції та `U` є довільним типом результату. Виклик `f` робиться тільки заради побічного ефекту; фактично, любий результат функції `f` буде відкинутий `foreach`.

`Traversable` також визначає багато суцільних методів, всі вони перелічені в Таблиці 24.1. Ці методи підпадають в такі категорії:

* *Додавання* `++`, що додає два прохідних разом, або додає всі елементи ітератора до прохідного.

* *Операції відображення* `map`, `flatMap` та `collect`, що продукують нову колекцію через застосування деякої функції до елементів колекції.

* *Перетворення* `toIndexedSeq`, `toIterable`, `toStream`, `toArray`, `toList`, `toSeq`, `toSet` та `toMap`, що повертають колекцію `Traversable` в більш специфічну колекцію. Всі ці перетворення повертають об'єкт отримувача, якщо він вже відповідає бажаному типу колекції. Наприклад, застосування `toList` до списку буде повертати сам список.

* *Операції копіювання* `copyToBuffer` та `copyToArray`. Як кажуть їх імена, вони копіюють елементи колекції до буфера або масива, відповідно.

* *Операції розміру* `isEmpty`, `nonEmpty`, `size` та `hasDefiniteSize`. Колекції, що є прохідними, можуть бути скінченими та нескінченими. Прикладом нескінченої прохідної колекції є потік натуральних чисел `Stream.from(0)`. Метод `hasDefiniteSize` вказує, що колекція, можливо, нескінчена. Якщо він повертає `false`, колекція може бути нескінченою, і в цьому випадку `size` буде видавати помилку або не повернеться.

* *Операції отримання елемента* `head`, `last`, `headOption`, `lastOption` та `find`. Вони обирають перший або останній елемент колекції, або інакше перший елемент, що задовільняє умові. Однак зазначте, що не всі колекції мають гарно визначення значення того, що значить "перший" та "останній". Наприклад, хеш множина може зберігати елементи відповідно до їх хеш ключів, що можуть змінюватись від запуску до запуску. В цьому випадку "перший" елемент хеш набору також може бути різним для разних запусків програм. Колекція є впорядкована, якщо вона завжди видає свої елементи в тому самому порядку. Більшість колекцій впорядковані, але деякі (такі як хеш множини) ні — відкидання впорядкованості дає трохи додаткової ефективності. Порядок часто є основою для отримання повторюваних тестів та допомагає в зневадженні. Ось чому колекції Scala провадять впорядковані альтернативи для всіх типів колекцій. Наприклад, впорядкована альтернатива для `HashSet` є `LinkedHashSet`.

* *Операції отримання субколекцій* `takeWhile`, `tail`, `init`, `slice`, `take`, `drop`, `filter`, `dropWhile`, `filterNot`, `withFilter`. Всі вони повертають деяку субколекцію, що ідентифікується диапазоном індексів або предикатом.

* *Операції підрозділу* `splitAt`, `span`, `partition` та `groupBy` підрозділяють елементи колекції на декілька субколекцій.

* *Перевірка елементів* `exists`, `forall` та `count` перевіряють елементи колекції за допомогою наданого предикату.

* *Згортки* `foldLeft`, `foldRight`, `/:`, `:\`, `reduceLeft`, `reduceRight` застосовують двомісні операції до послідовних елементів.

* *Особливі згортки* `sum`, `product`, `min`, `max` роблять з колекціями специфічних типів (числові або порівнювані).

* *Рядкові операції* `mkString`, `addString`, `stringPrefix` провадять альтернативні шляхи перетворення колекції на рядок.

* *Операції переглядів* складаються з двох перевантажених варіантів метода `view`. Перегляд є колекція, що обчислюється ліниво. Ви пізнаєте більше про перегляди в Розділі 24.14.

[caption="Операції трейта Traversable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|*Абстрактний метод:*
|xs foreach f|Виконує функцію `f` для кожного елементу `xs`.
2+|*Додавання:*
|xs ++ ys|Колекція, що складається з елементів обох, `xs` та `ys`.  `ys` є колекцією `TraversableOnce`, тобто або `Traversable`, або `Iterator`.
2+|*Мапи:*
|xs map f|Колекція, отримана від застосування функції `f` до кожного елемента в `xs`.
|xs flatMap f|Колекція, отримана від застосування функції `f` від значень-колекції до кожного елементу в `xs` та конкатенації результатів.
|xs collect f|Колекція, отримана від застосування часткової функції `f` до кожного елементу в `xs`, для яких вона визначена та накопичення результатів.
2+|*Перетворення:*
|xs.toArray|Конвертує колекцію в масив.
|xs.toList|Конвертує колекцію в список.
|xs.toIterable|Конвертує колекцію в Iterable.
|xs.toSeq|Конвертує колекцію в послідовність.
|xs.toIndexedSeq|Конвертує колекцію в індексовану послідовність.
|xs.toStream|Конвертує колекцію в потік (ліниво обчислювана послідовність).
|xs.toSet|Конвертує колекцію в множину.
|xs.toMap|Конвертує колекцію пар ключ/значення в мапу.
2+|*Копіювання:*
|xs copyToBuffer buf|Копіює всі елементи колекції в буфер `buf`.
|xs copyToArray(arr, s, len)|Копіює щонайбільше `len` елементів `arr`, починаючи з індексу `s`. Два останні аргументи опціональні. 
2+|*Інформація про розмір:*
|xs.isEmpty|Перевіряє, чи колекція порожня.
|xs.nonEmpty|Перевіряє, чи колекція містить елементи.
|xs.size|Число елементів в колекції.
|xs.hasDefiniteSize|True, якщо відомо, що xs має фіксований розмір.
2+|*Отримання елементів:*
|xs.head|Перший елемент колекції (або деякий елемент, якщо порядок не визначений).
|xs.headOption|Перший елемент `xs` в опціональному значенні, або `None`, якщо `xs` порожнє.
|xs.last|Останній елемент колекції (або деякий елемент, якщо порядок не визначений).
|xs.lastOption|Останній елемент `xs` в опціональному значенні, або `None`, якщо `xs` порожнє.
|xs find p|Опція, яка містить перший елемент в `xs`, що задовільняє `p`, або `None`, якщо жодний елемент не підійде.
2+|*Субколекції:*
|xs.tail|Залишок колекції, за винятком `xs.head`.
|xs.init|Залишок колекції, за винятком `xs.last`.
|xs slice (from, to)|Колекція, що складається з елементів `xs` в деякому диапазоні індексів (від `from` до `to`, виключно).
|xs take n|Колекція, що складається з перших `n` елементів `xs` (або деякі довільні `n` елементів, якщо порядок не визначений).
|xs drop n|Залишок колекції, за винятком `xs take n`.
|xs takeWhile p|Найдовший префікс елементів в колекції, що задовільняють `p`.
|xs dropWhile p|Колекція без найдовшого префіксу елементів, всі з яких задовільняють `p`.
|xs filter p|Колекція, що складається з тих елементів `xs`, що задовільняють предикату `p`.
|xs withFilter p|Не-строгий фільтр для цієї колекції. Всі операції на отриманому фільтрі будуть застосовані тільки для тих елементів `xs`, для яких мова `p` є `true`.
|xs filterNot p|Колекція, що складається з тих елементів `xs`, що не задовільняють предикатові `p`.
2+|*Суброзподіл:*
|xs splitAt n|Розділяє `xs` в позициї `n`, даючи пару колекцій (`xs take n`, `xs drop n`).
|xs span p|Розділяє `xs` відповідно до предикату, даючи пару колекцій (`xs takeWhile p`, `xs.dropWhile p`).
|xs partition p|Розділяє `xs` на пару колекцій; одна з елементами, що задовільняють предикату `p`, інша з елементами, що ні, даючи пару колекцій(`xs filter p`, `xs.filterNot p`).
|xs groupBy f|Розділяє `xs` на мапу колекцій, відповідно до функції дескреминатору `f`.
2+|*Умови до елементів:*
|xs forall p|Логічне, що визначає, чи предикат `p` дотримується до всіх елементів `xs`.
|xs exists p|Логічне, що вказує, чи предикат `p` дотримується до деякого елемента в `xs`.
|xs count p|Число елементів в `xs`, що задовільняють предикату `p`.
2+|*Згортки:*
|(z /: xs)(op)|Застосовує двомісну операцію `op` між послідовними елементами `xs`, ідучи зліва направо, починаючи з `z`.
|(xs :\ z)(op)|Застосовує двомісну операцію `op` між послідовними елементами `xs`, ідучи зправа наліво, починаючи з `z`.
|xs.foldLeft(z)(op)|Те саме, що і `(z /: xs)(op)`.
|xs.foldRight(z)(op)|Те саме, що і `(xs :\ z)(op)`.
|xs reduceLeft op|Застосовує двомісну операцію `op` між послідовними елементами непорожньої колекції `xs`, ідучи зліва направо.
|xs reduceRight op|Застосовує двомісну операцію `op` між послідовними елементами непорожньої колекції `xs`, ідучи зправа наліво.
2+|*Особливі згортки:*
|xs.sum|Сума числових значень елементів колекції `xs`.
|xs.product|Добуток числових значень елементів колекції `xs`.
|xs.min|Мінімум впорядкованих значень елементів колекції `xs`.
|xs.max|Максімум впорядкованих значень елементів колекції `xs`.
2+|*Рядки:*
|xs addString (b, start, sep, end)|Додає рядок до `StringBuilder` `b`, що показує всі елементи `xs`, розділені роздільниками `sep` та оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональні.
|xs mkString (start, sep, end)|Конвертує колекцію на рядок, що показує всі елементи `xs` між роздільниками `sep` та оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональні.
|xs.stringPrefix|The collection name at the beginning of the string returned from xs.toString.
2+|*Перегляди:*
|xs.view|Продукує перегляд xs.
|xs view (from, to)|Продукує перегляд, що представляє елементи в деякому диапазоні індексів `xs`. 
|===

24.4 Трейт Iterable
===================
Наступний трейт зверху на Малюнку 24.1 є `Iterable`. Всі методи в цьому трейті визначені в термінах абстрактного метода `iterator`, що видає елементи колекції один за одним. Абстрактний метод `foreach`, наслідуваний від трейту `Traversable`, реалізований в `Iterable` в термінах `iterator`. Ось справжня реалізація:
[source,scala]
----
def foreach[U](f: Elem => U): Unit = {
  val it = iterator
  while (it.hasNext) f(it.next())
}
----
Лише кілька субкласів `Iterable` перекривають цю стандартну реалізацію `foreach` в `Iterable`, оскільки вони можуть провадити більш ефективну реалізацію. Пам'ятайте, що `foreach` є основою для реалізації всіх операцій в `Traversable` так що продуктивність важлива.

Ще два метода існують в `Iterable`, що повертають ітератори: `grouped` та `sliding`. Однак ці ітератори не повертають поодинокі елементи, але цілі субпослідовності елементів оригінальної колекції. Максимальний розмір ціх послідовностей надається як аргумент до ціх методів. Метод `grouped` розбиває свої елементи на інкрементальні пакунки, тоді як `sliding` дає ковзаюче вікно по елементах. Різниця між двома стане яснішою при погляді на наступні взаємодії в інтерпретаторі:
[source,scala]
----
scala> val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala> val git = xs grouped 3
git: Iterator[List[Int]] = non-empty iterator

scala> git.next()
res2: List[Int] = List(1, 2, 3)

scala> git.next()
res3: List[Int] = List(4, 5)

scala> val sit = xs sliding 3
sit: Iterator[List[Int]] = non-empty iterator

scala> sit.next()
res4: List[Int] = List(1, 2, 3)

scala> sit.next()
res5: List[Int] = List(2, 3, 4)

scala> sit.next()
res6: List[Int] = List(3, 4, 5)
----
Трейт `Iterable` також додає деякі інші методи до `Traversable`, що можуть бути ефективно реалізовані тільки за наявності ітератора. Вони підсумовані в Таблиці 24.2:

[caption="Операції трейта Iterable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|*Абстрактний метод:*
|iterator|Ітератор, що видає кожний елемент в `xs`, в тому самому порядку, як `foreach` проходить по елементах
2+|*Інші ітератори:* 
|xs grouped size|Ітератор, що видає "частки" колекції фіксованого розміру
|xs sliding size|Ітератор, що видає ковзне вікно фіксованого розміру з елементів колекції
2+|*Субколекції:* 
|xs takeRight n|Колекція, що складається з останніх `n` елементів `xs` (або довільні `n` елементів, якщо порядок не визначений)
|xs dropRight n|Залишок колекції, за винятком `xs takeRight n`
2+|*Поєднувачі:*
|xs zip ys|Ітерабельне з пар відповідних елементів з `xs` та `ys`
|xs zipAll (ys, x, y)|Ітерабельне з пар відповідних елементів з `xs` та `ys`, де коротша послідовність розширюється, щоб співпадати до довшої, через додавання елементів `x` або `y`
|xs.zipWithIndex|Ітерабельне з пар елементів `xs` разом з їх індексами
2+|*Порівняння:*
|xs sameElements ys|Перевіряє, чи `xs` та `ys` містять ті самі елементи в тому ж порядку
|===

Чому мати обоє, `Traversable` та `Iterable`?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ви можете здивуватись, для чого додатковий трейт `Traversable` над `Iterable`. Чи не могли б зробити все з ітератором? То яка ідея мати більш абстрактний трейт, що визначає свої методи в термінах `foreach` замість `iterator`? Одна причина мати `Traversable` в тому, що іноді простіше або більш ефективно провадити реалізацію для `foreach`, ніж провадити реалізацію ітератора. Ось простий приклад. Скажімо, ви бажаєте ієрархію класів для бінарних дерев, що мають цілі елементи на листках. Ви можете розробиби цю ієрархію таким чином:
[source,scala]
----
sealed abstract class Tree
case class Branch(left: Tree, right: Tree) extends Tree
case class Node(elem: Int) extends Tree
----
Тепер вважатимемо, ви бажаєте зробити дерева перехідними. Щоб зробити це, треба щоб `Tree` наслідував від `Traversable[Int]` та визначав метод `foreach`, ось так:
[source,scala]
----
sealed abstract class Tree extends Traversable[Int] {
  def foreach[U](f: Int => U) = this match {
    case Node(elem) => f(elem)
    case Branch(l, r) => l foreach f; r foreach f
  }
}
----
Це не дуже складно, і це також дуже ефективно — перехід по збалансованому дереву пропорційно до числа елементів в дереві. Щоб побачити це, уявімо, що збалансоване дерево з `N` листками буде мати `N - 1` внутрішніх листків класу `Branch`. Так що загальна кількість кроків для обходу дерева є `N + N - 1`.

Тепер порівняйте це з робленням дерев ітерабельними. Щоб зробити це, робимо `Tree` походячим від `Iterable[Int]` та визначаємо метод `iterator` ось так:
[source,scala]
----
sealed abstract class Tree extends Iterable[Int] {
  def iterator: Iterator[Int] = this match {
    case Node(elem) => Iterator.single(elem)
    case Branch(l, r) => l.iterator ++ r.iterator
  }
}
----
На перший погляд це виглядає не складніше, ніж рішення `foreach`. Однак є проблема ефективності, що стосується реалізації метода конкатенації ітератора, `++`. Кожного разу,коли продукується елемент конкатенованим ітератором, як в `l.iterator ++ r.iterator`, обчислення потребує слідувати одному непрямому переходу, щоб отримати вірний ітератор (`l.iterator` або `r.iterator`). Загалом це робить `log(N)` перенаправлень, щоб отримати листок збалансованого дерева з `N` leaves. Так що ціна відвідування всіх елементів дерева становить від близько `2N` для метода обходу `foreach`, до `Nlog(N)` для проходу за допомогою ітератору. Якщо дерево має мільйон елементів, це означає близько двох мільйонів кроків для `foreach`, і біля двадцяти (?) мільйонів кроків для `iterator`. Так що рішення `foreach` має явну перевагу.

Субкатегорії Iterable
~~~~~~~~~~~~~~~~~~~~~
В ієрархії наслідування нижче `Iterable` ви знайдете три трейти: `Seq`, `Set` та `Map`. Загальний аспект ціх трьох трейтів в тому, що всі вони реалізують трейт `PartialFunction`,footnote:[Часткові функції були описані в Розділі 15.7.] з його методами `apply` та `isDefinedAt`. Однак спосіб, в який кожний трейт реалізує `PartialFunction`, відрізняється.

Для послідовностей `apply` є позиційне індексування, де елементи завжди пронумеровані від `0`. Тобто, `Seq(1, 2, 3)(1) == 2`. Для множин `apply` є перевіркою належності. Наприклад, `Set('a', 'b', 'c') ('b') == true`, тоді як `Set()('a') == false`. Нарешті, для мап `apply` є вибір. Наприклад, `Map('a' - > 1, 'b' -> 10, 'c' -> 100)('b') == 10`.

В наступних трьох розділах ми пояснимо кожний з трьох типів колекцій більш детально.

24.5 Трейти послідовностей `Seq`, `IndexedSeq`, `LinearSeq`
-----------------------------------------------------------
Трейт `Seq` представляє послідовності. Послідовність різновид ітерабельного, що має довжину та чиї елементи мають фіксовані індексовані позиції, починаючи від 0. Операції над послідовностями, підсумовані на Малюнку 24.3, підпадають в наступні категорії:

* *Операції індексування та довжини* `apply`, `isDefinedAt`, `length`, `indices` та `lengthCompare`. Для `Seq` операція `apply` означає індексування; таким чином послідовність типу `Seq[T]` є частковою функцією, що приймає аргумент `Int` (індекс) та видає елемент послідовності типу `T`. Іншими словами, `Seq[T]` розширює `PartialFunction[Int, T]`. Елементи послідовності індексовані від нуля до довжини послідовності мінус один. Метод `length` на послідовностях є псевдонимом метода `size` на загальних колекціях. Метод `lengthCompare` дозволяє вам порівнювати довжину двох послідовностей, навіть якщо одна з послідовностей має безкінечну довжину.

* *Операції пошуку індексу* `indexOf`, `lastIndexOf`, `indexOfSlice`, `lastIndexOfSlice`,`indexWhere`, `lastIndexWhere`, `segmentLength` та `prefixLength` повертають індекс елементу, рівному до заданого значення або співпадаючий з деяким предикатом.

* *Операції додавання* `+:`, `:+` та `padTo`, повертають нову послідовність, отриману від додавання елементів зпереду або з кінця послідовності.

* *Операції оновлення* `updated` та `patch`, що повертають нову послідовність, отриману від заміни деяких елементів оригінальної послідовності.

* *Операції сортування* `sorted`, `sortWith` та `sortBy` сортують елементи послідовності відповідно до різних критеріїв.

* *Операції обертання* `reverse`, `reverseIterator` та `reverseMap` видають або обробляють елементи послідовності в зворотньому порядку, від останнього до першого.

* *Операції порівняння* `startsWith`, `endsWith`, `contains`, `corresponds` та `containsSlice` співвідносить дві послідовності або шукає елемент в послідовності.

* *Множинні операції* `intersect`, `diff`, `union` та `distinct` виконують множино-подібні операції на елементах двох послідовностей, або видаляють дублікати.

Якщо послідовність змінна, вона пропонує додатковий метод з побічним ефектом `update`, що дозволяє оновлювати елементи. Згадайте з Глави 3, що синтаксис як `seq(idx) = elem` є просто скороченням для `seq.update(idx, elem)`. Зауважте різницю між `update` та `updated`. Метод `update` змінює елемент послідовності на місці та доступний тільки для змінних послідовностей. Метод `updated` доступний для всіх послідовностей та завжди повертає нову послідовність, замість модифікації оригіналу.

[caption="Операції трейта Seq"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Індексування та довжина:
|xs(i)|(або, розписано,`xs apply i`) Елемент `xs` за індексом `i`.
|xs isDefinedAt i|Перевіряє, чи `i` міститься в `xs.indices`.
|xs.length|Довжина послідовності (те саме, що і `size`).
|xs.lengthCompare ys|Повертає `-1`, якщо `xs` коротше за `ys`, `+1` якщо довше та `0` якщо вони мають рівну довжину. Робить, навіть якщо послідовності безкінечні.
|xs.indices|Диапазон індексів `xs`, що простягається від `0` до `xs.length - 1`. 
2+|Індексний пошук:
|xs indexOf x|Індекс першого елементу в `xs` рівному `x` (існують декілька варіантів).
|xs lastIndexOf x|Індекс останнього елементу в `xs` рівному `x` (існують декілька варіантів).
|xs indexOfSlice ys|Перший індекс `xs` такий, що наступні елементи починаючи з цього індексу формують послідовність `ys`.
|xs lastIndexOfSlice ys|Останній індекс `xs` такий, що наступні елементи починаючи з цього індексу формують послідовність `ys`.
|xs indexWhere p|Індекс першого елементу `xs`, задовільняє `p` (існують декілька варіантів).
|xs segmentLength (p, i)| Довжина найдовшого неперериваного сегменту елементів `xs`, починаючи з `xs(i)`, всі з яких задовільняють предикату `p`.
|xs prefixLength p|Довжина найдовшого префіксу з елементів `xs`, всі з яких задовільняють предикату `p`.
2+|Додавання:
|x +: xs|Нова послідовність, що складається з `x` перед `xs`.
|xs :+ x|Нова послідовність, що складається з `x` після `xs`.
|xs padTo (len, x)|Послідовність, що утворюється як результат від додавання значення `x` до `xs`, доки не буде досяжена довжина `len`.
2+|Оновлення:
|xs patch (i, ys, r)|Послідовність як результат від заміни `r` елементів `xs`, починаючи з `i` на латку `ys`.
|xs updated (i, x)|Копія `xs`, з елементом з індексом `i`, заміненим на `x`.
|xs(i) = x|(або, розписане, `xs.update(i, x)`, доступне тільки для` mutable.Seq`). Зміна елементу `xs` по індексу `i` на `y`.
2+|Сортування:
|xs.sorted|Нова послідовність, отримана від сортування елементів  `xs` з використанням стандартного впорядкування типу елементів `xs`.
|xs sortWith lessThan|Нова послідовність, отримана від сортування елементів `xs`, використовуючи `lessThan` як операції порівняння.
|xs sortBy f|Нова послідовність, отримана від сортування елементів `xs`. Порівняння між двома елементами обробляється через відображення двох елементів функцією `f` над обома та порівняння результатів.
2+|Обернення:
|xs.reverse|Послідовність з елементами `xs` в зворотньому порядку.
|xs.reverseIterator|Ітератор, що видає всі елементи `xs` в зворотньому порядку.
|xs reverseMap f|Послідовність, отримана від відображення `f` над елементами `xs` в зворотньому порядку.
2+|Порівняння:
|xs startsWith ys|Перевіряє, чи `xs` починається з послідовності `ys` (існують декілька варіантів).
|xs endsWith ys|Перевіряє, чи `xs` закінчується на `ys` (існують декілька варіантів).
|xs contains x|Перевіряє, чи `xs` має елемент, що дорівнює `x`.
|xs containsSlice ys|Перевіряє, чи `xs` має послідовність, що дорівнює `ys`.
|(xs corresponds ys)(p)|Перевіряє, чи відповідні елементи `xs` та `ys` задовільняють двомісному предикату `p`.
2+|Множинні операції:
|xs intersect ys|Множинний перетин послідовностей `xs` та `ys`, що зберігає порядок елементів в `xs`.
|xs diff ys|Множинна різниця послідовностей `xs` та `ys`, що зберігає порядок елементів в `xs`.
|xs union ys|Множинне об'єднання; те саме, що `xs ++ ys`.
|xs.distinct|Субпослідовність `xs`, що не містить дублікатів.
|===

Кожний трейт `Seq` має два субтрейти, `LinearSeq` та `IndexedSeq`. Вони не додають жодних нових операцій, але кожний пропонує різні характеристики продуктивності. Лінійна послідовність має ефективні операції `head` та `tail`, тоді як індексована послідовність має ефективні операції `apply`, `length` та (якщо `mutable`) `update`. `List` є часто використовувана лінійна послідовність, як і `Stream`. Дві часто використовувані індексовані послідовності є `Array` та `ArrayBuffer`. Клас `Vector` провадить цікавий компроміс між індексованим та лінійним доступом. Він має однаково ефективний сталий час індексного навантаження та сталий час лінійного доступу. Завдяки цьому вектори є гарною основою для шаблонів змішаного доступу, коли одночасно використовується індексний та лінійний доступи. Більше про вектори в Розділі 24.8.

Буфери
~~~~~~
Важлива суб-категорія змінних послідовностей є буфери. Буфери дозволяють не тільки оновлення існуючих елементів, але також вставки елементів, видалення елементів та ефективне додавання нових елементів в кінець буфера. Принципово нові методи, що підтримуються буферами, є `+=` та `++=` для додавання елементів в кінець та `+=:` і `++=:` для додавання зпереду, `insert` та `insertAll` для вставок елементів так само як `remove` та `-=` для видалення елементів. Ці These operations are summarized in Table 24.4.

Дві реалізації `Buffer` в загальному ужитку є `ListBuffer` та `ArrayBuffer`. Як підказує ім'я, `ListBuffer` підтримується `List` та підтримує ефективне перетворення його елементів `List`, тоді як  `ArrayBuffer` покладається на масив та може бути швидко перетворений на такий. Ви бачили проблиск реалізації `ListBuffer` в Розділі 22.2.

[caption="Операції трейта Buffer"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Додавання:
|buf += x|Додає елемент `x` до буфера `buf` та повертає самий `buf` як результат
|buf += (x, y, z)|Додає надані елементи до буфера
|buf ++= xs|Додає всі елементи в `xs` до буфера
|x +=: buf|Ставить елемент `x` в початок буфера
|xs ++=: buf|Ставить всі елементи `xs` в початок буфера
|buf insert (i, x)|Вставляє елемент `x` по індексу `i` в буфер
|buf insertAll (i, xs)|Вставляє всі елементи в `xs` по індексу `i` в буфер
2+|Видалення:
|buf -= x|Видаляє елемент `x` з буфера
|buf remove i|Видаляє елементпо індексу `i` з буфера
|buf remove (i, n)|Видаляє `n` елементів, починаючи з індексу `i`, з буфера
|buf trimStart n|Видаляє перші `n` елементів з буфера
|buf trimEnd n|Видаляє останні `n` елементів з буфера
|buf.clear()|Видаляє всі елементи з буфера
2+|Клонування:
|buf.clone|Новий буфер з тими самим елементами, що і `buf`
|===

24.6 Множини
------------
`Set` є `Iterable`, що не містить дублікатів елементів. Операції з множинами підсумовані в Таблиці 24.5 для `general` множин, і Таблиці 24.6 `mutable` множин. Вони підпадають під наступні категорії:

* *Перевірки* `contains`, `apply` та `subsetOf`. Метод `contains` вказує, чи множина містить наданий елемент. Метод `apply` для множини те саме, що і `contains` так що `set(elem)` відповідає до  `set contains elem`. Це означає, що множини можуть також використовуватись як функції перевірки, що повертають `true` для елементів, які вони містять. Наприклад:
[source,scala]
----
scala> val fruit = Set("apple", "orange", "peach", "banana")
fruit: scala.collection.immutable.Set[String] =
  Set(apple, orange, peach, banana)

scala> fruit("peach")
res7: Boolean = true

scala> fruit("potato")
res8: Boolean = false
----
* *Додавання* `+` and `++` додають до множини один або більше елементів, даючи нову множини в якості результату.

* *Видалення* `-` та `--` видаляють один або більше з множини, даючи нову множину.

* *Операції множин* для об'єднання, перетину та різниці. Ці операції існують в двох фломах: алгебраїчній та символічній. Алгебраїчні версії є `intersect`, `union` та `diff`, тоді як символічні версії `&`, `|` та `&~`. Метод `++`, який `Set` наслідує від `Traversable`, може розглядатись як ще один псевдоним для `union` або `|`, за винятком того, що `++` приймає аргумент `Traversable`, коли `union` та `|` приймають множини.

[caption="Операції трейта Set"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Перевірки:
|xs contains x|Перевіряє, чи `x` є елементом `xs`
|xs(x)|Те саме, що `xs contains x`
|xs subsetOf ys|Перевіряє, чи `xs` є підмножиною `ys`
2+|Додавання:
|xs + x|Множина, що містить всі елементи `xs` так само як `x`
|xs + (x, y, z)|Множина, що містить всі елементи `xs` так само як надані додаткові елементи
|xs ++ ys|Множина, що містить всі елементи `xs` так само, як всі елементи `ys`
2+|Видалення:
|xs - x|Множина, що містить всі елементи `xs`, за винятком `x`
|xs - (x, y, z)|Множина, що містить всі елементи `xs`, за винятком наданих елементів
|xs -- ys|Множина, що містить всі елементи `xs`, крім елементів в `ys`
|xs.empty|Порожня множина такого ж класу, що і `xs`
2+|Бінарні операції:
|xs & ys|Перетин множин `xs` та `ys`
|xs intersect ys|Те саме, що і `xs & ys`
|xs \| ys|Поєднання множин `xs` та `ys`
|xs union ys|Те саме, що і `xs | ys`
|xs &~ ys|Різниця множин `xs and ys`
|xs diff ys|Те саме, що і `xs &~ ys`
|===

Змінні множини мають методи, що додають, видаляють або оновлюють елементи, що підсумовані в Таблиці 24.6:

[caption="Операції трейта mutable.Set"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+"Додавання:
|xs += x|Додає елемент `x` до множини `xs` як побічний ефект та повератє сам `xs`
|xs += (x, y, z)|Додає надані елементи до множини як побічний ефект та повертає сам `xs`
|xs ++= ys|Додає всі елементи з `ys` до множини `xs` як побічний ефект та повертає сам `xs`
|xs add x|Додає елемент `x` до `xs` та повертає `true`, якщо `x` досі не був членом множини, `false` якщо він був там
2+|Видалення:
|xs -= x|Видаляє елемент `x` з множини `xs` як побічний ефект та повертає сам `xs`
|xs -= (x, y, z)|Видаляє надані елементи з множини `xs` як побічний ефект та повертає сам `xs`
|xs --= ys|Видаляє всі елементи в `ys` з множини `xs` як побічний ефект та повертає сам `xs`
|xs remove x|Видаляє `x` з `xs` та повертає `true`, якщо `x` до цього містився в множині, `false` якщо ні
|xs retain p|Залишає лише ті елементи в `xs`, що задовільняють предикату `p`
|xs.clear()|Видаляє всі елементи з `xs`
2+|Оновлення:
|xs(x) = b|(або, розписано, `xs.update(x, b)`) Якщо логічний аргумент `b` є `true`, додає `x` до `xs`, інакше видаляє `x` з `xs`
2+|Клонування:
|xs.clone|Нова змінна множина з тими ж елементами, що і `xs`
|===

Так само, як незмінні множини, змінні множини пропонують операції  `+` та `++` для додавання елементів та `-` та `--` для видалення елементів. Але вони рідше використовуються для змінних множин, оскікльки це включає копіювання множини. Ак більш ефективна альтернатива, змінні множини пропонують методи оновлення `+=` та `- =`. Операція `s += elem` додає `elem` до множини `s` в якості побічного ефекту та повертає змінену множину як результат. Подібно до цього, `s -= elem` видаляє `elem` з множини та повертає змінену множину як результат. Окрім `+=` та `-=` також існують масові операції `++=` та `--=`, що додають або видаляють всі елементи перехідного або ітератора.

Вибір імен методів, `+=` та `-=` означає, що дуже подібний код буде робити однаково, зі змінними та незмінними множинами. Зпочатку розглянемо наступний диалог в інтерпретаторі, що використовує незмінну множину `s`:
[source,scala]
----
scala> var s = Set(1, 2, 3)
s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)

scala> s += 4; s -= 2

scala> s
res10: scala.collection.immutable.Set[Int] = Set(1, 3, 4)
----
В цьому прикладі ми використали `+=` та `-=` на `var` типу `immutable.Set`. Як було пояснено на Кроці 10 в Главі 3, а твердження як `s += 4` є скороченням для `s = s + 4`. Так що це викликає метод додавання `+` на множині `s` та потім присвоює результат назад до змінної `s`. Розглянемо тепер аналогічну взаємодію зі змінним набором:
[source,scala]
----
scala> val s = collection.mutable.Set(1, 2, 3)
s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)

scala> s += 4
res11: s.type = Set(1, 2, 3, 4)

scala> s -= 2
res12: s.type = Set(1, 3, 4)
----
The end effect is very similar to the previous interaction; we start with a Set(1, 2, 3) and end up with a Set(1, 3, 4). However, even though the statements look the same as before, they do something different. The s += 4 statement now invokes the += method on the mutable set values, changing the set in place. Likewise, the s -= 2 statement now invokes the -= method on the same set.

Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.

Mutable sets also provide add and remove as variants of += and -=. The difference is that add andremove return a boolean result indicating whether the operation had an effect on the set.

The current default implementation of a mutable set uses a hash table to store the set's elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as hash tries.footnote:[Hash tries are described in Section 24.8.]

A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.

24.7 Мапи
---------
Maps are Iterables of pairs of keys and values (also named mappings or associations). As explained in Section 21.4, Scala's Predef class offers an implicit conversion that lets you writekey -> value as an alternate syntax for the pair (key, value). Therefore, Map("x" -> 24, "y" -> 25, "z" -> 26) means exactly the same as Map(("x", 24), ("y", 25), ("z", 26)), but reads better.

The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets. Mutable maps additionally support the operations shown in Table 24.8. Map operations fall into the following categories:

* *Lookups* apply, get, getOrElse, contains, and isDefinedAt. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is: 
[source,scala]
----
def get(key): Option[Value]
----
The operation "m get key" tests whether the map contains an association for the given key. If so, it returns the associated value in a Some. If no key is defined in the map, get returns None. Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option. If the key is not defined in the map, an exception is raised.

* Additions and updates +, ++, and updated, which let you add new bindings to a map or change existing bindings.

* Removals - and --, which remove bindings from a map.

* Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map's keys and values separately in various forms.

* Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.

[caption="Операції трейта Map"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Пошук:
|ms get k|Значення, асоційоване з ключем `k` в мапі `ms`, як опція, або `None`, якщо не знайдене
|ms(k)|(або, розписане, `ms apply k`) Значення, асоційоване з ключем `k` в мапі `ms`, або закидає виключення, якщо не знайдене
|ms getOrElse (k, d)|Значення, асоційоване з ключем `k` в мапі `ms`,або значення по замовчанню `d`, якщо не знайдене
|ms contains k|Перевіряє, чи `ms` містить відображення для ключа `k`
|ms isDefinedAt k|Те саме, що і `contains`
2+|Додавання та оновлення:
|ms + (k -> v)|Мапа, що містить всі відображення `ms` так само, як і `gk -> v` ключа `k` на значення `v`
|ms + (k -> v, l -> w)|Мапа, що містить всі відображення `ms`, разом з наданими парами ключ/значення
|ms ++ kvs|Мапа, що містить всі відображення `ms` так само, як і пари ключ/значення з `kvs`
|ms updated (k, v)|Таке саме, що і `ms + (k -> v)`
2+|Видалення:
|ms - k|Мапа, що містить всі відображення з `ms`, за винятком любих відображень для ключа `k`
|ms - (k, l, m)|Мапа, що містить всі відображення `ms`, за винятком всіх відображень з наданими ключамі
|ms -- ks|Мапа, що містить всі відображення з `ms`, за винятком любих відображень з ключами в `ks`
2+|Субколекції:
|ms.keys|Ітерабельне, що містить любий ключ в `ms`
|ms.keySet|Множина, що містить кожний ключ в `ms`
|ms.keysIterator|Ітератор, що видає кожний ключ в `ms`
|ms.values|Ітерабельне, що містить кожне значення, асоційоване з ключем в `ms`
|ms.valuesIterator|Ітератор, що видає кожне значення, асоційоване з ключем в `ms`
2+|Перетворення:
|ms filterKeys p|Перегляд мапи, що містить тільки ті відображення, в яких ключ відповідає предикату `p`
|ms mapValues f|Перегляд мапи, отриманий від застосування функції `f` до кожного значення, асоційованого з ключем в `ms`
|===

[caption="Операції трейта mutable.Map"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Додавання та оновлення:
|ms(k) = v|(або, розписано, `ms.update(k, v)`) Додає відображення ключа `k` на значення `v` до мапи `ms` як побічний ефект, переписуючи любі попередні відображення `k`
|ms += (k -> v)|Додає відображення ключа `k` на значення `v` до мапи `ms` як побічний ефект та повертає сам `ms`
|ms += (k -> v, l -> w)|Додає надані відображення до `ms` як побічний ефект та повертає сам `ms`
|ms ++= kvs|Додає всі відображення в `kvs` до `ms` як побічний ефект та повертає сам `ms`
|ms put (k, v)|Додає відображення ключа `k` на значення `v` до `ms` та повертає любе значення, асоційоване до цього з `k`, як опцію
|ms getOrElseUpdate (k, d)|Якщо ключ `k` визначений в мапі `ms`, повертає його асоційоване значення. Інакше оновлює `ms` відображенням `k -> d` та повертає `d`
2+|Видалення:
|ms -= k|Видаляє відображення ключа `k` з `ms` як побічний ефект та повертає сам `ms`
|ms -= (k, l, m)|Видаляє відображення наданних ключів з `ms` як побічний ефект та повертає сам `ms`
|ms --= ks|Видаляє всі ключі в `ks` з `ms` як побічний ефект та повертає сам `ms`
|ms remove k|Видаляє любі відображення ключа `k` з `ms` та повертає любе значення, до цього асоційоване з `k`, як опцію
|ms retain p|Зберігає тільки ті відображення в `ms`, ключ яких задовільняє предикату `p`.
|ms.clear()|Видаляє всі відображення з `ms`
2+|Перетворення та клонування:
|ms transform f|Перетворює всі асоційовані значення в мапі `ms` функцією `f`
|ms.clone|Повертає нову змінну мапу з тими самими відображеннями, що і `ms`
|===

Операції додавання та видалення для мап повторюють такі самі для множин. Як і для множин, змінні мапи також підтримують неруйнівні операції додавання `+`, `-` та `updated`, але вони використовуються менш часто, оскільки вони включають копіювання змінної мапи. Замість цього, змінна мапа `m` звичайно оновлюється "на місці", використовуючи два варіанти, `m(key) = value` або `m += (key -> value)`. Також є варіант `m put (key, value)`, що повертає значення `Option`, що складається зі значення, до того асоційованого з ключем, або `None`, якщо ключ не існував в мапі до цього.

Метод `getOrElseUpdate` корисний для доступу до мап, що діють як кеші. Скажімо, ви маєте коштовне обчислення, що перемикається викликом функції `f`:
[source,scala]
----
scala> def f(x: String) = {
        println("taking my time."); Thread.sleep(100)
        x.reverse }
f: (x: String)String
----
Далі уявімо, що `f` не має побічних ефектів так що повторний виклик з тими ж аргументами буде завжди давати той самий результат. В такому випадку ви можете зберігти час, зберігаючи попередньо обчислені прив'язки аргументів та результати `f` в мапі та обчислювати результат `f`, якщо результат від аргументів ще не знаходиться там. Ви можете сказати, що мапа є кешем для обчислення функції `f`.
[source,scala]
----
scala> val cache = collection.mutable.Map[String, String]()
cache: scala.collection.mutable.Map[String,String] = Map()
----
Тепер ви можете створити більш ефективну кешовану версію фукнції `f`:
[source,scala]
----
scala> def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))
cachedF: (s: String)String

scala> cachedF("abc")
taking my time.
res16: String = cba

scala> cachedF("abc")
res17: String = cba
----
Зауважте, що другий аргумент `getOrElseUpdate` є "за ім'ям" так що обчислення `f("abc")` вище виконується тільки якщо `getOrElseUpdate` потрубує значення свого другого аргументу, що саме коли перший аргумент не знайдений в кеш мапі. Ви також можете реалізувати `cachedF` напряму, використовуючи базові операції з мапами, але щоб зробити це знадобиться більше кода:
[source,scala]
----
def cachedF(arg: String) = cache get arg match {
  case Some(result) => result
  case None =>
    val result = f(arg)
    cache(arg) = result
    result
}
----
24.8 Суцільні класи незмінних колекцій
--------------------------------------
Scala провадить багато класів суцільних незмінних колекцій, з яких ви можете вибрати. Вони відрізняються в трейтах, які вони реалізують (мапи, множини, послідовності), чи можуть вони бути нескінченими та швидкістю різних операцій. Ми почнемо з огляду найбільш загальних типів незмінних колекцій.

Списки
~~~~~~
Списки є скінчені незмінні послідовності. Вони провадять доступ за сталий час до свого першого елементу так само, як і до залишку списку та вони мають операцію сталого часу `cons` для додавання нового елемента напочатку списку. Багато інших операцій займають лінійний час. Дівіться Глави 16 та 22 для розширеної дискусії щодо списків.

Потоки
~~~~~~
Потік подібний до списків, за тим винятком, що його елементи обчислюються ліниво. Через це потік може бути безкінечно довгий. Тільки елементи, що запитані, будуть обчислені. В іншому потоки мають ті самі характеристики продуктивності, що і списки.

В той час, як списки будуються за допомогою оператора `::`, потоки будуються за допомогою подібно виглядаючого `#::`. Ось простий приклад потоку, що містить цілі `1`, `2` та `3`:
[source,scala]
----
scala> val str = 1 #:: 2 #:: 3 #:: Stream.empty
str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
----
Голова цього потоку є `1` та хвіст має `2` та `3`. Однак хвіст тут не друкується, оскільки він все ще не обчислений! Потоки мають обчислюватись ліниво та метод `toString` для потоку досить уважний, щоб не змушувати до додаткового обчислення.

Нижче більш складний приклад. Він обчислює потік, що містить послідовність Фібоначчі, починаючи з наданих двох чисел. Послідовність Фібоначчі - це коли кожний елемент є сумою двох попередніх в послідовності:
[source,scala]
----
scala> def fibFrom(a: Int, b: Int): Stream[Int] =
          a #:: fibFrom(b, a + b)
fibFrom: (a: Int, b: Int)Stream[Int]
----
Ця функція оманливо проста. Перший елемент послідовності, вочевидь, `a` та залишок послідовності є послідовність Фібоначчі, починаючи з `b`, за яким іде `a + b`. Хитра частина є обчислення цієї послідовності без нескінченої рекурсії. Якщо функція використовує `::` замість `#::`, тоді кожний виклик до функції буде спричиняти інший виклик таким чином спричиняючи нескінчену рекурсію. Однак оскільки вона використовує `#::`, права частина не обчислюється, доки вона не стане потрібною.

Ось декілька перших елементів послідовності Фібоначчі, починаючи з двох елементів:
[source,scala]
----
scala> val fibs = fibFrom(1, 1).take(7)
fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)

scala> fibs.toList
res23: List[Int] = List(1, 1, 2, 3, 5, 8, 13)
----

Вектори
~~~~~~~
Списки дуже ефективні, коли алгоритм обробляє їх дбайливо, обробляючи тільки їх голови. Досутп, додавання та видалення тільки до голови списку забирає тільки сталий час, тоді як доступ або модифікація елементів в списку пізніше бере час лінійно відносно глибини списку.

Вектори є типом колекцій, що дають ефективний доступ до елементів після голови. Доступ до любого елементу вектора займає тільки "ефективно сталий час", як визначено нижче. Це більша константа, ніж для доступу до голови списка, або для читання елементу масиву, але, тим не менше, це константа. Як результат, алгоритми, що використовують вектори, не мають пильнувати щодо доступу тільки до голови послідовності. Вони можуть отримувати доступ та модифікувати елементи в довільних місцях, і таким чином, вони можуть бути значно зручніші до написання.

Вектори будуються та модифікуються так само, як інші послідовності:
[source,scala]
----
scala> val vec = scala.collection.immutable.Vector.empty
vec: scala.collection.immutable.Vector[Nothing] = Vector()

scala> val vec2 = vec :+ 1 :+ 2
vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)

scala> val vec3 = 100 +: vec2
vec3: scala.collection.immutable.Vector[Int]
  = Vector(100, 1, 2)

scala> vec3(0)
res24: Int = 100
----
Вектори представлені як широкі та мілкі дерева. Кожний вузол дерева містить до 32 елементів вектора, або містить до 32 інших вузлів дерева. Вектори до 32 елементів можуть бути представлені одним вузлом. Вектори до 32 * 32 = 1024 елементів можуть бути представлені з одним перенаправленям. Два стрибка від кореня дерева до фінального вузла елементу достатні для векторів до 2^15^ елементів, три стрибка для векторів 2^20^, чотири стрибка для векторів з 2^25^ елементами, і п'ять стрибкив для векторів до 2^30^ елементів. Так що для всіх векторів пристойного розміру вибір елементів включає до п'яти виборок примітивного масиву. Це те, що ми мали на увазі, коли писали, що доступ до елементу має "ефективно сталий час".

Вектори незмінні так що ви не зможете змінити елемент вектора на місці. Однак, з методом `updated` ви можете створити новий вектор, що відрізняється від наданого вектора тільки одним елементом:
[source,scala]
----
scala> val vec = Vector(1, 2, 3)
vec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)

scala> vec updated (2, 4)
res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)

scala> vec
res26: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)
----
Як показує останній рядок вище, виклик до `updated` не має ефекту на оригінальний вектор `vec`. Як і вибір, оновлення функціонального вектора також має "ефективно сталий час". Оновлення вектора всередині вектора може бути зроблене через копіювання вузла, що містить елемент, і кожного вузла, що вказує на нього, починаючи від кореня дерева. Це означає, що функціональне оновлення створює від одного до п'яти вузлів, кожний містить до 32 елементів або субдерев. Це, звичайно, більш коштовно, ніж оновлення на місці в змінному масиві, але все ще набагато дешевше, ніж копіювання цілого вектора.

Оскільки вектори влучають в гарний баланс між швидким довільними функціональними вибірками та швидкими довільними функціональними оновленнями, вони наразі є реалізацією по замовченню для незмінних індексованих послідовностей:
[source,scala]
----
scala> collection.immutable.IndexedSeq(1, 2, 3)
res27: scala.collection.immutable.IndexedSeq[Int]
  = Vector(1, 2, 3)Immutable stacks
----

Незмінні стеки
~~~~~~~~~~~~~~
Якщо вам треба послідовність останній-увійшов-перший-вийшов, ви можете використовувати `Stack`. Ви заштовхуєте елемент в стек за допомогою `push`, виштовуєте за допомогою `pop` та вибираєте зверху без видалення за допомогою `top`. Всі ці операції займають сталий час.

Ось деякі прості операції, що виконуються на стеку:
[source,scala]
----
scala> val stack = scala.collection.immutable.Stack.empty
stack: scala.collection.immutable.Stack[Nothing] = Stack()

scala> val hasOne = stack.push(1)
hasOne: scala.collection.immutable.Stack[Int] = Stack(1)

scala> stack
res28: scala.collection.immutable.Stack[Nothing] = Stack()

scala> hasOne.top
res29: Int = 1

scala> hasOne.pop
res30: scala.collection.immutable.Stack[Int] = Stack()
----
Незмінні стеки використовуються рідко в Scala програмах, оскільки їх функціональність повторює списки: `push` на незмінному стеку є те саме, що `::` на списку та `pop` на стеку те саме, що `tail` на списку.

Незмінні черги
~~~~~~~~~~~~~~
Черга така сама як стек, за виключенням що вона перший-війшов-перший-вийшов, ніж останній-війшов-перший-вийшов. Спрощена реалізація незмінних черг дискутувалась в Главі 19. Ось як ви можете створити порожню незмінну чергу:
[source,scala]
----
scala> val empty = scala.collection.immutable.Queue[Int]()
empty: scala.collection.immutable.Queue[Int] = Queue()
----
Ви можете додати елемент до незмінної черги за допомогою `enqueue`:
[source,scala]
----
scala> val has1 = empty.enqueue(1)
has1: scala.collection.immutable.Queue[Int] = Queue(1)
----
Щоб додати декілька елементів до черги, викличте `enqueue` з колекцією в якості аргумента:
[source,scala]
----
scala> val has123 = has1.enqueue(List(2, 3))
has123: scala.collection.immutable.Queue[Int] = Queue(1, 2,
3)
----
Щоб видалити елемент з голови черги, використовуйте `dequeue`:
[source,scala]
----
scala> val (element, has23) = has123.dequeue
element: Int = 1
has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)
----
Зауважте, що `dequeue` повертає пару, що складається з видаленого елементу та залишку черги.

Диапазони
~~~~~~~~~
Диапазон є впорядкованою послідовністю цілих, що відстоять нарівно один від одного. Наприклад, `1, 2, 3` є диапазон, як і `5, 8, 11, 14`. Щоб створити диапазон в Scala, використовуйте попередньо визначені методи `to` та `by`. Ось деякі приклади:
[source,scala]
----
scala> 1 to 3
res31: scala.collection.immutable.Range.Inclusive
  = Range(1, 2, 3)

scala> 5 to 14 by 3
res32: scala.collection.immutable.Range = Range(5, 8, 11, 14)
----
Якщо ви бажаєте створити диапазон, який виключає свій верхній ліміт, використовуйте зручний метод `until` замість `to`:
[source,scala]
----
scala> 1 until 3
res33: scala.collection.immutable.Range = Range(1, 2)
----
Диапазони представлені в просторі констант, оскільки вони можуть бути визначені через всього три числа: початок, кінець та значення кроку. Завдяки цій репрезентації, більшість операцій з диапазонами екстремально швидкі.

Хеш дерева
~~~~~~~~~~
Хеш дерева (_tries_, або _тріз_),footnote:["Trie" походить від слова "retrieval" та вимовляються як _tree_ або _try_.] є стандартним шляхом для ефективної реалізації незмінних масивів та мап. Їх репрезентація подібна до векторів в тому, що вони також дерева, де кожний вузол має 32 елементи або 32 субдерева, але вибірка робиться на основі хеш кода. Наприклад, щоб знайти наданий ключ, ви використовуєте молодші п'ять біт хеш коду від ключа, щоб обрати перше піддерево, наступні п'ять біт для іншого субдерева, і так далі. Вибірка зупиняється, як тільки всі елементи, що містяться в вузлі, мають хеш коди, які відрізняються один від одного в бітах, що вже вибрані. Таким чином, не всі біти хеш коду обов'язково використовуються.

Хеш _тріз_ поцілюють добрий баланс між достатньо швидкими пошуками та досить ефективними функціональними вставками (`+`) та видаленнями (`-`). Ось чому вони служать основою для реалізації по замовчанню для незмінних мап та множин Scala. Фактично, Scala має подальшу оптимізацію для незмінних множин та мап, що мають меньше ніж п'ять елементів. Множини та мапи від одного до чотирьох елементів зберігаються як один об'єкт, що містить самі елементи (або пари ключ/значення в випадку мап) як поля. Порожня незмінна множина та порожня незмінна мапа є в кожному випадку об'єктом синглтона  — немає потреби дублювати сховище для них, оскільки порожня множина та порожня мапа будуть завжди залишатись порожніми.

Червоне-чорне дерева
~~~~~~~~~~~~~~~~~~~~
Дерева червоне-чорне є формою збалансованих дерев, коли деякі вузли відмічені як "червоні" та інші "чорні". Як любі збалансовані двійникові дерева, операції на них надійно завершуються за час, логірифмічний до розміру дерева.

Scala провадить реалізації множин та мап, що внутрішньо використовують красне-чорне. Ви отримуєте доступ до них під іменами `TreeSet` та `TreeMap`:
[source,scala]
----
scala> val set = collection.immutable.TreeSet.empty[Int]
set: scala.collection.immutable.TreeSet[Int] = TreeSet()

scala> set + 1 + 3 + 3
res34: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)
----
Дерева червоне-чорне є також стандартною реалізацією `SortedSet` в Scala, оскільки вони провадять ефективний ітератор, що повертає всі елементи множини у впорядкованому вигляді.

Незмінні бітові множини
~~~~~~~~~~~~~~~~~~~~~~~
Бітова множина представляє колекцію малих цілих, як бітів більшого цілого. Наприклад, бітова множина, що містить 3, 2 та 0, буде представлене як ціле `1101` в бінарній системі, що є `13` десятичними.

Внутрішньо бітові множини використовують масив з 64-бітних `Long`. Перший `Long` в масиві є для цілих від 0 до 63, другий для від 64 до 127, і так далі. Таким чином, бітові множини дуже компактні, доки найдовше ціле в множині меньше ніж декілька сотен, або десь так.

Операції на бітових наборах дуже швидкі. Перевірка на включення займає сталий час. Додавання елемента до множини пропорційна до числа `Long` в масиві бітової множини, що типово мале число. Ось деякі прості приклади використання бітових множин:
[source,scala]
----
scala> val bits = scala.collection.immutable.BitSet.empty
bits: scala.collection.immutable.BitSet = BitSet()

scala> val moreBits = bits + 3 + 4 + 4
moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)

scala> moreBits(3)
res35: Boolean = true

scala> moreBits(0)
res36: Boolean = false
----

Спискові мапи
~~~~~~~~~~~~~
Спискова мапа представляє мапу як пов'язаний список пар ключ-значення. Загалом, операції на спискових мапах мають ітерувати по цілому списку. Таким чином, операції на списковій мапі займають час лінійно до розміру мапи. Фактично, існує невелике застосування списковим мапам в Scala, оскільки стандартні незмінні мапи майже завжди швидші. Одна можлива різниця є, коли якщо мапа з якихось причин сконструйована в такий спосіб, що перші елементи обираються значно більш часто, ніж інші елементи.
[source,scala]
----
scala> val map = collection.immutable.ListMap(
1 -> "one", 2 -> "two")
map: scala.collection.immutable.ListMap[Int,String] = Map(1
-> one, 2 -> two)

scala> map(2)
res37: String = "two"
----

24.9 Суцільні класи змінних колекцій
------------------------------------
Тепер, коли ви бачили найбільш загально використовувані класи незмінних колекцій, що провадить Scala в своїй стандартній бібліотеці, поглянемо на класи змінних колекцій.

Буфери масивів
~~~~~~~~~~~~~~
Ви вже бачили буфери масивів в Розділі 17.1. Буфер масиву зберігає масив та розмір. Більшість операцій на буфері масивів має ту саму швидкість, що і для масивів, оскільки операції просто отримують доступ та модифікують підлеглий масив. Додатково, буфери масивів можуть ефективно додавати дані в кінець. Додавання елементу до буферу масиву триває амортизовано сталий час. Таким чином, буфери масивів корисні для ефективної побудови великих колекцій, коли нові елементи завжди додаються в кінець. Ось деякі приклади:
[source,scala]
----
scala> val buf = collection.mutable.ArrayBuffer.empty[Int]
buf: scala.collection.mutable.ArrayBuffer[Int]
  = ArrayBuffer()

scala> buf += 1
res38: buf.type = ArrayBuffer(1)

scala> buf += 10
res39: buf.type = ArrayBuffer(1, 10)

scala> buf.toArray
res40: Array[Int] = Array(1, 10)
----

Буфери списків
~~~~~~~~~~~~~~
Ви вже бачили буфери списків в Розділі 17.1. Буфери списків подібні до буферів масивів, за виключенням того, що вони внутрішньо використовують зв'язані списки замість масивів. Якщо ви плануєте конвертувати буфер на список, коли він буде побудований, використовуйте буфер списків замість буферу масивів. Ось приклад:footnote:[`buf.type`, що з'являється в відповідях інтерпретатора в цьому та деяких інших прикладах цього розділу є типом синглтона. Як буде пояснено в Розділі 29.6, `buf.type` означає, що змінна зберіагє в точності об'єкт, на який посилається `buf`.]
[source,scala]
----
scala> val buf = collection.mutable.ListBuffer.empty[Int]
buf: scala.collection.mutable.ListBuffer[Int]
  = ListBuffer()

scala> buf += 1
res41: buf.type = ListBuffer(1)

scala> buf += 10
res42: buf.type = ListBuffer(1, 10)

scala> buf.toList
res43: List[Int] = List(1, 10)
----

Побудовники рядків
~~~~~~~~~~~~~~~~~~~
Так само, як буфери масивів корисні для побудови масивів та буфери списків корисні для побудови списків, побудовник рядків корисний для побудови рядків. Побудовники рядків використовуються настільки загально, що вони завжди імпортуються в простір імен по замовчанню. Створюйте їх просто як `new StringBuilder`:
[source,scala]
----
scala> val buf = new StringBuilder
buf: StringBuilder =

scala> buf += 'a'
res44: buf.type = a

scala> buf ++= "bcdef"
res45: buf.type = abcdef

scala> buf.toString
res46: String = abcdef
----

Зв'язані списки
~~~~~~~~~~~~~~~
Зв'язані списки є змінні послідовності, що складаються з вузлів, що пов'язані вказівниками `next`. В більшості мов `null` може бути взятий як порожній зв'язаний список. Це не робить для Scala колекцій, оскільки навіть порожні послідовності мають підтримувати всі методи послідовностей. Зокрема, `LinkedList.empty.isEmpty` повинно повертати `true` та не закидати `NullPointerException`. Порожні зв'язані списки замість цього закодовані в особливий спосіб: їх поле `next` вказує назад до самого вузла.

Як їх незмінні колеги, зв'язані списки краще обробляються послідовно. На додаток зв'язані списки спрощують вставку елемента або зв'язаного списку в інший зв'язаний список.

Подвійно зв'язаний список
~~~~~~~~~~~~~~~~~~~~~~~~~
`DoubleLinkedLists` подібні до однозв'язаних списків, описаних в попередньому підрозділі, але крім `next` вони мають інше змінне поле, `prev`, що вказує на елемент перед поточним вузлом. Головна перевага цього додаткового посилання в тому, що це робить видалення елементу дуже швидким.

Змінні списки
~~~~~~~~~~~~~
`MutableList` складається з одного зв'язаного списку, разом з вказівником, що посилається на термінальний порожній вузол цього списку. Це робить додавання до списку операцією сталого часу, оскільки уникається подорожування по списку в пошуку термінального вузла. `MutableList` наразі є стандартною реалізацією `mutable.LinearSeq` в Scala.

Черги
~~~~~
Scala провадить змінні черги, на додаток до незмінних. Ви використовуєте змінні черги подібно до того, як використовуються незмінні, але замість `enqueue` ви використовуєте оператори `+=` та `++=` для додавання. Також на змінній черзі метод `dequeue` буде лише видаляти головний елемент з черги та повертати його. Ось приклад:
[source,scala]
----
scala> val queue = new scala.collection.mutable.Queue[String]
queue: scala.collection.mutable.Queue[String] = Queue()

scala> queue += "a"
res47: queue.type = Queue(a)

scala> queue ++= List("b", "c")
res48: queue.type = Queue(a, b, c)

scala> queueres49: scala.collection.mutable.Queue[String] = Queue(a, b, c)

scala> queue.dequeue
res50: String = a

scala> queue
res51: scala.collection.mutable.Queue[String] = Queue(b, c)
----

Послідовності масивів
~~~~~~~~~~~~~~~~~~~~~
Послідовності масивів є змінні послідовності фіксованого розміру, що зберігають свої елементи всередині як `Array[AnyRef]`. Вони реалізовані в Scala як клас `ArraySeq`. Ви можете типово використовувати `ArraySeq`, якщо ви бажаєте масив заради його характеристик продуктивності, але ви також бажаєте створити загальні примірники послідовності, коли ви не знаєте тип елементів, і не маєте `ClassTag`, щоб запровадити під час виконання. Скоро ви дізнаєтесь про ці проблеми в Розділі 24.10.

Стеки
~~~~~
Ви бачили незмінні стеки раніше. Також є змінна версія. Це робить точно так саме, як і незмінна версія, за винятком того, що зміни відбуваються на місці. Ось приклад:
[source,scala]
----
scala> val stack = new scala.collection.mutable.Stack[Int]
stack: scala.collection.mutable.Stack[Int] = Stack()

scala> stack.push(1)
res52: stack.type = Stack(1)

scala> stack
res53: scala.collection.mutable.Stack[Int] = Stack(1)

scala> stack.push(2)
res54: stack.type = Stack(2, 1)

scala> stack
res55: scala.collection.mutable.Stack[Int] = Stack(2, 1)

scala> stack.top
res56: Int = 2

scala> stack
res57: scala.collection.mutable.Stack[Int] = Stack(2, 1)

scala> stack.pop
res58: Int = 2

scala> stack
res59: scala.collection.mutable.Stack[Int] = Stack(1)
----

Стекі з масивів
~~~~~~~~~~~~~~~
`ArrayStack` є альтернативною реалізацією змінного стеку, до базується на `Array`, що змінює розмір за потреби. Він провадить швидке індексування, і загалом трохи більше ефективний для більшості операцій, ніж звичайний змінний стек.

Хеш таблиці
~~~~~~~~~~~
Хеш таблиця зберігає свої елементи в підлеглому масиві, покладаючи кожний елемент в позицію в масиві, що визначається хеш кодом цього елемента. Додавання елемента до хеш таблиці займає тільки сталий час, доки немає іншого елемента в масиві, що май той самий хеш код. Таким чином хеш таблиці дуже швидкі, доки об'єкти, що покладаються в них мають гарне розподілення хеш кодів. Як результат, по замовчанню типи змінної мапи та множини в Scala базуються на хеш таблицях.

Хеш множини та мапи використовуються так само, як любі інші множини або мапи. Ось деякі прості приклади:
[source,scala]
----
scala> val map = collection.mutable.HashMap.empty[Int,String]
map: scala.collection.mutable.HashMap[Int,String] = Map()

scala> map += (1 -> "make a web site")
res60: map.type = Map(1 -> make a web site)

scala> map += (3 -> "profit!")
res61: map.type = Map(1 -> make a web site, 3 -> profit!)

scala> map(1)
res62: String = make a web site

scala> map contains 2
res63: Boolean = false
----
Ітерація по хеш таблиці не гарантовано виконується в деякому певному порядку. Ітерація просто проходить по підлеглому масиву,в якому б порядку це не траплялось. Щоб отримати гарантований порядок ітерації використовуйте зв'язану мапо або множину, замість звичайної. Зв'язана хеш мапа або множина така сама, як і звичайна мапа або множина, за тим винятком, що він таком влючає зв'язаний список елементів в тому порядку, як вони додавались. Ітерація по такій колекції відбувається завжди в тому порядку, в якому елементи були додані.

Слабкі хеш мапи
~~~~~~~~~~~~~~~
Слабка хеш мапа є особливим різновидом хеш мапи, в якій збирач сміття не слідує посиланням від мапи до ключів, що зберігаються в ній. Це означає, що ключ та його асоційоване значення будуть зникати з мапи, якщо немає іншого посилання на ключ. Слабкі хеш мапи корисні для завдань таких як кешування, де ви бажаєте пере-використати результат коштовної функції, коли функція викликається знову на тому ж ключі. Якщо ключі та результати функції зберігаються в звичайній хеш мапі, мапа буде зростати без обмежень, і жодний ключ ніколи не стане сміттям. Використання слабкої хеш мапи уникає цієї проблеми. Як тільки об'єкт ключа стає недосяжний, його входження видаляється зі слабкої хеш мапи. Слабкі хеш мапи в Scala реалізовані як огортка підлеглої Java реалізації, `java.util.WeakHashMap`.

Конкурентні мапи
~~~~~~~~~~~~~~~~
Конкурентні мапи можуть отримувати доступ з декількох потоків одночасно. На додаток до звичайних операцій з `Map`, вони провадять наступні атомарні операції:

[caption="Операції трейта ConcurrentMap"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
|m putIfAbsent(k, v)|Додає прив'язку ключ/value `k -> m`, за винятком коли `k` вже визначений в `m`
|m remove (k, v)|Видаляє входження для `k`, якщо він наразі відображений на `v`
|m replace (k, old, new)|Замінює значення, асоційоване з ключем `k` на `new`, якщо віе до цього був прив'язаний до `old`
|m replace (k, v)|Замінює значення, асоційоване з ключом `k` до `v`,якщо він до цього був пов'язаний з деяким значенням
|===

`ConcurrentMap` є трейтом в бібліотеці колекцій Scala. Наразі єдиною реалізацією є Java `java.util.concurrent.ConcurrentMap`, що може бути конвертований автоматично в мапу Scala, використовуючи стандартні перетворення колекцій Java/Scala, що будуть описані в Розділі 24.17.

Змінні бітові множини
~~~~~~~~~~~~~~~~~~~~~
Змінні бітові множини такі самі, як незмінні, за виключенням того, що вони можуть бути модифіковані на місці. Змінні бітові множини трохи більше ефективні при оновленні, ніж незмінні, оскільки вони не мають копіювати `Long`, що не були змінені. Ось приклад:
[source,scala]
----
scala> val bits = scala.collection.mutable.BitSet.empty
bits: scala.collection.mutable.BitSet = BitSet()

scala> bits += 1
res64: bits.type = BitSet(1)

scala> bits += 3
res65: bits.type = BitSet(1, 3)

scala> bits
res66: scala.collection.mutable.BitSet = BitSet(1, 3)
----

24.10 Масиви
------------
Масиви є особливим різновидом колекцій в Scala. З одного боку, масиви Scala відповідають один-до-одного до масивів Java. Тобто Scala масив `Array[Int]` представлений як Java `int[]`, `Array[Double]` представлений як Java `double[]` та `Array[String]` представлений як Java `String[]`. Але в той самий час, Scala масиви пропонують значно більше, ніж Java аналоги. Перше, масиви Scala можуть бути дженеріками. Тобто, ви можете мати `Array[T]`, де `T` є параметром типу або абстрактном типом. Друге, масиви Scala сумісні зі Scala послідовностями — ви можете передати `Array[T]`, де потрібне `Seq[T]`. Нарешті, масиви Scala також підтримують всі операції послідовностей. Ось приклад цього в дії: 
[source,scala]
----
scala> val a1 = Array(1, 2, 3)
a1: Array[Int] = Array(1, 2, 3)

scala> val a2 = a1 map (_ * 3)
a2: Array[Int] = Array(3, 6, 9)scala> val a3 = a2 filter (_ % 2 != 0)
a3: Array[Int] = Array(3, 9)

scala> a3.reverse
res1: Array[Int] = Array(9, 3)
----
Беручи до уваги, що Scala масиви представлені як масиви Java, як ці додаткові можливості підтримуються в Scala?

Відповідь полягає в систематичному використанні неявних перетворень. Масив не може претендувати на звання послідовності, оскільки тип даних, що представляє природні масиви, не є субтипом `Seq`. Замість цього, кожного разу, коли масив використовується як Seq, він неявно огортається в субклас `Seq`. Ім'я цього субкласу - `scala.collection.mutable.WrappedArray`. Тут ви бачите його в дії:
[source,scala]
----
scala> val seq: Seq[Int] = a1
seq: Seq[Int] = WrappedArray(1, 2, 3)

scala> val a4: Array[Int] = seq.toArray
a4: Array[Int] = Array(1, 2, 3)

scala> a1 eq a4
res2: Boolean = true
----
Ця взаємодія демонструє, що масиви сумісні з послідовностями, оскільки є неявне перетворення від `Array` до `WrappedArray`. Ідучи іншим шляхом, від `WrappedArray` до `Array`, ви можете використовувати метод `toArray`, визначений в `Traversable`. Останній рядок інтерпретатора вище показує, що огортання та потім розгортання за допомогою `toArray` дає вам той самий масив, з якого ви починали.

Існує також інше неявне перетворення, що застосовується до масивів. Це перетворення просто "додає" всі методи послідовностей до масивів, але не перетворює самий масив на послідовність. "Додавання" означає, що масив огортається в інший об'єкт `ArrayOps`, що підтримує всі методи послідовностей. Типово цей об'єкт `ArrayOps` коротко-тривалий; він зазвичай буде недоступний після виклику метода послідовності та його сховище буде утилізоване. Сучасні VM часто уникають створення цього об'єкту повністю.

Різниця між двома неявними перетвореннями масивів демонструється нижче:
[source,scala]
----
scala> val seq: Seq[Int] = a1
seq: Seq[Int] = WrappedArray(1, 2, 3)

scala> seq.reverse
res2: Seq[Int] = WrappedArray(3, 2, 1)

scala> val ops: collection.mutable.ArrayOps[Int] = a1
ops: scala.collection.mutable.ArrayOps[Int] = [I(1, 2, 3)

scala> ops.reverse
res3: Array[Int] = Array(3, 2, 1)
----
Ви бачите, що виклик `reverse` на `seq`, що є `WrappedArray`, знову буде давати `WrappedArray`. Це логічно, оскільки огорнуті масиви є `Seqs`, і виклик `reverse` на любому `Seq` буде знову давати `Seq`. З іншого боку, виклик `reverse` на `ops` значенні класу `ArrayOps` дасть в результаті `Array`, не `Seq`. Приклад `ArrayOps` вище був досить штучний, призначений тільки показати різницю з `WrappedArray`. Звичайно ви ніколи не визначаєте значення класу `ArrayOps`. Ви просто викликаєте метод `Seq` на масиві:
[source,scala]
----
scala> a1.reverse
res4: Array[Int] = Array(3, 2, 1)
----
Об'єкт `ArrayOps` вставляється автоматично через неявне перетворення. Так що рядок вище еквівалентний до наступного рядка, де `intArrayOps` було перетворенням, що було неявно вставленим до цього:
[source,scala]
----
scala> intArrayOps(a1).reverse
res5: Array[Int] = Array(3, 2, 1)
----
Це підіймає питання, як компілятор обирає `intArrayOps` перед іншим неявним перетворенням до `WrappedArray` в рядку вище. Кінець кінцем, обоє перетворення відображають масив на тип, що підтримує метод `reverse`, де це те, що вказане на вході. Відповідь на це питання в тому, що ці два неявні перетворення мають преоритети. Перетворення `ArrayOps` має вищий преоритет, ніж перетворення `WrappedArray`. Перший визначений в об'єкті `Predef`, тоді як другий визначений в класі `scala.LowPriorityImplicits`, що є суперкласом `Predef`. Неявні в субкласах та субоб'єктах мають перевагу над неявними в базових класах. Так що коли можуть застосовуватись обоє перетворень, буде обрана версія з `Predef`. Дуже подібна схема, що була описана в Розділі 21.7, робить для рядків.

Так що зараз ви знаєте, як масиви можуть бути сумісні з послідовностями та як вони можуть підтримувати всі операції послідовностей. Як щодо дженерікив? В Java ви не можете записати `T[]`, де `T` є параметром типу. Тоді як представлені `Array[T]` в Scala? Фактично, дженерік масив як `Array[T]` може бути під час виконання любим з вісьми масивів примітирних типів Java: `byte[]`, `short[]`, `char[]`, `int[]`, `long[]`, `float[]`, `double[]`, `boolean[]`, або він може бути масивом об'єктів. Єдиний загальний рантайм тип, що обіймає всі ці типи, є `AnyRef` (або, що еквівалентно, `java.lang.Object`) так що це той тип, на який компілятор Scala відображує `Array[T]`. Під час виконання, коли виконується доступ або модифікація елементу масиву типу `Array[T]`, відбувається послідовність перевірок типу, що визначає справжній тип масиву, за яким слідує коректна операція масиву на Java масиві. Ці перевірки типів дещо уповільнюють операції з масивами. Ви можете очікувати, що доступ до дженерік масивів будуть від трьох до чотирьох разів повільніші, ніж доступ до примітивних або об'єктних масивів. Це означає, що якщо вам треба максимальна продуктивність, вам треба обирати суцільні масиви замість дженерікив.

Однак представити дженерік масиви не є достатнім також має бути спосіб створювати дженерік масиви. Існує навіть складніша проблема, що потребує трохи більше допомоги з вашого боку. Щоб пролілюструвати проблему, розглянемо наступну спробу написати дженерік метод, що створює масив:
[source,scala]
----
// Це невірно!
def evenElems[T](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
----
Метод `evenElems` повертає новий масив, що складається з усіх елементів аргументу-вектора `xs`, що стоять в векторі на парних позиціях. Перший рядок тіла `evenElems` створює результуючий масив, що має той самий тип елементів, що і аргумент. Так що, в залежності від дійсного параметру типу `T`, це могло бути `Array[Int]`, або `Array[Boolean]`, або масив деякого іншого примітивного типу Java, або масив деякого типу посилання. Але ці типи мають різні репрезентації під час виконання, то як рантайм Scala збирається обрати коректний тип? Фактично, він не може зробити це базуючись на наданій йому інформації, оскільки справжній тип, що відповідає параметру типу `T`, затирається під час виконання. Ось чому ви отримаєте наступне повідомлення про помилку, якщо ви намагатиметесь скомпілювати код вище:
[source,scala]
----
error: cannot find class tag for element type T
  val arr = new Array[T]((arr.length + 1) / 2)
            ^
----
Що тут потрібне, це ваша допомога компілятору шляхом провадження підказки рантайму, якій справжній тип параметру `evenElems`. Ця підказка часу виконання приймає форму класового тегу `typescala.reflect.ClassTag`. Класовий тег описує затертий тип даного типу, що є всею інформацією, потрібною для конструювання масиву цього типу.

В багатьох випадках компілятор може генерувати класовий тег сам по собі. Це випадок для суцільних типів, як `Int` або `String`. Це також випадок для певних дженерік типів, як `List[T]`, де відомо досить інформації, щоб зпрогнозувати затертий тип; в цьому випадку затертий тип буде `List`.

Для повністю дженерік класів звичайна ідиома є передавати класовий тег використовуючи обмеження контексту, як обговорювалось в Розділі 21.6. Ось як визначення вище може бути полагоджене, через використання обмеження контексту:
[source,scala]
----
// Це робить
import scala.reflect.ClassTag
def evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
----
В цьому новому визначенні, коли створюється `Array[T]`, компілятор шукає класовий тег для параметру типу `T`, тобто, він буде шукати неявне значення типу `ClassTag[T]`. Якщо таке значення буде знайдене, класовий тег використовується для конструювання правильного типу масиву. Інакше ви побачите повідомлення про помилку, яке ви бачили до цього.

Ось інтеракція з інтерпретатором, що використовує метод `evenElems`:
[source,scala]
----
scala> evenElems(Vector(1, 2, 3, 4, 5))
res6: Array[Int] = Array(1, 3, 5)

scala> evenElems(Vector("this", "is", "a", "test", "run"))
res7: Array[java.lang.String] = Array(this, a, run)
----
В обох випадках компілятор Scala компілятор автоматично конструює класовий тег для типу елементів (перший - `Int`, другий - `String`) та передає його до неявного параметру метода `evenElems`. Компілятор може зробити це для суцільних типів, але ні, якщо аргумент самий є іншим параметром типу без свого класового тегу. Наприклад, наступне схибить:
[source,scala]
----
scala> def wrap[U](xs: Vector[U]) = evenElems(xs)
<console>:9: error: No ClassTag available for U
  def wrap[U](xs: Vector[U]) = evenElems(xs)
                                        ^
----
Що відбувається тут, це те, що `evenElems` вимагає класовий тег для параметру типа `U`, але жодний не був знайдений. Рішення в цьому випадку, звичайно, що треба вимагати інший класовий тег для `U`. Так що наступне робить:
[source,scala]
----
scala> def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)
wrap: [U](xs: Vector[U])(implicit evidence$1:
scala.reflect.ClassTag[U])Array[U]
----
Цей приклад також показує, що контекст, зв'язаний в визначенні `U`, є просто скороченням для неявного параметра, що тут має назву `evidence$1` типу `ClassTag[U]`.

24.11 Рядки
-----------
Як і масиви, рядки напряму не є послідовностями, але вони можуть бути сконвертовані до них, і вони також підтримують всі операції послідовностей. Ось деякі приклади операцій, що ви можете викликати для радків:
[source,scala]
----
scala> val str = "hello"
str: java.lang.String = hello

scala> str.reverse
res6: String = olleh

scala> str.map(_.toUpper)
res7: String = HELLO

scala> str drop 3
res8: String = lo

scala> str slice (1, 4)
res9: String = ell

scala> val s: Seq[Char] = str
s: Seq[Char] = WrappedString(h, e, l, l, o)
----
Ці операції підтримуються двома неявними перетвореннями, що пояснюються в Розділі 21.7. Перше, низько-преоритетне перетворення відображує `String` до `WrappedString`, що є субкласом `immutable.IndexedSeq`. Це перетворення було застосоване в останньому рядку попереднього приклада, де рядок був перетворений на `Seq`. Інше, високо-преоритетне перетворення відображує рядок до об'єкту `StringOps`, що додає всі методи незмінних послідовностей до рядків. Це перетворення було неявно вставлене в виклики методів `reverse`, `map`, `drop` та `slice` в попередньому прикладі.

24.12 Характеристики продуктивності
-----------------------------------
Як показали попередні пояснення, різні типи колекцій мають різні характеристики продуктивності. Часто це головна причина для обирання однієї колекції, ніж іншої. Ви можете бачити характеристики продуктивності деяких загальних операцій на колекціях, підсумовані в двох таблицях, Таблиці 24.12 та Таблиці 24.12.

Характеристики продуктивності типів послідовностей
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|===
|              |head|tail|apply|update|prepend|append|insert
8+|immutable
|List          |C|C|L|L|C|L|-
|Stream        |C|C|L|L|C|L|- 
|Vector        |eC|eC|eC|eC|eC|eC|-
|Stack         |C|C|L|L|C|L|-
|Queue         |aC|aC|L|L|L|C|- 
|Range         |C|C|C|-|-|-|-
|String        |C|L|C|L|L|L|- 
8+|mutable
|ArrayBuffer   |C|L|C|C|L|aC|L
|ListBuffer    |C|L|L|L|C|C|L
|StringBuilder |C|L|C|C|L|aC|L
|MutableList   |C|L|L|L|C|C|L
|Queue         |C|L|L|L|C|C|L
|ArraySeq      |C|L|C|C|-|-|-
|Stack         |C|L|L|L|C|L|L 
|ArrayStack    |C|L|C|C|aC|L|L 
|Array         |C|L|C|C|-|-|-
|===

Характеристики продуктивності типів множин та мап
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|===
|                 |lookup|add|remove|min
5+|immutable
|HashSet/HashMap  |eC|eC|eC|L
|TreeSet/TreeMap  |Log|Log|Log|Log
|BitSet           |C|L|L|eC.footnote:[Assuming bits are densely packed.]
|ListMap          |L|L|L|L
5+|mutable
|HashSet/HashMap  |eC|eC|eC|L
|WeakHashMap      |eC|eC|eC|L
|BitSet           |C|aC|C|eC^a
|===
 
Входження в ціх двох таблицях пояснюється наступним чином:

*C* Операція займає сталий час (швидка).

*eC* Операція ефективно займає сталий час, але це може залежати від деяких припущень таких, як максимальна довжина вектора, або розподілення хеш ключей.

*aC* Операція займає амортизований сталий час. Деякі виклики операції можуть зайняти довше, але якщо виконується багато операцій,в середньому операція триває сталий час.

*Log* Операція триває час, пропорційний до логарифму розміру колекції.

*L* Операція лінійна, триває час пропорційний до розміру колекції.

*-* Операція не підтримується.

Таблиця 24.12 розглядає типи послідовностей, змінні та незмінні, для неступних операцій:

*head* Вибір першого елемента в послідовності.

*tail* Створення нової колекції, що складається з усіх елементів, крім першого.

*apply* Індексування.

*update* Функціональне оновлення (за допомогою `updated`) для незмінних послідовностей, оновлення з побічним ефектом (за допомогою `update`) для змінних послідовностей.

*prepend* Додавання елементу зпереду послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.

*append* Додавання елементу в кінець послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.

*insert* Вставка елементу в довільну позицію послідовності. Напряму це підтримується тільки для змінних послідовностей.

Таблиця 24.12 розглядає змінні та незмінні множини та мапи стосовно наступних операцій:

*lookup* Перевірка, чи елемент знаходиться в множині або обирає значення, асоційоване з ключем.

*add* Додавання нового елементу до множини або новох мапи ключ/значення до мапи.

*remove* Видалення елементу з множини або ключа з мапи.

*min* Найменьший елемент в множині, або меньший ключ в мапі.

24.13 Еквівалентність
---------------------
Бібліотеки колекцій мають уніформний підхід до рівності та хешування. Перше, ідея в тому, щоб поділити колекції на множини, мапи та послідовності. Колекції в різних категоріях завжди нерівні. Наприклад, `Set(1, 2, 3)` нерівне до `List(1, 2, 3)`, навіть якщо вони містять ті самі елементи. З іншого боку, в тій самій категорії, колекції рівні, тільки, та тільки, якщо вони мають ті самі елементи (для послідовностей: ті ж елементи в тому ж порядку). Наприклад, `List(1, 2, 3) == Vector(1, 2, 3)`, та `HashSet(1, 2) == TreeSet(2, 1)`.
 
It does not matter for the equality check whether a collection is mutable or immutable. For a mutable collection, equality simply depends on the current elements at the time the equality test is performed. This means that a mutable collection might be equal to different collections at different times, depending what elements are added or removed. This is a potential trap when using a mutable collection as a key in a hash map. For example:
[source,scala]
----
scala> import collection.mutable.{HashMap, ArrayBuffer}
import collection.mutable.{HashMap, ArrayBuffer}scala> val buf = ArrayBuffer(1, 2, 3)
buf: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer(1, 2, 3)

scala> val map = HashMap(buf -> 3)
map: scala.collection.mutable.HashMap[scala.collection.
mutable.ArrayBuffer[Int],Int] = Map((ArrayBuffer(1, 2, 3),3))

scala> map(buf)
res13: Int = 3

scala> buf(0) += 1

scala> map(buf)
java.util.NoSuchElementException: key not found:
ArrayBuffer(2, 2, 3)
----
In this example, the selection in the last line will most likely fail because the hash code of the array xs has changed in the second-to-last line. Therefore, the hash-code-based lookup will look at a different place than the one in which xs was stored.

24.14 Перегляди
---------------
Collections have quite a few methods that construct new collections. Some examples are map,filter, and ++. We call such methods transformers because they take at least one collection as their receiver object and produce another collection in their result.

Transformers can be implemented in two principal ways: strict and non-strict (or lazy). A strict transformer constructs a new collection with all of its elements. A non-strict, or lazy, transformer constructs only a proxy for the result collection, and its elements are constructed on demand.

As an example of a non-strict transformer, consider the following implementation of a lazy map operation:
[source,scala]
----
def lazyMap[T, U](coll: Iterable[T], f: T => U) =
  new Iterable[U] {
    def iterator = coll.iterator map f
  }
----
Note that lazyMap constructs a new Iterable without stepping through all elements of the given collection coll. The given function f is instead applied to the elements of the new collection'siterator as they are demanded.

Scala collections are by default strict in all their transformers, except for Stream, which implements all its transformer methods lazily. However, there is a systematic way to turn every collection into a lazy one and vice versa, which is based on collection views. A view is a special kind of collection that represents some base collection, but implements all of its transformers lazily.

To go from a collection to its view, you can use the view method on the collection. If xs is some collection, then xs.view is the same collection, but with all transformers implemented lazily. To get back from a view to a strict collection, you can use the force method.As an example, say you have a vector of Ints over which you want to map two functions in succession: 
[source,scala]
----
scala> val v = Vector(1 to 10: _*)
v: scala.collection.immutable.Vector[Int] =
Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> v map (_ + 1) map (_ * 2)
res5: scala.collection.immutable.Vector[Int] =
Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
----
In the last statement, the expression v map (_ + 1) constructs a new vector that is then transformed into a third vector by the second call to map (_ * 2). In many situations, constructing the intermediate result from the first call to map is a bit wasteful. In the pseudo example, it would be faster to do a single map with the composition of the two functions (_ + 1)and (_ * 2). If you have the two functions available in the same place you can do this by hand. But quite often, successive transformations of a data structure are done in different program modules. Fusing those transformations would then undermine modularity. A more general way to avoid the intermediate results is by turning the vector first into a view, applying all transformations to the view, and finally forcing the view to a vector:
[source,scala]
----
scala> (v.view map (_ + 1) map (_ * 2)).force
res12: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
----
We'll do this sequence of operations again, one by one:
[source,scala]
----
scala> val vv = v.view
vv: scala.collection.SeqView[Int,Vector[Int]] =
  SeqView(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
----
The application v.view gives you a SeqView, i.e., a lazily evaluated Seq. The type SeqView has two type parameters. The first, Int, shows the type of the view's elements. The second, Vector[Int], shows you the type constructor you get back when forcing the view.

Applying the first map to the view gives you:
[source,scala]
----
scala> vv map (_ + 1)
res13: scala.collection.SeqView[Int,Seq[_]] = SeqViewM(...)
----
The result of the map is a value that prints SeqViewM(...). This is in essence a wrapper that records the fact that a map with function (_ + 1) needs to be applied on the vector v. It does not apply that map until the view is forced, however. The "M" after SeqView is an indication that the view encapsulates a map operation. Other letters indicate other delayed operations. For instance "S" indicates a delayed slice operation, and "R" indicates a reverse. We'll now apply the second map to the last result.
[source,scala]
----
scala> res13 map (_ * 2)
res14: scala.collection.SeqView[Int,Seq[_]] = SeqViewMM(...)
----
You now get a SeqView that contains two map operations, so it prints with a double "M":SeqViewMM(...). Finally, forcing the last result gives:
[source,scala]
----
scala> res14.force
res15: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
----
Both stored functions get applied as part of the execution of the force operation and a new vector is constructed. That way, no intermediate data structure is needed.

One detail to note is that the static type of the final result is a Seq, not a Vector. Tracing the types back we see that as soon as the first delayed map was applied, the result had static typeSeqViewM[Int, Seq[_]]. That is, the "knowledge" that the view was applied to the specific sequence type Vector got lost. The implementation of a view for any particular class requires quite a bit of code, so the Scala collection libraries provide views mostly only for general collection types, not for specific implementations.footnote:[An exception to this is arrays: applying delayed operations on arrays will again give results with static type Array.]

There are two reasons why you might want to consider using views. The first is performance. You have seen that by switching a collection to a view the construction of intermediate results can be avoided. These savings can be quite important. As another example, consider the problem of finding the first palindrome in a list of words. A palindrome is a word that reads backwards the same as forwards. Here are the necessary definitions:
[source,scala]
----
def isPalindrome(x: String) = x == x.reverse
def findPalindrome(s: Seq[String]) = s find isPalindrome
----
Now, assume you have a very long sequence words and you want to find a palindrome in the first million words of that sequence. Can you re-use the definition of findPalindrome? Of course, you could write:
[source,scala]
----
findPalindrome(words take 1000000)
----
This nicely separates the two aspects of taking the first million words of a sequence and finding a palindrome in it. But the downside is that it always constructs an intermediary sequence consisting of one million words, even if the first word of that sequence is already a palindrome. So potentially, 999,999 words are copied into the intermediary result without being inspected at all afterwards. Many programmers would give up here and write their own specialized version of finding palindromes in some given prefix of an argument sequence. But with views, you don't have to. Simply write:
[source,scala]
----
findPalindrome(words.view take 1000000)
----
This has the same nice separation of concerns, but instead of a sequence of a million elements it will only construct a single lightweight view object. This way, you do not need to choose between performance and modularity. The second use case applies to views over mutable sequences. Many transformer functions on such views provide a window into the original sequence that can then be used to update selectively some elements of that sequence. To see this in an example, suppose you have an array arr:
[source,scala]
----
scala> val arr = (0 to 9).toArray
arr: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
----
You can create a subwindow into that array by creating a slice of a view of the array:
[source,scala]
----
scala> val subarr = arr.view.slice(3, 6)subarr: scala.collection.mutable.IndexedSeqView[
Int,Array[Int]] = IndexedSeqViewS(...)
----
This gives a view, subarr, which refers to the elements at positions 3 through 5 of the array arr. The view does not copy these elements, it just provides a reference to them. Now, assume you have a method that modifies some elements of a sequence. For instance, the following negatemethod would negate all elements of the sequence of integers it's given:
[source,scala]
----
scala> def negate(xs: collection.mutable.Seq[Int]) =
        for (i <- 0 until xs.length) xs(i) = -xs(i)
negate: (xs: scala.collection.mutable.Seq[Int])Unit
----
Assume now you want to negate elements at positions three through five of the array arr. Can you use negate for this? Using a view, this is simple:
[source,scala]
----
scala> negate(subarr)

scala> arr
res4: Array[Int] = Array(0, 1, 2, -3, -4, -5, 6, 7, 8, 9)
----
What happened here is that negate changed all elements of subarr, which were a slice of the elements of arr. Again, you see that views help in keeping things modular. The code above nicely separated the question of what index range to apply a method to from the question what method to apply.

After having seen all these nifty uses of views you might wonder why have strict collections at all? One reason is that performance comparisons do not always favor lazy over strict collections. For smaller collection sizes the added overhead of forming and applying closures in views is often greater than the gain from avoiding the intermediary data structures. A possibly more important reason is that evaluation in views can be very confusing if the delayed operations have side effects.

Here's an example that bit a few users of versions of Scala before 2.8. In these versions theRange type
was lazy, so it behaved in effect like a view. People were trying to create a number of actors,footnote:[The Scala actors library has been deprecated, but this historical example is still relevant.] like
this:
[source,scala]
----
val actors = for (i <- 1 to 10) yield actor { ... }
----
They were surprised that none of the actors were executing afterwards, even though the actormethod should create and start an actor from the code that's enclosed in the braces following it. To explain why nothing happened, remember that the for expression above is equivalent to an application of the map method:
[source,scala]
----
val actors = (1 to 10) map (i => actor { ... })
----
Since previously the range produced by (1 to 10) behaved like a view, the result of the map was again a view. That is, no element was computed, and, consequently, no actor was created! Actors would have been created by forcing the range of the whole expression, but it's far from obvious that this is what was required to make the actors do their work.

To avoid surprises like this, the Scala collections gained more regular rules in version 2.8. All

collections except streams and views are strict. The only way to go from a strict to a lazy collection is
via the view method. The only way to go back is via force. So the actors definition above would behave
as expected in Scala 2.8 in that it would create and start ten actors. To get back the surprising previous
behavior, you'd have to add an explicit view method call:
[source,scala]
----
val actors = for (i <- (1 to 10).view) yield actor { ... }
----
In summary, views are a powerful tool to reconcile concerns of efficiency with concerns of modularity. But in order not to be entangled in aspects of delayed evaluation, you should restrict views to two scenarios. Either you apply views in purely functional code where collection transformations do not have side effects. Or you apply them over mutable collections where all modifications are done explicitly. What's best avoided is a mixture of views and operations that create new collections while also having side effects.

24.15 Ітератори
---------------
An iterator is not a collection, but rather a way to access the elements of a collection one by one. The two basic operations on an iterator it are next and hasNext. A call to it.next() will return the next element of the iterator and advance the state of the iterator. Calling next again on the same iterator will then yield the element one beyond the one returned previously. If there are no more elements to return, a call to next will throw a NoSuchElementException. You can find out whether there are more elements to return using Iterator's hasNext method.

The most straightforward way to "step through" all the elements returned by an iterator is to use
a while loop:
[source,scala]
----
while (it.hasNext)
  println(it.next())
----
Iterators in Scala also provide analogues of most of the methods that you find in theTraversable, Iterable, and Seq traits. For instance, they provide a foreach method that executes a given procedure on each element returned by an iterator. Using foreach, the loop above could be abbreviated to:
[source,scala]
----
it foreach println
----
As always, for expressions can be used as an alternate syntax for expressions involvingforeach, map, filter, and flatMap, so yet another way to print all elements returned by an iterator would be:
[source,scala]
----
for (elem <- it) println(elem)
----
There's an important difference between the foreach method on iterators and the same method on traversable collections: When called on an iterator, foreach will leave the iterator at its end when it is done. So calling next again on the same iterator will fail with aNoSuchElementException. By contrast, when called on a collection, foreach leaves the number of elements in the collection unchanged (unlessthe passed function adds or removes elements, but this is discouraged, because it can easily lead to surprising results).

The other operations that Iterator has in common with Traversable have the same property of leaving the iterator at its end when done. For instance, iterators provide a map method, which returns a new iterator:
[source,scala]
----
scala> val it = Iterator("a", "number", "of", "words")
it: Iterator[java.lang.String] = non-empty iterator

scala> it.map(_.length)
res1: Iterator[Int] = non-empty iterator

scala> res1 foreach println
1
6
2
5

scala> it.next()
java.util.NoSuchElementException: next on empty iterator
----
As you can see, after the call to map, the it iterator has advanced to its end. Another example is the dropWhile method, which can be used to find the first element of an iterator that has a certain property. For instance, to find the first word in the iterator shown previously that has at least two characters, you could write:
[source,scala]
----
scala> val it = Iterator("a", "number", "of", "words")
it: Iterator[java.lang.String] = non-empty iterator

scala> it dropWhile (_.length < 2)
res4: Iterator[java.lang.String] = non-empty iterator

scala> it.next()
res5: java.lang.String = number
----
Note again that it has changed by the call to dropWhile: it now points to the second word "number" in the list. In fact, it and the result res4 returned by dropWhile will return exactly the same sequence of elements.

There is only one standard operation, duplicate, which allows you to re-use the same iterator:
[source,scala]
----
val (it1, it2) = it.duplicate
----
The call to duplicate gives you two iterators, which each return exactly the same elements as the iterator it. The two iterators work independently; advancing one does not affect the other. By contrast the original iterator, it, is advanced to its end by duplicate and is thus rendered unusable.

In summary, iterators behave like collections if you never access an iterator again after invoking a method on it. The Scala collection libraries make this explicit with an abstraction called TraversableOnce, which is a common supertrait of Traversable and Iterator. As the nameimplies, TraversableOnce objects can be traversed using foreach, but the state of that object after the traversal is not specified. If the TraversableOnce object is in fact an Iterator, it will be at its end after the traversal, but if it is a Traversable, it will still exist as before. A common use case of TraversableOnce is as an argument type for methods that can take either an iterator or traversable as argument. An example is the appending method ++ in trait Traversable. It takes aTraversableOnce parameter, so you can append elements coming from either an iterator or a traversable collection.

All operations on iterators are summarized in Table 24.12.

[caption="Операції трейта Traversable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Абстрактні методи:
|it.next()|Повертає наступний елемент ітератора `it` та просувається далі.
|it.hasNext|Повертає `true`, якщо `it` може повернути наступний елемент.
2+|Варіації:
|it.buffered|Буферизований ітератор, що повертає всі елементи `it`.
|it grouped size|Ітератор, що отримує елементи `it` в "шматках" послідовностей фіксованого розміру.
|xs sliding size|Ітератор, що отримує елементи `it` в послідовностях плаваючого вікна фіксованого розміру.
2+|Копіювання:
|it copyToBuffer buf|Копіює всі повернуті `it` елементи до буфера `buf`.

|it copyToArray(arr, s, l)|Копіює щонайбільше `l` елементів, що повертаються `it`, до `arr`, починаючи з індексу `s`. Останні два аргументи опціональні.
2+|Дублікація:
|it.duplicate|Пара ітераторів, кожний з яких незалежно повертає всі елементи `it`.
2+|Додавання:
|it ++ jt|Ітератор, що повертає всі елементи, що повертає ітератор `it`, за яким слідують елементи, що повертає ітератор `jt`.
|it padTo (len, x)|Ітератор, що повертає всі елементи `it`, за якими слідують копії `x`, доки не буде досягнута загальна довжина з `len` елементів.
2+|Мапи:
|it map f|Ітератор, що отриманий від застосування функції `f` до кожного елементу, що повертає `it`.
|it flatMap f|Ітератор, що отриманий від застосування функції зі значенням ітератора `f` до кожного елементу, та додавання результатів.
|it collect f|Ітератор, отриманий від застосування часткової функції `f` до кожного елементу в `it`, до якого вона визначена, та збирання результатів.
2+|Перетворення:
|it.toArray|Збирає елементи, що повертає `it`, в масив.
|it.toList|Збирає елементи, що повертає `it`, в список.
|it.toIterable|Збирає елементи, що повертає `it`, в `iterable.it.toSeq`
|it.toIndexedSeq|Збирає елементи, що повертає `it`, в індексовану послідовність.
|it.toStream|Збирає елементи, що повертає `it`, в потік.
|it.toSet|Збирає елементи, що повертає `it`, в множину.
|it.toMap|Збирає пари ключ/значення, що повертає `it`, в мапу.
2+|Інформація про розмір:
|it.isEmpty|Перевіряє, чи ітератор порожній (протилежність `hasNext`).
|it.nonEmpty|Перевіряє, чи колекція містить елементи (псевдоним до `hasNext`)
|it.size|Число елементів, що повертає `it`. Увага: `it` після цієї операції буде вказувати на кінець!
|it.lengt|Те саме, що 'it.size'.
|it.hasDefiniteSize|Повертає `true`, якщо відомо, що `it` повертає обмежену кількість елементів (по замовчанню те саме, що `isEmpty`).
2+|Пошук і отримання елементів:
|it find p|Опція, що містить перший елемент, що повертає `it`, який задовільняє `p`, або `None`, якщо жодний елемент не підійде. Увага: ітератор просувається після знайденого елементу, або до кінця, якщо нічого не знайдене.
|it indexOf x|Індекс першого елемента, що повертається `it`, що дорівнює `x`. Увага: ітератор просувається за позицію цього елемента.
|it indexWhere p|Індекс першого елементу, що повертається `it`, що задовільняє `p`. Увага: ітератор просувається за позицію цього елемента.
2+|Субітератори:
|it take n|Ітератор, що повертає перші `n` елементів `it`. Увага: `it` буде просуватись до позиції за `n`-ним елементом, або до кінця, якщо `it` містить меньше ніж `n` елементів.
|it drop n|Ітератор, що починається з `(n + 1)`-ного елементу `it`. Увага: `it` буде просуватись на нову позицію.
|it slice (m, n)|Ітератор, що повертає фрагмент з елементів, що повертає `it`, починаючи з `m`-того елемента, та завершуючи перед `n`-ним елементом.
|it takeWhile p|Ітератор, що повертає елементи з `it`, доки умова `p` є `true`.
|it dropWhile p|Ітератор, що пропускає елементи з `it`, доки умова `p` є `true`, та повертає залишок.
|it filter p|Ітератор, що повертає всі елементи з `it`, що задовільняє умові `p`.
|it withFilter p|Те саме, що `it filter p`. Треба для використання ітераторів в виразах `for`.
|it filterNot p|Ітератор, що повертає всі елементи з `it`, що не задовільняють `p`.
2+|Підрозділення:
|it partition p|Розділяє `it` на пару з двох ітераторів; один повертає всі елементи, що задовільняють предикатові `p`, інший повертає всі елементи з `it`, що ні.
2+|Умови до елементів:
|it forall p|Логічне, вказує, чи предикат `p` дотримується до всіх елементів, що повертає `it`.
|it exists p|Логічне, вказує, чи предикат `p` виконується для деякого елементу, що повертає `it`.
|it count p|Число елементів в `it`, що задовільняють предикату `p`.
2+|Згортки:
|(z /: it)(op)|Застосовує двомісну операцію `op` між послідовними елементами, що повертає `it`, ідучи зліва направо, починаючи з `z`.
|(it :\ z)(op)|Застосовує двомісну операцію `op` між послідовними елементами, що повертає `it`, ідучи зправа наліво, починаючи з `z`.
|it.foldLeft(z)(op)|Те саме, що (z /: it)(op).
|it.foldRight(z)(op)|Те саме, що (it :\ z)(op).
|it reduceLeft op|Застосовує вдомірну операцію `op` між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.
|it reduceRight op|Застосовує вдомірну операцію `op` між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.
2+|Специфічні згортки:
|it.sum|Сума числових елементів, що повертає ітератор.
|it.product|Добуток значень числових елементів, що повертає ітератор.
|it.min|Мінімум впорядкованих елементів, що повертає ітератор.
|it.max|Максимум впорядкованих елементів, що повертає ітератор
2+|Поєднання:
|it zip jt|Ітератор пар відповідних елементів, що повертаються ітераторами `it` та `jt`.
|it zipAll (jt, x, y)|Ітератор пар відповідних елементів, що повертаються ітераторами `it` та `jt`, де коротший ітератор розширюється, щоб співпадати з довшим, через додавання елементів `x` або `y`.
|it.zipWithIndex|Ітератор пар елементів, що повертаються `it` разом з індексами.
2+|Оновлення:
|it patch (i, jt, r)|Ітератор, отриманий з `it` заміною `r` елементів починаючи з `i` патч-ітератором `jt`.
2+|Порівняння:
|it sameElements jt|Перевіряє, чи ітератори `it` та `jt` повертають ті самі елементи в тому самому порядку. Увага: після цієї операції щонайменьше один з `it` та `jt` опиниться в кінці.
2+|Рядки:
|it addString (b, start, sep, end)|Додає рядок до `StringBuilder` `b`, що показує всі елементи, повернуті `it` з роздільниками `sep`, оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональними.
|it mkString (start, sep, end)|Конвертує ітератор на рядоко, що показує всі елементи, що обмежені роздільникими `sep`, оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональними.
|===

Buffered iterators
~~~~~~~~~~~~~~~~~~
Sometimes you want an iterator that can "look ahead" so that you can inspect the next element to be
returned without advancing past that element. Consider, for instance, the task to skip leading empty
strings from an iterator that returns a sequence of strings. You might be tempted to write something like
the following method:// This won't work
def skipEmptyWordsNOT(it: Iterator[String]) = {
while (it.next().isEmpty) {}
}
But looking at this code more closely, it's clear that this is wrong: the code will indeed skip leading
empty strings, but it will also advance it past the first non-empty string!
The solution to this problem is to use a buffered iterator, an instance of
trait BufferedIterator.BufferedIterator is a subtrait of Iterator, which provides one extra method, head.
Calling head on a buffered iterator will return its first element, but will not advance the iterator. Using a
buffered iterator, skipping empty words can be written like this:
def skipEmptyWords(it: BufferedIterator[String]) =
while (it.head.isEmpty) { it.next() }
Every iterator can be converted to a buffered iterator by calling its buffered method. Here's an example:
scala> val it = Iterator(1, 2, 3, 4)
it: Iterator[Int] = non-empty iterator
scala> val bit = it.buffered
bit: java.lang.Object with scala.collection.
BufferedIterator[Int] = non-empty iterator
scala> bit.head
res10: Int = 1
scala> bit.next()
res11: Int = 1
scala> bit.next()
res11: Int = 2
Note that calling head on the buffered iterator, bit, did not advance it. Therefore, the subsequent
call, bit.next(), returned again the same value as bit.head.
24.16 CREATING COLLECTIONS FROM SCRATCH
You have already seen syntax like List(1, 2, 3), which creates a list of three integers, andMap('A' -
> 1, 'C' -> 2), which creates a map with two bindings. This is actually a universal feature of Scala
collections. You can take any collection name and follow it by a list of elements in parentheses. The
result will be a new collection with the given elements. Here are some more examples:
Traversable()
List()
List(1.0, 2.0)
Vector(1.0, 2.0)
Iterator(1, 2, 3)
Set(dog, cat, bird)
HashSet(dog, cat, bird)
Map('a' -> 7, 'b' -> 0)
//
//
//
//
//
//
//
//
An empty traversable object
The empty list
A list with elements 1.0, 2.0
A vector with elements 1.0, 2.0
An iterator returning three integers.
A set of three animals
A hash set of the same animals
A map from characters to integers"Under the covers" each of the above lines is a call to the apply method of some object. For instance,
the third line above expands to:
List.apply(1.0, 2.0)
So this is a call to the apply method of the companion object of the List class. That method takes an
arbitrary number of arguments and constructs a list from them. Every collection class in the Scala
library has a companion object with such an apply method. It does not matter whether the collection
class represents a concrete implementation, like List, Stream, orVector, or whether it is an trait such
as Seq, Set, or Traversable. In the latter case, calling applywill produce some default implementation of
the trait. Here are some examples:
scala> List(1, 2, 3)
res17: List[Int] = List(1, 2, 3)
scala> Traversable(1, 2, 3)
res18: Traversable[Int] = List(1, 2, 3)
scala> mutable.Traversable(1, 2, 3)
res19: scala.collection.mutable.Traversable[Int] =
ArrayBuffer(1, 2, 3)
Besides apply, every collection companion object also defines a member empty, which returns an
empty collection. So instead of List() you could write List.empty, instead of Map(), Map.empty, and so
on.
Descendants of Seq traits also provide other factory operations in their companion objects. These are
summarized in Table 24.13. In short, there's:
concat, which concatenates an arbitrary number of traversables together,
fill and tabulate, which generate single or multi-dimensional sequences of given dimensions
initialized by some expression or tabulating function,
* range, which generates integer sequences with some constant step length, and
* iterate, which generates the sequence resulting from repeated application of a function to a start
element.
*
*
Factory methods for sequences
What it is
S.empty
S(x, y, z)
S.concat(xs, ys, zs)
S.fill(n)(e)
What it does
The empty sequence
A sequence consisting of elements x, y, and z
The sequence obtained by concatenating the elements of xs,ys, and zs
A sequence of length n where each element is computed by expression e
A sequence of sequences of dimension m x n where each element is computed by
S.fill(m, n)(e)
expression e (exists also in higher dimensions)
S.tabulate(n)(f)
A sequence of length n where the element at each index i is computed by f(i)
A sequence of sequences of dimension m x n where the element at each index (i, j)
S.tabulate(m, n)(f)
is computed by f(i, j) (exists also in higher dimensions)S.range(start, end)
S.range(start, end,
step)
S.iterate(x, n)(f)
The sequence of integers start ... end - 1
The sequence of integers starting with start and progressing by step increments up
to, and excluding, the endvalue
The sequence of length n with elements x, f(x), f(f(x)), ...
24.17 CONVERSIONS BETWEEN JAVA AND SCALA COLLECTIONS
Like Scala, Java has a rich collections library. There are many similarities between the two. For
instance, both libraries know iterators, iterables, sets, maps, and sequences. But there are also important
differences. In particular, the Scala libraries put much more emphasis on immutable collections, and
provide many more operations that transform a collection into a new one.
Sometimes you might need to convert from one collection framework to the other. For instance, you
might want to access to an existing Java collection, as if it were a Scala collection. Or you might want
to pass one of Scala's collections to a Java method that expects the Java counterpart. It is quite easy to
do this, because Scala offers implicit conversions between all the major collection types in
the JavaConversions object. In particular, you will find bidirectional conversions between the following
types:
Iterator
Iterator
Iterable
Iterable
mutable.Buffer
mutable.Set
mutable.Map
\null
\null
\null
\null
\null
\null
\null
java.util.Iterator
java.util.Enumeration
java.lang.Iterable
java.util.Collection
java.util.List
java.util.Set
java.util.Map
To enable these conversions, simply import like this:
scala> import collection.JavaConversions._
import collection.JavaConversions._
You have now automatic conversions between Scala collections and their corresponding Java
collections.
scala> import collection.mutable._
import collection.mutable._
scala> val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]
scala> val buf: Seq[Int] = jul
buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)
scala> val m: java.util.Map[String, Int] =
HashMap("abc" -> 1, "hello" -> 2)
m: java.util.Map[String,Int] = {hello=2, abc=1}
Internally, these conversion work by setting up a "wrapper" object that forwards all operations to the
underlying collection object. So collections are never copied when converting between Java and Scala.
An interesting property is that if you do a round-trip conversion from, say, a Java type to itscorresponding Scala type, and back to the same Java type, you end up with the identical collection
object you started with.
Some other common Scala collections exist that can also be converted to Java types, but for which no
corresponding conversion exists in the other direction. These are:
Seq
mutable.Seq
Set
Map
\null
\null
\null
\null
java.util.List
java.util.List
java.util.Set
java.util.Map
Because Java does not distinguish between mutable and immutable collections in their type, a
conversion from, say, collection.immutable.List will yield a java.util.List, on which all attempted
mutation operations will throw an UnsupportedOperationException. Here's an example:
scala> val jul: java.util.List[Int] = List(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]
scala> jul.add(7)
java.lang.UnsupportedOperationException
at java.util.AbstractList.add(AbstractList.java:131)

24.18 Висновок
==============
You've now seen how to use Scala's collection in great detail. Scala's collections take the approach of
giving you powerful building blocks rather than a number of ad hoc utility methods. Putting together
two or three such building blocks allows you to express an enormous number of useful computations.
This style of library is especially effective due to Scala having a light syntax for function literals, and
due to it providing many collection types that are persistent and immutable.
This chapter has shown collections from the point of view of a programmer using the collection library.
The next chapter will show you how the collections are built and how you can add your own collection
types.
