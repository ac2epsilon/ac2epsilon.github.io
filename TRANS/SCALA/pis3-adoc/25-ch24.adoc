include::headers.adoc[]

Глава 24
--------

Колекції: докладно
==================

Scala включає елегантну та потужну бібліотеку колекцій. Навіть якщо вважати, що API колекцій тонкий на перший погляд, зміни, які він може спровокувати в вашому стилі програмування можуть бути грунтовними. Досить часто це так, якби ви робили на вищому рівні з базовими будівельними блоками програми, що є цілими колекціями, ніж їх елементами. Цей новий стиль програмування потребує деякої адаптації. Нащастя, адаптації допомагють декілька милих властивостей Scala колекцій. Вони прості в використанні, стислі, безпечні, швидкі та універсальні.

* *Простота в використанні:* Невеликого словника з двадцяти до сорока методів, досить для вирішення більшості проблем колекцій в парі операцій. Намає потреби огортати вашу голову кругом складних циклічних структур або рекурсій. Стійкі колекції вільні від операцій з побічними ефектами, що означає, що вам не треба хвилюватись про випадкове руйнування існуючих колекцій новими даними. Взаємодію між ітераторами та оновленнями колекцій ліквідовано.

* *Стислість:* Ви можете досягти за допомогою одного слова те, що раніше займало один або декілька циклів. Ви можете виразити функціональні операції за допомогою легковажного синтаксису, та без зусиль комбінувати операції, так що результат відчувається як власна алгебра.

* *Безпечність:* Щоб зрозуміти це, треба мати досвід. Статична типізація та функціональна природа Scala колекцій означає, що переважна більшість помилок, які ви можете зробити, відловлюються під час компіляції. Причини цього в тому, що (1) операції колекцій самі часто використовуються, і, таким чином, гарно протестовані. (2) використання операцій з колекціями робить входи та виходи явними, як параметри функції та результати. (3) Ці явні входи та виходи є предметом перевірки статичних типів. Підсумок всього цього в тому, що велика більшість хибних використань будуть заявляти про себе як помилки типів. Взагалі не є рідкістю мати програми з декількох сотень рядків, що роблять з першої спроби.

* *Швидкість:* Операції з колекціями настроєні і оптимізовані в бібліотеках. Як результат, використання колекцій типово досить ефективне. Ви можете бути в змозі зробити все трохи краще, через уважно налаштовані структури даних та операції, але ви також можете зробити все значно гірше, по ходу справи прийнявши якісь неоптимальні рішення з реалізації. Більше того, колекції були адаптовані до паралельної виконання на декількох ядрах. Паралельні колекції підтримують ті самі операції, що і послідовні, так що не треба вивчати нові операції та переписувати код. Ви можете перетворити послідовну колекцію в паралельну, просто викликавши метод `par`.

* *Універсальність:* Колекції провадять ті самі операції на любому типі, коли це має сенс робити. Так що ви можете багато чого досягти з досить малим словником операцій. Наприклад, рядок концептуально є послідовністю символів. Відповідно, в Scala колекціях рядок підтримує всі операції послідовностей. Те саме дійсне і для масивів.

Ця глава поглиблено описує API для класів колекцій Scala з перспективи користувача. Ви вже бачили швидкий тур по бібліотеці колекцій в Главі 17. Ця глава запрошує вас в більш детальний тур, показуючи всі класи колекцій, і всі методи, що вони визначають, так що вона включає все, що вам треба знати для використання Scala колекцій. Дивлячись наперед, Глава 25 буде сконцентрована на архитектурі та аспектах розширюваності бібліотеки, для людей, що реалізують нови типи колекцій.

24.1 Змінні та незмінні колекції
--------------------------------
Як ви вже знаєте, Scala колекції систематично відрізняють змінні та незмінні колекції. Змінні колекції можуть бути оновлені або розширені на місці. Це означає, що ви можете змінювати, додавати, або видаляти елементи колекції як побічний ефект. Незмінні колекції, для контрасту, ніколи не змінюються. Ви все ще маєте операції, що симулюють додавання, видалення або оновлення, але ці операції будуть в любому випадку повертати нову колекцію, та залишати стару колекцію незмінною.

Всі класи колекцій знаходяться в пакунку `scala.collection`, або одному з його субпакунків: `mutable`, `immutable`, та `generic`. Більшість класів колекцій, що потрібні клієнтському коду, існують в трьох варіантах, кожний з яких має різні характеристики з точки зору змінності. Три варіанти розміщені в пакунках `scala.collection`, `scala.collection.immutable`, та `scala.collection.mutable`.

Колекція в пакунку `scala.collection.immutable` гарантовано буде незмінною для будь-кого. Така колекція ніколи не буде змінюватись після її створення. Таким чином, ви можете покладатись на факт, що отримуєте доступ до значення тієї самої колекції постійно, і в різних точках часу будете завжди мати колекцію з тими самими елементами.

Колекція в пакунку `scala.collection.mutable` знана що має деякі операції, що змінюють колекцію на місці. Ці операції дозволяють вам писати код для зміни колекції самотужки. Однак ви маєте бути уважним, щоб розуміти та захищатись від любих оновлень, що виконують інші частини кодової бази.

Колекція в пакунку `scala.collection` може бути або змінною, або незмінною. Наприклад,`scala.collection.IndexedSeq[T]` є супертрейтом обох, `scala.collection.immutable.IndexedSeq[T]`, та її родички, `scala.collection.mutable.IndexedSeq[T]`. Загалом, кореневі колекції в пакунку `scala.collection` визначають той самий інтерфейс, що і незмінні колекції. І типово, змінні колекції в пакунку `scala.collection.mutable` додають деякі модифікації з побічним ефектом до цього незмінного інтерфейсу.

Різниця між кореневими колекціями та незмінними колекціями в тому, що клієнти назмінних колекцій мають гарантію, що ніхто не може змінити колекцію, коли як клієнти кореневих колекцій знають тільки, що вони самі не можуть змінити колекцію. Навіть зважаючи, що статичний тип такої колекції не провадить операцій для модифікації колекції, все ще може бути можливим, щоб тип часу виконання був змінною колекцією, що може бути змінена іншими клієнтами.

По замовчанню Scala завжди обирає незмінні колекції. Наприклад, якщо ви просто пишете `Set` без жодного префіксу, або без імпорту будь-чого, ви отримаєте незмінну множину, і якщо ви напишете `Iterable`, ви отримаєте незмінне ітерабельне, оскільки ці прив'язки по замовчанню імпортуються з пакунка `scala`. Щоб отримати змінні версії по замовчанню, вам треба написати явно `collection.mutable.Set`, або `collection.mutable.Iterable`.

Останній пакунок в ієрархії колекцій є `collection.generic`. Цей пакунок містить будівельні блоки для реалізації колекцій. Типово, класи колекцій відкладають реалізації деяких зі своїх операцій до класів в `generic`. З іншого боку, щоденні користувачі фреймворку колекцій мають потребу посилатись на класи в `generic` тільки за виключних обставин.

Ієрархія колекцій.
~~~~~~~~~~~~~~~~~~
----
Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4
----            

24.2 Узгодженість колекцій
--------------------------
Найбільш важливі класи колекцій показані на Малюнку 24.1. Є досить загального, що поділяють ці класи. Наприклад, кожний різновид колекції може бути створений за однаковим уніформним синтаксисом, записуючи ім'я класу колекції, за яким ідуть його елементи:
[source,scala]
----
Traversable(1, 2, 3)
Iterable("x", "y", "z")
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(Color.Red, Color.Green, Color.Blue)
SortedSet("hello", "world")
Buffer(x, y, z)
IndexedSeq(1.0, 2.0)
LinearSeq(a, b, c)
----
Той самий принцип також стосується специфічних реалізацій колекцій:
[source,scala]
----
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)
----
Метод `toString` для всіх колекцій продукує вивід, записаний як вище, з іменем типу, за яким в дужках ідуть елементи колекції. Всі колекції підтримують API, що провадить `Traversable`, але їх методи всі повертають їх власний клас, скоріше ніж кореневий клас  `Traversable`. Наприклад, метод `map` на `List` має тип повернення `List`, тоді як метод `map` на `Set` має тип повернення `Set`. Таким чином, статичний тип повернення ціх методів досить точний:
[source,scala]
----
scala> List(1, 2, 3) map (_ + 1)
res0: List[Int] = List(2, 3, 4)

scala> Set(1, 2, 3) map (_ * 2)
res1: scala.collection.immutable.Set[Int] = Set(2, 4, 6)
----
Еквівалентність також організована одноманітно для всіх класів колекцій; більше про це в Розділі 24.13.

Більшість класів на Малюнку 24.1 існують в трьох варіантах: `root`, `mutable`, та `immutable`. Одне виключення є трейт `Buffer`, що існує тільки як змінна колекція.

В залишку цієї глави ми будемо переглядати ці класи один за одним.

24.3 Трейт `Traversable`
------------------------
На вершині ієрархії колекцій стоїть трейт `Traversable` (_прохідний_). Його єдина операція є `foreach`:
[source,scala]
----
def foreach[U](f: Elem => U)
----
Класам колекцій, що реалізують `Traversable`, просто потрібно визначити цей метод; всі інші методи можуть бути наслідувані від `Traversable`.

Метод `foreach` призначений для обходу всіх елементів колекції, та застосування наданої операції `f` до кожного елементу. Тип операції `Elem => U`, де `Elem` є типом елементів колекції, та `U` є довільним типом результату. Виклик `f` робиться тільки заради побічного ефекту; фактично, любий результат функції `f` буде відкинутий `foreach`.

`Traversable` також визначає багато суцільних методів, всі вони перелічені в Таблиці 24.1. Ці методи підпадають в такі категорії:

* *Додавання* `++`, що додає два прохідних разом, або додає всі елементи ітератора до прохідного.

* *Операції відображення* `map`, `flatMap`, та `collect`, що продукують нову колекцію через застосування деякої функції до елементів колекції.

* *Перетворення* `toIndexedSeq`, `toIterable`, `toStream`, `toArray`, `toList`, `toSeq`, `toSet`, та `toMap`, що повертають колекцію `Traversable` в більш специфічну колекцію. Всі ці перетворення повертають об'єкт отримувача, якщо він вже відповідає бажаному типу колекції. Наприклад, застосування `toList` до списку буде повертати сам список.

* *Операції копіювання* `copyToBuffer` та `copyToArray`. Як кажуть їх імена, вони копіюють елементи колекції до буфера або масива, відповідно.

* *Операції розміру* `isEmpty`, `nonEmpty`, `size`, та `hasDefiniteSize`. Колекції, що є прохідними, можуть бути скінченими та нескінченими. Прикладом нескінченої прохідної колекції є потік натуральних чисел `Stream.from(0)`. Метод `hasDefiniteSize` вказує, що колекція, можливо, нескінчена. Якщо він повертає `false`, колекція може бути нескінченою, і в цьому випадку `size` буде видавати помилку або не повернеться.

* *Операції отримання елемента* `head`, `last`, `headOption`, `lastOption`, та `find`. Вони обирають перший або останній елемент колекції, або інакше перший елемент, що задовільняє умові. Однак зазначте, що не всі колекції мають гарно визначення значення того, що значить "перший" та "останній". Наприклад, хеш множина може зберігати елементи відповідно до їх хеш ключів, що можуть змінюватись від запуску до запуску. В цьому випадку "перший" елемент хеш набору також може бути різним для разних запусків програм. Колекція є впорядкована, якщо вона завжди видає свої елементи в тому самому порядку. Більшість колекцій впорядковані, але деякі (такі як хеш множини) ні — відкидання впорядкованості дає трохи додаткової ефективності. Порядок часто є основою для отримання повторюваних тестів, та допомагає в зневадженні. Ось чому колекції Scala провадять впорядковані альтернативи для всіх типів колекцій. Наприклад, впорядкована альтернатива для `HashSet` є `LinkedHashSet`.

* *Операції отримання субколекцій* `takeWhile`, `tail`, `init`, `slice`, `take`, `drop`, `filter`, `dropWhile`, `filterNot`, `withFilter`. Всі вони повертають деяку субколекцію, що ідентифікується диапазоном індексів або предикатом.

* *Операції підрозділу* `splitAt`, `span`, `partition`, та `groupBy` підрозділяють елементи колекції на декілька субколекцій.

* *Перевірка елементів* `exists`, `forall`, та `count` перевіряють елементи колекції за допомогою наданого предикату.

* *Згортки* `foldLeft`, `foldRight`, `/:`, `:\`, `reduceLeft`, `reduceRight` застосовують двомісні операції до послідовних елементів.

* *Особливі згортки* `sum`, `product`, `min`, `max` роблять з колекціями специфічних типів (числові або порівнювані).

* *Рядкові операції* `mkString`, `addString`, `stringPrefix` провадять альтернативні шляхи перетворення колекції на рядок.

* *Операції переглядів* складаються з двох перевантажених варіантів метода `view`. Перегляд є колекція, що обчислюється ліниво. Ви пізнаєте більше про перегляди в Розділі 24.14.

[caption="Операції трейта Traversable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|*Абстрактний метод:*
|xs foreach f|Виконує функцію `f` для кожного елементу `xs`.
2+|*Додавання:*
|xs ++ ys|Колекція, що складається з елементів обох, `xs` та `ys`.  `ys` є колекцією `TraversableOnce`, тобто або `Traversable`, або `Iterator`.
2+|*Мапи:*
|xs map f|Колекція, отримана від застосування функції `f` до кожного елемента в `xs`.
|xs flatMap f|Колекція, отримана від застосування функції `f` від значень-колекції до кожного елементу в `xs`, та конкатенації результатів.
|xs collect f|Колекція, отримана від застосування часткової функції `f` до кожного елементу в `xs`, для яких вона визначена, та накопичення результатів.
2+|*Перетворення:*
|xs.toArray|Конвертує колекцію в масив.
|xs.toList|Конвертує колекцію в список.
|xs.toIterable|Конвертує колекцію в Iterable.
|xs.toSeq|Конвертує колекцію в послідовність.
|xs.toIndexedSeq|Конвертує колекцію в індексовану послідовність.
|xs.toStream|Конвертує колекцію в потік (ліниво обчислювана послідовність).
|xs.toSet|Конвертує колекцію в множину.
|xs.toMap|Конвертує колекцію пар ключ/значення в мапу.
2+|*Копіювання:*
|xs copyToBuffer buf|Копіює всі елементи колекції в буфер `buf`.
|xs copyToArray(arr, s, len)|Копіює щонайбільше `len` елементів `arr`, починаючи з індексу `s`. Два останні аргументи опціональні. 
2+|*Інформація про розмір:*
|xs.isEmpty|Перевіряє, чи колекція порожня.
|xs.nonEmpty|Перевіряє, чи колекція містить елементи.
|xs.size|Число елементів в колекції.
|xs.hasDefiniteSize|True, якщо відомо, що xs має фіксований розмір.
2+|*Отримання елементів:*
|xs.head|Перший елемент колекції (або деякий елемент, якщо порядок не визначений).
|xs.headOption|Перший елемент `xs` в опціональному значенні, або `None`, якщо `xs` порожнє.
|xs.last|Останній елемент колекції (або деякий елемент, якщо порядок не визначений).
|xs.lastOption|Останній елемент `xs` в опціональному значенні, або `None`, якщо `xs` порожнє.
|xs find p|Опція, яка містить перший елемент в `xs`, що задовільняє `p`, або `None`, якщо жодний елемент не підійде.
2+|*Субколекції:*
|xs.tail|Залишок колекції, за винятком `xs.head`.
|xs.init|Залишок колекції, за винятком `xs.last`.
|xs slice (from, to)|Колекція, що складається з елементів `xs` в деякому диапазоні індексів (від `from` до `to`, виключно).
|xs take n|Колекція, що складається з перших `n` елементів `xs` (або деякі довільні `n` елементів, якщо порядок не визначений).
|xs drop n|Залишок колекції, за винятком `xs take n`.
|xs takeWhile p|Найдовший префікс елементів в колекції, що задовільняють `p`.
|xs dropWhile p|Колекція без найдовшого префіксу елементів, всі з яких задовільняють `p`.
|xs filter p|Колекція, що складається з тих елементів `xs`, що задовільняють предикату `p`.
|xs withFilter p|Не-строгий фільтр для цієї колекції. Всі операції на отриманому фільтрі будуть застосовані тільки для тих елементів `xs`, для яких мова `p` є `true`.
|xs filterNot p|Колекція, що складається з тих елементів `xs`, що не задовільняють предикатові `p`.
2+|*Суброзподіл:*
|xs splitAt n|Розділяє `xs` в позициї `n`, даючи пару колекцій (`xs take n`, `xs drop n`).
|xs span p|Розділяє `xs` відповідно до предикату, даючи пару колекцій (`xs takeWhile p`, `xs.dropWhile p`).
|xs partition p|Розділяє `xs` на пару колекцій; одна з елементами, що задовільняють предикату `p`, інша з елементами, що ні, даючи пару колекцій(`xs filter p`, `xs.filterNot p`).
|xs groupBy f|Розділяє `xs` на мапу колекцій, відповідно до функції дескреминатору `f`.
2+|*Умови до елементів:*
|xs forall p|Логічне, що визначає, чи предикат `p` дотримується до всіх елементів `xs`.
|xs exists p|Логічне, що вказує, чи предикат `p` дотримується до деякого елемента в `xs`.
|xs count p|Число елементів в `xs`, що задовільняють предикату `p`.
2+|*Згортки:*
|(z /: xs)(op)|Застосовує двомісну операцію `op` між послідовними елементами `xs`, ідучи зліва направо, починаючи з `z`.
|(xs :\ z)(op)|Застосовує двомісну операцію `op` між послідовними елементами `xs`, ідучи зправа наліво, починаючи з `z`.
|xs.foldLeft(z)(op)|Те саме, що і `(z /: xs)(op)`.
|xs.foldRight(z)(op)|Те саме, що і `(xs :\ z)(op)`.
|xs reduceLeft op|Застосовує двомісну операцію `op` між послідовними елементами непорожньої колекції `xs`, ідучи зліва направо.
|xs reduceRight op|Застосовує двомісну операцію `op` між послідовними елементами непорожньої колекції `xs`, ідучи зправа наліво.
2+|*Особливі згортки:*
|xs.sum|Сума числових значень елементів колекції `xs`.
|xs.product|Добуток числових значень елементів колекції `xs`.
|xs.min|Мінімум впорядкованих значень елементів колекції `xs`.
|xs.max|Максімум впорядкованих значень елементів колекції `xs`.
2+|*Рядки:*
|xs addString (b, start, sep, end)|Додає рядок до `StringBuilder` `b`, що показує всі елементи `xs`, розділені роздільниками `sep` та оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональні.
|xs mkString (start, sep, end)|Конвертує колекцію на рядок, що показує всі елементи `xs` між роздільниками `sep` та оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональні.
|xs.stringPrefix|The collection name at the beginning of the string returned from xs.toString.
2+|*Перегляди:*
|xs.view|Продукує перегляд xs.
|xs view (from, to)|Продукує перегляд, що представляє елементи в деякому диапазоні індексів `xs`. 
|===

24.4 Трейт Iterable
===================
Наступний трейт зверху на Малюнку 24.1 є `Iterable`. Всі методи в цьому трейті визначені в термінах абстрактного метода `iterator`, що видає елементи колекції один за одним. Абстрактний метод `foreach`, наслідуваний від трейту `Traversable`, реалізований в `Iterable` в термінах `iterator`. Ось справжня реалізація:
[source,scala]
----
def foreach[U](f: Elem => U): Unit = {
  val it = iterator
  while (it.hasNext) f(it.next())
}
----
Лише кілька субкласів `Iterable` перекривають цю стандартну реалізацію `foreach` в `Iterable`, оскільки вони можуть провадити більш ефективну реалізацію. Пам'ятайте, що `foreach` є основою для реалізації всіх операцій в `Traversable`, так що продуктивність важлива.

Ще два метода існують в `Iterable`, що повертають ітератори: `grouped` та `sliding`. Однак ці ітератори не повертають поодинокі елементи, але цілі субпослідовності елементів оригінальної колекції. Максимальний розмір ціх послідовностей надається як аргумент до ціх методів. Метод `grouped` розбиває свої елементи на інкрементальні пакунки, тоді як `sliding` дає ковзаюче вікно по елементах. Різниця між двома стане яснішою при погляді на наступні взаємодії в інтерпретаторі:
[source,scala]
----
scala> val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala> val git = xs grouped 3
git: Iterator[List[Int]] = non-empty iterator

scala> git.next()
res2: List[Int] = List(1, 2, 3)

scala> git.next()
res3: List[Int] = List(4, 5)

scala> val sit = xs sliding 3
sit: Iterator[List[Int]] = non-empty iterator

scala> sit.next()
res4: List[Int] = List(1, 2, 3)

scala> sit.next()
res5: List[Int] = List(2, 3, 4)

scala> sit.next()
res6: List[Int] = List(3, 4, 5)
----
Трейт `Iterable` також додає деякі інші методи до `Traversable`, що можуть бути ефективно реалізовані тільки за наявності ітератора. Вони підсумовані в Таблиці 24.2:

[caption="Операції трейта Iterable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|*Абстрактний метод:*
|iterator|Ітератор, що видає кожний елемент в `xs`, в тому самому порядку, як `foreach` проходить по елементах
2+|*Інші ітератори:* 
|xs grouped size|Ітератор, що видає "частки" колекції фіксованого розміру
|xs sliding size|Ітератор, що видає ковзне вікно фіксованого розміру з елементів колекції
2+|*Субколекції:* 
|xs takeRight n|Колекція, що складається з останніх `n` елементів `xs` (або довільні `n` елементів, якщо порядок не визначений)
|xs dropRight n|Залишок колекції, за винятком `xs takeRight n`
2+|*Поєднувачі:*
|xs zip ys|Ітерабельне з пар відповідних елементів з `xs` та `ys`
|xs zipAll (ys, x, y)|Ітерабельне з пар відповідних елементів з `xs` та `ys`, де коротша послідовність розширюється, щоб співпадати до довшої, через додавання елементів `x` або `y`
|xs.zipWithIndex|Ітерабельне з пар елементів `xs` разом з їх індексами
2+|*Порівняння:*
|xs sameElements ys|Перевіряє, чи `xs` та `ys` містять ті самі елементи в тому ж порядку
|===

Чому мати обоє, `Traversable` та `Iterable`?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ви можете здивуватись, для чого додатковий трейт `Traversable` над `Iterable`. Чи не могли б зробити все з ітератором? То яка ідея мати більш абстрактний трейт, що визначає свої методи в термінах `foreach` замість `iterator`? Одна причина мати `Traversable` в тому, що іноді простіше або більш ефективно провадити реалізацію для `foreach`, ніж провадити реалізацію ітератора. Ось простий приклад. Скажімо, ви бажаєте ієрархію класів для бінарних дерев, що мають цілі елементи на листках. Ви можете розробиби цю ієрархію таким чином:
[source,scala]
----
sealed abstract class Tree
case class Branch(left: Tree, right: Tree) extends Tree
case class Node(elem: Int) extends Tree
----
Тепер вважатимемо, ви бажаєте зробити дерева перехідними. Щоб зробити це, треба щоб `Tree` наслідував від `Traversable[Int]`, та визначав метод `foreach`, ось так:
[source,scala]
----
sealed abstract class Tree extends Traversable[Int] {
  def foreach[U](f: Int => U) = this match {
    case Node(elem) => f(elem)
    case Branch(l, r) => l foreach f; r foreach f
  }
}
----
Це не дуже складно, і це також дуже ефективно — перехід по збалансованому дереву пропорційно до числа елементів в дереві. Щоб побачити це, уявімо, що збалансоване дерево з `N` листками буде мати `N - 1` внутрішніх листків класу `Branch`. Так що загальна кількість кроків для обходу дерева є `N + N - 1`.

Тепер порівняйте це з робленням дерев ітерабельними. Щоб зробити це, робимо `Tree` походячим від `Iterable[Int]`, та визначаємо метод `iterator` ось так:
[source,scala]
----
sealed abstract class Tree extends Iterable[Int] {
  def iterator: Iterator[Int] = this match {
    case Node(elem) => Iterator.single(elem)
    case Branch(l, r) => l.iterator ++ r.iterator
  }
}
----
На перший погляд це виглядає не складніше, ніж рішення `foreach`. Однак є проблема ефективності, що стосується реалізації метода конкатенації ітератора, `++`. Кожного разу,коли продукується елемент конкатенованим ітератором, як в `l.iterator ++ r.iterator`, обчислення потребує слідувати одному непрямому переходу, щоб отримати вірний ітератор (`l.iterator` або `r.iterator`). Загалом це робить `log(N)` перенаправлень, щоб отримати листок збалансованого дерева з `N` leaves. Так що ціна відвідування всіх елементів дерева становить від близько `2N` для метода обходу `foreach`, до `Nlog(N)` для проходу за допомогою ітератору. Якщо дерево має мільйон елементів, це означає близько двох мільйонів кроків для `foreach`, і біля двадцяти (?) мільйонів кроків для `iterator`. Так що рішення `foreach` має явну перевагу.

Субкатегорії Iterable
~~~~~~~~~~~~~~~~~~~~~
В ієрархії наслідування нижче `Iterable` ви знайдете три трейти: `Seq`, `Set`, та `Map`. Загальний аспект ціх трьох трейтів в тому, що всі вони реалізують трейт `PartialFunction`,footnote:[Часткові функції були описані в Розділі 15.7.] з його методами `apply` та `isDefinedAt`. Однак спосіб, в який кожний трейт реалізує `PartialFunction`, відрізняється.

Для послідовностей `apply` є позиційне індексування, де елементи завжди пронумеровані від `0`. Тобто, `Seq(1, 2, 3)(1) == 2`. Для множин `apply` є перевіркою належності. Наприклад, `Set('a', 'b', 'c') ('b') == true`, тоді як `Set()('a') == false`. Нарешті, для мап `apply` є вибір. Наприклад, `Map('a' - > 1, 'b' -> 10, 'c' -> 100)('b') == 10`.

В наступних трьох розділах ми пояснимо кожний з трьох типів колекцій більш детально.

24.5 Трейти послідовностей `Seq`, `IndexedSeq`, `LinearSeq`
-----------------------------------------------------------
Трейт `Seq` представляє послідовності. Послідовність різновид ітерабельного, що має довжину, та чиї елементи мають фіксовані індексовані позиції, починаючи від 0. Операції над послідовностями, підсумовані на Малюнку 24.3, підпадають в наступні категорії:

* *Операції індексування та довжини* `apply`, `isDefinedAt`, `length`, `indices`, та `lengthCompare`. Для `Seq` операція `apply` означає індексування; таким чином послідовність типу `Seq[T]` є частковою функцією, що приймає аргумент `Int` (індекс), та видає елемент послідовності типу `T`. Іншими словами, `Seq[T]` розширює `PartialFunction[Int, T]`. Елементи послідовності індексовані від нуля до довжини послідовності мінус один. Метод `length` на послідовностях є псевдонимом метода `size` на загальних колекціях. Метод `lengthCompare` дозволяє вам порівнювати довжину двох послідовностей, навіть якщо одна з послідовностей має безкінечну довжину.

* *Операції пошуку індексу* `indexOf`, `lastIndexOf`, `indexOfSlice`, `lastIndexOfSlice`,`indexWhere`, `lastIndexWhere`, `segmentLength`, та `prefixLength` повертають індекс елементу, рівному до заданого значення або співпадаючий з деяким предикатом.

* *Операції додавання* `+:`, `:+`, та `padTo`, повертають нову послідовність, отриману від додавання елементів зпереду або з кінця послідовності.

* *Операції оновлення* `updated` та `patch`, що повертають нову послідовність, отриману від заміни деяких елементів оригінальної послідовності.

* *Операції сортування* `sorted`, `sortWith`, та `sortBy` сортують елементи послідовності відповідно до різних критеріїв.

* *Операції обертання* `reverse`, `reverseIterator`, та `reverseMap` видають або обробляють елементи послідовності в зворотньому порядку, від останнього до першого.

* *Операції порівняння* `startsWith`, `endsWith`, `contains`, `corresponds`, та `containsSlice` співвідносить дві послідовності або шукає елемент в послідовності.

* *Множинні операції* `intersect`, `diff`, `union`, та `distinct` виконують множино-подібні операції на елементах двох послідовностей, або видаляють дублікати.

Якщо послідовність змінна, вона пропонує додатковий метод з побічним ефектом `update`, що дозволяє оновлювати елементи. Згадайте з Глави 3, що синтаксис як `seq(idx) = elem` є просто скороченням для `seq.update(idx, elem)`. Зауважте різницю між `update` та `updated`. Метод `update` змінює елемент послідовності на місці, та доступний тільки для змінних послідовностей. Метод `updated` доступний для всіх послідовностей, та завжди повертає нову послідовність, замість модифікації оригіналу.

[caption="Операції трейта Seq"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Індексування та довжина:
|xs(i)|(або, розписано,`xs apply i`) Елемент `xs` за індексом `i`.
|xs isDefinedAt i|Перевіряє, чи `i` міститься в `xs.indices`.
|xs.length|Довжина послідовності (те саме, що і `size`).
|xs.lengthCompare ys|Повертає `-1`, якщо `xs` коротше за `ys`, `+1` якщо довше, та `0` якщо вони мають рівну довжину. Робить, навіть якщо послідовності безкінечні.
|xs.indices|Диапазон індексів `xs`, що простягається від `0` до `xs.length - 1`. 
2+|Індексний пошук:
|xs indexOf x|Індекс першого елементу в `xs` рівному `x` (існують декілька варіантів).
|xs lastIndexOf x|Індекс останнього елементу в `xs` рівному `x` (існують декілька варіантів).
|xs indexOfSlice ys|Перший індекс `xs`, такий, що наступні елементи починаючи з цього індексу формують послідовність `ys`.
|xs lastIndexOfSlice ys|Останній індекс `xs`, такий, що наступні елементи починаючи з цього індексу формують послідовність `ys`.
|xs indexWhere p|Індекс першого елементу `xs`, задовільняє `p` (існують декілька варіантів).
|xs segmentLength (p, i)| Довжина найдовшого неперериваного сегменту елементів `xs`, починаючи з `xs(i)`, всі з яких задовільняють предикату `p`.
|xs prefixLength p|Довжина найдовшого префіксу з елементів `xs`, всі з яких задовільняють предикату `p`.
2+|Додавання:
|x +: xs|Нова послідовність, що складається з `x` перед `xs`.
|xs :+ x|Нова послідовність, що складається з `x` після `xs`.
|xs padTo (len, x)|Послідовність, що утворюється як результат від додавання значення `x` до `xs`, доки не буде досяжена довжина `len`.
2+|Оновлення:
|xs patch (i, ys, r)|Послідовність як результат від заміни `r` елементів `xs`, починаючи з `i` на латку `ys`.
|xs updated (i, x)|Копія `xs`, з елементом з індексом `i`, заміненим на `x`.
|xs(i) = x|(або, розписане, `xs.update(i, x)`, доступне тільки для` mutable.Seq`). Зміна елементу `xs` по індексу `i` на `y`.
2+|Сортування:
|xs.sorted|Нова послідовність, отримана від сортування елементів  `xs` з використанням стандартного впорядкування типу елементів `xs`.
|xs sortWith lessThan|Нова послідовність, отримана від сортування елементів `xs`, використовуючи `lessThan` як операції порівняння.
|xs sortBy f|Нова послідовність, отримана від сортування елементів `xs`. Порівняння між двома елементами обробляється через відображення двох елементів функцією `f` над обома, та порівняння результатів.
2+|Обернення:
|xs.reverse|Послідовність з елементами `xs` в зворотньому порядку.
|xs.reverseIterator|Ітератор, що видає всі елементи `xs` в зворотньому порядку.
|xs reverseMap f|Послідовність, отримана від відображення `f` над елементами `xs` в зворотньому порядку.
2+|Порівняння:
|xs startsWith ys|Перевіряє, чи `xs` починається з послідовності `ys` (існують декілька варіантів).
|xs endsWith ys|Перевіряє, чи `xs` закінчується на `ys` (існують декілька варіантів).
|xs contains x|Перевіряє, чи `xs` має елемент, що дорівнює `x`.
|xs containsSlice ys|Перевіряє, чи `xs` має послідовність, що дорівнює `ys`.
|(xs corresponds ys)(p)|Перевіряє, чи відповідні елементи `xs` та `ys` задовільняють двомісному предикату `p`.
2+|Множинні операції:
|xs intersect ys|Множинний перетин послідовностей `xs` та `ys`, що зберігає порядок елементів в `xs`.
|xs diff ys|Множинна різниця послідовностей `xs` та `ys`, що зберігає порядок елементів в `xs`.
|xs union ys|Множинне об'єднання; те саме, що `xs ++ ys`.
|xs.distinct|Субпослідовність `xs`, що не містить дублікатів.
|===

Кожний трейт `Seq` має два субтрейти, `LinearSeq` та `IndexedSeq`. Вони не додають жодних нових операцій, але кожний пропонує різні характеристики продуктивності. Лінійна послідовність має ефективні операції `head` та `tail`, тоді як індексована послідовність має ефективні операції `apply`, `length`, та (якщо `mutable`) `update`. `List` є часто використовувана лінійна послідовність, як і `Stream`. Дві часто використовувані індексовані послідовності є `Array` та `ArrayBuffer`. Клас `Vector` провадить цікавий компроміс між індексованим та лінійним доступом. Він має однаково ефективний сталий час індексного навантаження, та сталий час лінійного доступу. Завдяки цьому вектори є гарною основою для шаблонів змішаного доступу, коли одночасно використовується індексний та лінійний доступи. Більше про вектори в Розділі 24.8.

Буфери
~~~~~~
Важлива суб-категорія змінних послідовностей є буфери. Буфери дозволяють не тільки оновлення існуючих елементів, але також вставки елементів, видалення елементів, та ефективне додавання нових елементів в кінець буфера. Принципово нові методи, що підтримуються буферами, є `+=` та `++=` для додавання елементів в кінець, та `+=:` і `++=:` для додавання зпереду, `insert` та `insertAll` для вставок елементів, так само як `remove` та `-=` для видалення елементів. Ці These operations are summarized in Table 24.4.

Дві реалізації `Buffer` в загальному ужитку є `ListBuffer` та `ArrayBuffer`. Як підказує ім'я, `ListBuffer` підтримується `List`, та підтримує ефективне перетворення його елементів `List`, тоді як  `ArrayBuffer` покладається на масив, та може бути швидко перетворений на такий. Ви бачили проблиск реалізації `ListBuffer` в Розділі 22.2.

[caption="Операції трейта Buffer"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Додавання:
|buf += x|Додає елемент `x` до буфера `buf`, та повертає самий `buf` як результат
|buf += (x, y, z)|Додає надані елементи до буфера
|buf ++= xs|Додає всі елементи в `xs` до буфера
|x +=: buf|Ставить елемент `x` в початок буфера
|xs ++=: buf|Ставить всі елементи `xs` в початок буфера
|buf insert (i, x)|Вставляє елемент `x` по індексу `i` в буфер
|buf insertAll (i, xs)|Вставляє всі елементи в `xs` по індексу `i` в буфер
2+|Видалення:
|buf -= x|Видаляє елемент `x` з буфера
|buf remove i|Видаляє елементпо індексу `i` з буфера
|buf remove (i, n)|Видаляє `n` елементів, починаючи з індексу `i`, з буфера
|buf trimStart n|Видаляє перші `n` елементів з буфера
|buf trimEnd n|Видаляє останні `n` елементів з буфера
|buf.clear()|Видаляє всі елементи з буфера
2+|Клонування:
|buf.clone|Новий буфер з тими самим елементами, що і `buf`
|===

24.6 Множини
------------
`Set` є `Iterable`, що не містить дублікатів елементів. Операції з множинами підсумовані в Таблиці 24.5 для `general` множин, і Таблиці 24.6 `mutable` множин. Вони підпадають під наступні категорії:

* *Перевірки* `contains`, `apply`, та `subsetOf`. Метод `contains` вказує, чи множина містить наданий елемент. Метод `apply` для множини те саме, що і `contains`, так що `set(elem)` відповідає до  `set contains elem`. Це означає, що множини можуть також використовуватись як функції перевірки, що повертають `true` для елементів, які вони містять. Наприклад:
[source,scala]
----
scala> val fruit = Set("apple", "orange", "peach", "banana")
fruit: scala.collection.immutable.Set[String] =
  Set(apple, orange, peach, banana)

scala> fruit("peach")
res7: Boolean = true

scala> fruit("potato")
res8: Boolean = false
----
* *Додавання* `+` and `++` додають до множини один або більше елементів, даючи нову множини в якості результату.

* *Видалення* `-` та `--` видаляють один або більше з множини, даючи нову множину.

* *Операції множин* для об'єднання, перетину та різниці. Ці операції існують в двох фломах: алгебраїчній та символічній. Алгебраїчні версії є `intersect`, `union`, та `diff`, тоді як символічні версії `&`, `|`, та `&~`. Метод `++`, який `Set` наслідує від `Traversable`, може розглядатись як ще один псевдоним для `union` або `|`, за винятком того, що `++` приймає аргумент `Traversable`, коли `union` та `|` приймають множини.

[caption="Операції трейта Set"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Перевірки:
|xs contains x|Перевіряє, чи `x` є елементом `xs`
|xs(x)|Те саме, що `xs contains x`
|xs subsetOf ys|Перевіряє, чи `xs` є підмножиною `ys`
2+|Додавання:
|xs + x|Множина, що містить всі елементи `xs`, так само як `x`
|xs + (x, y, z)|Множина, що містить всі елементи `xs`, так само як надані додаткові елементи
|xs ++ ys|Множина, що містить всі елементи `xs`, так само, як всі елементи `ys`
2+|Видалення:
|xs - x|Множина, що містить всі елементи `xs`, за винятком `x`
|xs - (x, y, z)|Множина, що містить всі елементи `xs`, за винятком наданих елементів
|xs -- ys|Множина, що містить всі елементи `xs`, крім елементів в `ys`
|xs.empty|Порожня множина такого ж класу, що і `xs`
2+|Бінарні операції:
|xs & ys|Перетин множин `xs` та `ys`
|xs intersect ys|Те саме, що і `xs & ys`
|xs \| ys|Поєднання множин `xs` та `ys`
|xs union ys|Те саме, що і `xs | ys`
|xs &~ ys|Різниця множин `xs and ys`
|xs diff ys|Те саме, що і `xs &~ ys`
|===

Змінні множини мають методи, що додають, видаляють або оновлюють елементи, що підсумовані в Таблиці 24.6:

[caption="Операції трейта mutable.Set"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+"Додавання:
|xs += x|Додає елемент `x` до множини `xs` як побічний ефект, та повератє сам `xs`
|xs += (x, y, z)|Додає надані елементи до множини як побічний ефект, та повертає сам `xs`
|xs ++= ys|Додає всі елементи з `ys` до множини `xs` як побічний ефект, та повертає сам `xs`
|xs add x|Додає елемент `x` до `xs` та повертає `true`, якщо `x` досі не був членом множини, `false` якщо він був там
2+|Видалення:
|xs -= x|Видаляє елемент `x` з множини `xs` як побічний ефект, та повертає сам `xs`
|xs -= (x, y, z)|Видаляє надані елементи з множини `xs` як побічний ефект, та повертає сам `xs`
|xs --= ys|Видаляє всі елементи в `ys` з множини `xs` як побічний ефект, та повертає сам `xs`
|xs remove x|Видаляє `x` з `xs`, та повертає `true`, якщо `x` до цього містився в множині, `false` якщо ні
|xs retain p|Залишає лише ті елементи в `xs`, що задовільняють предикату `p`
|xs.clear()|Видаляє всі елементи з `xs`
2+|Оновлення:
|xs(x) = b|(або, розписано, `xs.update(x, b)`) Якщо логічний аргумент `b` є `true`, додає `x` до `xs`, інакше видаляє `x` з `xs`
2+|Клонування:
|xs.clone|Нова змінна множина з тими ж елементами, що і `xs`
|===

Так само, як незмінні множини, змінні множини пропонують операції  `+` та `++` для додавання елементів, та `-` та `--` для видалення елементів. Але вони рідше використовуються для змінних множин, оскікльки це включає копіювання множини. Ак більш ефективна альтернатива, змінні множини пропонують методи оновлення `+=` та `- =`. Операція `s += elem` додає `elem` до множини `s` в якості побічного ефекту, та повертає змінену множину як результат. Подібно до цього, `s -= elem` видаляє `elem` з множини, та повертає змінену множину як результат. Окрім `+=` та `-=` також існують масові операції `++=` та `--=`, що додають або видаляють всі елементи перехідного або ітератора.

Вибір імен методів, `+=` та `-=` означає, що дуже подібний код буде робити однаково, зі змінними та незмінними множинами. Зпочатку розглянемо наступний диалог в інтерпретаторі, що використовує незмінну множину `s`:
[source,scala]
----
scala> var s = Set(1, 2, 3)
s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)

scala> s += 4; s -= 2

scala> s
res10: scala.collection.immutable.Set[Int] = Set(1, 3, 4)
----
В цьому прикладі ми використали `+=` та `-=` на `var` типу `immutable.Set`. Як було пояснено на Кроці 10 в Главі 3, а твердження як `s += 4` є скороченням для `s = s + 4`. Так що це викликає метод додавання `+` на множині `s`, та потім присвоює результат назад до змінної `s`. Розглянемо тепер аналогічну взаємодію зі змінним набором:
[source,scala]
----
scala> val s = collection.mutable.Set(1, 2, 3)
s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)

scala> s += 4
res11: s.type = Set(1, 2, 3, 4)

scala> s -= 2
res12: s.type = Set(1, 3, 4)
----
The end effect is very similar to the previous interaction; we start with a Set(1, 2, 3) and end up with a Set(1, 3, 4). However, even though the statements look the same as before, they do something different. The s += 4 statement now invokes the += method on the mutable set values, changing the set in place. Likewise, the s -= 2 statement now invokes the -= method on the same set.

Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.

Mutable sets also provide add and remove as variants of += and -=. The difference is that add andremove return a boolean result indicating whether the operation had an effect on the set.

The current default implementation of a mutable set uses a hash table to store the set's elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as hash tries.footnote:[Hash tries are described in Section 24.8.]

A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.

24.7 Мапи
---------
Maps are Iterables of pairs of keys and values (also named mappings or associations). As explained in Section 21.4, Scala's Predef class offers an implicit conversion that lets you writekey -> value as an alternate syntax for the pair (key, value). Therefore, Map("x" -> 24, "y" -> 25, "z" -> 26) means exactly the same as Map(("x", 24), ("y", 25), ("z", 26)), but reads better.

The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets. Mutable maps additionally support the operations shown in Table 24.8. Map operations fall into the following categories:

* *Lookups* apply, get, getOrElse, contains, and isDefinedAt. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is: 
[source,scala]
----
def get(key): Option[Value]
----
The operation "m get key" tests whether the map contains an association for the given key. If so, it returns the associated value in a Some. If no key is defined in the map, get returns None. Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option. If the key is not defined in the map, an exception is raised.

* Additions and updates +, ++, and updated, which let you add new bindings to a map or change existing bindings.

* Removals - and --, which remove bindings from a map.

* Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map's keys and values separately in various forms.

* Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.

[caption="Операції трейта Map"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Пошук:
|ms get k|Значення, асоційоване з ключем `k` в мапі `ms`, як опція, або `None`, якщо не знайдене
|ms(k)|(або, розписане, `ms apply k`) Значення, асоційоване з ключем `k` в мапі `ms`, або закидає виключення, якщо не знайдене
|ms getOrElse (k, d)|Значення, асоційоване з ключем `k` в мапі `ms`,або значення по замовчанню `d`, якщо не знайдене
|ms contains k|Перевіряє, чи `ms` містить відображення для ключа `k`
|ms isDefinedAt k|Те саме, що і `contains`
2+|Додавання та оновлення:
|ms + (k -> v)|Мапа, що містить всі відображення `ms`, так само, як і `gk -> v` ключа `k` на значення `v`
|ms + (k -> v, l -> w)|Мапа, що містить всі відображення `ms`, разом з наданими парами ключ/значення
|ms ++ kvs|Мапа, що містить всі відображення `ms`, так само, як і пари ключ/значення з `kvs`
|ms updated (k, v)|Таке саме, що і `ms + (k -> v)`
2+|Видалення:
|ms - k|Мапа, що містить всі відображення з `ms`, за винятком любих відображень для ключа `k`
|ms - (k, l, m)|Мапа, що містить всі відображення `ms`, за винятком всіх відображень з наданими ключамі
|ms -- ks|Мапа, що містить всі відображення з `ms`, за винятком любих відображень з ключами в `ks`
2+|Субколекції:
|ms.keys|Ітерабельне, що містить любий ключ в `ms`
|ms.keySet|Множина, що містить кожний ключ в `ms`
|ms.keysIterator|Ітератор, що видає кожний ключ в `ms`
|ms.values|Ітерабельне, що містить кожне значення, асоційоване з ключем в `ms`
|ms.valuesIterator|Ітератор, що видає кожне значення, асоційоване з ключем в `ms`
2+|Перетворення:
|ms filterKeys p|Перегляд мапи, що містить тільки ті відображення, в яких ключ відповідає предикату `p`
|ms mapValues f|Перегляд мапи, отриманий від застосування функції `f` до кожного значення, асоційованого з ключем в `ms`
|===

[caption="Операції трейта mutable.Map"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Додавання та оновлення:
|ms(k) = v|(або, розписано, `ms.update(k, v)`) Додає відображення ключа `k` на значення `v` до мапи `ms` як побічний ефект, переписуючи любі попередні відображення `k`
|ms += (k -> v)|Додає відображення ключа `k` на значення `v` до мапи `ms` як побічний ефект, та повертає сам `ms`
|ms += (k -> v, l -> w)|Додає надані відображення до `ms` як побічний ефект, та повертає сам `ms`
|ms ++= kvs|Додає всі відображення в `kvs` до `ms` як побічний ефект, та повертає сам `ms`
|ms put (k, v)|Додає відображення ключа `k` на значення `v` до `ms`, та повертає любе значення, асоційоване до цього з `k`, як опцію
|ms getOrElseUpdate (k, d)|Якщо ключ `k` визначений в мапі `ms`, повертає його асоційоване значення. Інакше оновлює `ms` відображенням `k -> d` та повертає `d`
2+|Видалення:
|ms -= k|Видаляє відображення ключа `k` з `ms` як побічний ефект, та повертає сам `ms`
|ms -= (k, l, m)|Видаляє відображення наданних ключів з `ms` як побічний ефект, та повертає сам `ms`
|ms --= ks|Видаляє всі ключі в `ks` з `ms` як побічний ефект, та повертає сам `ms`
|ms remove k|Видаляє любі відображення ключа `k` з `ms`, та повертає любе значення, до цього асоційоване з `k`, як опцію
|ms retain p|Зберігає тільки ті відображення в `ms`, ключ яких задовільняє предикату `p`.
|ms.clear()|Видаляє всі відображення з `ms`
2+|Перетворення та клонування:
|ms transform f|Перетворює всі асоційовані значення в мапі `ms` функцією `f`
|ms.clone|Повертає нову змінну мапу з тими самими відображеннями, що і `ms`
|===

The addition and removal operations for maps mirror those for sets. As for sets, mutable maps also support the non-destructive addition operations +, -, and updated, but they are used less frequently because they involve a copying of the mutable map. Instead, a mutable map mis usually updated "in place," using the two variants m(key) = value or m += (key -> value). There is also the variant m put (key, value), which returns an Option value that contains the value previously associated with key, or None if the key did not exist in the map before.

The getOrElseUpdate is useful for accessing maps that act as caches. Say you have an expensive computation triggered by invoking a function f:
[source,scala]
----
scala> def f(x: String) = {
println("taking my time."); Thread.sleep(100)
x.reverse }f: (x: String)String
----
Assume further that f has no side-effects, so invoking it again with the same argument will always yield the same result. In that case you could save time by storing previously computed bindings of argument and results of f in a map, and only computing the result of f if a result of an argument was not found there. You could say the map is a cache for the computations of the function f.
[source,scala]
----
scala> val cache = collection.mutable.Map[String, String]()
cache: scala.collection.mutable.Map[String,String] = Map()
----
You can now create a more efficient caching version of the f function:
[source,scala]
----
scala> def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))
cachedF: (s: String)String

scala> cachedF("abc")
taking my time.
res16: String = cba

scala> cachedF("abc")
res17: String = cba
----
Note that the second argument to getOrElseUpdate is "by-name," so the computation of f("abc")above is only performed if getOrElseUpdate requires the value of its second argument, which is precisely if its first argument is not found in the cache map. You could also have implementedcachedF directly, using just basic map operations, but it would have have taken more code to do so:
[source,scala]
----
def cachedF(arg: String) = cache get arg match {
  case Some(result) => result
  case None =>
    val result = f(arg)
    cache(arg) = result
    result
}
----
24.8 Суцільні класи незмінних колекцій
--------------------------------------
Scala provides many concrete immutable collection classes for you to choose from. They differ in the traits they implement (maps, sets, sequences), whether they can be infinite, and the speed of various operations. We'll start by reviewing the most common immutable collection types.

Списки
~~~~~~
Lists are finite immutable sequences. They provide constant-time access to their first element as well as the rest of the list, and they have a constant-time cons operation for adding a new element to the front of the list. Many other operations take linear time. See Chapters 16 and 22 for extensive discussions about lists.

Потоки
~~~~~~
A stream is like a list except that its elements are computed lazily. Because of this, a stream can be infinitely long. Only those elements requested will be computed. Otherwise, streams have the same performance characteristics as lists.

Whereas lists are constructed with the :: operator, streams are constructed with the similar-looking #::. Here is a simple example of a stream containing the integers 1, 2, and 3:
[source,scala]
----
scala> val str = 1 #:: 2 #:: 3 #:: Stream.empty
str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
----
The head of this stream is 1, and the tail of it has 2 and 3. The tail is not printed here, though, because it hasn't been computed yet! Streams are required to compute lazily, and the toStringmethod of a stream is careful not to force any extra evaluation.

Below is a more complex example. It computes a stream that contains a Fibonacci sequence starting with the given two numbers. A Fibonacci sequence is one where each element is the sum of the previous two elements in the series:
[source,scala]
----
scala> def fibFrom(a: Int, b: Int): Stream[Int] =
          a #:: fibFrom(b, a + b)
fibFrom: (a: Int, b: Int)Stream[Int]
----
This function is deceptively simple. The first element of the sequence is clearly a, and the rest of the sequence is the Fibonacci sequence starting with b followed by a + b. The tricky part is computing this sequence without causing an infinite recursion. If the function used :: instead of #::, then every call to the function would result in another call, thus causing an infinite recursion. Since it uses #::, though, the right-hand side is not evaluated until it is requested.

Here are the first few elements of the Fibonacci sequence starting with two ones:
[source,scala]
----
scala> val fibs = fibFrom(1, 1).take(7)
fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)

scala> fibs.toList
res23: List[Int] = List(1, 1, 2, 3, 5, 8, 13)
----

Вектори
~~~~~~~
Lists are very efficient when the algorithm processing them is careful to only process their heads. Accessing, adding, and removing the head of a list takes only constant time, whereas accessing or modifying elements later in the list takes time linear in the depth into the list.

Vectors are a collection type that give efficient access to elements beyond the head. Access to any elements of a vector take only "effectively constant time," as defined below. It's a larger constant than for access to the head of a list or for reading an element of an array, but it's a constant nonetheless. As a result, algorithms using vectors do not have to be careful about accessing just the head of the sequence. They can access and modify elements at arbitrary locations, and thus they can be much more convenient to write.
Vectors are built and modified just like any other sequence:
[source,scala]
----
scala> val vec = scala.collection.immutable.Vector.empty
vec: scala.collection.immutable.Vector[Nothing] = Vector()

scala> val vec2 = vec :+ 1 :+ 2
vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)

scala> val vec3 = 100 +: vec2
vec3: scala.collection.immutable.Vector[Int]
  = Vector(100, 1, 2)

scala> vec3(0)
res24: Int = 100
----
Vectors are represented as broad, shallow trees. Every tree node contains up to 32 elements of the vector or contains up to 32 other tree nodes. Vectors with up to 32 elements can be represented in a single node. Vectors with up to 32 * 32 = 1024 elements can be represented with a single indirection. Two hops from the root of the tree to the final element node are sufficient for vectors with up to 215 elements, three hops for vectors with 220, four hops for vectors with 225 elements and five hops for vectors with up to 230 elements. So for all vectors of reasonable size, an element selection involves up to five primitive array selections. This is what we meant when we wrote that element access is "effectively constant time."

Vectors are immutable, so you cannot change an element of a vector in place. However, with the updated method you can create a new vector that differs from a given vector only in a single element:
[source,scala]
----
scala> val vec = Vector(1, 2, 3)
vec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)

scala> vec updated (2, 4)
res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)

scala> vec
res26: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)
----
As the last line above shows, a call to updated has no effect on the original vector vec. Like selection, functional vector updates are also "effectively constant time." Updating an element in the middle of a vector can be done by copying the node that contains the element, and every node that points to it, starting from the root of the tree. This means that a functional update creates between one and five nodes that each contain up to 32 elements or subtrees. This is certainly more expensive than an in-place update in a mutable array, but still a lot cheaper than copying the whole vector.

Because vectors strike a good balance between fast random selections and fast random functional updates, they are currently the default implementation of immutable indexed sequences:
[source,scala]
----
scala> collection.immutable.IndexedSeq(1, 2, 3)
res27: scala.collection.immutable.IndexedSeq[Int]
  = Vector(1, 2, 3)Immutable stacks
----
If you need a last-in-first-out sequence, you can use a Stack. You push an element onto a stack with push, pop an element with pop, and peek at the top of the stack without removing it withtop. All of these operations are constant time.

Here are some simple operations performed on a stack:
[source,scala]
----
scala> val stack = scala.collection.immutable.Stack.empty
stack: scala.collection.immutable.Stack[Nothing] = Stack()

scala> val hasOne = stack.push(1)
hasOne: scala.collection.immutable.Stack[Int] = Stack(1)

scala> stack
res28: scala.collection.immutable.Stack[Nothing] = Stack()

scala> hasOne.top
res29: Int = 1

scala> hasOne.pop
res30: scala.collection.immutable.Stack[Int] = Stack()
----
Immutable stacks are used rarely in Scala programs because their functionality is subsumed by lists: A push on an immutable stack is the same as a :: on a list, and a pop on a stack is the same a tail on a list.

Незмінні черги
~~~~~~~~~~~~~~
A queue is just like a stack except that it is first-in-first-out rather than last-in-first-out. A simplified implementation of immutable queues was discussed in Chapter 19. Here's how you can create an empty immutable queue:
[source,scala]
----
scala> val empty = scala.collection.immutable.Queue[Int]()
empty: scala.collection.immutable.Queue[Int] = Queue()
----
You can append an element to an immutable queue with enqueue:
[source,scala]
----
scala> val has1 = empty.enqueue(1)
has1: scala.collection.immutable.Queue[Int] = Queue(1)
----
To append multiple elements to a queue, call enqueue with a collection as its argument:
[source,scala]
----
scala> val has123 = has1.enqueue(List(2, 3))
has123: scala.collection.immutable.Queue[Int] = Queue(1, 2,
3)
----
To remove an element from the head of the queue, use dequeue:
[source,scala]
----
scala> val (element, has23) = has123.dequeue
element: Int = 1
has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)
----
Note that dequeue returns a pair consisting of the element removed and the rest of the queue.

Диапазони
~~~~~~~~~
A range is an ordered sequence of integers that are equally spaced apart. For example, "1, 2, 3" is a range, as is "5, 8, 11, 14." To create a range in Scala, use the predefined methods to andby. Here are some examples:
[source,scala]
----
scala> 1 to 3
res31: scala.collection.immutable.Range.Inclusive
  = Range(1, 2, 3)

scala> 5 to 14 by 3
res32: scala.collection.immutable.Range = Range(5, 8, 11, 14)
----
If you want to create a range that is exclusive of its upper limit, use the convenience methoduntil instead of to:
[source,scala]
----
scala> 1 until 3
res33: scala.collection.immutable.Range = Range(1, 2)
----
Ranges are represented in constant space, because they can be defined by just three numbers: their start, their end, and the stepping value. Because of this representation, most operations on ranges are extremely fast.

Хеш дерева
~~~~~~~~~~
Hash tries,footnote:["Trie" comes from the word "retrieval" and is pronounced tree or try.] are a standard way to implement immutable sets and maps efficiently. Their representation is similar to vectors in that they are also trees where every node has 32 elements or 32 subtrees, but selection is done based on a hash code. For instance, to find a given key in a map, you use the lowest five bits of the hash code of the key to select the first subtree, the next five bits the next subtree, and so on. Selection stops once all elements stored in a node have hash codes that differ from each other in the bits that are selected so far. Thus, not all the bits of the hash code are necessarily used.

Hash tries strike a nice balance between reasonably fast lookups and reasonably efficient functional insertions (+) and deletions (-). That's why they underlie Scala's default implementations of immutable maps and sets. In fact, Scala has a further optimization for immutable sets and maps that contain less than five elements. Sets and maps with one to four elements are stored as single objects that just contain the elements (or key/value pairs in the case of a map) as fields. The empty immutable set and empty immutable map is in each case a singleton object—there's no need to duplicate storage for those because an empty immutable set or map will always stay empty.

Червоне-чорне дерева
~~~~~~~~~~~~~~~~~~~~
Red-black trees are a form of balanced binary trees where some nodes are designated "red" and others "black." Like any balanced binary tree, operations on them reliably complete in time logarithmic to the size of the tree.

Scala provides implementations of sets and maps that use a red-black tree internally. You access them under the names TreeSet and TreeMap:
[source,scala]
----
scala> val set = collection.immutable.TreeSet.empty[Int]
set: scala.collection.immutable.TreeSet[Int] = TreeSet()

scala> set + 1 + 3 + 3
res34: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)
----
Red-black trees are also the standard implementation of SortedSet in Scala, because they provide an efficient iterator that returns all elements of the set in sorted order.

Незмінні бітові множини
~~~~~~~~~~~~~~~~~~~~~~~
A bit set represents a collection of small integers as the bits of a larger integer. For example, the bit set containing 3, 2, and 0 would be represented as the integer 1101 in binary, which is 13 in decimal.

Internally, bit sets use an array of 64-bit Longs. The first Long in the array is for integers 0 through 63, the second is for 64 through 127, and so on. Thus, bit sets are very compact so long as the largest integer in the set is less than a few hundred or so.

Operations on bit sets are very fast. Testing for inclusion takes constant time. Adding an item to the set takes time proportional to the number of Longs in the bit set's array, which is typically a small number. Here are some simple examples of the use of a bit set:
[source,scala]
----
scala> val bits = scala.collection.immutable.BitSet.empty
bits: scala.collection.immutable.BitSet = BitSet()

scala> val moreBits = bits + 3 + 4 + 4
moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)

scala> moreBits(3)
res35: Boolean = true

scala> moreBits(0)
res36: Boolean = false
----

Спискові мапи
~~~~~~~~~~~~~
A list map represents a map as a linked list of key-value pairs. In general, operations on a list map might have to iterate through the entire list. Thus, operations on a list map take time linear in the size of the map. In fact there is little usage for list maps in Scala because standard immutable maps are almost always faster. The only possible difference is if the map is for some reason constructed in such a way that the first elements in the list are selected much more often than the other elements.
[source,scala]
----
scala> val map = collection.immutable.ListMap(
1 -> "one", 2 -> "two")
map: scala.collection.immutable.ListMap[Int,String] = Map(1
-> one, 2 -> two)

scala> map(2)
res37: String = "two"
----

24.9 Суцільні класи змінних колекцій
------------------------------------
Now that you've seen the most commonly used immutable collection classes that Scala provides in its standard library, take a look at the mutable collection classes.

Буфери масивів
~~~~~~~~~~~~~~
You've already seen array buffers in Section 17.1. An array buffer holds an array and a size. Most operations on an array buffer have the same speed as an array, because the operations simply access and modify the underlying array. Additionally, array buffers can have data efficiently added to the end. Appending an item to an array buffer takes amortized constant time. Thus, array buffers are useful for efficiently building up a large collection whenever the new items are always added to the end. Here are some examples:
[source,scala]
----
scala> val buf = collection.mutable.ArrayBuffer.empty[Int]
buf: scala.collection.mutable.ArrayBuffer[Int]
  = ArrayBuffer()

scala> buf += 1
res38: buf.type = ArrayBuffer(1)

scala> buf += 10
res39: buf.type = ArrayBuffer(1, 10)

scala> buf.toArray
res40: Array[Int] = Array(1, 10)
----

Буфери списків
~~~~~~~~~~~~~~
You've also already seen list buffers in Section 17.1. A list buffer is like an array buffer except that it uses a linked list internally instead of an array. If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer. Here's an example:footnote:[The "buf.type" that appears in the interpreter responses in this and several other examples in this section is a singleton type. As will be explained in Section 29.6, buf.type means the variable holds exactly the object referred to by buf.]
[source,scala]
----
scala> val buf = collection.mutable.ListBuffer.empty[Int]
buf: scala.collection.mutable.ListBuffer[Int]
  = ListBuffer()

scala> buf += 1
res41: buf.type = ListBuffer(1)

scala> buf += 10
res42: buf.type = ListBuffer(1, 10)

scala> buf.toList
res43: List[Int] = List(1, 10)
----

Будівельники рядків
~~~~~~~~~~~~~~~~~~~
Just like an array buffer is useful for building arrays, and a list buffer is useful for building lists, a string builder is useful for building strings. String builders are so commonly used that they are already imported into the default namespace. Create them with a simplenew StringBuilder, like this:
[source,scala]
----
scala> val buf = new StringBuilder
buf: StringBuilder =

scala> buf += 'a'
res44: buf.type = a

scala> buf ++= "bcdef"
res45: buf.type = abcdef

scala> buf.toString
res46: String = abcdef
----

Зв'язані списки
~~~~~~~~~~~~~~~
Linked lists are mutable sequences that consist of nodes that are linked with next pointers. In most languages null would be picked as the empty linked list. That does not work for Scala collections, because even empty sequences must support all sequence methods.LinkedList.empty.isEmpty, in particular, should return true and not throw a NullPointerException. Empty linked lists are encoded instead in a special way: Their next field points back to the node itself.

Like their immutable cousins, linked lists are best operated on sequentially. In addition, linked lists make it easy to insert an element or linked list into another linked list.

Подвійно зв'язаний список
~~~~~~~~~~~~~~~~~~~~~~~~~
DoubleLinkedLists are like the single linked lists described in the previous subsection, except besides next, they have another mutable field, prev, that points to the element preceding the current node. The main benefit of that additional link is that it makes element removal very fast.

Змінні списки
~~~~~~~~~~~~~
A MutableList consists of a single linked list together with a pointer that refers to the terminal empty node of that list. This makes list append a constant time operation because it avoids having to traverse the list in search for its terminal node. MutableList is currently the standard implementation of mutable.LinearSeq in Scala.

Черги
~~~~~
Scala provides mutable queues in addition to immutable ones. You use a mutable queue similarly to the way you use an immutable one, but instead of enqueue, you use the += and ++=operators to append. Also, on a mutable queue, the dequeue method will just remove the head element from the queue and return it. Here's an example:
[source,scala]
----
scala> val queue = new scala.collection.mutable.Queue[String]
queue: scala.collection.mutable.Queue[String] = Queue()

scala> queue += "a"
res47: queue.type = Queue(a)

scala> queue ++= List("b", "c")
res48: queue.type = Queue(a, b, c)

scala> queueres49: scala.collection.mutable.Queue[String] = Queue(a, b, c)

scala> queue.dequeue
res50: String = a

scala> queue
res51: scala.collection.mutable.Queue[String] = Queue(b, c)
----

Масивні послідовності
~~~~~~~~~~~~~~~~~~~~~
Array sequences are mutable sequences of fixed size that store their elements internally in anArray[AnyRef]. They are implemented in Scala by class ArraySeq. You would typically use an ArraySeq if you want an array for its performance characteristics, but you also want to create generic instances of the sequence where you do not know the type of the elements and do not have a ClassTag to provide it at run-time. You will find out about these issues with arrays shortly, in Section 24.10.

Стеки
~~~~~
You saw immutable stacks earlier. There is also a mutable version. It works exactly the same as the immutable version except that modifications happen in place. Here's an example:
[source,scala]
----
scala> val stack = new scala.collection.mutable.Stack[Int]
stack: scala.collection.mutable.Stack[Int] = Stack()

scala> stack.push(1)
res52: stack.type = Stack(1)

scala> stack
res53: scala.collection.mutable.Stack[Int] = Stack(1)

scala> stack.push(2)
res54: stack.type = Stack(2, 1)

scala> stack
res55: scala.collection.mutable.Stack[Int] = Stack(2, 1)

scala> stack.top
res56: Int = 2

scala> stack
res57: scala.collection.mutable.Stack[Int] = Stack(2, 1)

scala> stack.pop
res58: Int = 2

scala> stack
res59: scala.collection.mutable.Stack[Int] = Stack(1)
----

Масивні стеки
~~~~~~~~~~~~~
ArrayStack is an alternative implementation of a mutable stack, which is backed by an Arraythat gets resized as needed. It provides fast indexing and is generally slightly more efficient for most operations than a normal mutable stack.

Хеш таблиці
~~~~~~~~~~~
A hash table stores its elements in an underlying array, placing each item at a position in the array determined by the hash code of that item. Adding an element to a hash table takes only constant time, so long as there isn't already another element in the array that has the same hash code. Hash tables are thus very fast so long as the objects placed in them have a good distribution of hash codes. As a result, the default mutable map and set types in Scala are based on hash tables.

Hash sets and maps are used just like any other set or map. Here are some simple examples:
[source,scala]
----
scala> val map = collection.mutable.HashMap.empty[Int,String]
map: scala.collection.mutable.HashMap[Int,String] = Map()

scala> map += (1 -> "make a web site")
res60: map.type = Map(1 -> make a web site)

scala> map += (3 -> "profit!")
res61: map.type = Map(1 -> make a web site, 3 -> profit!)

scala> map(1)
res62: String = make a web site

scala> map contains 2
res63: Boolean = false
----
Iteration over a hash table is not guaranteed to occur in any particular order. Iteration simply proceeds through the underlying array in whichever order it happens to be. To get a guaranteed iteration order, use a linked hash map or set instead of a regular one. A linked hash map or set is just like a regular hash map or set except that it also includes a linked list of the elements in the order they were added. Iteration over such a collection is always in the same order that the elements were initially added.

Слабкі хеш мапи
~~~~~~~~~~~~~~~
A weak hash map is a special kind of hash map in which the garbage collector does not follow links from the map to the keys stored in it. This means that a key and its associated value will disappear from the map if there is no other reference to that key. Weak hash maps are useful for tasks such as caching, where you want to re-use an expensive function's result if the function is called again on the same key. If keys and function results are stored in a regular hash map, the map could grow without bounds, and no key would ever become garbage. Using a weak hash map avoids this problem. As soon as a key object becomes unreachable, it's entry is removed from the weak hash map. Weak hash maps in Scala are implemented as a wrapper of an underlying Java implementation, java.util.WeakHashMap.

Конкурентні мапи
~~~~~~~~~~~~~~~~
A concurrent map can be accessed by several threads at once. In addition to the usual Mapoperations, it provides the following atomic operations:

[caption="Операції трейта ConcurrentMap"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
|m putIfAbsent(k, v)|Adds key/value binding k -> m unless k is already defined in m
|m remove (k, v)|Removes entry for k if it is currently mapped to v
|m replace (k, old, new)| Replaces value associated with key k to new, if it was previously bound to old
|m replace (k, v)|Replaces value associated with key k to v, if it was previously bound to some value
|===

ConcurrentMap is a trait in the Scala collections library. Currently, its only implementation is Java's java.util.concurrent.ConcurrentMap, which can be converted automatically into a Scala map using the standard Java/Scala collection conversions, which will be described in Section 24.17.

Змінні бітові множини
~~~~~~~~~~~~~~~~~~~~~
A mutable bit set is just like an immutable one, except that it can be modified in place. Mutable bit sets are slightly more efficient at updating than immutable ones, because they don't have to copy around Longs that haven't changed. Here is an example:
[source,scala]
----
scala> val bits = scala.collection.mutable.BitSet.empty
bits: scala.collection.mutable.BitSet = BitSet()

scala> bits += 1
res64: bits.type = BitSet(1)

scala> bits += 3
res65: bits.type = BitSet(1, 3)

scala> bits
res66: scala.collection.mutable.BitSet = BitSet(1, 3)
----

24.10 Масиви
------------
Arrays are a special kind of collection in Scala. One the one hand, Scala arrays correspond one-to-one to Java arrays. That is, a Scala array Array[Int] is represented as a Java int[], anArray[Double] is represented as a Java double[] and an Array[String] is represented as a JavaString[]. But at the same time, Scala arrays offer much more their Java analogues. First, Scala arrays can be generic. That is, you can have an Array[T], where T is a type parameter or abstract type. Second, Scala arrays are compatible with Scala sequences—you can pass anArray[T] where a Seq[T] is required. Finally, Scala arrays also support all sequence operations. Here's an example of this in action: 
[source,scala]
----
scala> val a1 = Array(1, 2, 3)
a1: Array[Int] = Array(1, 2, 3)

scala> val a2 = a1 map (_ * 3)
a2: Array[Int] = Array(3, 6, 9)scala> val a3 = a2 filter (_ % 2 != 0)
a3: Array[Int] = Array(3, 9)

scala> a3.reverse
res1: Array[Int] = Array(9, 3)
----
Given that Scala arrays are represented just like Java arrays, how can these additional features be supported in Scala?

The answer lies in systematic use of implicit conversions. An array cannot pretend to be a sequence, because the data type representation of a native array is not a subtype of Seq. Instead, whenever an array would be used as a Seq, implicitly wrap it in a subclass of Seq. The name of that subclass is scala.collection.mutable.WrappedArray. Here you see it in action:
[source,scala]
----
scala> val seq: Seq[Int] = a1
seq: Seq[Int] = WrappedArray(1, 2, 3)

scala> val a4: Array[Int] = seq.toArray
a4: Array[Int] = Array(1, 2, 3)

scala> a1 eq a4
res2: Boolean = true
----
This interaction demonstrates that arrays are compatible with sequences, because there's an implicit conversion from Array to WrappedArray. To go the other way, from a WrappedArray to anArray, you can use the toArray method defined in Traversable. The last interpreter line above shows that wrapping then unwrapping with toArray gives you back the same array you started with.

There is yet another implicit conversion that gets applied to arrays. This conversion simply "adds" all sequence methods to arrays but does not turn the array itself into a sequence. "Adding" means that the array is wrapped in another object of type ArrayOps, which supports all sequence methods. Typically, this ArrayOps object is short-lived; it will usually be inaccessible after the call to the sequence method and its storage can be recycled. Modern VMs often avoid creating this object entirely.

The difference between the two implicit conversions on arrays is demonstrated here:
[source,scala]
----
scala> val seq: Seq[Int] = a1
seq: Seq[Int] = WrappedArray(1, 2, 3)

scala> seq.reverse
res2: Seq[Int] = WrappedArray(3, 2, 1)

scala> val ops: collection.mutable.ArrayOps[Int] = a1
ops: scala.collection.mutable.ArrayOps[Int] = [I(1, 2, 3)

scala> ops.reverse
res3: Array[Int] = Array(3, 2, 1)
----
You see that calling reverse on seq, which is a WrappedArray, will give again a WrappedArray. That's logical, because wrapped arrays are Seqs, and calling reverse on any Seq will give again a Seq. On the other hand, calling reverse on the ops value of class ArrayOps will result in an Array, not aSeq.The ArrayOps example above was quite artificial, intended only to show the difference toWrappedArray. Normally, you'd never define a value of class ArrayOps. You'd just call a Seq method on an array:
[source,scala]
----
scala> a1.reverse
res4: Array[Int] = Array(3, 2, 1)
----
The ArrayOps object gets inserted automatically by the implicit conversion. So the line above is equivalent to the following line, where intArrayOps was the conversion that was implicitly inserted previously:
[source,scala]
----
scala> intArrayOps(a1).reverse
res5: Array[Int] = Array(3, 2, 1)
----
This raises the question how the compiler picked intArrayOps over the other implicit conversion to WrappedArray in the line above. After all, both conversions map an array to a type that supports a reverse method, which is what the input specified. The answer to that question is that the two implicit conversions are prioritized. The ArrayOps conversion has a higher priority than the WrappedArray conversion. The first is defined in the Predef object whereas the second is defined in a class scala.LowPriorityImplicits, which is a superclass of Predef. Implicits in subclasses and subobjects take precedence over implicits in base classes. So if both conversions are applicable, the one in Predef is chosen. A very similar scheme, which was described in Section 21.7, works for strings.

So now you know how arrays can be compatible with sequences and how they can support all sequence operations. What about genericity? In Java you cannot write a T[] where T is a type parameter. How then is Scala's Array[T] represented? In fact a generic array like Array[T] could be at run time any of Java's eight primitive array types byte[], short[], char[], int[], long[],float[], double[], boolean[], or it could be an array of objects. The only common run-time type encompassing all of these types is AnyRef (or, equivalently java.lang.Object), so that's the type to which the Scala compiler maps Array[T]. At run-time, when an element of an array of typeArray[T] is accessed or updated there is a sequence of type tests that determine the actual array type, followed by the correct array operation on the Java array. These type tests slow down array operations somewhat. You can expect accesses to generic arrays to be three to four times slower than accesses to primitive or object arrays. This means that if you need maximal performance, you should prefer concrete over generic arrays.

Representing the generic array type is not enough, however, there must also be a way tocreate generic arrays. This is an even harder problem, which requires a little bit of help from you. To illustrate the problem, consider the following attempt to write a generic method that creates an array:
[source,scala]
----
// This is wrong!
def evenElems[T](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
----
The evenElems method returns a new array that consists of all elements of the argument vectorxs that are at even positions in the vector. The first line of the body of evenElems creates the result array, which has the same element type as the argument. So depending on the actual type parameter for T, this could be an Array[Int], or an Array[Boolean], or an array of some of the other primitive types in Java, or an array of some reference type. But these types all have different runtime representations, so how is the Scala runtime going to pick the correct one? In fact, it can't do that based on the information it is given, because the actual type that corresponds to the type parameter T is erased at runtime. That's why you will get the following error message if you attempt to compile the code above:
[source,scala]
----
error: cannot find class tag for element type T
  val arr = new Array[T]((arr.length + 1) / 2)
            ^
----
What's required here is that you help the compiler by providing a runtime hint of what the actual type parameter of evenElems is. This runtime hint takes the form of a class tag of typescala.reflect.ClassTag. A class tag describes the erased type of a given type, which is all the information needed to construct an array of that type.

In many cases the compiler can generate a class tag on its own. Such is the case for a concrete type like Int or String. It's also the case for certain generic types, like List[T], where enough information is known to predict the erased type; in this example the erased type would beList.

For fully generic cases, the usual idiom is to pass the class tag using a context bound, as discussed in Section 21.6. Here is how the above definition could be fixed by using a context bound:
[source,scala]
----
// This works
import scala.reflect.ClassTag
def evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
----
In this new definition, when the Array[T] is created, the compiler looks for a class tag for the type parameter T, that is, it will look for an implicit value of type ClassTag[T]. If such a value is found, the class tag is used to construct the right kind of array. Otherwise, you'll see an error message like the one shown previously.

Here is an interpreter interaction that uses the evenElems method:
[source,scala]
----
scala> evenElems(Vector(1, 2, 3, 4, 5))
res6: Array[Int] = Array(1, 3, 5)

scala> evenElems(Vector("this", "is", "a", "test", "run"))
res7: Array[java.lang.String] = Array(this, a, run)
----
In both cases, the Scala compiler automatically constructed a class tag for the element type (first Int, then String) and passed it to the implicit parameter of the evenElems method. The compiler can do thatfor all concrete types, but not if the argument is itself another type parameter without its class tag. For instance, the following fails:
[source,scala]
----
scala> def wrap[U](xs: Vector[U]) = evenElems(xs)
<console>:9: error: No ClassTag available for U
  def wrap[U](xs: Vector[U]) = evenElems(xs)
                                        ^
----
What happened here is that the evenElems demands a class tag for the type parameter U, but none was found. The solution in this case is, of course, to demand another implicit class tag for U. So the following works:
[source,scala]
----
scala> def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)
wrap: [U](xs: Vector[U])(implicit evidence$1:
scala.reflect.ClassTag[U])Array[U]
----
This example also shows that the context bound in the definition of U is just a shorthand for an implicit parameter named here evidence$1 of type ClassTag[U].

24.11 Рядки
-----------
Like arrays, strings are not directly sequences, but they can be converted to them, and they also support all sequence operations. Here are some examples of operations you can invoke on strings:
[source,scala]
----
scala> val str = "hello"
str: java.lang.String = hello

scala> str.reverse
res6: String = olleh

scala> str.map(_.toUpper)
res7: String = HELLO

scala> str drop 3
res8: String = lo

scala> str slice (1, 4)
res9: String = ell

scala> val s: Seq[Char] = str
s: Seq[Char] = WrappedString(h, e, l, l, o)
----
These operations are supported by two implicit conversions, which were explained in Section 21.7. The first, low-priority conversion maps a String to a WrappedString, which is a subclass ofimmutable.IndexedSeq. This conversion was applied in the last line of the previous example in which a string was converted into a Seq. The other, high-priority conversion maps a string to aStringOps object, which adds all methods on immutable sequences to strings. This conversion was implicitly inserted in the method calls of reverse, map, drop, and slice in the previous example.

24.12 Характеристики продуктивності
-----------------------------------
As the previous explanations have shown, different collection types have different performance characteristics. That's often the primary reason for picking one collection type over another. You can see the performance characteristics of some common operations on collections summarized in two tables, Table 24.12 and Table 24.12.

Performance characteristics of sequence types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|===
|              |head|tail|apply|update|prepend|append|insert
8+|immutable
|List          |C|C|L|L|C|L|-
|Stream        |C|C|L|L|C|L|- 
|Vector        |eC|eC|eC|eC|eC|eC|-
|Stack         |C|C|L|L|C|L|-
|Queue         |aC|aC|L|L|L|C|- 
|Range         |C|C|C|-|-|-|-
|String        |C|L|C|L|L|L|- 
8+|mutable
|ArrayBuffer   |C|L|C|C|L|aC|L
|ListBuffer    |C|L|L|L|C|C|L
|StringBuilder |C|L|C|C|L|aC|L
|MutableList   |C|L|L|L|C|C|L
|Queue         |C|L|L|L|C|C|L
|ArraySeq      |C|L|C|C|-|-|-
|Stack         |C|L|L|L|C|L|L 
|ArrayStack    |C|L|C|C|aC|L|L 
|Array         |C|L|C|C|-|-|-
|===

Performance characteristics of set and map types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|===
|                 |lookup|add|remove|min
5+|immutable
|HashSet/HashMap  |eC|eC|eC|L
|TreeSet/TreeMap  |Log|Log|Log|Log
|BitSet           |C|L|L|eC.footnote:[Assuming bits are densely packed.]
|ListMap          |L|L|L|L
5+|mutable
|HashSet/HashMap  |eC|eC|eC|L
|WeakHashMap      |eC|eC|eC|L
|BitSet           |C|aC|C|eC^a
|===
 
Входження в ціх двох таблицях пояснюється наступним чином:

*C* Операція займає сталий час (швидка).

*eC* Операція ефективно займає сталий час, але це може залежати від деяких припущень, таких, як максимальна довжина вектора, або розподілення хеш ключей.

*aC* Операція займає амортизований сталий час. Деякі виклики операції можуть зайняти довше, але якщо виконується багато операцій,в середньому операція триває сталий час.

*Log* Операція триває час, пропорційний до логарифму розміру колекції.

*L* Операція лінійна, триває час пропорційний до розміру колекції.

*-* Операція не підтримується.

Таблиця 24.12 treats sequence types—both immutable and mutable—with the following operations:

*head* Вибір першого елемента в послідовності.

*tail* Створення нової колекції, що складається з усіх елементів, крім першого.

*apply* Індексування.

*update* Functional update (with updated) for immutable sequences, side-effecting update (with update) for mutable sequences.

*prepend* Adding an element to the front of the sequence. For immutable sequences, this produces a new sequence. For mutable sequences it modifies the existing sequence.

*append* Adding an element at the end of the sequence. For immutable sequences, this produces a new sequence. For mutable sequences it modifies the existing sequence.

*insert* Inserting an element at an arbitrary position in the sequence. This is only supported directly for mutable sequences.

Table 24.12 treats mutable and immutable sets and maps with the following operations:

*lookup* Testing whether an element is contained in set, or selecting a value associated with a key.
*add* Adding a new element to a set or a new key/value pair to a map.
*remove* Removing an element from a set or a key from a map.
*min* The smallest element of the set, or the smallest key of a map.

24.13 Еквівалентність
---------------------
The collection libraries have a uniform approach to equality and hashing. The idea is, first, to divide
collections into sets, maps, and sequences. Collections in different categories are always unequal. For
instance, Set(1, 2, 3) is unequal to List(1, 2, 3) even though they contain the same elements. On the
other hand, within the same category, collections are equal if and only if they have the same elements
(for sequences: the same elements in the same order). For example, List(1, 2, 3) == Vector(1, 2, 3),
and HashSet(1, 2) == TreeSet(2, 1).
It does not matter for the equality check whether a collection is mutable or immutable. For a mutable
collection, equality simply depends on the current elements at the time the equality test is performed.
This means that a mutable collection might be equal to different collections at different times,
depending what elements are added or removed. This is a potential trap when using a mutable
collection as a key in a hash map. For example:
scala> import collection.mutable.{HashMap, ArrayBuffer}
import collection.mutable.{HashMap, ArrayBuffer}scala> val buf = ArrayBuffer(1, 2, 3)
buf: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer(1, 2, 3)
scala> val map = HashMap(buf -> 3)
map: scala.collection.mutable.HashMap[scala.collection.
mutable.ArrayBuffer[Int],Int] = Map((ArrayBuffer(1, 2, 3),3))
scala> map(buf)
res13: Int = 3
scala> buf(0) += 1
scala> map(buf)
java.util.NoSuchElementException: key not found:
ArrayBuffer(2, 2, 3)
In this example, the selection in the last line will most likely fail because the hash code of the
array xs has changed in the second-to-last line. Therefore, the hash-code-based lookup will look at a
different place than the one in which xs was stored.
24.14 VIEWS
Collections have quite a few methods that construct new collections. Some examples are map,filter,
and ++. We call such methods transformers because they take at least one collection as their receiver
object and produce another collection in their result.
Transformers can be implemented in two principal ways: strict and non-strict (or lazy). A strict
transformer constructs a new collection with all of its elements. A non-strict, or lazy, transformer
constructs only a proxy for the result collection, and its elements are constructed on demand.
As an example of a non-strict transformer, consider the following implementation of a lazy map
operation:
def lazyMap[T, U](coll: Iterable[T], f: T => U) =
new Iterable[U] {
def iterator = coll.iterator map f
}
Note that lazyMap constructs a new Iterable without stepping through all elements of the given
collection coll. The given function f is instead applied to the elements of the new collection'siterator as
they are demanded.
Scala collections are by default strict in all their transformers, except for Stream, which implements all
its transformer methods lazily. However, there is a systematic way to turn every collection into a lazy
one and vice versa, which is based on collection views. A view is a special kind of collection that
represents some base collection, but implements all of its transformers lazily.
To go from a collection to its view, you can use the view method on the collection. If xs is some
collection, then xs.view is the same collection, but with all transformers implemented lazily. To get
back from a view to a strict collection, you can use the force method.As an example, say you have a vector of Ints over which you want to map two functions in succession:
scala> val v = Vector(1 to 10: _*)
v: scala.collection.immutable.Vector[Int] =
Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
scala> v map (_ + 1) map (_ * 2)
res5: scala.collection.immutable.Vector[Int] =
Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
In the last statement, the expression v map (_ + 1) constructs a new vector that is then transformed into
a third vector by the second call to map (_ * 2). In many situations, constructing the intermediate result
from the first call to map is a bit wasteful. In the pseudo example, it would be faster to do a
single map with the composition of the two functions (_ + 1)and (_ * 2). If you have the two functions
available in the same place you can do this by hand. But quite often, successive transformations of a
data structure are done in different program modules. Fusing those transformations would then
undermine modularity. A more general way to avoid the intermediate results is by turning the vector
first into a view, applying all transformations to the view, and finally forcing the view to a vector:
scala> (v.view map (_ + 1) map (_ * 2)).force
res12: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
We'll do this sequence of operations again, one by one:
scala> val vv = v.view
vv: scala.collection.SeqView[Int,Vector[Int]] =
SeqView(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
The application v.view gives you a SeqView, i.e., a lazily evaluated Seq. The type SeqView has two
type parameters. The first, Int, shows the type of the view's elements. The second, Vector[Int], shows
you the type constructor you get back when forcing the view.
Applying the first map to the view gives you:
scala> vv map (_ + 1)
res13: scala.collection.SeqView[Int,Seq[_]] = SeqViewM(...)
The result of the map is a value that prints SeqViewM(...). This is in essence a wrapper that records the
fact that a map with function (_ + 1) needs to be applied on the vector v. It does not apply that map
until the view is forced, however. The "M" after SeqView is an indication that the view encapsulates
a map operation. Other letters indicate other delayed operations. For instance "S" indicates a
delayed slice operation, and "R" indicates a reverse. We'll now apply the second map to the last result.
scala> res13 map (_ * 2)
res14: scala.collection.SeqView[Int,Seq[_]] = SeqViewMM(...)
You now get a SeqView that contains two map operations, so it prints with a double
"M":SeqViewMM(...). Finally, forcing the last result gives:
scala> res14.force
res15: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)Both stored functions get applied as part of the execution of the force operation and a new vector is
constructed. That way, no intermediate data structure is needed.
One detail to note is that the static type of the final result is a Seq, not a Vector. Tracing the types back
we see that as soon as the first delayed map was applied, the result had static
typeSeqViewM[Int, Seq[_]]. That is, the "knowledge" that the view was applied to the specific
sequence type Vector got lost. The implementation of a view for any particular class requires quite a bit
of code, so the Scala collection libraries provide views mostly only for general collection types, not for
specific implementations.footnote:[An exception to this is arrays: applying delayed operations on arrays will again give results with static type Array.]
There are two reasons why you might want to consider using views. The first is performance. You have
seen that by switching a collection to a view the construction of intermediate results can be avoided.
These savings can be quite important. As another example, consider the problem of finding the first
palindrome in a list of words. A palindrome is a word that reads backwards the same as forwards. Here
are the necessary definitions:
def isPalindrome(x: String) = x == x.reverse
def findPalindrome(s: Seq[String]) = s find isPalindrome
Now, assume you have a very long sequence words and you want to find a palindrome in the first
million words of that sequence. Can you re-use the definition of findPalindrome? Of course, you could
write:
findPalindrome(words take 1000000)
This nicely separates the two aspects of taking the first million words of a sequence and finding a
palindrome in it. But the downside is that it always constructs an intermediary sequence consisting of
one million words, even if the first word of that sequence is already a palindrome. So potentially,
999,999 words are copied into the intermediary result without being inspected at all afterwards. Many
programmers would give up here and write their own specialized version of finding palindromes in
some given prefix of an argument sequence. But with views, you don't have to. Simply write:
findPalindrome(words.view take 1000000)
This has the same nice separation of concerns, but instead of a sequence of a million elements it will
only construct a single lightweight view object. This way, you do not need to choose between
performance and modularity.
The second use case applies to views over mutable sequences. Many transformer functions on such
views provide a window into the original sequence that can then be used to update selectively some
elements of that sequence. To see this in an example, suppose you have an array arr:
scala> val arr = (0 to 9).toArray
arr: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
You can create a subwindow into that array by creating a slice of a view of the array:
scala> val subarr = arr.view.slice(3, 6)subarr: scala.collection.mutable.IndexedSeqView[
Int,Array[Int]] = IndexedSeqViewS(...)
This gives a view, subarr, which refers to the elements at positions 3 through 5 of the array arr. The
view does not copy these elements, it just provides a reference to them. Now, assume you have a
method that modifies some elements of a sequence. For instance, the following negatemethod would
negate all elements of the sequence of integers it's given:
scala> def negate(xs: collection.mutable.Seq[Int]) =
for (i <- 0 until xs.length) xs(i) = -xs(i)
negate: (xs: scala.collection.mutable.Seq[Int])Unit
Assume now you want to negate elements at positions three through five of the array arr. Can you
use negate for this? Using a view, this is simple:
scala> negate(subarr)
scala> arr
res4: Array[Int] = Array(0, 1, 2, -3, -4, -5, 6, 7, 8, 9)
What happened here is that negate changed all elements of subarr, which were a slice of the elements
of arr. Again, you see that views help in keeping things modular. The code above nicely separated the
question of what index range to apply a method to from the question what method to apply.
After having seen all these nifty uses of views you might wonder why have strict collections at all? One
reason is that performance comparisons do not always favor lazy over strict collections. For smaller
collection sizes the added overhead of forming and applying closures in views is often greater than the
gain from avoiding the intermediary data structures. A possibly more important reason is that
evaluation in views can be very confusing if the delayed operations have side effects.
Here's an example that bit a few users of versions of Scala before 2.8. In these versions theRange type
was lazy, so it behaved in effect like a view. People were trying to create a number of actors,footnote:[The Scala actors library has been deprecated, but this historical example is still relevant.] like
this:
val actors = for (i <- 1 to 10) yield actor { ... }
They were surprised that none of the actors were executing afterwards, even though the actormethod
should create and start an actor from the code that's enclosed in the braces following it. To explain why
nothing happened, remember that the for expression above is equivalent to an application of
the map method:
val actors = (1 to 10) map (i => actor { ... })
Since previously the range produced by (1 to 10) behaved like a view, the result of the map was again a
view. That is, no element was computed, and, consequently, no actor was created! Actors would have
been created by forcing the range of the whole expression, but it's far from obvious that this is what
was required to make the actors do their work.To avoid surprises like this, the Scala collections gained more regular rules in version 2.8. All
collections except streams and views are strict. The only way to go from a strict to a lazy collection is
via the view method. The only way to go back is via force. So the actors definition above would behave
as expected in Scala 2.8 in that it would create and start ten actors. To get back the surprising previous
behavior, you'd have to add an explicit view method call:
val actors = for (i <- (1 to 10).view) yield actor { ... }
In summary, views are a powerful tool to reconcile concerns of efficiency with concerns of modularity.
But in order not to be entangled in aspects of delayed evaluation, you should restrict views to two
scenarios. Either you apply views in purely functional code where collection transformations do not
have side effects. Or you apply them over mutable collections where all modifications are done
explicitly. What's best avoided is a mixture of views and operations that create new collections while
also having side effects.
24.15 ITERATORS
An iterator is not a collection, but rather a way to access the elements of a collection one by one. The
two basic operations on an iterator it are next and hasNext. A call to it.next() will return the next
element of the iterator and advance the state of the iterator. Calling next again on the same iterator will
then yield the element one beyond the one returned previously. If there are no more elements to return,
a call to next will throw a NoSuchElementException. You can find out whether there are more elements
to return using Iterator's hasNext method.
The most straightforward way to "step through" all the elements returned by an iterator is to use
a while loop:
while (it.hasNext)
println(it.next())
Iterators in Scala also provide analogues of most of the methods that you find in
theTraversable, Iterable, and Seq traits. For instance, they provide a foreach method that executes a
given procedure on each element returned by an iterator. Using foreach, the loop above could be
abbreviated to:
it foreach println
As always, for expressions can be used as an alternate syntax for expressions
involvingforeach, map, filter, and flatMap, so yet another way to print all elements returned by an
iterator would be:
for (elem <- it) println(elem)
There's an important difference between the foreach method on iterators and the same method on
traversable collections: When called on an iterator, foreach will leave the iterator at its end when it is
done. So calling next again on the same iterator will fail with aNoSuchElementException. By contrast,
when called on a collection, foreach leaves the number of elements in the collection unchanged (unlessthe passed function adds or removes elements, but this is discouraged, because it can easily lead to
surprising results).
The other operations that Iterator has in common with Traversable have the same property of leaving
the iterator at its end when done. For instance, iterators provide a map method, which returns a new
iterator:
scala> val it = Iterator("a", "number", "of", "words")
it: Iterator[java.lang.String] = non-empty iterator
scala> it.map(_.length)
res1: Iterator[Int] = non-empty iterator
scala> res1 foreach println
1
6
2
5
scala> it.next()
java.util.NoSuchElementException: next on empty iterator
As you can see, after the call to map, the it iterator has advanced to its end.
Another example is the dropWhile method, which can be used to find the first element of an iterator
that has a certain property. For instance, to find the first word in the iterator shown previously that has
at least two characters, you could write:
scala> val it = Iterator("a", "number", "of", "words")
it: Iterator[java.lang.String] = non-empty iterator
scala> it dropWhile (_.length < 2)
res4: Iterator[java.lang.String] = non-empty iterator
scala> it.next()
res5: java.lang.String = number
Note again that it has changed by the call to dropWhile: it now points to the second word "number" in
the list. In fact, it and the result res4 returned by dropWhile will return exactly the same sequence of
elements.
There is only one standard operation, duplicate, which allows you to re-use the same iterator:
val (it1, it2) = it.duplicate
The call to duplicate gives you two iterators, which each return exactly the same elements as the
iterator it. The two iterators work independently; advancing one does not affect the other. By contrast
the original iterator, it, is advanced to its end by duplicate and is thus rendered unusable.
In summary, iterators behave like collections if you never access an iterator again after invoking a
method on it. The Scala collection libraries make this explicit with an abstraction
called TraversableOnce, which is a common supertrait of Traversable and Iterator. As the nameimplies, TraversableOnce objects can be traversed using foreach, but the state of that object after the
traversal is not specified. If the TraversableOnce object is in fact an Iterator, it will be at its end after
the traversal, but if it is a Traversable, it will still exist as before. A common use case
of TraversableOnce is as an argument type for methods that can take either an iterator or traversable as
argument. An example is the appending method ++ in trait Traversable. It takes
aTraversableOnce parameter, so you can append elements coming from either an iterator or a
traversable collection.
All operations on iterators are summarized in Table 24.12.
Operations in trait Iterator
What it is
Abstract methods:
it.next()
it.hasNext
Variations:
it.buffered
it grouped size
xs sliding size
Copying:
it copyToBuffer buf
What it does
Returns the next element in the iterator and advances pastit.
Returns true if it can return another element.
A buffered iterator returning all elements of it.
An iterator that yields the elements returned by it in fixed-sized sequence
"chunks."
An iterator that yields the elements returned by it in sequences representing a
sliding fixed-sized window.
Copies all elements returned by it to buffer buf.
Copies at most l elements returned by it to array arrstarting at index s. The last
it copyToArray(arr, s, l)
two arguments are optional.
Duplication:
it.duplicate
A pair of iterators that each independently return all elements of it.
Additions:
An iterator returning all elements returned by iterator it, followed by all
it ++ jt
elements returned by iterator jt.
The iterator that returns all elements of it followed by copies of x until
it padTo (len, x)
length len elements are returned overall.
Maps:
The iterator obtained from applying the function f to every element returned
it map f
from it.
The iterator obtained from applying the iterator-valued function f to every
it flatMap f
element in it and appending the results.
The iterator obtained from applying the partial function f to every element
it collect f
in it for which it is defined and collecting the results.
Conversions:
it.toArray
Collects the elements returned by it in an array.
it.toList
Collects the elements returned by it in a list.
it.toIterable
Collects the elements returned by it in an iterable.it.toSeq
it.toIndexedSeq
it.toStream
it.toSet
it.toMap
Size info:
it.isEmpty
it.nonEmpty
it.size
it.length
it.hasDefiniteSize
Collects the elements returned by it in a sequence.
Collects the elements returned by it in an indexed sequence.
Collects the elements returned by it in a stream.
Collects the elements returned by it in a set.
Collects the key/value pairs returned by it in a map.
Tests whether the iterator is empty (opposite of hasNext).
Tests whether the collection contains elements (alias ofhasNext).
The number of elements returned by it. Note: it will be at its end after this
operation!
Same as it.size.
Returns true if it is known to return finitely many elements (by default the
same as isEmpty).
Element retrieval index
search:
it find p
it indexOf x
it indexWhere p
An option containing the first element returned by it that satisfies p,
or None if no element qualifies. Note: The iterator advances to just after the
element, or, if none is found, to the end.
The index of the first element returned by it that equals x. Note: The iterator
advances past the position of this element.
The index of the first element returned by it that satisfies p. Note: The iterator
advances past the position of this element.
Subiterators:
it take n
it drop n
it slice (m, n)
it takeWhile p
it dropWhile p
it filter p
it withFilter p
it filterNot p
Subdivisions:
it partition p
An iterator returning of the first n elements of it. Note: itwill advance to the
position after the n'th element, or to its end, if it contains less than n elements.
The iterator that starts with the (n + 1)'th element of it. Note: it will advance to
the same position.
The iterator that returns a slice of the elements returned from it, starting with
the m'th element and ending before then'th element.
An iterator returning elements from it as long as conditionp is true.
An iterator skipping elements from it as long as condition pis true, and
returning the remainder.
An iterator returning all elements from it that satisfy the condition p.
Same as it filter p. Needed so that iterators can be used infor expressions.
An iterator returning all elements from it that do not satisfy the condition p.
Splits it into a pair of two iterators; one returning all elements from it that
satisfy the predicate p, the other returning all elements from it that do not.
Element conditions:
it forall p
it exists p
it count p
A boolean indicating whether the predicate p holds for all elements returned
by it.
A boolean indicating whether the predicate p holds for some element in it.
The number of elements in it that satisfy the predicate p.Folds:
(z /: it)(op)
(it :\ z)(op)
it.foldLeft(z)(op)
it.foldRight(z)(op)
it reduceLeft op
it reduceRight op
Specific folds:
it.sum
it.product
it.min
it.max
Zippers:
it zip jt
it zipAll (jt, x, y)
it.zipWithIndex
Update:
it patch (i, jt, r)
Applies binary operation op between successive elements returned by it,
going left to right, starting with z.
Applies binary operation op between successive elements returned by it,
going right to left, starting with z.
Same as (z /: it)(op).
Same as (it :\ z)(op).
Applies binary operation op between successive elements returned by non-
empty iterator it, going left to right.
Applies binary operation op between successive elements returned by non-
empty iterator it, going right to left.
The sum of the numeric element values returned by iteratorit.
The product of the numeric element values returned by iterator it.
The minimum of the ordered element values returned by iterator it.
The maximum of the ordered element values returned by iterator it.
An iterator of pairs of corresponding elements returned from iterators it and jt.
An iterator of pairs of corresponding elements returned from iterators it and jt,
where the shorter iterator is extended to match the longer one by appending
elements xor y.
An iterator of pairs of elements returned from it with their indicies.
The iterator resulting from it by replacing r elements starting with i by the
patch iterator jt.
Comparison:
it sameElements jt
A test whether iterators it and jt return the same elements in the same order.
Note: At least one of it and jt will be at its end after this operation.
Strings:
it addString (b, start,
sep, end)
Adds a string to StringBuilder b that shows all elements returned
by it between separators sep enclosed in stringsstart and end. start,sep,
and end are all optional.
it mkString (start,
sep, end)
Converts the iterator to a string that shows all elements returned by it between
separators sep enclosed in stringsstart and end. start,sep, and end are all
optional.
Buffered iterators
Sometimes you want an iterator that can "look ahead" so that you can inspect the next element to be
returned without advancing past that element. Consider, for instance, the task to skip leading empty
strings from an iterator that returns a sequence of strings. You might be tempted to write something like
the following method:// This won't work
def skipEmptyWordsNOT(it: Iterator[String]) = {
while (it.next().isEmpty) {}
}
But looking at this code more closely, it's clear that this is wrong: the code will indeed skip leading
empty strings, but it will also advance it past the first non-empty string!
The solution to this problem is to use a buffered iterator, an instance of
trait BufferedIterator.BufferedIterator is a subtrait of Iterator, which provides one extra method, head.
Calling head on a buffered iterator will return its first element, but will not advance the iterator. Using a
buffered iterator, skipping empty words can be written like this:
def skipEmptyWords(it: BufferedIterator[String]) =
while (it.head.isEmpty) { it.next() }
Every iterator can be converted to a buffered iterator by calling its buffered method. Here's an example:
scala> val it = Iterator(1, 2, 3, 4)
it: Iterator[Int] = non-empty iterator
scala> val bit = it.buffered
bit: java.lang.Object with scala.collection.
BufferedIterator[Int] = non-empty iterator
scala> bit.head
res10: Int = 1
scala> bit.next()
res11: Int = 1
scala> bit.next()
res11: Int = 2
Note that calling head on the buffered iterator, bit, did not advance it. Therefore, the subsequent
call, bit.next(), returned again the same value as bit.head.
24.16 CREATING COLLECTIONS FROM SCRATCH
You have already seen syntax like List(1, 2, 3), which creates a list of three integers, andMap('A' -
> 1, 'C' -> 2), which creates a map with two bindings. This is actually a universal feature of Scala
collections. You can take any collection name and follow it by a list of elements in parentheses. The
result will be a new collection with the given elements. Here are some more examples:
Traversable()
List()
List(1.0, 2.0)
Vector(1.0, 2.0)
Iterator(1, 2, 3)
Set(dog, cat, bird)
HashSet(dog, cat, bird)
Map('a' -> 7, 'b' -> 0)
//
//
//
//
//
//
//
//
An empty traversable object
The empty list
A list with elements 1.0, 2.0
A vector with elements 1.0, 2.0
An iterator returning three integers.
A set of three animals
A hash set of the same animals
A map from characters to integers"Under the covers" each of the above lines is a call to the apply method of some object. For instance,
the third line above expands to:
List.apply(1.0, 2.0)
So this is a call to the apply method of the companion object of the List class. That method takes an
arbitrary number of arguments and constructs a list from them. Every collection class in the Scala
library has a companion object with such an apply method. It does not matter whether the collection
class represents a concrete implementation, like List, Stream, orVector, or whether it is an trait such
as Seq, Set, or Traversable. In the latter case, calling applywill produce some default implementation of
the trait. Here are some examples:
scala> List(1, 2, 3)
res17: List[Int] = List(1, 2, 3)
scala> Traversable(1, 2, 3)
res18: Traversable[Int] = List(1, 2, 3)
scala> mutable.Traversable(1, 2, 3)
res19: scala.collection.mutable.Traversable[Int] =
ArrayBuffer(1, 2, 3)
Besides apply, every collection companion object also defines a member empty, which returns an
empty collection. So instead of List() you could write List.empty, instead of Map(), Map.empty, and so
on.
Descendants of Seq traits also provide other factory operations in their companion objects. These are
summarized in Table 24.13. In short, there's:
concat, which concatenates an arbitrary number of traversables together,
fill and tabulate, which generate single or multi-dimensional sequences of given dimensions
initialized by some expression or tabulating function,
* range, which generates integer sequences with some constant step length, and
* iterate, which generates the sequence resulting from repeated application of a function to a start
element.
*
*
Factory methods for sequences
What it is
S.empty
S(x, y, z)
S.concat(xs, ys, zs)
S.fill(n)(e)
What it does
The empty sequence
A sequence consisting of elements x, y, and z
The sequence obtained by concatenating the elements of xs,ys, and zs
A sequence of length n where each element is computed by expression e
A sequence of sequences of dimension m x n where each element is computed by
S.fill(m, n)(e)
expression e (exists also in higher dimensions)
S.tabulate(n)(f)
A sequence of length n where the element at each index i is computed by f(i)
A sequence of sequences of dimension m x n where the element at each index (i, j)
S.tabulate(m, n)(f)
is computed by f(i, j) (exists also in higher dimensions)S.range(start, end)
S.range(start, end,
step)
S.iterate(x, n)(f)
The sequence of integers start ... end - 1
The sequence of integers starting with start and progressing by step increments up
to, and excluding, the endvalue
The sequence of length n with elements x, f(x), f(f(x)), ...
24.17 CONVERSIONS BETWEEN JAVA AND SCALA COLLECTIONS
Like Scala, Java has a rich collections library. There are many similarities between the two. For
instance, both libraries know iterators, iterables, sets, maps, and sequences. But there are also important
differences. In particular, the Scala libraries put much more emphasis on immutable collections, and
provide many more operations that transform a collection into a new one.
Sometimes you might need to convert from one collection framework to the other. For instance, you
might want to access to an existing Java collection, as if it were a Scala collection. Or you might want
to pass one of Scala's collections to a Java method that expects the Java counterpart. It is quite easy to
do this, because Scala offers implicit conversions between all the major collection types in
the JavaConversions object. In particular, you will find bidirectional conversions between the following
types:
Iterator
Iterator
Iterable
Iterable
mutable.Buffer
mutable.Set
mutable.Map
\null
\null
\null
\null
\null
\null
\null
java.util.Iterator
java.util.Enumeration
java.lang.Iterable
java.util.Collection
java.util.List
java.util.Set
java.util.Map
To enable these conversions, simply import like this:
scala> import collection.JavaConversions._
import collection.JavaConversions._
You have now automatic conversions between Scala collections and their corresponding Java
collections.
scala> import collection.mutable._
import collection.mutable._
scala> val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]
scala> val buf: Seq[Int] = jul
buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)
scala> val m: java.util.Map[String, Int] =
HashMap("abc" -> 1, "hello" -> 2)
m: java.util.Map[String,Int] = {hello=2, abc=1}
Internally, these conversion work by setting up a "wrapper" object that forwards all operations to the
underlying collection object. So collections are never copied when converting between Java and Scala.
An interesting property is that if you do a round-trip conversion from, say, a Java type to itscorresponding Scala type, and back to the same Java type, you end up with the identical collection
object you started with.
Some other common Scala collections exist that can also be converted to Java types, but for which no
corresponding conversion exists in the other direction. These are:
Seq
mutable.Seq
Set
Map
\null
\null
\null
\null
java.util.List
java.util.List
java.util.Set
java.util.Map
Because Java does not distinguish between mutable and immutable collections in their type, a
conversion from, say, collection.immutable.List will yield a java.util.List, on which all attempted
mutation operations will throw an UnsupportedOperationException. Here's an example:
scala> val jul: java.util.List[Int] = List(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]
scala> jul.add(7)
java.lang.UnsupportedOperationException
at java.util.AbstractList.add(AbstractList.java:131)

24.18 Висновок
==============
You've now seen how to use Scala's collection in great detail. Scala's collections take the approach of
giving you powerful building blocks rather than a number of ad hoc utility methods. Putting together
two or three such building blocks allows you to express an enormous number of useful computations.
This style of library is especially effective due to Scala having a light syntax for function literals, and
due to it providing many collection types that are persistent and immutable.
This chapter has shown collections from the point of view of a programmer using the collection library.
The next chapter will show you how the collections are built and how you can add your own collection
types.
