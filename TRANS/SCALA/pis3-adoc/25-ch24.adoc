include::headers.adoc[]

Глава 24
--------

Колекції: докладно
==================

Scala включає елегантну та потужну бібліотеку колекцій. Навіть якщо вважати, що API колекцій тонкий на перший погляд, зміни, які він може спровокувати в вашому стилі програмування можуть бути грунтовними. Досить часто це так, якби ви робили на вищому рівні з базовими будівельними блоками програми, що є цілими колекціями, ніж їх елементами. Цей новий стиль програмування потребує деякої адаптації. Нащастя, адаптації допомагють декілька милих властивостей Scala колекцій. Вони прості в використанні, стислі, безпечні, швидкі та універсальні.

* *Простота в використанні:* Невеликого словника з двадцяти до сорока методів, досить для вирішення більшості проблем колекцій в парі операцій. Намає потреби огортати вашу голову кругом складних циклічних структур або рекурсій. Стійкі колекції вільні від операцій з побічними ефектами, що означає, що вам не треба хвилюватись про випадкове руйнування існуючих колекцій новими даними. Взаємодію між ітераторами та оновленнями колекцій ліквідовано.

* *Стислість:* Ви можете досягти за допомогою одного слова те, що раніше займало один або декілька циклів. Ви можете виразити функціональні операції за допомогою легковажного синтаксису та без зусиль комбінувати операції так що результат відчувається як власна алгебра.

* *Безпечність:* Щоб зрозуміти це, треба мати досвід. Статична типізація та функціональна природа Scala колекцій означає, що переважна більшість помилок, які ви можете зробити, відловлюються під час компіляції. Причини цього в тому, що (1) операції колекцій самі часто використовуються, і таким чином, гарно протестовані. (2) використання операцій з колекціями робить входи та виходи явними, як параметри функції та результати. (3) Ці явні входи та виходи є предметом перевірки статичних типів. Підсумок всього цього в тому, що велика більшість хибних використань будуть заявляти про себе як помилки типів. Взагалі не є рідкістю мати програми з декількох сотень рядків, що роблять з першої спроби.

* *Швидкість:* Операції з колекціями настроєні і оптимізовані в бібліотеках. Як результат, використання колекцій типово досить ефективне. Ви можете бути в змозі зробити все трохи краще, через уважно налаштовані структури даних та операції, але ви також можете зробити все значно гірше, по ходу справи прийнявши якісь неоптимальні рішення з реалізації. Більше того, колекції були адаптовані до паралельної виконання на декількох ядрах. Паралельні колекції підтримують ті самі операції, що і послідовні так що не треба вивчати нові операції та переписувати код. Ви можете перетворити послідовну колекцію в паралельну, просто викликавши метод `par`.

* *Універсальність:* Колекції провадять ті самі операції на любому типі, коли це має сенс робити. Так що ви можете багато чого досягти з досить малим словником операцій. Наприклад, рядок концептуально є послідовністю символів. Відповідно, в Scala колекціях рядок підтримує всі операції послідовностей. Те саме дійсне і для масивів.

Ця глава поглиблено описує API для класів колекцій Scala з перспективи користувача. Ви вже бачили швидкий тур по бібліотеці колекцій в Главі 17. Ця глава запрошує вас в більш детальний тур, показуючи всі класи колекцій, і всі методи, що вони визначають так що вона включає все, що вам треба знати для використання Scala колекцій. Дивлячись наперед, Глава 25 буде сконцентрована на архитектурі та аспектах розширюваності бібліотеки, для людей, що реалізують нови типи колекцій.

24.1 Змінні та незмінні колекції
--------------------------------
Як ви вже знаєте, Scala колекції систематично відрізняють змінні та незмінні колекції. Змінні колекції можуть бути оновлені або розширені на місці. Це означає, що ви можете змінювати, додавати, або видаляти елементи колекції як побічний ефект. Незмінні колекції, для контрасту, ніколи не змінюються. Ви все ще маєте операції, що симулюють додавання, видалення або оновлення, але ці операції будуть в любому випадку повертати нову колекцію та залишати стару колекцію незмінною.

Всі класи колекцій знаходяться в пакунку `scala.collection`, або одному з його субпакунків: `mutable`, `immutable` та `generic`. Більшість класів колекцій, що потрібні клієнтському коду, існують в трьох варіантах, кожний з яких має різні характеристики з точки зору змінності. Три варіанти розміщені в пакунках `scala.collection`, `scala.collection.immutable` та `scala.collection.mutable`.

Колекція в пакунку `scala.collection.immutable` гарантовано буде незмінною для будь-кого. Така колекція ніколи не буде змінюватись після її створення. Таким чином, ви можете покладатись на факт, що отримуєте доступ до значення тієї самої колекції постійно, і в різних точках часу будете завжди мати колекцію з тими самими елементами.

Колекція в пакунку `scala.collection.mutable` знана що має деякі операції, що змінюють колекцію на місці. Ці операції дозволяють вам писати код для зміни колекції самотужки. Однак ви маєте бути уважним, щоб розуміти та захищатись від любих оновлень, що виконують інші частини кодової бази.

Колекція в пакунку `scala.collection` може бути або змінною, або незмінною. Наприклад,`scala.collection.IndexedSeq[T]` є супертрейтом обох, `scala.collection.immutable.IndexedSeq[T]` та її родички, `scala.collection.mutable.IndexedSeq[T]`. Загалом, кореневі колекції в пакунку `scala.collection` визначають той самий інтерфейс, що і незмінні колекції. І типово, змінні колекції в пакунку `scala.collection.mutable` додають деякі модифікації з побічним ефектом до цього незмінного інтерфейсу.

Різниця між кореневими колекціями та незмінними колекціями в тому, що клієнти назмінних колекцій мають гарантію, що ніхто не може змінити колекцію, коли як клієнти кореневих колекцій знають тільки, що вони самі не можуть змінити колекцію. Навіть зважаючи, що статичний тип такої колекції не провадить операцій для модифікації колекції, все ще може бути можливим, щоб тип часу виконання був змінною колекцією, що може бути змінена іншими клієнтами.

По замовчанню Scala завжди обирає незмінні колекції. Наприклад, якщо ви просто пишете `Set` без жодного префіксу, або без імпорту будь-чого, ви отримаєте незмінну множину, і якщо ви напишете `Iterable`, ви отримаєте незмінне ітерабельне, оскільки ці прив'язки по замовчанню імпортуються з пакунка `scala`. Щоб отримати змінні версії по замовчанню, вам треба написати явно `collection.mutable.Set`, або `collection.mutable.Iterable`.

Останній пакунок в ієрархії колекцій є `collection.generic`. Цей пакунок містить будівельні блоки для реалізації колекцій. Типово, класи колекцій відкладають реалізації деяких зі своїх операцій до класів в `generic`. З іншого боку, щоденні користувачі фреймворку колекцій мають потребу посилатись на класи в `generic` тільки за виключних обставин.

Ієрархія колекцій.
~~~~~~~~~~~~~~~~~~
----
Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4
----            

24.2 Узгодженість колекцій
--------------------------
Найбільш важливі класи колекцій показані на Малюнку 24.1. Є досить загального, що поділяють ці класи. Наприклад, кожний різновид колекції може бути створений за однаковим уніформним синтаксисом, записуючи ім'я класу колекції, за яким ідуть його елементи:
[source,scala]
----
Traversable(1, 2, 3)
Iterable("x", "y", "z")
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(Color.Red, Color.Green, Color.Blue)
SortedSet("hello", "world")
Buffer(x, y, z)
IndexedSeq(1.0, 2.0)
LinearSeq(a, b, c)
----
Той самий принцип також стосується специфічних реалізацій колекцій:
[source,scala]
----
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)
----
Метод `toString` для всіх колекцій продукує вивід, записаний як вище, з іменем типу, за яким в дужках ідуть елементи колекції. Всі колекції підтримують API, що провадить `Traversable`, але їх методи всі повертають їх власний клас, скоріше ніж кореневий клас  `Traversable`. Наприклад, метод `map` на `List` має тип повернення `List`, тоді як метод `map` на `Set` має тип повернення `Set`. Таким чином, статичний тип повернення ціх методів досить точний:
[source,scala]
----
scala> List(1, 2, 3) map (_ + 1)
res0: List[Int] = List(2, 3, 4)

scala> Set(1, 2, 3) map (_ * 2)
res1: scala.collection.immutable.Set[Int] = Set(2, 4, 6)
----
Еквівалентність також організована одноманітно для всіх класів колекцій; більше про це в Розділі 24.13.

Більшість класів на Малюнку 24.1 існують в трьох варіантах: `root`, `mutable` та `immutable`. Одне виключення є трейт `Buffer`, що існує тільки як змінна колекція.

В залишку цієї глави ми будемо переглядати ці класи один за одним.

24.3 Трейт `Traversable`
------------------------
На вершині ієрархії колекцій стоїть трейт `Traversable` (_прохідний_). Його єдина операція є `foreach`:
[source,scala]
----
def foreach[U](f: Elem => U)
----
Класам колекцій, що реалізують `Traversable`, просто потрібно визначити цей метод; всі інші методи можуть бути наслідувані від `Traversable`.

Метод `foreach` призначений для обходу всіх елементів колекції та застосування наданої операції `f` до кожного елементу. Тип операції `Elem => U`, де `Elem` є типом елементів колекції та `U` є довільним типом результату. Виклик `f` робиться тільки заради побічного ефекту; фактично, любий результат функції `f` буде відкинутий `foreach`.

`Traversable` також визначає багато суцільних методів, всі вони перелічені в Таблиці 24.1. Ці методи підпадають в такі категорії:

* *Додавання* `++`, що додає два прохідних разом, або додає всі елементи ітератора до прохідного.

* *Операції відображення* `map`, `flatMap` та `collect`, що продукують нову колекцію через застосування деякої функції до елементів колекції.

* *Перетворення* `toIndexedSeq`, `toIterable`, `toStream`, `toArray`, `toList`, `toSeq`, `toSet` та `toMap`, що повертають колекцію `Traversable` в більш специфічну колекцію. Всі ці перетворення повертають об'єкт отримувача, якщо він вже відповідає бажаному типу колекції. Наприклад, застосування `toList` до списку буде повертати сам список.

* *Операції копіювання* `copyToBuffer` та `copyToArray`. Як кажуть їх імена, вони копіюють елементи колекції до буфера або масива, відповідно.

* *Операції розміру* `isEmpty`, `nonEmpty`, `size` та `hasDefiniteSize`. Колекції, що є прохідними, можуть бути скінченими та нескінченими. Прикладом нескінченої прохідної колекції є потік натуральних чисел `Stream.from(0)`. Метод `hasDefiniteSize` вказує, що колекція, можливо, нескінчена. Якщо він повертає `false`, колекція може бути нескінченою, і в цьому випадку `size` буде видавати помилку або не повернеться.

* *Операції отримання елемента* `head`, `last`, `headOption`, `lastOption` та `find`. Вони обирають перший або останній елемент колекції, або інакше перший елемент, що задовільняє умові. Однак зазначте, що не всі колекції мають гарно визначення значення того, що значить "перший" та "останній". Наприклад, хеш множина може зберігати елементи відповідно до їх хеш ключів, що можуть змінюватись від запуску до запуску. В цьому випадку "перший" елемент хеш набору також може бути різним для разних запусків програм. Колекція є впорядкована, якщо вона завжди видає свої елементи в тому самому порядку. Більшість колекцій впорядковані, але деякі (такі як хеш множини) ні — відкидання впорядкованості дає трохи додаткової ефективності. Порядок часто є основою для отримання повторюваних тестів та допомагає в зневадженні. Ось чому колекції Scala провадять впорядковані альтернативи для всіх типів колекцій. Наприклад, впорядкована альтернатива для `HashSet` є `LinkedHashSet`.

* *Операції отримання субколекцій* `takeWhile`, `tail`, `init`, `slice`, `take`, `drop`, `filter`, `dropWhile`, `filterNot`, `withFilter`. Всі вони повертають деяку субколекцію, що ідентифікується диапазоном індексів або предикатом.

* *Операції підрозділу* `splitAt`, `span`, `partition` та `groupBy` підрозділяють елементи колекції на декілька субколекцій.

* *Перевірка елементів* `exists`, `forall` та `count` перевіряють елементи колекції за допомогою наданого предикату.

* *Згортки* `foldLeft`, `foldRight`, `/:`, `:\`, `reduceLeft`, `reduceRight` застосовують двомісні операції до послідовних елементів.

* *Особливі згортки* `sum`, `product`, `min`, `max` роблять з колекціями специфічних типів (числові або порівнювані).

* *Рядкові операції* `mkString`, `addString`, `stringPrefix` провадять альтернативні шляхи перетворення колекції на рядок.

* *Операції переглядів* складаються з двох перевантажених варіантів метода `view`. Перегляд є колекція, що обчислюється ліниво. Ви пізнаєте більше про перегляди в Розділі 24.14.

[caption="Операції трейта Traversable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|*Абстрактний метод:*
|xs foreach f|Виконує функцію `f` для кожного елементу `xs`.
2+|*Додавання:*
|xs ++ ys|Колекція, що складається з елементів обох, `xs` та `ys`.  `ys` є колекцією `TraversableOnce`, тобто або `Traversable`, або `Iterator`.
2+|*Мапи:*
|xs map f|Колекція, отримана від застосування функції `f` до кожного елемента в `xs`.
|xs flatMap f|Колекція, отримана від застосування функції `f` від значень-колекції до кожного елементу в `xs` та конкатенації результатів.
|xs collect f|Колекція, отримана від застосування часткової функції `f` до кожного елементу в `xs`, для яких вона визначена та накопичення результатів.
2+|*Перетворення:*
|xs.toArray|Конвертує колекцію в масив.
|xs.toList|Конвертує колекцію в список.
|xs.toIterable|Конвертує колекцію в Iterable.
|xs.toSeq|Конвертує колекцію в послідовність.
|xs.toIndexedSeq|Конвертує колекцію в індексовану послідовність.
|xs.toStream|Конвертує колекцію в потік (ліниво обчислювана послідовність).
|xs.toSet|Конвертує колекцію в множину.
|xs.toMap|Конвертує колекцію пар ключ/значення в мапу.
2+|*Копіювання:*
|xs copyToBuffer buf|Копіює всі елементи колекції в буфер `buf`.
|xs copyToArray(arr, s, len)|Копіює щонайбільше `len` елементів `arr`, починаючи з індексу `s`. Два останні аргументи опціональні. 
2+|*Інформація про розмір:*
|xs.isEmpty|Перевіряє, чи колекція порожня.
|xs.nonEmpty|Перевіряє, чи колекція містить елементи.
|xs.size|Число елементів в колекції.
|xs.hasDefiniteSize|True, якщо відомо, що xs має фіксований розмір.
2+|*Отримання елементів:*
|xs.head|Перший елемент колекції (або деякий елемент, якщо порядок не визначений).
|xs.headOption|Перший елемент `xs` в опціональному значенні, або `None`, якщо `xs` порожнє.
|xs.last|Останній елемент колекції (або деякий елемент, якщо порядок не визначений).
|xs.lastOption|Останній елемент `xs` в опціональному значенні, або `None`, якщо `xs` порожнє.
|xs find p|Опція, яка містить перший елемент в `xs`, що задовільняє `p`, або `None`, якщо жодний елемент не підійде.
2+|*Субколекції:*
|xs.tail|Залишок колекції, за винятком `xs.head`.
|xs.init|Залишок колекції, за винятком `xs.last`.
|xs slice (from, to)|Колекція, що складається з елементів `xs` в деякому диапазоні індексів (від `from` до `to`, виключно).
|xs take n|Колекція, що складається з перших `n` елементів `xs` (або деякі довільні `n` елементів, якщо порядок не визначений).
|xs drop n|Залишок колекції, за винятком `xs take n`.
|xs takeWhile p|Найдовший префікс елементів в колекції, що задовільняють `p`.
|xs dropWhile p|Колекція без найдовшого префіксу елементів, всі з яких задовільняють `p`.
|xs filter p|Колекція, що складається з тих елементів `xs`, що задовільняють предикату `p`.
|xs withFilter p|Не-строгий фільтр для цієї колекції. Всі операції на отриманому фільтрі будуть застосовані тільки для тих елементів `xs`, для яких мова `p` є `true`.
|xs filterNot p|Колекція, що складається з тих елементів `xs`, що не задовільняють предикатові `p`.
2+|*Суброзподіл:*
|xs splitAt n|Розділяє `xs` в позициї `n`, даючи пару колекцій (`xs take n`, `xs drop n`).
|xs span p|Розділяє `xs` відповідно до предикату, даючи пару колекцій (`xs takeWhile p`, `xs.dropWhile p`).
|xs partition p|Розділяє `xs` на пару колекцій; одна з елементами, що задовільняють предикату `p`, інша з елементами, що ні, даючи пару колекцій(`xs filter p`, `xs.filterNot p`).
|xs groupBy f|Розділяє `xs` на мапу колекцій, відповідно до функції дескреминатору `f`.
2+|*Умови до елементів:*
|xs forall p|Логічне, що визначає, чи предикат `p` дотримується до всіх елементів `xs`.
|xs exists p|Логічне, що вказує, чи предикат `p` дотримується до деякого елемента в `xs`.
|xs count p|Число елементів в `xs`, що задовільняють предикату `p`.
2+|*Згортки:*
|(z /: xs)(op)|Застосовує двомісну операцію `op` між послідовними елементами `xs`, ідучи зліва направо, починаючи з `z`.
|(xs :\ z)(op)|Застосовує двомісну операцію `op` між послідовними елементами `xs`, ідучи зправа наліво, починаючи з `z`.
|xs.foldLeft(z)(op)|Те саме, що і `(z /: xs)(op)`.
|xs.foldRight(z)(op)|Те саме, що і `(xs :\ z)(op)`.
|xs reduceLeft op|Застосовує двомісну операцію `op` між послідовними елементами непорожньої колекції `xs`, ідучи зліва направо.
|xs reduceRight op|Застосовує двомісну операцію `op` між послідовними елементами непорожньої колекції `xs`, ідучи зправа наліво.
2+|*Особливі згортки:*
|xs.sum|Сума числових значень елементів колекції `xs`.
|xs.product|Добуток числових значень елементів колекції `xs`.
|xs.min|Мінімум впорядкованих значень елементів колекції `xs`.
|xs.max|Максімум впорядкованих значень елементів колекції `xs`.
2+|*Рядки:*
|xs addString (b, start, sep, end)|Додає рядок до `StringBuilder` `b`, що показує всі елементи `xs`, розділені роздільниками `sep` та оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональні.
|xs mkString (start, sep, end)|Конвертує колекцію на рядок, що показує всі елементи `xs` між роздільниками `sep` та оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональні.
|xs.stringPrefix|The collection name at the beginning of the string returned from xs.toString.
2+|*Перегляди:*
|xs.view|Продукує перегляд xs.
|xs view (from, to)|Продукує перегляд, що представляє елементи в деякому диапазоні індексів `xs`. 
|===

24.4 Трейт Iterable
===================
Наступний трейт зверху на Малюнку 24.1 є `Iterable`. Всі методи в цьому трейті визначені в термінах абстрактного метода `iterator`, що видає елементи колекції один за одним. Абстрактний метод `foreach`, наслідуваний від трейту `Traversable`, реалізований в `Iterable` в термінах `iterator`. Ось справжня реалізація:
[source,scala]
----
def foreach[U](f: Elem => U): Unit = {
  val it = iterator
  while (it.hasNext) f(it.next())
}
----
Лише кілька субкласів `Iterable` перекривають цю стандартну реалізацію `foreach` в `Iterable`, оскільки вони можуть провадити більш ефективну реалізацію. Пам'ятайте, що `foreach` є основою для реалізації всіх операцій в `Traversable` так що продуктивність важлива.

Ще два метода існують в `Iterable`, що повертають ітератори: `grouped` та `sliding`. Однак ці ітератори не повертають поодинокі елементи, але цілі субпослідовності елементів оригінальної колекції. Максимальний розмір ціх послідовностей надається як аргумент до ціх методів. Метод `grouped` розбиває свої елементи на інкрементальні пакунки, тоді як `sliding` дає ковзаюче вікно по елементах. Різниця між двома стане яснішою при погляді на наступні взаємодії в інтерпретаторі:
[source,scala]
----
scala> val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)

scala> val git = xs grouped 3
git: Iterator[List[Int]] = non-empty iterator

scala> git.next()
res2: List[Int] = List(1, 2, 3)

scala> git.next()
res3: List[Int] = List(4, 5)

scala> val sit = xs sliding 3
sit: Iterator[List[Int]] = non-empty iterator

scala> sit.next()
res4: List[Int] = List(1, 2, 3)

scala> sit.next()
res5: List[Int] = List(2, 3, 4)

scala> sit.next()
res6: List[Int] = List(3, 4, 5)
----
Трейт `Iterable` також додає деякі інші методи до `Traversable`, що можуть бути ефективно реалізовані тільки за наявності ітератора. Вони підсумовані в Таблиці 24.2:

[caption="Операції трейта Iterable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|*Абстрактний метод:*
|iterator|Ітератор, що видає кожний елемент в `xs`, в тому самому порядку, як `foreach` проходить по елементах
2+|*Інші ітератори:* 
|xs grouped size|Ітератор, що видає "частки" колекції фіксованого розміру
|xs sliding size|Ітератор, що видає ковзне вікно фіксованого розміру з елементів колекції
2+|*Субколекції:* 
|xs takeRight n|Колекція, що складається з останніх `n` елементів `xs` (або довільні `n` елементів, якщо порядок не визначений)
|xs dropRight n|Залишок колекції, за винятком `xs takeRight n`
2+|*Поєднувачі:*
|xs zip ys|Ітерабельне з пар відповідних елементів з `xs` та `ys`
|xs zipAll (ys, x, y)|Ітерабельне з пар відповідних елементів з `xs` та `ys`, де коротша послідовність розширюється, щоб співпадати до довшої, через додавання елементів `x` або `y`
|xs.zipWithIndex|Ітерабельне з пар елементів `xs` разом з їх індексами
2+|*Порівняння:*
|xs sameElements ys|Перевіряє, чи `xs` та `ys` містять ті самі елементи в тому ж порядку
|===

Чому мати обоє, `Traversable` та `Iterable`?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ви можете здивуватись, для чого додатковий трейт `Traversable` над `Iterable`. Чи не могли б зробити все з ітератором? То яка ідея мати більш абстрактний трейт, що визначає свої методи в термінах `foreach` замість `iterator`? Одна причина мати `Traversable` в тому, що іноді простіше або більш ефективно провадити реалізацію для `foreach`, ніж провадити реалізацію ітератора. Ось простий приклад. Скажімо, ви бажаєте ієрархію класів для бінарних дерев, що мають цілі елементи на листках. Ви можете розробиби цю ієрархію таким чином:
[source,scala]
----
sealed abstract class Tree
case class Branch(left: Tree, right: Tree) extends Tree
case class Node(elem: Int) extends Tree
----
Тепер вважатимемо, ви бажаєте зробити дерева перехідними. Щоб зробити це, треба щоб `Tree` наслідував від `Traversable[Int]` та визначав метод `foreach`, ось так:
[source,scala]
----
sealed abstract class Tree extends Traversable[Int] {
  def foreach[U](f: Int => U) = this match {
    case Node(elem) => f(elem)
    case Branch(l, r) => l foreach f; r foreach f
  }
}
----
Це не дуже складно, і це також дуже ефективно — перехід по збалансованому дереву пропорційно до числа елементів в дереві. Щоб побачити це, уявімо, що збалансоване дерево з `N` листками буде мати `N - 1` внутрішніх листків класу `Branch`. Так що загальна кількість кроків для обходу дерева є `N + N - 1`.

Тепер порівняйте це з робленням дерев ітерабельними. Щоб зробити це, робимо `Tree` походячим від `Iterable[Int]` та визначаємо метод `iterator` ось так:
[source,scala]
----
sealed abstract class Tree extends Iterable[Int] {
  def iterator: Iterator[Int] = this match {
    case Node(elem) => Iterator.single(elem)
    case Branch(l, r) => l.iterator ++ r.iterator
  }
}
----
На перший погляд це виглядає не складніше, ніж рішення `foreach`. Однак є проблема ефективності, що стосується реалізації метода конкатенації ітератора, `++`. Кожного разу,коли продукується елемент конкатенованим ітератором, як в `l.iterator ++ r.iterator`, обчислення потребує слідувати одному непрямому переходу, щоб отримати вірний ітератор (`l.iterator` або `r.iterator`). Загалом це робить `log(N)` перенаправлень, щоб отримати листок збалансованого дерева з `N` leaves. Так що ціна відвідування всіх елементів дерева становить від близько `2N` для метода обходу `foreach`, до `Nlog(N)` для проходу за допомогою ітератору. Якщо дерево має мільйон елементів, це означає близько двох мільйонів кроків для `foreach`, і біля двадцяти (?) мільйонів кроків для `iterator`. Так що рішення `foreach` має явну перевагу.

Субкатегорії Iterable
~~~~~~~~~~~~~~~~~~~~~
В ієрархії наслідування нижче `Iterable` ви знайдете три трейти: `Seq`, `Set` та `Map`. Загальний аспект ціх трьох трейтів в тому, що всі вони реалізують трейт `PartialFunction`,footnote:[Часткові функції були описані в Розділі 15.7.] з його методами `apply` та `isDefinedAt`. Однак спосіб, в який кожний трейт реалізує `PartialFunction`, відрізняється.

Для послідовностей `apply` є позиційне індексування, де елементи завжди пронумеровані від `0`. Тобто, `Seq(1, 2, 3)(1) == 2`. Для множин `apply` є перевіркою належності. Наприклад, `Set('a', 'b', 'c') ('b') == true`, тоді як `Set()('a') == false`. Нарешті, для мап `apply` є вибір. Наприклад, `Map('a' - > 1, 'b' -> 10, 'c' -> 100)('b') == 10`.

В наступних трьох розділах ми пояснимо кожний з трьох типів колекцій більш детально.

24.5 Трейти послідовностей `Seq`, `IndexedSeq`, `LinearSeq`
-----------------------------------------------------------
Трейт `Seq` представляє послідовності. Послідовність різновид ітерабельного, що має довжину та чиї елементи мають фіксовані індексовані позиції, починаючи від 0. Операції над послідовностями, підсумовані на Малюнку 24.3, підпадають в наступні категорії:

* *Операції індексування та довжини* `apply`, `isDefinedAt`, `length`, `indices` та `lengthCompare`. Для `Seq` операція `apply` означає індексування; таким чином послідовність типу `Seq[T]` є частковою функцією, що приймає аргумент `Int` (індекс) та видає елемент послідовності типу `T`. Іншими словами, `Seq[T]` розширює `PartialFunction[Int, T]`. Елементи послідовності індексовані від нуля до довжини послідовності мінус один. Метод `length` на послідовностях є псевдонимом метода `size` на загальних колекціях. Метод `lengthCompare` дозволяє вам порівнювати довжину двох послідовностей, навіть якщо одна з послідовностей має безкінечну довжину.

* *Операції пошуку індексу* `indexOf`, `lastIndexOf`, `indexOfSlice`, `lastIndexOfSlice`,`indexWhere`, `lastIndexWhere`, `segmentLength` та `prefixLength` повертають індекс елементу, рівному до заданого значення або співпадаючий з деяким предикатом.

* *Операції додавання* `+:`, `:+` та `padTo`, повертають нову послідовність, отриману від додавання елементів зпереду або з кінця послідовності.

* *Операції оновлення* `updated` та `patch`, що повертають нову послідовність, отриману від заміни деяких елементів оригінальної послідовності.

* *Операції сортування* `sorted`, `sortWith` та `sortBy` сортують елементи послідовності відповідно до різних критеріїв.

* *Операції обертання* `reverse`, `reverseIterator` та `reverseMap` видають або обробляють елементи послідовності в зворотньому порядку, від останнього до першого.

* *Операції порівняння* `startsWith`, `endsWith`, `contains`, `corresponds` та `containsSlice` співвідносить дві послідовності або шукає елемент в послідовності.

* *Множинні операції* `intersect`, `diff`, `union` та `distinct` виконують множино-подібні операції на елементах двох послідовностей, або видаляють дублікати.

Якщо послідовність змінна, вона пропонує додатковий метод з побічним ефектом `update`, що дозволяє оновлювати елементи. Згадайте з Глави 3, що синтаксис як `seq(idx) = elem` є просто скороченням для `seq.update(idx, elem)`. Зауважте різницю між `update` та `updated`. Метод `update` змінює елемент послідовності на місці та доступний тільки для змінних послідовностей. Метод `updated` доступний для всіх послідовностей та завжди повертає нову послідовність, замість модифікації оригіналу.

[caption="Операції трейта Seq"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Індексування та довжина:
|xs(i)|(або, розписано,`xs apply i`) Елемент `xs` за індексом `i`.
|xs isDefinedAt i|Перевіряє, чи `i` міститься в `xs.indices`.
|xs.length|Довжина послідовності (те саме, що і `size`).
|xs.lengthCompare ys|Повертає `-1`, якщо `xs` коротше за `ys`, `+1` якщо довше та `0` якщо вони мають рівну довжину. Робить, навіть якщо послідовності безкінечні.
|xs.indices|Диапазон індексів `xs`, що простягається від `0` до `xs.length - 1`. 
2+|Індексний пошук:
|xs indexOf x|Індекс першого елементу в `xs` рівному `x` (існують декілька варіантів).
|xs lastIndexOf x|Індекс останнього елементу в `xs` рівному `x` (існують декілька варіантів).
|xs indexOfSlice ys|Перший індекс `xs` такий, що наступні елементи починаючи з цього індексу формують послідовність `ys`.
|xs lastIndexOfSlice ys|Останній індекс `xs` такий, що наступні елементи починаючи з цього індексу формують послідовність `ys`.
|xs indexWhere p|Індекс першого елементу `xs`, задовільняє `p` (існують декілька варіантів).
|xs segmentLength (p, i)| Довжина найдовшого неперериваного сегменту елементів `xs`, починаючи з `xs(i)`, всі з яких задовільняють предикату `p`.
|xs prefixLength p|Довжина найдовшого префіксу з елементів `xs`, всі з яких задовільняють предикату `p`.
2+|Додавання:
|x +: xs|Нова послідовність, що складається з `x` перед `xs`.
|xs :+ x|Нова послідовність, що складається з `x` після `xs`.
|xs padTo (len, x)|Послідовність, що утворюється як результат від додавання значення `x` до `xs`, доки не буде досяжена довжина `len`.
2+|Оновлення:
|xs patch (i, ys, r)|Послідовність як результат від заміни `r` елементів `xs`, починаючи з `i` на латку `ys`.
|xs updated (i, x)|Копія `xs`, з елементом з індексом `i`, заміненим на `x`.
|xs(i) = x|(або, розписане, `xs.update(i, x)`, доступне тільки для` mutable.Seq`). Зміна елементу `xs` по індексу `i` на `y`.
2+|Сортування:
|xs.sorted|Нова послідовність, отримана від сортування елементів  `xs` з використанням стандартного впорядкування типу елементів `xs`.
|xs sortWith lessThan|Нова послідовність, отримана від сортування елементів `xs`, використовуючи `lessThan` як операції порівняння.
|xs sortBy f|Нова послідовність, отримана від сортування елементів `xs`. Порівняння між двома елементами обробляється через відображення двох елементів функцією `f` над обома та порівняння результатів.
2+|Обернення:
|xs.reverse|Послідовність з елементами `xs` в зворотньому порядку.
|xs.reverseIterator|Ітератор, що видає всі елементи `xs` в зворотньому порядку.
|xs reverseMap f|Послідовність, отримана від відображення `f` над елементами `xs` в зворотньому порядку.
2+|Порівняння:
|xs startsWith ys|Перевіряє, чи `xs` починається з послідовності `ys` (існують декілька варіантів).
|xs endsWith ys|Перевіряє, чи `xs` закінчується на `ys` (існують декілька варіантів).
|xs contains x|Перевіряє, чи `xs` має елемент, що дорівнює `x`.
|xs containsSlice ys|Перевіряє, чи `xs` має послідовність, що дорівнює `ys`.
|(xs corresponds ys)(p)|Перевіряє, чи відповідні елементи `xs` та `ys` задовільняють двомісному предикату `p`.
2+|Множинні операції:
|xs intersect ys|Множинний перетин послідовностей `xs` та `ys`, що зберігає порядок елементів в `xs`.
|xs diff ys|Множинна різниця послідовностей `xs` та `ys`, що зберігає порядок елементів в `xs`.
|xs union ys|Множинне об'єднання; те саме, що `xs ++ ys`.
|xs.distinct|Субпослідовність `xs`, що не містить дублікатів.
|===

Кожний трейт `Seq` має два субтрейти, `LinearSeq` та `IndexedSeq`. Вони не додають жодних нових операцій, але кожний пропонує різні характеристики продуктивності. Лінійна послідовність має ефективні операції `head` та `tail`, тоді як індексована послідовність має ефективні операції `apply`, `length` та (якщо `mutable`) `update`. `List` є часто використовувана лінійна послідовність, як і `Stream`. Дві часто використовувані індексовані послідовності є `Array` та `ArrayBuffer`. Клас `Vector` провадить цікавий компроміс між індексованим та лінійним доступом. Він має однаково ефективний сталий час індексного навантаження та сталий час лінійного доступу. Завдяки цьому вектори є гарною основою для шаблонів змішаного доступу, коли одночасно використовується індексний та лінійний доступи. Більше про вектори в Розділі 24.8.

Буфери
~~~~~~
Важлива суб-категорія змінних послідовностей є буфери. Буфери дозволяють не тільки оновлення існуючих елементів, але також вставки елементів, видалення елементів та ефективне додавання нових елементів в кінець буфера. Принципово нові методи, що підтримуються буферами, є `+=` та `++=` для додавання елементів в кінець та `+=:` і `++=:` для додавання зпереду, `insert` та `insertAll` для вставок елементів так само як `remove` та `-=` для видалення елементів. Ці These operations are summarized in Table 24.4.

Дві реалізації `Buffer` в загальному ужитку є `ListBuffer` та `ArrayBuffer`. Як підказує ім'я, `ListBuffer` підтримується `List` та підтримує ефективне перетворення його елементів `List`, тоді як  `ArrayBuffer` покладається на масив та може бути швидко перетворений на такий. Ви бачили проблиск реалізації `ListBuffer` в Розділі 22.2.

[caption="Операції трейта Buffer"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Додавання:
|buf += x|Додає елемент `x` до буфера `buf` та повертає самий `buf` як результат
|buf += (x, y, z)|Додає надані елементи до буфера
|buf ++= xs|Додає всі елементи в `xs` до буфера
|x +=: buf|Ставить елемент `x` в початок буфера
|xs ++=: buf|Ставить всі елементи `xs` в початок буфера
|buf insert (i, x)|Вставляє елемент `x` по індексу `i` в буфер
|buf insertAll (i, xs)|Вставляє всі елементи в `xs` по індексу `i` в буфер
2+|Видалення:
|buf -= x|Видаляє елемент `x` з буфера
|buf remove i|Видаляє елементпо індексу `i` з буфера
|buf remove (i, n)|Видаляє `n` елементів, починаючи з індексу `i`, з буфера
|buf trimStart n|Видаляє перші `n` елементів з буфера
|buf trimEnd n|Видаляє останні `n` елементів з буфера
|buf.clear()|Видаляє всі елементи з буфера
2+|Клонування:
|buf.clone|Новий буфер з тими самим елементами, що і `buf`
|===

24.6 Множини
------------
`Set` є `Iterable`, що не містить дублікатів елементів. Операції з множинами підсумовані в Таблиці 24.5 для `general` множин, і Таблиці 24.6 `mutable` множин. Вони підпадають під наступні категорії:

* *Перевірки* `contains`, `apply` та `subsetOf`. Метод `contains` вказує, чи множина містить наданий елемент. Метод `apply` для множини те саме, що і `contains` так що `set(elem)` відповідає до  `set contains elem`. Це означає, що множини можуть також використовуватись як функції перевірки, що повертають `true` для елементів, які вони містять. Наприклад:
[source,scala]
----
scala> val fruit = Set("apple", "orange", "peach", "banana")
fruit: scala.collection.immutable.Set[String] =
  Set(apple, orange, peach, banana)

scala> fruit("peach")
res7: Boolean = true

scala> fruit("potato")
res8: Boolean = false
----
* *Додавання* `+` and `++` додають до множини один або більше елементів, даючи нову множини в якості результату.

* *Видалення* `-` та `--` видаляють один або більше з множини, даючи нову множину.

* *Операції множин* для об'єднання, перетину та різниці. Ці операції існують в двох фломах: алгебраїчній та символічній. Алгебраїчні версії є `intersect`, `union` та `diff`, тоді як символічні версії `&`, `|` та `&~`. Метод `++`, який `Set` наслідує від `Traversable`, може розглядатись як ще один псевдоним для `union` або `|`, за винятком того, що `++` приймає аргумент `Traversable`, коли `union` та `|` приймають множини.

[caption="Операції трейта Set"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Перевірки:
|xs contains x|Перевіряє, чи `x` є елементом `xs`
|xs(x)|Те саме, що `xs contains x`
|xs subsetOf ys|Перевіряє, чи `xs` є підмножиною `ys`
2+|Додавання:
|xs + x|Множина, що містить всі елементи `xs` так само як `x`
|xs + (x, y, z)|Множина, що містить всі елементи `xs` так само як надані додаткові елементи
|xs ++ ys|Множина, що містить всі елементи `xs` так само, як всі елементи `ys`
2+|Видалення:
|xs - x|Множина, що містить всі елементи `xs`, за винятком `x`
|xs - (x, y, z)|Множина, що містить всі елементи `xs`, за винятком наданих елементів
|xs -- ys|Множина, що містить всі елементи `xs`, крім елементів в `ys`
|xs.empty|Порожня множина такого ж класу, що і `xs`
2+|Бінарні операції:
|xs & ys|Перетин множин `xs` та `ys`
|xs intersect ys|Те саме, що і `xs & ys`
|xs \| ys|Поєднання множин `xs` та `ys`
|xs union ys|Те саме, що і `xs | ys`
|xs &~ ys|Різниця множин `xs and ys`
|xs diff ys|Те саме, що і `xs &~ ys`
|===

Змінні множини мають методи, що додають, видаляють або оновлюють елементи, що підсумовані в Таблиці 24.6:

[caption="Операції трейта mutable.Set"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+"Додавання:
|xs += x|Додає елемент `x` до множини `xs` як побічний ефект та повератє сам `xs`
|xs += (x, y, z)|Додає надані елементи до множини як побічний ефект та повертає сам `xs`
|xs ++= ys|Додає всі елементи з `ys` до множини `xs` як побічний ефект та повертає сам `xs`
|xs add x|Додає елемент `x` до `xs` та повертає `true`, якщо `x` досі не був членом множини, `false` якщо він був там
2+|Видалення:
|xs -= x|Видаляє елемент `x` з множини `xs` як побічний ефект та повертає сам `xs`
|xs -= (x, y, z)|Видаляє надані елементи з множини `xs` як побічний ефект та повертає сам `xs`
|xs --= ys|Видаляє всі елементи в `ys` з множини `xs` як побічний ефект та повертає сам `xs`
|xs remove x|Видаляє `x` з `xs` та повертає `true`, якщо `x` до цього містився в множині, `false` якщо ні
|xs retain p|Залишає лише ті елементи в `xs`, що задовільняють предикату `p`
|xs.clear()|Видаляє всі елементи з `xs`
2+|Оновлення:
|xs(x) = b|(або, розписано, `xs.update(x, b)`) Якщо логічний аргумент `b` є `true`, додає `x` до `xs`, інакше видаляє `x` з `xs`
2+|Клонування:
|xs.clone|Нова змінна множина з тими ж елементами, що і `xs`
|===

Так само, як незмінні множини, змінні множини пропонують операції  `+` та `++` для додавання елементів та `-` та `--` для видалення елементів. Але вони рідше використовуються для змінних множин, оскікльки це включає копіювання множини. Ак більш ефективна альтернатива, змінні множини пропонують методи оновлення `+=` та `- =`. Операція `s += elem` додає `elem` до множини `s` в якості побічного ефекту та повертає змінену множину як результат. Подібно до цього, `s -= elem` видаляє `elem` з множини та повертає змінену множину як результат. Окрім `+=` та `-=` також існують масові операції `++=` та `--=`, що додають або видаляють всі елементи перехідного або ітератора.

Вибір імен методів, `+=` та `-=` означає, що дуже подібний код буде робити однаково, зі змінними та незмінними множинами. Зпочатку розглянемо наступний диалог в інтерпретаторі, що використовує незмінну множину `s`:
[source,scala]
----
scala> var s = Set(1, 2, 3)
s: scala.collection.immutable.Set[Int] = Set(1, 2, 3)

scala> s += 4; s -= 2

scala> s
res10: scala.collection.immutable.Set[Int] = Set(1, 3, 4)
----
В цьому прикладі ми використали `+=` та `-=` на `var` типу `immutable.Set`. Як було пояснено на Кроці 10 в Главі 3, а твердження як `s += 4` є скороченням для `s = s + 4`. Так що це викликає метод додавання `+` на множині `s` та потім присвоює результат назад до змінної `s`. Розглянемо тепер аналогічну взаємодію зі змінним набором:
[source,scala]
----
scala> val s = collection.mutable.Set(1, 2, 3)
s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)

scala> s += 4
res11: s.type = Set(1, 2, 3, 4)

scala> s -= 2
res12: s.type = Set(1, 3, 4)
----
The end effect is very similar to the previous interaction; we start with a Set(1, 2, 3) and end up with a Set(1, 3, 4). However, even though the statements look the same as before, they do something different. The s += 4 statement now invokes the += method on the mutable set values, changing the set in place. Likewise, the s -= 2 statement now invokes the -= method on the same set.

Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.

Mutable sets also provide add and remove as variants of += and -=. The difference is that add andremove return a boolean result indicating whether the operation had an effect on the set.

The current default implementation of a mutable set uses a hash table to store the set's elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as hash tries.footnote:[Hash tries are described in Section 24.8.]

A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.

24.7 Мапи
---------
Maps are Iterables of pairs of keys and values (also named mappings or associations). As explained in Section 21.4, Scala's Predef class offers an implicit conversion that lets you writekey -> value as an alternate syntax for the pair (key, value). Therefore, Map("x" -> 24, "y" -> 25, "z" -> 26) means exactly the same as Map(("x", 24), ("y", 25), ("z", 26)), but reads better.

The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets. Mutable maps additionally support the operations shown in Table 24.8. Map operations fall into the following categories:

* *Lookups* apply, get, getOrElse, contains, and isDefinedAt. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is: 
[source,scala]
----
def get(key): Option[Value]
----
The operation "m get key" tests whether the map contains an association for the given key. If so, it returns the associated value in a Some. If no key is defined in the map, get returns None. Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option. If the key is not defined in the map, an exception is raised.

* Additions and updates +, ++, and updated, which let you add new bindings to a map or change existing bindings.

* Removals - and --, which remove bindings from a map.

* Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map's keys and values separately in various forms.

* Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.

[caption="Операції трейта Map"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Пошук:
|ms get k|Значення, асоційоване з ключем `k` в мапі `ms`, як опція, або `None`, якщо не знайдене
|ms(k)|(або, розписане, `ms apply k`) Значення, асоційоване з ключем `k` в мапі `ms`, або закидає виключення, якщо не знайдене
|ms getOrElse (k, d)|Значення, асоційоване з ключем `k` в мапі `ms`,або значення по замовчанню `d`, якщо не знайдене
|ms contains k|Перевіряє, чи `ms` містить відображення для ключа `k`
|ms isDefinedAt k|Те саме, що і `contains`
2+|Додавання та оновлення:
|ms + (k -> v)|Мапа, що містить всі відображення `ms` так само, як і `gk -> v` ключа `k` на значення `v`
|ms + (k -> v, l -> w)|Мапа, що містить всі відображення `ms`, разом з наданими парами ключ/значення
|ms ++ kvs|Мапа, що містить всі відображення `ms` так само, як і пари ключ/значення з `kvs`
|ms updated (k, v)|Таке саме, що і `ms + (k -> v)`
2+|Видалення:
|ms - k|Мапа, що містить всі відображення з `ms`, за винятком любих відображень для ключа `k`
|ms - (k, l, m)|Мапа, що містить всі відображення `ms`, за винятком всіх відображень з наданими ключамі
|ms -- ks|Мапа, що містить всі відображення з `ms`, за винятком любих відображень з ключами в `ks`
2+|Субколекції:
|ms.keys|Ітерабельне, що містить любий ключ в `ms`
|ms.keySet|Множина, що містить кожний ключ в `ms`
|ms.keysIterator|Ітератор, що видає кожний ключ в `ms`
|ms.values|Ітерабельне, що містить кожне значення, асоційоване з ключем в `ms`
|ms.valuesIterator|Ітератор, що видає кожне значення, асоційоване з ключем в `ms`
2+|Перетворення:
|ms filterKeys p|Перегляд мапи, що містить тільки ті відображення, в яких ключ відповідає предикату `p`
|ms mapValues f|Перегляд мапи, отриманий від застосування функції `f` до кожного значення, асоційованого з ключем в `ms`
|===

[caption="Операції трейта mutable.Map"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Додавання та оновлення:
|ms(k) = v|(або, розписано, `ms.update(k, v)`) Додає відображення ключа `k` на значення `v` до мапи `ms` як побічний ефект, переписуючи любі попередні відображення `k`
|ms += (k -> v)|Додає відображення ключа `k` на значення `v` до мапи `ms` як побічний ефект та повертає сам `ms`
|ms += (k -> v, l -> w)|Додає надані відображення до `ms` як побічний ефект та повертає сам `ms`
|ms ++= kvs|Додає всі відображення в `kvs` до `ms` як побічний ефект та повертає сам `ms`
|ms put (k, v)|Додає відображення ключа `k` на значення `v` до `ms` та повертає любе значення, асоційоване до цього з `k`, як опцію
|ms getOrElseUpdate (k, d)|Якщо ключ `k` визначений в мапі `ms`, повертає його асоційоване значення. Інакше оновлює `ms` відображенням `k -> d` та повертає `d`
2+|Видалення:
|ms -= k|Видаляє відображення ключа `k` з `ms` як побічний ефект та повертає сам `ms`
|ms -= (k, l, m)|Видаляє відображення наданних ключів з `ms` як побічний ефект та повертає сам `ms`
|ms --= ks|Видаляє всі ключі в `ks` з `ms` як побічний ефект та повертає сам `ms`
|ms remove k|Видаляє любі відображення ключа `k` з `ms` та повертає любе значення, до цього асоційоване з `k`, як опцію
|ms retain p|Зберігає тільки ті відображення в `ms`, ключ яких задовільняє предикату `p`.
|ms.clear()|Видаляє всі відображення з `ms`
2+|Перетворення та клонування:
|ms transform f|Перетворює всі асоційовані значення в мапі `ms` функцією `f`
|ms.clone|Повертає нову змінну мапу з тими самими відображеннями, що і `ms`
|===

Операції додавання та видалення для мап повторюють такі самі для множин. Як і для множин, змінні мапи також підтримують неруйнівні операції додавання `+`, `-` та `updated`, але вони використовуються менш часто, оскільки вони включають копіювання змінної мапи. Замість цього, змінна мапа `m` звичайно оновлюється "на місці", використовуючи два варіанти, `m(key) = value` або `m += (key -> value)`. Також є варіант `m put (key, value)`, що повертає значення `Option`, що складається зі значення, до того асоційованого з ключем, або `None`, якщо ключ не існував в мапі до цього.

Метод `getOrElseUpdate` корисний для доступу до мап, що діють як кеші. Скажімо, ви маєте коштовне обчислення, що перемикається викликом функції `f`:
[source,scala]
----
scala> def f(x: String) = {
        println("taking my time."); Thread.sleep(100)
        x.reverse }
f: (x: String)String
----
Далі уявімо, що `f` не має побічних ефектів так що повторний виклик з тими ж аргументами буде завжди давати той самий результат. В такому випадку ви можете зберігти час, зберігаючи попередньо обчислені прив'язки аргументів та результати `f` в мапі та обчислювати результат `f`, якщо результат від аргументів ще не знаходиться там. Ви можете сказати, що мапа є кешем для обчислення функції `f`.
[source,scala]
----
scala> val cache = collection.mutable.Map[String, String]()
cache: scala.collection.mutable.Map[String,String] = Map()
----
Тепер ви можете створити більш ефективну кешовану версію фукнції `f`:
[source,scala]
----
scala> def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))
cachedF: (s: String)String

scala> cachedF("abc")
taking my time.
res16: String = cba

scala> cachedF("abc")
res17: String = cba
----
Зауважте, що другий аргумент `getOrElseUpdate` є "за ім'ям" так що обчислення `f("abc")` вище виконується тільки якщо `getOrElseUpdate` потрубує значення свого другого аргументу, що саме коли перший аргумент не знайдений в кеш мапі. Ви також можете реалізувати `cachedF` напряму, використовуючи базові операції з мапами, але щоб зробити це знадобиться більше кода:
[source,scala]
----
def cachedF(arg: String) = cache get arg match {
  case Some(result) => result
  case None =>
    val result = f(arg)
    cache(arg) = result
    result
}
----
24.8 Суцільні класи незмінних колекцій
--------------------------------------
Scala провадить багато класів суцільних незмінних колекцій, з яких ви можете вибрати. Вони відрізняються в трейтах, які вони реалізують (мапи, множини, послідовності), чи можуть вони бути нескінченими та швидкістю різних операцій. Ми почнемо з огляду найбільш загальних типів незмінних колекцій.

Списки
~~~~~~
Списки є скінчені незмінні послідовності. Вони провадять доступ за сталий час до свого першого елементу так само, як і до залишку списку та вони мають операцію сталого часу `cons` для додавання нового елемента напочатку списку. Багато інших операцій займають лінійний час. Дівіться Глави 16 та 22 для розширеної дискусії щодо списків.

Потоки
~~~~~~
Потік подібний до списків, за тим винятком, що його елементи обчислюються ліниво. Через це потік може бути безкінечно довгий. Тільки елементи, що запитані, будуть обчислені. В іншому потоки мають ті самі характеристики продуктивності, що і списки.

В той час, як списки будуються за допомогою оператора `::`, потоки будуються за допомогою подібно виглядаючого `#::`. Ось простий приклад потоку, що містить цілі `1`, `2` та `3`:
[source,scala]
----
scala> val str = 1 #:: 2 #:: 3 #:: Stream.empty
str: scala.collection.immutable.Stream[Int] = Stream(1, ?)
----
Голова цього потоку є `1` та хвіст має `2` та `3`. Однак хвіст тут не друкується, оскільки він все ще не обчислений! Потоки мають обчислюватись ліниво та метод `toString` для потоку досить уважний, щоб не змушувати до додаткового обчислення.

Нижче більш складний приклад. Він обчислює потік, що містить послідовність Фібоначчі, починаючи з наданих двох чисел. Послідовність Фібоначчі - це коли кожний елемент є сумою двох попередніх в послідовності:
[source,scala]
----
scala> def fibFrom(a: Int, b: Int): Stream[Int] =
          a #:: fibFrom(b, a + b)
fibFrom: (a: Int, b: Int)Stream[Int]
----
Ця функція оманливо проста. Перший елемент послідовності, вочевидь, `a` та залишок послідовності є послідовність Фібоначчі, починаючи з `b`, за яким іде `a + b`. Хитра частина є обчислення цієї послідовності без нескінченої рекурсії. Якщо функція використовує `::` замість `#::`, тоді кожний виклик до функції буде спричиняти інший виклик таким чином спричиняючи нескінчену рекурсію. Однак оскільки вона використовує `#::`, права частина не обчислюється, доки вона не стане потрібною.

Ось декілька перших елементів послідовності Фібоначчі, починаючи з двох елементів:
[source,scala]
----
scala> val fibs = fibFrom(1, 1).take(7)
fibs: scala.collection.immutable.Stream[Int] = Stream(1, ?)

scala> fibs.toList
res23: List[Int] = List(1, 1, 2, 3, 5, 8, 13)
----

Вектори
~~~~~~~
Списки дуже ефективні, коли алгоритм обробляє їх дбайливо, обробляючи тільки їх голови. Досутп, додавання та видалення тільки до голови списку забирає тільки сталий час, тоді як доступ або модифікація елементів в списку пізніше бере час лінійно відносно глибини списку.

Вектори є типом колекцій, що дають ефективний доступ до елементів після голови. Доступ до любого елементу вектора займає тільки "ефективно сталий час", як визначено нижче. Це більша константа, ніж для доступу до голови списка, або для читання елементу масиву, але, тим не менше, це константа. Як результат, алгоритми, що використовують вектори, не мають пильнувати щодо доступу тільки до голови послідовності. Вони можуть отримувати доступ та модифікувати елементи в довільних місцях, і таким чином, вони можуть бути значно зручніші до написання.

Вектори будуються та модифікуються так само, як інші послідовності:
[source,scala]
----
scala> val vec = scala.collection.immutable.Vector.empty
vec: scala.collection.immutable.Vector[Nothing] = Vector()

scala> val vec2 = vec :+ 1 :+ 2
vec2: scala.collection.immutable.Vector[Int] = Vector(1, 2)

scala> val vec3 = 100 +: vec2
vec3: scala.collection.immutable.Vector[Int]
  = Vector(100, 1, 2)

scala> vec3(0)
res24: Int = 100
----
Вектори представлені як широкі та мілкі дерева. Кожний вузол дерева містить до 32 елементів вектора, або містить до 32 інших вузлів дерева. Вектори до 32 елементів можуть бути представлені одним вузлом. Вектори до 32 * 32 = 1024 елементів можуть бути представлені з одним перенаправленям. Два стрибка від кореня дерева до фінального вузла елементу достатні для векторів до 2^15^ елементів, три стрибка для векторів 2^20^, чотири стрибка для векторів з 2^25^ елементами, і п'ять стрибкив для векторів до 2^30^ елементів. Так що для всіх векторів пристойного розміру вибір елементів включає до п'яти виборок примітивного масиву. Це те, що ми мали на увазі, коли писали, що доступ до елементу має "ефективно сталий час".

Вектори незмінні так що ви не зможете змінити елемент вектора на місці. Однак, з методом `updated` ви можете створити новий вектор, що відрізняється від наданого вектора тільки одним елементом:
[source,scala]
----
scala> val vec = Vector(1, 2, 3)
vec: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)

scala> vec updated (2, 4)
res25: scala.collection.immutable.Vector[Int] = Vector(1, 2, 4)

scala> vec
res26: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3)
----
Як показує останній рядок вище, виклик до `updated` не має ефекту на оригінальний вектор `vec`. Як і вибір, оновлення функціонального вектора також має "ефективно сталий час". Оновлення вектора всередині вектора може бути зроблене через копіювання вузла, що містить елемент, і кожного вузла, що вказує на нього, починаючи від кореня дерева. Це означає, що функціональне оновлення створює від одного до п'яти вузлів, кожний містить до 32 елементів або субдерев. Це, звичайно, більш коштовно, ніж оновлення на місці в змінному масиві, але все ще набагато дешевше, ніж копіювання цілого вектора.

Оскільки вектори влучають в гарний баланс між швидким довільними функціональними вибірками та швидкими довільними функціональними оновленнями, вони наразі є реалізацією по замовченню для незмінних індексованих послідовностей:
[source,scala]
----
scala> collection.immutable.IndexedSeq(1, 2, 3)
res27: scala.collection.immutable.IndexedSeq[Int]
  = Vector(1, 2, 3)Immutable stacks
----

Незмінні стеки
~~~~~~~~~~~~~~
Якщо вам треба послідовність останній-увійшов-перший-вийшов, ви можете використовувати `Stack`. Ви заштовхуєте елемент в стек за допомогою `push`, виштовуєте за допомогою `pop` та вибираєте зверху без видалення за допомогою `top`. Всі ці операції займають сталий час.

Ось деякі прості операції, що виконуються на стеку:
[source,scala]
----
scala> val stack = scala.collection.immutable.Stack.empty
stack: scala.collection.immutable.Stack[Nothing] = Stack()

scala> val hasOne = stack.push(1)
hasOne: scala.collection.immutable.Stack[Int] = Stack(1)

scala> stack
res28: scala.collection.immutable.Stack[Nothing] = Stack()

scala> hasOne.top
res29: Int = 1

scala> hasOne.pop
res30: scala.collection.immutable.Stack[Int] = Stack()
----
Незмінні стеки використовуються рідко в Scala програмах, оскільки їх функціональність повторює списки: `push` на незмінному стеку є те саме, що `::` на списку та `pop` на стеку те саме, що `tail` на списку.

Незмінні черги
~~~~~~~~~~~~~~
Черга така сама як стек, за виключенням що вона перший-війшов-перший-вийшов, ніж останній-війшов-перший-вийшов. Спрощена реалізація незмінних черг дискутувалась в Главі 19. Ось як ви можете створити порожню незмінну чергу:
[source,scala]
----
scala> val empty = scala.collection.immutable.Queue[Int]()
empty: scala.collection.immutable.Queue[Int] = Queue()
----
Ви можете додати елемент до незмінної черги за допомогою `enqueue`:
[source,scala]
----
scala> val has1 = empty.enqueue(1)
has1: scala.collection.immutable.Queue[Int] = Queue(1)
----
Щоб додати декілька елементів до черги, викличте `enqueue` з колекцією в якості аргумента:
[source,scala]
----
scala> val has123 = has1.enqueue(List(2, 3))
has123: scala.collection.immutable.Queue[Int] = Queue(1, 2,
3)
----
Щоб видалити елемент з голови черги, використовуйте `dequeue`:
[source,scala]
----
scala> val (element, has23) = has123.dequeue
element: Int = 1
has23: scala.collection.immutable.Queue[Int] = Queue(2, 3)
----
Зауважте, що `dequeue` повертає пару, що складається з видаленого елементу та залишку черги.

Диапазони
~~~~~~~~~
Диапазон є впорядкованою послідовністю цілих, що відстоять нарівно один від одного. Наприклад, `1, 2, 3` є диапазон, як і `5, 8, 11, 14`. Щоб створити диапазон в Scala, використовуйте попередньо визначені методи `to` та `by`. Ось деякі приклади:
[source,scala]
----
scala> 1 to 3
res31: scala.collection.immutable.Range.Inclusive
  = Range(1, 2, 3)

scala> 5 to 14 by 3
res32: scala.collection.immutable.Range = Range(5, 8, 11, 14)
----
Якщо ви бажаєте створити диапазон, який виключає свій верхній ліміт, використовуйте зручний метод `until` замість `to`:
[source,scala]
----
scala> 1 until 3
res33: scala.collection.immutable.Range = Range(1, 2)
----
Диапазони представлені в просторі констант, оскільки вони можуть бути визначені через всього три числа: початок, кінець та значення кроку. Завдяки цій репрезентації, більшість операцій з диапазонами екстремально швидкі.

Хеш дерева
~~~~~~~~~~
Хеш дерева (_tries_, або _тріз_),footnote:["Trie" походить від слова "retrieval" та вимовляються як _tree_ або _try_.] є стандартним шляхом для ефективної реалізації незмінних масивів та мап. Їх репрезентація подібна до векторів в тому, що вони також дерева, де кожний вузол має 32 елементи або 32 субдерева, але вибірка робиться на основі хеш кода. Наприклад, щоб знайти наданий ключ, ви використовуєте молодші п'ять біт хеш коду від ключа, щоб обрати перше піддерево, наступні п'ять біт для іншого субдерева, і так далі. Вибірка зупиняється, як тільки всі елементи, що містяться в вузлі, мають хеш коди, які відрізняються один від одного в бітах, що вже вибрані. Таким чином, не всі біти хеш коду обов'язково використовуються.

Хеш _тріз_ поцілюють добрий баланс між достатньо швидкими пошуками та досить ефективними функціональними вставками (`+`) та видаленнями (`-`). Ось чому вони служать основою для реалізації по замовчанню для незмінних мап та множин Scala. Фактично, Scala має подальшу оптимізацію для незмінних множин та мап, що мають меньше ніж п'ять елементів. Множини та мапи від одного до чотирьох елементів зберігаються як один об'єкт, що містить самі елементи (або пари ключ/значення в випадку мап) як поля. Порожня незмінна множина та порожня незмінна мапа є в кожному випадку об'єктом синглтона  — немає потреби дублювати сховище для них, оскільки порожня множина та порожня мапа будуть завжди залишатись порожніми.

Червоне-чорне дерева
~~~~~~~~~~~~~~~~~~~~
Дерева червоне-чорне є формою збалансованих дерев, коли деякі вузли відмічені як "червоні" та інші "чорні". Як любі збалансовані двійникові дерева, операції на них надійно завершуються за час, логірифмічний до розміру дерева.

Scala провадить реалізації множин та мап, що внутрішньо використовують красне-чорне. Ви отримуєте доступ до них під іменами `TreeSet` та `TreeMap`:
[source,scala]
----
scala> val set = collection.immutable.TreeSet.empty[Int]
set: scala.collection.immutable.TreeSet[Int] = TreeSet()

scala> set + 1 + 3 + 3
res34: scala.collection.immutable.TreeSet[Int] = TreeSet(1, 3)
----
Дерева червоне-чорне є також стандартною реалізацією `SortedSet` в Scala, оскільки вони провадять ефективний ітератор, що повертає всі елементи множини у впорядкованому вигляді.

Незмінні бітові множини
~~~~~~~~~~~~~~~~~~~~~~~
Бітова множина представляє колекцію малих цілих, як бітів більшого цілого. Наприклад, бітова множина, що містить 3, 2 та 0, буде представлене як ціле `1101` в бінарній системі, що є `13` десятичними.

Внутрішньо бітові множини використовують масив з 64-бітних `Long`. Перший `Long` в масиві є для цілих від 0 до 63, другий для від 64 до 127, і так далі. Таким чином, бітові множини дуже компактні, доки найдовше ціле в множині меньше ніж декілька сотен, або десь так.

Операції на бітових наборах дуже швидкі. Перевірка на включення займає сталий час. Додавання елемента до множини пропорційна до числа `Long` в масиві бітової множини, що типово мале число. Ось деякі прості приклади використання бітових множин:
[source,scala]
----
scala> val bits = scala.collection.immutable.BitSet.empty
bits: scala.collection.immutable.BitSet = BitSet()

scala> val moreBits = bits + 3 + 4 + 4
moreBits: scala.collection.immutable.BitSet = BitSet(3, 4)

scala> moreBits(3)
res35: Boolean = true

scala> moreBits(0)
res36: Boolean = false
----

Спискові мапи
~~~~~~~~~~~~~
Спискова мапа представляє мапу як пов'язаний список пар ключ-значення. Загалом, операції на спискових мапах мають ітерувати по цілому списку. Таким чином, операції на списковій мапі займають час лінійно до розміру мапи. Фактично, існує невелике застосування списковим мапам в Scala, оскільки стандартні незмінні мапи майже завжди швидші. Одна можлива різниця є, коли якщо мапа з якихось причин сконструйована в такий спосіб, що перші елементи обираються значно більш часто, ніж інші елементи.
[source,scala]
----
scala> val map = collection.immutable.ListMap(
1 -> "one", 2 -> "two")
map: scala.collection.immutable.ListMap[Int,String] = Map(1
-> one, 2 -> two)

scala> map(2)
res37: String = "two"
----

24.9 Суцільні класи змінних колекцій
------------------------------------
Тепер, коли ви бачили найбільш загально використовувані класи незмінних колекцій, що провадить Scala в своїй стандартній бібліотеці, поглянемо на класи змінних колекцій.

Буфери масивів
~~~~~~~~~~~~~~
Ви вже бачили буфери масивів в Розділі 17.1. Буфер масиву зберігає масив та розмір. Більшість операцій на буфері масивів має ту саму швидкість, що і для масивів, оскільки операції просто отримують доступ та модифікують підлеглий масив. Додатково, буфери масивів можуть ефективно додавати дані в кінець. Додавання елементу до буферу масиву триває амортизовано сталий час. Таким чином, буфери масивів корисні для ефективної побудови великих колекцій, коли нові елементи завжди додаються в кінець. Ось деякі приклади:
[source,scala]
----
scala> val buf = collection.mutable.ArrayBuffer.empty[Int]
buf: scala.collection.mutable.ArrayBuffer[Int]
  = ArrayBuffer()

scala> buf += 1
res38: buf.type = ArrayBuffer(1)

scala> buf += 10
res39: buf.type = ArrayBuffer(1, 10)

scala> buf.toArray
res40: Array[Int] = Array(1, 10)
----

Буфери списків
~~~~~~~~~~~~~~
Ви вже бачили буфери списків в Розділі 17.1. Буфери списків подібні до буферів масивів, за виключенням того, що вони внутрішньо використовують зв'язані списки замість масивів. Якщо ви плануєте конвертувати буфер на список, коли він буде побудований, використовуйте буфер списків замість буферу масивів. Ось приклад:footnote:[`buf.type`, що з'являється в відповідях інтерпретатора в цьому та деяких інших прикладах цього розділу є типом синглтона. Як буде пояснено в Розділі 29.6, `buf.type` означає, що змінна зберіагє в точності об'єкт, на який посилається `buf`.]
[source,scala]
----
scala> val buf = collection.mutable.ListBuffer.empty[Int]
buf: scala.collection.mutable.ListBuffer[Int]
  = ListBuffer()

scala> buf += 1
res41: buf.type = ListBuffer(1)

scala> buf += 10
res42: buf.type = ListBuffer(1, 10)

scala> buf.toList
res43: List[Int] = List(1, 10)
----

Побудовники рядків
~~~~~~~~~~~~~~~~~~~
Так само, як буфери масивів корисні для побудови масивів та буфери списків корисні для побудови списків, побудовник рядків корисний для побудови рядків. Побудовники рядків використовуються настільки загально, що вони завжди імпортуються в простір імен по замовчанню. Створюйте їх просто як `new StringBuilder`:
[source,scala]
----
scala> val buf = new StringBuilder
buf: StringBuilder =

scala> buf += 'a'
res44: buf.type = a

scala> buf ++= "bcdef"
res45: buf.type = abcdef

scala> buf.toString
res46: String = abcdef
----

Зв'язані списки
~~~~~~~~~~~~~~~
Зв'язані списки є змінні послідовності, що складаються з вузлів, що пов'язані вказівниками `next`. В більшості мов `null` може бути взятий як порожній зв'язаний список. Це не робить для Scala колекцій, оскільки навіть порожні послідовності мають підтримувати всі методи послідовностей. Зокрема, `LinkedList.empty.isEmpty` повинно повертати `true` та не закидати `NullPointerException`. Порожні зв'язані списки замість цього закодовані в особливий спосіб: їх поле `next` вказує назад до самого вузла.

Як їх незмінні колеги, зв'язані списки краще обробляються послідовно. На додаток зв'язані списки спрощують вставку елемента або зв'язаного списку в інший зв'язаний список.

Подвійно зв'язаний список
~~~~~~~~~~~~~~~~~~~~~~~~~
`DoubleLinkedLists` подібні до однозв'язаних списків, описаних в попередньому підрозділі, але крім `next` вони мають інше змінне поле, `prev`, що вказує на елемент перед поточним вузлом. Головна перевага цього додаткового посилання в тому, що це робить видалення елементу дуже швидким.

Змінні списки
~~~~~~~~~~~~~
`MutableList` складається з одного зв'язаного списку, разом з вказівником, що посилається на термінальний порожній вузол цього списку. Це робить додавання до списку операцією сталого часу, оскільки уникається подорожування по списку в пошуку термінального вузла. `MutableList` наразі є стандартною реалізацією `mutable.LinearSeq` в Scala.

Черги
~~~~~
Scala провадить змінні черги, на додаток до незмінних. Ви використовуєте змінні черги подібно до того, як використовуються незмінні, але замість `enqueue` ви використовуєте оператори `+=` та `++=` для додавання. Також на змінній черзі метод `dequeue` буде лише видаляти головний елемент з черги та повертати його. Ось приклад:
[source,scala]
----
scala> val queue = new scala.collection.mutable.Queue[String]
queue: scala.collection.mutable.Queue[String] = Queue()

scala> queue += "a"
res47: queue.type = Queue(a)

scala> queue ++= List("b", "c")
res48: queue.type = Queue(a, b, c)

scala> queueres49: scala.collection.mutable.Queue[String] = Queue(a, b, c)

scala> queue.dequeue
res50: String = a

scala> queue
res51: scala.collection.mutable.Queue[String] = Queue(b, c)
----

Послідовності масивів
~~~~~~~~~~~~~~~~~~~~~
Послідовності масивів є змінні послідовності фіксованого розміру, що зберігають свої елементи всередині як `Array[AnyRef]`. Вони реалізовані в Scala як клас `ArraySeq`. Ви можете типово використовувати `ArraySeq`, якщо ви бажаєте масив заради його характеристик продуктивності, але ви також бажаєте створити загальні примірники послідовності, коли ви не знаєте тип елементів, і не маєте `ClassTag`, щоб запровадити під час виконання. Скоро ви дізнаєтесь про ці проблеми в Розділі 24.10.

Стеки
~~~~~
Ви бачили незмінні стеки раніше. Також є змінна версія. Це робить точно так саме, як і незмінна версія, за винятком того, що зміни відбуваються на місці. Ось приклад:
[source,scala]
----
scala> val stack = new scala.collection.mutable.Stack[Int]
stack: scala.collection.mutable.Stack[Int] = Stack()

scala> stack.push(1)
res52: stack.type = Stack(1)

scala> stack
res53: scala.collection.mutable.Stack[Int] = Stack(1)

scala> stack.push(2)
res54: stack.type = Stack(2, 1)

scala> stack
res55: scala.collection.mutable.Stack[Int] = Stack(2, 1)

scala> stack.top
res56: Int = 2

scala> stack
res57: scala.collection.mutable.Stack[Int] = Stack(2, 1)

scala> stack.pop
res58: Int = 2

scala> stack
res59: scala.collection.mutable.Stack[Int] = Stack(1)
----

Стекі з масивів
~~~~~~~~~~~~~~~
`ArrayStack` є альтернативною реалізацією змінного стеку, до базується на `Array`, що змінює розмір за потреби. Він провадить швидке індексування, і загалом трохи більше ефективний для більшості операцій, ніж звичайний змінний стек.

Хеш таблиці
~~~~~~~~~~~
Хеш таблиця зберігає свої елементи в підлеглому масиві, покладаючи кожний елемент в позицію в масиві, що визначається хеш кодом цього елемента. Додавання елемента до хеш таблиці займає тільки сталий час, доки немає іншого елемента в масиві, що май той самий хеш код. Таким чином хеш таблиці дуже швидкі, доки об'єкти, що покладаються в них мають гарне розподілення хеш кодів. Як результат, по замовчанню типи змінної мапи та множини в Scala базуються на хеш таблицях.

Хеш множини та мапи використовуються так само, як любі інші множини або мапи. Ось деякі прості приклади:
[source,scala]
----
scala> val map = collection.mutable.HashMap.empty[Int,String]
map: scala.collection.mutable.HashMap[Int,String] = Map()

scala> map += (1 -> "make a web site")
res60: map.type = Map(1 -> make a web site)

scala> map += (3 -> "profit!")
res61: map.type = Map(1 -> make a web site, 3 -> profit!)

scala> map(1)
res62: String = make a web site

scala> map contains 2
res63: Boolean = false
----
Ітерація по хеш таблиці не гарантовано виконується в деякому певному порядку. Ітерація просто проходить по підлеглому масиву,в якому б порядку це не траплялось. Щоб отримати гарантований порядок ітерації використовуйте зв'язану мапо або множину, замість звичайної. Зв'язана хеш мапа або множина така сама, як і звичайна мапа або множина, за тим винятком, що він таком влючає зв'язаний список елементів в тому порядку, як вони додавались. Ітерація по такій колекції відбувається завжди в тому порядку, в якому елементи були додані.

Слабкі хеш мапи
~~~~~~~~~~~~~~~
Слабка хеш мапа є особливим різновидом хеш мапи, в якій збирач сміття не слідує посиланням від мапи до ключів, що зберігаються в ній. Це означає, що ключ та його асоційоване значення будуть зникати з мапи, якщо немає іншого посилання на ключ. Слабкі хеш мапи корисні для завдань таких як кешування, де ви бажаєте пере-використати результат коштовної функції, коли функція викликається знову на тому ж ключі. Якщо ключі та результати функції зберігаються в звичайній хеш мапі, мапа буде зростати без обмежень, і жодний ключ ніколи не стане сміттям. Використання слабкої хеш мапи уникає цієї проблеми. Як тільки об'єкт ключа стає недосяжний, його входження видаляється зі слабкої хеш мапи. Слабкі хеш мапи в Scala реалізовані як огортка підлеглої Java реалізації, `java.util.WeakHashMap`.

Конкурентні мапи
~~~~~~~~~~~~~~~~
Конкурентні мапи можуть отримувати доступ з декількох потоків одночасно. На додаток до звичайних операцій з `Map`, вони провадять наступні атомарні операції:

[caption="Операції трейта ConcurrentMap"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
|m putIfAbsent(k, v)|Додає прив'язку ключ/value `k -> m`, за винятком коли `k` вже визначений в `m`
|m remove (k, v)|Видаляє входження для `k`, якщо він наразі відображений на `v`
|m replace (k, old, new)|Замінює значення, асоційоване з ключем `k` на `new`, якщо віе до цього був прив'язаний до `old`
|m replace (k, v)|Замінює значення, асоційоване з ключом `k` до `v`,якщо він до цього був пов'язаний з деяким значенням
|===

`ConcurrentMap` є трейтом в бібліотеці колекцій Scala. Наразі єдиною реалізацією є Java `java.util.concurrent.ConcurrentMap`, що може бути конвертований автоматично в мапу Scala, використовуючи стандартні перетворення колекцій Java/Scala, що будуть описані в Розділі 24.17.

Змінні бітові множини
~~~~~~~~~~~~~~~~~~~~~
Змінні бітові множини такі самі, як незмінні, за виключенням того, що вони можуть бути модифіковані на місці. Змінні бітові множини трохи більше ефективні при оновленні, ніж незмінні, оскільки вони не мають копіювати `Long`, що не були змінені. Ось приклад:
[source,scala]
----
scala> val bits = scala.collection.mutable.BitSet.empty
bits: scala.collection.mutable.BitSet = BitSet()

scala> bits += 1
res64: bits.type = BitSet(1)

scala> bits += 3
res65: bits.type = BitSet(1, 3)

scala> bits
res66: scala.collection.mutable.BitSet = BitSet(1, 3)
----

24.10 Масиви
------------
Масиви є особливим різновидом колекцій в Scala. З одного боку, масиви Scala відповідають один-до-одного до масивів Java. Тобто Scala масив `Array[Int]` представлений як Java `int[]`, `Array[Double]` представлений як Java `double[]` та `Array[String]` представлений як Java `String[]`. Але в той самий час, Scala масиви пропонують значно більше, ніж Java аналоги. Перше, масиви Scala можуть бути дженеріками. Тобто, ви можете мати `Array[T]`, де `T` є параметром типу або абстрактном типом. Друге, масиви Scala сумісні зі Scala послідовностями — ви можете передати `Array[T]`, де потрібне `Seq[T]`. Нарешті, масиви Scala також підтримують всі операції послідовностей. Ось приклад цього в дії: 
[source,scala]
----
scala> val a1 = Array(1, 2, 3)
a1: Array[Int] = Array(1, 2, 3)

scala> val a2 = a1 map (_ * 3)
a2: Array[Int] = Array(3, 6, 9)scala> val a3 = a2 filter (_ % 2 != 0)
a3: Array[Int] = Array(3, 9)

scala> a3.reverse
res1: Array[Int] = Array(9, 3)
----
Беручи до уваги, що Scala масиви представлені як масиви Java, як ці додаткові можливості підтримуються в Scala?

Відповідь полягає в систематичному використанні неявних перетворень. Масив не може претендувати на звання послідовності, оскільки тип даних, що представляє природні масиви, не є субтипом `Seq`. Замість цього, кожного разу, коли масив використовується як Seq, він неявно огортається в субклас `Seq`. Ім'я цього субкласу - `scala.collection.mutable.WrappedArray`. Тут ви бачите його в дії:
[source,scala]
----
scala> val seq: Seq[Int] = a1
seq: Seq[Int] = WrappedArray(1, 2, 3)

scala> val a4: Array[Int] = seq.toArray
a4: Array[Int] = Array(1, 2, 3)

scala> a1 eq a4
res2: Boolean = true
----
Ця взаємодія демонструє, що масиви сумісні з послідовностями, оскільки є неявне перетворення від `Array` до `WrappedArray`. Ідучи іншим шляхом, від `WrappedArray` до `Array`, ви можете використовувати метод `toArray`, визначений в `Traversable`. Останній рядок інтерпретатора вище показує, що огортання та потім розгортання за допомогою `toArray` дає вам той самий масив, з якого ви починали.

Існує також інше неявне перетворення, що застосовується до масивів. Це перетворення просто "додає" всі методи послідовностей до масивів, але не перетворює самий масив на послідовність. "Додавання" означає, що масив огортається в інший об'єкт `ArrayOps`, що підтримує всі методи послідовностей. Типово цей об'єкт `ArrayOps` коротко-тривалий; він зазвичай буде недоступний після виклику метода послідовності та його сховище буде утилізоване. Сучасні VM часто уникають створення цього об'єкту повністю.

Різниця між двома неявними перетвореннями масивів демонструється нижче:
[source,scala]
----
scala> val seq: Seq[Int] = a1
seq: Seq[Int] = WrappedArray(1, 2, 3)

scala> seq.reverse
res2: Seq[Int] = WrappedArray(3, 2, 1)

scala> val ops: collection.mutable.ArrayOps[Int] = a1
ops: scala.collection.mutable.ArrayOps[Int] = [I(1, 2, 3)

scala> ops.reverse
res3: Array[Int] = Array(3, 2, 1)
----
Ви бачите, що виклик `reverse` на `seq`, що є `WrappedArray`, знову буде давати `WrappedArray`. Це логічно, оскільки огорнуті масиви є `Seqs`, і виклик `reverse` на любому `Seq` буде знову давати `Seq`. З іншого боку, виклик `reverse` на `ops` значенні класу `ArrayOps` дасть в результаті `Array`, не `Seq`. Приклад `ArrayOps` вище був досить штучний, призначений тільки показати різницю з `WrappedArray`. Звичайно ви ніколи не визначаєте значення класу `ArrayOps`. Ви просто викликаєте метод `Seq` на масиві:
[source,scala]
----
scala> a1.reverse
res4: Array[Int] = Array(3, 2, 1)
----
Об'єкт `ArrayOps` вставляється автоматично через неявне перетворення. Так що рядок вище еквівалентний до наступного рядка, де `intArrayOps` було перетворенням, що було неявно вставленим до цього:
[source,scala]
----
scala> intArrayOps(a1).reverse
res5: Array[Int] = Array(3, 2, 1)
----
Це підіймає питання, як компілятор обирає `intArrayOps` перед іншим неявним перетворенням до `WrappedArray` в рядку вище. Кінець кінцем, обоє перетворення відображають масив на тип, що підтримує метод `reverse`, де це те, що вказане на вході. Відповідь на це питання в тому, що ці два неявні перетворення мають преоритети. Перетворення `ArrayOps` має вищий преоритет, ніж перетворення `WrappedArray`. Перший визначений в об'єкті `Predef`, тоді як другий визначений в класі `scala.LowPriorityImplicits`, що є суперкласом `Predef`. Неявні в субкласах та субоб'єктах мають перевагу над неявними в базових класах. Так що коли можуть застосовуватись обоє перетворень, буде обрана версія з `Predef`. Дуже подібна схема, що була описана в Розділі 21.7, робить для рядків.

Так що зараз ви знаєте, як масиви можуть бути сумісні з послідовностями та як вони можуть підтримувати всі операції послідовностей. Як щодо дженерікив? В Java ви не можете записати `T[]`, де `T` є параметром типу. Тоді як представлені `Array[T]` в Scala? Фактично, дженерік масив як `Array[T]` може бути під час виконання любим з вісьми масивів примітирних типів Java: `byte[]`, `short[]`, `char[]`, `int[]`, `long[]`, `float[]`, `double[]`, `boolean[]`, або він може бути масивом об'єктів. Єдиний загальний рантайм тип, що обіймає всі ці типи, є `AnyRef` (або, що еквівалентно, `java.lang.Object`) так що це той тип, на який компілятор Scala відображує `Array[T]`. Під час виконання, коли виконується доступ або модифікація елементу масиву типу `Array[T]`, відбувається послідовність перевірок типу, що визначає справжній тип масиву, за яким слідує коректна операція масиву на Java масиві. Ці перевірки типів дещо уповільнюють операції з масивами. Ви можете очікувати, що доступ до дженерік масивів будуть від трьох до чотирьох разів повільніші, ніж доступ до примітивних або об'єктних масивів. Це означає, що якщо вам треба максимальна продуктивність, вам треба обирати суцільні масиви замість дженерікив.

Однак представити дженерік масиви не є достатнім також має бути спосіб створювати дженерік масиви. Існує навіть складніша проблема, що потребує трохи більше допомоги з вашого боку. Щоб пролілюструвати проблему, розглянемо наступну спробу написати дженерік метод, що створює масив:
[source,scala]
----
// Це невірно!
def evenElems[T](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
----
Метод `evenElems` повертає новий масив, що складається з усіх елементів аргументу-вектора `xs`, що стоять в векторі на парних позиціях. Перший рядок тіла `evenElems` створює результуючий масив, що має той самий тип елементів, що і аргумент. Так що, в залежності від дійсного параметру типу `T`, це могло бути `Array[Int]`, або `Array[Boolean]`, або масив деякого іншого примітивного типу Java, або масив деякого типу посилання. Але ці типи мають різні репрезентації під час виконання, то як рантайм Scala збирається обрати коректний тип? Фактично, він не може зробити це базуючись на наданій йому інформації, оскільки справжній тип, що відповідає параметру типу `T`, затирається під час виконання. Ось чому ви отримаєте наступне повідомлення про помилку, якщо ви намагатиметесь скомпілювати код вище:
[source,scala]
----
error: cannot find class tag for element type T
  val arr = new Array[T]((arr.length + 1) / 2)
            ^
----
Що тут потрібне, це ваша допомога компілятору шляхом провадження підказки рантайму, якій справжній тип параметру `evenElems`. Ця підказка часу виконання приймає форму класового тегу `typescala.reflect.ClassTag`. Класовий тег описує затертий тип даного типу, що є всею інформацією, потрібною для конструювання масиву цього типу.

В багатьох випадках компілятор може генерувати класовий тег сам по собі. Це випадок для суцільних типів, як `Int` або `String`. Це також випадок для певних дженерік типів, як `List[T]`, де відомо досить інформації, щоб зпрогнозувати затертий тип; в цьому випадку затертий тип буде `List`.

Для повністю дженерік класів звичайна ідиома є передавати класовий тег використовуючи обмеження контексту, як обговорювалось в Розділі 21.6. Ось як визначення вище може бути полагоджене, через використання обмеження контексту:
[source,scala]
----
// Це робить
import scala.reflect.ClassTag
def evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}
----
В цьому новому визначенні, коли створюється `Array[T]`, компілятор шукає класовий тег для параметру типу `T`, тобто, він буде шукати неявне значення типу `ClassTag[T]`. Якщо таке значення буде знайдене, класовий тег використовується для конструювання правильного типу масиву. Інакше ви побачите повідомлення про помилку, яке ви бачили до цього.

Ось інтеракція з інтерпретатором, що використовує метод `evenElems`:
[source,scala]
----
scala> evenElems(Vector(1, 2, 3, 4, 5))
res6: Array[Int] = Array(1, 3, 5)

scala> evenElems(Vector("this", "is", "a", "test", "run"))
res7: Array[java.lang.String] = Array(this, a, run)
----
В обох випадках компілятор Scala компілятор автоматично конструює класовий тег для типу елементів (перший - `Int`, другий - `String`) та передає його до неявного параметру метода `evenElems`. Компілятор може зробити це для суцільних типів, але ні, якщо аргумент самий є іншим параметром типу без свого класового тегу. Наприклад, наступне схибить:
[source,scala]
----
scala> def wrap[U](xs: Vector[U]) = evenElems(xs)
<console>:9: error: No ClassTag available for U
  def wrap[U](xs: Vector[U]) = evenElems(xs)
                                        ^
----
Що відбувається тут, це те, що `evenElems` вимагає класовий тег для параметру типа `U`, але жодний не був знайдений. Рішення в цьому випадку, звичайно, що треба вимагати інший класовий тег для `U`. Так що наступне робить:
[source,scala]
----
scala> def wrap[U: ClassTag](xs: Vector[U]) = evenElems(xs)
wrap: [U](xs: Vector[U])(implicit evidence$1:
scala.reflect.ClassTag[U])Array[U]
----
Цей приклад також показує, що контекст, зв'язаний в визначенні `U`, є просто скороченням для неявного параметра, що тут має назву `evidence$1` типу `ClassTag[U]`.

24.11 Рядки
-----------
Як і масиви, рядки напряму не є послідовностями, але вони можуть бути сконвертовані до них, і вони також підтримують всі операції послідовностей. Ось деякі приклади операцій, що ви можете викликати для радків:
[source,scala]
----
scala> val str = "hello"
str: java.lang.String = hello

scala> str.reverse
res6: String = olleh

scala> str.map(_.toUpper)
res7: String = HELLO

scala> str drop 3
res8: String = lo

scala> str slice (1, 4)
res9: String = ell

scala> val s: Seq[Char] = str
s: Seq[Char] = WrappedString(h, e, l, l, o)
----
Ці операції підтримуються двома неявними перетвореннями, що пояснюються в Розділі 21.7. Перше, низько-преоритетне перетворення відображує `String` до `WrappedString`, що є субкласом `immutable.IndexedSeq`. Це перетворення було застосоване в останньому рядку попереднього приклада, де рядок був перетворений на `Seq`. Інше, високо-преоритетне перетворення відображує рядок до об'єкту `StringOps`, що додає всі методи незмінних послідовностей до рядків. Це перетворення було неявно вставлене в виклики методів `reverse`, `map`, `drop` та `slice` в попередньому прикладі.

24.12 Характеристики продуктивності
-----------------------------------
Як показали попередні пояснення, різні типи колекцій мають різні характеристики продуктивності. Часто це головна причина для обирання однієї колекції, ніж іншої. Ви можете бачити характеристики продуктивності деяких загальних операцій на колекціях, підсумовані в двох таблицях, Таблиці 24.12 та Таблиці 24.12.

Характеристики продуктивності типів послідовностей
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|===
|              |head|tail|apply|update|prepend|append|insert
8+|immutable
|List          |C|C|L|L|C|L|-
|Stream        |C|C|L|L|C|L|- 
|Vector        |eC|eC|eC|eC|eC|eC|-
|Stack         |C|C|L|L|C|L|-
|Queue         |aC|aC|L|L|L|C|- 
|Range         |C|C|C|-|-|-|-
|String        |C|L|C|L|L|L|- 
8+|mutable
|ArrayBuffer   |C|L|C|C|L|aC|L
|ListBuffer    |C|L|L|L|C|C|L
|StringBuilder |C|L|C|C|L|aC|L
|MutableList   |C|L|L|L|C|C|L
|Queue         |C|L|L|L|C|C|L
|ArraySeq      |C|L|C|C|-|-|-
|Stack         |C|L|L|L|C|L|L 
|ArrayStack    |C|L|C|C|aC|L|L 
|Array         |C|L|C|C|-|-|-
|===

Характеристики продуктивності типів множин та мап
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
|===
|                 |lookup|add|remove|min
5+|immutable
|HashSet/HashMap  |eC|eC|eC|L
|TreeSet/TreeMap  |Log|Log|Log|Log
|BitSet           |C|L|L|eC.footnote:[Assuming bits are densely packed.]
|ListMap          |L|L|L|L
5+|mutable
|HashSet/HashMap  |eC|eC|eC|L
|WeakHashMap      |eC|eC|eC|L
|BitSet           |C|aC|C|eC^a
|===
 
Входження в ціх двох таблицях пояснюється наступним чином:

*C* Операція займає сталий час (швидка).

*eC* Операція ефективно займає сталий час, але це може залежати від деяких припущень таких, як максимальна довжина вектора, або розподілення хеш ключей.

*aC* Операція займає амортизований сталий час. Деякі виклики операції можуть зайняти довше, але якщо виконується багато операцій,в середньому операція триває сталий час.

*Log* Операція триває час, пропорційний до логарифму розміру колекції.

*L* Операція лінійна, триває час пропорційний до розміру колекції.

*-* Операція не підтримується.

Таблиця 24.12 розглядає типи послідовностей, змінні та незмінні, для неступних операцій:

*head* Вибір першого елемента в послідовності.

*tail* Створення нової колекції, що складається з усіх елементів, крім першого.

*apply* Індексування.

*update* Функціональне оновлення (за допомогою `updated`) для незмінних послідовностей, оновлення з побічним ефектом (за допомогою `update`) для змінних послідовностей.

*prepend* Додавання елементу зпереду послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.

*append* Додавання елементу в кінець послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.

*insert* Вставка елементу в довільну позицію послідовності. Напряму це підтримується тільки для змінних послідовностей.

Таблиця 24.12 розглядає змінні та незмінні множини та мапи стосовно наступних операцій:

*lookup* Перевірка, чи елемент знаходиться в множині або обирає значення, асоційоване з ключем.

*add* Додавання нового елементу до множини або новох мапи ключ/значення до мапи.

*remove* Видалення елементу з множини або ключа з мапи.

*min* Найменьший елемент в множині, або меньший ключ в мапі.

24.13 Еквівалентність
---------------------
Бібліотеки колекцій мають уніформний підхід до рівності та хешування. Перше, ідея в тому, щоб поділити колекції на множини, мапи та послідовності. Колекції в різних категоріях завжди нерівні. Наприклад, `Set(1, 2, 3)` нерівне до `List(1, 2, 3)`, навіть якщо вони містять ті самі елементи. З іншого боку, в тій самій категорії, колекції рівні, тільки, та тільки, якщо вони мають ті самі елементи (для послідовностей: ті ж елементи в тому ж порядку). Наприклад, `List(1, 2, 3) == Vector(1, 2, 3)`, та `HashSet(1, 2) == TreeSet(2, 1)`.
 
Не має значення для перевірки рівності, чи колекція змінна, чи незмінна. Для змінної колекції рівність просто залежить від поточних елементів на час, коли виконується перевірка. Це означає, що змінні колекції можуть бути еквівалентні до різних колекцій в різний час, в залежності що було додано або видалене. Це потенційна пастка, коли змінна колекція використовується як ключ в хеш мапі. Наприклад:
[source,scala]
----
scala> import collection.mutable.{HashMap, ArrayBuffer}
import collection.mutable.{HashMap, ArrayBuffer}

scala> val buf = ArrayBuffer(1, 2, 3)
buf: scala.collection.mutable.ArrayBuffer[Int] =
  ArrayBuffer(1, 2, 3)

scala> val map = HashMap(buf -> 3)
map: scala.collection.mutable.HashMap[scala.collection.
mutable.ArrayBuffer[Int],Int] = Map((ArrayBuffer(1, 2, 3),3))

scala> map(buf)
res13: Int = 3

scala> buf(0) += 1

scala> map(buf)
java.util.NoSuchElementException: key not found:
  ArrayBuffer(2, 2, 3)
----
В цьому прикладі вибірка в останньому рядку скоріше всього схибить, оскільки хеш код масива `xs` зміниться в передостанньому рядку. Таким чином, пошук на основі хеш кода буде шукати в іншому місці, ніж той, в якому був збережений `xs`.

24.14 Перегляди
---------------
Колекції мають декілька методів, що конструюють нові колекції. Деякі приклади є `map`, `filter` та `++`. Ми називаємо такі методи трансформерами, оскільки вони приймають щонайменьше одну колекцію в якості свого об'єкта-отримувача, та продукують іншу колекцію в якості результата.

Трансформери можуть бути реалізовані в два принципові способи: строгий та нестрогий (або лінивий). Строгий трансформер конструює нову колекцію з усіма своїми елементами. Нестрогий, або лінивий, трансформер конструює тільки проксі для результуючої колекції, та його елементи конструюються на вимогу.

Як приклад нестрогого трансформера, розглянемо наступну реалізацію лінивої операції `map`:
[source,scala]
----
def lazyMap[T, U](coll: Iterable[T], f: T => U) =
  new Iterable[U] {
    def iterator = coll.iterator map f
  }
----
Зауважте, що `lazyMap` конструює нове `Iterable` без крокування по всіх елементах наданої колекції `coll`. Надана функція `f` замість цього застосовується до елементів ітератора нової колекції, по мірі потреби.

Scala колекції по замовчанню строгі в усіх своїх трансформерах, за винятком `Stream`, що реалізує всі свої методи-трансформери ліниво. Однак існує систематичний спосіб для перетворення кожної колекції в ліниву та навпаки, що базується на переглядах колекції. Перегляд є особливим різновидом колекції, що представляє деяку базову колекцію, але реалізує всі її трансформери ліниво.

Щоб перейти від колекції до її перегляду, ви можете використовувати метод `view` на колекції. Якщо `xs` є деякою колекцією, тоді `xs.view` є та сама колекція, але всі трансформери якої реалізовані ліниво. Щоб перейти назад від перегляду до строгої колекції ви можете використати метод `force`. Як приклад, скажімо, ви маєте вектор з `Int`, на якому ви бажаєте виконати дві функції одна за другою: 
[source,scala]
----
scala> val v = Vector(1 to 10: _*)
v: scala.collection.immutable.Vector[Int] =
Vector(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> v map (_ + 1) map (_ * 2)
res5: scala.collection.immutable.Vector[Int] =
Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
----
В останньому твердженні вираз `v map (_ + 1)` конструює новий вектор, що потім трансформується і третій вектор, через другий виклик до `map (_ * 2)`. В багатьох ситуаціях конструювання проміжного результату після першого виклику до `map` є трохи марнотратним. В псевдо прикладі буде скорішим зробити єдиний `map` з композицією двох функцій, `(_ + 1)` та `(_ * 2)`. Якщо ви маєте дві функції доступними в тому самому місці, ви можете зробити це вручну. Але досить часто послідовні трансформації структур даних виконуються в разних програмних модулях. Зплавлення ціх перетворень потім буде підривати модульність. Більш загальним шляхом уникнути проміжних результатів є перетворення вектора зпочатку на перегляд, застосування до перегляду всіх трансформацій, на нарешті примушення перегляду знову до вектора:
[source,scala]
----
scala> (v.view map (_ + 1) map (_ * 2)).force
res12: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
----
Ми зробимо цю послідовність операцій знову одну з одною:
[source,scala]
----
scala> val vv = v.view
vv: scala.collection.SeqView[Int,Vector[Int]] =
  SeqView(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
----
Застосування `v.view` дає вам `SeqView`, тобто ліниво обчислену `Seq`. Тип `SeqView` має два параметри типу. Перший, `Int`, показує тип елементів перегляду. Другий, `Vector[Int]`, показує вам тип конструктора, що ви отримаєте назад, коли будете примушувати перегляд.

Застосування першого `map` до перегляду дасть таке:
[source,scala]
----
scala> vv map (_ + 1)
res13: scala.collection.SeqView[Int,Seq[_]] = SeqViewM(...)
----
Результатом `map` є значення, що друкує `SeqViewM(...)`. Це в основному огортка, що записує факт, що `map` з функцією `(_ + 1)` треба застосувати до вектора `v`. Він, однак, не застосовує цей `map`, доки перегляд не буде форсований. "M" після `SeqView` вказує на те, що перегляд екнкапсулює операцію `map`. Ініш літери вказують інші відкладені операції. Наприклад, "S" вказує на відкладену операцію `slice`, та "R" вказує на `reverse`. Тепер ми застосуємо другий `map` до останнього результату.
[source,scala]
----
scala> res13 map (_ * 2)
res14: scala.collection.SeqView[Int,Seq[_]] = SeqViewMM(...)
----
Тепер ви отримали `SeqView`, що містить дві операції `map`, так що друкуються дві "M": `SeqViewMM(...)`. Нарешті, форсування останнього результату дає:
[source,scala]
----
scala> res14.force
res15: Seq[Int] = Vector(4, 6, 8, 10, 12, 14, 16, 18, 20, 22)
----
Обоє збережені функції застосовуються як частина виконання операції `force`, та конструюється новий вектор. Таким чином, жодні проміжні структури непотрібні.

Одна деталь, яку треба зауважити, це те, що статичний тип фінального результату є `Seq`, а не `Vector`. Відстежуючи типи назад, ми бачимо, що як тільки був застосований перший відкладений `map`, результат має статичний метод `SeqViewM[Int, Seq[_]]`. Тобто, "знання" що перегляд був застосований до певного тип послідовності `Vector` було втрачене. Реалізація перегляду для любого окремого класу потребує трохи коду, так що бібліотеки колекцій Scala провадять перегляди в основному тільки для загальних типів колекцій,не для специфічних реалізацій.footnote:[Виключенням для цього є масиви: застосування відкладених операцій на масивах буде знову давати результат зі статичним типом `Array`.]

Існує дві причини, чому ви можете вирішити використовувати перегляди. Перша це продуктивність. Ви бачили, що перемикання з колекції на перегляд можливо уникає створення проміжних колекцій. Ці збереження можуть бути досить важливі. Як інший приклад розглянемо проблему пошуку першого паліндрому в списку слів. Паліндром - це слово, що однаково читається в обох напрямках. Ось необхідні визначення:
[source,scala]
----
def isPalindrome(x: String) = x == x.reverse
def findPalindrome(s: Seq[String]) = s find isPalindrome
----
Тепер уявімо, щоб ви маєте дуже довгу послідовність слів, та ви бажаєте знайти паліндром в першому мільйоні слів цієї послідовностіі. Чи ви можете повторно використати визначення `findPalindrome`? Звичайно, ви можете написати:
[source,scala]
----
findPalindrome(words take 1000000)
----
Це мило розділяє два аспекти отримання першого мільйона слів з послідовності, та пошук в ньому паліндрому. Але недолік в тому, що це завжди будує проміжну послідовність, що складається з одного мільйона слів, навіть якщо перше слово в цій послідовності поліндром. Так що після цього потенційно 999999 слів копіюються в проміжний результат взагалі без перевірки. Багато програмістів тут здадуться і напишуть свої власні версії пошуку паліндромів в деякому наданому префіксі аргумента-послідовності. Але з переглядами ви не маєте робити це. Просто напишіть:
[source,scala]
----
findPalindrome(words.view take 1000000)
----
Це матиме той самий гарний поділ турбот, але замість послідовності з мільйона елементів це буде конструювати лише один легковажний об'єкт перегляда. Таким чином, вам не треба обирати між продуктивністю та модульністю. Другий випадок застосування стосується до переглядів змінних послідовностей. Багато функцій-трансформерів на таких переглядах провадять вікно до оригінальної послідовності, що потім може використовуватись для вибіркового оновлення деяких елементів в цій послідовності. Щоб побачити це на прикладі, уявімо ми маємо масив `arr`:
[source,scala]
----
scala> val arr = (0 to 9).toArray
arr: Array[Int] = Array(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
----
Ви можете створити субвікно в цьому масиві, створивши скибку `slice` перегляду масиву:
[source,scala]
----
scala> val subarr = arr.view.slice(3, 6)
subarr: scala.collection.mutable.IndexedSeqView[
  Int,Array[Int]] = IndexedSeqViewS(...)
----
Це дає перегляд `subarr`, що посилається на елементи в позиціях від 3 до 5 в масиві `arr`. Перегляд не копіює ці елементи, він тільки провадить посилання на них. Тепер уявімо, що ви маєте метод, що модифікує деякі елементи в послідовності. Наприклад, наступний метод `negate` буде обертати знак всіх наданих елементів послідовності цілих:
[source,scala]
----
scala> def negate(xs: collection.mutable.Seq[Int]) =
        for (i <- 0 until xs.length) xs(i) = -xs(i)
negate: (xs: scala.collection.mutable.Seq[Int])Unit
----
Тепер уявімо, що ви бажаєте змінити знак елементів в позиціях від трьох до п'яти масива `arr`. Чи можливо використати для цього `negate`? З використанням перегляду це просто:
[source,scala]
----
scala> negate(subarr)

scala> arr
res4: Array[Int] = Array(0, 1, 2, -3, -4, -5, 6, 7, 8, 9)
----
Що тут відбувається, це те, що `negate` змінює всі елементи в `subarr`, що є скибкою елементів `arr`. Знову, ви бачите, що перегляди допомагають підтримувати речі модулярними. Код вище гарно розділяє питання, до якого диапазону індексів застосувати метод, та те, який саме метод застосувати.

Після того, як ми побачили всі ці дотепні використання переглядів, ви можете здивуватись, для чого взагалі мати строгі послідовності? Одна причина в тому, що порівняння продуктивності не завжди на користь лінивих в колекцій в порівнянні зі строгими. Для меньших розмірів колекцій додаткове навантаження по формуванню замикань в переглядах часто більше, ніж вигода від уникнення проміжних структур даних. Можливо більш важлива причина в тому, що обчислення в переглядах можуть бути дуже збентежливі, якщо операції мають побічні ефекти.

Ось приклад, що зачепив декількох користувачів версій Scala до 2.8. В ціх версіях тип `theRange` був лінивий, так що він ефективно поводився як перегляд. Люди намагались створити декілька акторів,footnote:[Бібліотека акторів Scala вже застаріла, але цей історичний приклад все ще актуальний.] ось так:
[source,scala]
----
val actors = for (i <- 1 to 10) yield actor { ... }
----
Вони були здивовані, що після цього жодний з акторів не виконувався, навіть якщо метод `actor` повинен створювати та запускати актора на основі кода, що оточений в фігурні дужки за ним. Щоб пояснити, чому нічого не відбувається, нагадаємо, що вираз `for` вище еквівалентний до застосування методу `map`:
[source,scala]
----
val actors = (1 to 10) map (i => actor { ... })
----
Оскільки попередній `range`, спродукований `(1 to 10)`, поводиться як перегляд, результатом `map` знову буде перегляд. Тобто, відповідно, жодного елементу не було обчислено, та жодного актора не було створено! Актори були створені через форсування `range` для всього виразу, але це менше ніж очевидне, що все це треба щоб змусити акторів до своєї роботи.

Щоб уникнути ціх сюрпризів, колекції Scala отримали більш регулярні правила в версії 2.8. Всі колекції, за винятком потоків та переглядів, є строгими. Єдиний шлях від строгих до лінивих колекцій - через метод `view`. Єдиний шлях іти зворотнім шляхом - через метод `force`. Так що визначення акторів вище будуть робити як очікується в Scala 2.8, в тому розмінні, що будуть створені та запущені десять акторів. Щоб перейти до цікавої попередньої поведінки, ви маєте додати явний виклик метода `view`:
[source,scala]
----
val actors = for (i <- (1 to 10).view) yield actor { ... }
----
В підсумку, перегляди є потужним інструментом для примирення проблем ефективності з проблемами модульності. Але щоб загрузнути в аспектах відкладеного виконання, вам слідує обмежити перегляди до двох сценаріїв. Або ви застосувуєте перегляди в чисто функціональному коді, де трансформації колекцій не мають побічних ефектів. Або ви застосовуєте їх для змінних колекцій, коли всі модифікації виконуються явно. Чого треба уникати, це змішування переглядів і операцій, що створюють нові колекції, при цьому також маючи побічні ефекти.

24.15 Ітератори
---------------
Ітератор не є колекцією, але скоріше шляхом отримати доступ до елементів колекції один за одним. Існує дві базові операції на ітераторі `it`, `next` та `hasNext`. Виклик до `it.next()` буде повертати наступний елемент ітератора, та просувати стан ітератора. Наступний виклик `next` на тому самому ітераторі буде видавати елемент на один далі від повернутого перед цім. Якщо немає більше елементів, що можна повернути, виклик до `next` буде закидати `NoSuchElementException`. Ви можете дізнатись, чи є ще елементи, що можна повернути, використовуючи метод `Iterator`'а `hasNext`.

Найбільш прямолінійний метод "прокрокувати" по всіх елементах, що повертає ітератор, це використання циклу `while`:
[source,scala]
----
while (it.hasNext)
  println(it.next())
----
Ітератори в Scala також провадять аналоги до більшості з методів, що ви можете знайти в трейтах `Traversable`, `Iterable` та `Seq`. Наприклад, вони провадять метод `foreach`, що виконує надану процедуру на кожному елементі, що повертаються ітератором. Використовуючи `foreach`, цикл вище може бути скорочений до:
[source,scala]
----
it foreach println
----
Як завжди, вирази `for` можуть використовуватись як альтернативний синтаксис для виразів, що включають `foreach`, `map`, `filter` та `flatMap`, так що інший спосіб надрукувати всі елементи, що повертаються ітератором, буде таке:
[source,scala]
----
for (elem <- it) println(elem)
----
Існує важлива різниця між методом `foreach` на ітераторі, та тим самим методом на перехідних колекціях: коли він викликається на ітераторів, `foreach` після свого закінчення буде залишати ітератор в кінці. Так що наступний виклик до `next` знову на томуж ітератору буде хибним `NoSuchElementException`. На відміну до цього, коли викликається для колекції, `foreach` залишає число елементів в колекції без змін (якщо передана функція не додає або видаляє елементи, але це не заохочується, оскільки легко може призвести до несподіваних результатів).

Інші операції, які `Iterator` має назагал з `Traversable`, мають ту саму властивість полишати ітератор в кінці після завершення. Наприклад, ітератори провадять метод `map`, що повертає новий ітератор:
[source,scala]
----
scala> val it = Iterator("a", "number", "of", "words")
it: Iterator[java.lang.String] = non-empty iterator

scala> it.map(_.length)
res1: Iterator[Int] = non-empty iterator

scala> res1 foreach println
1
6
2
5

scala> it.next()
java.util.NoSuchElementException: next on empty iterator
----
Як ви можете бачити, після виклику до `map`, ітератор просунувся в кінець. Інший приклад є метод `dropWhile`, що може використовуватись для пошуку першого елементу ітератора, що має певну властивість. Наприклад, щоб знайти перше слово в ітераторі, показаному до цього, що має щонайменьше два символи, ви можете записати:
[source,scala]
----
scala> val it = Iterator("a", "number", "of", "words")
it: Iterator[java.lang.String] = non-empty iterator

scala> it dropWhile (_.length < 2)
res4: Iterator[java.lang.String] = non-empty iterator

scala> it.next()
res5: java.lang.String = number
----
Знову зауважте, що `it` був змінений через виклик до `dropWhile`: тепер `it` вказує на друге слово "number" в списку. Фактично, `it` та результат `res4`, що повертається `dropWhile`, буде повертати точно такуж ж послідовність елементів.

Існує тільки одна стандартна операція, `duplicate`, що дозволяє вам повторно використовувати той самий ітератор:
[source,scala]
----
val (it1, it2) = it.duplicate
----
Виклик до `duplicate` дає вам два ітератори, де кожний повертає точно такі ж елементи, що і ітератор `it`. Два ітератори роблять незалежно; просування одного не впливає на інший. На відміну від цього, оригінальний оператор, `it`, просувається до свого кінця під час дублювання, і, таким чином, стає некорисним.

В підсумку, ітератори поводяться як колекції, якщо ви ніколи не отримуєте доступ до ітератора знову, після виклику на ньому метода. Бібліотеки колекцій Scala робить це явним, з абстракцією на ім'я `TraversableOnce`, що є загальним трейтом для `Traversable` та `Iterator`. Як відказує ім'я, об'єкти `TraversableOnce` можуть проходити з використанням `foreach`, але стан цього об'єкту після проходження не визначений. Якщо об'єкт `TraversableOnce` фактично є `Iterator`, він після проходження буде в своєму кінці, але якщо це `Traversable`, він буде існувати як раніше. Загальний спосіб застосування `TraversableOnce` - як тип аргумента для методів, що можуть приймати або ітератор, або перехідне в якості аргумента. Прикладом є метод додавання `++` в трейті `Traversable`. Він приймає параметр `TraversableOnce`, так що ви можете додати елементи, що походять або від ітератора, або від перехідної колекції.

Всі операції на ітераторах підсумовані в Таблиці 24.12.

[caption="Операції трейта Traversable"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
2+|Абстрактні методи:
|it.next()|Повертає наступний елемент ітератора `it` та просувається далі.
|it.hasNext|Повертає `true`, якщо `it` може повернути наступний елемент.
2+|Варіації:
|it.buffered|Буферизований ітератор, що повертає всі елементи `it`.
|it grouped size|Ітератор, що отримує елементи `it` в "шматках" послідовностей фіксованого розміру.
|xs sliding size|Ітератор, що отримує елементи `it` в послідовностях плаваючого вікна фіксованого розміру.
2+|Копіювання:
|it copyToBuffer buf|Копіює всі повернуті `it` елементи до буфера `buf`.

|it copyToArray(arr, s, l)|Копіює щонайбільше `l` елементів, що повертаються `it`, до `arr`, починаючи з індексу `s`. Останні два аргументи опціональні.
2+|Дублікація:
|it.duplicate|Пара ітераторів, кожний з яких незалежно повертає всі елементи `it`.
2+|Додавання:
|it ++ jt|Ітератор, що повертає всі елементи, що повертає ітератор `it`, за яким слідують елементи, що повертає ітератор `jt`.
|it padTo (len, x)|Ітератор, що повертає всі елементи `it`, за якими слідують копії `x`, доки не буде досягнута загальна довжина з `len` елементів.
2+|Мапи:
|it map f|Ітератор, що отриманий від застосування функції `f` до кожного елементу, що повертає `it`.
|it flatMap f|Ітератор, що отриманий від застосування функції зі значенням ітератора `f` до кожного елементу, та додавання результатів.
|it collect f|Ітератор, отриманий від застосування часткової функції `f` до кожного елементу в `it`, до якого вона визначена, та збирання результатів.
2+|Перетворення:
|it.toArray|Збирає елементи, що повертає `it`, в масив.
|it.toList|Збирає елементи, що повертає `it`, в список.
|it.toIterable|Збирає елементи, що повертає `it`, в `iterable.it.toSeq`
|it.toIndexedSeq|Збирає елементи, що повертає `it`, в індексовану послідовність.
|it.toStream|Збирає елементи, що повертає `it`, в потік.
|it.toSet|Збирає елементи, що повертає `it`, в множину.
|it.toMap|Збирає пари ключ/значення, що повертає `it`, в мапу.
2+|Інформація про розмір:
|it.isEmpty|Перевіряє, чи ітератор порожній (протилежність `hasNext`).
|it.nonEmpty|Перевіряє, чи колекція містить елементи (псевдоним до `hasNext`)
|it.size|Число елементів, що повертає `it`. Увага: `it` після цієї операції буде вказувати на кінець!
|it.lengt|Те саме, що 'it.size'.
|it.hasDefiniteSize|Повертає `true`, якщо відомо, що `it` повертає обмежену кількість елементів (по замовчанню те саме, що `isEmpty`).
2+|Пошук і отримання елементів:
|it find p|Опція, що містить перший елемент, що повертає `it`, який задовільняє `p`, або `None`, якщо жодний елемент не підійде. Увага: ітератор просувається після знайденого елементу, або до кінця, якщо нічого не знайдене.
|it indexOf x|Індекс першого елемента, що повертається `it`, що дорівнює `x`. Увага: ітератор просувається за позицію цього елемента.
|it indexWhere p|Індекс першого елементу, що повертається `it`, що задовільняє `p`. Увага: ітератор просувається за позицію цього елемента.
2+|Субітератори:
|it take n|Ітератор, що повертає перші `n` елементів `it`. Увага: `it` буде просуватись до позиції за `n`-ним елементом, або до кінця, якщо `it` містить меньше ніж `n` елементів.
|it drop n|Ітератор, що починається з `(n + 1)`-ного елементу `it`. Увага: `it` буде просуватись на нову позицію.
|it slice (m, n)|Ітератор, що повертає фрагмент з елементів, що повертає `it`, починаючи з `m`-того елемента, та завершуючи перед `n`-ним елементом.
|it takeWhile p|Ітератор, що повертає елементи з `it`, доки умова `p` є `true`.
|it dropWhile p|Ітератор, що пропускає елементи з `it`, доки умова `p` є `true`, та повертає залишок.
|it filter p|Ітератор, що повертає всі елементи з `it`, що задовільняє умові `p`.
|it withFilter p|Те саме, що `it filter p`. Треба для використання ітераторів в виразах `for`.
|it filterNot p|Ітератор, що повертає всі елементи з `it`, що не задовільняють `p`.
2+|Підрозділення:
|it partition p|Розділяє `it` на пару з двох ітераторів; один повертає всі елементи, що задовільняють предикатові `p`, інший повертає всі елементи з `it`, що ні.
2+|Умови до елементів:
|it forall p|Логічне, вказує, чи предикат `p` дотримується до всіх елементів, що повертає `it`.
|it exists p|Логічне, вказує, чи предикат `p` виконується для деякого елементу, що повертає `it`.
|it count p|Число елементів в `it`, що задовільняють предикату `p`.
2+|Згортки:
|(z /: it)(op)|Застосовує двомісну операцію `op` між послідовними елементами, що повертає `it`, ідучи зліва направо, починаючи з `z`.
|(it :\ z)(op)|Застосовує двомісну операцію `op` між послідовними елементами, що повертає `it`, ідучи зправа наліво, починаючи з `z`.
|it.foldLeft(z)(op)|Те саме, що (z /: it)(op).
|it.foldRight(z)(op)|Те саме, що (it :\ z)(op).
|it reduceLeft op|Застосовує вдомірну операцію `op` між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.
|it reduceRight op|Застосовує вдомірну операцію `op` між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.
2+|Специфічні згортки:
|it.sum|Сума числових елементів, що повертає ітератор.
|it.product|Добуток значень числових елементів, що повертає ітератор.
|it.min|Мінімум впорядкованих елементів, що повертає ітератор.
|it.max|Максимум впорядкованих елементів, що повертає ітератор
2+|Поєднання:
|it zip jt|Ітератор пар відповідних елементів, що повертаються ітераторами `it` та `jt`.
|it zipAll (jt, x, y)|Ітератор пар відповідних елементів, що повертаються ітераторами `it` та `jt`, де коротший ітератор розширюється, щоб співпадати з довшим, через додавання елементів `x` або `y`.
|it.zipWithIndex|Ітератор пар елементів, що повертаються `it` разом з індексами.
2+|Оновлення:
|it patch (i, jt, r)|Ітератор, отриманий з `it` заміною `r` елементів починаючи з `i` патч-ітератором `jt`.
2+|Порівняння:
|it sameElements jt|Перевіряє, чи ітератори `it` та `jt` повертають ті самі елементи в тому самому порядку. Увага: після цієї операції щонайменьше один з `it` та `jt` опиниться в кінці.
2+|Рядки:
|it addString (b, start, sep, end)|Додає рядок до `StringBuilder` `b`, що показує всі елементи, повернуті `it` з роздільниками `sep`, оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональними.
|it mkString (start, sep, end)|Конвертує ітератор на рядоко, що показує всі елементи, що обмежені роздільникими `sep`, оточені рядками `start` та `end`. `start`, `sep` та `end` всі є опціональними.
|===

Буферізовані ітератори
~~~~~~~~~~~~~~~~~~~~~~
Іноді ви бажаєте ітератори, що можуть "заглядати наперед", так що ви можете інспектувати наступний елемент, що буде повернутий, без просування за цей елемент. Розглянемо, наприклад, завдання пропуску початкових порожніх рядків з ітератора, що повертає послідовність рядків. Ви можете підпасти в спокусу написати дещо подібне до такого метода:
[source,scala]
----
// Це не працюватиме
def skipEmptyWordsNOT(it: Iterator[String]) = {
  while (it.next().isEmpty) {}
}
----  
Але подивіться на цей код ближче, ясно що він невірний: код вочевидь пропустить початкові порожні рядки, але він також просуне `it` за перший непорожній рядок!

Рішення до цієї проблеми є використання буферизованого ітератора, примірника трейту `BufferedIterator`. `BufferedIterator` є субтрейтом `Iterator`, що провадить один додатковий метод, `head`. Виклик `head` на буферизованому ітераторі буде повертати його перший елемент, але не буде просувати ітератор. Використовуючи буферизований ітератор пропуск порожніх слів може бути записаний таким чином:
[source,scala]
----
def skipEmptyWords(it: BufferedIterator[String]) =
  while (it.head.isEmpty) { it.next() }
----
Кожний ітератор може бути конвертований на буферизований ітератор, через виклик його методу `buffered`. Ось приклад:
[source,scala]
----
scala> val it = Iterator(1, 2, 3, 4)
it: Iterator[Int] = non-empty iterator

scala> val bit = it.buffered
bit: java.lang.Object with scala.collection.
BufferedIterator[Int] = non-empty iterator

scala> bit.head
res10: Int = 1

scala> bit.next()
res11: Int = 1

scala> bit.next()
res11: Int = 2
---- 
Зауважте, що виклик `head` на буферизованому ітераторі, `bit`, не просуває його. Таким чином, наступний виклик `bit.next()` повертає те саме значення, що і `bit.head`.

24.16 Створення колекцій з нуля
-------------------------------
Ви вже бачили синтаксис, як `List(1, 2, 3)`, що створює список з трьох цілих, та `Map('A' - > 1, 'C' -> 2)`, що створює мапу з двома парами прив'язок. Насправді це універсальна можливість Scala колекцій. Ви можете взяти любе ім'я колекції, та поставити після нього список елементів в дужках. Результат буде новою колекцією з наданими елементвами. Ось деякі інші приклади:
[source,scala]
----
Traversable() // Порожній перехідний об'єкт
List() // Порожній список
List(1.0, 2.0) // Список з елементами 1.0, 2.0
Vector(1.0, 2.0) // Вектор з елементами 1.0, 2.0 
Iterator(1, 2, 3) // Ітератор, що повертає три цілі.
Set(dog, cat, bird) // Множина з трьох тварин
HashSet(dog, cat, bird) // Хеш множина з тими ж тваринами
Map('a' -> 7, 'b' -> 0) // Мапа з символів до цілих
----
"Під покровом" кожний з рядків вище викликає метод `apply` на деякому об'єкті. Наприклад, третій рядок розширюється до такого:
[source,scala]
----
List.apply(1.0, 2.0)
----
Так що це виклик до метода `apply` об'єкта компанйона класу `List`. Метод приймає довільне число аргументів, та конструює з них список. Кожний клас колекції в бібліотеці Scala має метод `apply`. Не має значення, чи клас колекції представляє суцільну реалізацію, як `List`, `Stream` або `Vector`, або це трейт, такий як `Seq`, `Set` або `Traversable`. В останньому випадку виклик `apply` буде продукувати деяку реалізацію трейта по замовчанню. Ось деякі приклади:
[source,scala]
----
scala> List(1, 2, 3)
res17: List[Int] = List(1, 2, 3)

scala> Traversable(1, 2, 3)
res18: Traversable[Int] = List(1, 2, 3)

scala> mutable.Traversable(1, 2, 3)
res19: scala.collection.mutable.Traversable[Int] =
ArrayBuffer(1, 2, 3)
----
Крім `apply` кожний об'єкт компанйон колекції визначає метод `empty`, що повертає порожню колекцію. Так що замість `List()` ви можете написати `List.empty`, замість `Map()` - `Map.empty`, і так далі.

Нащадки трейтів `Seq` також провадять інші операції фабрик в своїх об'єктах компанйонах. Вони підсумовані в Таблиці 24.13. Скорочено це виглядає так:

* `concat` конкатенує довільне число перехідних разом

* `fill` та `tabulate`, що генерують одно- або багато-вимісні послідовності, ініціалізовані деякими виразами або функцією табуляції

* `range`, яка генерує цілі послідовності з деяким заданим кроком

* `iterate`, що генерує послідовність, як результат від повторного застосування функції до початкового елемента.

[caption="Методи фабрик для послідовностей"]
.
[cols="1,5",options="header"]
|===
^| Що таке ^| Що робить
|S.empty|Порожня послідовність
|S(x, y, z)|Послідовність з елементів `x`, `y` та `z`
|S.concat(xs, ys, zs)|Послідовність, отримана як конкатенація елементів `xs`, `ys` та `zs`
|S.fill(n)(e)|Послідовність довжини `n`, де кожний елемент обчисляється як вираз `e`
|S.fill(m, n)(e)|Послідовність послідовностей розміром `m x n`, де кожний елемент обчислюється як вираз `e` (існує також для більших розмірнестей)
|S.tabulate(n)(f)|Послідовність довжини `n`, де елемент для кожного індексу `i` обчислюється як `f(i)`
|S.tabulate(m, n)(f)| Послідовність послідовностей розміром `m x n`, де елемент з індексом `(i, j)` обчислюється як `f(i, j)` (існує також для більших розмірностей)
|S.range(start, end)|Послідовність цілих `start ... end - 1`
|S.range(start, end, step)|Послідовність цілих, що починається зі `start`, та продовжується з кроком `step` до значення `end`, виключно
|S.iterate(x, n)(f)|Послідовність довжини `n` з елементами `x`, `f(x)`, `f(f(x))`, ...
|===

24.17 Перетворення між колекціями Java і Scala
----------------------------------------------
Як Scala, Java має багату бібліотеку колекцій. Існує багато подібного між ціма двома. Наприклад, обоє знають про ітерації, ітерабельні, множини, мапи та послідовності. Але також існують важливі відмінності. Зокрема, бібліотеки Scala роблять значно більший наголос на незмінні колекції, та провадять значно більше операцій, що трансформують колекції в нові.

Іноді вам треба конвертувати колекцію з ощного фреймфорка в інший. Наприклад, ви можете отримати доступ до існуючої Java колекції, так, якби це була Scala. Або ви можете забажати одну зі Scala колекцій до Java методу, що очікує Java варіант. Зробити це досить легко, оскільки Scala пропонує неявні перетворення між всіма головними типами колекцій в об'єкт `JavaConversions`. Зокрема, ви знайдете двосторонні перетворення між наступними типами:

|====
|Iterator||java.util.Iterator
|Iterator||java.util.Enumeration
|Iterable||java.lang.Iterable
|Iterable||java.util.Collection
|mutable.Buffer||java.util.List
|mutable.Set||java.util.Set
|mutable.Map||java.util.Mapx
|===

Щоб дозволити ці перетворення, просто імпортуйте їх, ось так:
[source,scala]
----
scala> import collection.JavaConversions._
import collection.JavaConversions._
----
Тепер ви маєте автоматичні перетворення між колекціями Scala, та відповідними колекціями Java.
[source,scala]
----
scala> import collection.mutable._
import collection.mutable._

scala> val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]

scala> val buf: Seq[Int] = jul
buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)

scala> val m: java.util.Map[String, Int] =
HashMap("abc" -> 1, "hello" -> 2)
m: java.util.Map[String,Int] = {hello=2, abc=1}
----
Внутрішньо ці перетворення роблять через встановлення об'єкта "огортки", що пересилає всі операції до підлеглого об'єкта колекції. Так що колекції ніколи не копіюються, коли конвертуються між Java та Scala. Цікава властивість в тому, що якщо ви робите кругову конверсію, скажімо, Java типу до відповідного типу Scala, та назад до того самого типу Java, ви скінчите з об'єктом ідентичного типу, до того, з якого починали.

Деякі інші загальні Scala колекції також можуть бути конвертовані до Java типів, але для яких немає відповідного перетворення в іншому напрямку:

|===
|Seq||java.util.List
|mutable.Seq||java.util.List
|Set||java.util.Set
|Map||java.util.Map
|===

Оскільки Java не розрізняє між змінними та незмінними колекціями в своїх типах, перетворення зі, скажімо, `collection.immutable.List` буде давати `java.util.List`, на якому всі операції змін будуть закидати `UnsupportedOperationException`. Ось приклад:
[source,scala]
----
scala> val jul: java.util.List[Int] = List(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]

scala> jul.add(7)
java.lang.UnsupportedOperationException
at java.util.AbstractList.add(AbstractList.java:131)
----

24.18 Висновок
==============
Тепер ви побачили, як використовувати Scala колекції дуже детально. Колекції Scala приймають підхід надання вам потужних будівельних блоків, скоріше, ніж декількох споміжних методів на підхваті. Покладаючи поряд два або три такі будівельні блоки, дозволяє вам виразити величезну кількість коричних обчислень. Цей стиль бібліотек особливо ефективний через те, що Scala має легкий синтаксис для функціональних літералів, та через те, що вона провадить багато типів колекцій, що стійкі та незмінні.

Ця глава показала колекції з точки зору програміста, що використовує бібліотеку колекцій. Наступна глава покаже вам, як колекції побудовані, та як ви можете додати власні типи колекцій.