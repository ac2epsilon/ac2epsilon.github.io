<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__35">Глава 35</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___scells">Електронна таблиця SCells</h1>
<div class="paragraph"><p>В попередніх главах ви бачили багато різних конструкцій мови програмування Scala. В цій главі ви побачите, як ці конструкції грають разом в реалізації розширюваного застосування. Задачею буде написати застосування електронної таблиці, що матиме назву <code>SCells</code>.</p></div>
<div class="paragraph"><p>Є багато причин, чому це завдання може бути цікавим. Для початку, кожний знає електронні таблиці, так що просто зрозуміти, що повинно робити застосування. Друге, електронні таблиці є програмами, що виконують великий диапазон різних обчислювальних завдань. Присутній візуальний аспект, де електронна таблиця є багатим GUI застосуванням. Існує символічний аспект, що має відношення до формул, та того, як розбирати та інтерпретувати їх. Є ообчислювальний аспект, що має справу з тим, як оновлювати можливо великі таблиці інкрементально. Існує реактивний аспект, коли таблиці розглядаються як програми, що реагують в інтерактивний спосіб на події. Нарешті існує компонентний аспект, коли застосування сконструйоване як набір компонентів повторного застосування. Всі ці аспекти будуть розглядатись в деталях в цій главі.</p></div>
<div class="paragraph"><p>Малюнок 35.1 - Проста електронна таблиця.</p></div>
<div class="sect1">
<h2 id="_35_1__">35.1 Візуальний фреймворк</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми почнемо з написання базового візуального фреймворка застосування. Малюнок 35.1 показує першу ітерацію користувацького інтерфейсу. Ви можете бачити, що електронна таблиця є прокручуваною таблицею. Вона має рядки від 0 до 99, та стовпчики від A до Z. Ви виражаєте це в Swing через визначення таблиці як <code>ScrollPane</code> що містить <code>Table</code>. Лістинг 35.1 показує код.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">swing._</span>

<span class="k">class</span> <span class="nc">Spreadsheet</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ScrollPane</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Table</span><span class="o">(</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">rowHeight</span> <span class="k">=</span> <span class="mi">25</span>
    <span class="n">autoResizeMode</span> <span class="k">=</span> <span class="nc">Table</span><span class="o">.</span><span class="nc">AutoResizeMode</span><span class="o">.</span><span class="nc">Off</span>
    <span class="n">showGrid</span> <span class="k">=</span> <span class="kc">true</span>
    <span class="n">gridColor</span> <span class="k">=</span> <span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">awt</span><span class="o">.</span><span class="nc">Color</span><span class="o">(</span><span class="mi">150</span><span class="o">,</span> <span class="mi">150</span><span class="o">,</span> <span class="mi">150</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">rowHeader</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">ListView</span><span class="o">((</span><span class="mi">0</span> <span class="n">until</span> <span class="n">height</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">fixedCellWidth</span> <span class="k">=</span> <span class="mi">30</span>
    <span class="n">fixedCellHeight</span> <span class="k">=</span> <span class="n">table</span><span class="o">.</span><span class="n">rowHeight</span>
  <span class="o">}</span>

  <span class="n">viewportView</span> <span class="k">=</span> <span class="n">table</span>
  <span class="n">rowHeaderView</span> <span class="k">=</span> <span class="n">rowHeader</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.1 - Код для електронної таблиці на Малюнку Figure 35.1.</p></div>
<div class="paragraph"><p>Компонент електронної таблиці, показаний на Лістингу 35.1 визначений в пакунку <code>org.stairwaybook.scells</code>, що буде містити всі класи, трейти та об'єкти, що треба для застосування. Він імпортує з пакунка <code>scala.swing</code> основні елементи огортки Scala Swing. Сама таблиця є класом, що приймає як параметри висоту та ширину (в числі клітин). Клас розширює <code>ScrollPane</code>, що дає дві полоси прогрутки знизу та зправа на Малюнку 35.1. Він містить два субкомпонента на ім'я <code>table</code> та <code>rowHeader</code>.</p></div>
<div class="paragraph"><p>Компонент <code>table</code> є примірником анонімного субкласа від класа <code>scala.swing.Table</code>. Чотири рядкі в його тілі встановлюють деякі атрибути: <code>rowHeight</code> для висоти рядка таблиці в пікселях, <code>autoResizeMode</code> для вимкнення авто-розміру таблиці, <code>showGrid</code> для показу решітки між клітинами, та <code>gridColor</code> для встановлення кольору решітки в темно сірий.</p></div>
<div class="paragraph"><p>Компонент <code>rowHeader</code>, що містить заголовки стовпчиків зліва таблиці на Малюнку 35.1, є <code>ListView</code>, що відображує свої елементи з рядками від 0 до 99. Два рядка в його тілі фіксують ширину клітини до 30 пікселів, та висоту таку саму, як <code>rowHeight</code> таблиці.</p></div>
<div class="paragraph"><p>Вся таблиця зібрана у встановлення двох полів в <code>ScrollPane</code>. Поле <code>viewportView</code> встановлене в <code>table</code>, та <code>rowHeaderView</code> встановлене в список <code>rowHeader</code>. Різниця між двома переглядами в тому, що поле перегляду панелі прокрутки є область, що прокручується двома лінійками, тоді як заголовки рядків зліва залишаються фіксованими коли ви рухаєте горизонтальну прокрутку. Через якусь примху Swing завжди надає по замовчанню заголовки стовпчиків зверху таблиці, так що немає потреби визначати їх явно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">swing._</span>

<span class="k">object</span> <span class="nc">Main</span> <span class="k">extends</span> <span class="nc">SimpleSwingApplication</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">top</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MainFrame</span> <span class="o">{</span>
    <span class="n">title</span> <span class="k">=</span> <span class="s">&quot;ScalaSheet&quot;</span>
    <span class="n">contents</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Spreadsheet</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">26</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.2 - Головна програма для застосування електронної таблиці.</p></div>
<div class="paragraph"><p>Щоб спробувати рудиментарну таблицю, показану в Лістингу 35.1, вам тільи треба визначити головну програму, що створює компонент <code>Spreadsheet</code>. Така програма показана в Лістингу 35.2.</p></div>
<div class="paragraph"><p>Програма <code>Main</code> наслідує від <code>SimpleSwingApplication</code>, що турбується про всі низькорівневі деталі, що мають бути встановлені перед тим, як Swing застосування може бути запущеним. Вам треба тільки визначити вікно вищого рівня для застосування в методі <code>top</code>. В нашому прикладі <code>top</code> є <code>MainFrame</code>, що має два визначених елементи: його заголовок, встановлений в <code>"ScalaSheet"</code>, та його <code>contents</code>, встановлений в клас <code>Spreadsheet</code> з 100 рядками та 26 стовпчиками. Це все. Якщо ви запустите це застосування зі <code>scala org.stairwaybook.scells.Main</code>, ви маєте побачити таблицю з Малюнка 35.1.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_2______">35.2 Роз'єднання вводу даних та відображення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви трохи пограєте з тільки що написаною таблицею, ви швидко помітите, що вивід, який вона продукує в клітині, завжди такий самий , який ви ввели в клітину. Справжня таблиця так не поводиться. В реальній електронній таблиці вам треба ввести формулу, і ви побачите значення. Так що те, що введено, відрізняється від того, що відображується.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">swing._</span>

<span class="k">class</span> <span class="nc">Spreadsheet</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ScrollPane</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">cellModel</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Model</span><span class="o">(</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span>
  <span class="k">import</span> <span class="nn">cellModel._</span>

  <span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Table</span><span class="o">(</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>

  <span class="c1">// як раніше...</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">rendererComponent</span><span class="o">(</span><span class="n">isSelected</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
      <span class="n">hasFocus</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Component</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">hasFocus</span><span class="o">)</span> <span class="k">new</span> <span class="nc">TextField</span><span class="o">(</span><span class="n">userData</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">))</span>
    <span class="k">else</span>
      <span class="k">new</span> <span class="nc">Label</span><span class="o">(</span><span class="n">cells</span><span class="o">(</span><span class="n">row</span><span class="o">)(</span><span class="n">column</span><span class="o">).</span><span class="n">toString</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">xAlignment</span> <span class="k">=</span> <span class="nc">Alignment</span><span class="o">.</span><span class="nc">Right</span>
      <span class="o">}</span>
    <span class="k">def</span> <span class="n">userData</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">v</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="s">&quot;&quot;</span> <span class="k">else</span> <span class="n">v</span><span class="o">.</span><span class="n">toString</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="c1">// решта як раніше...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.3 - Електронна таблиця з методом <code>rendererComponent</code>.</p></div>
<div class="paragraph"><p>Як перший крок до справжнього застосування електронної таблиці вам слідує сконцентруватись на розділенні елементу даних та відображення. Базовий механізм для відображення міститься в методі  <code>rendererComponent</code> класу <code>Table</code>. По замовчанню <code>rendererComponent</code> завжди відображує те, що введене. Якщо ви бажаєте змінити це, вам треба перекрити <code>rendererComponent</code> на щось інше. Лістинг 35.3 показує нову версію <code>Spreadsheet</code> з методом <code>rendererComponent</code>.</p></div>
<div class="paragraph"><p>Метод <code>rendererComponent</code> перекриває метод по замовчанню в класі <code>Table</code>. Він приймає чотири параметри. Параметри <code>isSelected</code> та <code>hasFocus</code> є <code>Boolean</code>, що вказують, чи клітина була вибрана, та чи вона має фокус, що означає, що ввод клавіатури пійде в клітину. Інші два параметри, <code>row</code> та <code>column</code>, дають координати клітини.</p></div>
<div class="paragraph"><p>Новий метод <code>rendererComponent</code> перевіряє, чи клітина має фокус вводу. Якщо <code>hasFocus</code> є <code>true</code>, клітина використовується для редагування. В цьому випадку ви бажаєте відображати редагуємий <code>TextField</code>, що містить дані, що користувач ввів останнього разу. Ці дані повертаються допоміжним методом <code>userData</code>, що відображує вміст таблиці за наданим рядком та стовпчиком. Вміст отримується викликом  <code>this(row, column)</code>.<span class="footnote"><br />[Хоча <code>this(row, column)</code> може виглядати подібно до виклику конструктора, в цьому випадку це виклик метода <code>apply</code> на поточному примірнику <code>Table</code>.]<br /></span> Метод <code>userData</code> також турбується про відображення елемента <code>null</code> як порожнього рядка замість <code>"null"</code>.</p></div>
<div class="paragraph"><p>Докі все добре. Але що має відображатись, якщо клітина не має фокуса? В реальній таблиці це має бути значення клітини. Таким чином, насправді тут роблять дві таблиці. Перша на ім'я <code>table</code> містить те, що ввів користувач. Друга "тіньова" таблиця містить внутрішню репрезентацію клітин, та що має бути відображено. В прикладі електронної таблиці ця таблиця є двовимірним масивом на ім'я <code>cells</code>. Якщо клітина на заданому рядку та стовпчику не має фокусу редагування, метод <code>rendererComponent</code> буде відображувати елемент <code>cells(row)(column)</code>. Елемент не може бути відредагований, так що він буде відображатись в <code>Label</code> замість <code>editableTextField</code>.</p></div>
<div class="paragraph"><p>Залишається визначити внутрішній масив клітин. Ви можете зробити цце напряму в класі <code>Spreadsheet</code>, але загалом бажано розділяти перегляд GUI компонент від їх внутрішньої моделі. Ось чому в прикладі вище масив клітин визначений в окремому класі на ім'я <code>Model</code>. Модель інтегрована в <code>Spreadsheet</code> через визначення значення <code>cellModel</code> з типом <code>Model</code>. Твердження <code>import</code>, що слідує за цім визначенням <code>val</code>, робить члени <code>cellModel</code> доступні без потреби ставити префікс. Лістинг 35.4 показує першу, спрощену версію класу <code>Model</code>. Клас визначає внутрішній клас <code>Cell</code>, та двовимірний масив <code>cells</code> з елементів <code>Cell</code>. Кожний елемент ініціалізований як новий примірник <code>Cell</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>

<span class="k">class</span> <span class="nc">Model</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">Cell</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">cells</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">ofDim</span><span class="o">[</span><span class="kt">Cell</span><span class="o">](</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">height</span><span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">width</span><span class="o">)</span>
    <span class="n">cells</span><span class="o">(</span><span class="n">i</span><span class="o">)(</span><span class="n">j</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cell</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.4 - Перша версія класу <code>Model</code>.</p></div>
<div class="paragraph"><p>Малюнок 35.2 - Клітини відображують себе.</p></div>
<div class="paragraph"><p>Ось і все. Якщо ви скомпілюєте модифікований клас <code>Spreadsheet</code> з класом <code>Model</code>, та запустите застосування <code>Main</code>, ви повинні побачити вікно як на Малюнку 35.2.</p></div>
<div class="paragraph"><p>Ціллю цього розділу було отримати дизайн, де відображене значення клітини відрізняється від тексту, що був в неї введений. Ця ціль очевидно була досягнута, хоча і в дуже сирий спосіб. В новій таблиці ви можете ввести будь-що в клітину, але вона буде завжди відображувати тільки свої координати, коли втратить фокус. Ясно, що ми ще не закінчили.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_3_">35.3 Формули</h2>
<div class="sectionbody">
<div class="paragraph"><p>В реальності електронна таблиця містить дві речі: поточне значення та формулу для обчислення цього значення.</p></div>
<div class="paragraph"><p>Існує три типи формул в електронних таблицях:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Числові значення, як <code>1.22</code>, <code>-3</code> або <code>0</code>.
</p>
</li>
<li>
<p>
Текстові мітки, як <code>"Річний звіт"</code>, <code>"Амортизація"</code> або <code>"Загалом"</code>.
</p>
</li>
<li>
<p>
Формули, що обчислюють нові значення від вмісту клітин, як <code>=add(A1,B2)</code> або <code>=sum(mul(2, A2), C1:D16)</code>
</p>
</li>
</ol></div>
<div class="paragraph"><p>Формула, що обчислює значення, завжди починається зі знаку рівняння, за яким слідує арифметичний вираз. Електронна таблиця <code>SCells</code> має виключно просту та уніформну угоду щодо арифметичних виразів: кожний вираз є застосуванням деякої функції до списку аргументів. Ім'я функції є ідентифікатор, такий як <code>add</code> для двомісного додавання, або <code>sum</code> для підсумку довільного числа операндів. Аргументом функції може бути число, посилання на клітину, посилання на диапазон клітин, такий як <code>C1:D16</code>, або інше застосування функції. Ви побачите пізніше, що <code>SCells</code> має відкриту архитектуру, що спрощує встановлення ваших власних функцій через композицію міксінів.</p></div>
<div class="paragraph"><p>Перший крок до обробки формул є написання типів, що будуть їх представляти. Як ви можете очікувати, різні типи формул представлені кейс класами. Лістинг 35.5 показує вміст файла на ім'я <code>Formulas.scala</code>, де ці класи представлені:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>

<span class="k">trait</span> <span class="nc">Formula</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Coord</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Formula</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="o">(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">column</span><span class="o">).</span><span class="n">toChar</span><span class="o">.</span><span class="n">toString</span> <span class="o">+</span> <span class="n">row</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Range</span><span class="o">(</span><span class="n">c1</span><span class="k">:</span> <span class="kt">Coord</span><span class="o">,</span> <span class="n">c2</span><span class="k">:</span> <span class="kt">Coord</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Formula</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">toString</span> <span class="o">+</span> <span class="s">&quot;:&quot;</span> <span class="o">+</span> <span class="n">c2</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Formula</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">value</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Textual</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Formula</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">value</span>
<span class="o">}</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Application</span><span class="o">(</span><span class="n">function</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">arguments</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Formula</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Formula</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
    <span class="n">function</span> <span class="o">+</span> <span class="n">arguments</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;(&quot;</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">,</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Empty</span> <span class="k">extends</span> <span class="nc">Textual</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.5 - Класи, що представляють формули.</p></div>
<div class="paragraph"><p>Трейт <code>Formula</code>, показаний в Лістингу 35.5, має п'ять кейс класів в якості дітей:</p></div>
<div class="paragraph"><p><code>Coord</code> для координат клітин, як <code>A3</code>,
<code>Range</code> для диапазонів клітин, як <code>A3:B17</code>,
<code>Number</code> для чисел з плаваючою комою, як <code>3.1415</code>,
<code>Textual</code> для текстуальних міток, як <code>"Амортизація"</code>,
<code>Application</code> для застосувань функцій, як <code>sum(A1,A2)</code>.</p></div>
<div class="paragraph"><p>Кожний кейс клас перекриває метод <code>toString</code>, так що він відображує свій різновид формули в стандартний спосіб, показаний вище. Для зручності також є об'єкт <code>Empty</code>, що представляє вміст порожньої клитини. Об'єкт <code>Empty</code> є примірником класу <code>Textual</code> з порожнім аргументом рядка.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_4__">35.4 Розбір формул</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередньому розділі ви бачили різні різновиди формул, та як вони виглядають в вигляді рядків. В цьому розділі ви побачите, як обернути цей процес: як трансформувати рядок користувацького ввооду в дерево  <code>Formula</code>. Решта цього розділу пояснює один по одному різні елементи класу <code>FormulaParsers</code>, що містить парсери, що виконують перетворення. Клас побудований на фреймворку комбінаторів, наданому в Главі 33. А саме, парсери формул є примірниками класу <code>RegexParsers</code>, поясненому в тій главі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>

<span class="k">object</span> <span class="nc">FormulaParsers</span> <span class="k">extends</span> <span class="nc">RegexParsers</span> <span class="o">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Перші два елементи об'єкта <code>FormulaParsers</code> є додатковими парсерами для ідентифікаторів та десятичних чисел:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">ident</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;[a-zA-Z_]\w*&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="k">def</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;-?\d+(\.\d*)?&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити з першого регулярного виразу вище, ідентифікатор починається з літери або підкреслення. За цім іде довільна кількість "словних" символів, представлених кодом регулярного виразу <code>\w</code>, що розпізнає літери, цифри та підкреслення. Другий регулярний вираз описує десятичні числа, що складаються з опціонального знаку мінусу, однієї або більше цифри, що представлені кодом регулярного виразу <code>\d</code>, та опціонально десяткової частини, що складається з крапки, за якою іде одна або більше цифр.</p></div>
<div class="paragraph"><p>Наступний елемент об'єкта <code>FormulaParsers</code> є парсер клітин, що розпізнає координати клітини, такі як <code>C11</code> або <code>B2</code>. Спочатку він викликає парсер регуляних виразів, що визначає форму координат: одна літера та одна або більше цифр. Повернутий з цього парсера рядок потім перетворюється на координати клітини, через відділення літери від числової частини, та перетворення обох частин на індекси для клітини, для отримання стовпчика та рядка клітини:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">cell</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Coord</span><span class="o">]</span> <span class="k">=</span>
  <span class="s">&quot;&quot;&quot;[A-Za-z]\d+&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span> <span class="o">^^</span> <span class="o">{</span> <span class="n">s</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">column</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toUpper</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span>
    <span class="k">val</span> <span class="n">row</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">toInt</span>
    <span class="nc">Coord</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що парсер клітини є дещо обмежувальним в тому, що він дозволяє координати стовпчика тільи з однієї літери. Таким чином число стовпчиків таблиць ефективно обмежене до щонайбільше 26, оскількі подальші стовпчики не можуть бути розібрані. Є гарною ідеєю узагальнити парсер так, щоб він сприймав клітини з декільками ведучими літерами. Це залишається вам як практична вправа.</p></div>
<div class="paragraph"><p>Парсер диапазонів розпізнає диапазон клітин. Такий диапазон складається з двох координат клітин з двокрапкою між ними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">range</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Range</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">cell</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">cell</span> <span class="o">^^</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">c1</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">c2</span> <span class="k">=&gt;</span> <span class="nc">Range</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Парсер чисел розпізнає десятичні числа, що конвертуються до <code>Double</code> та огортаються в примірник класу <code>Number</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">number</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Number</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">decimal</span> <span class="o">^^</span> <span class="o">(</span><span class="n">d</span> <span class="k">=&gt;</span> <span class="nc">Number</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">toDouble</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Парсер застосувань розпізнає застосування функції. Таке застосування складається з ідентифікатора, за яким іде список виразів аргументів в дужках:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">application</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Application</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">ident</span><span class="o">~</span><span class="s">&quot;(&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;)&quot;</span> <span class="o">^^</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">f</span><span class="o">~</span><span class="s">&quot;(&quot;</span><span class="o">~</span><span class="n">ps</span><span class="o">~</span><span class="s">&quot;)&quot;</span> <span class="k">=&gt;</span> <span class="nc">Application</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">ps</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Парсер <code>expr</code> розпізнає вираз формули — або високорівневу формулу, що іде за <code>=</code>, або аргумент до функції. Такий формульний вираз визначений бути клітиною, диапазоном клітин, числом або застосуванням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Formula</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">range</span> <span class="o">|</span> <span class="n">cell</span> <span class="o">|</span> <span class="n">number</span> <span class="o">|</span> <span class="n">application</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення парсера <code>expr</code> містить надспрощення, оскільки диапазони клітин повинні з'являтись тільки як аргументи функцій; вони не повинні бути дозволені як високорівневі формули. Ви можете змінити граматику формули так, щоб в ній два використання виразів було розділені, та диапазони синтаксично були видалені з високорівневих формул. В представленій тут електронній таблиці замість цього така помилка детектується при обчисленні виразу.</p></div>
<div class="paragraph"><p>Текстуальний парсер розпізнає довільний вхідний рядок, докі він не починається зі знака рівності (нагадаємо, що рядки, що посинаються з <code>=</code> розглядаються як формули):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">textual</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Textual</span><span class="o">]</span> <span class="k">=</span>
  <span class="s">&quot;&quot;&quot;[^=].*&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span> <span class="o">^^</span> <span class="nc">Textual</span>
</pre></div></div></div>
<div class="paragraph"><p>Парсер формул розпізнає всі різновиди легального вводу в клітину. Формула є або число, або текстуальний елемент, або формула, що починається з рядка рівності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">formula</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Formula</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">number</span> <span class="o">|</span> <span class="n">textual</span> <span class="o">|</span> <span class="s">&quot;=&quot;</span><span class="o">~&gt;</span><span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Це складає граматику для клітин електронної таблиці. Фінальний метод <code>parse</code> використовує цю граматику в методі, що конвертує вхідні рядкі в дерево <code>Formula</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">parse</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Formula</span> <span class="o">=</span>
  <span class="n">parseAll</span><span class="o">(</span><span class="n">formula</span><span class="o">,</span> <span class="n">input</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span>
    <span class="k">case</span> <span class="n">f</span><span class="k">:</span> <span class="kt">NoSuccess</span> <span class="o">=&gt;</span> <span class="nc">Textual</span><span class="o">(</span><span class="s">&quot;[&quot;</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">msg</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="c1">// кінець FormulaParsers</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>parse</code> розбирає весь вхід за допомогою парсера формул. Якщо він успішний, повертається результуюча формула. Якщо він схибить, замість цього буде повертатись об'єкт <code>Textual</code> з повідомлення про помилку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">swing._</span>
<span class="k">import</span> <span class="nn">event._</span>

<span class="k">class</span> <span class="nc">Spreadsheet</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">...</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Table</span><span class="o">(</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">reactions</span> <span class="o">+=</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">TableUpdated</span><span class="o">(</span><span class="n">table</span><span class="o">,</span> <span class="n">rows</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="n">rows</span><span class="o">)</span>
          <span class="n">cells</span><span class="o">(</span><span class="n">row</span><span class="o">)(</span><span class="n">column</span><span class="o">).</span><span class="n">formula</span> <span class="k">=</span>
            <span class="nc">FormulaParsers</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="n">userData</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.6 - Таблиця, що парсить формули.</p></div>
<div class="paragraph"><p>Це все, що треба для парсинга формул. Єдина річ, що залишається - це інтегрувати парсер в таблицю. Щоб зробити це, ви маєте збагатити клас <code>Cell</code> в класі <code>Model</code> полем <code>formula</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Cell</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">formula</span><span class="k">:</span> <span class="kt">Formula</span> <span class="o">=</span> <span class="nc">Empty</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">formula</span><span class="o">.</span><span class="n">toString</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В новій версії класу <code>Cell</code> метод <code>toString</code> визначений для відображення формули клітини. Такім чином ви можете перевірити, чи були формули розібрані коректно.</p></div>
<div class="paragraph"><p>Останній крок в цьому розділі є інтеграція парсера в таблицю. Розбір формули відбувається як реакція на користувацький ввод в клітину. Завершений ввод в клітину моделюється в бібліотеці Swing подією <code>TableUpdated</code>. Клас <code>TableUpdated</code> міститься в пакунку <code>scala.swing.event</code>. Подія має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">TableUpdated</span><span class="o">(</span><span class="n">table</span><span class="o">,</span> <span class="n">rows</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона містить таблицю, що була змінена, так само як набір координат задіяних клітин, наданих як <code>rows</code> та <code>column</code>. Параметр <code>rows</code> є значенням диапазону типу <code>Range[Int]</code>.<span class="footnote"><br />[Range[Int] є також типом Scala виразу, такого як "1 to N". Це має на увазі, що між клітинами немає циклічних залежностей. Ми обговоримо відкидання цього припущення в кінці цієї глави.]<br /></span> Параметр <code>column</code> є цілим. Так що загалом подія <code>TableUpdated</code> може посилатись на декілька задіяних клітин, але вони можуть бути на послідовному диапазоні рядків, та поділяти той самий стовпчик.</p></div>
<div class="paragraph"><p>Малюнок 35.3 - Клітини, що відображують свої формули.</p></div>
<div class="paragraph"><p>Як тільки таблиця зміниться, відповідні клітини мають бути пере-розбрані. Щоб реагувати на подію <code>TableUpdated</code>, ви додаєте <code>case</code> до значення <code>reactions</code> компонента таблиці, як показано в Лістингу 35.6. Тепер, коли таблиця відредагована, формули всіх задіяних клітин будуть оновлені через парсинг відповідних користувацьких даних. Коли скомпілювати класи, що описані дотепер, та запустити застосування <code>scells.Main</code>, ви маєте застосування електронної таблиці, таке як показане на Малюнку 35.3. Ви можете редагувати клітини вводячи в них текст. Після завершення редагування клітина відображує формулу, яку вона містить. Ви також можете спробувати ввести якісь нелегальний ввод, наприклад <code>=add(1, X)</code> в поле, що має фокус редагування на Малюнку 35.3. Нелегальний ввоод покаже повідомлення про помилку. Наприклад, як тільки ви залишите редаговане поле на Малюнку 35.3, ви повинні побачити в клітині повідомлення <code>"['(' expected]"</code> (щоб побачити все повідомлення про помилку вам може знадобитись розширити стовпчик через перетаскування роздільника між заголовками стовпчиків вправо).</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_5_">35.5 Обчислення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Звичайно, в кінці електронна таблиця повинна обчислити формули, а не тільки відображати їх. Щоб досягти цього в цьому розділі ми додамо потрібні компоненти.</p></div>
<div class="paragraph"><p>Що нам треба, це метод <code>evaluate</code>, що приймає формулу, та повертає значення формули в поточній електронній таблиці, представлене як <code>Double</code>. Ми покладемо цей метод в новий трейт <code>Evaluator</code>. Методу буде потрібно отримувати доступ до полей клітин в класі <code>Model</code>, що з'ясувати поточні значення клітин, на які є посилання в формулі. З іншого боку, клас <code>Model</code> має викликати <code>evaluate</code>. Таким чином є взаємна залежність між <code>Model</code> та <code>Evaluator</code>. Гарний спосіб виразити таку взаємну залежність між класами показаний в Главі 29: ви використовуєте наслідування в одному напрямуку, та типи <code>self</code> в іншому.</p></div>
<div class="paragraph"><p>В прикладі електронної таблиці клас <code>Model</code> наслідує від <code>Evaluator</code>, і таким чином отримує доступ до метода <code>evaluation</code>. Щоб пійти в іншому напрямку, клас <code>Evaluator</code> визначає свій тип <code>self</code> як <code>Model</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">trait</span> <span class="nc">Evaluator</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Model</span> <span class="o">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином значення <code>this</code> в класі <code>Evaluator</code> вважається <code>Model</code> , та масив клітин доступні через писання або в <code>cells</code> або в <code>this.cells</code>.</p></div>
<div class="paragraph"><p>Тепер, коли підключення зроблене, ми сконцентруємось на визначенні вмісту класу <code>Evaluator</code>. Лістинг 35.7 показує реалізацію метода <code>evaluate</code>. Як ви можете очікувати, метод містить порівняння шаблонів по різних типах формул. Для координати <code>Coord(row, column)</code> він повертає значення масиву <code>cells</code> в цій координаті. Для числа <code>Number(v)</code> він повертає значення <code>v</code>. Для текстуальної мітки <code>Textual(s)</code> він повертає нуль. Нарешті для застосування <code>Application(function, arguments)</code> він обчислює значення для всіх аргументів, отримує об'єкт функції, відповідний до назви функції, з таблиці операцій, та застосовує цю функцію до всіх значень аргументів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Formula</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="k">try</span> <span class="o">{</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Coord</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">cells</span><span class="o">(</span><span class="n">row</span><span class="o">)(</span><span class="n">column</span><span class="o">).</span><span class="n">value</span>
    <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">v</span>
    <span class="k">case</span> <span class="nc">Textual</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="mi">0</span>
    <span class="k">case</span> <span class="nc">Application</span><span class="o">(</span><span class="n">function</span><span class="o">,</span> <span class="n">arguments</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">argvals</span> <span class="k">=</span> <span class="n">arguments</span> <span class="n">flatMap</span> <span class="n">evalList</span>
      <span class="n">operations</span><span class="o">(</span><span class="n">function</span><span class="o">)(</span><span class="n">argvals</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">Exception</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">.</span><span class="nc">NaN</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.7 - Метод <code>evaluate</code> трейта <code>Evaluator</code>.</p></div>
<div class="paragraph"><p>Таблиця <code>operations</code> відображує імена функцій на об'єкти функцій. Вона визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Op</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Double</span>
<span class="k">val</span> <span class="n">operations</span> <span class="k">=</span> <span class="k">new</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Op</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити з цього визначення, операціх змодельовані як функції від списків значень на значення.</p></div>
<div class="paragraph"><p>Тип <code>Op</code> вводить зручний псевдоним для типу операції.</p></div>
<div class="paragraph"><p>Обчислення в <code>evaluate</code> огорнутий в <code>try-catch</code> для захисту проти помилок вводу. Насправді є декілька речей, що можуть пійти не так при обчисленні формули клітини: координати можуть бути за межами; імена функцій можуть бути невизначені; функції можуть мати невірне число аргументів; арифметичні операції можуть бути нелегальні або викликати переповнення. Реакція на любу з ціх помилок така сама: повертається значення "not-a-number". Повернуте значення <code>Double.NaN</code> є IEEE репрезентацією для обчислення, що не має відповідного значення з плаваючою комою. Це може статись через переповнення або ділення на ноль, як приклад. Метод <code>evaluate</code> з Лістинга 35.7 обирає повертати те саме значення для всіх різновидів помилок. Перевага цієї схеми в тому, що її просто зрозуміти, та вона не потребує багато коду для реалізації. Її недолік в тому, що всі помилки зліплені докупи, так що користувач на має жодного детального зворотнього зв'язка по тому, що пішло не так. Якщо ви бажаєте, ви можете поекспериментувати з більш покращеними способами представляти помилки в застосуванні <code>SCells</code>.</p></div>
<div class="paragraph"><p>Обчислення аргументів відрізняється від обчислення високорівневих формул. Аргументи можуть бути списками, тоді як високорівневі функції ні. Наприклад, вираз аргументів <code>A1:A3</code> в <code>sum(A1:A3)</code> повертає значення рядків <code>A1</code>, <code>A2</code>, <code>A3</code> в списку. Цей список потім передається в операцію <code>sum</code>. Можливо міксувати списки та окремі значення в виразах аргументів, наприклад, як робить операція <code>sum(A1:A3, 1.0, C7)</code>, що підраховує суму п'яти елементів. Щоб обробляти аргументи, що можуть бути обчислені як списки, є інша функція обчислення, <code>evalList</code>, що приймає формулу та повертає список значень:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">evalList</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Formula</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Range</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">references</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">evaluate</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо аргумент формула, передана до <code>evalList</code> є <code>Range</code>, повертається значення-список, що містить список всіх значень, представлених диапазоном. Для кожної іншої формули результат буде список, що складається з єдиного значення результату цієї формули. <code>cells</code>, на який посилається формула, обчислюється третьою функцією, <code>references</code>. Ось її визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">references</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Formula</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Cell</span><span class="o">]</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Coord</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">List</span><span class="o">(</span><span class="n">cells</span><span class="o">(</span><span class="n">row</span><span class="o">)(</span><span class="n">column</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">Range</span><span class="o">(</span><span class="nc">Coord</span><span class="o">(</span><span class="n">r1</span><span class="o">,</span> <span class="n">c1</span><span class="o">),</span> <span class="nc">Coord</span><span class="o">(</span><span class="n">r2</span><span class="o">,</span> <span class="n">c2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">r1</span> <span class="n">to</span> <span class="n">r2</span><span class="o">).</span><span class="n">toList</span><span class="o">;</span> <span class="n">column</span> <span class="k">&lt;-</span> <span class="n">c1</span> <span class="n">to</span> <span class="n">c2</span><span class="o">)</span>
      <span class="k">yield</span> <span class="n">cells</span><span class="o">(</span><span class="n">row</span><span class="o">)(</span><span class="n">column</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Application</span><span class="o">(</span><span class="n">function</span><span class="o">,</span> <span class="n">arguments</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">arguments</span> <span class="n">flatMap</span> <span class="n">references</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="nc">List</span><span class="o">()</span>
<span class="o">}</span>
<span class="o">}</span> <span class="c1">// кінець Evaluator</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>references</code> насправді більш загальний, ніж треба прямо зараз, в тому, що він обчислює список клітин, на який посилається любий різновид формули, не тільки формула <code>Range</code>. Пізніше з'ясується, що додана функціональність потрібна для обчислення наборів клітин, що мають бути оновлені. Тіло метода є прямолінійним співпадінням шаблонів на різних типах формул. Для координати <code>Coord(row, column)</code> він повертає одноелементний список, що містить клітину з такими координатами. Для виразів диапазону <code>Range(coord1, coord2)</code> він повертає всі клітини між ціма двома координатами, обчислені <code>for</code> виразом. Для застосування функції <code>Application(function, arguments)</code> він повертає клітини, на які посилається кожний вираз аргументів, сконкатеновані через <code>flatMap</code> в єдиний список. Для двох інших типів формул, <code>Textual</code> та <code>Number</code>, він повертає порожній список.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_6__">35.6 Бібліотеки операцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас <code>Evaluator</code> сам не визначає операцій, що можуть бути виконані на клітинах: його таблиця <code>operations</code> спочатку порожня. Ідея полягає в визначення таких операцій в інших трейтах, що потім міксуються в клас <code>Model</code>. Лістинг 35.8 показує приклад трейта, що реалізує загальні арифметичні операції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">trait</span> <span class="nc">Arithmetic</span> <span class="o">{</span> <span class="k">this:</span> <span class="kt">Evaluator</span> <span class="o">=&gt;</span>
  <span class="n">operations</span> <span class="o">+=</span> <span class="o">(</span>
    <span class="s">&quot;add&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">},</span>
    <span class="s">&quot;sub&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">},</span>
    <span class="s">&quot;div&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span> <span class="o">},</span>
    <span class="s">&quot;mul&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">},</span>
    <span class="s">&quot;mod&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span> <span class="o">},</span>
    <span class="s">&quot;sum&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mf">0.0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span> <span class="o">},</span>
    <span class="s">&quot;prod&quot;</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">xs</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mf">1.0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.8 - Бібліотека для арифметичних операцій.</p></div>
<div class="paragraph"><p>Цікаво, що цей трейт не має експортованих членів. Єдина річ, що він робить, це заповнює таблицю під час ініціалізації. Він отримує доступ до цієї таблиці через використання типу <code>self</code> <code>Evaluator</code>, тобто через ту саму техніку, яку використовує клас <code>Arithmetic</code> для доступу до моделі. З сіми операцій, що визначені в трейті <code>Arithmetic</code>, п'ять є двомісними операціями, та дві приймають довільне число аргументів. Всі двомісні операції слідують тій самій схемі. Наприклад, операція додавання <code>add</code> визначена виразом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">{</span> <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто вона очікує список аргументів, що складається з двох елементів <code>x</code> та <code>y</code>, та повертає суму <code>x</code> та <code>y</code>. Якщо аргумент списку містить кількість елементів, що не дорівнює двом, закидається <code>MatchError</code>. Це відповідає до загальної філософії <code>"let it crash"</code> моделі обчислення <code>SCell</code>, де некоректний ввод очікувано приводить до виключення часу виконання, що потім перехоплюється в <code>try-catch</code> метода <code>evaluation</code>.</p></div>
<div class="paragraph"><p>Дві останні операції, <code>sum</code> та <code>prod</code>, приймають список аргументва довільної довжини та вставляють двомісну операцію між послідовними елементами. Так що вини є примірниками схеми "лівої згортки", що в класі <code>List</code> виражається операцією <code>/:</code>. Наприклад, щоб підсумувати список чисел <code>List(x, y, z)</code>, операція обчислює <code>0 + x + y + z</code>. Перший операнд, 0, є результатом, якщо список порожній.</p></div>
<div class="paragraph"><p>Ви можете інтегрувати цю бібліотеку операцій в електронну таблицю через міксування трейта <code>Arithmetic</code> в клас <code>Model</code>, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>

<span class="k">class</span> <span class="nc">Model</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Evaluator</span> <span class="k">with</span> <span class="nc">Arithmetic</span> <span class="o">{</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">Cell</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">formula</span><span class="k">:</span> <span class="kt">Formula</span> <span class="o">=</span> <span class="nc">Empty</span>
    <span class="k">def</span> <span class="n">value</span> <span class="k">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">formula</span><span class="o">)</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">formula</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Textual</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">toString</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">...</span> <span class="c1">// решта як раніше</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша зміна в класі <code>Model</code> стосується шляху, як клітини відображують себе. В новій версії відображувані значення клітини залежать від її формули. Якщо формула є полем <code>Textual</code>, вміст поля відображується буквально. У всіх інших випадках вормула обчислюється та відображується результуюче значення ціх обчислень.</p></div>
<div class="paragraph"><p>Малюнок 35.4 - Клітини, що обчислюються.</p></div>
<div class="paragraph"><p>Якщо ви скомпілюєте змінені трейти та класи, та перезапустите програму <code>Main</code>, ви отримаєте дещо, що починає скидатись на електронну таблицю. Ви можете ввести формули в клітини та отримати їх переобчисленими. Наприклад, як тільки ви закриєте фокус вводу на клітині <code>C5</code> з Малюнка 35.4, в побачите <code>86.0</code>, результат обчислення формули <code>sum(C1:C4)</code>.</p></div>
<div class="paragraph"><p>Однак досі відсутній ключовий момент. Якщо ви зміните значення клітини <code>C1</code> на Малюнку 35.4 з <code>20</code> на <code>100</code>, сума в клітині <code>C5</code> не буде автоматично оновленою до <code>166</code>. Вам буде треба клацнути на <code>C5</code> вручну, щоб побачити зміну в її значенні. Ось чого бракує, це способа мати переобчислення значень клітин автоматично після змін.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_7__">35.7 Змінене просування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо значення клітини змінилось, всі клітини, що залежать від її значення, мають перерахувати та висвітити своє значення. Найпростіший шлях зробити це буде переобчислити значення кожної клітини в таблиці після кожної зміни. Але такий підхід не дуже гарно маштабується по мірі того, як таблиця зростатиме в розмірі.</p></div>
<div class="paragraph"><p>Кращий підхід є переобчислити значення тільки тих клітин, що посилаються на змінену клітину в своїх формулах. Ідея є використати базований на подіях фреймворк <code>publish/subscribe</code> для зміни просування: як тільки клітина отримує формулу, вона підписується на повідомлення від всіх змін значень в клітинах, до яких посилається формула. Зміна значення в одній з ціх клітин буде перемикати переобчислення клітини підписчика. Якщо таке переобчислення спричинить зміну значення клітини, вона в свою чергу повідомить всі клітини, що залежать від неї. Цей процес продовжиться, доки всі значення клітин не стабілізуються, тобто не буде змін в значеннях любої з клітин.<span class="footnote"><br />[Це вважає, що немає циклічних залежностей між клітинами. Ми обговоримо це припущення в кінці цієї глави.]<br /></span></p></div>
<div class="paragraph"><p>Фреймворк публікації/підписки реалізований в класі <code>Model</code> з використанням стандартного механізму подій фреймворка Scala Swing. Ось нова (і фінальна) версія цього класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">swing._</span>

<span class="k">class</span> <span class="nc">Model</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Evaluator</span> <span class="k">with</span> <span class="nc">Arithmetic</span> <span class="o">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняно з попередньою версією <code>Model</code>, ця версія додає новий <code>import swing._</code>, що робить абстракцію подій Swing безпосередньо доступною.</p></div>
<div class="paragraph"><p>Головна модифікація класу <code>Model</code> стосується вкладеного класу <code>Cell</code>. Клас <code>Cell</code> тепер наслідує від <code>Publisher</code>, так що ми можемо публікувати події. Логіка обробки подій повністю міститься в сеттерах двох властивостей: <code>value</code> та <code>formula</code>. Ось нова версія <code>Cell</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Cell</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Publisher</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">formula</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Textual</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">value</span><span class="o">.</span><span class="n">toString</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зовні виглядає, що <code>value</code> та <code>formula</code> є дві змінні класу <code>Cell</code>. Їх справжня реалізація є в термінах двох приватних полів, що обладнані публічними геттерами <code>value</code> та <code>formula</code>, та сеттерами, <code>value_=</code> та <code>formula_=</code>. Ось визначення, що реалізують властивість <code>value</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">var</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">v</span>
<span class="k">def</span> <span class="n">value_=</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!(</span><span class="n">v</span> <span class="o">==</span> <span class="n">w</span> <span class="o">||</span> <span class="n">v</span><span class="o">.</span><span class="n">isNaN</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">.</span><span class="n">isNaN</span><span class="o">))</span> <span class="o">{</span>
    <span class="n">v</span> <span class="k">=</span> <span class="n">w</span>
    <span class="n">publish</span><span class="o">(</span><span class="nc">ValueChanged</span><span class="o">(</span><span class="k">this</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Сеттер <code>value_=</code> присвоює нове значення <code>w</code> приватному полю <code>v</code>. Якщо нове значення відрізняється від старого, він також публікує подію <code>ValueChanged</code> з самою клітиною в якості аргумента. Зауважте, що перевірка, чи значення змінилось, є трохи заплутаним, бо включає значення <code>NaN</code>. Специфікація Java каже, що <code>NaN</code> є відмінним від любого іншого значення, включаючи себе! Таким чином, перевірка чи два значення є такі самі має трактувати <code>NaN</code> особливо: два значення <code>v</code>, <code>w</code> є такі самі, якщо вони рівні з точки зору <code>==</code>, або вони обоє є <code>NaN</code>, тобто <code>v.isNaN</code> та <code>w.isNaN</code> обоє дають <code>true</code>.</p></div>
<div class="paragraph"><p>Кожного разу, коли сеттер <code>value_=</code> виконує публікацію в фреймворці <code>publish/subscribe</code>, сеттер <code>formula_=</code> виконує підписку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">var</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Formula</span> <span class="o">=</span> <span class="nc">Empty</span>
<span class="k">def</span> <span class="n">formula</span><span class="k">:</span> <span class="kt">Formula</span> <span class="o">=</span> <span class="n">f</span>
<span class="k">def</span> <span class="n">formula_=</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Formula</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="k">&lt;-</span> <span class="n">references</span><span class="o">(</span><span class="n">formula</span><span class="o">))</span> <span class="n">deafTo</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
  <span class="k">this</span><span class="o">.</span><span class="n">f</span> <span class="k">=</span> <span class="n">f</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="k">&lt;-</span> <span class="n">references</span><span class="o">(</span><span class="n">formula</span><span class="o">))</span> <span class="n">listenTo</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
  <span class="n">value</span> <span class="k">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо клітинці присвоєна нова формула, вона спочатку відписується за допомогою <code>deafTo</code> від усіх клітин, на які посилалась попередня формула. Потім вона зберігає нову формулу в приватній змінній <code>f</code> та підписується за допомогою <code>listenTo</code> на всі клітини, на які посилається. Нарешті вона переобчислює значення використовуючи нову формулу.</p></div>
<div class="paragraph"><p>Остання частина коду в переглянутому класі <code>Cell</code> вказує, як реагувати на подію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">reactions</span> <span class="o">+=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">ValueChanged</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">value</span> <span class="k">=</span> <span class="n">evaluate</span><span class="o">(</span><span class="n">formula</span><span class="o">)</span>
<span class="o">}</span>
<span class="o">}</span> <span class="c1">// кінець класу Cell</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас ValueChanged також міститься в класі <code>Model</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">ValueChanged</span><span class="o">(</span><span class="n">cell</span><span class="k">:</span> <span class="kt">Cell</span><span class="o">)</span> <span class="k">extends</span> <span class="n">event</span><span class="o">.</span><span class="nc">Event</span>
</pre></div></div></div>
<div class="paragraph"><p>Решта класу <code>Model</code> як раніше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">val</span> <span class="n">cells</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">ofDim</span><span class="o">[</span><span class="kt">Cell</span><span class="o">](</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">height</span><span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">width</span><span class="o">)</span>
    <span class="n">cells</span><span class="o">(</span><span class="n">i</span><span class="o">)(</span><span class="n">j</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cell</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
<span class="o">}</span> <span class="c1">// кінець класу Model</span>

<span class="k">package</span> <span class="nn">org.stairwaybook.scells</span>
<span class="k">import</span> <span class="nn">swing._</span><span class="o">,</span> <span class="n">event</span><span class="o">.</span><span class="k">_</span>

<span class="k">class</span> <span class="nc">Spreadsheet</span><span class="o">(</span><span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ScrollPane</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">cellModel</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Model</span><span class="o">(</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span>
  <span class="k">import</span> <span class="nn">cellModel._</span>
  <span class="k">val</span> <span class="n">table</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Table</span><span class="o">(</span><span class="n">height</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
<span class="o">...</span> <span class="c1">// без змін</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">rendererComponent</span><span class="o">(</span>
      <span class="n">isSelected</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">hasFocus</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
      <span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
<span class="o">...</span> <span class="c1">// без змін</span>

  <span class="k">def</span> <span class="n">userData</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">column</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
<span class="o">...</span> <span class="c1">// без змін</span>

  <span class="n">reactions</span> <span class="o">+=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">TableUpdated</span><span class="o">(</span><span class="n">table</span><span class="o">,</span> <span class="n">rows</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="n">rows</span><span class="o">)</span>
        <span class="n">cells</span><span class="o">(</span><span class="n">row</span><span class="o">)(</span><span class="n">column</span><span class="o">).</span><span class="n">formula</span> <span class="k">=</span>
          <span class="nc">FormulaParsers</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="n">userData</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">column</span><span class="o">))</span>
    <span class="k">case</span> <span class="nc">ValueChanged</span><span class="o">(</span><span class="n">cell</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">updateCell</span><span class="o">(</span><span class="n">cell</span><span class="o">.</span><span class="n">row</span><span class="o">,</span> <span class="n">cell</span><span class="o">.</span><span class="n">column</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="n">cells</span><span class="o">;</span> <span class="n">cell</span> <span class="k">&lt;-</span> <span class="n">row</span><span class="o">)</span> <span class="n">listenTo</span><span class="o">(</span><span class="n">cell</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">rowHeader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListView</span><span class="o">(</span><span class="mi">0</span> <span class="n">until</span> <span class="n">height</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">fixedCellWidth</span> <span class="k">=</span> <span class="mi">30</span>
  <span class="n">fixedCellHeight</span> <span class="k">=</span> <span class="n">table</span><span class="o">.</span><span class="n">rowHeight</span>
<span class="o">}</span>
<span class="n">viewportView</span> <span class="k">=</span> <span class="n">table</span>
<span class="n">rowHeaderView</span> <span class="k">=</span> <span class="n">rowHeader</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 35.9 - Завершений компонент електронної таблиці.</p></div>
<div class="paragraph"><p>Код електронної таблиці майже готовий. Остання відсутня частина є перемальовка модифікованих клітин. Досі всі просування значень стосувались тільки внутрішніх значень <code>Cell</code>; видима таблиця не зазнавала впливу. Один спосіб змінити це буде додати команду <code>redraw</code> до сеттера <code>value_=</code>. Однак це може підірвати пряму сеперацію між моделлю та переглядом, що ми бачили до цього. Більш модульне рішення є повідомити таблицю про всі події <code>ValueChanged</code>, та дати їх перемалювати себе. Лістинг 35.9 показує фінальний компонент електронної таблиці, що реалізує цю схему.</p></div>
<div class="paragraph"><p>Клас <code>Spreadsheet</code> на Лістингу 35.9 має тільки дві нові ревізії. Перше, компонент <code>table</code> тепер підписується за допомогою <code>listenTo</code> на всі клітини в <code>model</code>. Друге, є новий <code>case</code> в <code>table</code> <code>reactions</code>: якщо він нотифікований подією <code>ValueChanged(cell)</code>, він потребує перемалювати відповідну клітину через виклик <code>updateCell(cell.row, cell.column)</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_35_8_">35.8 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Електронна таблиця, розроблена в цій главі, є повністю функціональною, навіть якщо в деяких моментах вона адаптує простіші рішення для реалізації, ніж найбільш зручні для користувача. Таким чином, вона змогла бути написаною лише в меньше 200 рядків коду. Тим не менше, архитектура електронної таблиці робить модифікації та розширення простими. В випадку, якщо ви хочете поекспериментувати з кодом трохи більше, ось деякі поради, що ви можете змінити або додати:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
В можете зробити таблицю змінного розміру, так що число рядків або стовпчиків може бути змінене інтерактивно.
</p>
</li>
<li>
<p>
Ви можете додати нові типи формул, наприклад бінарні операції або інші функції.
</p>
</li>
<li>
<p>
Ви можете подумати що робити, коли клітини рекурсивно посилаються самі на себе. Наприклад, якщо клітина <code>A1</code> містить формулу <code>add(B1, 1)</code>, та <code>B1</code> містить формулу <code>mul(A1, 2)</code>, переобчислення любої з ціх клітин буде викликати переповнення стеку. Зрозуміло, що це не дуже гарне рішення. Як альтернатива, ви можете або заборонити таку ситуацію, або просто обчислювати одну ітерацію кожного разу, коли клітини змінюються.
</p>
</li>
<li>
<p>
Ви можете розширити обробку помилок, даячи більш детальне описання того, що пішло не так.
</p>
</li>
<li>
<p>
Ви можете додати поле вводу формул зверху таблиці, так що довгі формули можуть бути введені більш зручно.
</p>
</li>
</ol></div>
<div class="paragraph"><p>На початку цієї книги ми зробили наголос на аспекті маштабованосі Scala. Ми стверджували, що комбінація об'єктної орієнтованості  Scala, та функціональних конструкцій робить її підходящою для програм в диапазоні від малих скриптів до дуже великих систем. Електронна таблиця, представлена тут, все ще є малою системою, навіть якщо вона робить значно більше, ніж 200 рядків в більшості інших мов. Тим не менш, ви бачите багато з деталей, що робить Scala маштабованою в цьому застосуванні.</p></div>
<div class="paragraph"><p>Електронна таблиця використовує Scala класи та трейти з їх міксин композицією, щоб комбінувати компоненти в гнучкий спосіб. Рекурсіивні залежності між компонентами виражені через використання типів <code>self</code>. Потреба в статичному стані повністю прибрана — тільки високорівневі компоненти, що не є класами, є дерева формул та парсери парсерів, та обоє є повністю функціональними. Застосування також екстенсивно використовує функції вищих порядків та порівняння шаблонів, однаково, для доступу до формул та обробки подій. Так що це гарний приклад того, як функціональне та об'єктно орієнтовне прорамування може бути успішно зкомбіновано.</p></div>
<div class="paragraph"><p>Одна з важливих причин, чому застосування електронної таблиці таке стисле, є те, що воно базується на потужних бібліотеках. Бібліотека парсерного комбінатора провадить фактично внутрішню домен-специфічну мову для написання парсерів. Без неї розбір формул міг бути значно більш складним. Обробка подій в бібліотеках Scala Swing є гарним прикладом потужності керівних абстракцій. Якщо ви знаєте бібліотеки Java Swing, ви можливо оцінили стислість Scala концепції <code>reactions</code>, особливо коли порівнювати до тонкощів написання методів повідомлень та реалізації інтерфейсів слухачів в класичному шаблоні дизайну publish/subscribe. Так що електронна таблиця демонструє переваги розширюваності, коли високорівневі бібліотеки можуть бути зроблені так, щоб виглядати як розширення мови.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-28 10:17:10 EEST
</div>
</div>
</body>
</html>
