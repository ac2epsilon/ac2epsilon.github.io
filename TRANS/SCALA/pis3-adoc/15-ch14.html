<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__14">Глава 14</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Твердження та тести</h1>
<div class="paragraph"><p>Твердження та тести є два важливі шляхи, яким ви можете перевірити, що програмне забезпечення, яке ви пишете, поводиться так, як ви очікуєте. В цій главі ми покажемо декілька опцій, що ви маєте в Scala для написання та виконання тестів.</p></div>
<div class="sect1">
<h2 id="_14_1_">14.1 Твердження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Твердження в Scala написані як виклики попередньо визначеного метода <code>assert</code>.<span class="footnote"><br />[Метод <code>assert</code> визначений в об'єкті синглтоні <code>Predef</code>, чиї члени автоматично імпортуються в кожний джерельний файл Scala.]<br /></span> Вираз <code>assert(умова)</code> закидає <code>AssertionError</code>, якщо умова не дотримується. Існує також версія <code>assert</code> з двома аргументами: вираз <code>assert(умова, пояснення)</code> перевіряє умову, та, якщо воно не дотримується, закидає <code>AssertionError</code>, що містить надане пояснення. Тип пояснення <code>Any</code>, так що ви можете передати любий об'єкт в якості пояснення. Метод <code>assert</code> буде викликати <code>toString</code> не ньому, щоб отримати рядок пояснення, що покладається в <code>AssertionError</code>. Наприклад, в методі з назвою <code>above</code> класа <code>Element</code>, показаному в Лістингу 10.13, ви можете розмістити <code>assert</code> після виклику до <code>widen</code>, щоб переконатись, що поширені елементи мають однакову ширину. Це показано в Лістингу 14.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">this1</span> <span class="k">=</span> <span class="k">this</span> <span class="n">widen</span> <span class="n">that</span><span class="o">.</span><span class="n">width</span>
  <span class="k">val</span> <span class="n">that1</span> <span class="k">=</span> <span class="n">that</span> <span class="n">widen</span> <span class="k">this</span><span class="o">.</span><span class="n">width</span>
  <span class="n">assert</span><span class="o">(</span><span class="n">this1</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">that1</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">this1</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that1</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.1 - Використання твердження.</p></div>
<div class="paragraph"><p>Інший шлях, як ви можете обрати зробити це, є перевірити ширини в кінці метода <code>widen</code>, прямо перед поверненням значення. Ви можете досягти цього через зберігання результату як <code>val</code>, виконуя твердження для результату, потім вказуючи <code>val</code> останнім, так що результат буде повернений, якщо твердження справджується. Однак ви можете зробити це більш стисло, за допомогою зручного метода в <code>Predef</code> на ім'я <code>ensuring</code>, як показано в Лістингу 14.2.</p></div>
<div class="paragraph"><p>Метод <code>ensuring</code> може бути використаний з любим типом результату завдяки неявному перетворенню. Хоча це виглядає в цьому коді так, якби ми викликали <code>ensuring</code> на результаті <code>widen</code>, що має тип <code>Element</code>, насправді викликаючи <code>ensuring</code> на типі, до якого <code>Element</code> неявно конвертоване. Метод <code>ensuring</code> приймає один аргумент, функцію предикати, що приймає тип результату та повертає <code>Boolean</code>, та передає результат в предикат. Якщо предикат повертає <code>true</code>, <code>ensuring</code> буде повертати результат; інакше  <code>ensuring</code> буде закидати <code>AssertionError</code>.</p></div>
<div class="paragraph"><p>В цьому прикладі предикат є <code>w &lt;= _.width</code>. Підкреслення є заповнювачем для одного аргумента, переданого до предикату, результату <code>Element</code> метода <code>widen</code>. Якщо ширина, передана як <code>w</code> до <code>widen</code> меньше або рівне до ширини результуючого <code>Element</code>, предикат буде давати результат <code>true</code>, та <code>ensuring</code> буде давати результат <code>Element</code>, на якому він був викликаний. Оскільки це останній вираз метода <code>widen</code>, сам <code>widen</code> потім буде мати результат <code>Element</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">widen</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">width</span><span class="o">)</span>
    <span class="k">this</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">left</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">width</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
    <span class="k">var</span> <span class="n">right</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">w</span> <span class="o">-</span> <span class="n">width</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
    <span class="n">left</span> <span class="n">beside</span> <span class="k">this</span> <span class="n">beside</span> <span class="n">right</span>
  <span class="o">}</span> <span class="n">ensuring</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="k">_</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.2 - Використання <code>ensuring</code> для твердження щодо результата функції.</p></div>
<div class="paragraph"><p>Твердження можуть бути вімкнені та вимкнені з використанням флагів командного рядка JVM, <code>-ea</code> та <code>-da</code>. Коли ввімкнено, кожне твердження служить як малий тест, що використовує дійсні дані, що використовуються при виконанні програми. В залишку цієї глави ми сфокусуємось на написанні зовнішніх тестів, що провадять свої власні тестові дані, та виконуються незалежно від застосування.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_2___scala">14.2 Тестування в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви маєте багато опцій для тестування в Scala, від визнаних Java інструментів, таких як JUnit та TestNG, до інструментів, написаних на Scala, таких як ScalaTest, specs2, та ScalaCheck. В залишку цієї глави ми надамо вам швидкий тур по цім інструментам. Ми почнемо з ScalaTest.</p></div>
<div class="paragraph"><p>ScalaTest є найбільш гнучким фреймворком тестування Scala: він може бути налаштований для вирішення різних проблем. Гнучкість ScalaTest означає, що команди можуть використовувати такі стилі тестування, що найкраще підходять до їх потреб. Наприклад, для команд, знайомих з JUnit, стиль FunSuite буде відчуватись комфортабельним в знайомим. Лістинг 14.3 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.FunSuite</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSuite</span> <span class="k">extends</span> <span class="nc">FunSuite</span> <span class="o">{</span>

  <span class="n">test</span><span class="o">(</span><span class="s">&quot;elem result should have passed width&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.3 - Writing tests with FunSuite.</p></div>
<div class="paragraph"><p>Центральна концепція в ScalaTest є сюїта, колекція тестів. Тестом може бути будь-що з ім'ям, що може розпочатись, та або мати вдачу, або схибити, бути в стані очікування або скасованим. Трейт <code>Suite</code> є центральною одиницею композиції в ScalaTest. Сюїта декларує методи "життєвого цикла", що визначають шлях по замовчанню для виконання тесту, що може бути перекрите для налаштування того, як тести можуть бути написані або виконані.</p></div>
<div class="paragraph"><p>ScalaTest пропонує трейти стилів, що розширюють <code>Suite</code>, та перекривають методи життєвого циклу, щоб підтримувати різні стилі тестування. Він також провадить міксіни трейтів, що що перекривають методи життєвого циклу, щоб адресувати окремі потреби тестування. Ви визначаєте тестові класи через композицію стилів <code>Suite</code> та міксін трейтів, та визначаєте тестові сюїти, через композицію примірників <code>Suite</code>.</p></div>
<div class="paragraph"><p><code>FunSuite</code>, що розширюється тестовим класом, показаним на Лістингу 14.3, є прикладом тестового стилю. <code>Fun</code> в <code>FunSuite</code> означає функцію; <code>test</code> є методом, визначеним в  <code>FunSuite</code>, що викликається первинним конструктором <code>ElementSuite</code>. Ви вказуєте ім'я тесту як рядок в дужках, та сам код тестування між фігурними дужками. Тестовий код є функцією, переданою як параметр за-ім'ям до <code>test</code>, що реєструє її для подальшого виклику.</p></div>
<div class="paragraph"><p>ScalaTest інтегрований в загальні інструменти побудови (такі як sbt та Maven), та IDE (такі як IntelliJ IDEA та Eclipse). Також ви можете виконати <code>Suite</code> напряму, через застосування ScalaTest Runner, або з інтерпретатора Scala, просто викликавши на ньому <code>execute</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="k">new</span> <span class="nc">ElementSuite</span><span class="o">).</span><span class="n">execute</span><span class="o">()</span>
<span class="nc">ElementSuite</span><span class="k">:</span>
<span class="kt">-</span> <span class="kt">elem</span> <span class="kt">result</span> <span class="kt">should</span> <span class="kt">have</span> <span class="kt">passed</span> <span class="kt">width</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі стилі ScalaTest, включаючи <code>FunSuite</code>, розроблені для заохочення написання сфокусованих тестів з описовими назвами. На додаток, всі стилі генерують специфікація-подібний вихід, що може спростити комунікацію між зацікавленими сторонами. Стиль, що ви обираєте, диктує тільки те, як будуть виглядати декларації вашого тесту. Все інше в ScalaTest робить узгоджено в однаковий спосіб, не важливо, який стиль ви оберете.<span class="footnote"><br />[Більше деталей щодо ScalaTest досутпні на <a href="http://www.scalatest.org/.">3]<br /></span></a></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_3____">14.3 Інформативні звіти про збої</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тест в Лістингу 14.3 намагається створити елемент ширини 2, та стверджує, що ширина отриманого елементу, відповідно, 2. Коли твердження схибить, звіт про збій повинен включати ім'я файлу та номер рядка винного твердження, а також інформативне повідомлення про помилку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">width</span> <span class="k">=</span> <span class="mi">3</span>
<span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">org</span><span class="o">.</span><span class="n">scalatest</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="nc">TestFailedException</span><span class="k">:</span>
    <span class="err">3</span> <span class="kt">did</span> <span class="kt">not</span> <span class="kt">equal</span> <span class="err">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб запровадити описові повідомлення про помилки тверджень, ScalaTest аналізує вирази, передані в кожному виклику <code>assert</code> під час компіляції. Якщо ви бажаєте бачити навіть більш детальну інформацію щодо збоїв тверджень, ви можете використовувати ScalaTest <code>DiagrammedAssertions</code>, чиї повідомлення про помилки відображають діаграму виразу, передану до <code>assert</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">contains</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
<span class="n">org</span><span class="o">.</span><span class="n">scalatest</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="nc">TestFailedException</span><span class="k">:</span>

  <span class="kt">assert</span><span class="o">(</span><span class="kt">List</span><span class="o">(</span><span class="err">1</span><span class="o">,</span> <span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">).</span><span class="n">contains</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
         <span class="o">|</span>    <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>
         <span class="o">|</span>    <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="kc">false</span>    <span class="mi">4</span>
         <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В ScalaTest методи <code>assert</code> не роблять різницю між дійсним та очікуваним результатом в повідомленнях помилок. Вони просто вказують, що лівий операнд не дорівнює правому операнду, або показує значення на діаграмі. Якщо ви бажаєте наголосити на різниці між дійсним та очікуваним, ви можете альтернативно використовувати метод ScalaTest  <code>assertResult</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">assertResult</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">ele</span><span class="o">.</span><span class="n">width</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи такий вираз, ви вказуєте, що ви очікуєте, що код між фігурними дужками дає результат <code>2</code>. Коли код в дужках дасть результат <code>3</code>, ви побачите повідомлення "Expected 2, but got 3" в звіті про збій тесту.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте перевірити, що метод закидає очікувані виключення, ви можете використовувати метод ScalaTest <code>assertThrows</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">assertThrows</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо код між фігурними дужками закидає інше виключення, ніж очікується, або не закидає виключення взагалі, <code>assertThrows</code> терміново переривається з <code>TestFailedException</code>. Ви отримаєте корисне повідомлення про помилку в звіті, таке як:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Expected IllegalArgumentException to be thrown,
  but NegativeArraySizeException was thrown.</code></pre>
</div></div>
<div class="paragraph"><p>З іншого боку, якщо код завершується терміново з примірником переданого класу виключення, <code>assertThrows</code> буде повертатись звичайно. Якщо ви бажаєте проінспектувати далі очікуване виключення, ви можете використовувати <code>intercept</code> замість <code>assertThrows</code>. Метод <code>intercept</code> робить так саме, як <code>asassertThrows</code>, за винятком того, що коли очікуване виключення спрацьовує, <code>intercept</code> повертає його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">caught</span> <span class="k">=</span>
  <span class="n">intercept</span><span class="o">[</span><span class="kt">ArithmeticException</span><span class="o">]</span> <span class="o">{</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span>
  <span class="o">}</span>

<span class="n">assert</span><span class="o">(</span><span class="n">caught</span><span class="o">.</span><span class="n">getMessage</span> <span class="o">==</span> <span class="s">&quot;/ by zero&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коротше, твердження ScalaTest тяжко роблять для провадження корисних повідомлень, що допомагатимуть вам діагностувати та поладнати проблеми в вашому коді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_4___">14.4 Тести як специфікації</h2>
<div class="sectionbody">
<div class="paragraph"><p>В стилі тестування <em>поведінко-рушійної розробки</em> (behavior-driven development, BDD), наголос робиться на написанні зрозумілих для людей специфікацій очікуваної поведінки коду, та додавання супроводжуючих тестів, які перевіряють код на задану поведінку. ScalaTest включає декілька трейтів, що спрощує цей стиль тестування. Приклад використання такого трейту, <code>FlatSpec</code>, показаний в Лістингу 14.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.FlatSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.Matchers</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="k">with</span> <span class="nc">Matchers</span> <span class="o">{</span>
  <span class="s">&quot;A UniformElement&quot;</span> <span class="n">should</span>
       <span class="s">&quot;have a width equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;have a height equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">ele</span><span class="o">.</span><span class="n">height</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;throw an IAE if passed a negative width&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="n">an</span> <span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="n">should</span> <span class="n">be</span> <span class="n">thrownBy</span> <span class="o">{</span>
      <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.4 - Специфікація та тестування поведінки за допомогою ScalaTest <code>FlatSpec</code>.</p></div>
<div class="paragraph"><p>В <code>FlatSpec</code> ви пишете тести як твердження специфікації. Ви починаєте писати з імені для субпроекту під тестом як рядок ("A UniformElement" в Лістингу 14.4), потім <code>should</code> (або <code>must</code> або <code>can</code>), потім рядок, що вказує частину поведінки, яка очікується від предмета, потім <code>in</code>. В фігурних дужках, що ідуть далі, ви пишете код, що перевіряє вказану поведінку. В наступних реченнях ви можете писати <code>it</code> для посилання до найбільш останнього взятого предмета. Коли виконується <code>FlatSpec</code>, він буде проганяти кожне речення специфікації як тест ScalaTest. При виконанні <code>FlatSpec</code> (та інші трейти специфікацій  ScalaTest) генерує вивід, що читається як специфікація. Наприклад, ось на що буде схожий вивід, якщо ви запустите <code>ElementSpec</code> з Лістинга 14.4 в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="k">new</span> <span class="nc">ElementSpec</span><span class="o">).</span><span class="n">execute</span><span class="o">()</span>
<span class="n">A</span> <span class="nc">UniformElement</span>
<span class="o">-</span> <span class="n">should</span> <span class="n">have</span> <span class="n">a</span> <span class="n">width</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">passed</span> <span class="n">value</span>
<span class="o">-</span> <span class="n">should</span> <span class="n">have</span> <span class="n">a</span> <span class="n">height</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">passed</span> <span class="n">value</span>
<span class="o">-</span> <span class="n">should</span> <span class="k">throw</span> <span class="n">an</span> <span class="nc">IAE</span> <span class="k">if</span> <span class="n">passed</span> <span class="n">a</span> <span class="n">negative</span> <span class="n">width</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.4 також ілюструє домен-специфічну мову (domain-specific language, DSL) матчерів в ScalaTest. Міксуючи трейт <code>Matchers</code>, ви можете написати твердження, що читаються майже як природна мова. ScalaTest провадить багато матчерів в своєму DSL, та також дозволяє вам визначати нові матчери з власними повідомленнями. Матчери, показані в Лістингу 14.4 включають синтаксис <code>should be</code> та <code>an [...] should be thrownBy { ...}</code>. Як альтернатива, ви можете зміксувати <code>MustMatchers</code>, якщо ви бажаєте <code>must</code> замість <code>should</code>. Наприклад, міксування <code>MustMatchers</code> дозволить вам писати вирази, такі як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="n">must</span> <span class="n">be</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="n">map</span> <span class="n">must</span> <span class="n">contain</span> <span class="n">key</span> <span class="sc">&#39;c&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо останнє твердження схибить, ви побачите повідомлення про помилку, подібне до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Map</span><span class="o">(</span><span class="sc">&#39;a&#39;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">did</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">key</span> <span class="sc">&#39;c&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тестовий фреймворк specs2 є інструментом з відкритим кодом, написаний на Scala Eric Torreborre, також підтримує стиль тестування BDD, але з іншим синтаксисом. Наприклад, ви можете використати specs2 для написання тесту, показаного в Лістингу 14.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.specs2._</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">object</span> <span class="nc">ElementSpecification</span> <span class="k">extends</span> <span class="nc">Specification</span> <span class="o">{</span>
  <span class="s">&quot;A UniformElement&quot;</span> <span class="n">should</span> <span class="o">{</span>
    <span class="s">&quot;have a width equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
      <span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="n">must</span> <span class="n">be_==</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="s">&quot;have a height equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
      <span class="n">ele</span><span class="o">.</span><span class="n">height</span> <span class="n">must</span> <span class="n">be_==</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="s">&quot;throw an IAE if passed a negative width&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">must</span>
      <span class="n">throwA</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.5 - Специфікація та тестування поведінки за допомогою фреймворка specs2.</p></div>
<div class="paragraph"><p>Як і ScalaTest, specs2 провадить DSL. Ви можете бачити деякі приклади матчерів specs2 в дії в Лістингу 14.5 в рядках, що містять <code>must be_==</code> та <code>must throwA</code>.<span class="footnote"><br />[Ви можете завантажити specs2 на <a href="http://specs2.org/">http://specs2.org/</a>.]<br /></span> Ви можете використовувати specs2 окремо, але він також інтегрований з ScalaTest та JUnit, так що ви можете використати тести specs2 з ціма інструментами, також.</p></div>
<div class="paragraph"><p>Одна з великих ідей BDD в тому, що тести можуть бути використані для спрощення комунікації між людьми, які визначають, що програмне забезпечення має робити, людьми, що реалізують програмне забезпечення, та людьми, що визначають, коли програма завершена та робить. Хоча любий зі стилів ScalaTest або specs2 можуть бути використаний в цій манері, ScalaTest <code>FeatureSpec</code> навмисне розроблений для цього. Лістинг 14.6 показує приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest._</span>

<span class="k">class</span> <span class="nc">TVSetSpec</span> <span class="k">extends</span> <span class="nc">FeatureSpec</span> <span class="k">with</span> <span class="nc">GivenWhenThen</span> <span class="o">{</span>

  <span class="n">feature</span><span class="o">(</span><span class="s">&quot;TV power button&quot;</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">scenario</span><span class="o">(</span><span class="s">&quot;User presses power button when TV is off&quot;</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Given</span><span class="o">(</span><span class="s">&quot;a TV set that is switched off&quot;</span><span class="o">)</span>
      <span class="nc">When</span><span class="o">(</span><span class="s">&quot;the power button is pressed&quot;</span><span class="o">)</span>
      <span class="nc">Then</span><span class="o">(</span><span class="s">&quot;the TV should switch on&quot;</span><span class="o">)</span>
      <span class="n">pending</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.6 - Використання тестів для спрощення комунікації між зацікавленими сторонами.</p></div>
<div class="paragraph"><p>FeatureSpec розроблений для направлення спілкування щодо потреб до програмних систем: ви маєте ідентифікувати специфічні можливості, потім вказати ці можливості в термінах сценаріїв. Методи <code>Given</code>, <code>When</code> та <code>Then</code> (запроваджені трейтом <code>GivenWhenThen</code>) можуть допомогти сфокусувати обговорення на особливостях окремих сценаріїв. Виклик <code>pending</code> в кінці вказує, що ані тести, вні справжня поведінка не були реалізовані, тільки специфікація. Як тільки всі тести та задана поведінка будуть реалізовані, тести будуть пройдені, та вимоги можуть вважатись задовільненими.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_5____">14.5 Базоване на властивостях тестування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Інший корисний інструмент тестування для Scala є ScalaCheck, фреймворк з відкритим кодом, написаний Rickard Nilsson. ScalaCheck дозволяє вам задавати властивості, яким має підкорюватись код під тестуванням. Для кожної властивості ScalaCheck буде генерувати дані, та виконувати твердження, що перевіряють, чи властивість буде справджуватись. Лістинг 14.7 показує приклад використання ScalaCheck з ScalaTest <code>WordSpec</code>, що міксує трейт <code>PropertyChecks</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.WordSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.prop.PropertyChecks</span>
<span class="k">import</span> <span class="nn">org.scalatest.MustMatchers._</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">WordSpec</span> <span class="k">with</span> <span class="nc">PropertyChecks</span> <span class="o">{</span>
  <span class="s">&quot;elem result&quot;</span> <span class="n">must</span> <span class="o">{</span>
    <span class="s">&quot;have passed width&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">whenever</span> <span class="o">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">width</span> <span class="n">must</span> <span class="n">equal</span> <span class="o">(</span><span class="n">w</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.7 - Написання властивість-базованих тестів за допомогою ScalaCheck.</p></div>
<div class="paragraph"><p><code>WordSpec</code> є класом стилю ScalaTest. Трейт <code>PropertyChecks</code> провадить декілька методів <code>forAll</code>, що дозволяють вам міксувати властивість-базовані тести з традиційними твердження-базованими або матчер-базованими тестами. В цьому прикладі ми перевіряємо властивість, якій має підкорюватись фабрика <code>elem</code>. Властивості ScalaCheck виражені як функціональне значення, що приймає як параметри дані, потрібні для твердження властивості. Ці дані будуть згенеровані ScalaCheck. У властивості, показаній в Лістингу 14.7, дані є ціле на ім'я <code>w</code>, що представляє ширину. В тілі функції ви бачите цей код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">whenever</span> <span class="o">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">width</span> <span class="n">must</span> <span class="n">equal</span> <span class="o">(</span><span class="n">w</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Твердження <code>whenever</code> вказує, що коли ліва частина вираза є <code>true</code>, вираз зправа має також бути <code>true</code>. Так що в цьому випадку, вираз в блоці має бути <code>true</code>, коли <code>w</code> є більше ніж <code>0</code>. Права частина виразу в цьому випадку буде давати <code>true</code>, якщо ширина, передана до фабрики <code>elem</code> є тою самою, що і <code>width</code> для Element, що повертається з фабрики.</p></div>
<div class="paragraph"><p>З цією малою кількістю коду ScalaCheck буде генерувати, можливо, сотні значень для керування тестуванням кожного з них, шукаючи значення, для якого властивість не справджується. Якщо властивість дає <code>true</code> для кожного значення, що пробує ScalaCheck, тест буде пройдений. Інакше тест завершиться несподівано з <code>TestFailedException</code>, що містить інформацію, включаючи значення, яке спричинило збій.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_6____">14.6 Організація та виконання тестів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кожний фреймворк, згаданий в цій главі, провадить деякий механізм для організації та виконання тестів. В цьому розділі ми надамо швидкий огляд підходу ScalaTest. Щоб отримати повну історію по кожному з ціх фреймворків, вам треба проконсультуватись з їх документацією.</p></div>
<div class="paragraph"><p>В ScalaTest ви організуєте великі тестові сюїти, вкладаючи <code>Suite</code> в <code>Suite</code>. Коли <code>Suite</code> виконується, вона буде виконувати свої вкладені сюїти, так само, як і їх тести. Вкладені <code>Suite</code> будуть в свою чергу виконувати свої вкладені <code>Suite</code>, і так далі. Таким чином, велика сюїта представлена як дерево об'єктів <code>Suite</code>. Коли ви виконуєте кореневу  <code>Suite</code> в дереві, всі сюїти в дереві будуть виконані.</p></div>
<div class="paragraph"><p>Ви можете вкладувати сюїти іручну або автоматично. Щоб вкладати вручну, ви або перекриваєте метод <code>nested</code> для вашої <code>Suite</code>, або передаєте всі <code>Suite</code>, що ви бажаєте вкласти, в конструктор класу <code>Suites</code>, який ScalaTest провадить саме для цієї цілі. Щоб вкласти сюїти автоматично, ви провадите імена пакунків до ScalaTest Runner, що буде визначати <code>Suite</code> автоматично, вкладати їх під кореневою <code>Suite</code>, та виконувати кореневу <code>Suite</code>.</p></div>
<div class="paragraph"><p>Ви можете визвати застосування ScalaTest Runner з командного рядка або через інструмент побудови, такий як <code>sbt</code>, <code>maven</code> або <code>ant</code>. Найпростіший спосіб викликати Runner з командного рядка через застосування <code>org.scalatest.run</code>. Це застосування очікує повністю кваліфіковане ім'я тестованого класу. Наприклад, щоб виконати тестовий клас, показаний в Лістингу 14.6, ви маєте компілювати його такою командою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="n">cp</span> <span class="n">scalatest</span><span class="o">.</span><span class="n">jar</span> <span class="nc">TVSetSpec</span><span class="o">.</span><span class="n">scala</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ви можете виконати його:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala -cp scalatest.jar org.scalatest.run TVSetSpec</code></pre>
</div></div>
<div class="paragraph"><p>Малюнок 14.1 - Вивід <code>org.scalatest.run</code>.</p></div>
<div class="paragraph"><p>За допомогою <code>-cp</code> ви покладаєте файл ScalaTest JAR на шлях до класів. (При завантаженні ім'я JAR файла буде включати номери версій вбудованих Scala та ScalaTest.) Наступний токен, <code>org.scalatest.run</code>, є повністю кваліфікованим іменем застосування. Scala буде виконувати це застосування, та передасть залишок токенів як аргументи командного рядка. Аргумент <code>TVSetSpec</code> вказує на сюїту, що треба виконати. Результат показаний на Малюнку 14.1.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_7_">14.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили приклади міксування тверджень напряму в промисловий код, так само, як і написання їх назовні, в тестах. Ви бачили, що як Scala програміст, ви можете отримати переваги від популярних тестових інструментів від спільноти Java, таких, як JUnit та TestNG, так само, як і від новіших інструментів, розроблених спеціально для Scala, таких як ScalaTest, ScalaCheck, та specs2. Обоє, твердження в коді та зовнішні тести можуть допомогти вам досягти цілі щодо якості вашого коду. Ми відчуваємо, що ці технології досить важливі, щоб виправдати короткий відступ від Scala туторіала, що представляє ця глава. Однак в наступній главі ми повернемось до туторіала по мові, та розглянемо дуже корисний аспект Scala: співпадіння шаблонів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-17 22:49:01 EET
</div>
</div>
</body>
</html>
