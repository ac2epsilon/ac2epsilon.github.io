include::headers.adoc[]

Глава 31
--------

Комбінування Scala та Java
==========================

Scala код часто використовується в тандемі з великими Java програмами та фреймворками. Оскільки Scala високо сумісна з Java, більшість часу ви можете комбінувати мови без великих турбот. Наприклад, стандартні фреймворки, такі як `Swing`, `Servlets` та `JUnit` відомо роблять досить гарно зі Scala. Тим не менше, час від часу ви будете натрапляти на якісь проблеми, комбінуючи Java та Scala.

Ця глава описує два аспекти комбінування Java та Scala. Перше, вона описує, як Scala транслюється до Java, що особливо важливо, якщо ви викликаєте Scala код з Java. Друге, вона дискутує використання Java анотацій в Scala, важлива можливість, якщо ви бажаєте використовувати Scala з існуючим Java фреймворком.

31.1 Використання Scala з Java
------------------------------
Більшість часу ви можете думати про Scala на рівні джерельного коду. Однак ви будете мати багатше розуміння того, як робить система, якщо ви будете дещо знати про її трансляцію. Більше того, якщо ви викликаєте Scala код з Java, вам буде треба знати, як Scala код виглядає з точки зору Java.

Загальні правила
~~~~~~~~~~~~~~~~
Scala реалізована як трансляція до стандартного байткоду Java. Наскільки це можливо, можливості Scala відображуються напряму на еквівалентні Java можливості. Наприклад, Scala класи, методи, рядки та виключення всі компілюються до таких самих в Java байткоді, як і колеги з Java.

Щоб зробити це можливим, знадобився подекуди непростий вибір дизайну Scala. Наприклад, це могло б бути гарним, щоб розрішувати перевантажені методи під час виконання, використовуючи типи часу виконання, скоріше ніж під час компіляції. Однак такий дизайн буде стикатись з аналогічним в Java, що зробить значно складнішим змішувати Java та Scala. В цьому випадку Scala залишається з розрішенням перевантаження від Java, і, таким чином, Scala методи та виклики методів можуть напряму відображатись на Java методи та виклики методів.

Scala має власний дизайн для інших можливостей. Наприклад, трейти не мають еквівалента в Java. Подібно до цього, хоча обоє, Scala та Java мають дженерік типи, деталі обох систем конфліктують. Для можливостей мови, як ці, код Scala не може напряму відобразитись на Java конструкції, так що вони мають бути закодовані з використанням якоїсь комбінації структур, що має Java.

Для ціх можливостей, що відображаються непрямо, кодування не фіксоване. Є постійне зусилля зробити трансляцію такою простою, як це можливо, так що на час, коли ви це читаєте, деякі деталі можуть бути різні, відносно часу написання. Ви можете знайти, яку трансляцію використовує ваш поточний компілятор Scala, продивившись `.class` файли за допомогою інструментів, як `javap`.

Такі головні правила. Тепер розглянемо деякі особливі випадки.

Типи значень
~~~~~~~~~~~~
Тип значення, як `Int`, може бути трансльований до Java в два різні способи. Коли можливо, компілятор транслює `Scala` `Int` до `Java` `int`, щоб отримати кращу продуктивність. Однак іноді це не можливо, оскільки компілято не впевнений, чи він транслює `Int`, або деякий інший тип даних. Наприклад, зокрема `List[Any]` може містити тільки `Int`, але компілятор не має способу бути впевненим.

В таких випадках, коли компілятор невпевнений, чи об'єкт є значенням або ні, компілятор використовує об'єкти та покладається на класи огортки. Наприклад, класи огорток, такі як `java.lang.Integer` дозволяють типам значень бути огорнутими в Java об'єкт, і так оброблятись кодом, що потребує об'єктів.footnote:[Реалізація типів значень була обговорена в деталях в Розділі 11.2.]

Синглтон об'єкти
~~~~~~~~~~~~~~~~
Java не має точного еквіваленту до синглтон об'єктів, але вона має статичні методи. Трансляція Scala синглтон об'єктів використовує комбінацію статичних методів та методів примірника. Для кожного об'єкта синглтона Scala, компілятор буде створювати Java клас для об'єкта з доданим до нього в кінці знака долара. Для об'єкта синглтона на ім'я `App` компілятор продукує Java клас на ім'я `App$`. Цей клас має всі методи та поля об'єкта синглтона Scala. Клас Java також має єдине статичне поле та ім'я `MODULE$`, що зберігає один примірник класу, що створений під час виконання.

Як повний приклад, уявімо, що ви компілюєте наступний синглтон об'єкт:
[source,scala]
----
object App {
  def main(args: Array[String]) = {
    println("Hello, world!")
  }
}
----
Scala буде генерувати Java клас `App$` з наступними полями та методами:
[source,scala]
----
$ javap App$
public final class App$ extends java.lang.Object
implements scala.ScalaObject{
  public static final App$ MODULE$;
  public static {};
  public App$();
  public void main(java.lang.String[]);
  public int $tag();
}
----
Це трансляція для загального використання. Важливий особливий випадок коли ви маєте "самостійний" синглтон об'єкт, що не іде з класом з таким самим ім'ям. Наприклад, ви можете мати об'єкт синглтон на ім'я `App`, але не мати жодного класу на ім'я `App`. В цьому випадку компілятор буде створювати Java клас на ім'я `App`, що має статичний метод перенаправлювач для кожного метода об'єкта синглтоона Scala:
[source,scala]
----
$ javap App
Compiled from "App.scala"
public final class App extends java.lang.Object{
  public static final int $tag();
  public static final void main(java.lang.String[]);
}
----
Для контрасту, якщо ви мали клас на ім'я `App`, Scala буде ствоорювати відповідний Java клас `App` для зберігання всіх членів класу `App`, що ви визначили. В цьому випадку він не буде додавати жодних методів перенаправлення для так-само-названого об'єкта синглтона, та Java код буде мати доступ до синглтона через поле `MODULE$`.

Трейти як інтерфейси
--------------------
Компіляція любого трейта створює Java інтерфейс з тим самим ім'ям. Цей інтерфейс корисний як Java тип, та він дозволяє вам викликати методи на об'єктах Scala через змінні цього типу.

Реалізація трейта в Java є інша історія. В загальному випадку це не принципово; однак один особливий випадок важливий. Якщо ви робите Scala трейт, що включає тільки абстрактні методи, тоді цей трейт буде трансльований напряму в Java інтерфейс, без іншого коду, про який треба турбуватись. В основному це означає, що ви можете написати Java інтерфейс в Scala синтаксисі, якщо побажаєте.

31.2 Анотації
-------------
Система загальних анотацій Scala обговорювалась в Главі 27. Цей розділ обговорює Java-специфічні аспекти анотацій.

Додаткові ефекти від стандартних анотацій
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Декілька анотацій призводять до того, що компілятор видає додаткову інформацію, коли націлений на Java платформу. Коли компілятор бачить таку анотацію, він спочатку обробляє її відповідно до загальним правилам Scala, і потім він робить дещо додаткове для Java.

*Застаріння* Для любого метода або класа, відміченого як `@deprecated`, компілятор буде додавати власну анотацію Java до видаваємого коду. Завдяки цьому Java компілятори можуть видивати попередження, коли Java код отримує застарілі Scala методи.

*Мінливі поля* Подібним чином, любе поле, відмічене як `@volatile` в Scala отримує Java модифікатор `volatile` в виданому коді. Таким чином, мінливі поля в Scala поводяться точно у відповідності до Java сементики, та доступ до мінливих полів відбувається в послідовності точно відповідно до правил, заданих для мінливих полів в Java моделі пам'яті.

Сериалізація
~~~~~~~~~~~~
Три стандартні анотації сериалізації Scala всі транслюються до Java еквівалентів.

Клас `@serializable` має доданий до нього Java інтерфейс `Serializable`.

Анотація `@SerialVersionUID(1234L)` конвертується на наступне визначення поля Java:
[source,scala]
----
// Маркер версії серіалізації Java
private final static long SerialVersionUID = 1234L
----
Люба змінна, відмічена `@transient` отримує Java модифікатор `transient`.

Закидання виключень
~~~~~~~~~~~~~~~~~~~
Scala не перевіряє, що закинуті виключення перехоплюються. Таким чином Scala не має еквіваленту до Java декларації `throws` на методах. Всі Scala методи транслюються до Java методів, що не декларують закидання виключень.footnote:[Причина, з якох все це робить, в тому, що перевіряч байткоду Java взагалі не перевіряє декларацій! Компілятор Java перевіряє, але не перевіряч.]

Причина, чому ця можливість видалена зі Scala в тому, що досвід Java з цім був не дуже позитивний. Оскільки анотовані методи зі `throws` спричиняли жорсткий безлад, дуже багато розробників писали код, що ковтає і відкидає виключення, тільки щоб зробити компіляцію коду без додавання ціх всіх тверджень `throws`. Можливо вони мали намір покращити обробку виключень пізніше, але досвід показує, що всі надто часто придушені строками програмісти ніколи не будуть повертатись та додавати потрібну обробку виключень. Перекручений результат в тому, що ця можливість з кращих намірів часто завершувалась створенням меньш надійного коду. Велика кількість промислового Java коду ковтає та приховує рантайм виключення, і причиною робити це є задоволення компілятора.

Однак іноді, коли робиться інтерфейс до Java, вам може знадобитись написати Scala код, який має дружні до Java анотації, що описують, які виключення ваш метод буде закидати. Наприклад, кожний метод в віддаленому інтерфейсі RMI потребує зазначити `java.io.RemoteException` в твердженні `throws`. Таким чином, якщо ви бажаєте написати віддалений інтерфейс RMI як Scala трейт з абстрактними методами, вам знадобиться перелічити `RemoteException` в твердженні `throws` для ціх методів. Щоб досягти цього, все що вам треба зробити це відмітити ваші методи анотацією `@throws`. Наприклад, Scala клас, показаний в Лістингу 31.1 має метод, позначений що закидає `IOException`.
[source,scala]
----
import java.io._
class Reader(fname: String) {
  private val in =
    new BufferedReader(new FileReader(fname))
  @throws(classOf[IOException])
  def read() = in.read()
}
----
Лістинг 31.1 - Метод Scala, що декларує Java твердження `throws`.

Ось як це виглядає з боку Java:
[source,scala]
----
$ javap Reader
Compiled from "Reader.scala"
  public class Reader extends java.lang.Object implements
scala.ScalaObject{
  public Reader(java.lang.String);
  public int read() throws java.io.IOException;
public int $tag();
}
$
----
Зауважте, що метод `read` вказує за допомогою твердження `Java` `throws`, що він може закидати `IOException`.

Java анотації
~~~~~~~~~~~~~
Існуючі анотації з Java фреймворків можуть напряму використовуватись в Scala коді. Любий Java фреймворк буде бачити анотації, що ви пишете, так само, якби ви писали це в Java.

Широка різноманіть Java пакунків використовує анотації. Як приклад, розглянемо JUnit 4. JUnit це фреймворк для написання та виконання автоматизованих тестів. Остання версія, JUnit 4, використовує анотації для вказання, які частини вашого коду є тестами. Ідея в тому, що ви пишете багато тестів для вашого коду, та потім ви використовуєте ці тести коли змінюєте свій код. Таким чином, якщо ваші зміни додають нову ваду, один з ціх тестів буде хибити, і ви безпосередньо це з'ясуєте.

Написання тестів просте. Ви просто пишете метод в класі верхнього рівня, що виконує ваш код, та ви використовуєте анотацію для відмітки вашого метода як тесту. Це виглядає так:
[source,scala]
----
import org.junit.Test
import org.junit.Assert.assertEquals

class SetTest {
  @Test
  def testMultiAdd = {
    val set = Set() + 1 + 2 + 3 + 1 + 2 + 3
    assertEquals(3, set.size)
  }
}
----
Метод `testMultiAdd` є тестом. Цей тест дадає декілька елементів до множини, та переконується, що кожний доданий тільки один раз. Метод `assertEquals`, що іде як частина JUnit API, перевіряє, що два його аргументи рівні. Якщо вони різні тест схибить. В цьому випадку тест перевіряє, що повторюване додавання тих самих чисел не збільшує розмір множини.

Тест відмічений з використанням анотації `org.junit.Test`. Зауважте, що ця анотація була імпортована, так що на неї посилається як просто `@Test`, замість більш заплутаного `@org.junit.Test`.

Ось і все тут про це. Тест може бути виконаний з використанням любого виконувача JUnit. Ось як він виконується за допомогою виконувача з командного рядка:
[source,scala]
----
$ scala -cp junit-4.3.1.jar:. org.junit.runner.JUnitCore SetTest
JUnit version 4.3.1
.
Time: 0.023
OK (1 test)
----

Написання ваших власних анотацій
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Щоб зробити анотацію, що видима для Java рефлексії, ви маєте використовувати Java нотацію та компілювати за допомогою `javac`. Для цього випадку написання анотацій в Scala не виглядає корисним, так що стандартний компілятор не підтримує його. Причина в тому, що підтримка Scala без сумніву швидко схибить на всіх можливостях анотацій Java, та більше, Scala буде мати одного дня власну рефлексію, в якому випадку ви будете бажати мати доступ до Scala анотацій через Scala рефлексію.

Ось приклад анотації:
[source,java]
----
import java.lang.annotation.*; // Це Java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Ignore { }
----
Після компіляції цього за допомогою javac ви можете використовувати анотацію таким чином:
[source,scala]
----
object Tests {
  @Ignore
  def testData = List(0, 1, -1, 5, -5)

  def test1 = {
    assert(testData == (testData.head :: testData.tail))
  }

  def test2 = {
    assert(testData.contains(testData.head))
  }
}
----
В цьому прикладі `test1` та `test2` вважаються тестовими методами, але `testData` повинен бути проігнорований, навіть незважаючи що його ім'я починається на `"test"`. Щоб бачити, коли ці анотації присутні, ви можете використовувати Java API рефлексії. Ось код приклада, що показує, як це робить:
[source,scala]
----
for {
  method <- Tests.getClass.getMethods
  if method.getName.startsWith("test")
  if method.getAnnotation(classOf[Ignore]) == null
} {
  println("found a test method: " + method)
}
----
Тут рефлективні методи `getClass` та `getMethods` використовуються для інспекції всіх полів класу входящого об'єкту. Це звичайні методи рефлексії. Специфічна до анотацій частина в використанні метода `getAnnotation`. Багато об'єктів рефлексії мають метод `getAnnotation` для пошуку анотацій специфічного типу. В цьому випадку код шукає анотацію нашого нового типу `Ignore`. Оскільки це Java API, успіх вказує або що результат є `null`, або дійсний об'єкт анотації.

Ось цей код в дії:
[source,scala]
----
$ javac Ignore.java
$ scalac Tests.scala
$ scalac FindTests.scala
$ scala FindTests
found a test method: public void Tests$.test2()
found a test method: public void Tests$.test1()
----
Побічно зауважте, що методи в класі `Tests$`, замість класу `Tests`, якщо дивитись через Java рефлексію. Як описане на початку глави, реалізація сенглтон об'єктів Scala, покладається в Java клас з доданим знаком долару в кінці імені. В цьому випадку реалізація Tests є в Java класі `Tests$`.

Будьте уважні, коли ви використовуєте Java анотації, ви маєте робити з їх обмеженнями. Наприклад, ви можте використовувати тільки константи, не вирази, в аргументах анотацій. Ви можте підтримувати `@serial(1234)`, але не `@serial(x * 2)`, оскільки `x * 2` не є константою.

31.3 Підстановочні типи
-----------------------
Всі Java типи мають Scala еквівалент. Це потрібно, так щоб цей Scala код міг отримувати доступ до любих легальних Java класів. Більшість часу трансляція прямолінійна. `Pattern` в Java є `Pattern` в Scala, та `Iterator<Component>` в Java є `Iterator[Component]` в Scala. Однак для деяких випадків типів Scala, що ви бачили до цього, недостатньо. Що ви будете робити з підстановочними типами Java, як `Iterator<?>` або `Iterator<? extends Component>`? Що ми можемо робити щодо сирих типів, як `Iterator`, де параметр типу пропущений? Для підстановочних типів Java та сирих типів Scala використовує додатковий різновид типу, що також називається підстановочним типом.

Підстановочні типи записуються з використання синтаксису замінника, так само як скорочені функціональні літерали, описані в Розділі 8.5. В скороченнях для функціональних літералів ви можете використовувати підкреслення (`_`) замість виразу; наприклад, `(_ + 1)` є те саме, що `(x => x + 1)`. Підстановочні типи використовують ту саму ідею, тільки для типів замість виразів. Якщо ви пишете `Iterator[_]`, тоді підкреслення заміняє тип. Такий тип представляє `Iterator`, де тип елементу невідомий.

Ви також можете вставити верню та нижню межі, коли використовуєте цей синтаксис замінника. Просто додайте межу після підкреслення, використовуючи той самий `<:` синтаксис, що використовується для параметрів типу (Розділ 19.8 та Розділ 19.5). Наприклад, тип `Iterator[_ <: Component]` є ітератором, де елемент типу невідомий, але який би тип це не був, він має бути субтипом `Component`.

Ось як ви пишете підстановочний тип, але як його використовувати? В простих випадках ви можете ігнорувати підстановку, та викликати методи на базовому типі. Наприклад, уявімо, що ви маєте наступний Java клас:
[source,java]
----
// Це Java клас з підстановками класів
public class Wild {
  public Collection<?> contents() {
    Collection<String> stuff = new Vector<String>();
    stuff.add("a");
    stuff.add("b");
    stuff.add("see");
    return stuff;
  }
}
----
Якщо ви отримаєте доступ до цього в Scala коді, ви побачите, що він має підстановочний тип:
[source,scala]
----
scala> val contents = (new Wild).contents
contents: java.util.Collection[_] = [a, b, see]
----
Якщо ви бажаєте з'ясувати, скільки елементів в цій колекції, ви можете просто ігнорувати підстановочну частину, та просто викликати метод `size` як звичайно:
[source,scala]
----
scala> contents.size()
res0: Int = 3
----
В більш складних випадках підстановочні типи можуть бути більш незграбними. Оскільки підстановочний тип не має імені, немає способу використати його в двох різних місцях. Наприклад, уявімо, що ви бажаєте створити змінну множину Scala, та ініціалізувати її елементами `contents`:
[source,scala]
----
import scala.collection.mutable
val iter = (new Wild).contents.iterator
val set = mutable.Set.empty[???] // який тут тип?
while (iter.hasMore)
  set += iter.next()
----
Проблема виникає в третьому рядку. Немає способу назвати тип елементів в Java колекції, так що ви не можете написати задовільний тип для множини. Щоб обробити цей різновид проблем, ось два трюки, які ви можете розглянути:

1. Коли передаєте підстановочний тип в метод, дайте параметр до методу для замінника. Тепер ви маєте ім'я для типу, так що можете використовувати його багато разів, як вам треба.

2. Замість повертання підстановочного типу з методу, поверніть об'єкт, що має абстрактні члени для кожного з типів замінників. (Дивіться Главу 20 для інформації по абстрактних членах.)

Використовуючи обоє ці трюки разом, попередній код може бути записаний наступним чином:
[source,scala]
----
import scala.collection.mutable
import java.util.Collection
abstract class SetAndType {
  type Elem
  val set: mutable.Set[Elem]
}

def javaSet2ScalaSet[T](jset: Collection[T]): SetAndType = {
  val sset = mutable.Set.empty[T] // тепер T може бути названий!
  val iter = jset.iterator
  while (iter.hasNext)
    sset += iter.next()

  return new SetAndType {
    type Elem = T
    val set = sset
  }
}
----
Ви можете бачити, чому Scala код звичайно не використовує підстановочні типи. Щоб зробити щось виключне з ними, ви скоріше перетворюєте їх на використання абстрактних членів. Так що так само гарно ви можете починати з абстрактних членів.

31.4 Компіляція Scala та Java разом
-----------------------------------
Звичайно, коли ви компілюєте Scala код, що залежить від Java коду, спочатку ви будуєте Java код до `class` файлів. Потім ви будуєте Scala код, покладаючи Java class файли на `classpath`. Однак цей підхід не працює, якщо Java код має посилання назад на Scala код. В такому випадку не має значення, в якому порядку ви компілюєте ваш код, одна сторона або інша буде мати незадовільнені зовнішні посилання. Ці ситуації не є рідкістю; це відбувається частіше всього в Java проекті, де ви заміняєте один джерельний Java файл на джерельний файл Scala.

Щоб підтримувати такі побудови, Scala дозволяє компіляцію джерельного коду Java, так само, як Java `class` файлів. Все що вам треба зробити, це покласти Java файли на командний рядок, так само, як вони б були Scala файлами. Scala компілятор не буде компілювати ці Java файли, але він буде сканувати їх, щоб побачити, що вони містять. Щоб використати цю можливість, ви спочатку компілюєте Scala код з використанням джерельних файлів Java, та потім компілюєте Java код з використанням class файлів Scala.

Ось типова послідовність команд:
[source,scala]
----
$ scalac -d bin InventoryAnalysis.scala InventoryItem.java \
Inventory.java

$ javac -cp bin -d bin Inventory.java InventoryItem.java \
InventoryManagement.java

$ scala -cp bin InventoryManagement
Most expensive item = sprocket($4.99)
----

31.5 Інтеграція Java 8 в Scala 2.12
-----------------------------------
Java 8 додає декілька покращень до мови Java та байткодів, з чого Scala отримує переваги в своєму релізі 2.12.footnote:[Scala 2.12 потребує Java 8, так щоб вона могла отримувати переваги від можливостей Java 8.] Використовуючи нові можливості Java 8, компілятор Scala 2.12 може генерувати маньші класи та `jar` файли, та покращити бінарну сумісність трейтів.

Лямбда вирази та "SAM" типи
~~~~~~~~~~~~~~~~~~~~~~~~~~~
З перспективи Scala програміста, найбільш помітне розширення в Scala 2.12, пов'язане з Java 8 є те, що функціональні літерали Scala можуть бути використані як лямбда вирази Java 8, як більш стисла форма для виразів примірників анонімних класів. Щоб передати поведінку до метода, до появи Java 8 Java програмісти часто визначали примірникі анонімних внутрішніх класів, як тут:
[source,scala]
----
JButton button = new JButton(); // Це Java
button.addActionListener(
  new ActionListener() {
    public void actionPerformed(ActionEvent event) {
      System.out.println("pressed!");
    }
  }
);
----
В цьому прикладі анонімний примірник `ActionListener` створюється та передається до `addActionListener` в Swing `JButton`. Коли користувач клацає на кнопці, Swing буде викликати метод `actionPerformed` на цьому примірнику, що буде друкувати "pressed!".

В Java 8 лямбда вираз може використовуватись будь-де, де потрібен примірник класу або інтерфейсу, що містить тільки один абстрактний метод (SAM). `ActionListener` є такий інтерфейс, оскільки він містить один абстрактний метод, `actionPerformed`. Таким чином може бути лямбда для реєстрації слухача дій на кнопці Swing. Ось приклад:
[source,scala]
----
JButton button = new JButton(); // Це Java 8
button.addActionListener(
  event -> System.out.println("pressed!")
);
----
В Scala ви можете також використовувати анонімний внутрішній клас в тій же ситуації, але ви можете краще використати функціональний літерал, ось так:
[source,scala]
----
val button = new JButton
button.addActionListener(
  _ => println("pressed!")
)
----
Як ви вже бачили в Розділі 21.1, ви можете підтримувати такий стиль кодування, через визначення неявної конверсії від функціонального типу `ActionEvent => Unit` до `ActionListener`.

Scala 2.12 дозволяє використання функціональних літералів в цьому випадку, навіть за відсутності такого неявного перетворення. Як з Java 8, Scala 2.12 буде дозволяти функціональні типи для використання там, де потрібен примірник класу або трейту, що декларує один абстрактний метод (SAM). Це робить з любим SAM в Scala 2.12. Наприклад, ви можете визначити трейт `Increaser` з одним абстрактним методом, `increase`:
[source,scala]
----
scala> trait Increaser {
  def increase(i: Int): Int
}
defined trait Increaser
----
Потім ви можете визначити метод, що приймає `Increaser`:
[source,scala]
----
scala> def increaseOne(increaser: Increaser): Int =
increaser.increase(1)
increaseOne: (increaser: Increaser)Int
----
Щоб викликати ваш новий метод, ви можете передати анонімний примірник до трейту `Increaser`, ось так:
[source,scala]
----
scala> increaseOne(
  new Increaser {
    def increase(i: Int): Int = i + 7
  }
)
res0: Int = 8
----
Однак в Scala 2.12 ви можете альтернативно просто використати функціональний літерал, оскільки `Increaser` є SAM типом:
[source,scala]
----
scala> increaseOne(i => i + 7) // Scala 2.12
res1: Int = 8
----

Використання Java 8 Stream зі Scala 2.12
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Java Stream є функціональною структурою даних, що пропонує метод, що сприймає `java.util.function.IntUnaryOperator`. Зі Scala ви можете викликати `Stream.map` для інкременту кожного елемента в `Array`, ось так:
[source,scala]
----
scala> import java.util.function.IntUnaryOperator
import java.util.function.IntUnaryOperator

scala> import java.util.Arrays
import java.util.Arrays

scala> val stream = Arrays.stream(Array(1, 2, 3))
stream: java.util.stream.IntStream = ...

scala> stream.map(
  new IntUnaryOperator {
    def applyAsInt(i: Int): Int = i + 1
  }
).toArray
res3: Array[Int] = Array(2, 3, 4)
----
Однак завдяки тому, що `IntUnaryOperator` є SAM типом, ви можете в Scala 2.12 викликати його більш стисло за допомогою функціонального літерала:
[source,scala]
----
scala> val stream = Arrays.stream(Array(1, 2, 3))
stream: java.util.stream.IntStream = ...

scala> stream.map(i => i + 1).toArray // Scala 2.12
res4: Array[Int] = Array(2, 3, 4)
----
Зауважте, що тільки функціональні літерали будуть адаптовані до SAM типів, не довільні вирази, що мають функціональний тип. Наприклад, розглянемо наступну `val`, `f`, що має тип `Int => Int`:
[source,scala]
----
scala> val f = (i: Int) => i + 1
f: Int => Int = ...
----
Хоча `f` має той самий тип, що і функціональний літерал, переданий до `stream.map` до цього, ви не можете використовувати `f` там, де потрібний `IntUnaryOperator`:
[source,scala]
----
scala> val stream = Arrays.stream(Array(1, 2, 3))
stream: java.util.stream.IntStream = ...

scala> stream.map(f).toArray
<console>:16: error: type mismatch;
found   : Int => Int
required: java.util.function.IntUnaryOperator
      stream.map(f).toArray
                 ^
----
Щоб використати `f`, ви можете явно викликати її як функціональний літерал, ось так:
[source,scala]
----
scala> stream.map(i => f(i)).toArray
res5: Array[Int] = Array(2, 3, 4)
----
Або ви можете анотувати `f` з `IntUnaryOperator`, типом, що очікує `Stream.map`, коли ви визначаєте `f`:
[source,scala]
----
scala> val f: IntUnaryOperator = i => i + 1
f: java.util.function.IntUnaryOperator = ...

scala> val stream = Arrays.stream(Array(1, 2, 3))
stream: java.util.stream.IntStream = ...scala> stream.map(f).toArray
res6: Array[Int] = Array(2, 3, 4)
----
Зі Scala 2.12 та Java 8 ви також можете викликати методи, скомпільовані за допомогою Scala з Java, передаючи функціональні типи Scala з використанням лямбда виразів Java. Хоча функціональні типи Scala визначені як трейти, що включають суцільні методи, Scala 2.12 компілює трейти до Java інтерфейсів з методами по замовчанню, нова можливість Java 8. Як результат, функціональні типи Scala з'являються в Java як SAM.

31.6 Висновок
-------------
Більшість часу ви можете ігнорувати, як реалізована Scala, і просто писати та виконувати ваш код. Але іноді гарно "подивитись за лаштунки", так що ця глава зайшла в три аспекти реалізації Scala на Java платформі: як виглядає трансляція, як анотації Scala та Java роблять разом, та як підстановочні типи Scala дозволяють вам отримати доступ до підстановочних типів Java. Також розглянуті використання примітивів конкурентності зі Scala, та компіляцію комбіновиних проектів Scala та Java. Ці теми важливі, чи ви використовуєте Scala та Java разом, чи ні.
