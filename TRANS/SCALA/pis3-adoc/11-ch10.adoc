include::headers.adoc[]

Глава 10
--------

Композиція та наслідування
==========================

Глава 6 вводить деякі базові об'єктно-орієнтовні аспекти Scala. Ця глава підхоплює там, де полишила Глава 6, та занурюється в підтримку в Scala об'єктно-орієнтовного програмування в значно більших деталях. Ми будемо порівнювати два фундаментальні співвідношення між класами: композицію та наслідування. Композиція означає, що один клас зберігає посилання на інший, використовуючи цей клас для допомоги в виконанні своєї міссії. Наслідування є відношенням суперклас/субклас. На додаток до ціх тем, ми будемо обговорювати абстрактні класи, методи без параметрів, розширення класів, перекриття методів та полів, параметрічні поля, виклик конструкторів суперкласу, поліморфізм та динамічна прив'язка, фінальні члени та класи, та об'єкти та методи фабрик.

10.1 Бібліотека двохмірного розташування
----------------------------------------
Як робочий приклад в цій главі ми створимо бібліотеку для побудови та відображення прямокутника, заповненого текстом. Для зручності бібліотека буде провадити методи фабрики на ім'я `elem`, що конструює елементи з переданих даних. Наприклад, ви будете в змозі створити елемент розташування, що містить рядок, використовуючи метод фабрики з наступною сігнатурою:
[source,scala]
----
elem(s: String): Element
----
Як ви можете бачити, елементи будуть змодельовані за допомогою типу на ім'я `Element`. Ви зможете викликати `above` або `beside` на `element`, передаючи другий елемент, щоб створити новий елемент, який є комбінацією двох. Наприклад, наступний вираз буде конструювати більший елемент, що складається з двох колонок, кожна висотою 2:
[source,scala]
----
val column1 = elem("hello") above elem("***")
val column2 = elem("***") above elem("world")
column1 beside column2
----
Друк результате цього виразу буде давати вам таке:
----
hello ***
*** world
----
Елементи розташування є гарним прикладом системи, в якій об'єкти можуть бути сконструйовані з простих частин за допомогою оераторів композиції. В цій главі ми будемо визначати класи, що дозволять конструювання об'єктів-елементів з масивів, ліній та прямокутників. Ці базові об'єкти елементів будуть простими частинами. Ми також визначимо операції композиції `above` та `beside`. Такі компонуючі оператори також часто називають _комбінаторами_, оскікльи вони комбінують елементи в деякій галузі в нові елементи.

Думаючи в термінах комбінаторів загалом гарний підхід розробки бібліотеки: це відплачується - думати про фундаментальні шляхи конструювання об'єктів в домені застосування. Що таке прості об'єкти? В який спосіб найбільш цікаві об'єкти можуть бути сконструйовані з простіших? Як комбінатори поводяться разом? Які комбінатори найбільш загальні? Чи вони задовільняють цікавим законам? Якщо ви маєте гарні відповіді на ці запитання, розробка вашої бібліотеки на вірному шляху.

10.2 Абстрактні класи
---------------------
Наше перше завдання є визначити тип `Element`, що предаставляє елементи розташування. Оскільки елементи є двохвимірні прямокутники символів, має сенс включити член `contents`, що посалається на вміст елемента розташування. Цей `contents` може бути представлений як масив рядків, до кожний рядок представляє лінію. Таким чином, тип результата, що повертається `contents` буде `Array[String]`. Лістинг 10.1 показує, як це буде виглядати.
[source,scala]
----
abstract class Element {
  def contents: Array[String]
}
----
Лістинг 10.1 - Визначення абстрактного метода та класа.

В цьому класі `contents` декларовано як метод, що не має реалізації. Іншими словами, метод є абстрактним членом класа `Element`. Клас з абстрактинми методами має сам бути визначений як абстрактний, що робиться додаванням модифікатора `abstract` перед ключовим словом `class`:
[source,scala]
----
abstract class Element ...
----
Модифікатор `abstract` означає, що клас може мати абстрактні члени, що не мають реалізації. Як результат, ви не можете створити примірник абстрактного класу. Якщо ви спробуєте зробити це, ви отримаєте помилку компіляції:
[source,scala]
----
scala> new Element
<console>:5: error: class Element is abstract;
    cannot be instantiated
       new Element
           ^
----
Пізніше в цій главі ви побачите, як створити субкласи класа `Element`, для яких ви будете в змозі створити примірники, оскільки вони заповнюють відсутнє визначення дла `contents`.

Зауважте, що метод `contents` в класі `Element` не має модифікатора `abstract`. Метод є абстрактним, якщо він не має реалізації (тобто знака рівності або тіла). На відміну від Java, для декларацій методів модифікатор `abstract` не потрібен (та не дозволений). Методи, що мають реалізцію, називаються _суцільними_.

Інша частка термінології відрізняє декларації та визначення. Клас `Element` _декларує_ абстрактний метод `contents`, але наразі не _визначає_ конкретинх методів. Однак в наступному розділі ми розширимо `Element`, визначаючи деякі суцільні методи.

10.3 Визначення методів без параметрів
--------------------------------------
Як наступний крок, ми додамо методи до `Element`, що з'ясовують його ширину та довжину, як показано в Лістингу 10.2. Метод `height` повертає число рядків в `contents`. Метод `width` повертає довжину першого рядка, або повертає нуль, якщо в елементі немає нічого. (Це означає, що ви не можете визначити елемент з висотою нуль, та ненульовою шириною.)
[source,scala]
----
abstract class Element {
  def contents: Array[String]
  def height: Int = contents.length
  def width: Int = if (height == 0) 0 else contents(0).length
}
----
Лістинг 10.2 - Визначення методів без параметрів, `width` та `height`.

Зауважте, що жодний з трьох методів `Element` не має списку параметрів, навіть порожнього. Наприклад, замість:
[source,scala]
----
def width(): Int
----
метод визначений без дужок:
[source,scala]
----
def width: Int
----
Такі _безпараметричні_ методи є досить загальними в Scala. На відміну, методи, визначені з порожніми дужками, такі як `def height(): Int`, називаються _методами з порожніми дужками_. Рекомендована домовленість є використовувати безпараметричні методи, коли немає параметрів, і метод отримує доступ до змінного стану тільки через читання полів містячого об'єкта (зокрема, він не змінює змінний стан). Ця домовленість підтримує принцип уніфіормного доступу,footnote:[Meyer, Object-Oriented Software Construction [Mey00\]] який каже, що клієнтський код не має зазнати впливу від рішення реалізувати атрибут як поле або метод.

Наприклад, ми можемо реалізувати `width` та `height` елемента як поля, замість методів, просто змінивши `def` в кожному визначенні на `val`:
[source,scala]
----
abstract class Element {
  def contents: Array[String]
  val height = contents.length
  val width =
    if (height == 0) 0 else contents(0).length
}
----
Дві пари визначень повністю еквівалентні з клієнтської точки зору. Єдине що відрізняється, це те, що доступ до поля може бути трохи швидший, ніж виклик метода, оскільки значення полів попередньо обчислені при ініціалізації класа, замість бути обчислені при кожному виклику метода. З іншого боку, поля потребують додаткового простору в пам'яті в кожному елементі `Element`. Так що це залежить від профілю використання класа, чи атрибут краще представляти як поле чи метод, і цей профіль використання може змінитись з часом. Суть в тому, що клієнти класа `Element` не мають зазнати впливу, коли змінюється внутрішнє представлення.

Зокрема, клієнт класу `Element` не має бути переписаний, якщо поле цього класа буде змінено на функцію доступу, доки ця функція є чистою (тобто вона не має жодних побічних ефектів, та не залежить від змінного стану). Клієнт не має турбуватись в жодному випадку.

Доки все гарно. Але все ще є невелике ускладнення, що має справу з тим, як Java обробляє речі. Проблема в тому, що Java не реалізує принцип уніформного доступу. Так що існує `string.length()` в Java, не `string.length`, навіть якщо `array.length`, не `array.length()`. Нічого і казати, що це дуже бентежить.

Щоб полатати цю дірку, Scala є дуже ліберальною, коли доходить до міксування безпараметричних методів, та методів з порожніми дужками. Зокрема, ви можете перекрити безпараметричні методи методом порожніх дужок, та навпаки. Ви також можете відкинути порожні дужки при виклику функції, що не приймає аргументів. Наприклад, наступні два рядка обоє є легальними в Scala:
[source,scala]
----
Array(1, 2, 3).toString
"abc".length
----
В принципі можливо відкинути всі порожні дужки в викликах функцій Scala. Однак все ще рекомендовано писати порожні дужки, коли викликаний метод представляє більше ніж властивість об'єкта отримувача. Наприклад, порожні дужки на місці, коли метод виконує I/O, записує переприсвоювані змінні (`var`), або читає `var` окрім полів отримувача, прямо або непрямо через використання змінних об'єктів. Таким чином, список параметрів діє як візуальна підказка, що виклик запускає деякі цікаві обчислення. Наприклад:
[source,scala]
----
"hello".length // немає (), бо немає побічних ефектів
println() // краще не відкидати ()
----
Щоб підсумувати, в Scala заохочується визначати методи, що не приймають параметрів, та не мають побічних ефектів, як безпараметричні методи (тобто відкидаючи порожні дужки). З іншого боку, вам ніколи не слід визначати метод, що має побічні ефекти, без дужок, оскільки виклики цього метода потім будуть виглядати як вибір поля. Так що ваші клієнти можуть бути здивовані, коли побачать побічні ефекти.

Подібним чином, коли ви викликаєте функцію, що має побічний ефект, переконайтесь, що коли писали виклик включили порожні дужки. Інший спосіб думати про це: коли функція, що ви викликаєте, виконує операцію, використовуйте дужки. Але якщо вона просто провадить доступ до властивості, прибирайте дужки.

10.4 Розширення класів
----------------------
Нам все ще треба бути в змозі створювати нові об'єкти елементів. Ви вже бачили, що `new Element` не може бути використаний для цього, оскільки `Element` є абстрактним. Таким чином, щоб створити примірник елемента, нам треба створити субклас, що розширює `Element`, та реалізує абстрактний метод `contents`. Лістинг 10.3 показує можливий спосіб зробити це:
[source,scala]
----
class ArrayElement(conts: Array[String]) extends Element {
  def contents: Array[String] = conts
}
----
Лістинг 10.3 - Визначення `ArrayElement` як субкласа `Element`.

Клас `ArrayElement` визначений для розширення класу `Element`. Так само, як в Java, ви використовуєте твердження `extends` після імені класу, щоб виразити цей факт:
[source,scala]
----
... extends Element ...
----

Малюнок 10.1 - Діаграма класів для `ArrayElement`.

Таке твердження `extends` має два ефекти: це дає класу `ArrayElement` наслідувати всі неприватні члени від класу `Element`, та це робить тип `ArrayElement` субтипом типу `Element`. Зважаючи що `ArrayElement` розширює `Element`, клас `ArrayElement` називається субкласом класу `Element`. І навпаки, `Element` є суперкласом `ArrayElement`. Якщо ви приберете твердження `extends`, компілятор Scala неявно вважатиме, що ваш клас розширює `scala.AnyRef`, що на Java платформі є те саме, що і клас `java.lang.Object`. Таким чином, клас `Element` неявно розширює клас `AnyRef`. Ви можете бачити ці відношення наслідування на Малюнку 10.1.

Наслідування означає, що всі члени суперкласа також є членами субкласу, з двома виключеннями. Перше, приватні члени суперкласу не наслідуються в субкласі. Друге, члени суперкласа не наслідуються, якщо член з таким же ім'ям та параметрами вже реалізовані в субкласі. В такому випадку ми кажемо, що субклас _перекриває_ член в суперкласі. Якщо член субкласу є суцільним, та член суперкласу є абстрактним, ми також кажемо, що суцільний член реалізує абстрактний.

Наприклад, метод `contents` в `ArrayElement` перекриває (або, альтернативно, реалізує) абстрактний метод `contents` в класі `Element`.footnote:[Одна проріха в цьому дизайні в тому, що оскільки повернутий масив є змінним, клієнти можуть змінити його. Для книжки ми будемо підтримувати речі простими, але коли `ArrayElement` є частиною реального проекта, ви можете розглянути можливість повертати захисну копію масива замість цього. Інша проблема полягає в тому, що ми досі не переконались, що кожний елемент `String` масиву  `contents` має ту саму довжину. Це може бути вирішене через перевірку передумови в первинному конструкторі, за закиданні виключення, якщо вона порушується.] Для контрасту, клас `ArrayElement` наслідує методи `width` та `height` від класа `Element`. Наприклад, маючи `ArrayElement ae`, ви можете запитати його `width` використовуючи `ae.width`, так, якби `width` було визначене в класі `ArrayElement`:
[source,scala]
----
scala> val ae = new ArrayElement(Array("hello", "world"))
ae: ArrayElement = ArrayElement@39274bf7

scala> ae.width
res0: Int = 5
----
Створення субтипів означає, що значення субкласу може бути використане, коли потрібне значення суперкласу. Наприклад:
[source,scala]
----
val e: Element = new ArrayElement(Array("hello"))
----
Змінна `e` визначена як тип `Element`, так що його значення ініціалізації також має бути `Element`. Фактично, значення ініціалізації є `ArrayElement`. Це OK, оскільки клас `ArrayElement` розширює клас `Element`, і як результат, тип `ArrayElement` сумісний з типом `Element`.footnote:[Для додаткової перспективи на різницю між суперкласом та субкласом дивіться входження глассарію щодо субтипів.]

Малюнок 10.1 також показує порівняння відношень, що існують між `ArrayElement` та `Array[String]`. Це відношення називається композицією, та  клас `ArrayElement` є "скомпонований" з класу `Array[String]`, тому що компілятор Scala буде покладати в двійниковий клас, що він генерує для `ArrayElement`, поле, що містить посилання на переданий масив `conts`. Ми обговоримо деякі рішення дизайну композиції та наслідування далі в цій главі, в Розділі 10.11.

10.5 Перекриття методів та полей
--------------------------------
Принцип уніформного доступу є тільки одним аспектом, коли Scala розглядає поля та методи в більш уніформний спосіб, ніж Java. Інша різниця в тому, що в Scala поля та методи належать до того самого простору імен. Це робить можливим для поля перекривати метод без параметрів. Наприклад, ви можете змінити реалізацію `contents` в класі `ArrayElement` з метода на поле, без модифікації визначення абстрактного метода `contents` в класі `Element`, як показано в Лістингу 10.4:
[source,scala]
----
class ArrayElement(conts: Array[String]) extends Element {
  val contents: Array[String] = conts
}
----
Лістинг 10.4 - Перекриття метода без параметрів за допомогою поля.

Поле `contents` (визначене як `val`) в цій версії `ArrayElement` є чудово гарною реалізацією метода без параметрів `contents` (декларований за допомогою `def`) в класі `Element`. З іншої сторони, в Scala заборонено визначати поле та метод з тим самим ім'ям в тому самому класі, хоча це дозволено в Java.

Наприклад, цей Java клас буде чудово компілюватись:
[source,java]
----
// Це Java
class CompilesFine {
  private int f = 0;
  public int f() {
    return 1;
  }
}
----
Але відповідний клас Scala не буде компілюватись:
[source,scala]
----
class WontCompile {
  private var f = 0 // Не буде компілюватись, оскільки поле
  def f = 1         // та метод мають те саме ім'я
}
----
Загалом, Scala має лише два простору імен для визначень, на відміну від чотирьох в Java. Чотири простори імен в Java є поля, методи, типи та пакунки. На відміну в Scala лише два простори імен:

* значення (поля, методи, пакунки та об'єкти синглтони)
* types (імена класів та трейтів)

Причина, з якої Scala покладає поля та методи в той самий простір імен в точності та, щоб ви могли перекривати методи без параметірв за допомогою `val`, дещо, чого ви не можете робити в Java.footnote:[Причина, з якої в Scala пакунки подіяють той самий простір імен, що поля і методи - бо це дозволяє вам імпортувати пакунки (на додаток до тільки імен типів) та поля і методи об'єктів синглтонів. Це знову дещо, чого ви не можете в Java. Це буде описане в Розділі 13.3.]

10.6 Визначення параметричних полів
-----------------------------------
Знову розглянемо визначення класу `ArrayElement`, показану в попередній главі. Він мав параметр `conts`, чиє єдине призначення є бути скопійованим в поле `contents`. Ім'я параметра `conts` було обране саме так, щоб воно могло виглядати подібно до імені поля  `contents`, насправді не перетинаючись з ним. Це "сморід коду," ознака, що може бути непотрібна надмірність або повторення у вашому коді.

Ви можете уникнути сморіду коду, комбінуючи параметр та поле в одному визначенні параметричного коду, як показано в Лістингу 10.5:
[source,scala]
----
class ArrayElement(
  val contents: Array[String]
) extends Element
----
Лістинг 10.5 - Визначення `contents` як параметричного поля.

Зауважте, що тепер параметр `contents` має перед собою `val`. Це скорочення, що одночасно визначеє параметр та поле з тим самим полем. Зокрема, клас `ArrayElement` тепер має (неперепризначуване) поле `contents`, до якого можна отримати з поза меж класу. Поле ініціалізоване значенням параметру. Це так, якби клас був написаний наступним чином, де `x123` є довільним свіжим ім'ям для параметру:
[source,scala]
----
class ArrayElement(x123: Array[String]) extends Element {
  val contents: Array[String] = x123
}
----
Також ви можете перед параметром класу поставити `var`, в якому випадку відповідне поле буде переприсвоюване. Нарешті, можливо додати модифікатори, такі як `private`, `protected`,footnote:[Модифікатор `protected`, що надає доступ до субкласів, буде розкритий в деталях в Главі 13.] або `override` до ціх параметричних полів, так само, як ви можете зробити для любих інших членів методів. Наприклад, розгляньте визначення наступних класів:
[source,scala]
----
class Cat {
  val dangerous = false
}

class Tiger (
  override val dangerous: Boolean,
  private var age: Int
) extends Cat
----
Визначення `Tiger` є скороченням для наступного альтернативного визначення класу, з перекриттям члена `dangerous` та приватним членом `age`:
[source,scala]
----
class Tiger(param1: Boolean, param2: Int) extends Cat {
  override val dangerous = param1
  private var age = param2
}
----
Обоє члени ініціалізовані від відповідних парамтрів. Ми довільно обираємо імена для ціх параметрів, `param1` та `param2`. Важлива річ була щоб вони не перетинались з іншими іменами в полі зору.

10.7 Виклик конструкторів суперкласу
------------------------------------
Тепер ви маєте повну систему, що складається з двох класів: абстрактного класу `Element`, що розширений суцільним класом `ArrayElement`. Ви можете також уявити собі для вираження елемента. Наприклад, клієнти можуть виявити бажання створити елемент розташування, що складається з однієї лінії, взятої як рядок. Об'єктно-орієнтовне програмування робить простим розширення системи за допомогою нових варіантів даних. Ви можете просто додавати субкласі. Наприклад, Лістинг 10.6 показує клас `LineElement`, що поширює `ArrayElement`:
[source,scala]
----
class LineElement(s: String) extends ArrayElement(Array(s)) {
  override def width = s.length
  override def height = 1
}
----
Лістинг 10.6 - Викликання конструктора суперкласа.

Оскікльи `LineElement` розширює `ArrayElement`, та конструктор `ArrayElement` приймає параметр (`Array[String]`), `LineElement` потребує передати аргумент до первинного конструктора його суперкласу. Щоб викликати конструктор суперкласу, ви просто покладаєте аргумент або аргументи, що ви бажаєте передати, в дужках, що слідують за ім'ям суперкласу. Наприклад, клас `LineElement` передає `Array(s)` до первинного конструктора `ArrayElement`, покладаючи в його в дужки після імені суперкласа `ArrayElement`:
[source,scala]
----
... extends ArrayElement(Array(s)) ...
----
З новим субкласом ієрархія наслідування для елементів розташування зараз виглядає, як показано на Малюнку 10.2.

Малюнок 10.2 - Діаграма класів для `LineElement`.

10.8 Використання модифікатора override
---------------------------------------
Зауважте, що визначення `width` та `height` в `LineElement` має модифікатор `override`. В розділі 6.3 ви бачили цей модифікатор в визначенні метода `toString`. Scala потребує такого модифікатора для всіх членів, що перекривають суцільний метод в батьківському класі. Модифікатор є опціональним, якщо член реалізує абстрактний член з тим самим ім'ям. Модифікатор заборонений, якщо член не перекриває або не реалізує деякий член в базовому класі. Оскільки `height` та `width` в класі `LineElement` перекривають суцільні визначення в класі `Element`, `override` є обов'язковим.

Це правило провадить корисну інформацію для компілятора, що допомагає уникати деяких складних для відлову помилок, та робить еволюцію безпечнішою. Наприклад, якщо ви випадково невірно назвали метод, або випадково дали йому інший список параметрів, компілятор відповість повідомленням про помилку:
[source,scala]
----
$ scalac LineElement.scala
.../LineElement.scala:50:
error: method hight overrides nothing
  override def hight = 1
           ^
----
Домовленість перекриття навіть більше важливе, коли доходить до еволюції системи. Скажімо, ви визначаєте бібліотеку з методів малювання 2D. Ви зробили її публічно доступною, та вона широко уживана. В наступній версії бібліотеки ви бажаєте додати до вашого базового класа `Shape` новий метод з такою сигнатурою:
[source,scala]
----
def hidden(): Boolean
----
Ваш новий метод буде використовуватись в різних методах малювання, щоб визначити, чи треба малювати фігуру. Це може призвести до значного прискорення, але ви не можете зробити це без ризику поламати клієнтській код. Кінець кінцем, клієнт міг вже визначити субклас `Shape` з іншою реалізацією `hidden`. Можливо, клієнській метод насправді робить отримуючий об'єкт зникаючим, замість перевіряти, чи об'єкт прихований. Оскільки дві версії `hidden` перекривають один одний, ваші методи малювання скінчать тим, що робитимуть об'єкти знікаючими, що напевне не те, чого ви бажаєте!

Ці "випадкові перекриття" є найбільш загальною маніфестацією того, що називається проблемою "крихких базових класів". Проблема в тому, що якщо ви додаєте нові члени до базових класів (які ми звичайно називаємо суперкласами) в ієрархії класів, ми ризикуємо зламати клієнтській код. Scala не може повністю вирішити проблему крихкіх базових класів, але він покращує ситуацію, порівняно з Java.footnote:[В Java 1.5 була введена анотація `@Override`, що робить подібно до модифікатор Scala `override`, але на відміну від Scala `override`, це не вимагається.] Якщо бібліотека малювання та її клієнти були написані на Scala, тоді оригінальна клієнтська реалізація `hidden` не може мати модифікатора  `override`, оскільки на той час немає іншого метода з цім ім'ям.

Як тільки ви додасте метод `hidden` до другої версії вашого класу фігури, перекомпіляція клієнта буде давати помилку, подібну до наступної:
[source,scala]
----
.../Shapes.scala:6: error: error overriding method
     hidden in class Shape of type ()Boolean;
method hidden needs `override' modifier
def hidden(): Boolean =
^
----
Тобто, замість помилкової поведінки ваш клієнт отримає помилку часу компіляції, що, зазвичай, значно краще.

10.9 Поліморфізм та динамічне зв'язування
-----------------------------------------
Ви бачили в Розділі 10.4, що змінна типу `Element` може посилатись на об'єкт типу `ArrayElement`. Ім'я цього феномену є _поліморфізм_, що означає "багато форм". В цьому випадку, об'єкти `Element` можуть мати багато форм.footnote:[Цей різновид поліморфізму називається поліморфізмом субтипізації. Інший різновид поліморфізму в Scala називається універсальним поліморфізмом, та обговорюється в Главі 19.]

Доки ви бачили дві такі форми: `ArrayElement` та `LineElement`. Ви можете створити більше форм `Element`, через визначення нових субкласів `Element`. Наприклад, ви можете визначити нову форму `Element`, що має задані ширину та довжину, та повністю заповнений наданим символом:
[source,scala]
----
class UniformElement(
  ch: Char,
  override val width: Int,
  override val height: Int
) extends Element {
  private val line = ch.toString * width
  def contents = Array.fill(height)(line)
}
----
Ієрархія наслідування для класа `Element` тепер виглядає як показано на Малюнку 10.3. Як результат, Scala буде приймати всі наступні присвоєння, оскільки тип присвоюваних виразів відповідає до типу визначенної змінної:
[source,scala]
----
val e1: Element = new ArrayElement(Array("hello", "world"))
val ae: ArrayElement = new LineElement("hello")
val e2: Element = ae
val e3: Element = new UniformElement('x', 2, 3)
----
Якщо ви перевірите ієрархію наслідування, ви знайдете, що для кожного з ціх чотирьох визначень `val`, тип виразу зправа від знаку рівності нижче типу `val`, що ініціалізується зліва знаку рівності.

Малюнок 10.3 - Ієрархія класу елементів розташування.

Однак друга частина історії в тому, що виклики ціх методів не змінній і виразах зв'язані динамічно. Це означає, що справжня реалізація метода визначається під час виконання, на основі класу об'єкта, не на основі типу змінної або виразу. Щоб продемонструвати цю поведінку, ми тимчасово видалимо всі існуючі члени з нашого класу `Element`, та додамо в `Element` метод з назвою `demo`. Ми перекриємо `demo` в `ArrayElement` та `LineElement`, але не в `UniformElement`:
[source,scala]
----
abstract class Element {
  def demo() = {
    println("Element's implementation invoked")
  }
}

class ArrayElement extends Element {
  override def demo() = {
    println("ArrayElement's implementation invoked")
  }
}

class LineElement extends ArrayElement {
  override def demo() = {
    println("LineElement's implementation invoked")
  }
}

// UniformElement наслідує demo від Element
class UniformElement extends Element
----
Якщо ви введете цей код в інтерпретатор, потім ви можете визначитицей метод, що приймає `Element`, та викликає на ньому `demo`:
[source,scala]
----
def invokeDemo(e: Element) = {
  e.demo()
}
----
Якщо ви передасте `ArrayElement` до `invokeDemo`, ви побачите повідомлення, що вказує, що була викликана реалізація demo з ArrayElement, навіть хоча тип змінної `e`, на якому викликається demo, є `Element`:
[source,scala]
----
scala> invokeDemo(new ArrayElement)
ArrayElement's implementation invoked
----
Подібно до цього, якщо ви передасте `LineElement` до `invokeDemo`, ви побачите повідомлення, що вказує, що була викликана реалізація `demo` з `LineElement`:
[source,scala]
----
scala> invokeDemo(new LineElement)
LineElement's implementation invoked
----
Поведінка коли передається `UniformElement` може зпочатку виглядати підозрілою, але вона коректна:
[source,scala]
----
scala> invokeDemo(new UniformElement)
Element's implementation invoked
----
Оскільки `UniformElement` не перекриває `demo`, він наслідує реалізацію `demo` від свого суперкласу, `Element`. Таким чином, реалізація `Element` є коректною реалізацією `demo`, коли клас об'єкта є `UniformElement`.

10.10 Декларація фінальних членів
---------------------------------
Іноді, коли розробляється ієрархія наслідування, ви бажаєте переконатись, що член не може бути перекритий в субкласах. В Scala, як і в Java, ви робите це, додаючи модифікатор `final` до члена. Як показано в Лістингу 10.7, ви можете покласти модифікатор `final` на `demo` метод в `ArrayElement`.
[source,scala]
----
class ArrayElement extends Element {
  final override def demo() = {
    println("ArrayElement's implementation invoked")
  }
}
----
Лістинг 10.7 - Декларування фінального методу.

Маючи цю версію `ArrayElement`, спроба перекрити `demo` в субкласі `LineElement` не буде компілюватись:
[source,scala]
----
elem.scala:18: error: error overriding method demo
   in class ArrayElement of type ()Unit;
method demo cannot override final member
    override def demo() = {
                 ^
----
Також часом ви бажаєте переконатись, що цілий клас не може мати субкласів. Щоб зробити це, просто декларуйте цілий клас фінальним, додаючи модифікатор `final` до декларації класу. Наприклад, Лістинг 10.8 показує, як ви можете декларувати фінальний `ArrayElement`:
[source,scala]
----
final class ArrayElement extends Element {
  override def demo() = {
    println("ArrayElement's implementation invoked")
  }
}
----
Лістинг 10.8 - Декларування фінального класу.

З цією версією `ArrayElement`, люба спроба визначити субклас не буде компілюватись:
[source,scala]
----
elem.scala: 18: error: illegal inheritance from final class
    ArrayElement
  class LineElement extends ArrayElement {
                            ^
----
Тепер ми видалимо модифікатор `final` та метод `demo`, та повернемось до ранішньої реалізації сімейства `Element`. В залишку глави ми зфокусуємо нашу увагу на завершенні робочої версії бібліотеки розташування.

10.11 Використання композиції та наслідування
---------------------------------------------
Композиція та наслідування є двома шляхами визначити новий клас в термінах іншого існуючого класа. Якщо те, чого ви шукаєте, це просте повторне використання коду, ви маєте обрати композицію замість наслідування. Тільки наслідування потерпає від проблеми крихких базових класів, коли ви можете ненавмисно зашкодити субкласам через зміни в суперкласі.

Одне питання, що ви можете запитати себе щодо відношення наслідування, чи моделює воно відношення "..є примірником..".footnote:[Meyers, Effective C++ [Mey91\]] Наприклад, це буде досить дотепним сказати, що `ArrayElement` _є примірником_ `Element`. Інше питання, що ви можете запитати, це чи те, чи колись клієнти забажають використовувати тип субкласів як тип суперкласу.footnote:[Eckel, Thinking in Java [Eck98\]] В випадку `ArrayElement`, ми очевидно очікуємо, що клієнти бажатимуть використовувати `ArrayElement` як `Element`.

Якщо ви задасте ці питання щодо відношень наслідування, показаних на Малюнку 10.3, чи якесь з відношень виглядає підозріло? Закрема, чи виглає це очевидним, що `LineElement` _є примірником_ `ArrayElement`? Чи ви думаєте, що клієнтам колись знадобиться використовувати `LineElement` як `ArrayElement`?

Фактично, ми визначили `LineElement` як субклас `ArrayElement` в основному для повторного використання визначення `contents` з `ArrayElement`. Можливо, було б краще визначити `LineElement` як прямий субклас `Element`, ось так:
[source,scala]
----
class LineElement(s: String) extends Element {
  val contents = Array(s)
  override def width = s.length
  override def height = 1
}
----
В попередній версії `LineElement` має відношення наслідування з `ArrayElement`, від якого він наслідує `contents`. Тепер він має відношення композиції з `Array`: він має посилання на масив з рядків зі свого власного поля `contents`.footnote:[Клас `ArrayElement` також має відношення композиції з `Array`, оскільки його параметричне поле `contents` містить посилання на масив з рядків. Код для `ArrayElement` показаний в Лістингу 10.5. Його відношення композиції представлене на діаграмі класу як діамант, наприклад, як показано на Малюнку 10.1.] Маючи цю реалізацію `LineElement`, ієрархія наслідування для `Element` тепер виглядає так, як на Малюнку 10.4.

Малюнок 10.4 - Ієрархія класів з переробленим `LineElement`.

10.12 Реалізація `above`, `beside` та `toString`
-----------------------------------------------
Як наступний крок, ми реалізуємо метод `above` в класі `Element`. Покладання одного елементу над іншим означає конкатенацію двох значень `contents` для елементів. Так що перша чернетка метода `above` може виглядати так:
[source,scala]
----
def above(that: Element): Element =
  new ArrayElement(this.contents ++ that.contents)
----
Операція `++` конкатенує два масиви. Масиви в Scala представлені масивами Java, але підтримують значно більше методів. Більш точно, масиви в Scala можуть бути конвертовані в примірники класу `scala.Seq`, що представляє собою послідовність-подібні структуру, та містить декілька методів для доступу та перетворення послідовностей. Деякі інші методи масивів будуть пояснені в цій главі, та більш докладна дискусія буде надана в Главі 17.

Фактично, попередньо показаний код не дуже достатній, оскільки він не дозволяє вам покладати вам елементи різної ширини один зверху іншого. Щоб утримувати речі в цьому розділі простими, ми залишимо це як є, та передаватимемо до `above` тільки елементи однієї ширини. В Розділі 10.14 ми зробимо покращення до `above`, так щоб клієнти могли використовувати його для комбінування елементів з різною шириною.

Наступний метод, що треба реалізувати, є `beside`. Щоб покласти два елементи один поряд з іншим, ми створимо новий елемент, в якому кожна лінія утворюється від канкатенації відповідних ліній з двох елементів. Як і раніше, щоб утримувати речі простими, ми почнемо з припущення, що два елементи мають ту саму висоту. Це призводить до наступного дизайну метода `beside`:
[source,scala]
----
def beside(that: Element): Element = {
  val contents = new Array[String](this.contents.length)
  for (i <- 0 until this.contents.length)
    contents(i) = this.contents(i) + that.contents(i)
  new ArrayElement(contents)
}
----
Метод `beside` спочатку розміщує новий масив `contents`, та заповнює його вмістом відповідних елементів масива в `this.contents` та `that.contents`. В фіналі він продукує новий `ArrayElement`, що містить новий `contents`.

Хоча ця реалізація `beside` робить, це імперативний стиль, промовистим знаком чого є цикл в якому ми проходимо по масиву. Альтернативно, метод може бути скорочений до одного вирау:
[source,scala]
----
new ArrayElement(
  for (
        (line1, line2) <- this.contents zip that.contents
      ) yield line1 + line2
)
----
Тут є два масива, `this.contents` та `that.contents`, що трансформуються в масив з пар (що називаютсья `Tuple2s`) використовуючи оператор `zip`. Оператор `zip` бере відповідні елементи зі своїх двох операндів, та формує масив з пар. Наприклад, цей вираз:
[source,scala]
----
Array(1, 2, 3) zip Array("a", "b")
----
обчислюється до:
[source,scala]
----
Array((1, "a"), (2, "b"))
----
Якщо один з двох масивів довший за інший, `zip` буде відкидати зайві елементи. В виразі вище третій елемент лівого операнда, `3`, не формує частину результату, оскільки він не має відповідного елемента в правому операнді.

Після цього поєднаний масив ітерується в виразу `for`. Тут синтаксис `for ((line1, line2) <- ...)` дозволяє вам назвати обоє елементи з пари в одному шаблоні (тобто, тепер `line1` тепер відповідає першому елементу з пари, та `line2` відповідає другому). Система співпадіння з шаблонами в Scala буде описана в деталях в Главі 15. Доки ви можете думати про це як про спосіб визначити дві `val`, `line1` та `line2`, на кожному кроці ітерації.

Вираз `for` має частину `yield`, і, таким чином, видає результат. Результат буде того самого типу, що і вираз, по якому іде ітерація (тобто, це масив). Кожний елемент масиву є результатом конкатенації відповідних рядків, `line1` та `line2`. Так що ваш останній результат цього коду є той самий, що і в першій версії `beside`, але оскільки він уникає індексації масиву, цей результат отриманий в менш схильний до помилок спосіб.

Вам все ще треба спосіб відображати елементи. Як звичайно, це робиться через визначення метода `toString`, що повертає елемент, відформатований як рядок. Ось визначення:
[source,scala]
----
override def toString = contents mkString "\n"
----
Реалізація `toString` задіє `mkString`, що визначене для всіх послідовностей, включаючи масиви. Як ви бачили в Розділі 7.8, вирази, як `arr mkString sep` повертає рядок, що складається з усіх елементів масива `arr`. Кожний елемент відзеркалюється на рядок, через виклик для кожного елементу `toString`. Рядок роздільника, sep, вставляється між послідовними рядками елементів. Так що вираз `contents mkString "\n"` форматує масив `contents` як рядок, де кожний елемент масива з'являється на окремому рядку.
[source,scala]
----
abstract class Element {def contents: Array[String]
  def width: Int =
    if (height == 0) 0 else contents(0).length

  def height: Int = contents.length
  
  def above(that: Element): Element =
    new ArrayElement(this.contents ++ that.contents)

  def beside(that: Element): Element =
    new ArrayElement(
      for (
        (line1, line2) <- this.contents zip that.contents
      ) yield line1 + line2
    )

  override def toString = contents mkString "\n"
}
----
Лістинг 10.9 - Клас `Element` з `above`, `beside` та `toString`.

Зауважте, що `toString` не має порожнього списку параметрів. Це слідує рекомендаціям для принципа уніформного доступу, оскільки `toString` є чистим методом, що не приймає жодних параметрів. З додаванням ціх трьох методів, клас `Element` тепер виглядає як показано в Лістингу 10.9.

10.13 Визначення об'єкта фабрики
--------------------------------
Тепер ви маєте ієрархію класів для елементів розташування. Ця ієрархія може бути представлена вашим клієнтам "як є", але ви також можете обрати приховати ієрархію за лаштунками об'єкта фабрики.

Об'єкт фабрики містить методи, що конструюють інші об'єкти. Потім клієнти використовують ці методи фабрики, замість конструювання об'єктів напряму за допомогою `new`. Перевага цього підходу до створення об'єктів в тому, що створення об'єктів може бути централізоване, і деталі того, як об'єкти представлені класами може бути приховане. Це приховування одночасно зробить вашу бібліотеку простішою для розуміння клієнтами, оскільки показані меньше деталей, та провадить вам більше можливостей пізніше змінити реалізацію вашої бібліотеки, не руйнуючи код клієнта.

Перше завдання в конструюванні фабрики для ваших об'єктів розташування є обрати, де мають бути розміщені методи фабрики. Чи мають вони бути членами об'єкта синглтона, або класа? Що повинно викликати містячий об'єкт або клас? Існую багато можливостей. Прямолінійне рішення є створити об'єкт компанйон класа `Element`, та зробити його об'єктом фабрикою для елементів розміщення. Таким чином, вам треба показати вашим клієнтам тільки комбінацію класа/об'єкта, та ви можете приховати три класа реалізації,`ArrayElement`, `LineElement`, та `UniformElement`.

Лістинг 10.10 є дизайном об'єкта `Element`, що слідує цій схемі. Об'єкт  `Element` містить три перевантажені варіанти метода `elem`, та кожний конструює різний тип об'єкта розташування.
[source,scala]
----
object Element {
  def elem(contents: Array[String]): Element =
    new ArrayElement(contents)
    
  def elem(chr: Char, width: Int, height: Int): Element =
    new UniformElement(chr, width, height)

  def elem(line: String): Element =
    new LineElement(line)
}
----
Лістинг 10.10 - Об'єкт фабрики з методом фабрики.

З появою ціх методів фабрик має сенс змінити реалізацію класа `Element`, так щоб він шов через методи фабрик `elem`, скоріше ніж створювати нові примірники `ArrayElement` напряму. Щоб викликати методи фабрик, не кваліфікуючи їх іменем об'єкта синглтона, `Element`, ми будемо імпортувати `Element.elem` на верхньому рівні джерельного файла. Іншими словами, замість виклику методів фабрик як `Element.elem` зсередини класу `Element`,ми імпортуємо `Element.elem`, так що ви можете просто викликати методи фабрик по їх простому імені, `elem`. Лістинг 10.11 показує, як буде виглядати клас Element після ціх змін.
[source,scala]
----
import Element.elem

abstract class Element {

  def contents: Array[String]

  def width: Int =
    if (height == 0) 0 else contents(0).length

  def height: Int = contents.length

  def above(that: Element): Element =
    elem(this.contents ++ that.contents)

  def beside(that: Element): Element =
    elem(
      for (
        (line1, line2) <- this.contents zip that.contents
      ) yield line1 + line2
    )

  override def toString = contents mkString "\n"
}
----
Лістинг 10.11 - Клас `Element` після рефакторинга з додавання методів фабрик.

На додаток, маючи методи фабрик, тепер субкласи `ArrayElement`, `LineElement`, `UniformElement` можуть бути приватними, оскільки вони більше не мають отримувати доступ напряму від клієнтів. В Scala ви можете визначати класи та об'єкти синглтони. Один спосіб зробити субкласи `Element` приватними - це покласти їх в об'єкт синглтон `Element`, та декларувати їх там приватними. Класи будуть все ще доступні до трьох методах фабрик `elem`, де вони потрібні. Лістинг 10.12 показує, як це буде виглядати.

10.14 Підвищення та розширення
------------------------------
Нам треба одне останнє покращення. Версія `Element`, показана в Лістингу 10.11, не є повністю достатньою, оскільки вона не дозволяє клієнтам покладати елементи з різною шириною один на одний, або класти поряд елементи з різною висотою. Наприклад, обчислення наступних виразів не буде робити коректно, оскільки другий рядок в комбінованому елементі довший, ніж в першому:
[source,scala]
----
new ArrayElement(Array("hello")) above
new ArrayElement(Array("world!"))
----
Подібно до цього, обчислення наступного виразу не буде робити потрібним чином, оскільки перший `ArrayElement` має висоту два, а другий висоту один:
[source,scala]
----
new ArrayElement(Array("one", "two")) beside
new ArrayElement(Array("one"))
----
Лістинг 10.13 показує приватний допоміжний метод, `widen`, що приймає ширину, та повертає `Element` такої ширини. Результат містить вміст цього `Element`, відцентрований та вирівняний зліва та зправа додатковими проміжками, як треба щоб досягти потрібної ширини. Лістинг 10.13 також показує подібний метод, `heighten`, що виконує ту саму функцію в вертикальному напрямку. Метод `widen` викликається в `above`, щоб переконатись, що `Element`, покладений над будь-яким іншим, матиме ту саму ширину. Подібно до цього, метод `heighten` викликається в `beside`, щоб переконатись, що елементи, розташовані поряд, мають ту саму ширину. З такими змінами бібліотека розташування готова до використання.
[source,scala]
----
object Element {

    private class ArrayElement(
      val contents: Array[String]
    ) extends Element

    private class LineElement(s: String) extends Element {
      val contents = Array(s)
      override def width = s.length
      override def height = 1
    }

    private class UniformElement(
      ch: Char,
      override val width: Int,
      override val height: Int
    ) extends Element {
      private val line = ch.toString * width
      def contents = Array.fill(height)(line)
    }

    def elem(contents: Array[String]): Element =
      new ArrayElement(contents)

    def elem(chr: Char, width: Int, height: Int): Element =
      new UniformElement(chr, width, height)

    def elem(line: String): Element =
      new LineElement(line)
}
----
Лістинг 10.12 - Приховування реалізації за допомогою приватних класів.

[source,scala]
----
import Element.elem

abstract class Element {
  def contents: Array[String]

  def width: Int = contents(0).length
  def height: Int = contents.length

  def above(that: Element): Element = {
    val this1 = this widen that.width
    val that1 = that widen this.width
    elem(this1.contents ++ that1.contents)
  }

  def beside(that: Element): Element = {
    val this1 = this heighten that.height
    val that1 = that heighten this.height
    elem(
      for ((line1, line2) <- this1.contents zip that1.contents)
      yield line1 + line2)
  }

  def widen(w: Int): Element =
    if (w <= width) this
    else {
      val left = elem(' ', (w - width) / 2, height)
      val right = elem(' ', w - width - left.width, height)
      left beside this beside right
    }

  def heighten(h: Int): Element =
    if (h <= height) this
    else {
      val top = elem(' ', width, (h - height) / 2)
      val bot = elem(' ', width, h - height - top.height)
      top above this above bot
    }
  }
  
  override def toString = contents mkString "\n"
}
----
Лістинг 10.13 - `Element` з методами `widen` та `heighten`.

10.15 Складаємо все разом
-------------------------
Цікавий спосіб потренуватись з майже всіма елементами бібліотеки розташування - це написати програму, що малює спіраль з заданим числом граней. Ця програма Spiral, показана в Лістингу 10.14, що робить саме це.
[source,scala]
----
import Element.elem

object Spiral {
  
  val space = elem(" ")
  
  val corner = elem("+")

  def spiral(nEdges: Int, direction: Int): Element = {
    if (nEdges == 1)
      elem("+")
    else {
      val sp = spiral(nEdges - 1, (direction + 3) % 4)
      def verticalBar = elem('|', 1, sp.height)
      def horizontalBar = elem('-', sp.width, 1)
      if (direction == 0)
        (corner beside horizontalBar) above (sp beside space)
      else if (direction == 1)
        (sp above space) beside (corner above verticalBar)
      else if (direction == 2)
        (space beside sp) above (horizontalBar beside corner)
      else
        (verticalBar above corner) beside (space above sp)
    }
  }

  def main(args: Array[String]) = {
    val nSides = args(0).toInt
    println(spiral(nSides, 0))
  }
}
----
Лістинг 10.14 - Застосування Spiral.

Оскікльи `Spiral` є окремий об'єкт з методом `main` відповідної сигнатури, це застосування Scala. Spiral приймає один аргумент командного рядка як ціле, та малює спіраль з заданим числом граней. Наприклад, ви можете намалювати шісти-гранну спіраль, як показано зліва, та більші спіралі, які показані зправа.
----
$ scala Spiral 6    $ scala Spiral 11   $ scala Spiral 17
+-----              +----------         +----------------
|                   |                   |
| +-+               | +------+          | +------------+
| + |               | |      |          | |            |
|   |               | | +--+ |          | | +--------+ |
+---+               | | |  | |          | | |        | |
                    | | ++ | |          | | | +----+ | |
                    | |    | |          | | | |    | | |
                    | +----+ |          | | | | ++ | | |
                    |        |          | | | |  | | | |
                    +--------+          | | | +--+ | | |
                                        | | |      | | |
                                        | | +------+ | |
                                        | |          | |
                                        | +----------+ |
                                        |              |
                                        +--------------+    
----
10.16 Висновок
--------------
В цьому розділі ви бачили більше концепцій, пов'язаних з об'єктно-орієнтовним програмуванням в Scala. Поміж іншого, вам зустрілись абстрактні класи, наслідквання та субтипи, ієрархії класів, параметричні поля та перекриття методів. Ви мали розвинути відчуття конструювання нетривіальних ієрархій в Scala. Ми будемо знову робити з бібліотекою розташувань в Главі 14.
 