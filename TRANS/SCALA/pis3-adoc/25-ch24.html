<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__24">Глава 24</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Колекції: докладно</h1>
<div class="paragraph"><p>Scala включає елегантну та потужну бібліотеку колекцій. Навіть якщо вважати, що API колекцій тонкий на перший погляд, зміни, які він може спровокувати в вашому стилі програмування можуть бути грунтовними. Досить часто це так, якби ви робили на вищому рівні з базовими будівельними блоками програми, що є цілими колекціями, ніж їх елементами. Цей новий стиль програмування потребує деякої адаптації. Нащастя, адаптації допомагють декілька милих властивостей Scala колекцій. Вони прості в використанні, стислі, безпечні, швидкі та універсальні.</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Простота в використанні:</strong> Невеликого словника з двадцяти до сорока методів, досить для вирішення більшості проблем колекцій в парі операцій. Намає потреби огортати вашу голову кругом складних циклічних структур або рекурсій. Стійкі колекції вільні від операцій з побічними ефектами, що означає, що вам не треба хвилюватись про випадкове руйнування існуючих колекцій новими даними. Взаємодію між ітераторами та оновленнями колекцій ліквідовано.
</p>
</li>
<li>
<p>
<strong>Стислість:</strong> Ви можете досягти за допомогою одного слова те, що раніше займало один або декілька циклів. Ви можете виразити функціональні операції за допомогою легковажного синтаксису та без зусиль комбінувати операції так що результат відчувається як власна алгебра.
</p>
</li>
<li>
<p>
<strong>Безпечність:</strong> Щоб зрозуміти це, треба мати досвід. Статична типізація та функціональна природа Scala колекцій означає, що переважна більшість помилок, які ви можете зробити, відловлюються під час компіляції. Причини цього в тому, що (1) операції колекцій самі часто використовуються, і таким чином, гарно протестовані. (2) використання операцій з колекціями робить входи та виходи явними, як параметри функції та результати. (3) Ці явні входи та виходи є предметом перевірки статичних типів. Підсумок всього цього в тому, що велика більшість хибних використань будуть заявляти про себе як помилки типів. Взагалі не є рідкістю мати програми з декількох сотень рядків, що роблять з першої спроби.
</p>
</li>
<li>
<p>
<strong>Швидкість:</strong> Операції з колекціями настроєні і оптимізовані в бібліотеках. Як результат, використання колекцій типово досить ефективне. Ви можете бути в змозі зробити все трохи краще, через уважно налаштовані структури даних та операції, але ви також можете зробити все значно гірше, по ходу справи прийнявши якісь неоптимальні рішення з реалізації. Більше того, колекції були адаптовані до паралельної виконання на декількох ядрах. Паралельні колекції підтримують ті самі операції, що і послідовні так що не треба вивчати нові операції та переписувати код. Ви можете перетворити послідовну колекцію в паралельну, просто викликавши метод <code>par</code>.
</p>
</li>
<li>
<p>
<strong>Універсальність:</strong> Колекції провадять ті самі операції на любому типі, коли це має сенс робити. Так що ви можете багато чого досягти з досить малим словником операцій. Наприклад, рядок концептуально є послідовністю символів. Відповідно, в Scala колекціях рядок підтримує всі операції послідовностей. Те саме дійсне і для масивів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ця глава поглиблено описує API для класів колекцій Scala з перспективи користувача. Ви вже бачили швидкий тур по бібліотеці колекцій в Главі 17. Ця глава запрошує вас в більш детальний тур, показуючи всі класи колекцій, і всі методи, що вони визначають так що вона включає все, що вам треба знати для використання Scala колекцій. Дивлячись наперед, Глава 25 буде сконцентрована на архитектурі та аспектах розширюваності бібліотеки, для людей, що реалізують нови типи колекцій.</p></div>
<div class="sect1">
<h2 id="_24_1____">24.1 Змінні та незмінні колекції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви вже знаєте, Scala колекції систематично відрізняють змінні та незмінні колекції. Змінні колекції можуть бути оновлені або розширені на місці. Це означає, що ви можете змінювати, додавати, або видаляти елементи колекції як побічний ефект. Незмінні колекції, для контрасту, ніколи не змінюються. Ви все ще маєте операції, що симулюють додавання, видалення або оновлення, але ці операції будуть в любому випадку повертати нову колекцію та залишати стару колекцію незмінною.</p></div>
<div class="paragraph"><p>Всі класи колекцій знаходяться в пакунку <code>scala.collection</code>, або одному з його субпакунків: <code>mutable</code>, <code>immutable</code> та <code>generic</code>. Більшість класів колекцій, що потрібні клієнтському коду, існують в трьох варіантах, кожний з яких має різні характеристики з точки зору змінності. Три варіанти розміщені в пакунках <code>scala.collection</code>, <code>scala.collection.immutable</code> та <code>scala.collection.mutable</code>.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection.immutable</code> гарантовано буде незмінною для будь-кого. Така колекція ніколи не буде змінюватись після її створення. Таким чином, ви можете покладатись на факт, що отримуєте доступ до значення тієї самої колекції постійно, і в різних точках часу будете завжди мати колекцію з тими самими елементами.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection.mutable</code> знана що має деякі операції, що змінюють колекцію на місці. Ці операції дозволяють вам писати код для зміни колекції самотужки. Однак ви маєте бути уважним, щоб розуміти та захищатись від любих оновлень, що виконують інші частини кодової бази.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection</code> може бути або змінною, або незмінною. Наприклад,<code>scala.collection.IndexedSeq[T]</code> є супертрейтом обох, <code>scala.collection.immutable.IndexedSeq[T]</code> та її родички, <code>scala.collection.mutable.IndexedSeq[T]</code>. Загалом, кореневі колекції в пакунку <code>scala.collection</code> визначають той самий інтерфейс, що і незмінні колекції. І типово, змінні колекції в пакунку <code>scala.collection.mutable</code> додають деякі модифікації з побічним ефектом до цього незмінного інтерфейсу.</p></div>
<div class="paragraph"><p>Різниця між кореневими колекціями та незмінними колекціями в тому, що клієнти назмінних колекцій мають гарантію, що ніхто не може змінити колекцію, коли як клієнти кореневих колекцій знають тільки, що вони самі не можуть змінити колекцію. Навіть зважаючи, що статичний тип такої колекції не провадить операцій для модифікації колекції, все ще може бути можливим, щоб тип часу виконання був змінною колекцією, що може бути змінена іншими клієнтами.</p></div>
<div class="paragraph"><p>По замовчанню Scala завжди обирає незмінні колекції. Наприклад, якщо ви просто пишете <code>Set</code> без жодного префіксу, або без імпорту будь-чого, ви отримаєте незмінну множину, і якщо ви напишете <code>Iterable</code>, ви отримаєте незмінне ітерабельне, оскільки ці прив'язки по замовчанню імпортуються з пакунка <code>scala</code>. Щоб отримати змінні версії по замовчанню, вам треба написати явно <code>collection.mutable.Set</code>, або <code>collection.mutable.Iterable</code>.</p></div>
<div class="paragraph"><p>Останній пакунок в ієрархії колекцій є <code>collection.generic</code>. Цей пакунок містить будівельні блоки для реалізації колекцій. Типово, класи колекцій відкладають реалізації деяких зі своїх операцій до класів в <code>generic</code>. З іншого боку, щоденні користувачі фреймворку колекцій мають потребу посилатись на класи в <code>generic</code> тільки за виключних обставин.</p></div>
<div class="sect2">
<h3 id="___2">Ієрархія колекцій.</h3>
<div class="listingblock">
<div class="content">
<pre><code>Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_2__">24.2 Узгодженість колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Найбільш важливі класи колекцій показані на Малюнку 24.1. Є досить загального, що поділяють ці класи. Наприклад, кожний різновид колекції може бути створений за однаковим уніформним синтаксисом, записуючи ім'я класу колекції, за яким ідуть його елементи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">Iterable</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">,</span> <span class="s">&quot;y&quot;</span><span class="o">,</span> <span class="s">&quot;z&quot;</span><span class="o">)</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">,</span> <span class="s">&quot;z&quot;</span> <span class="o">-&gt;</span> <span class="mi">26</span><span class="o">)</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Green</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>
<span class="nc">SortedSet</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">)</span>
<span class="nc">Buffer</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
<span class="nc">IndexedSeq</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="nc">LinearSeq</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Той самий принцип також стосується специфічних реалізацій колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">HashMap</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">,</span> <span class="s">&quot;z&quot;</span> <span class="o">-&gt;</span> <span class="mi">26</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>toString</code> для всіх колекцій продукує вивід, записаний як вище, з іменем типу, за яким в дужках ідуть елементи колекції. Всі колекції підтримують API, що провадить <code>Traversable</code>, але їх методи всі повертають їх власний клас, скоріше ніж кореневий клас  <code>Traversable</code>. Наприклад, метод <code>map</code> на <code>List</code> має тип повернення <code>List</code>, тоді як метод <code>map</code> на <code>Set</code> має тип повернення <code>Set</code>. Таким чином, статичний тип повернення ціх методів досить точний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Еквівалентність також організована одноманітно для всіх класів колекцій; більше про це в Розділі 24.13.</p></div>
<div class="paragraph"><p>Більшість класів на Малюнку 24.1 існують в трьох варіантах: <code>root</code>, <code>mutable</code> та <code>immutable</code>. Одне виключення є трейт <code>Buffer</code>, що існує тільки як змінна колекція.</p></div>
<div class="paragraph"><p>В залишку цієї глави ми будемо переглядати ці класи один за одним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_3__code_traversable_code">24.3 Трейт <code>Traversable</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>На вершині ієрархії колекцій стоїть трейт <code>Traversable</code> (<em>прохідний</em>). Його єдина операція є <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Класам колекцій, що реалізують <code>Traversable</code>, просто потрібно визначити цей метод; всі інші методи можуть бути наслідувані від <code>Traversable</code>.</p></div>
<div class="paragraph"><p>Метод <code>foreach</code> призначений для обходу всіх елементів колекції та застосування наданої операції <code>f</code> до кожного елементу. Тип операції <code>Elem =&gt; U</code>, де <code>Elem</code> є типом елементів колекції та <code>U</code> є довільним типом результату. Виклик <code>f</code> робиться тільки заради побічного ефекту; фактично, любий результат функції <code>f</code> буде відкинутий <code>foreach</code>.</p></div>
<div class="paragraph"><p><code>Traversable</code> також визначає багато суцільних методів, всі вони перелічені в Таблиці 24.1. Ці методи підпадають в такі категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Додавання</strong> <code>++</code>, що додає два прохідних разом, або додає всі елементи ітератора до прохідного.
</p>
</li>
<li>
<p>
<strong>Операції відображення</strong> <code>map</code>, <code>flatMap</code> та <code>collect</code>, що продукують нову колекцію через застосування деякої функції до елементів колекції.
</p>
</li>
<li>
<p>
<strong>Перетворення</strong> <code>toIndexedSeq</code>, <code>toIterable</code>, <code>toStream</code>, <code>toArray</code>, <code>toList</code>, <code>toSeq</code>, <code>toSet</code> та <code>toMap</code>, що повертають колекцію <code>Traversable</code> в більш специфічну колекцію. Всі ці перетворення повертають об'єкт отримувача, якщо він вже відповідає бажаному типу колекції. Наприклад, застосування <code>toList</code> до списку буде повертати сам список.
</p>
</li>
<li>
<p>
<strong>Операції копіювання</strong> <code>copyToBuffer</code> та <code>copyToArray</code>. Як кажуть їх імена, вони копіюють елементи колекції до буфера або масива, відповідно.
</p>
</li>
<li>
<p>
<strong>Операції розміру</strong> <code>isEmpty</code>, <code>nonEmpty</code>, <code>size</code> та <code>hasDefiniteSize</code>. Колекції, що є прохідними, можуть бути скінченими та нескінченими. Прикладом нескінченої прохідної колекції є потік натуральних чисел <code>Stream.from(0)</code>. Метод <code>hasDefiniteSize</code> вказує, що колекція, можливо, нескінчена. Якщо він повертає <code>false</code>, колекція може бути нескінченою, і в цьому випадку <code>size</code> буде видавати помилку або не повернеться.
</p>
</li>
<li>
<p>
<strong>Операції отримання елемента</strong> <code>head</code>, <code>last</code>, <code>headOption</code>, <code>lastOption</code> та <code>find</code>. Вони обирають перший або останній елемент колекції, або інакше перший елемент, що задовільняє умові. Однак зазначте, що не всі колекції мають гарно визначення значення того, що значить "перший" та "останній". Наприклад, хеш множина може зберігати елементи відповідно до їх хеш ключів, що можуть змінюватись від запуску до запуску. В цьому випадку "перший" елемент хеш набору також може бути різним для разних запусків програм. Колекція є впорядкована, якщо вона завжди видає свої елементи в тому самому порядку. Більшість колекцій впорядковані, але деякі (такі як хеш множини) ні — відкидання впорядкованості дає трохи додаткової ефективності. Порядок часто є основою для отримання повторюваних тестів та допомагає в зневадженні. Ось чому колекції Scala провадять впорядковані альтернативи для всіх типів колекцій. Наприклад, впорядкована альтернатива для <code>HashSet</code> є <code>LinkedHashSet</code>.
</p>
</li>
<li>
<p>
<strong>Операції отримання субколекцій</strong> <code>takeWhile</code>, <code>tail</code>, <code>init</code>, <code>slice</code>, <code>take</code>, <code>drop</code>, <code>filter</code>, <code>dropWhile</code>, <code>filterNot</code>, <code>withFilter</code>. Всі вони повертають деяку субколекцію, що ідентифікується диапазоном індексів або предикатом.
</p>
</li>
<li>
<p>
<strong>Операції підрозділу</strong> <code>splitAt</code>, <code>span</code>, <code>partition</code> та <code>groupBy</code> підрозділяють елементи колекції на декілька субколекцій.
</p>
</li>
<li>
<p>
<strong>Перевірка елементів</strong> <code>exists</code>, <code>forall</code> та <code>count</code> перевіряють елементи колекції за допомогою наданого предикату.
</p>
</li>
<li>
<p>
<strong>Згортки</strong> <code>foldLeft</code>, <code>foldRight</code>, <code>/:</code>, <code>:\</code>, <code>reduceLeft</code>, <code>reduceRight</code> застосовують двомісні операції до послідовних елементів.
</p>
</li>
<li>
<p>
<strong>Особливі згортки</strong> <code>sum</code>, <code>product</code>, <code>min</code>, <code>max</code> роблять з колекціями специфічних типів (числові або порівнювані).
</p>
</li>
<li>
<p>
<strong>Рядкові операції</strong> <code>mkString</code>, <code>addString</code>, <code>stringPrefix</code> провадять альтернативні шляхи перетворення колекції на рядок.
</p>
</li>
<li>
<p>
<strong>Операції переглядів</strong> складаються з двох перевантажених варіантів метода <code>view</code>. Перегляд є колекція, що обчислюється ліниво. Ви пізнаєте більше про перегляди в Розділі 24.14.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Абстрактний метод:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs foreach</p></td>
<td align="left" valign="top"><p class="table">Виконує функцію <code>f</code> для кожного елементу <code>xs</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Додавання:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++ ys</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з елементів обох, <code>xs</code> та <code>ys</code>.  <code>ys</code> є колекцією <code>TraversableOnce</code>, тобто або <code>Traversable</code>, або <code>Iterator</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Мапи:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs map</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування функції <code>f</code> до кожного елемента в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs flatMap</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування функції <code>f</code> від значень-колекції до кожного елементу в <code>xs</code> та конкатенації результатів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs collect</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування часткової функції <code>f</code> до кожного елементу в <code>xs</code>, для яких вона визначена та накопичення результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Перетворення:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toArray</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в масив.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toList</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в список.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toIterable</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в Iterable.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toSeq</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toIndexedSeq</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в індексовану послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toStream</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в потік (ліниво обчислювана послідовність).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toSet</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в множину.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toMap</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію пар ключ/значення в мапу.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Копіювання:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs copyToBuffer buf</p></td>
<td align="left" valign="top"><p class="table">Копіює всі елементи колекції в буфер <code>buf</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs copyToArray(arr, s, len)</p></td>
<td align="left" valign="top"><p class="table">Копіює щонайбільше <code>len</code> елементів <code>arr</code>, починаючи з індексу <code>s</code>. Два останні аргументи опціональні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Інформація про розмір:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.isEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція порожня.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.nonEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція містить елементи.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.size</p></td>
<td align="left" valign="top"><p class="table">Число елементів в колекції.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.hasDefiniteSize</p></td>
<td align="left" valign="top"><p class="table">True, якщо відомо, що xs має фіксований розмір.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Отримання елементів:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.head</p></td>
<td align="left" valign="top"><p class="table">Перший елемент колекції (або деякий елемент, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.headOption</p></td>
<td align="left" valign="top"><p class="table">Перший елемент <code>xs</code> в опціональному значенні, або <code>None</code>, якщо <code>xs</code> порожнє.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.last</p></td>
<td align="left" valign="top"><p class="table">Останній елемент колекції (або деякий елемент, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.lastOption</p></td>
<td align="left" valign="top"><p class="table">Останній елемент <code>xs</code> в опціональному значенні, або <code>None</code>, якщо <code>xs</code> порожнє.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs find</p></td>
<td align="left" valign="top"><p class="table">Опція, яка містить перший елемент в <code>xs</code>, що задовільняє <code>p</code>, або <code>None</code>, якщо жодний елемент не підійде.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Субколекції:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.tail</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs.head</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.init</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs.last</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs slice (from, to)</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з елементів <code>xs</code> в деякому диапазоні індексів (від <code>from</code> до <code>to</code>, виключно).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs take</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з перших <code>n</code> елементів <code>xs</code> (або деякі довільні <code>n</code> елементів, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs drop</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs take n</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs takeWhile</p></td>
<td align="left" valign="top"><p class="table">Найдовший префікс елементів в колекції, що задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs dropWhile</p></td>
<td align="left" valign="top"><p class="table">Колекція без найдовшого префіксу елементів, всі з яких задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs filter</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з тих елементів <code>xs</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs withFilter</p></td>
<td align="left" valign="top"><p class="table">Не-строгий фільтр для цієї колекції. Всі операції на отриманому фільтрі будуть застосовані тільки для тих елементів <code>xs</code>, для яких мова <code>p</code> є <code>true</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs filterNot</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з тих елементів <code>xs</code>, що не задовільняють предикатові <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Суброзподіл:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs splitAt</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> в позициї <code>n</code>, даючи пару колекцій (<code>xs take n</code>, <code>xs drop n</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs span</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> відповідно до предикату, даючи пару колекцій (<code>xs takeWhile p</code>, <code>xs.dropWhile p</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs partition</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> на пару колекцій; одна з елементами, що задовільняють предикату <code>p</code>, інша з елементами, що ні, даючи пару колекцій(<code>xs filter p</code>, <code>xs.filterNot p</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs groupBy</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> на мапу колекцій, відповідно до функції дескреминатору <code>f</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Умови до елементів:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs forall</p></td>
<td align="left" valign="top"><p class="table">Логічне, що визначає, чи предикат <code>p</code> дотримується до всіх елементів <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs exists</p></td>
<td align="left" valign="top"><p class="table">Логічне, що вказує, чи предикат <code>p</code> дотримується до деякого елемента в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs count</p></td>
<td align="left" valign="top"><p class="table">Число елементів в <code>xs</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Згортки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(z /: xs)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами <code>xs</code>, ідучи зліва направо, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(xs :\ z)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами <code>xs</code>, ідучи зправа наліво, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.foldLeft(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>(z /: xs)(op)</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.foldRight(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>(xs :\ z)(op)</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reduceLeft op</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами непорожньої колекції <code>xs</code>, ідучи зліва направо.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reduceRight op</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами непорожньої колекції <code>xs</code>, ідучи зправа наліво.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Особливі згортки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.sum</p></td>
<td align="left" valign="top"><p class="table">Сума числових значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.product</p></td>
<td align="left" valign="top"><p class="table">Добуток числових значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.min</p></td>
<td align="left" valign="top"><p class="table">Мінімум впорядкованих значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.max</p></td>
<td align="left" valign="top"><p class="table">Максімум впорядкованих значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Рядки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs addString (b, start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Додає рядок до <code>StringBuilder</code> <code>b</code>, що показує всі елементи <code>xs</code>, розділені роздільниками <code>sep</code> та оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs mkString (start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію на рядок, що показує всі елементи <code>xs</code> між роздільниками <code>sep</code> та оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.stringPrefix</p></td>
<td align="left" valign="top"><p class="table">The collection name at the beginning of the string returned from xs.toString.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Перегляди:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.view</p></td>
<td align="left" valign="top"><p class="table">Продукує перегляд xs.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs view (from, to)</p></td>
<td align="left" valign="top"><p class="table">Продукує перегляд, що представляє елементи в деякому диапазоні індексів <code>xs</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<h1 id="_24_4__iterable">24.4 Трейт Iterable</h1>
<div class="paragraph"><p>Наступний трейт зверху на Малюнку 24.1 є <code>Iterable</code>. Всі методи в цьому трейті визначені в термінах абстрактного метода <code>iterator</code>, що видає елементи колекції один за одним. Абстрактний метод <code>foreach</code>, наслідуваний від трейту <code>Traversable</code>, реалізований в <code>Iterable</code> в термінах <code>iterator</code>. Ось справжня реалізація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="n">f</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лише кілька субкласів <code>Iterable</code> перекривають цю стандартну реалізацію <code>foreach</code> в <code>Iterable</code>, оскільки вони можуть провадити більш ефективну реалізацію. Пам'ятайте, що <code>foreach</code> є основою для реалізації всіх операцій в <code>Traversable</code> так що продуктивність важлива.</p></div>
<div class="paragraph"><p>Ще два метода існують в <code>Iterable</code>, що повертають ітератори: <code>grouped</code> та <code>sliding</code>. Однак ці ітератори не повертають поодинокі елементи, але цілі субпослідовності елементів оригінальної колекції. Максимальний розмір ціх послідовностей надається як аргумент до ціх методів. Метод <code>grouped</code> розбиває свої елементи на інкрементальні пакунки, тоді як <code>sliding</code> дає ковзаюче вікно по елементах. Різниця між двома стане яснішою при погляді на наступні взаємодії в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">git</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">grouped</span> <span class="mi">3</span>
<span class="n">git</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sit</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">sliding</span> <span class="mi">3</span>
<span class="n">sit</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Трейт <code>Iterable</code> також додає деякі інші методи до <code>Traversable</code>, що можуть бути ефективно реалізовані тільки за наявності ітератора. Вони підсумовані в Таблиці 24.2:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Абстрактний метод:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">iterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожний елемент в <code>xs</code>, в тому самому порядку, як <code>foreach</code> проходить по елементах</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Інші ітератори:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs grouped size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає "частки" колекції фіксованого розміру</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sliding size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає ковзне вікно фіксованого розміру з елементів колекції</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Субколекції:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs takeRight</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з останніх <code>n</code> елементів <code>xs</code> (або довільні <code>n</code> елементів, якщо порядок не визначений)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs dropRight</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs takeRight n</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Поєднувачі:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs zip ys</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар відповідних елементів з <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs zipAll (ys, x, y)</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар відповідних елементів з <code>xs</code> та <code>ys</code>, де коротша послідовність розширюється, щоб співпадати до довшої, через додавання елементів <code>x</code> або <code>y</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.zipWithIndex</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар елементів <code>xs</code> разом з їх індексами</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Порівняння:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sameElements ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> та <code>ys</code> містять ті самі елементи в тому ж порядку</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="____code_traversable_code__code_iterable_code">Чому мати обоє, <code>Traversable</code> та <code>Iterable</code>?</h3>
<div class="paragraph"><p>Ви можете здивуватись, для чого додатковий трейт <code>Traversable</code> над <code>Iterable</code>. Чи не могли б зробити все з ітератором? То яка ідея мати більш абстрактний трейт, що визначає свої методи в термінах <code>foreach</code> замість <code>iterator</code>? Одна причина мати <code>Traversable</code> в тому, що іноді простіше або більш ефективно провадити реалізацію для <code>foreach</code>, ніж провадити реалізацію ітератора. Ось простий приклад. Скажімо, ви бажаєте ієрархію класів для бінарних дерев, що мають цілі елементи на листках. Ви можете розробиби цю ієрархію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер вважатимемо, ви бажаєте зробити дерева перехідними. Щоб зробити це, треба щоб <code>Tree</code> наслідував від <code>Traversable[Int]</code> та визначав метод <code>foreach</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">;</span> <span class="n">r</span> <span class="n">foreach</span> <span class="n">f</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не дуже складно, і це також дуже ефективно — перехід по збалансованому дереву пропорційно до числа елементів в дереві. Щоб побачити це, уявімо, що збалансоване дерево з <code>N</code> листками буде мати <code>N - 1</code> внутрішніх листків класу <code>Branch</code>. Так що загальна кількість кроків для обходу дерева є <code>N + N - 1</code>.</p></div>
<div class="paragraph"><p>Тепер порівняйте це з робленням дерев ітерабельними. Щоб зробити це, робимо <code>Tree</code> походячим від <code>Iterable[Int]</code> та визначаємо метод <code>iterator</code> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">.</span><span class="n">single</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">iterator</span> <span class="o">++</span> <span class="n">r</span><span class="o">.</span><span class="n">iterator</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>На перший погляд це виглядає не складніше, ніж рішення <code>foreach</code>. Однак є проблема ефективності, що стосується реалізації метода конкатенації ітератора, <code>++</code>. Кожного разу,коли продукується елемент конкатенованим ітератором, як в <code>l.iterator ++ r.iterator</code>, обчислення потребує слідувати одному непрямому переходу, щоб отримати вірний ітератор (<code>l.iterator</code> або <code>r.iterator</code>). Загалом це робить <code>log(N)</code> перенаправлень, щоб отримати листок збалансованого дерева з <code>N</code> leaves. Так що ціна відвідування всіх елементів дерева становить від близько <code>2N</code> для метода обходу <code>foreach</code>, до <code>Nlog(N)</code> для проходу за допомогою ітератору. Якщо дерево має мільйон елементів, це означає близько двох мільйонів кроків для <code>foreach</code>, і біля двадцяти (?) мільйонів кроків для <code>iterator</code>. Так що рішення <code>foreach</code> має явну перевагу.</p></div>
</div>
<div class="sect2">
<h3 id="__iterable">Субкатегорії Iterable</h3>
<div class="paragraph"><p>В ієрархії наслідування нижче <code>Iterable</code> ви знайдете три трейти: <code>Seq</code>, <code>Set</code> та <code>Map</code>. Загальний аспект ціх трьох трейтів в тому, що всі вони реалізують трейт <code>PartialFunction</code>,<span class="footnote"><br />[Часткові функції були описані в Розділі 15.7.]<br /></span> з його методами <code>apply</code> та <code>isDefinedAt</code>. Однак спосіб, в який кожний трейт реалізує <code>PartialFunction</code>, відрізняється.</p></div>
<div class="paragraph"><p>Для послідовностей <code>apply</code> є позиційне індексування, де елементи завжди пронумеровані від <code>0</code>. Тобто, <code>Seq(1, 2, 3)(1) == 2</code>. Для множин <code>apply</code> є перевіркою належності. Наприклад, <code>Set('a', 'b', 'c') ('b') == true</code>, тоді як <code>Set()('a') == false</code>. Нарешті, для мап <code>apply</code> є вибір. Наприклад, <code>Map('a' - &gt; 1, 'b' -&gt; 10, 'c' -&gt; 100)('b') == 10</code>.</p></div>
<div class="paragraph"><p>В наступних трьох розділах ми пояснимо кожний з трьох типів колекцій більш детально.</p></div>
</div>
<div class="sect1">
<h2 id="_24_5___code_seq_code_code_indexedseq_code_code_linearseq_code">24.5 Трейти послідовностей <code>Seq</code>, <code>IndexedSeq</code>, <code>LinearSeq</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Трейт <code>Seq</code> представляє послідовності. Послідовність різновид ітерабельного, що має довжину та чиї елементи мають фіксовані індексовані позиції, починаючи від 0. Операції над послідовностями, підсумовані на Малюнку 24.3, підпадають в наступні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Операції індексування та довжини</strong> <code>apply</code>, <code>isDefinedAt</code>, <code>length</code>, <code>indices</code> та <code>lengthCompare</code>. Для <code>Seq</code> операція <code>apply</code> означає індексування; таким чином послідовність типу <code>Seq[T]</code> є частковою функцією, що приймає аргумент <code>Int</code> (індекс) та видає елемент послідовності типу <code>T</code>. Іншими словами, <code>Seq[T]</code> розширює <code>PartialFunction[Int, T]</code>. Елементи послідовності індексовані від нуля до довжини послідовності мінус один. Метод <code>length</code> на послідовностях є псевдонимом метода <code>size</code> на загальних колекціях. Метод <code>lengthCompare</code> дозволяє вам порівнювати довжину двох послідовностей, навіть якщо одна з послідовностей має безкінечну довжину.
</p>
</li>
<li>
<p>
<strong>Операції пошуку індексу</strong> <code>indexOf</code>, <code>lastIndexOf</code>, <code>indexOfSlice</code>, <code>lastIndexOfSlice</code>,<code>indexWhere</code>, <code>lastIndexWhere</code>, <code>segmentLength</code> та <code>prefixLength</code> повертають індекс елементу, рівному до заданого значення або співпадаючий з деяким предикатом.
</p>
</li>
<li>
<p>
<strong>Операції додавання</strong> <code>+:</code>, <code>:+</code> та <code>padTo</code>, повертають нову послідовність, отриману від додавання елементів зпереду або з кінця послідовності.
</p>
</li>
<li>
<p>
<strong>Операції оновлення</strong> <code>updated</code> та <code>patch</code>, що повертають нову послідовність, отриману від заміни деяких елементів оригінальної послідовності.
</p>
</li>
<li>
<p>
<strong>Операції сортування</strong> <code>sorted</code>, <code>sortWith</code> та <code>sortBy</code> сортують елементи послідовності відповідно до різних критеріїв.
</p>
</li>
<li>
<p>
<strong>Операції обертання</strong> <code>reverse</code>, <code>reverseIterator</code> та <code>reverseMap</code> видають або обробляють елементи послідовності в зворотньому порядку, від останнього до першого.
</p>
</li>
<li>
<p>
<strong>Операції порівняння</strong> <code>startsWith</code>, <code>endsWith</code>, <code>contains</code>, <code>corresponds</code> та <code>containsSlice</code> співвідносить дві послідовності або шукає елемент в послідовності.
</p>
</li>
<li>
<p>
<strong>Множинні операції</strong> <code>intersect</code>, <code>diff</code>, <code>union</code> та <code>distinct</code> виконують множино-подібні операції на елементах двох послідовностей, або видаляють дублікати.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо послідовність змінна, вона пропонує додатковий метод з побічним ефектом <code>update</code>, що дозволяє оновлювати елементи. Згадайте з Глави 3, що синтаксис як <code>seq(idx) = elem</code> є просто скороченням для <code>seq.update(idx, elem)</code>. Зауважте різницю між <code>update</code> та <code>updated</code>. Метод <code>update</code> змінює елемент послідовності на місці та доступний тільки для змінних послідовностей. Метод <code>updated</code> доступний для всіх послідовностей та завжди повертає нову послідовність, замість модифікації оригіналу.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Індексування та довжина:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(i)</p></td>
<td align="left" valign="top"><p class="table">(або, розписано,<code>xs apply i</code>) Елемент <code>xs</code> за індексом <code>i</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs isDefinedAt</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>i</code> міститься в <code>xs.indices</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.length</p></td>
<td align="left" valign="top"><p class="table">Довжина послідовності (те саме, що і <code>size</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.lengthCompare ys</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>-1</code>, якщо <code>xs</code> коротше за <code>ys</code>, <code>+1</code> якщо довше та <code>0</code> якщо вони мають рівну довжину. Робить, навіть якщо послідовності безкінечні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.indices</p></td>
<td align="left" valign="top"><p class="table">Диапазон індексів <code>xs</code>, що простягається від <code>0</code> до <code>xs.length - 1</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Індексний пошук:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу в <code>xs</code> рівному <code>x</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs lastIndexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс останнього елементу в <code>xs</code> рівному <code>x</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexOfSlice ys</p></td>
<td align="left" valign="top"><p class="table">Перший індекс <code>xs</code> такий, що наступні елементи починаючи з цього індексу формують послідовність <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs lastIndexOfSlice ys</p></td>
<td align="left" valign="top"><p class="table">Останній індекс <code>xs</code> такий, що наступні елементи починаючи з цього індексу формують послідовність <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexWhere</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу <code>xs</code>, задовільняє <code>p</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs segmentLength (p, i)</p></td>
<td align="left" valign="top"><p class="table">Довжина найдовшого неперериваного сегменту елементів <code>xs</code>, починаючи з <code>xs(i)</code>, всі з яких задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs prefixLength</p></td>
<td align="left" valign="top"><p class="table">Довжина найдовшого префіксу з елементів <code>xs</code>, всі з яких задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">x +: xs</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, що складається з <code>x</code> перед <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs :+</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, що складається з <code>x</code> після <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs padTo (len, x)</p></td>
<td align="left" valign="top"><p class="table">Послідовність, що утворюється як результат від додавання значення <code>x</code> до <code>xs</code>, доки не буде досяжена довжина <code>len</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs patch (i, ys, r)</p></td>
<td align="left" valign="top"><p class="table">Послідовність як результат від заміни <code>r</code> елементів <code>xs</code>, починаючи з <code>i</code> на латку <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs updated (i, x)</p></td>
<td align="left" valign="top"><p class="table">Копія <code>xs</code>, з елементом з індексом <code>i</code>, заміненим на <code>x</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(i) =</p></td>
<td align="left" valign="top"><p class="table">(або, розписане, <code>xs.update(i, x)</code>, доступне тільки для` mutable.Seq`). Зміна елементу <code>xs</code> по індексу <code>i</code> на <code>y</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Сортування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.sorted</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів  <code>xs</code> з використанням стандартного впорядкування типу елементів <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sortWith lessThan</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів <code>xs</code>, використовуючи <code>lessThan</code> як операції порівняння.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sortBy</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів <code>xs</code>. Порівняння між двома елементами обробляється через відображення двох елементів функцією <code>f</code> над обома та порівняння результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Обернення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.reverse</p></td>
<td align="left" valign="top"><p class="table">Послідовність з елементами <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.reverseIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає всі елементи <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reverseMap</p></td>
<td align="left" valign="top"><p class="table">Послідовність, отримана від відображення <code>f</code> над елементами <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Порівняння:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs startsWith ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> починається з послідовності <code>ys</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs endsWith ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> закінчується на <code>ys</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> має елемент, що дорівнює <code>x</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs containsSlice ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> має послідовність, що дорівнює <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(xs corresponds ys)(p)</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи відповідні елементи <code>xs</code> та <code>ys</code> задовільняють двомісному предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Множинні операції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs intersect ys</p></td>
<td align="left" valign="top"><p class="table">Множинний перетин послідовностей <code>xs</code> та <code>ys</code>, що зберігає порядок елементів в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs diff ys</p></td>
<td align="left" valign="top"><p class="table">Множинна різниця послідовностей <code>xs</code> та <code>ys</code>, що зберігає порядок елементів в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs union ys</p></td>
<td align="left" valign="top"><p class="table">Множинне об'єднання; те саме, що <code>xs ++ ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.distinct</p></td>
<td align="left" valign="top"><p class="table">Субпослідовність <code>xs</code>, що не містить дублікатів.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Кожний трейт <code>Seq</code> має два субтрейти, <code>LinearSeq</code> та <code>IndexedSeq</code>. Вони не додають жодних нових операцій, але кожний пропонує різні характеристики продуктивності. Лінійна послідовність має ефективні операції <code>head</code> та <code>tail</code>, тоді як індексована послідовність має ефективні операції <code>apply</code>, <code>length</code> та (якщо <code>mutable</code>) <code>update</code>. <code>List</code> є часто використовувана лінійна послідовність, як і <code>Stream</code>. Дві часто використовувані індексовані послідовності є <code>Array</code> та <code>ArrayBuffer</code>. Клас <code>Vector</code> провадить цікавий компроміс між індексованим та лінійним доступом. Він має однаково ефективний сталий час індексного навантаження та сталий час лінійного доступу. Завдяки цьому вектори є гарною основою для шаблонів змішаного доступу, коли одночасно використовується індексний та лінійний доступи. Більше про вектори в Розділі 24.8.</p></div>
<div class="sect2">
<h3 id="_">Буфери</h3>
<div class="paragraph"><p>Важлива суб-категорія змінних послідовностей є буфери. Буфери дозволяють не тільки оновлення існуючих елементів, але також вставки елементів, видалення елементів та ефективне додавання нових елементів в кінець буфера. Принципово нові методи, що підтримуються буферами, є <code>+=</code> та <code>++=</code> для додавання елементів в кінець та <code>+=:</code> і <code>++=:</code> для додавання зпереду, <code>insert</code> та <code>insertAll</code> для вставок елементів так само як <code>remove</code> та <code>-=</code> для видалення елементів. Ці These operations are summarized in Table 24.4.</p></div>
<div class="paragraph"><p>Дві реалізації <code>Buffer</code> в загальному ужитку є <code>ListBuffer</code> та <code>ArrayBuffer</code>. Як підказує ім'я, <code>ListBuffer</code> підтримується <code>List</code> та підтримує ефективне перетворення його елементів <code>List</code>, тоді як  <code>ArrayBuffer</code> покладається на масив та може бути швидко перетворений на такий. Ви бачили проблиск реалізації <code>ListBuffer</code> в Розділі 22.2.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf +=</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до буфера <code>buf</code> та повертає самий <code>buf</code> як результат</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf += (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Додає надані елементи до буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf ++= xs</p></td>
<td align="left" valign="top"><p class="table">Додає всі елементи в <code>xs</code> до буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">x +=: buf</p></td>
<td align="left" valign="top"><p class="table">Ставить елемент <code>x</code> в початок буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++=: buf</p></td>
<td align="left" valign="top"><p class="table">Ставить всі елементи <code>xs</code> в початок буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf insert (i, x)</p></td>
<td align="left" valign="top"><p class="table">Вставляє елемент <code>x</code> по індексу <code>i</code> в буфер</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf insertAll (i, xs)</p></td>
<td align="left" valign="top"><p class="table">Вставляє всі елементи в <code>xs</code> по індексу <code>i</code> в буфер</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент <code>x</code> з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє елементпо індексу <code>i</code> з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf remove (i, n)</p></td>
<td align="left" valign="top"><p class="table">Видаляє <code>n</code> елементів, починаючи з індексу <code>i</code>, з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf trimStart</p></td>
<td align="left" valign="top"><p class="table">Видаляє перші <code>n</code> елементів з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf trimEnd</p></td>
<td align="left" valign="top"><p class="table">Видаляє останні <code>n</code> елементів з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи з буфера</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf.clone</p></td>
<td align="left" valign="top"><p class="table">Новий буфер з тими самим елементами, що і <code>buf</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_6_">24.6 Множини</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>Set</code> є <code>Iterable</code>, що не містить дублікатів елементів. Операції з множинами підсумовані в Таблиці 24.5 для <code>general</code> множин, і Таблиці 24.6 <code>mutable</code> множин. Вони підпадають під наступні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Перевірки</strong> <code>contains</code>, <code>apply</code> та <code>subsetOf</code>. Метод <code>contains</code> вказує, чи множина містить наданий елемент. Метод <code>apply</code> для множини те саме, що і <code>contains</code> так що <code>set(elem)</code> відповідає до  <code>set contains elem</code>. Це означає, що множини можуть також використовуватись як функції перевірки, що повертають <code>true</code> для елементів, які вони містять. Наприклад:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span><span class="o">,</span> <span class="s">&quot;peach&quot;</span><span class="o">,</span> <span class="s">&quot;banana&quot;</span><span class="o">)</span>
<span class="n">fruit</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="n">apple</span><span class="o">,</span> <span class="n">orange</span><span class="o">,</span> <span class="n">peach</span><span class="o">,</span> <span class="n">banana</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">(</span><span class="s">&quot;peach&quot;</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">(</span><span class="s">&quot;potato&quot;</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Додавання</strong> <code>+</code> and <code>++</code> додають до множини один або більше елементів, даючи нову множини в якості результату.
</p>
</li>
<li>
<p>
<strong>Видалення</strong> <code>-</code> та <code>--</code> видаляють один або більше з множини, даючи нову множину.
</p>
</li>
<li>
<p>
<strong>Операції множин</strong> для об'єднання, перетину та різниці. Ці операції існують в двох фломах: алгебраїчній та символічній. Алгебраїчні версії є <code>intersect</code>, <code>union</code> та <code>diff</code>, тоді як символічні версії <code>&amp;</code>, <code>|</code> та <code>&amp;~</code>. Метод <code>++</code>, який <code>Set</code> наслідує від <code>Traversable</code>, може розглядатись як ще один псевдоним для <code>union</code> або <code>|</code>, за винятком того, що <code>++</code> приймає аргумент <code>Traversable</code>, коли <code>union</code> та <code>|</code> приймають множини.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перевірки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>x</code> є елементом <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(x)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <code>xs contains x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs subsetOf ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> є підмножиною <code>ys</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs +</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само як <code>x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs + (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само як надані додаткові елементи</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++ ys</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само, як всі елементи <code>ys</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, за винятком <code>x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs - (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, за винятком наданих елементів</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs&#8201;&#8212;&#8201;ys</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, крім елементів в <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.empty</p></td>
<td align="left" valign="top"><p class="table">Порожня множина такого ж класу, що і <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Бінарні операції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs &amp; ys</p></td>
<td align="left" valign="top"><p class="table">Перетин множин <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs intersect ys</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>xs &amp; ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs | ys</p></td>
<td align="left" valign="top"><p class="table">Поєднання множин <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs union ys</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і `xs</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ys`</p></td>
<td align="left" valign="top"><p class="table">xs &amp;~ ys</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Різниця множин <code>xs and ys</code></p></td>
<td align="left" valign="top"><p class="table">xs diff ys</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Змінні множини мають методи, що додають, видаляють або оновлюють елементи, що підсумовані в Таблиці 24.6:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить
2+"Додавання:</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">xs +=</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до множини <code>xs</code> як побічний ефект та повератє сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs += (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Додає надані елементи до множини як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++= ys</p></td>
<td align="left" valign="top"><p class="table">Додає всі елементи з <code>ys</code> до множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs add</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до <code>xs</code> та повертає <code>true</code>, якщо <code>x</code> досі не був членом множини, <code>false</code> якщо він був там</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент <code>x</code> з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -= (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Видаляє надані елементи з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs --= ys</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи в <code>ys</code> з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє <code>x</code> з <code>xs</code> та повертає <code>true</code>, якщо <code>x</code> до цього містився в множині, <code>false</code> якщо ні</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs retain</p></td>
<td align="left" valign="top"><p class="table">Залишає лише ті елементи в <code>xs</code>, що задовільняють предикату <code>p</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи з <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(x) =</p></td>
<td align="left" valign="top"><p class="table">(або, розписано, <code>xs.update(x, b)</code>) Якщо логічний аргумент <code>b</code> є <code>true</code>, додає <code>x</code> до <code>xs</code>, інакше видаляє <code>x</code> з <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.clone</p></td>
<td align="left" valign="top"><p class="table">Нова змінна множина з тими ж елементами, що і <code>xs</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Так само, як незмінні множини, змінні множини пропонують операції  <code>+</code> та <code>++</code> для додавання елементів та <code>-</code> та <code>--</code> для видалення елементів. Але вони рідше використовуються для змінних множин, оскікльки це включає копіювання множини. Ак більш ефективна альтернатива, змінні множини пропонують методи оновлення <code>+=</code> та <code>- =</code>. Операція <code>s += elem</code> додає <code>elem</code> до множини <code>s</code> в якості побічного ефекту та повертає змінену множину як результат. Подібно до цього, <code>s -= elem</code> видаляє <code>elem</code> з множини та повертає змінену множину як результат. Окрім <code>+=</code> та <code>-=</code> також існують масові операції <code>++=</code> та <code>--=</code>, що додають або видаляють всі елементи перехідного або ітератора.</p></div>
<div class="paragraph"><p>Вибір імен методів, <code>+=</code> та <code>-=</code> означає, що дуже подібний код буде робити однаково, зі змінними та незмінними множинами. Зпочатку розглянемо наступний диалог в інтерпретаторі, що використовує незмінну множину <code>s</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span> <span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі ми використали <code>+=</code> та <code>-=</code> на <code>var</code> типу <code>immutable.Set</code>. Як було пояснено на Кроці 10 в Главі 3, а твердження як <code>s += 4</code> є скороченням для <code>s = s + 4</code>. Так що це викликає метод додавання <code>+</code> на множині <code>s</code> та потім присвоює результат назад до змінної <code>s</code>. Розглянемо тепер аналогічну взаємодію зі змінним набором:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The end effect is very similar to the previous interaction; we start with a Set(1, 2, 3) and end up with a Set(1, 3, 4). However, even though the statements look the same as before, they do something different. The s += 4 statement now invokes the += method on the mutable set values, changing the set in place. Likewise, the s -= 2 statement now invokes the -= method on the same set.</p></div>
<div class="paragraph"><p>Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.</p></div>
<div class="paragraph"><p>Mutable sets also provide add and remove as variants of += and -=. The difference is that add andremove return a boolean result indicating whether the operation had an effect on the set.</p></div>
<div class="paragraph"><p>The current default implementation of a mutable set uses a hash table to store the set&#8217;s elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as hash tries.<span class="footnote"><br />[Hash tries are described in Section 24.8.]<br /></span></p></div>
<div class="paragraph"><p>A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_7_">24.7 Мапи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Maps are Iterables of pairs of keys and values (also named mappings or associations). As explained in Section 21.4, Scala&#8217;s Predef class offers an implicit conversion that lets you writekey &#8594; value as an alternate syntax for the pair (key, value). Therefore, Map("x" &#8594; 24, "y" &#8594; 25, "z" &#8594; 26) means exactly the same as Map"x", but reads better.</p></div>
<div class="paragraph"><p>The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets. Mutable maps additionally support the operations shown in Table 24.8. Map operations fall into the following categories:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Lookups</strong> apply, get, getOrElse, contains, and isDefinedAt. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Value</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>The operation "m get key" tests whether the map contains an association for the given key. If so, it returns the associated value in a Some. If no key is defined in the map, get returns None. Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option. If the key is not defined in the map, an exception is raised.</p></div>
<div class="ulist"><ul>
<li>
<p>
Additions and updates <code>, +</code>, and updated, which let you add new bindings to a map or change existing bindings.
</p>
</li>
<li>
<p>
Removals - and --, which remove bindings from a map.
</p>
</li>
<li>
<p>
Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map&#8217;s keys and values separately in various forms.
</p>
</li>
<li>
<p>
Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Пошук:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms get</p></td>
<td align="left" valign="top"><p class="table">Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>, як опція, або <code>None</code>, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms(k)</p></td>
<td align="left" valign="top"><p class="table">(або, розписане, <code>ms apply k</code>) Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>, або закидає виключення, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms getOrElse (k, d)</p></td>
<td align="left" valign="top"><p class="table">Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>,або значення по замовчанню <code>d</code>, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>ms</code> містить відображення для ключа <code>k</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms isDefinedAt</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>contains</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання та оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms + (k &#8594; v)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code> так само, як і <code>gk -&gt; v</code> ключа <code>k</code> на значення <code>v</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms + (k &#8594; v, l &#8594; w)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code>, разом з наданими парами ключ/значення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms ++ kvs</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code> так само, як і пари ключ/значення з <code>kvs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms updated (k, v)</p></td>
<td align="left" valign="top"><p class="table">Таке саме, що і <code>ms + (k -&gt; v)</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення з <code>ms</code>, за винятком любих відображень для ключа <code>k</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms - (k, l, m)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code>, за винятком всіх відображень з наданими ключамі</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms&#8201;&#8212;&#8201;ks</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення з <code>ms</code>, за винятком любих відображень з ключами в <code>ks</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Субколекції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keys</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне, що містить любий ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keySet</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить кожний ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keysIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожний ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.values</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне, що містить кожне значення, асоційоване з ключем в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.valuesIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожне значення, асоційоване з ключем в <code>ms</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms filterKeys</p></td>
<td align="left" valign="top"><p class="table">Перегляд мапи, що містить тільки ті відображення, в яких ключ відповідає предикату <code>p</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms mapValues</p></td>
<td align="left" valign="top"><p class="table">Перегляд мапи, отриманий від застосування функції <code>f</code> до кожного значення, асоційованого з ключем в <code>ms</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання та оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms(k) =</p></td>
<td align="left" valign="top"><div class="verse">(або, розписано, <code>ms.update(k, v)</code>) Додає відображення ключа <code>k</code> на значення <code>v</code> до мапи <code>ms</code> як побічний ефект, переписуючи любі попередні відображення <code>k</code></div></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms += (k &#8594; v)</p></td>
<td align="left" valign="top"><p class="table">Додає відображення ключа <code>k</code> на значення <code>v</code> до мапи <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms += (k &#8594; v, l &#8594; w)</p></td>
<td align="left" valign="top"><p class="table">Додає надані відображення до <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms ++= kvs</p></td>
<td align="left" valign="top"><p class="table">Додає всі відображення в <code>kvs</code> до <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms put (k, v)</p></td>
<td align="left" valign="top"><p class="table">Додає відображення ключа <code>k</code> на значення <code>v</code> до <code>ms</code> та повертає любе значення, асоційоване до цього з <code>k</code>, як опцію</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms getOrElseUpdate (k, d)</p></td>
<td align="left" valign="top"><p class="table">Якщо ключ <code>k</code> визначений в мапі <code>ms</code>, повертає його асоційоване значення. Інакше оновлює <code>ms</code> відображенням <code>k -&gt; d</code> та повертає <code>d</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє відображення ключа <code>k</code> з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -= (k, l, m)</p></td>
<td align="left" valign="top"><p class="table">Видаляє відображення наданних ключів з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms --= ks</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі ключі в <code>ks</code> з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє любі відображення ключа <code>k</code> з <code>ms</code> та повертає любе значення, до цього асоційоване з <code>k</code>, як опцію</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms retain</p></td>
<td align="left" valign="top"><p class="table">Зберігає тільки ті відображення в <code>ms</code>, ключ яких задовільняє предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі відображення з <code>ms</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення та клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms transform</p></td>
<td align="left" valign="top"><p class="table">Перетворює всі асоційовані значення в мапі <code>ms</code> функцією <code>f</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.clone</p></td>
<td align="left" valign="top"><p class="table">Повертає нову змінну мапу з тими самими відображеннями, що і <code>ms</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Операції додавання та видалення для мап повторюють такі самі для множин. Як і для множин, змінні мапи також підтримують неруйнівні операції додавання <code>+</code>, <code>-</code> та <code>updated</code>, але вони використовуються менш часто, оскільки вони включають копіювання змінної мапи. Замість цього, змінна мапа <code>m</code> звичайно оновлюється "на місці", використовуючи два варіанти, <code>m(key) = value</code> або <code>m += (key -&gt; value)</code>. Також є варіант <code>m put (key, value)</code>, що повертає значення <code>Option</code>, що складається зі значення, до того асоційованого з ключем, або <code>None</code>, якщо ключ не існував в мапі до цього.</p></div>
<div class="paragraph"><p>Метод <code>getOrElseUpdate</code> корисний для доступу до мап, що діють як кеші. Скажімо, ви маєте коштовне обчислення, що перемикається викликом функції <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;taking my time.&quot;</span><span class="o">);</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">reverse</span> <span class="o">}</span>
<span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Далі уявімо, що <code>f</code> не має побічних ефектів так що повторний виклик з тими ж аргументами буде завжди давати той самий результат. В такому випадку ви можете зберігти час, зберігаючи попередньо обчислені прив'язки аргументів та результати <code>f</code> в мапі та обчислювати результат <code>f</code>, якщо результат від аргументів ще не знаходиться там. Ви можете сказати, що мапа є кешем для обчислення функції <code>f</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">cache</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви можете створити більш ефективну кешовану версію фукнції <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="n">cachedF</span><span class="k">:</span> <span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cachedF</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">taking</span> <span class="n">my</span> <span class="n">time</span><span class="o">.</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cba</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cachedF</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cba</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що другий аргумент <code>getOrElseUpdate</code> є "за ім'ям" так що обчислення <code>f("abc")</code> вище виконується тільки якщо <code>getOrElseUpdate</code> потрубує значення свого другого аргументу, що саме коли перший аргумент не знайдений в кеш мапі. Ви також можете реалізувати <code>cachedF</code> напряму, використовуючи базові операції з мапами, але щоб зробити це знадобиться більше кода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span> <span class="n">get</span> <span class="n">arg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
    <span class="n">cache</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="k">=</span> <span class="n">result</span>
    <span class="n">result</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_8____">24.8 Суцільні класи незмінних колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить багато класів суцільних незмінних колекцій, з яких ви можете вибрати. Вони відрізняються в трейтах, які вони реалізують (мапи, множини, послідовності), чи можуть вони бути нескінченими та швидкістю різних операцій. Ми почнемо з огляду найбільш загальних типів незмінних колекцій.</p></div>
<div class="sect2">
<h3 id="__2">Списки</h3>
<div class="paragraph"><p>Списки є скінчені незмінні послідовності. Вони провадять доступ за сталий час до свого першого елементу так само, як і до залишку списку та вони мають операцію сталого часу <code>cons</code> для додавання нового елемента напочатку списку. Багато інших операцій займають лінійний час. Дівіться Глави 16 та 22 для розширеної дискусії щодо списків.</p></div>
</div>
<div class="sect2">
<h3 id="__3">Потоки</h3>
<div class="paragraph"><p>Потік подібний до списків, за тим винятком, що його елементи обчислюються ліниво. Через це потік може бути безкінечно довгий. Тільки елементи, що запитані, будуть обчислені. В іншому потоки мають ті самі характеристики продуктивності, що і списки.</p></div>
<div class="paragraph"><p>В той час, як списки будуються за допомогою оператора <code>::</code>, потоки будуються за допомогою подібно виглядаючого <code>#::</code>. Ось простий приклад потоку, що містить цілі <code>1</code>, <code>2</code> та <code>3</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mi">2</span> <span class="o">#::</span> <span class="mi">3</span> <span class="o">#::</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">empty</span>
<span class="n">str</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">?)</span>
</pre></div></div></div>
<div class="paragraph"><p>Голова цього потоку є <code>1</code> та хвіст має <code>2</code> та <code>3</code>. Однак хвіст тут не друкується, оскільки він все ще не обчислений! Потоки мають обчислюватись ліниво та метод <code>toString</code> для потоку досить уважний, щоб не змушувати до додаткового обчислення.</p></div>
<div class="paragraph"><p>Нижче більш складний приклад. Він обчислює потік, що містить послідовність Фібоначчі, починаючи з наданих двох чисел. Послідовність Фібоначчі - це коли кожний елемент є сумою двох попередніх в послідовності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">a</span> <span class="o">#::</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
<span class="n">fibFrom</span><span class="k">:</span> <span class="o">(</span><span class="kt">a:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">b:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція оманливо проста. Перший елемент послідовності, вочевидь, <code>a</code> та залишок послідовності є послідовність Фібоначчі, починаючи з <code>b</code>, за яким іде <code>a + b</code>. Хитра частина є обчислення цієї послідовності без нескінченої рекурсії. Якщо функція використовує <code>::</code> замість <code>#::</code>, тоді кожний виклик до функції буде спричиняти інший виклик таким чином спричиняючи нескінчену рекурсію. Однак оскільки вона використовує <code>#::</code>, права частина не обчислюється, доки вона не стане потрібною.</p></div>
<div class="paragraph"><p>Ось декілька перших елементів послідовності Фібоначчі, починаючи з двох елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fibs</span> <span class="k">=</span> <span class="n">fibFrom</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">fibs</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__4">Вектори</h3>
<div class="paragraph"><p>Списки дуже ефективні, коли алгоритм обробляє їх дбайливо, обробляючи тільки їх голови. Досутп, додавання та видалення тільки до голови списку забирає тільки сталий час, тоді як доступ або модифікація елементів в списку пізніше бере час лінійно відносно глибини списку.</p></div>
<div class="paragraph"><p>Вектори є типом колекцій, що дають ефективний доступ до елементів після голови. Доступ до любого елементу вектора займає тільки "ефективно сталий час", як визначено нижче. Це більша константа, ніж для доступу до голови списка, або для читання елементу масиву, але, тим не менше, це константа. Як результат, алгоритми, що використовують вектори, не мають пильнувати щодо доступу тільки до голови послідовності. Вони можуть отримувати доступ та модифікувати елементи в довільних місцях, і таким чином, вони можуть бути значно зручніші до написання.</p></div>
<div class="paragraph"><p>Вектори будуються та модифікуються так само, як інші послідовності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>
<span class="n">vec</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec2</span> <span class="k">=</span> <span class="n">vec</span> <span class="o">:+</span> <span class="mi">1</span> <span class="o">:+</span> <span class="mi">2</span>
<span class="n">vec2</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec3</span> <span class="k">=</span> <span class="mi">100</span> <span class="o">+:</span> <span class="n">vec2</span>
<span class="n">vec3</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec3</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div></div></div>
<div class="paragraph"><p>Вектори представлені як широкі та мілкі дерева. Кожний вузол дерева містить до 32 елементів вектора, або містить до 32 інших вузлів дерева. Вектори до 32 елементів можуть бути представлені одним вузлом. Вектори до 32 * 32 = 1024 елементів можуть бути представлені з одним перенаправленям. Два стрибка від кореня дерева до фінального вузла елементу достатні для векторів до 2<sup>15</sup> елементів, три стрибка для векторів 2<sup>20</sup>, чотири стрибка для векторів з 2<sup>25</sup> елементами, і п'ять стрибкив для векторів до 2<sup>30</sup> елементів. Так що для всіх векторів пристойного розміру вибір елементів включає до п'яти виборок примітивного масиву. Це те, що ми мали на увазі, коли писали, що доступ до елементу має "ефективно сталий час".</p></div>
<div class="paragraph"><p>Вектори незмінні так що ви не зможете змінити елемент вектора на місці. Однак, з методом <code>updated</code> ви можете створити новий вектор, що відрізняється від наданого вектора тільки одним елементом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">vec</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="n">updated</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як показує останній рядок вище, виклик до <code>updated</code> не має ефекту на оригінальний вектор <code>vec</code>. Як і вибір, оновлення функціонального вектора також має "ефективно сталий час". Оновлення вектора всередині вектора може бути зроблене через копіювання вузла, що містить елемент, і кожного вузла, що вказує на нього, починаючи від кореня дерева. Це означає, що функціональне оновлення створює від одного до п'яти вузлів, кожний містить до 32 елементів або субдерев. Це, звичайно, більш коштовно, ніж оновлення на місці в змінному масиві, але все ще набагато дешевше, ніж копіювання цілого вектора.</p></div>
<div class="paragraph"><p>Оскільки вектори влучають в гарний баланс між швидким довільними функціональними вибірками та швидкими довільними функціональними оновленнями, вони наразі є реалізацією по замовченню для незмінних індексованих послідовностей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">scala.collection.immutable.IndexedSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="nc">Immutable</span> <span class="n">stacks</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___3">Незмінні стеки</h3>
<div class="paragraph"><p>Якщо вам треба послідовність останній-увійшов-перший-вийшов, ви можете використовувати <code>Stack</code>. Ви заштовхуєте елемент в стек за допомогою <code>push</code>, виштовуєте за допомогою <code>pop</code> та вибираєте зверху без видалення за допомогою <code>top</code>. Всі ці операції займають сталий час.</p></div>
<div class="paragraph"><p>Ось деякі прості операції, що виконуються на стеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">.</span><span class="n">empty</span>
<span class="n">stack</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hasOne</span> <span class="k">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">hasOne</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">top</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">pop</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Незмінні стеки використовуються рідко в Scala програмах, оскільки їх функціональність повторює списки: <code>push</code> на незмінному стеку є те саме, що <code>::</code> на списку та <code>pop</code> на стеку те саме, що <code>tail</code> на списку.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Незмінні черги</h3>
<div class="paragraph"><p>Черга така сама як стек, за виключенням що вона перший-війшов-перший-вийшов, ніж останній-війшов-перший-вийшов. Спрощена реалізація незмінних черг дискутувалась в Главі 19. Ось як ви можете створити порожню незмінну чергу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
<span class="n">empty</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додати елемент до незмінної черги за допомогою <code>enqueue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">has1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">has1</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб додати декілька елементів до черги, викличте <code>enqueue</code> з колекцією в якості аргумента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">has123</span> <span class="k">=</span> <span class="n">has1</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">has123</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
<span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб видалити елемент з голови черги, використовуйте <code>dequeue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">has23</span><span class="o">)</span> <span class="k">=</span> <span class="n">has123</span><span class="o">.</span><span class="n">dequeue</span>
<span class="n">element</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">has23</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>dequeue</code> повертає пару, що складається з видаленого елементу та залишку черги.</p></div>
</div>
<div class="sect2">
<h3 id="__5">Диапазони</h3>
<div class="paragraph"><p>Диапазон є впорядкованою послідовністю цілих, що відстоять нарівно один від одного. Наприклад, <code>1, 2, 3</code> є диапазон, як і <code>5, 8, 11, 14</code>. Щоб створити диапазон в Scala, використовуйте попередньо визначені методи <code>to</code> та <code>by</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range.Inclusive</span>
  <span class="k">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="n">to</span> <span class="mi">14</span> <span class="n">by</span> <span class="mi">3</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте створити диапазон, який виключає свій верхній ліміт, використовуйте зручний метод <code>until</code> замість <code>to</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Диапазони представлені в просторі констант, оскільки вони можуть бути визначені через всього три числа: початок, кінець та значення кроку. Завдяки цій репрезентації, більшість операцій з диапазонами екстремально швидкі.</p></div>
</div>
<div class="sect2">
<h3 id="___5">Хеш дерева</h3>
<div class="paragraph"><p>Хеш дерева (<em>tries</em>, або <em>тріз</em>),<span class="footnote"><br />["Trie" походить від слова "retrieval" та вимовляються як <em>tree</em> або <em>try</em>.]<br /></span> є стандартним шляхом для ефективної реалізації незмінних масивів та мап. Їх репрезентація подібна до векторів в тому, що вони також дерева, де кожний вузол має 32 елементи або 32 субдерева, але вибірка робиться на основі хеш кода. Наприклад, щоб знайти наданий ключ, ви використовуєте молодші п'ять біт хеш коду від ключа, щоб обрати перше піддерево, наступні п'ять біт для іншого субдерева, і так далі. Вибірка зупиняється, як тільки всі елементи, що містяться в вузлі, мають хеш коди, які відрізняються один від одного в бітах, що вже вибрані. Таким чином, не всі біти хеш коду обов'язково використовуються.</p></div>
<div class="paragraph"><p>Хеш <em>тріз</em> поцілюють добрий баланс між достатньо швидкими пошуками та досить ефективними функціональними вставками (<code>+</code>) та видаленнями (<code>-</code>). Ось чому вони служать основою для реалізації по замовчанню для незмінних мап та множин Scala. Фактично, Scala має подальшу оптимізацію для незмінних множин та мап, що мають меньше ніж п'ять елементів. Множини та мапи від одного до чотирьох елементів зберігаються як один об'єкт, що містить самі елементи (або пари ключ/значення в випадку мап) як поля. Порожня незмінна множина та порожня незмінна мапа є в кожному випадку об'єктом синглтона  — немає потреби дублювати сховище для них, оскільки порожня множина та порожня мапа будуть завжди залишатись порожніми.</p></div>
</div>
<div class="sect2">
<h3 id="___">Червоне-чорне дерева</h3>
<div class="paragraph"><p>Дерева червоне-чорне є формою збалансованих дерев, коли деякі вузли відмічені як "червоні" та інші "чорні". Як любі збалансовані двійникові дерева, операції на них надійно завершуються за час, логірифмічний до розміру дерева.</p></div>
<div class="paragraph"><p>Scala провадить реалізації множин та мап, що внутрішньо використовують красне-чорне. Ви отримуєте доступ до них під іменами <code>TreeSet</code> та <code>TreeMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">set</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Дерева червоне-чорне є також стандартною реалізацією <code>SortedSet</code> в Scala, оскільки вони провадять ефективний ітератор, що повертає всі елементи множини у впорядкованому вигляді.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Незмінні бітові множини</h3>
<div class="paragraph"><p>Бітова множина представляє колекцію малих цілих, як бітів більшого цілого. Наприклад, бітова множина, що містить 3, 2 та 0, буде представлене як ціле <code>1101</code> в бінарній системі, що є <code>13</code> десятичними.</p></div>
<div class="paragraph"><p>Внутрішньо бітові множини використовують масив з 64-бітних <code>Long</code>. Перший <code>Long</code> в масиві є для цілих від 0 до 63, другий для від 64 до 127, і так далі. Таким чином, бітові множини дуже компактні, доки найдовше ціле в множині меньше ніж декілька сотен, або десь так.</p></div>
<div class="paragraph"><p>Операції на бітових наборах дуже швидкі. Перевірка на включення займає сталий час. Додавання елемента до множини пропорційна до числа <code>Long</code> в масиві бітової множини, що типово мале число. Ось деякі прості приклади використання бітових множин:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">moreBits</span> <span class="k">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span>
<span class="n">moreBits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">moreBits</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">moreBits</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___6">Спискові мапи</h3>
<div class="paragraph"><p>Спискова мапа представляє мапу як пов'язаний список пар ключ-значення. Загалом, операції на спискових мапах мають ітерувати по цілому списку. Таким чином, операції на списковій мапі займають час лінійно до розміру мапи. Фактично, існує невелике застосування списковим мапам в Scala, оскільки стандартні незмінні мапи майже завжди швидші. Одна можлива різниця є, коли якщо мапа з якихось причин сконструйована в такий спосіб, що перші елементи обираються значно більш часто, ніж інші елементи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">ListMap</span><span class="o">(</span>
<span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.immutable.ListMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span>
<span class="o">-&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">two</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;two&quot;</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_9____">24.9 Суцільні класи змінних колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили найбільш загально використовувані класи незмінних колекцій, що провадить Scala в своїй стандартній бібліотеці, поглянемо на класи змінних колекцій.</p></div>
<div class="sect2">
<h3 id="___7">Буфери масивів</h3>
<div class="paragraph"><p>Ви вже бачили буфери масивів в Розділі 17.1. Буфер масиву зберігає масив та розмір. Більшість операцій на буфері масивів має ту саму швидкість, що і для масивів, оскільки операції просто отримують доступ та модифікують підлеглий масив. Додатково, буфери масивів можуть ефективно додавати дані в кінець. Додавання елементу до буферу масиву триває амортизовано сталий час. Таким чином, буфери масивів корисні для ефективної побудови великих колекцій, коли нові елементи завжди додаються в кінець. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res38</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___8">Буфери списків</h3>
<div class="paragraph"><p>Ви вже бачили буфери списків в Розділі 17.1. Буфери списків подібні до буферів масивів, за виключенням того, що вони внутрішньо використовують зв'язані списки замість масивів. Якщо ви плануєте конвертувати буфер на список, коли він буде побудований, використовуйте буфер списків замість буферу масивів. Ось приклад:<span class="footnote"><br />[<code>buf.type</code>, що з'являється в відповідях інтерпретатора в цьому та деяких інших прикладах цього розділу є типом синглтона. Як буде пояснено в Розділі 29.6, <code>buf.type</code> означає, що змінна зберіагє в точності об'єкт, на який посилається <code>buf</code>.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___9">Побудовники рядків</h3>
<div class="paragraph"><p>Так само, як буфери масивів корисні для побудови масивів та буфери списків корисні для побудови списків, побудовник рядків корисний для побудови рядків. Побудовники рядків використовуються настільки загально, що вони завжди імпортуються в простір імен по замовчанню. Створюйте їх просто як <code>new StringBuilder</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="sc">&#39;a&#39;</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">++=</span> <span class="s">&quot;bcdef&quot;</span>
<span class="n">res45</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="n">abcdef</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toString</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcdef</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Зв'язані списки</h3>
<div class="paragraph"><p>Зв'язані списки є змінні послідовності, що складаються з вузлів, що пов'язані вказівниками <code>next</code>. В більшості мов <code>null</code> може бути взятий як порожній зв'язаний список. Це не робить для Scala колекцій, оскільки навіть порожні послідовності мають підтримувати всі методи послідовностей. Зокрема, <code>LinkedList.empty.isEmpty</code> повинно повертати <code>true</code> та не закидати <code>NullPointerException</code>. Порожні зв'язані списки замість цього закодовані в особливий спосіб: їх поле <code>next</code> вказує назад до самого вузла.</p></div>
<div class="paragraph"><p>Як їх незмінні колеги, зв'язані списки краще обробляються послідовно. На додаток зв'язані списки спрощують вставку елемента або зв'язаного списку в інший зв'язаний список.</p></div>
</div>
<div class="sect2">
<h3 id="____">Подвійно зв'язаний список</h3>
<div class="paragraph"><p><code>DoubleLinkedLists</code> подібні до однозв'язаних списків, описаних в попередньому підрозділі, але крім <code>next</code> вони мають інше змінне поле, <code>prev</code>, що вказує на елемент перед поточним вузлом. Головна перевага цього додаткового посилання в тому, що це робить видалення елементу дуже швидким.</p></div>
</div>
<div class="sect2">
<h3 id="___10">Змінні списки</h3>
<div class="paragraph"><p><code>MutableList</code> складається з одного зв'язаного списку, разом з вказівником, що посилається на термінальний порожній вузол цього списку. Це робить додавання до списку операцією сталого часу, оскільки уникається подорожування по списку в пошуку термінального вузла. <code>MutableList</code> наразі є стандартною реалізацією <code>mutable.LinearSeq</code> в Scala.</p></div>
</div>
<div class="sect2">
<h3 id="__6">Черги</h3>
<div class="paragraph"><p>Scala провадить змінні черги, на додаток до незмінних. Ви використовуєте змінні черги подібно до того, як використовуються незмінні, але замість <code>enqueue</code> ви використовуєте оператори <code>+=</code> та <code>++=</code> для додавання. Також на змінній черзі метод <code>dequeue</code> буде лише видаляти головний елемент з черги та повертати його. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">+=</span> <span class="s">&quot;a&quot;</span>
<span class="n">res47</span><span class="k">:</span> <span class="kt">queue.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">)</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">queue.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queueres49</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___11">Послідовності масивів</h3>
<div class="paragraph"><p>Послідовності масивів є змінні послідовності фіксованого розміру, що зберігають свої елементи всередині як <code>Array[AnyRef]</code>. Вони реалізовані в Scala як клас <code>ArraySeq</code>. Ви можете типово використовувати <code>ArraySeq</code>, якщо ви бажаєте масив заради його характеристик продуктивності, але ви також бажаєте створити загальні примірники послідовності, коли ви не знаєте тип елементів, і не маєте <code>ClassTag</code>, щоб запровадити під час виконання. Скоро ви дізнаєтесь про ці проблеми в Розділі 24.10.</p></div>
</div>
<div class="sect2">
<h3 id="__7">Стеки</h3>
<div class="paragraph"><p>Ви бачили незмінні стеки раніше. Також є змінна версія. Це робить точно так саме, як і незмінна версія, за винятком того, що зміни відбуваються на місці. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">stack</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">stack.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">stack.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">top</span>
<span class="n">res56</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res57</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res59</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____4">Стекі з масивів</h3>
<div class="paragraph"><p><code>ArrayStack</code> є альтернативною реалізацією змінного стеку, до базується на <code>Array</code>, що змінює розмір за потреби. Він провадить швидке індексування, і загалом трохи більше ефективний для більшості операцій, ніж звичайний змінний стек.</p></div>
</div>
<div class="sect2">
<h3 id="___12">Хеш таблиці</h3>
<div class="paragraph"><p>Хеш таблиця зберігає свої елементи в підлеглому масиві, покладаючи кожний елемент в позицію в масиві, що визначається хеш кодом цього елемента. Додавання елемента до хеш таблиці займає тільки сталий час, доки немає іншого елемента в масиві, що май той самий хеш код. Таким чином хеш таблиці дуже швидкі, доки об'єкти, що покладаються в них мають гарне розподілення хеш кодів. Як результат, по замовчанню типи змінної мапи та множини в Scala базуються на хеш таблицях.</p></div>
<div class="paragraph"><p>Хеш множини та мапи використовуються так само, як любі інші множини або мапи. Ось деякі прості приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;make a web site&quot;</span><span class="o">)</span>
<span class="n">res60</span><span class="k">:</span> <span class="kt">map.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;profit!&quot;</span><span class="o">)</span>
<span class="n">res61</span><span class="k">:</span> <span class="kt">map.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">profit</span><span class="o">!)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res62</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">contains</span> <span class="mi">2</span>
<span class="n">res63</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітерація по хеш таблиці не гарантовано виконується в деякому певному порядку. Ітерація просто проходить по підлеглому масиву,в якому б порядку це не траплялось. Щоб отримати гарантований порядок ітерації використовуйте зв'язану мапо або множину, замість звичайної. Зв'язана хеш мапа або множина така сама, як і звичайна мапа або множина, за тим винятком, що він таком влючає зв'язаний список елементів в тому порядку, як вони додавались. Ітерація по такій колекції відбувається завжди в тому порядку, в якому елементи були додані.</p></div>
</div>
<div class="sect2">
<h3 id="____5">Слабкі хеш мапи</h3>
<div class="paragraph"><p>Слабка хеш мапа є особливим різновидом хеш мапи, в якій збирач сміття не слідує посиланням від мапи до ключів, що зберігаються в ній. Це означає, що ключ та його асоційоване значення будуть зникати з мапи, якщо немає іншого посилання на ключ. Слабкі хеш мапи корисні для завдань таких як кешування, де ви бажаєте пере-використати результат коштовної функції, коли функція викликається знову на тому ж ключі. Якщо ключі та результати функції зберігаються в звичайній хеш мапі, мапа буде зростати без обмежень, і жодний ключ ніколи не стане сміттям. Використання слабкої хеш мапи уникає цієї проблеми. Як тільки об'єкт ключа стає недосяжний, його входження видаляється зі слабкої хеш мапи. Слабкі хеш мапи в Scala реалізовані як огортка підлеглої Java реалізації, <code>java.util.WeakHashMap</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___13">Конкурентні мапи</h3>
<div class="paragraph"><p>Конкурентні мапи можуть отримувати доступ з декількох потоків одночасно. На додаток до звичайних операцій з <code>Map</code>, вони провадять наступні атомарні операції:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">m putIfAbsent(k, v)</p></td>
<td align="left" valign="top"><p class="table">Додає прив'язку ключ/value <code>k -&gt; m</code>, за винятком коли <code>k</code> вже визначений в <code>m</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m remove (k, v)</p></td>
<td align="left" valign="top"><p class="table">Видаляє входження для <code>k</code>, якщо він наразі відображений на <code>v</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m replace (k, old, new)</p></td>
<td align="left" valign="top"><p class="table">Замінює значення, асоційоване з ключем <code>k</code> на <code>new</code>, якщо віе до цього був прив'язаний до <code>old</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m replace (k, v)</p></td>
<td align="left" valign="top"><p class="table">Замінює значення, асоційоване з ключом <code>k</code> до <code>v</code>,якщо він до цього був пов'язаний з деяким значенням</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p><code>ConcurrentMap</code> є трейтом в бібліотеці колекцій Scala. Наразі єдиною реалізацією є Java <code>java.util.concurrent.ConcurrentMap</code>, що може бути конвертований автоматично в мапу Scala, використовуючи стандартні перетворення колекцій Java/Scala, що будуть описані в Розділі 24.17.</p></div>
</div>
<div class="sect2">
<h3 id="____6">Змінні бітові множини</h3>
<div class="paragraph"><p>Змінні бітові множини такі самі, як незмінні, за виключенням того, що вони можуть бути модифіковані на місці. Змінні бітові множини трохи більше ефективні при оновленні, ніж незмінні, оскільки вони не мають копіювати <code>Long</code>, що не були змінені. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.mutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res64</span><span class="k">:</span> <span class="kt">bits.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="n">res65</span><span class="k">:</span> <span class="kt">bits.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span>
<span class="n">res66</span><span class="k">:</span> <span class="kt">scala.collection.mutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_10_">24.10 Масиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Масиви є особливим різновидом колекцій в Scala. З одного боку, масиви Scala відповідають один-до-одного до масивів Java. Тобто Scala масив <code>Array[Int]</code> представлений як Java <code>int[]</code>, <code>Array[Double]</code> представлений як Java <code>double[]</code> та <code>Array[String]</code> представлений як Java <code>String[]</code>. Але в той самий час, Scala масиви пропонують значно більше, ніж Java аналоги. Перше, масиви Scala можуть бути дженеріками. Тобто, ви можете мати <code>Array[T]</code>, де <code>T</code> є параметром типу або абстрактном типом. Друге, масиви Scala сумісні зі Scala послідовностями — ви можете передати <code>Array[T]</code>, де потрібне <code>Seq[T]</code>. Нарешті, масиви Scala також підтримують всі операції послідовностей. Ось приклад цього в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">a1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span> <span class="k">=</span> <span class="n">a1</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a3</span> <span class="k">=</span> <span class="n">a2</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">a3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">a3</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги, що Scala масиви представлені як масиви Java, як ці додаткові можливості підтримуються в Scala?</p></div>
<div class="paragraph"><p>Відповідь полягає в систематичному використанні неявних перетворень. Масив не може претендувати на звання послідовності, оскільки тип даних, що представляє природні масиви, не є субтипом <code>Seq</code>. Замість цього, кожного разу, коли масив використовується як Seq, він неявно огортається в субклас <code>Seq</code>. Ім'я цього субкласу - <code>scala.collection.mutable.WrappedArray</code>. Тут ви бачите його в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="n">eq</span> <span class="n">a4</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця взаємодія демонструє, що масиви сумісні з послідовностями, оскільки є неявне перетворення від <code>Array</code> до <code>WrappedArray</code>. Ідучи іншим шляхом, від <code>WrappedArray</code> до <code>Array</code>, ви можете використовувати метод <code>toArray</code>, визначений в <code>Traversable</code>. Останній рядок інтерпретатора вище показує, що огортання та потім розгортання за допомогою <code>toArray</code> дає вам той самий масив, з якого ви починали.</p></div>
<div class="paragraph"><p>Існує також інше неявне перетворення, що застосовується до масивів. Це перетворення просто "додає" всі методи послідовностей до масивів, але не перетворює самий масив на послідовність. "Додавання" означає, що масив огортається в інший об'єкт <code>ArrayOps</code>, що підтримує всі методи послідовностей. Типово цей об'єкт <code>ArrayOps</code> коротко-тривалий; він зазвичай буде недоступний після виклику метода послідовності та його сховище буде утилізоване. Сучасні VM часто уникають створення цього об'єкту повністю.</p></div>
<div class="paragraph"><p>Різниця між двома неявними перетвореннями масивів демонструється нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">seq</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ops</span><span class="k">:</span> <span class="kt">collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">ops</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">I</span><span class="o">(</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">)</span>

<span class="kt">scala&gt;</span> <span class="kt">ops.reverse</span>
<span class="kt">res3:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Array</span><span class="o">(</span><span class="err">3</span>, <span class="err">2</span>, <span class="err">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що виклик <code>reverse</code> на <code>seq</code>, що є <code>WrappedArray</code>, знову буде давати <code>WrappedArray</code>. Це логічно, оскільки огорнуті масиви є <code>Seqs</code>, і виклик <code>reverse</code> на любому <code>Seq</code> буде знову давати <code>Seq</code>. З іншого боку, виклик <code>reverse</code> на <code>ops</code> значенні класу <code>ArrayOps</code> дасть в результаті <code>Array</code>, не <code>Seq</code>. Приклад <code>ArrayOps</code> вище був досить штучний, призначений тільки показати різницю з <code>WrappedArray</code>. Звичайно ви ніколи не визначаєте значення класу <code>ArrayOps</code>. Ви просто викликаєте метод <code>Seq</code> на масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a1</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Об'єкт <code>ArrayOps</code> вставляється автоматично через неявне перетворення. Так що рядок вище еквівалентний до наступного рядка, де <code>intArrayOps</code> було перетворенням, що було неявно вставленим до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">intArrayOps</span><span class="o">(</span><span class="n">a1</span><span class="o">).</span><span class="n">reverse</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це підіймає питання, як компілятор обирає <code>intArrayOps</code> перед іншим неявним перетворенням до <code>WrappedArray</code> в рядку вище. Кінець кінцем, обоє перетворення відображають масив на тип, що підтримує метод <code>reverse</code>, де це те, що вказане на вході. Відповідь на це питання в тому, що ці два неявні перетворення мають преоритети. Перетворення <code>ArrayOps</code> має вищий преоритет, ніж перетворення <code>WrappedArray</code>. Перший визначений в об'єкті <code>Predef</code>, тоді як другий визначений в класі <code>scala.LowPriorityImplicits</code>, що є суперкласом <code>Predef</code>. Неявні в субкласах та субоб'єктах мають перевагу над неявними в базових класах. Так що коли можуть застосовуватись обоє перетворень, буде обрана версія з <code>Predef</code>. Дуже подібна схема, що була описана в Розділі 21.7, робить для рядків.</p></div>
<div class="paragraph"><p>Так що зараз ви знаєте, як масиви можуть бути сумісні з послідовностями та як вони можуть підтримувати всі операції послідовностей. Як щодо дженерікив? В Java ви не можете записати <code>T[]</code>, де <code>T</code> є параметром типу. Тоді як представлені <code>Array[T]</code> в Scala? Фактично, дженерік масив як <code>Array[T]</code> може бути під час виконання любим з вісьми масивів примітирних типів Java: <code>byte[]</code>, <code>short[]</code>, <code>char[]</code>, <code>int[]</code>, <code>long[]</code>, <code>float[]</code>, <code>double[]</code>, <code>boolean[]</code>, або він може бути масивом об'єктів. Єдиний загальний рантайм тип, що обіймає всі ці типи, є <code>AnyRef</code> (або, що еквівалентно, <code>java.lang.Object</code>) так що це той тип, на який компілятор Scala відображує <code>Array[T]</code>. Під час виконання, коли виконується доступ або модифікація елементу масиву типу <code>Array[T]</code>, відбувається послідовність перевірок типу, що визначає справжній тип масиву, за яким слідує коректна операція масиву на Java масиві. Ці перевірки типів дещо уповільнюють операції з масивами. Ви можете очікувати, що доступ до дженерік масивів будуть від трьох до чотирьох разів повільніші, ніж доступ до примітивних або об'єктних масивів. Це означає, що якщо вам треба максимальна продуктивність, вам треба обирати суцільні масиви замість дженерікив.</p></div>
<div class="paragraph"><p>Однак представити дженерік масиви не є достатнім також має бути спосіб створювати дженерік масиви. Існує навіть складніша проблема, що потребує трохи більше допомоги з вашого боку. Щоб пролілюструвати проблему, розглянемо наступну спробу написати дженерік метод, що створює масив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це невірно!</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>evenElems</code> повертає новий масив, що складається з усіх елементів аргументу-вектора <code>xs</code>, що стоять в векторі на парних позиціях. Перший рядок тіла <code>evenElems</code> створює результуючий масив, що має той самий тип елементів, що і аргумент. Так що, в залежності від дійсного параметру типу <code>T</code>, це могло бути <code>Array[Int]</code>, або <code>Array[Boolean]</code>, або масив деякого іншого примітивного типу Java, або масив деякого типу посилання. Але ці типи мають різні репрезентації під час виконання, то як рантайм Scala збирається обрати коректний тип? Фактично, він не може зробити це базуючись на наданій йому інформації, оскільки справжній тип, що відповідає параметру типу <code>T</code>, затирається під час виконання. Ось чому ви отримаєте наступне повідомлення про помилку, якщо ви намагатиметесь скомпілювати код вище:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">error</span><span class="k">:</span> <span class="kt">cannot</span> <span class="kt">find</span> <span class="kt">class</span> <span class="kt">tag</span> <span class="kt">for</span> <span class="kt">element</span> <span class="k">type</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">arr</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут потрібне, це ваша допомога компілятору шляхом провадження підказки рантайму, якій справжній тип параметру <code>evenElems</code>. Ця підказка часу виконання приймає форму класового тегу <code>typescala.reflect.ClassTag</code>. Класовий тег описує затертий тип даного типу, що є всею інформацією, потрібною для конструювання масиву цього типу.</p></div>
<div class="paragraph"><p>В багатьох випадках компілятор може генерувати класовий тег сам по собі. Це випадок для суцільних типів, як <code>Int</code> або <code>String</code>. Це також випадок для певних дженерік типів, як <code>List[T]</code>, де відомо досить інформації, щоб зпрогнозувати затертий тип; в цьому випадку затертий тип буде <code>List</code>.</p></div>
<div class="paragraph"><p>Для повністю дженерік класів звичайна ідиома є передавати класовий тег використовуючи обмеження контексту, як обговорювалось в Розділі 21.6. Ось як визначення вище може бути полагоджене, через використання обмеження контексту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це робить</span>
<span class="k">import</span> <span class="nn">scala.reflect.ClassTag</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому новому визначенні, коли створюється <code>Array[T]</code>, компілятор шукає класовий тег для параметру типу <code>T</code>, тобто, він буде шукати неявне значення типу <code>ClassTag[T]</code>. Якщо таке значення буде знайдене, класовий тег використовується для конструювання правильного типу масиву. Інакше ви побачите повідомлення про помилку, яке ви бачили до цього.</p></div>
<div class="paragraph"><p>Ось інтеракція з інтерпретатором, що використовує метод <code>evenElems</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="s">&quot;this&quot;</span><span class="o">,</span> <span class="s">&quot;is&quot;</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;test&quot;</span><span class="o">,</span> <span class="s">&quot;run&quot;</span><span class="o">))</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">run</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В обох випадках компілятор Scala компілятор автоматично конструює класовий тег для типу елементів (перший - <code>Int</code>, другий - <code>String</code>) та передає його до неявного параметру метода <code>evenElems</code>. Компілятор може зробити це для суцільних типів, але ні, якщо аргумент самий є іншим параметром типу без свого класового тегу. Наприклад, наступне схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">ClassTag</span> <span class="kt">available</span> <span class="kt">for</span> <span class="kt">U</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
                                        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що відбувається тут, це те, що <code>evenElems</code> вимагає класовий тег для параметру типа <code>U</code>, але жодний не був знайдений. Рішення в цьому випадку, звичайно, що треба вимагати інший класовий тег для <code>U</code>. Так що наступне робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="n">wrap</span><span class="k">:</span> <span class="err">[</span><span class="kt">U</span><span class="err">]</span><span class="o">(</span><span class="kt">xs:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">evidence$1</span><span class="k">:</span>
<span class="kt">scala.reflect.ClassTag</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="nc">Array</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад також показує, що контекст, зв'язаний в визначенні <code>U</code>, є просто скороченням для неявного параметра, що тут має назву <code>evidence$1</code> типу <code>ClassTag[U]</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_11_">24.11 Рядки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як і масиви, рядки напряму не є послідовностями, але вони можуть бути сконвертовані до них, і вони також підтримують всі операції послідовностей. Ось деякі приклади операцій, що ви можете викликати для радків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">str</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">hello</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">olleh</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toUpper</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">HELLO</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span> <span class="n">drop</span> <span class="mi">3</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span> <span class="n">slice</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">ell</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">str</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedString</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці операції підтримуються двома неявними перетвореннями, що пояснюються в Розділі 21.7. Перше, низько-преоритетне перетворення відображує <code>String</code> до <code>WrappedString</code>, що є субкласом <code>immutable.IndexedSeq</code>. Це перетворення було застосоване в останньому рядку попереднього приклада, де рядок був перетворений на <code>Seq</code>. Інше, високо-преоритетне перетворення відображує рядок до об'єкту <code>StringOps</code>, що додає всі методи незмінних послідовностей до рядків. Це перетворення було неявно вставлене в виклики методів <code>reverse</code>, <code>map</code>, <code>drop</code> та <code>slice</code> в попередньому прикладі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_12__">24.12 Характеристики продуктивності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як показали попередні пояснення, різні типи колекцій мають різні характеристики продуктивності. Часто це головна причина для обирання однієї колекції, ніж іншої. Ви можете бачити характеристики продуктивності деяких загальних операцій на колекціях, підсумовані в двох таблицях, Таблиці 24.12 та Таблиці 24.12.</p></div>
<div class="sect2">
<h3 id="_____2">Характеристики продуктивності типів послідовностей</h3>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">head</p></td>
<td align="left" valign="top"><p class="table">tail</p></td>
<td align="left" valign="top"><p class="table">apply</p></td>
<td align="left" valign="top"><p class="table">update</p></td>
<td align="left" valign="top"><p class="table">prepend</p></td>
<td align="left" valign="top"><p class="table">append</p></td>
<td align="left" valign="top"><p class="table">insert</p></td>
</tr>
<tr>
<td colspan="8" align="left" valign="top"><p class="table">immutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">List</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stream</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Vector</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Queue</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Range</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td colspan="8" align="left" valign="top"><p class="table">mutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArrayBuffer</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ListBuffer</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">StringBuilder</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">MutableList</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Queue</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArraySeq</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArrayStack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Array</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="______">Характеристики продуктивності типів множин та мап</h3>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">lookup</p></td>
<td align="left" valign="top"><p class="table">add</p></td>
<td align="left" valign="top"><p class="table">remove</p></td>
<td align="left" valign="top"><p class="table">min</p></td>
</tr>
<tr>
<td colspan="5" align="left" valign="top"><p class="table">immutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">HashSet/HashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">TreeSet/TreeMap</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BitSet</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">eC.<span class="footnote"><br />[Assuming bits are densely packed.]<br /></span></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ListMap</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td colspan="5" align="left" valign="top"><p class="table">mutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">HashSet/HashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WeakHashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BitSet</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">eC^a</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Входження в ціх двох таблицях пояснюється наступним чином:</p></div>
<div class="paragraph"><p><strong>C</strong> Операція займає сталий час (швидка).</p></div>
<div class="paragraph"><p><strong>eC</strong> Операція ефективно займає сталий час, але це може залежати від деяких припущень таких, як максимальна довжина вектора, або розподілення хеш ключей.</p></div>
<div class="paragraph"><p><strong>aC</strong> Операція займає амортизований сталий час. Деякі виклики операції можуть зайняти довше, але якщо виконується багато операцій,в середньому операція триває сталий час.</p></div>
<div class="paragraph"><p><strong>Log</strong> Операція триває час, пропорційний до логарифму розміру колекції.</p></div>
<div class="paragraph"><p><strong>L</strong> Операція лінійна, триває час пропорційний до розміру колекції.</p></div>
<div class="paragraph"><p><strong>-</strong> Операція не підтримується.</p></div>
<div class="paragraph"><p>Таблиця 24.12 розглядає типи послідовностей, змінні та незмінні, для неступних операцій:</p></div>
<div class="paragraph"><p><strong>head</strong> Вибір першого елемента в послідовності.</p></div>
<div class="paragraph"><p><strong>tail</strong> Створення нової колекції, що складається з усіх елементів, крім першого.</p></div>
<div class="paragraph"><p><strong>apply</strong> Індексування.</p></div>
<div class="paragraph"><p><strong>update</strong> Функціональне оновлення (за допомогою <code>updated</code>) для незмінних послідовностей, оновлення з побічним ефектом (за допомогою <code>update</code>) для змінних послідовностей.</p></div>
<div class="paragraph"><p><strong>prepend</strong> Додавання елементу зпереду послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.</p></div>
<div class="paragraph"><p><strong>append</strong> Додавання елементу в кінець послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.</p></div>
<div class="paragraph"><p><strong>insert</strong> Вставка елементу в довільну позицію послідовності. Напряму це підтримується тільки для змінних послідовностей.</p></div>
<div class="paragraph"><p>Таблиця 24.12 розглядає змінні та незмінні множини та мапи стосовно наступних операцій:</p></div>
<div class="paragraph"><p><strong>lookup</strong> Перевірка, чи елемент знаходиться в множині або обирає значення, асоційоване з ключем.</p></div>
<div class="paragraph"><p><strong>add</strong> Додавання нового елементу до множини або новох мапи ключ/значення до мапи.</p></div>
<div class="paragraph"><p><strong>remove</strong> Видалення елементу з множини або ключа з мапи.</p></div>
<div class="paragraph"><p><strong>min</strong> Найменьший елемент в множині, або меньший ключ в мапі.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_13_">24.13 Еквівалентність</h2>
<div class="sectionbody">
<div class="paragraph"><p>Бібліотеки колекцій мають уніформний підхід до рівності та хешування. Перше, ідея в тому, щоб поділити колекції на множини, мапи та послідовності. Колекції в різних категоріях завжди нерівні. Наприклад, <code>Set(1, 2, 3)</code> нерівне до <code>List(1, 2, 3)</code>, навіть якщо вони містять ті самі елементи. З іншого боку, в тій самій категорії, колекції рівні, тільки, та тільки, якщо вони мають ті самі елементи (для послідовностей: ті ж елементи в тому ж порядку). Наприклад, <code>List(1, 2, 3) == Vector(1, 2, 3)</code>, та <code>HashSet(1, 2) == TreeSet(2, 1)</code>.</p></div>
<div class="paragraph"><p>It does not matter for the equality check whether a collection is mutable or immutable. For a mutable collection, equality simply depends on the current elements at the time the equality test is performed. This means that a mutable collection might be equal to different collections at different times, depending what elements are added or removed. This is a potential trap when using a mutable collection as a key in a hash map. For example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="nc">HashMap</span><span class="o">(</span><span class="n">buf</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashMap</span><span class="o">[</span><span class="kt">scala.collection.</span>
<span class="kt">mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span><span class="mi">3</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">key</span> <span class="kt">not</span> <span class="kt">found:</span>
<span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>In this example, the selection in the last line will most likely fail because the hash code of the array xs has changed in the second-to-last line. Therefore, the hash-code-based lookup will look at a different place than the one in which xs was stored.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_14_">24.14 Перегляди</h2>
<div class="sectionbody">
<div class="paragraph"><p>Collections have quite a few methods that construct new collections. Some examples are map,filter, and ++. We call such methods transformers because they take at least one collection as their receiver object and produce another collection in their result.</p></div>
<div class="paragraph"><p>Transformers can be implemented in two principal ways: strict and non-strict (or lazy). A strict transformer constructs a new collection with all of its elements. A non-strict, or lazy, transformer constructs only a proxy for the result collection, and its elements are constructed on demand.</p></div>
<div class="paragraph"><p>As an example of a non-strict transformer, consider the following implementation of a lazy map operation:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lazyMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">coll</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">map</span> <span class="n">f</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Note that lazyMap constructs a new Iterable without stepping through all elements of the given collection coll. The given function f is instead applied to the elements of the new collection&#8217;siterator as they are demanded.</p></div>
<div class="paragraph"><p>Scala collections are by default strict in all their transformers, except for Stream, which implements all its transformer methods lazily. However, there is a systematic way to turn every collection into a lazy one and vice versa, which is based on collection views. A view is a special kind of collection that represents some base collection, but implements all of its transformers lazily.</p></div>
<div class="paragraph"><p>To go from a collection to its view, you can use the view method on the collection. If xs is some collection, then xs.view is the same collection, but with all transformers implemented lazily. To get back from a view to a strict collection, you can use the force method.As an example, say you have a vector of Ints over which you want to map two functions in succession:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>In the last statement, the expression v map (_ + 1) constructs a new vector that is then transformed into a third vector by the second call to map (_ * 2). In many situations, constructing the intermediate result from the first call to map is a bit wasteful. In the pseudo example, it would be faster to do a single map with the composition of the two functions (_ + 1)and (_ * 2). If you have the two functions available in the same place you can do this by hand. But quite often, successive transformations of a data structure are done in different program modules. Fusing those transformations would then undermine modularity. A more general way to avoid the intermediate results is by turning the vector first into a view, applying all transformations to the view, and finally forcing the view to a vector:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">view</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)).</span><span class="n">force</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>We&#8217;ll do this sequence of operations again, one by one:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vv</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">view</span>
<span class="n">vv</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">SeqView</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The application v.view gives you a SeqView, i.e., a lazily evaluated Seq. The type SeqView has two type parameters. The first, Int, shows the type of the view&#8217;s elements. The second, Vector[Int], shows you the type constructor you get back when forcing the view.</p></div>
<div class="paragraph"><p>Applying the first map to the view gives you:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vv</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Seq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">SeqViewM</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>The result of the map is a value that prints SeqViewM(&#8230;). This is in essence a wrapper that records the fact that a map with function (_ + 1) needs to be applied on the vector v. It does not apply that map until the view is forced, however. The "M" after SeqView is an indication that the view encapsulates a map operation. Other letters indicate other delayed operations. For instance "S" indicates a delayed slice operation, and "R" indicates a reverse. We&#8217;ll now apply the second map to the last result.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res13</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Seq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">SeqViewMM</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>You now get a SeqView that contains two map operations, so it prints with a double "M":SeqViewMM(&#8230;). Finally, forcing the last result gives:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res14</span><span class="o">.</span><span class="n">force</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Both stored functions get applied as part of the execution of the force operation and a new vector is constructed. That way, no intermediate data structure is needed.</p></div>
<div class="paragraph"><p>One detail to note is that the static type of the final result is a Seq, not a Vector. Tracing the types back we see that as soon as the first delayed map was applied, the result had static typeSeqViewM[Int, Seq[_]]. That is, the "knowledge" that the view was applied to the specific sequence type Vector got lost. The implementation of a view for any particular class requires quite a bit of code, so the Scala collection libraries provide views mostly only for general collection types, not for specific implementations.<span class="footnote"><br />[An exception to this is arrays: applying delayed operations on arrays will again give results with static type Array.]<br /></span></p></div>
<div class="paragraph"><p>There are two reasons why you might want to consider using views. The first is performance. You have seen that by switching a collection to a view the construction of intermediate results can be avoided. These savings can be quite important. As another example, consider the problem of finding the first palindrome in a list of words. A palindrome is a word that reads backwards the same as forwards. Here are the necessary definitions:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">def</span> <span class="n">findPalindrome</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">s</span> <span class="n">find</span> <span class="n">isPalindrome</span>
</pre></div></div></div>
<div class="paragraph"><p>Now, assume you have a very long sequence words and you want to find a palindrome in the first million words of that sequence. Can you re-use the definition of findPalindrome? Of course, you could write:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>This nicely separates the two aspects of taking the first million words of a sequence and finding a palindrome in it. But the downside is that it always constructs an intermediary sequence consisting of one million words, even if the first word of that sequence is already a palindrome. So potentially, 999,999 words are copied into the intermediary result without being inspected at all afterwards. Many programmers would give up here and write their own specialized version of finding palindromes in some given prefix of an argument sequence. But with views, you don&#8217;t have to. Simply write:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">view</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>This has the same nice separation of concerns, but instead of a sequence of a million elements it will only construct a single lightweight view object. This way, you do not need to choose between performance and modularity. The second use case applies to views over mutable sequences. Many transformer functions on such views provide a window into the original sequence that can then be used to update selectively some elements of that sequence. To see this in an example, suppose you have an array arr:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span><span class="o">).</span><span class="n">toArray</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>You can create a subwindow into that array by creating a slice of a view of the array:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">subarr</span> <span class="k">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span><span class="n">subarr</span><span class="k">:</span> <span class="kt">scala.collection.mutable.IndexedSeqView</span><span class="o">[</span>
<span class="kt">Int</span>,<span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">IndexedSeqViewS</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>This gives a view, subarr, which refers to the elements at positions 3 through 5 of the array arr. The view does not copy these elements, it just provides a reference to them. Now, assume you have a method that modifies some elements of a sequence. For instance, the following negatemethod would negate all elements of the sequence of integers it&#8217;s given:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="o">-</span><span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="n">negate</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">scala.collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Assume now you want to negate elements at positions three through five of the array arr. Can you use negate for this? Using a view, this is simple:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">negate</span><span class="o">(</span><span class="n">subarr</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>What happened here is that negate changed all elements of subarr, which were a slice of the elements of arr. Again, you see that views help in keeping things modular. The code above nicely separated the question of what index range to apply a method to from the question what method to apply.</p></div>
<div class="paragraph"><p>After having seen all these nifty uses of views you might wonder why have strict collections at all? One reason is that performance comparisons do not always favor lazy over strict collections. For smaller collection sizes the added overhead of forming and applying closures in views is often greater than the gain from avoiding the intermediary data structures. A possibly more important reason is that evaluation in views can be very confusing if the delayed operations have side effects.</p></div>
<div class="paragraph"><p>Here&#8217;s an example that bit a few users of versions of Scala before 2.8. In these versions theRange type
was lazy, so it behaved in effect like a view. People were trying to create a number of actors,<span class="footnote"><br />[The Scala actors library has been deprecated, but this historical example is still relevant.]<br /></span> like
this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="k">yield</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>They were surprised that none of the actors were executing afterwards, even though the actormethod should create and start an actor from the code that&#8217;s enclosed in the braces following it. To explain why nothing happened, remember that the for expression above is equivalent to an application of the map method:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Since previously the range produced by (1 to 10) behaved like a view, the result of the map was again a view. That is, no element was computed, and, consequently, no actor was created! Actors would have been created by forcing the range of the whole expression, but it&#8217;s far from obvious that this is what was required to make the actors do their work.</p></div>
<div class="paragraph"><p>To avoid surprises like this, the Scala collections gained more regular rules in version 2.8. All</p></div>
<div class="paragraph"><p>collections except streams and views are strict. The only way to go from a strict to a lazy collection is
via the view method. The only way to go back is via force. So the actors definition above would behave
as expected in Scala 2.8 in that it would create and start ten actors. To get back the surprising previous
behavior, you&#8217;d have to add an explicit view method call:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="n">view</span><span class="o">)</span> <span class="k">yield</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>In summary, views are a powerful tool to reconcile concerns of efficiency with concerns of modularity. But in order not to be entangled in aspects of delayed evaluation, you should restrict views to two scenarios. Either you apply views in purely functional code where collection transformations do not have side effects. Or you apply them over mutable collections where all modifications are done explicitly. What&#8217;s best avoided is a mixture of views and operations that create new collections while also having side effects.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_15_">24.15 Ітератори</h2>
<div class="sectionbody">
<div class="paragraph"><p>An iterator is not a collection, but rather a way to access the elements of a collection one by one. The two basic operations on an iterator it are next and hasNext. A call to it.next() will return the next element of the iterator and advance the state of the iterator. Calling next again on the same iterator will then yield the element one beyond the one returned previously. If there are no more elements to return, a call to next will throw a NoSuchElementException. You can find out whether there are more elements to return using Iterator&#8217;s hasNext method.</p></div>
<div class="paragraph"><p>The most straightforward way to "step through" all the elements returned by an iterator is to use
a while loop:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Iterators in Scala also provide analogues of most of the methods that you find in theTraversable, Iterable, and Seq traits. For instance, they provide a foreach method that executes a given procedure on each element returned by an iterator. Using foreach, the loop above could be abbreviated to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">it</span> <span class="n">foreach</span> <span class="n">println</span>
</pre></div></div></div>
<div class="paragraph"><p>As always, for expressions can be used as an alternate syntax for expressions involvingforeach, map, filter, and flatMap, so yet another way to print all elements returned by an iterator would be:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">elem</span> <span class="k">&lt;-</span> <span class="n">it</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>There&#8217;s an important difference between the foreach method on iterators and the same method on traversable collections: When called on an iterator, foreach will leave the iterator at its end when it is done. So calling next again on the same iterator will fail with aNoSuchElementException. By contrast, when called on a collection, foreach leaves the number of elements in the collection unchanged (unlessthe passed function adds or removes elements, but this is discouraged, because it can easily lead to surprising results).</p></div>
<div class="paragraph"><p>The other operations that Iterator has in common with Traversable have the same property of leaving the iterator at its end when done. For instance, iterators provide a map method, which returns a new iterator:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;number&quot;</span><span class="o">,</span> <span class="s">&quot;of&quot;</span><span class="o">,</span> <span class="s">&quot;words&quot;</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="mi">1</span>
<span class="mi">6</span>
<span class="mi">2</span>
<span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">next</span> <span class="kt">on</span> <span class="kt">empty</span> <span class="kt">iterator</span>
</pre></div></div></div>
<div class="paragraph"><p>As you can see, after the call to map, the it iterator has advanced to its end. Another example is the dropWhile method, which can be used to find the first element of an iterator that has a certain property. For instance, to find the first word in the iterator shown previously that has at least two characters, you could write:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;number&quot;</span><span class="o">,</span> <span class="s">&quot;of&quot;</span><span class="o">,</span> <span class="s">&quot;words&quot;</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">number</span>
</pre></div></div></div>
<div class="paragraph"><p>Note again that it has changed by the call to dropWhile: it now points to the second word "number" in the list. In fact, it and the result res4 returned by dropWhile will return exactly the same sequence of elements.</p></div>
<div class="paragraph"><p>There is only one standard operation, duplicate, which allows you to re-use the same iterator:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">(</span><span class="n">it1</span><span class="o">,</span> <span class="n">it2</span><span class="o">)</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">duplicate</span>
</pre></div></div></div>
<div class="paragraph"><p>The call to duplicate gives you two iterators, which each return exactly the same elements as the iterator it. The two iterators work independently; advancing one does not affect the other. By contrast the original iterator, it, is advanced to its end by duplicate and is thus rendered unusable.</p></div>
<div class="paragraph"><p>In summary, iterators behave like collections if you never access an iterator again after invoking a method on it. The Scala collection libraries make this explicit with an abstraction called TraversableOnce, which is a common supertrait of Traversable and Iterator. As the nameimplies, TraversableOnce objects can be traversed using foreach, but the state of that object after the traversal is not specified. If the TraversableOnce object is in fact an Iterator, it will be at its end after the traversal, but if it is a Traversable, it will still exist as before. A common use case of TraversableOnce is as an argument type for methods that can take either an iterator or traversable as argument. An example is the appending method ++ in trait Traversable. It takes aTraversableOnce parameter, so you can append elements coming from either an iterator or a traversable collection.</p></div>
<div class="paragraph"><p>All operations on iterators are summarized in Table 24.12.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Абстрактні методи:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.next()</p></td>
<td align="left" valign="top"><p class="table">Повертає наступний елемент ітератора <code>it</code> та просувається далі.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.hasNext</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>true</code>, якщо <code>it</code> може повернути наступний елемент.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Варіації:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.buffered</p></td>
<td align="left" valign="top"><p class="table">Буферизований ітератор, що повертає всі елементи <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it grouped size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отримує елементи <code>it</code> в "шматках" послідовностей фіксованого розміру.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sliding size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отримує елементи <code>it</code> в послідовностях плаваючого вікна фіксованого розміру.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Копіювання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it copyToBuffer buf</p></td>
<td align="left" valign="top"><p class="table">Копіює всі повернуті <code>it</code> елементи до буфера <code>buf</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it copyToArray(arr, s, l)</p></td>
<td align="left" valign="top"><p class="table">Копіює щонайбільше <code>l</code> елементів, що повертаються <code>it</code>, до <code>arr</code>, починаючи з індексу <code>s</code>. Останні два аргументи опціональні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Дублікація:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.duplicate</p></td>
<td align="left" valign="top"><p class="table">Пара ітераторів, кожний з яких незалежно повертає всі елементи <code>it</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it ++ jt</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи, що повертає ітератор <code>it</code>, за яким слідують елементи, що повертає ітератор <code>jt</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it padTo (len, x)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи <code>it</code>, за якими слідують копії <code>x</code>, доки не буде досягнута загальна довжина з <code>len</code> елементів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Мапи:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it map</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отриманий від застосування функції <code>f</code> до кожного елементу, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it flatMap</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отриманий від застосування функції зі значенням ітератора <code>f</code> до кожного елементу, та додавання результатів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it collect</p></td>
<td align="left" valign="top"><p class="table">Ітератор, отриманий від застосування часткової функції <code>f</code> до кожного елементу в <code>it</code>, до якого вона визначена, та збирання результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toArray</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в масив.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toList</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в список.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toIterable</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в <code>iterable.it.toSeq</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toIndexedSeq</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в індексовану послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toStream</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в потік.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toSet</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в множину.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toMap</p></td>
<td align="left" valign="top"><p class="table">Збирає пари ключ/значення, що повертає <code>it</code>, в мапу.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Інформація про розмір:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.isEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи ітератор порожній (протилежність <code>hasNext</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.nonEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція містить елементи (псевдоним до <code>hasNext</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.size</p></td>
<td align="left" valign="top"><p class="table">Число елементів, що повертає <code>it</code>. Увага: <code>it</code> після цієї операції буде вказувати на кінець!</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.lengt</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <em>it.size</em>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.hasDefiniteSize</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>true</code>, якщо відомо, що <code>it</code> повертає обмежену кількість елементів (по замовчанню те саме, що <code>isEmpty</code>).</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Пошук і отримання елементів:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it find</p></td>
<td align="left" valign="top"><p class="table">Опція, що містить перший елемент, що повертає <code>it</code>, який задовільняє <code>p</code>, або <code>None</code>, якщо жодний елемент не підійде. Увага: ітератор просувається після знайденого елементу, або до кінця, якщо нічого не знайдене.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it indexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елемента, що повертається <code>it</code>, що дорівнює <code>x</code>. Увага: ітератор просувається за позицію цього елемента.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it indexWhere</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу, що повертається <code>it</code>, що задовільняє <code>p</code>. Увага: ітератор просувається за позицію цього елемента.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Субітератори:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it take</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає перші <code>n</code> елементів <code>it</code>. Увага: <code>it</code> буде просуватись до позиції за <code>n</code>-ним елементом, або до кінця, якщо <code>it</code> містить меньше ніж <code>n</code> елементів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it drop</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що починається з <code>(n + 1)</code>-ного елементу <code>it</code>. Увага: <code>it</code> буде просуватись на нову позицію.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it slice (m, n)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає фрагмент з елементів, що повертає <code>it</code>, починаючи з <code>m</code>-того елемента, та завершуючи перед <code>n</code>-ним елементом.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it takeWhile</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає елементи з <code>it</code>, доки умова <code>p</code> є <code>true</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it dropWhile</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що пропускає елементи з <code>it</code>, доки умова <code>p</code> є <code>true</code>, та повертає залишок.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it filter</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи з <code>it</code>, що задовільняє умові <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it withFilter</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <code>it filter p</code>. Треба для використання ітераторів в виразах <code>for</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it filterNot</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи з <code>it</code>, що не задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Підрозділення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it partition</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>it</code> на пару з двох ітераторів; один повертає всі елементи, що задовільняють предикатові <code>p</code>, інший повертає всі елементи з <code>it</code>, що ні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Умови до елементів:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it forall</p></td>
<td align="left" valign="top"><p class="table">Логічне, вказує, чи предикат <code>p</code> дотримується до всіх елементів, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it exists</p></td>
<td align="left" valign="top"><p class="table">Логічне, вказує, чи предикат <code>p</code> виконується для деякого елементу, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it count</p></td>
<td align="left" valign="top"><p class="table">Число елементів в <code>it</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Згортки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(z /: it)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами, що повертає <code>it</code>, ідучи зліва направо, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(it :\ z)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами, що повертає <code>it</code>, ідучи зправа наліво, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.foldLeft(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що (z /: it)(op).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.foldRight(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що (it :\ z)(op).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it reduceLeft op</p></td>
<td align="left" valign="top"><p class="table">Застосовує вдомірну операцію <code>op</code> між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it reduceRight op</p></td>
<td align="left" valign="top"><p class="table">Застосовує вдомірну операцію <code>op</code> між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Специфічні згортки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.sum</p></td>
<td align="left" valign="top"><p class="table">Сума числових елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.product</p></td>
<td align="left" valign="top"><p class="table">Добуток значень числових елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.min</p></td>
<td align="left" valign="top"><p class="table">Мінімум впорядкованих елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.max</p></td>
<td align="left" valign="top"><p class="table">Максимум впорядкованих елементів, що повертає ітератор</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Поєднання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it zip jt</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар відповідних елементів, що повертаються ітераторами <code>it</code> та <code>jt</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it zipAll (jt, x, y)</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар відповідних елементів, що повертаються ітераторами <code>it</code> та <code>jt</code>, де коротший ітератор розширюється, щоб співпадати з довшим, через додавання елементів <code>x</code> або <code>y</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.zipWithIndex</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар елементів, що повертаються <code>it</code> разом з індексами.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it patch (i, jt, r)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, отриманий з <code>it</code> заміною <code>r</code> елементів починаючи з <code>i</code> патч-ітератором <code>jt</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Порівняння:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it sameElements jt</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи ітератори <code>it</code> та <code>jt</code> повертають ті самі елементи в тому самому порядку. Увага: після цієї операції щонайменьше один з <code>it</code> та <code>jt</code> опиниться в кінці.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Рядки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it addString (b, start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Додає рядок до <code>StringBuilder</code> <code>b</code>, що показує всі елементи, повернуті <code>it</code> з роздільниками <code>sep</code>, оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональними.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it mkString (start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Конвертує ітератор на рядоко, що показує всі елементи, що обмежені роздільникими <code>sep</code>, оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональними.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_buffered_iterators">Buffered iterators</h3>
<div class="paragraph"><p>Sometimes you want an iterator that can "look ahead" so that you can inspect the next element to be
returned without advancing past that element. Consider, for instance, the task to skip leading empty
strings from an iterator that returns a sequence of strings. You might be tempted to write something like
the following method:// This won&#8217;t work
def skipEmptyWordsNOT(it: Iterator[String]) = {
while (it.next().isEmpty) {}
}
But looking at this code more closely, it&#8217;s clear that this is wrong: the code will indeed skip leading
empty strings, but it will also advance it past the first non-empty string!
The solution to this problem is to use a buffered iterator, an instance of
trait BufferedIterator.BufferedIterator is a subtrait of Iterator, which provides one extra method, head.
Calling head on a buffered iterator will return its first element, but will not advance the iterator. Using a
buffered iterator, skipping empty words can be written like this:
def skipEmptyWords(it: BufferedIterator[String]) =
while (it.head.isEmpty) { it.next() }
Every iterator can be converted to a buffered iterator by calling its buffered method. Here&#8217;s an example:
scala&gt; val it = Iterator(1, 2, 3, 4)
it: Iterator[Int] = non-empty iterator
scala&gt; val bit = it.buffered
bit: java.lang.Object with scala.collection.
BufferedIterator[Int] = non-empty iterator
scala&gt; bit.head
res10: Int = 1
scala&gt; bit.next()
res11: Int = 1
scala&gt; bit.next()
res11: Int = 2
Note that calling head on the buffered iterator, bit, did not advance it. Therefore, the subsequent
call, bit.next(), returned again the same value as bit.head.
24.16 CREATING COLLECTIONS FROM SCRATCH
You have already seen syntax like List(1, 2, 3), which creates a list of three integers, andMap(<em>A</em> -
&gt; 1, <em>C</em> &#8594; 2), which creates a map with two bindings. This is actually a universal feature of Scala
collections. You can take any collection name and follow it by a list of elements in parentheses. The
result will be a new collection with the given elements. Here are some more examples:
Traversable()
List()
List(1.0, 2.0)
Vector(1.0, 2.0)
Iterator(1, 2, 3)
Set(dog, cat, bird)
HashSet(dog, cat, bird)
Map(<em>a</em> &#8594; 7, <em>b</em> &#8594; 0)




An empty traversable object
The empty list
A list with elements 1.0, 2.0
A vector with elements 1.0, 2.0
An iterator returning three integers.
A set of three animals
A hash set of the same animals
A map from characters to integers"Under the covers" each of the above lines is a call to the apply method of some object. For instance,
the third line above expands to:
List.apply(1.0, 2.0)
So this is a call to the apply method of the companion object of the List class. That method takes an
arbitrary number of arguments and constructs a list from them. Every collection class in the Scala
library has a companion object with such an apply method. It does not matter whether the collection
class represents a concrete implementation, like List, Stream, orVector, or whether it is an trait such
as Seq, Set, or Traversable. In the latter case, calling applywill produce some default implementation of
the trait. Here are some examples:
scala&gt; List(1, 2, 3)
res17: List[Int] = List(1, 2, 3)
scala&gt; Traversable(1, 2, 3)
res18: Traversable[Int] = List(1, 2, 3)
scala&gt; mutable.Traversable(1, 2, 3)
res19: scala.collection.mutable.Traversable[Int] =
ArrayBuffer(1, 2, 3)
Besides apply, every collection companion object also defines a member empty, which returns an
empty collection. So instead of List() you could write List.empty, instead of Map(), Map.empty, and so
on.
Descendants of Seq traits also provide other factory operations in their companion objects. These are
summarized in Table 24.13. In short, there&#8217;s:
concat, which concatenates an arbitrary number of traversables together,
fill and tabulate, which generate single or multi-dimensional sequences of given dimensions
initialized by some expression or tabulating function,
* range, which generates integer sequences with some constant step length, and
* iterate, which generates the sequence resulting from repeated application of a function to a start
element.
*
*
Factory methods for sequences
What it is
S.empty
S(x, y, z)
S.concat(xs, ys, zs)
S.fill(n)(e)
What it does
The empty sequence
A sequence consisting of elements x, y, and z
The sequence obtained by concatenating the elements of xs,ys, and zs
A sequence of length n where each element is computed by expression e
A sequence of sequences of dimension m x n where each element is computed by
S.fill(m, n)(e)
expression e (exists also in higher dimensions)
S.tabulate(n)(f)
A sequence of length n where the element at each index i is computed by f(i)
A sequence of sequences of dimension m x n where the element at each index (i, j)
S.tabulate(m, n)(f)
is computed by f(i, j) (exists also in higher dimensions)S.range(start, end)
S.range(start, end,
step)
S.iterate(x, n)(f)
The sequence of integers start &#8230; end - 1
The sequence of integers starting with start and progressing by step increments up
to, and excluding, the endvalue
The sequence of length n with elements x, f(x), f(f(x)), &#8230;
24.17 CONVERSIONS BETWEEN JAVA AND SCALA COLLECTIONS
Like Scala, Java has a rich collections library. There are many similarities between the two. For
instance, both libraries know iterators, iterables, sets, maps, and sequences. But there are also important
differences. In particular, the Scala libraries put much more emphasis on immutable collections, and
provide many more operations that transform a collection into a new one.
Sometimes you might need to convert from one collection framework to the other. For instance, you
might want to access to an existing Java collection, as if it were a Scala collection. Or you might want
to pass one of Scala&#8217;s collections to a Java method that expects the Java counterpart. It is quite easy to
do this, because Scala offers implicit conversions between all the major collection types in
the JavaConversions object. In particular, you will find bidirectional conversions between the following
types:
Iterator
Iterator
Iterable
Iterable
mutable.Buffer
mutable.Set
mutable.Map
\null
\null
\null
\null
\null
\null
\null
java.util.Iterator
java.util.Enumeration
java.lang.Iterable
java.util.Collection
java.util.List
java.util.Set
java.util.Map
To enable these conversions, simply import like this:
scala&gt; import collection.JavaConversions._
import collection.JavaConversions._
You have now automatic conversions between Scala collections and their corresponding Java
collections.
scala&gt; import collection.mutable._
import collection.mutable._
scala&gt; val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]
scala&gt; val buf: Seq[Int] = jul
buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)
scala&gt; val m: java.util.Map[String, Int] =
HashMap("abc" &#8594; 1, "hello" &#8594; 2)
m: java.util.Map[String,Int] = 2, abc=1
Internally, these conversion work by setting up a "wrapper" object that forwards all operations to the
underlying collection object. So collections are never copied when converting between Java and Scala.
An interesting property is that if you do a round-trip conversion from, say, a Java type to itscorresponding Scala type, and back to the same Java type, you end up with the identical collection
object you started with.
Some other common Scala collections exist that can also be converted to Java types, but for which no
corresponding conversion exists in the other direction. These are:
Seq
mutable.Seq
Set
Map
\null
\null
\null
\null
java.util.List
java.util.List
java.util.Set
java.util.Map
Because Java does not distinguish between mutable and immutable collections in their type, a
conversion from, say, collection.immutable.List will yield a java.util.List, on which all attempted
mutation operations will throw an UnsupportedOperationException. Here&#8217;s an example:
scala&gt; val jul: java.util.List[Int] = List(1, 2, 3)
jul: java.util.List[Int] = [1, 2, 3]
scala&gt; jul.add(7)
java.lang.UnsupportedOperationException
at java.util.AbstractList.add(AbstractList.java:131)</p></div>
</div>
</div>
</div>
<h1 id="_24_18_">24.18 Висновок</h1>
<div class="paragraph"><p>You&#8217;ve now seen how to use Scala&#8217;s collection in great detail. Scala&#8217;s collections take the approach of
giving you powerful building blocks rather than a number of ad hoc utility methods. Putting together
two or three such building blocks allows you to express an enormous number of useful computations.
This style of library is especially effective due to Scala having a light syntax for function literals, and
due to it providing many collection types that are persistent and immutable.
This chapter has shown collections from the point of view of a programmer using the collection library.
The next chapter will show you how the collections are built and how you can add your own collection
types.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-02 03:58:15 EEST
</div>
</div>
</body>
</html>
