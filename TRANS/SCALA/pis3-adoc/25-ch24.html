<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__24">Глава 24</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Колекції: докладно</h1>
<div class="paragraph"><p>Scala включає елегантну та потужну бібліотеку колекцій. Навіть якщо вважати, що API колекцій тонкий на перший погляд, зміни, які він може спровокувати в вашому стилі програмування можуть бути грунтовними. Досить часто це так, якби ви робили на вищому рівні з базовими будівельними блоками програми, що є цілими колекціями, ніж їх елементами. Цей новий стиль програмування потребує деякої адаптації. Нащастя, адаптації допомагють декілька милих властивостей Scala колекцій. Вони прості в використанні, стислі, безпечні, швидкі та універсальні.</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Простота в використанні:</strong> Невеликого словника з двадцяти до сорока методів, досить для вирішення більшості проблем колекцій в парі операцій. Намає потреби огортати вашу голову кругом складних циклічних структур або рекурсій. Стійкі колекції вільні від операцій з побічними ефектами, що означає, що вам не треба хвилюватись про випадкове руйнування існуючих колекцій новими даними. Взаємодію між ітераторами та оновленнями колекцій ліквідовано.
</p>
</li>
<li>
<p>
<strong>Стислість:</strong> Ви можете досягти за допомогою одного слова те, що раніше займало один або декілька циклів. Ви можете виразити функціональні операції за допомогою легковажного синтаксису та без зусиль комбінувати операції так що результат відчувається як власна алгебра.
</p>
</li>
<li>
<p>
<strong>Безпечність:</strong> Щоб зрозуміти це, треба мати досвід. Статична типізація та функціональна природа Scala колекцій означає, що переважна більшість помилок, які ви можете зробити, відловлюються під час компіляції. Причини цього в тому, що (1) операції колекцій самі часто використовуються, і таким чином, гарно протестовані. (2) використання операцій з колекціями робить входи та виходи явними, як параметри функції та результати. (3) Ці явні входи та виходи є предметом перевірки статичних типів. Підсумок всього цього в тому, що велика більшість хибних використань будуть заявляти про себе як помилки типів. Взагалі не є рідкістю мати програми з декількох сотень рядків, що роблять з першої спроби.
</p>
</li>
<li>
<p>
<strong>Швидкість:</strong> Операції з колекціями настроєні і оптимізовані в бібліотеках. Як результат, використання колекцій типово досить ефективне. Ви можете бути в змозі зробити все трохи краще, через уважно налаштовані структури даних та операції, але ви також можете зробити все значно гірше, по ходу справи прийнявши якісь неоптимальні рішення з реалізації. Більше того, колекції були адаптовані до паралельної виконання на декількох ядрах. Паралельні колекції підтримують ті самі операції, що і послідовні так що не треба вивчати нові операції та переписувати код. Ви можете перетворити послідовну колекцію в паралельну, просто викликавши метод <code>par</code>.
</p>
</li>
<li>
<p>
<strong>Універсальність:</strong> Колекції провадять ті самі операції на любому типі, коли це має сенс робити. Так що ви можете багато чого досягти з досить малим словником операцій. Наприклад, рядок концептуально є послідовністю символів. Відповідно, в Scala колекціях рядок підтримує всі операції послідовностей. Те саме дійсне і для масивів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ця глава поглиблено описує API для класів колекцій Scala з перспективи користувача. Ви вже бачили швидкий тур по бібліотеці колекцій в Главі 17. Ця глава запрошує вас в більш детальний тур, показуючи всі класи колекцій, і всі методи, що вони визначають так що вона включає все, що вам треба знати для використання Scala колекцій. Дивлячись наперед, Глава 25 буде сконцентрована на архитектурі та аспектах розширюваності бібліотеки, для людей, що реалізують нови типи колекцій.</p></div>
<div class="sect1">
<h2 id="_24_1____">24.1 Змінні та незмінні колекції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви вже знаєте, Scala колекції систематично відрізняють змінні та незмінні колекції. Змінні колекції можуть бути оновлені або розширені на місці. Це означає, що ви можете змінювати, додавати, або видаляти елементи колекції як побічний ефект. Незмінні колекції, для контрасту, ніколи не змінюються. Ви все ще маєте операції, що симулюють додавання, видалення або оновлення, але ці операції будуть в любому випадку повертати нову колекцію та залишати стару колекцію незмінною.</p></div>
<div class="paragraph"><p>Всі класи колекцій знаходяться в пакунку <code>scala.collection</code>, або одному з його субпакунків: <code>mutable</code>, <code>immutable</code> та <code>generic</code>. Більшість класів колекцій, що потрібні клієнтському коду, існують в трьох варіантах, кожний з яких має різні характеристики з точки зору змінності. Три варіанти розміщені в пакунках <code>scala.collection</code>, <code>scala.collection.immutable</code> та <code>scala.collection.mutable</code>.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection.immutable</code> гарантовано буде незмінною для будь-кого. Така колекція ніколи не буде змінюватись після її створення. Таким чином, ви можете покладатись на факт, що отримуєте доступ до значення тієї самої колекції постійно, і в різних точках часу будете завжди мати колекцію з тими самими елементами.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection.mutable</code> знана що має деякі операції, що змінюють колекцію на місці. Ці операції дозволяють вам писати код для зміни колекції самотужки. Однак ви маєте бути уважним, щоб розуміти та захищатись від любих оновлень, що виконують інші частини кодової бази.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection</code> може бути або змінною, або незмінною. Наприклад,<code>scala.collection.IndexedSeq[T]</code> є супертрейтом обох, <code>scala.collection.immutable.IndexedSeq[T]</code> та її родички, <code>scala.collection.mutable.IndexedSeq[T]</code>. Загалом, кореневі колекції в пакунку <code>scala.collection</code> визначають той самий інтерфейс, що і незмінні колекції. І типово, змінні колекції в пакунку <code>scala.collection.mutable</code> додають деякі модифікації з побічним ефектом до цього незмінного інтерфейсу.</p></div>
<div class="paragraph"><p>Різниця між кореневими колекціями та незмінними колекціями в тому, що клієнти назмінних колекцій мають гарантію, що ніхто не може змінити колекцію, коли як клієнти кореневих колекцій знають тільки, що вони самі не можуть змінити колекцію. Навіть зважаючи, що статичний тип такої колекції не провадить операцій для модифікації колекції, все ще може бути можливим, щоб тип часу виконання був змінною колекцією, що може бути змінена іншими клієнтами.</p></div>
<div class="paragraph"><p>По замовчанню Scala завжди обирає незмінні колекції. Наприклад, якщо ви просто пишете <code>Set</code> без жодного префіксу, або без імпорту будь-чого, ви отримаєте незмінну множину, і якщо ви напишете <code>Iterable</code>, ви отримаєте незмінне ітерабельне, оскільки ці прив'язки по замовчанню імпортуються з пакунка <code>scala</code>. Щоб отримати змінні версії по замовчанню, вам треба написати явно <code>collection.mutable.Set</code>, або <code>collection.mutable.Iterable</code>.</p></div>
<div class="paragraph"><p>Останній пакунок в ієрархії колекцій є <code>collection.generic</code>. Цей пакунок містить будівельні блоки для реалізації колекцій. Типово, класи колекцій відкладають реалізації деяких зі своїх операцій до класів в <code>generic</code>. З іншого боку, щоденні користувачі фреймворку колекцій мають потребу посилатись на класи в <code>generic</code> тільки за виключних обставин.</p></div>
<div class="sect2">
<h3 id="___2">Ієрархія колекцій.</h3>
<div class="listingblock">
<div class="content">
<pre><code>Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_2__">24.2 Узгодженість колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Найбільш важливі класи колекцій показані на Малюнку 24.1. Є досить загального, що поділяють ці класи. Наприклад, кожний різновид колекції може бути створений за однаковим уніформним синтаксисом, записуючи ім'я класу колекції, за яким ідуть його елементи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">Iterable</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">,</span> <span class="s">&quot;y&quot;</span><span class="o">,</span> <span class="s">&quot;z&quot;</span><span class="o">)</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">,</span> <span class="s">&quot;z&quot;</span> <span class="o">-&gt;</span> <span class="mi">26</span><span class="o">)</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Green</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>
<span class="nc">SortedSet</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">)</span>
<span class="nc">Buffer</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
<span class="nc">IndexedSeq</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="nc">LinearSeq</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Той самий принцип також стосується специфічних реалізацій колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">HashMap</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">,</span> <span class="s">&quot;z&quot;</span> <span class="o">-&gt;</span> <span class="mi">26</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>toString</code> для всіх колекцій продукує вивід, записаний як вище, з іменем типу, за яким в дужках ідуть елементи колекції. Всі колекції підтримують API, що провадить <code>Traversable</code>, але їх методи всі повертають їх власний клас, скоріше ніж кореневий клас  <code>Traversable</code>. Наприклад, метод <code>map</code> на <code>List</code> має тип повернення <code>List</code>, тоді як метод <code>map</code> на <code>Set</code> має тип повернення <code>Set</code>. Таким чином, статичний тип повернення ціх методів досить точний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Еквівалентність також організована одноманітно для всіх класів колекцій; більше про це в Розділі 24.13.</p></div>
<div class="paragraph"><p>Більшість класів на Малюнку 24.1 існують в трьох варіантах: <code>root</code>, <code>mutable</code> та <code>immutable</code>. Одне виключення є трейт <code>Buffer</code>, що існує тільки як змінна колекція.</p></div>
<div class="paragraph"><p>В залишку цієї глави ми будемо переглядати ці класи один за одним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_3__code_traversable_code">24.3 Трейт <code>Traversable</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>На вершині ієрархії колекцій стоїть трейт <code>Traversable</code> (<em>прохідний</em>). Його єдина операція є <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Класам колекцій, що реалізують <code>Traversable</code>, просто потрібно визначити цей метод; всі інші методи можуть бути наслідувані від <code>Traversable</code>.</p></div>
<div class="paragraph"><p>Метод <code>foreach</code> призначений для обходу всіх елементів колекції та застосування наданої операції <code>f</code> до кожного елементу. Тип операції <code>Elem =&gt; U</code>, де <code>Elem</code> є типом елементів колекції та <code>U</code> є довільним типом результату. Виклик <code>f</code> робиться тільки заради побічного ефекту; фактично, любий результат функції <code>f</code> буде відкинутий <code>foreach</code>.</p></div>
<div class="paragraph"><p><code>Traversable</code> також визначає багато суцільних методів, всі вони перелічені в Таблиці 24.1. Ці методи підпадають в такі категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Додавання</strong> <code>++</code>, що додає два прохідних разом, або додає всі елементи ітератора до прохідного.
</p>
</li>
<li>
<p>
<strong>Операції відображення</strong> <code>map</code>, <code>flatMap</code> та <code>collect</code>, що продукують нову колекцію через застосування деякої функції до елементів колекції.
</p>
</li>
<li>
<p>
<strong>Перетворення</strong> <code>toIndexedSeq</code>, <code>toIterable</code>, <code>toStream</code>, <code>toArray</code>, <code>toList</code>, <code>toSeq</code>, <code>toSet</code> та <code>toMap</code>, що повертають колекцію <code>Traversable</code> в більш специфічну колекцію. Всі ці перетворення повертають об'єкт отримувача, якщо він вже відповідає бажаному типу колекції. Наприклад, застосування <code>toList</code> до списку буде повертати сам список.
</p>
</li>
<li>
<p>
<strong>Операції копіювання</strong> <code>copyToBuffer</code> та <code>copyToArray</code>. Як кажуть їх імена, вони копіюють елементи колекції до буфера або масива, відповідно.
</p>
</li>
<li>
<p>
<strong>Операції розміру</strong> <code>isEmpty</code>, <code>nonEmpty</code>, <code>size</code> та <code>hasDefiniteSize</code>. Колекції, що є прохідними, можуть бути скінченими та нескінченими. Прикладом нескінченої прохідної колекції є потік натуральних чисел <code>Stream.from(0)</code>. Метод <code>hasDefiniteSize</code> вказує, що колекція, можливо, нескінчена. Якщо він повертає <code>false</code>, колекція може бути нескінченою, і в цьому випадку <code>size</code> буде видавати помилку або не повернеться.
</p>
</li>
<li>
<p>
<strong>Операції отримання елемента</strong> <code>head</code>, <code>last</code>, <code>headOption</code>, <code>lastOption</code> та <code>find</code>. Вони обирають перший або останній елемент колекції, або інакше перший елемент, що задовільняє умові. Однак зазначте, що не всі колекції мають гарно визначення значення того, що значить "перший" та "останній". Наприклад, хеш множина може зберігати елементи відповідно до їх хеш ключів, що можуть змінюватись від запуску до запуску. В цьому випадку "перший" елемент хеш набору також може бути різним для разних запусків програм. Колекція є впорядкована, якщо вона завжди видає свої елементи в тому самому порядку. Більшість колекцій впорядковані, але деякі (такі як хеш множини) ні — відкидання впорядкованості дає трохи додаткової ефективності. Порядок часто є основою для отримання повторюваних тестів та допомагає в зневадженні. Ось чому колекції Scala провадять впорядковані альтернативи для всіх типів колекцій. Наприклад, впорядкована альтернатива для <code>HashSet</code> є <code>LinkedHashSet</code>.
</p>
</li>
<li>
<p>
<strong>Операції отримання субколекцій</strong> <code>takeWhile</code>, <code>tail</code>, <code>init</code>, <code>slice</code>, <code>take</code>, <code>drop</code>, <code>filter</code>, <code>dropWhile</code>, <code>filterNot</code>, <code>withFilter</code>. Всі вони повертають деяку субколекцію, що ідентифікується диапазоном індексів або предикатом.
</p>
</li>
<li>
<p>
<strong>Операції підрозділу</strong> <code>splitAt</code>, <code>span</code>, <code>partition</code> та <code>groupBy</code> підрозділяють елементи колекції на декілька субколекцій.
</p>
</li>
<li>
<p>
<strong>Перевірка елементів</strong> <code>exists</code>, <code>forall</code> та <code>count</code> перевіряють елементи колекції за допомогою наданого предикату.
</p>
</li>
<li>
<p>
<strong>Згортки</strong> <code>foldLeft</code>, <code>foldRight</code>, <code>/:</code>, <code>:\</code>, <code>reduceLeft</code>, <code>reduceRight</code> застосовують двомісні операції до послідовних елементів.
</p>
</li>
<li>
<p>
<strong>Особливі згортки</strong> <code>sum</code>, <code>product</code>, <code>min</code>, <code>max</code> роблять з колекціями специфічних типів (числові або порівнювані).
</p>
</li>
<li>
<p>
<strong>Рядкові операції</strong> <code>mkString</code>, <code>addString</code>, <code>stringPrefix</code> провадять альтернативні шляхи перетворення колекції на рядок.
</p>
</li>
<li>
<p>
<strong>Операції переглядів</strong> складаються з двох перевантажених варіантів метода <code>view</code>. Перегляд є колекція, що обчислюється ліниво. Ви пізнаєте більше про перегляди в Розділі 24.14.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Абстрактний метод:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs foreach</p></td>
<td align="left" valign="top"><p class="table">Виконує функцію <code>f</code> для кожного елементу <code>xs</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Додавання:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++ ys</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з елементів обох, <code>xs</code> та <code>ys</code>.  <code>ys</code> є колекцією <code>TraversableOnce</code>, тобто або <code>Traversable</code>, або <code>Iterator</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Мапи:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs map</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування функції <code>f</code> до кожного елемента в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs flatMap</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування функції <code>f</code> від значень-колекції до кожного елементу в <code>xs</code> та конкатенації результатів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs collect</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування часткової функції <code>f</code> до кожного елементу в <code>xs</code>, для яких вона визначена та накопичення результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Перетворення:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toArray</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в масив.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toList</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в список.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toIterable</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в Iterable.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toSeq</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toIndexedSeq</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в індексовану послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toStream</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в потік (ліниво обчислювана послідовність).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toSet</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в множину.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toMap</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію пар ключ/значення в мапу.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Копіювання:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs copyToBuffer buf</p></td>
<td align="left" valign="top"><p class="table">Копіює всі елементи колекції в буфер <code>buf</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs copyToArray(arr, s, len)</p></td>
<td align="left" valign="top"><p class="table">Копіює щонайбільше <code>len</code> елементів <code>arr</code>, починаючи з індексу <code>s</code>. Два останні аргументи опціональні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Інформація про розмір:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.isEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція порожня.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.nonEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція містить елементи.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.size</p></td>
<td align="left" valign="top"><p class="table">Число елементів в колекції.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.hasDefiniteSize</p></td>
<td align="left" valign="top"><p class="table">True, якщо відомо, що xs має фіксований розмір.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Отримання елементів:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.head</p></td>
<td align="left" valign="top"><p class="table">Перший елемент колекції (або деякий елемент, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.headOption</p></td>
<td align="left" valign="top"><p class="table">Перший елемент <code>xs</code> в опціональному значенні, або <code>None</code>, якщо <code>xs</code> порожнє.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.last</p></td>
<td align="left" valign="top"><p class="table">Останній елемент колекції (або деякий елемент, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.lastOption</p></td>
<td align="left" valign="top"><p class="table">Останній елемент <code>xs</code> в опціональному значенні, або <code>None</code>, якщо <code>xs</code> порожнє.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs find</p></td>
<td align="left" valign="top"><p class="table">Опція, яка містить перший елемент в <code>xs</code>, що задовільняє <code>p</code>, або <code>None</code>, якщо жодний елемент не підійде.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Субколекції:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.tail</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs.head</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.init</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs.last</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs slice (from, to)</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з елементів <code>xs</code> в деякому диапазоні індексів (від <code>from</code> до <code>to</code>, виключно).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs take</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з перших <code>n</code> елементів <code>xs</code> (або деякі довільні <code>n</code> елементів, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs drop</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs take n</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs takeWhile</p></td>
<td align="left" valign="top"><p class="table">Найдовший префікс елементів в колекції, що задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs dropWhile</p></td>
<td align="left" valign="top"><p class="table">Колекція без найдовшого префіксу елементів, всі з яких задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs filter</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з тих елементів <code>xs</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs withFilter</p></td>
<td align="left" valign="top"><p class="table">Не-строгий фільтр для цієї колекції. Всі операції на отриманому фільтрі будуть застосовані тільки для тих елементів <code>xs</code>, для яких мова <code>p</code> є <code>true</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs filterNot</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з тих елементів <code>xs</code>, що не задовільняють предикатові <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Суброзподіл:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs splitAt</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> в позициї <code>n</code>, даючи пару колекцій (<code>xs take n</code>, <code>xs drop n</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs span</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> відповідно до предикату, даючи пару колекцій (<code>xs takeWhile p</code>, <code>xs.dropWhile p</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs partition</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> на пару колекцій; одна з елементами, що задовільняють предикату <code>p</code>, інша з елементами, що ні, даючи пару колекцій(<code>xs filter p</code>, <code>xs.filterNot p</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs groupBy</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> на мапу колекцій, відповідно до функції дескреминатору <code>f</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Умови до елементів:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs forall</p></td>
<td align="left" valign="top"><p class="table">Логічне, що визначає, чи предикат <code>p</code> дотримується до всіх елементів <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs exists</p></td>
<td align="left" valign="top"><p class="table">Логічне, що вказує, чи предикат <code>p</code> дотримується до деякого елемента в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs count</p></td>
<td align="left" valign="top"><p class="table">Число елементів в <code>xs</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Згортки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(z /: xs)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами <code>xs</code>, ідучи зліва направо, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(xs :\ z)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами <code>xs</code>, ідучи зправа наліво, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.foldLeft(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>(z /: xs)(op)</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.foldRight(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>(xs :\ z)(op)</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reduceLeft op</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами непорожньої колекції <code>xs</code>, ідучи зліва направо.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reduceRight op</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами непорожньої колекції <code>xs</code>, ідучи зправа наліво.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Особливі згортки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.sum</p></td>
<td align="left" valign="top"><p class="table">Сума числових значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.product</p></td>
<td align="left" valign="top"><p class="table">Добуток числових значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.min</p></td>
<td align="left" valign="top"><p class="table">Мінімум впорядкованих значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.max</p></td>
<td align="left" valign="top"><p class="table">Максімум впорядкованих значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Рядки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs addString (b, start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Додає рядок до <code>StringBuilder</code> <code>b</code>, що показує всі елементи <code>xs</code>, розділені роздільниками <code>sep</code> та оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs mkString (start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію на рядок, що показує всі елементи <code>xs</code> між роздільниками <code>sep</code> та оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.stringPrefix</p></td>
<td align="left" valign="top"><p class="table">The collection name at the beginning of the string returned from xs.toString.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Перегляди:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.view</p></td>
<td align="left" valign="top"><p class="table">Продукує перегляд xs.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs view (from, to)</p></td>
<td align="left" valign="top"><p class="table">Продукує перегляд, що представляє елементи в деякому диапазоні індексів <code>xs</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<h1 id="_24_4__iterable">24.4 Трейт Iterable</h1>
<div class="paragraph"><p>Наступний трейт зверху на Малюнку 24.1 є <code>Iterable</code>. Всі методи в цьому трейті визначені в термінах абстрактного метода <code>iterator</code>, що видає елементи колекції один за одним. Абстрактний метод <code>foreach</code>, наслідуваний від трейту <code>Traversable</code>, реалізований в <code>Iterable</code> в термінах <code>iterator</code>. Ось справжня реалізація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="n">f</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лише кілька субкласів <code>Iterable</code> перекривають цю стандартну реалізацію <code>foreach</code> в <code>Iterable</code>, оскільки вони можуть провадити більш ефективну реалізацію. Пам'ятайте, що <code>foreach</code> є основою для реалізації всіх операцій в <code>Traversable</code> так що продуктивність важлива.</p></div>
<div class="paragraph"><p>Ще два метода існують в <code>Iterable</code>, що повертають ітератори: <code>grouped</code> та <code>sliding</code>. Однак ці ітератори не повертають поодинокі елементи, але цілі субпослідовності елементів оригінальної колекції. Максимальний розмір ціх послідовностей надається як аргумент до ціх методів. Метод <code>grouped</code> розбиває свої елементи на інкрементальні пакунки, тоді як <code>sliding</code> дає ковзаюче вікно по елементах. Різниця між двома стане яснішою при погляді на наступні взаємодії в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">git</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">grouped</span> <span class="mi">3</span>
<span class="n">git</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sit</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">sliding</span> <span class="mi">3</span>
<span class="n">sit</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Трейт <code>Iterable</code> також додає деякі інші методи до <code>Traversable</code>, що можуть бути ефективно реалізовані тільки за наявності ітератора. Вони підсумовані в Таблиці 24.2:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Абстрактний метод:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">iterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожний елемент в <code>xs</code>, в тому самому порядку, як <code>foreach</code> проходить по елементах</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Інші ітератори:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs grouped size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає "частки" колекції фіксованого розміру</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sliding size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає ковзне вікно фіксованого розміру з елементів колекції</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Субколекції:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs takeRight</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з останніх <code>n</code> елементів <code>xs</code> (або довільні <code>n</code> елементів, якщо порядок не визначений)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs dropRight</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs takeRight n</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Поєднувачі:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs zip ys</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар відповідних елементів з <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs zipAll (ys, x, y)</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар відповідних елементів з <code>xs</code> та <code>ys</code>, де коротша послідовність розширюється, щоб співпадати до довшої, через додавання елементів <code>x</code> або <code>y</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.zipWithIndex</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар елементів <code>xs</code> разом з їх індексами</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Порівняння:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sameElements ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> та <code>ys</code> містять ті самі елементи в тому ж порядку</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="____code_traversable_code__code_iterable_code">Чому мати обоє, <code>Traversable</code> та <code>Iterable</code>?</h3>
<div class="paragraph"><p>Ви можете здивуватись, для чого додатковий трейт <code>Traversable</code> над <code>Iterable</code>. Чи не могли б зробити все з ітератором? То яка ідея мати більш абстрактний трейт, що визначає свої методи в термінах <code>foreach</code> замість <code>iterator</code>? Одна причина мати <code>Traversable</code> в тому, що іноді простіше або більш ефективно провадити реалізацію для <code>foreach</code>, ніж провадити реалізацію ітератора. Ось простий приклад. Скажімо, ви бажаєте ієрархію класів для бінарних дерев, що мають цілі елементи на листках. Ви можете розробиби цю ієрархію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер вважатимемо, ви бажаєте зробити дерева перехідними. Щоб зробити це, треба щоб <code>Tree</code> наслідував від <code>Traversable[Int]</code> та визначав метод <code>foreach</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">;</span> <span class="n">r</span> <span class="n">foreach</span> <span class="n">f</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не дуже складно, і це також дуже ефективно — перехід по збалансованому дереву пропорційно до числа елементів в дереві. Щоб побачити це, уявімо, що збалансоване дерево з <code>N</code> листками буде мати <code>N - 1</code> внутрішніх листків класу <code>Branch</code>. Так що загальна кількість кроків для обходу дерева є <code>N + N - 1</code>.</p></div>
<div class="paragraph"><p>Тепер порівняйте це з робленням дерев ітерабельними. Щоб зробити це, робимо <code>Tree</code> походячим від <code>Iterable[Int]</code> та визначаємо метод <code>iterator</code> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">.</span><span class="n">single</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">iterator</span> <span class="o">++</span> <span class="n">r</span><span class="o">.</span><span class="n">iterator</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>На перший погляд це виглядає не складніше, ніж рішення <code>foreach</code>. Однак є проблема ефективності, що стосується реалізації метода конкатенації ітератора, <code>++</code>. Кожного разу,коли продукується елемент конкатенованим ітератором, як в <code>l.iterator ++ r.iterator</code>, обчислення потребує слідувати одному непрямому переходу, щоб отримати вірний ітератор (<code>l.iterator</code> або <code>r.iterator</code>). Загалом це робить <code>log(N)</code> перенаправлень, щоб отримати листок збалансованого дерева з <code>N</code> leaves. Так що ціна відвідування всіх елементів дерева становить від близько <code>2N</code> для метода обходу <code>foreach</code>, до <code>Nlog(N)</code> для проходу за допомогою ітератору. Якщо дерево має мільйон елементів, це означає близько двох мільйонів кроків для <code>foreach</code>, і біля двадцяти (?) мільйонів кроків для <code>iterator</code>. Так що рішення <code>foreach</code> має явну перевагу.</p></div>
</div>
<div class="sect2">
<h3 id="__iterable">Субкатегорії Iterable</h3>
<div class="paragraph"><p>В ієрархії наслідування нижче <code>Iterable</code> ви знайдете три трейти: <code>Seq</code>, <code>Set</code> та <code>Map</code>. Загальний аспект ціх трьох трейтів в тому, що всі вони реалізують трейт <code>PartialFunction</code>,<span class="footnote"><br />[Часткові функції були описані в Розділі 15.7.]<br /></span> з його методами <code>apply</code> та <code>isDefinedAt</code>. Однак спосіб, в який кожний трейт реалізує <code>PartialFunction</code>, відрізняється.</p></div>
<div class="paragraph"><p>Для послідовностей <code>apply</code> є позиційне індексування, де елементи завжди пронумеровані від <code>0</code>. Тобто, <code>Seq(1, 2, 3)(1) == 2</code>. Для множин <code>apply</code> є перевіркою належності. Наприклад, <code>Set('a', 'b', 'c') ('b') == true</code>, тоді як <code>Set()('a') == false</code>. Нарешті, для мап <code>apply</code> є вибір. Наприклад, <code>Map('a' - &gt; 1, 'b' -&gt; 10, 'c' -&gt; 100)('b') == 10</code>.</p></div>
<div class="paragraph"><p>В наступних трьох розділах ми пояснимо кожний з трьох типів колекцій більш детально.</p></div>
</div>
<div class="sect1">
<h2 id="_24_5___code_seq_code_code_indexedseq_code_code_linearseq_code">24.5 Трейти послідовностей <code>Seq</code>, <code>IndexedSeq</code>, <code>LinearSeq</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Трейт <code>Seq</code> представляє послідовності. Послідовність різновид ітерабельного, що має довжину та чиї елементи мають фіксовані індексовані позиції, починаючи від 0. Операції над послідовностями, підсумовані на Малюнку 24.3, підпадають в наступні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Операції індексування та довжини</strong> <code>apply</code>, <code>isDefinedAt</code>, <code>length</code>, <code>indices</code> та <code>lengthCompare</code>. Для <code>Seq</code> операція <code>apply</code> означає індексування; таким чином послідовність типу <code>Seq[T]</code> є частковою функцією, що приймає аргумент <code>Int</code> (індекс) та видає елемент послідовності типу <code>T</code>. Іншими словами, <code>Seq[T]</code> розширює <code>PartialFunction[Int, T]</code>. Елементи послідовності індексовані від нуля до довжини послідовності мінус один. Метод <code>length</code> на послідовностях є псевдонимом метода <code>size</code> на загальних колекціях. Метод <code>lengthCompare</code> дозволяє вам порівнювати довжину двох послідовностей, навіть якщо одна з послідовностей має безкінечну довжину.
</p>
</li>
<li>
<p>
<strong>Операції пошуку індексу</strong> <code>indexOf</code>, <code>lastIndexOf</code>, <code>indexOfSlice</code>, <code>lastIndexOfSlice</code>,<code>indexWhere</code>, <code>lastIndexWhere</code>, <code>segmentLength</code> та <code>prefixLength</code> повертають індекс елементу, рівному до заданого значення або співпадаючий з деяким предикатом.
</p>
</li>
<li>
<p>
<strong>Операції додавання</strong> <code>+:</code>, <code>:+</code> та <code>padTo</code>, повертають нову послідовність, отриману від додавання елементів зпереду або з кінця послідовності.
</p>
</li>
<li>
<p>
<strong>Операції оновлення</strong> <code>updated</code> та <code>patch</code>, що повертають нову послідовність, отриману від заміни деяких елементів оригінальної послідовності.
</p>
</li>
<li>
<p>
<strong>Операції сортування</strong> <code>sorted</code>, <code>sortWith</code> та <code>sortBy</code> сортують елементи послідовності відповідно до різних критеріїв.
</p>
</li>
<li>
<p>
<strong>Операції обертання</strong> <code>reverse</code>, <code>reverseIterator</code> та <code>reverseMap</code> видають або обробляють елементи послідовності в зворотньому порядку, від останнього до першого.
</p>
</li>
<li>
<p>
<strong>Операції порівняння</strong> <code>startsWith</code>, <code>endsWith</code>, <code>contains</code>, <code>corresponds</code> та <code>containsSlice</code> співвідносить дві послідовності або шукає елемент в послідовності.
</p>
</li>
<li>
<p>
<strong>Множинні операції</strong> <code>intersect</code>, <code>diff</code>, <code>union</code> та <code>distinct</code> виконують множино-подібні операції на елементах двох послідовностей, або видаляють дублікати.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо послідовність змінна, вона пропонує додатковий метод з побічним ефектом <code>update</code>, що дозволяє оновлювати елементи. Згадайте з Глави 3, що синтаксис як <code>seq(idx) = elem</code> є просто скороченням для <code>seq.update(idx, elem)</code>. Зауважте різницю між <code>update</code> та <code>updated</code>. Метод <code>update</code> змінює елемент послідовності на місці та доступний тільки для змінних послідовностей. Метод <code>updated</code> доступний для всіх послідовностей та завжди повертає нову послідовність, замість модифікації оригіналу.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Індексування та довжина:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(i)</p></td>
<td align="left" valign="top"><p class="table">(або, розписано,<code>xs apply i</code>) Елемент <code>xs</code> за індексом <code>i</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs isDefinedAt</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>i</code> міститься в <code>xs.indices</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.length</p></td>
<td align="left" valign="top"><p class="table">Довжина послідовності (те саме, що і <code>size</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.lengthCompare ys</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>-1</code>, якщо <code>xs</code> коротше за <code>ys</code>, <code>+1</code> якщо довше та <code>0</code> якщо вони мають рівну довжину. Робить, навіть якщо послідовності безкінечні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.indices</p></td>
<td align="left" valign="top"><p class="table">Диапазон індексів <code>xs</code>, що простягається від <code>0</code> до <code>xs.length - 1</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Індексний пошук:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу в <code>xs</code> рівному <code>x</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs lastIndexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс останнього елементу в <code>xs</code> рівному <code>x</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexOfSlice ys</p></td>
<td align="left" valign="top"><p class="table">Перший індекс <code>xs</code> такий, що наступні елементи починаючи з цього індексу формують послідовність <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs lastIndexOfSlice ys</p></td>
<td align="left" valign="top"><p class="table">Останній індекс <code>xs</code> такий, що наступні елементи починаючи з цього індексу формують послідовність <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexWhere</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу <code>xs</code>, задовільняє <code>p</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs segmentLength (p, i)</p></td>
<td align="left" valign="top"><p class="table">Довжина найдовшого неперериваного сегменту елементів <code>xs</code>, починаючи з <code>xs(i)</code>, всі з яких задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs prefixLength</p></td>
<td align="left" valign="top"><p class="table">Довжина найдовшого префіксу з елементів <code>xs</code>, всі з яких задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">x +: xs</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, що складається з <code>x</code> перед <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs :+</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, що складається з <code>x</code> після <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs padTo (len, x)</p></td>
<td align="left" valign="top"><p class="table">Послідовність, що утворюється як результат від додавання значення <code>x</code> до <code>xs</code>, доки не буде досяжена довжина <code>len</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs patch (i, ys, r)</p></td>
<td align="left" valign="top"><p class="table">Послідовність як результат від заміни <code>r</code> елементів <code>xs</code>, починаючи з <code>i</code> на латку <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs updated (i, x)</p></td>
<td align="left" valign="top"><p class="table">Копія <code>xs</code>, з елементом з індексом <code>i</code>, заміненим на <code>x</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(i) =</p></td>
<td align="left" valign="top"><p class="table">(або, розписане, <code>xs.update(i, x)</code>, доступне тільки для` mutable.Seq`). Зміна елементу <code>xs</code> по індексу <code>i</code> на <code>y</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Сортування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.sorted</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів  <code>xs</code> з використанням стандартного впорядкування типу елементів <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sortWith lessThan</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів <code>xs</code>, використовуючи <code>lessThan</code> як операції порівняння.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sortBy</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів <code>xs</code>. Порівняння між двома елементами обробляється через відображення двох елементів функцією <code>f</code> над обома та порівняння результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Обернення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.reverse</p></td>
<td align="left" valign="top"><p class="table">Послідовність з елементами <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.reverseIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає всі елементи <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reverseMap</p></td>
<td align="left" valign="top"><p class="table">Послідовність, отримана від відображення <code>f</code> над елементами <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Порівняння:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs startsWith ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> починається з послідовності <code>ys</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs endsWith ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> закінчується на <code>ys</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> має елемент, що дорівнює <code>x</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs containsSlice ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> має послідовність, що дорівнює <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(xs corresponds ys)(p)</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи відповідні елементи <code>xs</code> та <code>ys</code> задовільняють двомісному предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Множинні операції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs intersect ys</p></td>
<td align="left" valign="top"><p class="table">Множинний перетин послідовностей <code>xs</code> та <code>ys</code>, що зберігає порядок елементів в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs diff ys</p></td>
<td align="left" valign="top"><p class="table">Множинна різниця послідовностей <code>xs</code> та <code>ys</code>, що зберігає порядок елементів в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs union ys</p></td>
<td align="left" valign="top"><p class="table">Множинне об'єднання; те саме, що <code>xs ++ ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.distinct</p></td>
<td align="left" valign="top"><p class="table">Субпослідовність <code>xs</code>, що не містить дублікатів.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Кожний трейт <code>Seq</code> має два субтрейти, <code>LinearSeq</code> та <code>IndexedSeq</code>. Вони не додають жодних нових операцій, але кожний пропонує різні характеристики продуктивності. Лінійна послідовність має ефективні операції <code>head</code> та <code>tail</code>, тоді як індексована послідовність має ефективні операції <code>apply</code>, <code>length</code> та (якщо <code>mutable</code>) <code>update</code>. <code>List</code> є часто використовувана лінійна послідовність, як і <code>Stream</code>. Дві часто використовувані індексовані послідовності є <code>Array</code> та <code>ArrayBuffer</code>. Клас <code>Vector</code> провадить цікавий компроміс між індексованим та лінійним доступом. Він має однаково ефективний сталий час індексного навантаження та сталий час лінійного доступу. Завдяки цьому вектори є гарною основою для шаблонів змішаного доступу, коли одночасно використовується індексний та лінійний доступи. Більше про вектори в Розділі 24.8.</p></div>
<div class="sect2">
<h3 id="_">Буфери</h3>
<div class="paragraph"><p>Важлива суб-категорія змінних послідовностей є буфери. Буфери дозволяють не тільки оновлення існуючих елементів, але також вставки елементів, видалення елементів та ефективне додавання нових елементів в кінець буфера. Принципово нові методи, що підтримуються буферами, є <code>+=</code> та <code>++=</code> для додавання елементів в кінець та <code>+=:</code> і <code>++=:</code> для додавання зпереду, <code>insert</code> та <code>insertAll</code> для вставок елементів так само як <code>remove</code> та <code>-=</code> для видалення елементів. Ці These operations are summarized in Table 24.4.</p></div>
<div class="paragraph"><p>Дві реалізації <code>Buffer</code> в загальному ужитку є <code>ListBuffer</code> та <code>ArrayBuffer</code>. Як підказує ім'я, <code>ListBuffer</code> підтримується <code>List</code> та підтримує ефективне перетворення його елементів <code>List</code>, тоді як  <code>ArrayBuffer</code> покладається на масив та може бути швидко перетворений на такий. Ви бачили проблиск реалізації <code>ListBuffer</code> в Розділі 22.2.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf +=</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до буфера <code>buf</code> та повертає самий <code>buf</code> як результат</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf += (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Додає надані елементи до буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf ++= xs</p></td>
<td align="left" valign="top"><p class="table">Додає всі елементи в <code>xs</code> до буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">x +=: buf</p></td>
<td align="left" valign="top"><p class="table">Ставить елемент <code>x</code> в початок буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++=: buf</p></td>
<td align="left" valign="top"><p class="table">Ставить всі елементи <code>xs</code> в початок буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf insert (i, x)</p></td>
<td align="left" valign="top"><p class="table">Вставляє елемент <code>x</code> по індексу <code>i</code> в буфер</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf insertAll (i, xs)</p></td>
<td align="left" valign="top"><p class="table">Вставляє всі елементи в <code>xs</code> по індексу <code>i</code> в буфер</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент <code>x</code> з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє елементпо індексу <code>i</code> з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf remove (i, n)</p></td>
<td align="left" valign="top"><p class="table">Видаляє <code>n</code> елементів, починаючи з індексу <code>i</code>, з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf trimStart</p></td>
<td align="left" valign="top"><p class="table">Видаляє перші <code>n</code> елементів з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf trimEnd</p></td>
<td align="left" valign="top"><p class="table">Видаляє останні <code>n</code> елементів з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи з буфера</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf.clone</p></td>
<td align="left" valign="top"><p class="table">Новий буфер з тими самим елементами, що і <code>buf</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_6_">24.6 Множини</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>Set</code> є <code>Iterable</code>, що не містить дублікатів елементів. Операції з множинами підсумовані в Таблиці 24.5 для <code>general</code> множин, і Таблиці 24.6 <code>mutable</code> множин. Вони підпадають під наступні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Перевірки</strong> <code>contains</code>, <code>apply</code> та <code>subsetOf</code>. Метод <code>contains</code> вказує, чи множина містить наданий елемент. Метод <code>apply</code> для множини те саме, що і <code>contains</code> так що <code>set(elem)</code> відповідає до  <code>set contains elem</code>. Це означає, що множини можуть також використовуватись як функції перевірки, що повертають <code>true</code> для елементів, які вони містять. Наприклад:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span><span class="o">,</span> <span class="s">&quot;peach&quot;</span><span class="o">,</span> <span class="s">&quot;banana&quot;</span><span class="o">)</span>
<span class="n">fruit</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="n">apple</span><span class="o">,</span> <span class="n">orange</span><span class="o">,</span> <span class="n">peach</span><span class="o">,</span> <span class="n">banana</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">(</span><span class="s">&quot;peach&quot;</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">(</span><span class="s">&quot;potato&quot;</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Додавання</strong> <code>+</code> and <code>++</code> додають до множини один або більше елементів, даючи нову множини в якості результату.
</p>
</li>
<li>
<p>
<strong>Видалення</strong> <code>-</code> та <code>--</code> видаляють один або більше з множини, даючи нову множину.
</p>
</li>
<li>
<p>
<strong>Операції множин</strong> для об'єднання, перетину та різниці. Ці операції існують в двох фломах: алгебраїчній та символічній. Алгебраїчні версії є <code>intersect</code>, <code>union</code> та <code>diff</code>, тоді як символічні версії <code>&amp;</code>, <code>|</code> та <code>&amp;~</code>. Метод <code>++</code>, який <code>Set</code> наслідує від <code>Traversable</code>, може розглядатись як ще один псевдоним для <code>union</code> або <code>|</code>, за винятком того, що <code>++</code> приймає аргумент <code>Traversable</code>, коли <code>union</code> та <code>|</code> приймають множини.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перевірки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>x</code> є елементом <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(x)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <code>xs contains x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs subsetOf ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> є підмножиною <code>ys</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs +</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само як <code>x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs + (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само як надані додаткові елементи</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++ ys</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само, як всі елементи <code>ys</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, за винятком <code>x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs - (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, за винятком наданих елементів</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs&#8201;&#8212;&#8201;ys</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, крім елементів в <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.empty</p></td>
<td align="left" valign="top"><p class="table">Порожня множина такого ж класу, що і <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Бінарні операції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs &amp; ys</p></td>
<td align="left" valign="top"><p class="table">Перетин множин <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs intersect ys</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>xs &amp; ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs | ys</p></td>
<td align="left" valign="top"><p class="table">Поєднання множин <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs union ys</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і `xs</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ys`</p></td>
<td align="left" valign="top"><p class="table">xs &amp;~ ys</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Різниця множин <code>xs and ys</code></p></td>
<td align="left" valign="top"><p class="table">xs diff ys</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Змінні множини мають методи, що додають, видаляють або оновлюють елементи, що підсумовані в Таблиці 24.6:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить
2+"Додавання:</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">xs +=</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до множини <code>xs</code> як побічний ефект та повератє сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs += (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Додає надані елементи до множини як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++= ys</p></td>
<td align="left" valign="top"><p class="table">Додає всі елементи з <code>ys</code> до множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs add</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до <code>xs</code> та повертає <code>true</code>, якщо <code>x</code> досі не був членом множини, <code>false</code> якщо він був там</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент <code>x</code> з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -= (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Видаляє надані елементи з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs --= ys</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи в <code>ys</code> з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє <code>x</code> з <code>xs</code> та повертає <code>true</code>, якщо <code>x</code> до цього містився в множині, <code>false</code> якщо ні</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs retain</p></td>
<td align="left" valign="top"><p class="table">Залишає лише ті елементи в <code>xs</code>, що задовільняють предикату <code>p</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи з <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(x) =</p></td>
<td align="left" valign="top"><p class="table">(або, розписано, <code>xs.update(x, b)</code>) Якщо логічний аргумент <code>b</code> є <code>true</code>, додає <code>x</code> до <code>xs</code>, інакше видаляє <code>x</code> з <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.clone</p></td>
<td align="left" valign="top"><p class="table">Нова змінна множина з тими ж елементами, що і <code>xs</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Так само, як незмінні множини, змінні множини пропонують операції  <code>+</code> та <code>++</code> для додавання елементів та <code>-</code> та <code>--</code> для видалення елементів. Але вони рідше використовуються для змінних множин, оскікльки це включає копіювання множини. Ак більш ефективна альтернатива, змінні множини пропонують методи оновлення <code>+=</code> та <code>- =</code>. Операція <code>s += elem</code> додає <code>elem</code> до множини <code>s</code> в якості побічного ефекту та повертає змінену множину як результат. Подібно до цього, <code>s -= elem</code> видаляє <code>elem</code> з множини та повертає змінену множину як результат. Окрім <code>+=</code> та <code>-=</code> також існують масові операції <code>++=</code> та <code>--=</code>, що додають або видаляють всі елементи перехідного або ітератора.</p></div>
<div class="paragraph"><p>Вибір імен методів, <code>+=</code> та <code>-=</code> означає, що дуже подібний код буде робити однаково, зі змінними та незмінними множинами. Зпочатку розглянемо наступний диалог в інтерпретаторі, що використовує незмінну множину <code>s</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span> <span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі ми використали <code>+=</code> та <code>-=</code> на <code>var</code> типу <code>immutable.Set</code>. Як було пояснено на Кроці 10 в Главі 3, а твердження як <code>s += 4</code> є скороченням для <code>s = s + 4</code>. Так що це викликає метод додавання <code>+</code> на множині <code>s</code> та потім присвоює результат назад до змінної <code>s</code>. Розглянемо тепер аналогічну взаємодію зі змінним набором:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The end effect is very similar to the previous interaction; we start with a Set(1, 2, 3) and end up with a Set(1, 3, 4). However, even though the statements look the same as before, they do something different. The s += 4 statement now invokes the += method on the mutable set values, changing the set in place. Likewise, the s -= 2 statement now invokes the -= method on the same set.</p></div>
<div class="paragraph"><p>Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.</p></div>
<div class="paragraph"><p>Mutable sets also provide add and remove as variants of += and -=. The difference is that add andremove return a boolean result indicating whether the operation had an effect on the set.</p></div>
<div class="paragraph"><p>The current default implementation of a mutable set uses a hash table to store the set&#8217;s elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as hash tries.<span class="footnote"><br />[Hash tries are described in Section 24.8.]<br /></span></p></div>
<div class="paragraph"><p>A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_7_">24.7 Мапи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Maps are Iterables of pairs of keys and values (also named mappings or associations). As explained in Section 21.4, Scala&#8217;s Predef class offers an implicit conversion that lets you writekey &#8594; value as an alternate syntax for the pair (key, value). Therefore, Map("x" &#8594; 24, "y" &#8594; 25, "z" &#8594; 26) means exactly the same as Map"x", but reads better.</p></div>
<div class="paragraph"><p>The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets. Mutable maps additionally support the operations shown in Table 24.8. Map operations fall into the following categories:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Lookups</strong> apply, get, getOrElse, contains, and isDefinedAt. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Value</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>The operation "m get key" tests whether the map contains an association for the given key. If so, it returns the associated value in a Some. If no key is defined in the map, get returns None. Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option. If the key is not defined in the map, an exception is raised.</p></div>
<div class="ulist"><ul>
<li>
<p>
Additions and updates <code>, +</code>, and updated, which let you add new bindings to a map or change existing bindings.
</p>
</li>
<li>
<p>
Removals - and --, which remove bindings from a map.
</p>
</li>
<li>
<p>
Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map&#8217;s keys and values separately in various forms.
</p>
</li>
<li>
<p>
Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Пошук:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms get</p></td>
<td align="left" valign="top"><p class="table">Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>, як опція, або <code>None</code>, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms(k)</p></td>
<td align="left" valign="top"><p class="table">(або, розписане, <code>ms apply k</code>) Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>, або закидає виключення, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms getOrElse (k, d)</p></td>
<td align="left" valign="top"><p class="table">Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>,або значення по замовчанню <code>d</code>, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>ms</code> містить відображення для ключа <code>k</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms isDefinedAt</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>contains</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання та оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms + (k &#8594; v)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code> так само, як і <code>gk -&gt; v</code> ключа <code>k</code> на значення <code>v</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms + (k &#8594; v, l &#8594; w)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code>, разом з наданими парами ключ/значення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms ++ kvs</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code> так само, як і пари ключ/значення з <code>kvs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms updated (k, v)</p></td>
<td align="left" valign="top"><p class="table">Таке саме, що і <code>ms + (k -&gt; v)</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення з <code>ms</code>, за винятком любих відображень для ключа <code>k</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms - (k, l, m)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code>, за винятком всіх відображень з наданими ключамі</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms&#8201;&#8212;&#8201;ks</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення з <code>ms</code>, за винятком любих відображень з ключами в <code>ks</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Субколекції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keys</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне, що містить любий ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keySet</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить кожний ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keysIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожний ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.values</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне, що містить кожне значення, асоційоване з ключем в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.valuesIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожне значення, асоційоване з ключем в <code>ms</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms filterKeys</p></td>
<td align="left" valign="top"><p class="table">Перегляд мапи, що містить тільки ті відображення, в яких ключ відповідає предикату <code>p</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms mapValues</p></td>
<td align="left" valign="top"><p class="table">Перегляд мапи, отриманий від застосування функції <code>f</code> до кожного значення, асоційованого з ключем в <code>ms</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання та оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms(k) =</p></td>
<td align="left" valign="top"><div class="verse">(або, розписано, <code>ms.update(k, v)</code>) Додає відображення ключа <code>k</code> на значення <code>v</code> до мапи <code>ms</code> як побічний ефект, переписуючи любі попередні відображення <code>k</code></div></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms += (k &#8594; v)</p></td>
<td align="left" valign="top"><p class="table">Додає відображення ключа <code>k</code> на значення <code>v</code> до мапи <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms += (k &#8594; v, l &#8594; w)</p></td>
<td align="left" valign="top"><p class="table">Додає надані відображення до <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms ++= kvs</p></td>
<td align="left" valign="top"><p class="table">Додає всі відображення в <code>kvs</code> до <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms put (k, v)</p></td>
<td align="left" valign="top"><p class="table">Додає відображення ключа <code>k</code> на значення <code>v</code> до <code>ms</code> та повертає любе значення, асоційоване до цього з <code>k</code>, як опцію</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms getOrElseUpdate (k, d)</p></td>
<td align="left" valign="top"><p class="table">Якщо ключ <code>k</code> визначений в мапі <code>ms</code>, повертає його асоційоване значення. Інакше оновлює <code>ms</code> відображенням <code>k -&gt; d</code> та повертає <code>d</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє відображення ключа <code>k</code> з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -= (k, l, m)</p></td>
<td align="left" valign="top"><p class="table">Видаляє відображення наданних ключів з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms --= ks</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі ключі в <code>ks</code> з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє любі відображення ключа <code>k</code> з <code>ms</code> та повертає любе значення, до цього асоційоване з <code>k</code>, як опцію</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms retain</p></td>
<td align="left" valign="top"><p class="table">Зберігає тільки ті відображення в <code>ms</code>, ключ яких задовільняє предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі відображення з <code>ms</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення та клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms transform</p></td>
<td align="left" valign="top"><p class="table">Перетворює всі асоційовані значення в мапі <code>ms</code> функцією <code>f</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.clone</p></td>
<td align="left" valign="top"><p class="table">Повертає нову змінну мапу з тими самими відображеннями, що і <code>ms</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Операції додавання та видалення для мап повторюють такі самі для множин. Як і для множин, змінні мапи також підтримують неруйнівні операції додавання <code>+</code>, <code>-</code> та <code>updated</code>, але вони використовуються менш часто, оскільки вони включають копіювання змінної мапи. Замість цього, змінна мапа <code>m</code> звичайно оновлюється "на місці", використовуючи два варіанти, <code>m(key) = value</code> або <code>m += (key -&gt; value)</code>. Також є варіант <code>m put (key, value)</code>, що повертає значення <code>Option</code>, що складається зі значення, до того асоційованого з ключем, або <code>None</code>, якщо ключ не існував в мапі до цього.</p></div>
<div class="paragraph"><p>Метод <code>getOrElseUpdate</code> корисний для доступу до мап, що діють як кеші. Скажімо, ви маєте коштовне обчислення, що перемикається викликом функції <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;taking my time.&quot;</span><span class="o">);</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">reverse</span> <span class="o">}</span>
<span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Далі уявімо, що <code>f</code> не має побічних ефектів так що повторний виклик з тими ж аргументами буде завжди давати той самий результат. В такому випадку ви можете зберігти час, зберігаючи попередньо обчислені прив'язки аргументів та результати <code>f</code> в мапі та обчислювати результат <code>f</code>, якщо результат від аргументів ще не знаходиться там. Ви можете сказати, що мапа є кешем для обчислення функції <code>f</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">cache</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви можете створити більш ефективну кешовану версію фукнції <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="n">cachedF</span><span class="k">:</span> <span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cachedF</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">taking</span> <span class="n">my</span> <span class="n">time</span><span class="o">.</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cba</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cachedF</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cba</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що другий аргумент <code>getOrElseUpdate</code> є "за ім'ям" так що обчислення <code>f("abc")</code> вище виконується тільки якщо <code>getOrElseUpdate</code> потрубує значення свого другого аргументу, що саме коли перший аргумент не знайдений в кеш мапі. Ви також можете реалізувати <code>cachedF</code> напряму, використовуючи базові операції з мапами, але щоб зробити це знадобиться більше кода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span> <span class="n">get</span> <span class="n">arg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
    <span class="n">cache</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="k">=</span> <span class="n">result</span>
    <span class="n">result</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_8____">24.8 Суцільні класи незмінних колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить багато класів суцільних незмінних колекцій, з яких ви можете вибрати. Вони відрізняються в трейтах, які вони реалізують (мапи, множини, послідовності), чи можуть вони бути нескінченими та швидкістю різних операцій. Ми почнемо з огляду найбільш загальних типів незмінних колекцій.</p></div>
<div class="sect2">
<h3 id="__2">Списки</h3>
<div class="paragraph"><p>Списки є скінчені незмінні послідовності. Вони провадять доступ за сталий час до свого першого елементу так само, як і до залишку списку та вони мають операцію сталого часу <code>cons</code> для додавання нового елемента напочатку списку. Багато інших операцій займають лінійний час. Дівіться Глави 16 та 22 для розширеної дискусії щодо списків.</p></div>
</div>
<div class="sect2">
<h3 id="__3">Потоки</h3>
<div class="paragraph"><p>Потік подібний до списків, за тим винятком, що його елементи обчислюються ліниво. Через це потік може бути безкінечно довгий. Тільки елементи, що запитані, будуть обчислені. В іншому потоки мають ті самі характеристики продуктивності, що і списки.</p></div>
<div class="paragraph"><p>В той час, як списки будуються за допомогою оператора <code>::</code>, потоки будуються за допомогою подібно виглядаючого <code>#::</code>. Ось простий приклад потоку, що містить цілі <code>1</code>, <code>2</code> та <code>3</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mi">2</span> <span class="o">#::</span> <span class="mi">3</span> <span class="o">#::</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">empty</span>
<span class="n">str</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">?)</span>
</pre></div></div></div>
<div class="paragraph"><p>Голова цього потоку є <code>1</code> та хвіст має <code>2</code> та <code>3</code>. Однак хвіст тут не друкується, оскільки він все ще не обчислений! Потоки мають обчислюватись ліниво та метод <code>toString</code> для потоку досить уважний, щоб не змушувати до додаткового обчислення.</p></div>
<div class="paragraph"><p>Нижче більш складний приклад. Він обчислює потік, що містить послідовність Фібоначчі, починаючи з наданих двох чисел. Послідовність Фібоначчі - це коли кожний елемент є сумою двох попередніх в послідовності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">a</span> <span class="o">#::</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
<span class="n">fibFrom</span><span class="k">:</span> <span class="o">(</span><span class="kt">a:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">b:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція оманливо проста. Перший елемент послідовності, вочевидь, <code>a</code> та залишок послідовності є послідовність Фібоначчі, починаючи з <code>b</code>, за яким іде <code>a + b</code>. Хитра частина є обчислення цієї послідовності без нескінченої рекурсії. Якщо функція використовує <code>::</code> замість <code>#::</code>, тоді кожний виклик до функції буде спричиняти інший виклик таким чином спричиняючи нескінчену рекурсію. Однак оскільки вона використовує <code>#::</code>, права частина не обчислюється, доки вона не стане потрібною.</p></div>
<div class="paragraph"><p>Ось декілька перших елементів послідовності Фібоначчі, починаючи з двох елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fibs</span> <span class="k">=</span> <span class="n">fibFrom</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">fibs</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__4">Вектори</h3>
<div class="paragraph"><p>Списки дуже ефективні, коли алгоритм обробляє їх дбайливо, обробляючи тільки їх голови. Досутп, додавання та видалення тільки до голови списку забирає тільки сталий час, тоді як доступ або модифікація елементів в списку пізніше бере час лінійно відносно глибини списку.</p></div>
<div class="paragraph"><p>Вектори є типом колекцій, що дають ефективний доступ до елементів після голови. Доступ до любого елементу вектора займає тільки "ефективно сталий час", як визначено нижче. Це більша константа, ніж для доступу до голови списка, або для читання елементу масиву, але, тим не менше, це константа. Як результат, алгоритми, що використовують вектори, не мають пильнувати щодо доступу тільки до голови послідовності. Вони можуть отримувати доступ та модифікувати елементи в довільних місцях, і таким чином, вони можуть бути значно зручніші до написання.</p></div>
<div class="paragraph"><p>Вектори будуються та модифікуються так само, як інші послідовності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>
<span class="n">vec</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec2</span> <span class="k">=</span> <span class="n">vec</span> <span class="o">:+</span> <span class="mi">1</span> <span class="o">:+</span> <span class="mi">2</span>
<span class="n">vec2</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec3</span> <span class="k">=</span> <span class="mi">100</span> <span class="o">+:</span> <span class="n">vec2</span>
<span class="n">vec3</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec3</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div></div></div>
<div class="paragraph"><p>Вектори представлені як широкі та мілкі дерева. Кожний вузол дерева містить до 32 елементів вектора, або містить до 32 інших вузлів дерева. Вектори до 32 елементів можуть бути представлені одним вузлом. Вектори до 32 * 32 = 1024 елементів можуть бути представлені з одним перенаправленям. Два стрибка від кореня дерева до фінального вузла елементу достатні для векторів до 2<sup>15</sup> елементів, три стрибка для векторів 2<sup>20</sup>, чотири стрибка для векторів з 2<sup>25</sup> елементами, і п'ять стрибкив для векторів до 2<sup>30</sup> елементів. Так що для всіх векторів пристойного розміру вибір елементів включає до п'яти виборок примітивного масиву. Це те, що ми мали на увазі, коли писали, що доступ до елементу має "ефективно сталий час".</p></div>
<div class="paragraph"><p>Вектори незмінні так що ви не зможете змінити елемент вектора на місці. Однак, з методом <code>updated</code> ви можете створити новий вектор, що відрізняється від наданого вектора тільки одним елементом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">vec</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="n">updated</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як показує останній рядок вище, виклик до <code>updated</code> не має ефекту на оригінальний вектор <code>vec</code>. Як і вибір, оновлення функціонального вектора також має "ефективно сталий час". Оновлення вектора всередині вектора може бути зроблене через копіювання вузла, що містить елемент, і кожного вузла, що вказує на нього, починаючи від кореня дерева. Це означає, що функціональне оновлення створює від одного до п'яти вузлів, кожний містить до 32 елементів або субдерев. Це, звичайно, більш коштовно, ніж оновлення на місці в змінному масиві, але все ще набагато дешевше, ніж копіювання цілого вектора.</p></div>
<div class="paragraph"><p>Оскільки вектори влучають в гарний баланс між швидким довільними функціональними вибірками та швидкими довільними функціональними оновленнями, вони наразі є реалізацією по замовченню для незмінних індексованих послідовностей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">scala.collection.immutable.IndexedSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="nc">Immutable</span> <span class="n">stacks</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___3">Незмінні стеки</h3>
<div class="paragraph"><p>Якщо вам треба послідовність останній-увійшов-перший-вийшов, ви можете використовувати <code>Stack</code>. Ви заштовхуєте елемент в стек за допомогою <code>push</code>, виштовуєте за допомогою <code>pop</code> та вибираєте зверху без видалення за допомогою <code>top</code>. Всі ці операції займають сталий час.</p></div>
<div class="paragraph"><p>Ось деякі прості операції, що виконуються на стеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">.</span><span class="n">empty</span>
<span class="n">stack</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hasOne</span> <span class="k">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">hasOne</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">top</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">pop</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Незмінні стеки використовуються рідко в Scala програмах, оскільки їх функціональність повторює списки: <code>push</code> на незмінному стеку є те саме, що <code>::</code> на списку та <code>pop</code> на стеку те саме, що <code>tail</code> на списку.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Незмінні черги</h3>
<div class="paragraph"><p>Черга така сама як стек, за виключенням що вона перший-війшов-перший-вийшов, ніж останній-війшов-перший-вийшов. Спрощена реалізація незмінних черг дискутувалась в Главі 19. Ось як ви можете створити порожню незмінну чергу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
<span class="n">empty</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додати елемент до незмінної черги за допомогою <code>enqueue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">has1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">has1</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб додати декілька елементів до черги, викличте <code>enqueue</code> з колекцією в якості аргумента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">has123</span> <span class="k">=</span> <span class="n">has1</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">has123</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
<span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб видалити елемент з голови черги, використовуйте <code>dequeue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">has23</span><span class="o">)</span> <span class="k">=</span> <span class="n">has123</span><span class="o">.</span><span class="n">dequeue</span>
<span class="n">element</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">has23</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>dequeue</code> повертає пару, що складається з видаленого елементу та залишку черги.</p></div>
</div>
<div class="sect2">
<h3 id="__5">Диапазони</h3>
<div class="paragraph"><p>Диапазон є впорядкованою послідовністю цілих, що відстоять нарівно один від одного. Наприклад, <code>1, 2, 3</code> є диапазон, як і <code>5, 8, 11, 14</code>. Щоб створити диапазон в Scala, використовуйте попередньо визначені методи <code>to</code> та <code>by</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range.Inclusive</span>
  <span class="k">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="n">to</span> <span class="mi">14</span> <span class="n">by</span> <span class="mi">3</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте створити диапазон, який виключає свій верхній ліміт, використовуйте зручний метод <code>until</code> замість <code>to</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Диапазони представлені в просторі констант, оскільки вони можуть бути визначені через всього три числа: початок, кінець та значення кроку. Завдяки цій репрезентації, більшість операцій з диапазонами екстремально швидкі.</p></div>
</div>
<div class="sect2">
<h3 id="___5">Хеш дерева</h3>
<div class="paragraph"><p>Хеш дерева (<em>tries</em>, або <em>тріз</em>),<span class="footnote"><br />["Trie" походить від слова "retrieval" та вимовляються як <em>tree</em> або <em>try</em>.]<br /></span> є стандартним шляхом для ефективної реалізації незмінних масивів та мап. Їх репрезентація подібна до векторів в тому, що вони також дерева, де кожний вузол має 32 елементи або 32 субдерева, але вибірка робиться на основі хеш кода. Наприклад, щоб знайти наданий ключ, ви використовуєте молодші п'ять біт хеш коду від ключа, щоб обрати перше піддерево, наступні п'ять біт для іншого субдерева, і так далі. Вибірка зупиняється, як тільки всі елементи, що містяться в вузлі, мають хеш коди, які відрізняються один від одного в бітах, що вже вибрані. Таким чином, не всі біти хеш коду обов'язково використовуються.</p></div>
<div class="paragraph"><p>Хеш <em>тріз</em> поцілюють добрий баланс між достатньо швидкими пошуками та досить ефективними функціональними вставками (<code>+</code>) та видаленнями (<code>-</code>). Ось чому вони служать основою для реалізації по замовчанню для незмінних мап та множин Scala. Фактично, Scala має подальшу оптимізацію для незмінних множин та мап, що мають меньше ніж п'ять елементів. Множини та мапи від одного до чотирьох елементів зберігаються як один об'єкт, що містить самі елементи (або пари ключ/значення в випадку мап) як поля. Порожня незмінна множина та порожня незмінна мапа є в кожному випадку об'єктом синглтона  — немає потреби дублювати сховище для них, оскільки порожня множина та порожня мапа будуть завжди залишатись порожніми.</p></div>
</div>
<div class="sect2">
<h3 id="___">Червоне-чорне дерева</h3>
<div class="paragraph"><p>Дерева червоне-чорне є формою збалансованих дерев, коли деякі вузли відмічені як "червоні" та інші "чорні". Як любі збалансовані двійникові дерева, операції на них надійно завершуються за час, логірифмічний до розміру дерева.</p></div>
<div class="paragraph"><p>Scala провадить реалізації множин та мап, що внутрішньо використовують красне-чорне. Ви отримуєте доступ до них під іменами <code>TreeSet</code> та <code>TreeMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">set</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Дерева червоне-чорне є також стандартною реалізацією <code>SortedSet</code> в Scala, оскільки вони провадять ефективний ітератор, що повертає всі елементи множини у впорядкованому вигляді.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Незмінні бітові множини</h3>
<div class="paragraph"><p>Бітова множина представляє колекцію малих цілих, як бітів більшого цілого. Наприклад, бітова множина, що містить 3, 2 та 0, буде представлене як ціле <code>1101</code> в бінарній системі, що є <code>13</code> десятичними.</p></div>
<div class="paragraph"><p>Внутрішньо бітові множини використовують масив з 64-бітних <code>Long</code>. Перший <code>Long</code> в масиві є для цілих від 0 до 63, другий для від 64 до 127, і так далі. Таким чином, бітові множини дуже компактні, доки найдовше ціле в множині меньше ніж декілька сотен, або десь так.</p></div>
<div class="paragraph"><p>Операції на бітових наборах дуже швидкі. Перевірка на включення займає сталий час. Додавання елемента до множини пропорційна до числа <code>Long</code> в масиві бітової множини, що типово мале число. Ось деякі прості приклади використання бітових множин:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">moreBits</span> <span class="k">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span>
<span class="n">moreBits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">moreBits</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">moreBits</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___6">Спискові мапи</h3>
<div class="paragraph"><p>Спискова мапа представляє мапу як пов'язаний список пар ключ-значення. Загалом, операції на спискових мапах мають ітерувати по цілому списку. Таким чином, операції на списковій мапі займають час лінійно до розміру мапи. Фактично, існує невелике застосування списковим мапам в Scala, оскільки стандартні незмінні мапи майже завжди швидші. Одна можлива різниця є, коли якщо мапа з якихось причин сконструйована в такий спосіб, що перші елементи обираються значно більш часто, ніж інші елементи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">ListMap</span><span class="o">(</span>
<span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.immutable.ListMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span>
<span class="o">-&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">two</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;two&quot;</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_9____">24.9 Суцільні класи змінних колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили найбільш загально використовувані класи незмінних колекцій, що провадить Scala в своїй стандартній бібліотеці, поглянемо на класи змінних колекцій.</p></div>
<div class="sect2">
<h3 id="___7">Буфери масивів</h3>
<div class="paragraph"><p>Ви вже бачили буфери масивів в Розділі 17.1. Буфер масиву зберігає масив та розмір. Більшість операцій на буфері масивів має ту саму швидкість, що і для масивів, оскільки операції просто отримують доступ та модифікують підлеглий масив. Додатково, буфери масивів можуть ефективно додавати дані в кінець. Додавання елементу до буферу масиву триває амортизовано сталий час. Таким чином, буфери масивів корисні для ефективної побудови великих колекцій, коли нові елементи завжди додаються в кінець. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res38</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___8">Буфери списків</h3>
<div class="paragraph"><p>Ви вже бачили буфери списків в Розділі 17.1. Буфери списків подібні до буферів масивів, за виключенням того, що вони внутрішньо використовують зв'язані списки замість масивів. Якщо ви плануєте конвертувати буфер на список, коли він буде побудований, використовуйте буфер списків замість буферу масивів. Ось приклад:<span class="footnote"><br />[<code>buf.type</code>, що з'являється в відповідях інтерпретатора в цьому та деяких інших прикладах цього розділу є типом синглтона. Як буде пояснено в Розділі 29.6, <code>buf.type</code> означає, що змінна зберіагє в точності об'єкт, на який посилається <code>buf</code>.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___9">Побудовники рядків</h3>
<div class="paragraph"><p>Так само, як буфери масивів корисні для побудови масивів та буфери списків корисні для побудови списків, побудовник рядків корисний для побудови рядків. Побудовники рядків використовуються настільки загально, що вони завжди імпортуються в простір імен по замовчанню. Створюйте їх просто як <code>new StringBuilder</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="sc">&#39;a&#39;</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">++=</span> <span class="s">&quot;bcdef&quot;</span>
<span class="n">res45</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="n">abcdef</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toString</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcdef</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Зв'язані списки</h3>
<div class="paragraph"><p>Зв'язані списки є змінні послідовності, що складаються з вузлів, що пов'язані вказівниками <code>next</code>. В більшості мов <code>null</code> може бути взятий як порожній зв'язаний список. Це не робить для Scala колекцій, оскільки навіть порожні послідовності мають підтримувати всі методи послідовностей. Зокрема, <code>LinkedList.empty.isEmpty</code> повинно повертати <code>true</code> та не закидати <code>NullPointerException</code>. Порожні зв'язані списки замість цього закодовані в особливий спосіб: їх поле <code>next</code> вказує назад до самого вузла.</p></div>
<div class="paragraph"><p>Як їх незмінні колеги, зв'язані списки краще обробляються послідовно. На додаток зв'язані списки спрощують вставку елемента або зв'язаного списку в інший зв'язаний список.</p></div>
</div>
<div class="sect2">
<h3 id="____">Подвійно зв'язаний список</h3>
<div class="paragraph"><p><code>DoubleLinkedLists</code> подібні до однозв'язаних списків, описаних в попередньому підрозділі, але крім <code>next</code> вони мають інше змінне поле, <code>prev</code>, що вказує на елемент перед поточним вузлом. Головна перевага цього додаткового посилання в тому, що це робить видалення елементу дуже швидким.</p></div>
</div>
<div class="sect2">
<h3 id="___10">Змінні списки</h3>
<div class="paragraph"><p><code>MutableList</code> складається з одного зв'язаного списку, разом з вказівником, що посилається на термінальний порожній вузол цього списку. Це робить додавання до списку операцією сталого часу, оскільки уникається подорожування по списку в пошуку термінального вузла. <code>MutableList</code> наразі є стандартною реалізацією <code>mutable.LinearSeq</code> в Scala.</p></div>
</div>
<div class="sect2">
<h3 id="__6">Черги</h3>
<div class="paragraph"><p>Scala провадить змінні черги, на додаток до незмінних. Ви використовуєте змінні черги подібно до того, як використовуються незмінні, але замість <code>enqueue</code> ви використовуєте оператори <code>+=</code> та <code>++=</code> для додавання. Також на змінній черзі метод <code>dequeue</code> буде лише видаляти головний елемент з черги та повертати його. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">+=</span> <span class="s">&quot;a&quot;</span>
<span class="n">res47</span><span class="k">:</span> <span class="kt">queue.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">)</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">queue.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queueres49</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___11">Послідовності масивів</h3>
<div class="paragraph"><p>Послідовності масивів є змінні послідовності фіксованого розміру, що зберігають свої елементи всередині як <code>Array[AnyRef]</code>. Вони реалізовані в Scala як клас <code>ArraySeq</code>. Ви можете типово використовувати <code>ArraySeq</code>, якщо ви бажаєте масив заради його характеристик продуктивності, але ви також бажаєте створити загальні примірники послідовності, коли ви не знаєте тип елементів, і не маєте <code>ClassTag</code>, щоб запровадити під час виконання. Скоро ви дізнаєтесь про ці проблеми в Розділі 24.10.</p></div>
</div>
<div class="sect2">
<h3 id="__7">Стеки</h3>
<div class="paragraph"><p>Ви бачили незмінні стеки раніше. Також є змінна версія. Це робить точно так саме, як і незмінна версія, за винятком того, що зміни відбуваються на місці. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">stack</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">stack.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">stack.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">top</span>
<span class="n">res56</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res57</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res59</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____4">Стекі з масивів</h3>
<div class="paragraph"><p><code>ArrayStack</code> є альтернативною реалізацією змінного стеку, до базується на <code>Array</code>, що змінює розмір за потреби. Він провадить швидке індексування, і загалом трохи більше ефективний для більшості операцій, ніж звичайний змінний стек.</p></div>
</div>
<div class="sect2">
<h3 id="___12">Хеш таблиці</h3>
<div class="paragraph"><p>Хеш таблиця зберігає свої елементи в підлеглому масиві, покладаючи кожний елемент в позицію в масиві, що визначається хеш кодом цього елемента. Додавання елемента до хеш таблиці займає тільки сталий час, доки немає іншого елемента в масиві, що май той самий хеш код. Таким чином хеш таблиці дуже швидкі, доки об'єкти, що покладаються в них мають гарне розподілення хеш кодів. Як результат, по замовчанню типи змінної мапи та множини в Scala базуються на хеш таблицях.</p></div>
<div class="paragraph"><p>Хеш множини та мапи використовуються так само, як любі інші множини або мапи. Ось деякі прості приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;make a web site&quot;</span><span class="o">)</span>
<span class="n">res60</span><span class="k">:</span> <span class="kt">map.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;profit!&quot;</span><span class="o">)</span>
<span class="n">res61</span><span class="k">:</span> <span class="kt">map.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">profit</span><span class="o">!)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res62</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">contains</span> <span class="mi">2</span>
<span class="n">res63</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітерація по хеш таблиці не гарантовано виконується в деякому певному порядку. Ітерація просто проходить по підлеглому масиву,в якому б порядку це не траплялось. Щоб отримати гарантований порядок ітерації використовуйте зв'язану мапо або множину, замість звичайної. Зв'язана хеш мапа або множина така сама, як і звичайна мапа або множина, за тим винятком, що він таком влючає зв'язаний список елементів в тому порядку, як вони додавались. Ітерація по такій колекції відбувається завжди в тому порядку, в якому елементи були додані.</p></div>
</div>
<div class="sect2">
<h3 id="____5">Слабкі хеш мапи</h3>
<div class="paragraph"><p>Слабка хеш мапа є особливим різновидом хеш мапи, в якій збирач сміття не слідує посиланням від мапи до ключів, що зберігаються в ній. Це означає, що ключ та його асоційоване значення будуть зникати з мапи, якщо немає іншого посилання на ключ. Слабкі хеш мапи корисні для завдань таких як кешування, де ви бажаєте пере-використати результат коштовної функції, коли функція викликається знову на тому ж ключі. Якщо ключі та результати функції зберігаються в звичайній хеш мапі, мапа буде зростати без обмежень, і жодний ключ ніколи не стане сміттям. Використання слабкої хеш мапи уникає цієї проблеми. Як тільки об'єкт ключа стає недосяжний, його входження видаляється зі слабкої хеш мапи. Слабкі хеш мапи в Scala реалізовані як огортка підлеглої Java реалізації, <code>java.util.WeakHashMap</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___13">Конкурентні мапи</h3>
<div class="paragraph"><p>Конкурентні мапи можуть отримувати доступ з декількох потоків одночасно. На додаток до звичайних операцій з <code>Map</code>, вони провадять наступні атомарні операції:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">m putIfAbsent(k, v)</p></td>
<td align="left" valign="top"><p class="table">Додає прив'язку ключ/value <code>k -&gt; m</code>, за винятком коли <code>k</code> вже визначений в <code>m</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m remove (k, v)</p></td>
<td align="left" valign="top"><p class="table">Видаляє входження для <code>k</code>, якщо він наразі відображений на <code>v</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m replace (k, old, new)</p></td>
<td align="left" valign="top"><p class="table">Замінює значення, асоційоване з ключем <code>k</code> на <code>new</code>, якщо віе до цього був прив'язаний до <code>old</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m replace (k, v)</p></td>
<td align="left" valign="top"><p class="table">Замінює значення, асоційоване з ключом <code>k</code> до <code>v</code>,якщо він до цього був пов'язаний з деяким значенням</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p><code>ConcurrentMap</code> є трейтом в бібліотеці колекцій Scala. Наразі єдиною реалізацією є Java <code>java.util.concurrent.ConcurrentMap</code>, що може бути конвертований автоматично в мапу Scala, використовуючи стандартні перетворення колекцій Java/Scala, що будуть описані в Розділі 24.17.</p></div>
</div>
<div class="sect2">
<h3 id="____6">Змінні бітові множини</h3>
<div class="paragraph"><p>Змінні бітові множини такі самі, як незмінні, за виключенням того, що вони можуть бути модифіковані на місці. Змінні бітові множини трохи більше ефективні при оновленні, ніж незмінні, оскільки вони не мають копіювати <code>Long</code>, що не були змінені. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.mutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res64</span><span class="k">:</span> <span class="kt">bits.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="n">res65</span><span class="k">:</span> <span class="kt">bits.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span>
<span class="n">res66</span><span class="k">:</span> <span class="kt">scala.collection.mutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_10_">24.10 Масиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Масиви є особливим різновидом колекцій в Scala. З одного боку, масиви Scala відповідають один-до-одного до масивів Java. Тобто Scala масив <code>Array[Int]</code> представлений як Java <code>int[]</code>, <code>Array[Double]</code> представлений як Java <code>double[]</code> та <code>Array[String]</code> представлений як Java <code>String[]</code>. Але в той самий час, Scala масиви пропонують значно більше, ніж Java аналоги. Перше, масиви Scala можуть бути дженеріками. Тобто, ви можете мати <code>Array[T]</code>, де <code>T</code> є параметром типу або абстрактном типом. Друге, масиви Scala сумісні зі Scala послідовностями — ви можете передати <code>Array[T]</code>, де потрібне <code>Seq[T]</code>. Нарешті, масиви Scala також підтримують всі операції послідовностей. Ось приклад цього в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">a1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span> <span class="k">=</span> <span class="n">a1</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a3</span> <span class="k">=</span> <span class="n">a2</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">a3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">a3</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги, що Scala масиви представлені як масиви Java, як ці додаткові можливості підтримуються в Scala?</p></div>
<div class="paragraph"><p>Відповідь полягає в систематичному використанні неявних перетворень. Масив не може претендувати на звання послідовності, оскільки тип даних, що представляє природні масиви, не є субтипом <code>Seq</code>. Замість цього, кожного разу, коли масив використовується як Seq, він неявно огортається в субклас <code>Seq</code>. Ім'я цього субкласу - <code>scala.collection.mutable.WrappedArray</code>. Тут ви бачите його в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="n">eq</span> <span class="n">a4</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця взаємодія демонструє, що масиви сумісні з послідовностями, оскільки є неявне перетворення від <code>Array</code> до <code>WrappedArray</code>. Ідучи іншим шляхом, від <code>WrappedArray</code> до <code>Array</code>, ви можете використовувати метод <code>toArray</code>, визначений в <code>Traversable</code>. Останній рядок інтерпретатора вище показує, що огортання та потім розгортання за допомогою <code>toArray</code> дає вам той самий масив, з якого ви починали.</p></div>
<div class="paragraph"><p>Існує також інше неявне перетворення, що застосовується до масивів. Це перетворення просто "додає" всі методи послідовностей до масивів, але не перетворює самий масив на послідовність. "Додавання" означає, що масив огортається в інший об'єкт <code>ArrayOps</code>, що підтримує всі методи послідовностей. Типово цей об'єкт <code>ArrayOps</code> коротко-тривалий; він зазвичай буде недоступний після виклику метода послідовності та його сховище буде утилізоване. Сучасні VM часто уникають створення цього об'єкту повністю.</p></div>
<div class="paragraph"><p>Різниця між двома неявними перетвореннями масивів демонструється нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">seq</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ops</span><span class="k">:</span> <span class="kt">collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">ops</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">I</span><span class="o">(</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">)</span>

<span class="kt">scala&gt;</span> <span class="kt">ops.reverse</span>
<span class="kt">res3:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Array</span><span class="o">(</span><span class="err">3</span>, <span class="err">2</span>, <span class="err">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що виклик <code>reverse</code> на <code>seq</code>, що є <code>WrappedArray</code>, знову буде давати <code>WrappedArray</code>. Це логічно, оскільки огорнуті масиви є <code>Seqs</code>, і виклик <code>reverse</code> на любому <code>Seq</code> буде знову давати <code>Seq</code>. З іншого боку, виклик <code>reverse</code> на <code>ops</code> значенні класу <code>ArrayOps</code> дасть в результаті <code>Array</code>, не <code>Seq</code>. Приклад <code>ArrayOps</code> вище був досить штучний, призначений тільки показати різницю з <code>WrappedArray</code>. Звичайно ви ніколи не визначаєте значення класу <code>ArrayOps</code>. Ви просто викликаєте метод <code>Seq</code> на масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a1</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Об'єкт <code>ArrayOps</code> вставляється автоматично через неявне перетворення. Так що рядок вище еквівалентний до наступного рядка, де <code>intArrayOps</code> було перетворенням, що було неявно вставленим до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">intArrayOps</span><span class="o">(</span><span class="n">a1</span><span class="o">).</span><span class="n">reverse</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це підіймає питання, як компілятор обирає <code>intArrayOps</code> перед іншим неявним перетворенням до <code>WrappedArray</code> в рядку вище. Кінець кінцем, обоє перетворення відображають масив на тип, що підтримує метод <code>reverse</code>, де це те, що вказане на вході. Відповідь на це питання в тому, що ці два неявні перетворення мають преоритети. Перетворення <code>ArrayOps</code> має вищий преоритет, ніж перетворення <code>WrappedArray</code>. Перший визначений в об'єкті <code>Predef</code>, тоді як другий визначений в класі <code>scala.LowPriorityImplicits</code>, що є суперкласом <code>Predef</code>. Неявні в субкласах та субоб'єктах мають перевагу над неявними в базових класах. Так що коли можуть застосовуватись обоє перетворень, буде обрана версія з <code>Predef</code>. Дуже подібна схема, що була описана в Розділі 21.7, робить для рядків.</p></div>
<div class="paragraph"><p>Так що зараз ви знаєте, як масиви можуть бути сумісні з послідовностями та як вони можуть підтримувати всі операції послідовностей. Як щодо дженерікив? В Java ви не можете записати <code>T[]</code>, де <code>T</code> є параметром типу. Тоді як представлені <code>Array[T]</code> в Scala? Фактично, дженерік масив як <code>Array[T]</code> може бути під час виконання любим з вісьми масивів примітирних типів Java: <code>byte[]</code>, <code>short[]</code>, <code>char[]</code>, <code>int[]</code>, <code>long[]</code>, <code>float[]</code>, <code>double[]</code>, <code>boolean[]</code>, або він може бути масивом об'єктів. Єдиний загальний рантайм тип, що обіймає всі ці типи, є <code>AnyRef</code> (або, що еквівалентно, <code>java.lang.Object</code>) так що це той тип, на який компілятор Scala відображує <code>Array[T]</code>. Під час виконання, коли виконується доступ або модифікація елементу масиву типу <code>Array[T]</code>, відбувається послідовність перевірок типу, що визначає справжній тип масиву, за яким слідує коректна операція масиву на Java масиві. Ці перевірки типів дещо уповільнюють операції з масивами. Ви можете очікувати, що доступ до дженерік масивів будуть від трьох до чотирьох разів повільніші, ніж доступ до примітивних або об'єктних масивів. Це означає, що якщо вам треба максимальна продуктивність, вам треба обирати суцільні масиви замість дженерікив.</p></div>
<div class="paragraph"><p>Однак представити дженерік масиви не є достатнім також має бути спосіб створювати дженерік масиви. Існує навіть складніша проблема, що потребує трохи більше допомоги з вашого боку. Щоб пролілюструвати проблему, розглянемо наступну спробу написати дженерік метод, що створює масив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це невірно!</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>evenElems</code> повертає новий масив, що складається з усіх елементів аргументу-вектора <code>xs</code>, що стоять в векторі на парних позиціях. Перший рядок тіла <code>evenElems</code> створює результуючий масив, що має той самий тип елементів, що і аргумент. Так що, в залежності від дійсного параметру типу <code>T</code>, це могло бути <code>Array[Int]</code>, або <code>Array[Boolean]</code>, або масив деякого іншого примітивного типу Java, або масив деякого типу посилання. Але ці типи мають різні репрезентації під час виконання, то як рантайм Scala збирається обрати коректний тип? Фактично, він не може зробити це базуючись на наданій йому інформації, оскільки справжній тип, що відповідає параметру типу <code>T</code>, затирається під час виконання. Ось чому ви отримаєте наступне повідомлення про помилку, якщо ви намагатиметесь скомпілювати код вище:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">error</span><span class="k">:</span> <span class="kt">cannot</span> <span class="kt">find</span> <span class="kt">class</span> <span class="kt">tag</span> <span class="kt">for</span> <span class="kt">element</span> <span class="k">type</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">arr</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут потрібне, це ваша допомога компілятору шляхом провадження підказки рантайму, якій справжній тип параметру <code>evenElems</code>. Ця підказка часу виконання приймає форму класового тегу <code>typescala.reflect.ClassTag</code>. Класовий тег описує затертий тип даного типу, що є всею інформацією, потрібною для конструювання масиву цього типу.</p></div>
<div class="paragraph"><p>В багатьох випадках компілятор може генерувати класовий тег сам по собі. Це випадок для суцільних типів, як <code>Int</code> або <code>String</code>. Це також випадок для певних дженерік типів, як <code>List[T]</code>, де відомо досить інформації, щоб зпрогнозувати затертий тип; в цьому випадку затертий тип буде <code>List</code>.</p></div>
<div class="paragraph"><p>Для повністю дженерік класів звичайна ідиома є передавати класовий тег використовуючи обмеження контексту, як обговорювалось в Розділі 21.6. Ось як визначення вище може бути полагоджене, через використання обмеження контексту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це робить</span>
<span class="k">import</span> <span class="nn">scala.reflect.ClassTag</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому новому визначенні, коли створюється <code>Array[T]</code>, компілятор шукає класовий тег для параметру типу <code>T</code>, тобто, він буде шукати неявне значення типу <code>ClassTag[T]</code>. Якщо таке значення буде знайдене, класовий тег використовується для конструювання правильного типу масиву. Інакше ви побачите повідомлення про помилку, яке ви бачили до цього.</p></div>
<div class="paragraph"><p>Ось інтеракція з інтерпретатором, що використовує метод <code>evenElems</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="s">&quot;this&quot;</span><span class="o">,</span> <span class="s">&quot;is&quot;</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;test&quot;</span><span class="o">,</span> <span class="s">&quot;run&quot;</span><span class="o">))</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">run</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В обох випадках компілятор Scala компілятор автоматично конструює класовий тег для типу елементів (перший - <code>Int</code>, другий - <code>String</code>) та передає його до неявного параметру метода <code>evenElems</code>. Компілятор може зробити це для суцільних типів, але ні, якщо аргумент самий є іншим параметром типу без свого класового тегу. Наприклад, наступне схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">ClassTag</span> <span class="kt">available</span> <span class="kt">for</span> <span class="kt">U</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
                                        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що відбувається тут, це те, що <code>evenElems</code> вимагає класовий тег для параметру типа <code>U</code>, але жодний не був знайдений. Рішення в цьому випадку, звичайно, що треба вимагати інший класовий тег для <code>U</code>. Так що наступне робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="n">wrap</span><span class="k">:</span> <span class="err">[</span><span class="kt">U</span><span class="err">]</span><span class="o">(</span><span class="kt">xs:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">evidence$1</span><span class="k">:</span>
<span class="kt">scala.reflect.ClassTag</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="nc">Array</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад також показує, що контекст, зв'язаний в визначенні <code>U</code>, є просто скороченням для неявного параметра, що тут має назву <code>evidence$1</code> типу <code>ClassTag[U]</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_11_">24.11 Рядки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як і масиви, рядки напряму не є послідовностями, але вони можуть бути сконвертовані до них, і вони також підтримують всі операції послідовностей. Ось деякі приклади операцій, що ви можете викликати для радків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">str</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">hello</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">olleh</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toUpper</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">HELLO</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span> <span class="n">drop</span> <span class="mi">3</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span> <span class="n">slice</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">ell</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">str</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedString</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці операції підтримуються двома неявними перетвореннями, що пояснюються в Розділі 21.7. Перше, низько-преоритетне перетворення відображує <code>String</code> до <code>WrappedString</code>, що є субкласом <code>immutable.IndexedSeq</code>. Це перетворення було застосоване в останньому рядку попереднього приклада, де рядок був перетворений на <code>Seq</code>. Інше, високо-преоритетне перетворення відображує рядок до об'єкту <code>StringOps</code>, що додає всі методи незмінних послідовностей до рядків. Це перетворення було неявно вставлене в виклики методів <code>reverse</code>, <code>map</code>, <code>drop</code> та <code>slice</code> в попередньому прикладі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_12__">24.12 Характеристики продуктивності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як показали попередні пояснення, різні типи колекцій мають різні характеристики продуктивності. Часто це головна причина для обирання однієї колекції, ніж іншої. Ви можете бачити характеристики продуктивності деяких загальних операцій на колекціях, підсумовані в двох таблицях, Таблиці 24.12 та Таблиці 24.12.</p></div>
<div class="sect2">
<h3 id="_____2">Характеристики продуктивності типів послідовностей</h3>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">head</p></td>
<td align="left" valign="top"><p class="table">tail</p></td>
<td align="left" valign="top"><p class="table">apply</p></td>
<td align="left" valign="top"><p class="table">update</p></td>
<td align="left" valign="top"><p class="table">prepend</p></td>
<td align="left" valign="top"><p class="table">append</p></td>
<td align="left" valign="top"><p class="table">insert</p></td>
</tr>
<tr>
<td colspan="8" align="left" valign="top"><p class="table">immutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">List</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stream</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Vector</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Queue</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Range</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td colspan="8" align="left" valign="top"><p class="table">mutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArrayBuffer</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ListBuffer</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">StringBuilder</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">MutableList</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Queue</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArraySeq</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArrayStack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Array</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="______">Характеристики продуктивності типів множин та мап</h3>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">lookup</p></td>
<td align="left" valign="top"><p class="table">add</p></td>
<td align="left" valign="top"><p class="table">remove</p></td>
<td align="left" valign="top"><p class="table">min</p></td>
</tr>
<tr>
<td colspan="5" align="left" valign="top"><p class="table">immutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">HashSet/HashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">TreeSet/TreeMap</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BitSet</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">eC.<span class="footnote"><br />[Assuming bits are densely packed.]<br /></span></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ListMap</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td colspan="5" align="left" valign="top"><p class="table">mutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">HashSet/HashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WeakHashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BitSet</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">eC^a</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Входження в ціх двох таблицях пояснюється наступним чином:</p></div>
<div class="paragraph"><p><strong>C</strong> Операція займає сталий час (швидка).</p></div>
<div class="paragraph"><p><strong>eC</strong> Операція ефективно займає сталий час, але це може залежати від деяких припущень таких, як максимальна довжина вектора, або розподілення хеш ключей.</p></div>
<div class="paragraph"><p><strong>aC</strong> Операція займає амортизований сталий час. Деякі виклики операції можуть зайняти довше, але якщо виконується багато операцій,в середньому операція триває сталий час.</p></div>
<div class="paragraph"><p><strong>Log</strong> Операція триває час, пропорційний до логарифму розміру колекції.</p></div>
<div class="paragraph"><p><strong>L</strong> Операція лінійна, триває час пропорційний до розміру колекції.</p></div>
<div class="paragraph"><p><strong>-</strong> Операція не підтримується.</p></div>
<div class="paragraph"><p>Таблиця 24.12 розглядає типи послідовностей, змінні та незмінні, для неступних операцій:</p></div>
<div class="paragraph"><p><strong>head</strong> Вибір першого елемента в послідовності.</p></div>
<div class="paragraph"><p><strong>tail</strong> Створення нової колекції, що складається з усіх елементів, крім першого.</p></div>
<div class="paragraph"><p><strong>apply</strong> Індексування.</p></div>
<div class="paragraph"><p><strong>update</strong> Функціональне оновлення (за допомогою <code>updated</code>) для незмінних послідовностей, оновлення з побічним ефектом (за допомогою <code>update</code>) для змінних послідовностей.</p></div>
<div class="paragraph"><p><strong>prepend</strong> Додавання елементу зпереду послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.</p></div>
<div class="paragraph"><p><strong>append</strong> Додавання елементу в кінець послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.</p></div>
<div class="paragraph"><p><strong>insert</strong> Вставка елементу в довільну позицію послідовності. Напряму це підтримується тільки для змінних послідовностей.</p></div>
<div class="paragraph"><p>Таблиця 24.12 розглядає змінні та незмінні множини та мапи стосовно наступних операцій:</p></div>
<div class="paragraph"><p><strong>lookup</strong> Перевірка, чи елемент знаходиться в множині або обирає значення, асоційоване з ключем.</p></div>
<div class="paragraph"><p><strong>add</strong> Додавання нового елементу до множини або новох мапи ключ/значення до мапи.</p></div>
<div class="paragraph"><p><strong>remove</strong> Видалення елементу з множини або ключа з мапи.</p></div>
<div class="paragraph"><p><strong>min</strong> Найменьший елемент в множині, або меньший ключ в мапі.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_13_">24.13 Еквівалентність</h2>
<div class="sectionbody">
<div class="paragraph"><p>Бібліотеки колекцій мають уніформний підхід до рівності та хешування. Перше, ідея в тому, щоб поділити колекції на множини, мапи та послідовності. Колекції в різних категоріях завжди нерівні. Наприклад, <code>Set(1, 2, 3)</code> нерівне до <code>List(1, 2, 3)</code>, навіть якщо вони містять ті самі елементи. З іншого боку, в тій самій категорії, колекції рівні, тільки, та тільки, якщо вони мають ті самі елементи (для послідовностей: ті ж елементи в тому ж порядку). Наприклад, <code>List(1, 2, 3) == Vector(1, 2, 3)</code>, та <code>HashSet(1, 2) == TreeSet(2, 1)</code>.</p></div>
<div class="paragraph"><p>Не має значення для перевірки рівності, чи колекція змінна, чи незмінна. Для змінної колекції рівність просто залежить від поточних елементів на час, коли виконується перевірка. Це означає, що змінні колекції можуть бути еквівалентні до різних колекцій в різний час, в залежності що було додано або видалене. Це потенційна пастка, коли змінна колекція використовується як ключ в хеш мапі. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="nc">HashMap</span><span class="o">(</span><span class="n">buf</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashMap</span><span class="o">[</span><span class="kt">scala.collection.</span>
<span class="kt">mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span><span class="mi">3</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">key</span> <span class="kt">not</span> <span class="kt">found:</span>
  <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі вибірка в останньому рядку скоріше всього схибить, оскільки хеш код масива <code>xs</code> зміниться в передостанньому рядку. Таким чином, пошук на основі хеш кода буде шукати в іншому місці, ніж той, в якому був збережений <code>xs</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_14_">24.14 Перегляди</h2>
<div class="sectionbody">
<div class="paragraph"><p>Колекції мають декілька методів, що конструюють нові колекції. Деякі приклади є <code>map</code>, <code>filter</code> та <code>++</code>. Ми називаємо такі методи трансформерами, оскільки вони приймають щонайменьше одну колекцію в якості свого об'єкта-отримувача, та продукують іншу колекцію в якості результата.</p></div>
<div class="paragraph"><p>Трансформери можуть бути реалізовані в два принципові способи: строгий та нестрогий (або лінивий). Строгий трансформер конструює нову колекцію з усіма своїми елементами. Нестрогий, або лінивий, трансформер конструює тільки проксі для результуючої колекції, та його елементи конструюються на вимогу.</p></div>
<div class="paragraph"><p>Як приклад нестрогого трансформера, розглянемо наступну реалізацію лінивої операції <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lazyMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">coll</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">map</span> <span class="n">f</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>lazyMap</code> конструює нове <code>Iterable</code> без крокування по всіх елементах наданої колекції <code>coll</code>. Надана функція <code>f</code> замість цього застосовується до елементів ітератора нової колекції, по мірі потреби.</p></div>
<div class="paragraph"><p>Scala колекції по замовчанню строгі в усіх своїх трансформерах, за винятком <code>Stream</code>, що реалізує всі свої методи-трансформери ліниво. Однак існує систематичний спосіб для перетворення кожної колекції в ліниву та навпаки, що базується на переглядах колекції. Перегляд є особливим різновидом колекції, що представляє деяку базову колекцію, але реалізує всі її трансформери ліниво.</p></div>
<div class="paragraph"><p>Щоб перейти від колекції до її перегляду, ви можете використовувати метод <code>view</code> на колекції. Якщо <code>xs</code> є деякою колекцією, тоді <code>xs.view</code> є та сама колекція, але всі трансформери якої реалізовані ліниво. Щоб перейти назад від перегляду до строгої колекції ви можете використати метод <code>force</code>. Як приклад, скажімо, ви маєте вектор з <code>Int</code>, на якому ви бажаєте виконати дві функції одна за другою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В останньому твердженні вираз <code>v map (_ + 1)</code> конструює новий вектор, що потім трансформується і третій вектор, через другий виклик до <code>map (_ * 2)</code>. В багатьох ситуаціях конструювання проміжного результату після першого виклику до <code>map</code> є трохи марнотратним. В псевдо прикладі буде скорішим зробити єдиний <code>map</code> з композицією двох функцій, <code>(_ + 1)</code> та <code>(_ * 2)</code>. Якщо ви маєте дві функції доступними в тому самому місці, ви можете зробити це вручну. Але досить часто послідовні трансформації структур даних виконуються в разних програмних модулях. Зплавлення ціх перетворень потім буде підривати модульність. Більш загальним шляхом уникнути проміжних результатів є перетворення вектора зпочатку на перегляд, застосування до перегляду всіх трансформацій, на нарешті примушення перегляду знову до вектора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">view</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)).</span><span class="n">force</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми зробимо цю послідовність операцій знову одну з одною:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vv</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">view</span>
<span class="n">vv</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">SeqView</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосування <code>v.view</code> дає вам <code>SeqView</code>, тобто ліниво обчислену <code>Seq</code>. Тип <code>SeqView</code> має два параметри типу. Перший, <code>Int</code>, показує тип елементів перегляду. Другий, <code>Vector[Int]</code>, показує вам тип конструктора, що ви отримаєте назад, коли будете примушувати перегляд.</p></div>
<div class="paragraph"><p>Застосування першого <code>map</code> до перегляду дасть таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vv</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Seq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">SeqViewM</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>Результатом <code>map</code> є значення, що друкує <code>SeqViewM(...)</code>. Це в основному огортка, що записує факт, що <code>map</code> з функцією <code>(_ + 1)</code> треба застосувати до вектора <code>v</code>. Він, однак, не застосовує цей <code>map</code>, доки перегляд не буде форсований. "M" після <code>SeqView</code> вказує на те, що перегляд екнкапсулює операцію <code>map</code>. Ініш літери вказують інші відкладені операції. Наприклад, "S" вказує на відкладену операцію <code>slice</code>, та "R" вказує на <code>reverse</code>. Тепер ми застосуємо другий <code>map</code> до останнього результату.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res13</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Seq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">SeqViewMM</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви отримали <code>SeqView</code>, що містить дві операції <code>map</code>, так що друкуються дві "M": <code>SeqViewMM(...)</code>. Нарешті, форсування останнього результату дає:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res14</span><span class="o">.</span><span class="n">force</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Обоє збережені функції застосовуються як частина виконання операції <code>force</code>, та конструюється новий вектор. Таким чином, жодні проміжні структури непотрібні.</p></div>
<div class="paragraph"><p>Одна деталь, яку треба зауважити, це те, що статичний тип фінального результату є <code>Seq</code>, а не <code>Vector</code>. Відстежуючи типи назад, ми бачимо, що як тільки був застосований перший відкладений <code>map</code>, результат має статичний метод <code>SeqViewM[Int, Seq[_]]</code>. Тобто, "знання" що перегляд був застосований до певного тип послідовності <code>Vector</code> було втрачене. Реалізація перегляду для любого окремого класу потребує трохи коду, так що бібліотеки колекцій Scala провадять перегляди в основному тільки для загальних типів колекцій,не для специфічних реалізацій.<span class="footnote"><br />[Виключенням для цього є масиви: застосування відкладених операцій на масивах буде знову давати результат зі статичним типом <code>Array</code>.]<br /></span></p></div>
<div class="paragraph"><p>Існує дві причини, чому ви можете вирішити використовувати перегляди. Перша це продуктивність. Ви бачили, що перемикання з колекції на перегляд можливо уникає створення проміжних колекцій. Ці збереження можуть бути досить важливі. Як інший приклад розглянемо проблему пошуку першого паліндрому в списку слів. Паліндром - це слово, що однаково читається в обох напрямках. Ось необхідні визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">def</span> <span class="n">findPalindrome</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">s</span> <span class="n">find</span> <span class="n">isPalindrome</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер уявімо, щоб ви маєте дуже довгу послідовність слів, та ви бажаєте знайти паліндром в першому мільйоні слів цієї послідовностіі. Чи ви можете повторно використати визначення <code>findPalindrome</code>? Звичайно, ви можете написати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це мило розділяє два аспекти отримання першого мільйона слів з послідовності, та пошук в ньому паліндрому. Але недолік в тому, що це завжди будує проміжну послідовність, що складається з одного мільйона слів, навіть якщо перше слово в цій послідовності поліндром. Так що після цього потенційно 999999 слів копіюються в проміжний результат взагалі без перевірки. Багато програмістів тут здадуться і напишуть свої власні версії пошуку паліндромів в деякому наданому префіксі аргумента-послідовності. Але з переглядами ви не маєте робити це. Просто напишіть:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">view</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це матиме той самий гарний поділ турбот, але замість послідовності з мільйона елементів це буде конструювати лише один легковажний об'єкт перегляда. Таким чином, вам не треба обирати між продуктивністю та модульністю. Другий випадок застосування стосується до переглядів змінних послідовностей. Багато функцій-трансформерів на таких переглядах провадять вікно до оригінальної послідовності, що потім може використовуватись для вибіркового оновлення деяких елементів в цій послідовності. Щоб побачити це на прикладі, уявімо ми маємо масив <code>arr</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span><span class="o">).</span><span class="n">toArray</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити субвікно в цьому масиві, створивши скибку <code>slice</code> перегляду масиву:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">subarr</span> <span class="k">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">subarr</span><span class="k">:</span> <span class="kt">scala.collection.mutable.IndexedSeqView</span><span class="o">[</span>
  <span class="kt">Int</span>,<span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">IndexedSeqViewS</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дає перегляд <code>subarr</code>, що посилається на елементи в позиціях від 3 до 5 в масиві <code>arr</code>. Перегляд не копіює ці елементи, він тільки провадить посилання на них. Тепер уявімо, що ви маєте метод, що модифікує деякі елементи в послідовності. Наприклад, наступний метод <code>negate</code> буде обертати знак всіх наданих елементів послідовності цілих:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="o">-</span><span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="n">negate</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">scala.collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер уявімо, що ви бажаєте змінити знак елементів в позиціях від трьох до п'яти масива <code>arr</code>. Чи можливо використати для цього <code>negate</code>? З використанням перегляду це просто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">negate</span><span class="o">(</span><span class="n">subarr</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це те, що <code>negate</code> змінює всі елементи в <code>subarr</code>, що є скибкою елементів <code>arr</code>. Знову, ви бачите, що перегляди допомагають підтримувати речі модулярними. Код вище гарно розділяє питання, до якого диапазону індексів застосувати метод, та те, який саме метод застосувати.</p></div>
<div class="paragraph"><p>Після того, як ми побачили всі ці дотепні використання переглядів, ви можете здивуватись, для чого взагалі мати строгі послідовності? Одна причина в тому, що порівняння продуктивності не завжди на користь лінивих в колекцій в порівнянні зі строгими. Для меньших розмірів колекцій додаткове навантаження по формуванню замикань в переглядах часто більше, ніж вигода від уникнення проміжних структур даних. Можливо більш важлива причина в тому, що обчислення в переглядах можуть бути дуже збентежливі, якщо операції мають побічні ефекти.</p></div>
<div class="paragraph"><p>Ось приклад, що зачепив декількох користувачів версій Scala до 2.8. В ціх версіях тип <code>theRange</code> був лінивий, так що він ефективно поводився як перегляд. Люди намагались створити декілька акторів,<span class="footnote"><br />[Бібліотека акторів Scala вже застаріла, але цей історичний приклад все ще актуальний.]<br /></span> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="k">yield</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони були здивовані, що після цього жодний з акторів не виконувався, навіть якщо метод <code>actor</code> повинен створювати та запускати актора на основі кода, що оточений в фігурні дужки за ним. Щоб пояснити, чому нічого не відбувається, нагадаємо, що вираз <code>for</code> вище еквівалентний до застосування методу <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки попередній <code>range</code>, спродукований <code>(1 to 10)</code>, поводиться як перегляд, результатом <code>map</code> знову буде перегляд. Тобто, відповідно, жодного елементу не було обчислено, та жодного актора не було створено! Актори були створені через форсування <code>range</code> для всього виразу, але це менше ніж очевидне, що все це треба щоб змусити акторів до своєї роботи.</p></div>
<div class="paragraph"><p>Щоб уникнути ціх сюрпризів, колекції Scala отримали більш регулярні правила в версії 2.8. Всі колекції, за винятком потоків та переглядів, є строгими. Єдиний шлях від строгих до лінивих колекцій - через метод <code>view</code>. Єдиний шлях іти зворотнім шляхом - через метод <code>force</code>. Так що визначення акторів вище будуть робити як очікується в Scala 2.8, в тому розмінні, що будуть створені та запущені десять акторів. Щоб перейти до цікавої попередньої поведінки, ви маєте додати явний виклик метода <code>view</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="n">view</span><span class="o">)</span> <span class="k">yield</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В підсумку, перегляди є потужним інструментом для примирення проблем ефективності з проблемами модульності. Але щоб загрузнути в аспектах відкладеного виконання, вам слідує обмежити перегляди до двох сценаріїв. Або ви застосувуєте перегляди в чисто функціональному коді, де трансформації колекцій не мають побічних ефектів. Або ви застосовуєте їх для змінних колекцій, коли всі модифікації виконуються явно. Чого треба уникати, це змішування переглядів і операцій, що створюють нові колекції, при цьому також маючи побічні ефекти.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_15_">24.15 Ітератори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ітератор не є колекцією, але скоріше шляхом отримати доступ до елементів колекції один за одним. Існує дві базові операції на ітераторі <code>it</code>, <code>next</code> та <code>hasNext</code>. Виклик до <code>it.next()</code> буде повертати наступний елемент ітератора, та просувати стан ітератора. Наступний виклик <code>next</code> на тому самому ітераторі буде видавати елемент на один далі від повернутого перед цім. Якщо немає більше елементів, що можна повернути, виклик до <code>next</code> буде закидати <code>NoSuchElementException</code>. Ви можете дізнатись, чи є ще елементи, що можна повернути, використовуючи метод <code>Iterator</code>'а <code>hasNext</code>.</p></div>
<div class="paragraph"><p>Найбільш прямолінійний метод "прокрокувати" по всіх елементах, що повертає ітератор, це використання циклу <code>while</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітератори в Scala також провадять аналоги до більшості з методів, що ви можете знайти в трейтах <code>Traversable</code>, <code>Iterable</code> та <code>Seq</code>. Наприклад, вони провадять метод <code>foreach</code>, що виконує надану процедуру на кожному елементі, що повертаються ітератором. Використовуючи <code>foreach</code>, цикл вище може бути скорочений до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">it</span> <span class="n">foreach</span> <span class="n">println</span>
</pre></div></div></div>
<div class="paragraph"><p>Як завжди, вирази <code>for</code> можуть використовуватись як альтернативний синтаксис для виразів, що включають <code>foreach</code>, <code>map</code>, <code>filter</code> та <code>flatMap</code>, так що інший спосіб надрукувати всі елементи, що повертаються ітератором, буде таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">elem</span> <span class="k">&lt;-</span> <span class="n">it</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує важлива різниця між методом <code>foreach</code> на ітераторі, та тим самим методом на перехідних колекціях: коли він викликається на ітераторів, <code>foreach</code> після свого закінчення буде залишати ітератор в кінці. Так що наступний виклик до <code>next</code> знову на томуж ітератору буде хибним <code>NoSuchElementException</code>. На відміну до цього, коли викликається для колекції, <code>foreach</code> залишає число елементів в колекції без змін (якщо передана функція не додає або видаляє елементи, але це не заохочується, оскільки легко може призвести до несподіваних результатів).</p></div>
<div class="paragraph"><p>Інші операції, які <code>Iterator</code> має назагал з <code>Traversable</code>, мають ту саму властивість полишати ітератор в кінці після завершення. Наприклад, ітератори провадять метод <code>map</code>, що повертає новий ітератор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;number&quot;</span><span class="o">,</span> <span class="s">&quot;of&quot;</span><span class="o">,</span> <span class="s">&quot;words&quot;</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="mi">1</span>
<span class="mi">6</span>
<span class="mi">2</span>
<span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">next</span> <span class="kt">on</span> <span class="kt">empty</span> <span class="kt">iterator</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, після виклику до <code>map</code>, ітератор просунувся в кінець. Інший приклад є метод <code>dropWhile</code>, що може використовуватись для пошуку першого елементу ітератора, що має певну властивість. Наприклад, щоб знайти перше слово в ітераторі, показаному до цього, що має щонайменьше два символи, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;number&quot;</span><span class="o">,</span> <span class="s">&quot;of&quot;</span><span class="o">,</span> <span class="s">&quot;words&quot;</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">number</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову зауважте, що <code>it</code> був змінений через виклик до <code>dropWhile</code>: тепер <code>it</code> вказує на друге слово "number" в списку. Фактично, <code>it</code> та результат <code>res4</code>, що повертається <code>dropWhile</code>, буде повертати точно такуж ж послідовність елементів.</p></div>
<div class="paragraph"><p>Існує тільки одна стандартна операція, <code>duplicate</code>, що дозволяє вам повторно використовувати той самий ітератор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">(</span><span class="n">it1</span><span class="o">,</span> <span class="n">it2</span><span class="o">)</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">duplicate</span>
</pre></div></div></div>
<div class="paragraph"><p>Виклик до <code>duplicate</code> дає вам два ітератори, де кожний повертає точно такі ж елементи, що і ітератор <code>it</code>. Два ітератори роблять незалежно; просування одного не впливає на інший. На відміну від цього, оригінальний оператор, <code>it</code>, просувається до свого кінця під час дублювання, і, таким чином, стає некорисним.</p></div>
<div class="paragraph"><p>В підсумку, ітератори поводяться як колекції, якщо ви ніколи не отримуєте доступ до ітератора знову, після виклику на ньому метода. Бібліотеки колекцій Scala робить це явним, з абстракцією на ім'я <code>TraversableOnce</code>, що є загальним трейтом для <code>Traversable</code> та <code>Iterator</code>. Як відказує ім'я, об'єкти <code>TraversableOnce</code> можуть проходити з використанням <code>foreach</code>, але стан цього об'єкту після проходження не визначений. Якщо об'єкт <code>TraversableOnce</code> фактично є <code>Iterator</code>, він після проходження буде в своєму кінці, але якщо це <code>Traversable</code>, він буде існувати як раніше. Загальний спосіб застосування <code>TraversableOnce</code> - як тип аргумента для методів, що можуть приймати або ітератор, або перехідне в якості аргумента. Прикладом є метод додавання <code>++</code> в трейті <code>Traversable</code>. Він приймає параметр <code>TraversableOnce</code>, так що ви можете додати елементи, що походять або від ітератора, або від перехідної колекції.</p></div>
<div class="paragraph"><p>Всі операції на ітераторах підсумовані в Таблиці 24.12.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Абстрактні методи:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.next()</p></td>
<td align="left" valign="top"><p class="table">Повертає наступний елемент ітератора <code>it</code> та просувається далі.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.hasNext</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>true</code>, якщо <code>it</code> може повернути наступний елемент.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Варіації:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.buffered</p></td>
<td align="left" valign="top"><p class="table">Буферизований ітератор, що повертає всі елементи <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it grouped size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отримує елементи <code>it</code> в "шматках" послідовностей фіксованого розміру.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sliding size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отримує елементи <code>it</code> в послідовностях плаваючого вікна фіксованого розміру.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Копіювання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it copyToBuffer buf</p></td>
<td align="left" valign="top"><p class="table">Копіює всі повернуті <code>it</code> елементи до буфера <code>buf</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it copyToArray(arr, s, l)</p></td>
<td align="left" valign="top"><p class="table">Копіює щонайбільше <code>l</code> елементів, що повертаються <code>it</code>, до <code>arr</code>, починаючи з індексу <code>s</code>. Останні два аргументи опціональні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Дублікація:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.duplicate</p></td>
<td align="left" valign="top"><p class="table">Пара ітераторів, кожний з яких незалежно повертає всі елементи <code>it</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it ++ jt</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи, що повертає ітератор <code>it</code>, за яким слідують елементи, що повертає ітератор <code>jt</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it padTo (len, x)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи <code>it</code>, за якими слідують копії <code>x</code>, доки не буде досягнута загальна довжина з <code>len</code> елементів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Мапи:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it map</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отриманий від застосування функції <code>f</code> до кожного елементу, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it flatMap</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отриманий від застосування функції зі значенням ітератора <code>f</code> до кожного елементу, та додавання результатів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it collect</p></td>
<td align="left" valign="top"><p class="table">Ітератор, отриманий від застосування часткової функції <code>f</code> до кожного елементу в <code>it</code>, до якого вона визначена, та збирання результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toArray</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в масив.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toList</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в список.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toIterable</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в <code>iterable.it.toSeq</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toIndexedSeq</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в індексовану послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toStream</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в потік.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toSet</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в множину.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toMap</p></td>
<td align="left" valign="top"><p class="table">Збирає пари ключ/значення, що повертає <code>it</code>, в мапу.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Інформація про розмір:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.isEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи ітератор порожній (протилежність <code>hasNext</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.nonEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція містить елементи (псевдоним до <code>hasNext</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.size</p></td>
<td align="left" valign="top"><p class="table">Число елементів, що повертає <code>it</code>. Увага: <code>it</code> після цієї операції буде вказувати на кінець!</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.lengt</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <em>it.size</em>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.hasDefiniteSize</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>true</code>, якщо відомо, що <code>it</code> повертає обмежену кількість елементів (по замовчанню те саме, що <code>isEmpty</code>).</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Пошук і отримання елементів:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it find</p></td>
<td align="left" valign="top"><p class="table">Опція, що містить перший елемент, що повертає <code>it</code>, який задовільняє <code>p</code>, або <code>None</code>, якщо жодний елемент не підійде. Увага: ітератор просувається після знайденого елементу, або до кінця, якщо нічого не знайдене.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it indexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елемента, що повертається <code>it</code>, що дорівнює <code>x</code>. Увага: ітератор просувається за позицію цього елемента.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it indexWhere</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу, що повертається <code>it</code>, що задовільняє <code>p</code>. Увага: ітератор просувається за позицію цього елемента.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Субітератори:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it take</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає перші <code>n</code> елементів <code>it</code>. Увага: <code>it</code> буде просуватись до позиції за <code>n</code>-ним елементом, або до кінця, якщо <code>it</code> містить меньше ніж <code>n</code> елементів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it drop</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що починається з <code>(n + 1)</code>-ного елементу <code>it</code>. Увага: <code>it</code> буде просуватись на нову позицію.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it slice (m, n)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає фрагмент з елементів, що повертає <code>it</code>, починаючи з <code>m</code>-того елемента, та завершуючи перед <code>n</code>-ним елементом.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it takeWhile</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає елементи з <code>it</code>, доки умова <code>p</code> є <code>true</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it dropWhile</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що пропускає елементи з <code>it</code>, доки умова <code>p</code> є <code>true</code>, та повертає залишок.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it filter</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи з <code>it</code>, що задовільняє умові <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it withFilter</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <code>it filter p</code>. Треба для використання ітераторів в виразах <code>for</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it filterNot</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи з <code>it</code>, що не задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Підрозділення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it partition</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>it</code> на пару з двох ітераторів; один повертає всі елементи, що задовільняють предикатові <code>p</code>, інший повертає всі елементи з <code>it</code>, що ні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Умови до елементів:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it forall</p></td>
<td align="left" valign="top"><p class="table">Логічне, вказує, чи предикат <code>p</code> дотримується до всіх елементів, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it exists</p></td>
<td align="left" valign="top"><p class="table">Логічне, вказує, чи предикат <code>p</code> виконується для деякого елементу, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it count</p></td>
<td align="left" valign="top"><p class="table">Число елементів в <code>it</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Згортки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(z /: it)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами, що повертає <code>it</code>, ідучи зліва направо, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(it :\ z)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами, що повертає <code>it</code>, ідучи зправа наліво, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.foldLeft(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що (z /: it)(op).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.foldRight(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що (it :\ z)(op).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it reduceLeft op</p></td>
<td align="left" valign="top"><p class="table">Застосовує вдомірну операцію <code>op</code> між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it reduceRight op</p></td>
<td align="left" valign="top"><p class="table">Застосовує вдомірну операцію <code>op</code> між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Специфічні згортки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.sum</p></td>
<td align="left" valign="top"><p class="table">Сума числових елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.product</p></td>
<td align="left" valign="top"><p class="table">Добуток значень числових елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.min</p></td>
<td align="left" valign="top"><p class="table">Мінімум впорядкованих елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.max</p></td>
<td align="left" valign="top"><p class="table">Максимум впорядкованих елементів, що повертає ітератор</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Поєднання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it zip jt</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар відповідних елементів, що повертаються ітераторами <code>it</code> та <code>jt</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it zipAll (jt, x, y)</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар відповідних елементів, що повертаються ітераторами <code>it</code> та <code>jt</code>, де коротший ітератор розширюється, щоб співпадати з довшим, через додавання елементів <code>x</code> або <code>y</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.zipWithIndex</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар елементів, що повертаються <code>it</code> разом з індексами.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it patch (i, jt, r)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, отриманий з <code>it</code> заміною <code>r</code> елементів починаючи з <code>i</code> патч-ітератором <code>jt</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Порівняння:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it sameElements jt</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи ітератори <code>it</code> та <code>jt</code> повертають ті самі елементи в тому самому порядку. Увага: після цієї операції щонайменьше один з <code>it</code> та <code>jt</code> опиниться в кінці.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Рядки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it addString (b, start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Додає рядок до <code>StringBuilder</code> <code>b</code>, що показує всі елементи, повернуті <code>it</code> з роздільниками <code>sep</code>, оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональними.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it mkString (start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Конвертує ітератор на рядоко, що показує всі елементи, що обмежені роздільникими <code>sep</code>, оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональними.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="___14">Буферізовані ітератори</h3>
<div class="paragraph"><p>Іноді ви бажаєте ітератори, що можуть "заглядати наперед", так що ви можете інспектувати наступний елемент, що буде повернутий, без просування за цей елемент. Розглянемо, наприклад, завдання пропуску початкових порожніх рядків з ітератора, що повертає послідовність рядків. Ви можете підпасти в спокусу написати дещо подібне до такого метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це не працюватиме</span>
<span class="k">def</span> <span class="n">skipEmptyWordsNOT</span><span class="o">(</span><span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">().</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але подивіться на цей код ближче, ясно що він невірний: код вочевидь пропустить початкові порожні рядки, але він також просуне <code>it</code> за перший непорожній рядок!</p></div>
<div class="paragraph"><p>Рішення до цієї проблеми є використання буферизованого ітератора, примірника трейту <code>BufferedIterator</code>. <code>BufferedIterator</code> є субтрейтом <code>Iterator</code>, що провадить один додатковий метод, <code>head</code>. Виклик <code>head</code> на буферизованому ітераторі буде повертати його перший елемент, але не буде просувати ітератор. Використовуючи буферизований ітератор пропуск порожніх слів може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">skipEmptyWords</span><span class="o">(</span><span class="n">it</span><span class="k">:</span> <span class="kt">BufferedIterator</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний ітератор може бути конвертований на буферизований ітератор, через виклик його методу <code>buffered</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bit</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">buffered</span>
<span class="n">bit</span><span class="k">:</span> <span class="kt">java.lang.Object</span> <span class="kt">with</span> <span class="kt">scala.collection.</span>
<span class="kt">BufferedIterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bit</span><span class="o">.</span><span class="n">head</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що виклик <code>head</code> на буферизованому ітераторі, <code>bit</code>, не просуває його. Таким чином, наступний виклик <code>bit.next()</code> повертає те саме значення, що і <code>bit.head</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_16____">24.16 Створення колекцій з нуля</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви вже бачили синтаксис, як <code>List(1, 2, 3)</code>, що створює список з трьох цілих, та <code>Map('A' - &gt; 1, 'C' -&gt; 2)</code>, що створює мапу з двома парами прив'язок. Насправді це універсальна можливість Scala колекцій. Ви можете взяти любе ім'я колекції, та поставити після нього список елементів в дужках. Результат буде новою колекцією з наданими елементвами. Ось деякі інші приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Traversable</span><span class="o">()</span> <span class="c1">// Порожній перехідний об&#39;єкт</span>
<span class="nc">List</span><span class="o">()</span> <span class="c1">// Порожній список</span>
<span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span> <span class="c1">// Список з елементами 1.0, 2.0</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span> <span class="c1">// Вектор з елементами 1.0, 2.0</span>
<span class="nc">Iterator</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// Ітератор, що повертає три цілі.</span>
<span class="nc">Set</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">bird</span><span class="o">)</span> <span class="c1">// Множина з трьох тварин</span>
<span class="nc">HashSet</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">bird</span><span class="o">)</span> <span class="c1">// Хеш множина з тими ж тваринами</span>
<span class="nc">Map</span><span class="o">(</span><span class="sc">&#39;a&#39;</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// Мапа з символів до цілих</span>
</pre></div></div></div>
<div class="paragraph"><p>"Під покровом" кожний з рядків вище викликає метод <code>apply</code> на деякому об'єкті. Наприклад, третій рядок розширюється до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що це виклик до метода <code>apply</code> об'єкта компанйона класу <code>List</code>. Метод приймає довільне число аргументів, та конструює з них список. Кожний клас колекції в бібліотеці Scala має метод <code>apply</code>. Не має значення, чи клас колекції представляє суцільну реалізацію, як <code>List</code>, <code>Stream</code> або <code>Vector</code>, або це трейт, такий як <code>Seq</code>, <code>Set</code> або <code>Traversable</code>. В останньому випадку виклик <code>apply</code> буде продукувати деяку реалізацію трейта по замовчанню. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Крім <code>apply</code> кожний об'єкт компанйон колекції визначає метод <code>empty</code>, що повертає порожню колекцію. Так що замість <code>List()</code> ви можете написати <code>List.empty</code>, замість <code>Map()</code> - <code>Map.empty</code>, і так далі.</p></div>
<div class="paragraph"><p>Нащадки трейтів <code>Seq</code> також провадять інші операції фабрик в своїх об'єктах компанйонах. Вони підсумовані в Таблиці 24.13. Скорочено це виглядає так:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>concat</code> конкатенує довільне число перехідних разом
</p>
</li>
<li>
<p>
<code>fill</code> та <code>tabulate</code>, що генерують одно- або багато-вимісні послідовності, ініціалізовані деякими виразами або функцією табуляції
</p>
</li>
<li>
<p>
<code>range</code>, яка генерує цілі послідовності з деяким заданим кроком
</p>
</li>
<li>
<p>
<code>iterate</code>, що генерує послідовність, як результат від повторного застосування функції до початкового елемента.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">S.empty</p></td>
<td align="left" valign="top"><p class="table">Порожня послідовність</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S(x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Послідовність з елементів <code>x</code>, <code>y</code> та <code>z</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.concat(xs, ys, zs)</p></td>
<td align="left" valign="top"><p class="table">Послідовність, отримана як конкатенація елементів <code>xs</code>, <code>ys</code> та <code>zs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.fill(n)(e)</p></td>
<td align="left" valign="top"><p class="table">Послідовність довжини <code>n</code>, де кожний елемент обчисляється як вираз <code>e</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.fill(m, n)(e)</p></td>
<td align="left" valign="top"><p class="table">Послідовність послідовностей розміром <code>m x n</code>, де кожний елемент обчислюється як вираз <code>e</code> (існує також для більших розмірнестей)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.tabulate(n)(f)</p></td>
<td align="left" valign="top"><p class="table">Послідовність довжини <code>n</code>, де елемент для кожного індексу <code>i</code> обчислюється як <code>f(i)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.tabulate(m, n)(f)</p></td>
<td align="left" valign="top"><p class="table">Послідовність послідовностей розміром <code>m x n</code>, де елемент з індексом <code>(i, j)</code> обчислюється як <code>f(i, j)</code> (існує також для більших розмірностей)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.range(start, end)</p></td>
<td align="left" valign="top"><p class="table">Послідовність цілих <code>start ... end - 1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.range(start, end, step)</p></td>
<td align="left" valign="top"><p class="table">Послідовність цілих, що починається зі <code>start</code>, та продовжується з кроком <code>step</code> до значення <code>end</code>, виключно</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.iterate(x, n)(f)</p></td>
<td align="left" valign="top"><p class="table">Послідовність довжини <code>n</code> з елементами <code>x</code>, <code>f(x)</code>, <code>f(f(x))</code>, &#8230;</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_17____java__scala">24.17 Перетворення між колекціями Java і Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як Scala, Java має багату бібліотеку колекцій. Існує багато подібного між ціма двома. Наприклад, обоє знають про ітерації, ітерабельні, множини, мапи та послідовності. Але також існують важливі відмінності. Зокрема, бібліотеки Scala роблять значно більший наголос на незмінні колекції, та провадять значно більше операцій, що трансформують колекції в нові.</p></div>
<div class="paragraph"><p>Іноді вам треба конвертувати колекцію з ощного фреймфорка в інший. Наприклад, ви можете отримати доступ до існуючої Java колекції, так, якби це була Scala. Або ви можете забажати одну зі Scala колекцій до Java методу, що очікує Java варіант. Зробити це досить легко, оскільки Scala пропонує неявні перетворення між всіма головними типами колекцій в об'єкт <code>JavaConversions</code>. Зокрема, ви знайдете двосторонні перетворення між наступними типами:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Iterator</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Iterator</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Iterator</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Enumeration</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Iterable</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.lang.Iterable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Iterable</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Collection</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Buffer</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.List</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Set</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Set</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Map</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Mapx</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Щоб дозволити ці перетворення, просто імпортуйте їх, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.JavaConversions._</span>
<span class="k">import</span> <span class="nn">collection.JavaConversions._</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви маєте автоматичні перетворення між колекціями Scala, та відповідними колекціями Java.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.mutable._</span>
<span class="k">import</span> <span class="nn">collection.mutable._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">jul</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">java.util.Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">HashMap</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">m</span><span class="k">:</span> <span class="kt">java.util.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span><span class="n">hello</span><span class="k">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">abc</span><span class="k">=</span><span class="mi">1</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Внутрішньо ці перетворення роблять через встановлення об'єкта "огортки", що пересилає всі операції до підлеглого об'єкта колекції. Так що колекції ніколи не копіюються, коли конвертуються між Java та Scala. Цікава властивість в тому, що якщо ви робите кругову конверсію, скажімо, Java типу до відповідного типу Scala, та назад до того самого типу Java, ви скінчите з об'єктом ідентичного типу, до того, з якого починали.</p></div>
<div class="paragraph"><p>Деякі інші загальні Scala колекції також можуть бути конвертовані до Java типів, але для яких немає відповідного перетворення в іншому напрямку:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Seq</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.List</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Seq</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.List</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Set</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Set</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Map</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Map</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Оскільки Java не розрізняє між змінними та незмінними колекціями в своїх типах, перетворення зі, скажімо, <code>collection.immutable.List</code> буде давати <code>java.util.List</code>, на якому всі операції змін будуть закидати <code>UnsupportedOperationException</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">jul</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">UnsupportedOperationException</span>
<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">AbstractList</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">AbstractList</span><span class="o">.</span><span class="n">java</span><span class="k">:</span><span class="err">131</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<h1 id="_24_18_">24.18 Висновок</h1>
<div class="paragraph"><p>Тепер ви побачили, як використовувати Scala колекції дуже детально. Колекції Scala приймають підхід надання вам потужних будівельних блоків, скоріше, ніж декількох споміжних методів на підхваті. Покладаючи поряд два або три такі будівельні блоки, дозволяє вам виразити величезну кількість коричних обчислень. Цей стиль бібліотек особливо ефективний через те, що Scala має легкий синтаксис для функціональних літералів, та через те, що вона провадить багато типів колекцій, що стійкі та незмінні.</p></div>
<div class="paragraph"><p>Ця глава показала колекції з точки зору програміста, що використовує бібліотеку колекцій. Наступна глава покаже вам, як колекції побудовані, та як ви можете додати власні типи колекцій.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-08 03:42:05 EEST
</div>
</div>
</body>
</html>
