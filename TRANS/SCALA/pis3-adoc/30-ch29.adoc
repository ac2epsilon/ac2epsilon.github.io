include::headers.adoc[]

Глава 29
--------

Модулярне програмування з використанням об'єктів
================================================

В Главі 1 ми стверджували, що один зі способів, в який Scala є маштабованою мовою, це те, що ви можете використовувати ті самі прийоми для конструювання малих, так само як і великих програм. Досі в цій книзі ми в основному фокусувались на програмуванні в малому: розробленні та реалізації маліших програмних частин, з яких ви можете конструювати більші програми.
footnote:[Ця термінологія була введена в творі DeRemer, et. al., "Programming - in - the - large versus programming - in - the - small." [DeR75\]] Інша сторона історії є програмування в великому: організація та збирання менших частин в більші програми, застосування або системи. Ми торкались цього предмета, коли ми обговорювали пакунки та модифікатори доступу в Главі 13. Коротко кажучи, пакунки та модифікатори доступу дозволяють вам організувати великі програми, використовуючи пакунки як модулі, де модуль є "меньшою програмною частиною" з гарно визначеним інтерфейсом та прихованою реалізацією.

В той час, коли поділення програм на пакунки завжди досить корисне, воно обмежене, оскільки воно не провадить методів для абстракції. Ви не можете переналаштувати пакунок в два способи в тій самій програмі, і ви не можете наслідувати між пакунками. Пакунок завжди включає один конкретний список компонент, і цей список фіксований, доки ви не зміните код.

В цій главі ми обсудимо, як ви можете задіяти об'єктно орієнтовні можливості Scala, щоб зробити програму більш модулярною. Спочатку ми покажемо, як простий об'єкт синглтон може бути використаний як модуль. Потім ми покажемо, як ви можете використовувати трейти та класи для абстракцій в модулях. Ці абстракції можуть бути переконфігуровані в декілька модулів, навіть декілька разів в тій самій програмі. Нарешті, ми покажемо прагматичну техніку для використання трейтів для розподілу модуля по декільком файлам.

29.1 Проблема
-------------
По мірі того, як програма зростає в розмірі, стає все більше важливим організувати її в модулярний спосіб. По перше, можливість окремо компілювати різні модулі, що складають систему, допомагає різним командам робити незалежно. На додаток, корисно мати змогу відмикати одну реалізацію модуля, та підмикати іншу, оскільки це дозволяє використовувати різні конфігурації системи в різних контекстах, таких, як юніт тестування на десктопі розробника, інтеграційні тести, тестова експлуатація та розгортання.

Наприклад, ви можете мати застосування, що використовує базу даних та сервіс повідомлень. По мірі як ви пишете код, ви можете бажати виконувати юніт тести на вашому десктопі, що використовують фіктивні мок версії обох, бази даних та сервіса повідомлень, що симулює ці сервіси достатньо для тестування, без потреби розмовляти по мережі до загального ресурса. Протягом інтеграційного тестування ви можете побажати використовувати мок сервіс повідомлень, але живу базу даних. Під час тестової експлуатації, та напевне при розгортанні, ваша організація скоріше всього буде використовувати живі версії обох, бази даних та сервіс повідомлень.

Люба техніка, що націлена на спрощення цього різновиду модульності потребує провадити декілька основних речей. Перше, має бути конструкція модуля, що провадить гарне розділення інтерфейса та реалізації. Друге, потрібен бути шлях заміняти один модуль на інший, що має той самий інтерфейс, без зміни або перекомпіляції модулів, що залежать від заміненого. Нарешті, повинен бути спосіб поєднувати модулі разом. Ця задача поєднання може розглядатись як конфігурація системи.

Один підхід до вирішення цієї проблеми є ін'єкція залежностей, прийом, що підтримується на Java платформі фреймворками, як Spring та Guice, що популярні в корпоративній Java спільноті.footnote:[Fowler, "Inversion of control containers and the dependency injection pattern." [Fow04\]] Наприклад Spring в основному дозволяє вам презентувати інтерфейс модуля як Java інтерфейс, та реалізації модуля як Java класи. Ви можете задати залежності між модулями та "приєднати" застосування разом через зовнішній файл конфігурації XML. Хоча ви можете використовувати Spring зі Scala, і через це використовувати підхід Spring для досягнення модульності рівня системи ваших Scala програм, зі Scala ви маєте деякі альтернативи, доступні через саму мову. В залишку цієї глави ви покажемо, як використовувати об'єкти як модулі для бажаної модульності "в великому", без використання зовнішнього фреймворку.

29.2 Застосування рецепту
-------------------------
Уявіть, що ви будуєте корпоративне веб застосування, що дозволить користувачам керувати рецептами. Ви бажаєте розбити програму на шари, включаючи прикладний шар та шар застосування. В прикладному шарі ви визначите прикладні об'єкти, що захоплять бізнес концепції та правила, так само як енкапсулюють стан, що буде збережений в зовнішній базі даних. В рівні застосування ви будете провадити API, організоване в термінах сервісів, які застосування пропонує клієнтам (включаючи рівень користувацького інтерфейсу). Рівень застосування буде реалізувати ці серсіси через координацію завдань та делегацію роботи до об'єктів прикладного домена.footnote:[Іменування ціх шарів слідує таким в Evans, Domain-Driven Design. [Eva03\]]

Ви бажаєте бути в змозі під'єднати реальну або мок версію на кожному з ціх рівнів, так що ви можете більш просто писати юніт тести для вашого застосування. Щоб досягти цієї цілі ви можете розглядати об'єкти, що ви бажаєте зробити мок, як модулі. В Scala немає потреби для об'єктів бути "малими" речами, немає потреби використовувати деякий інший різновид конструктора для "великих" речей, як модулі. Один зі шляхів, в який Scala є маштабованою мовою, є те, що ті самі конструкції використовуються для структур, однаково, малих та великих.

Наприклад, оскільки одне з "речей", що ви бажаєте зробити мок на прикладному рівні, є об'єкт, що представляє реляційну базу даних, ви зробите його одним з модулей. На рівні застосування ви будете трактувати об'єкт "переглядач бази даних" як модуль. База даних буде містити всі рецепти, що людина буде збирати. Переглядач буде допомагати шукати та переглядати базу даних, наприклад, щоб знайти кожний рецепт, що включає інгредієнти, що у вас є в наявності.

Перша річ, що треба зробити, є моделювання їжі та рецептів. Щоб утримувати речі простими, їжа буде мати лише назву, як показано в Лістингу 29.1. Рецепт буде мати ім'я, список інгредієнтів і деякі інструкції, як показано на Лістингу 29.2.
[source,scala]
----
package org.stairwaybook.recipe

abstract class Food(val name: String) {
  override def toString = name
}
----
Лістинг 29.1 - Простий клас сутності `Food`.

[source,scala]
----
package org.stairwaybook.recipe

class Recipe(
  val name: String,
  val ingredients: List[Food],
  val instructions: String
) {
  override def toString = name
}
----
Лістинг 29.2 - Простий клас сутності `Recipe`.

Класи `Food` та `Recipe`, показані в Лістингу 29.1 та 29.2, представляють сутності, що будуть представлені в базі даних.footnote:[Ці класи сутностей спрощені, щоб не захаращувати приклад багатьма деталями реального світу. Але трансформація ціх класів в сутності, що можуть бути збережені за допомогою Hibernate або, наприклад, Java Persistence Architecture, буде потребувати тільки декількох модифікацій, таких як додавання поля `private Long id` та конструктора без аргументів, покладання анотацій `scala.reflect.BeanProperty` на поля, вказання відповідних відображень через анотації або окремий XML файл, і так далі.] Лістинг 29.3 показує деякі примірники синглтонів ціх класів, що можуть бути використані для написання тестів.
[source,scala]
----
package org.stairwaybook.recipe

object Apple extends Food("Apple")
object Orange extends Food("Orange")
object Cream extends Food("Cream")
object Sugar extends Food("Sugar")

object FruitSalad extends Recipe(
  "fruit salad",
  List(Apple, Orange, Cream, Sugar),
  "Stir it all together."
)
----
Лістинг 29.3 - Приклади `Food` та `Recipe` для використання в тестах.

[source,scala]
----
package org.stairwaybook.recipe

object SimpleDatabase {
  def allFoods = List(Apple, Orange, Cream, Sugar)

  def foodNamed(name: String): Option[Food] =
    allFoods.find(_.name == name)

  def allRecipes: List[Recipe] = List(FruitSalad)
}

object SimpleBrowser {
  def recipesUsing(food: Food) =
    SimpleDatabase.allRecipes.filter(recipe =>
      recipe.ingredients.contains(food))
}
----
Лістинг 29.4 - Фіктивна база даних та модулі перегляду.

Scala використовує об'єкти для модулів, так що ви можете почати модулізацію вашої програми зі створення двох синглтонів, що служитимуть як фіктивні мок реалізації бази даних та переглядача під час тестування. Оскільки це мок, модуль бази даних підтримується простим списком в пам'яті. Реалізації ціх об'єктів показані в Лістингу 29.4. Ви можете використовувати цю базу даних та переглядач наступним чином:
[source,scala]
----
scala> val apple = SimpleDatabase.foodNamed("Apple").get
apple: Food = Apple

scala> SimpleBrowser.recipesUsing(apple)
res0: List[Recipe] = List(fruit salad)
----
Щоб зробити речі трохи цікавішими, уявімо, що база даних сортує їжу по категоріях. Щоб реалізувати це, ви можете додати клас `FoodCategory`, та перерахувати всі категорії в базі даних, як показано в Лістингу 29.5. Зауважте в цьому прикладі ключове слово `private`, що корисне для реалізації класів, і також корисне для реалізації модулів. Елементи, що відмічені як приватні, є частиною реалізації модуля, і, таким чином, відносно прості для зміни без впливу на інші модулі.

В цій точці можуть бути додані значно більше можливостей, але ви отримали ідею. Програми можуть бути поділені на об'єкти синглтони, про які ви можете думати як про модулі. Це не велика новина, але це стає дуже корисним, коли ви розглядатимете абстракції (про що ми скоро розповімо).
[source,scala]
----
package org.stairwaybook.recipe

object SimpleDatabase {
  def allFoods = List(Apple, Orange, Cream, Sugar)

  def foodNamed(name: String): Option[Food] =
    allFoods.find(_.name == name)

  def allRecipes: List[Recipe] = List(FruitSalad)

  case class FoodCategory(name: String, foods: List[Food])

  private var categories = List(
    FoodCategory("fruits", List(Apple, Orange)),
    FoodCategory("misc", List(Cream, Sugar)))

  def allCategories = categories
}

object SimpleBrowser {
  def recipesUsing(food: Food) =
    SimpleDatabase.allRecipes.filter(recipe =>
      recipe.ingredients.contains(food))
  
  def displayCategory(category: SimpleDatabase.FoodCategory) = {
    println(category)
  }
}
----
Лістинг 29.5 - Модулі бази даних та переглядача з доданими категоріями.

29.3 Абстракції
---------------
Хоча приклади, показані дотепер, керували розбиттям вашого застосування на окремі модулі бази даних та переглядача, досі дизай не дуже "модулярний". Проблема в тому, що існує "жорсткий зв'язок" від модуля переглядача до модуля бази даних:
[source,scala]
----
SimpleDatabase.allRecipes.filter(recipe => ...
----
Оскільки модуль `SimpleBrowser` споминає модуль `SimpleDatabase` за ім'ям, ви не будете в змозі під'єднати іншу реалізацію модуля бази даних, без модифікації та перекомпіляції модуля переглядача. На додаток, хоча немає жорсткого посилання від модуля `SimpleDatabase` до модуля `SimpleBrowser`,footnote:[Це гарно, бо кожний з ціх архитектурних шарів повинен залежати тільки від шарів під ним.] немає ясного спосібу дозволити шару користувацького інтерфейсу, наприклад, бути сконфігурованим для використання інших реалізацій модуля переглядача.

Однак, коли робити ці модулі більш підключуваними, важливо уникати дублікації кода, оскільки більшість коду з вірогідністю може бути поширений між різними реалізаціями того самого модуля. Наприклад уявімо, що ви бажаєте, щоб та сама кодова база підтримувала декілька баз даних рецептів. Ви скоріше всього захочете використати код переглядача для кожного з примірників, оскільки тільки одна річ, що буде відрізняться в переглядачах, це база даних, на яку вони посилаються. За винятком реалізації бази даних, решта коду може бути використана повторно, символ до символа. Як аранжувати програму, щоб зменшити повторення коду? Як код можна зробити конфігурованим, так що ви б могли конфігурувати його з використанням любої реалізації бази даних?

Відповідь знайома: якщо модуль є об'єктом, тоді шаблоном для модуля є клас. Точно так, як клас описує загальні частини всіх своїх примірників, клас може описувати частину модуля, що є загальною для всіх можливих конфігурацій.
[source,scala]
----
abstract class Browser {
  val database: Database

  def recipesUsing(food: Food) =
    database.allRecipes.filter(recipe =>
      recipe.ingredients.contains(food))

  def displayCategory(category: database.FoodCategory) = {
    println(category)
  }
}
----
Лістинг29.6 - Клас `Browser` з абстрактною `val` бази даних.

Визначення переглядача таким чином перетворюєтья на клас, замість об'єкта, та база даних для користування задається як абстрактний член класу, як показано в Лістингу 29.6. База даних також стає класом, що включає стільки, як це можливо, загального для всіх баз даних,та декларує відсутні частини, які має визначити база даних. В цьому випадку всі модулі бази даних мають визначати методи для `allFoods`, `allRecipes` та `allCategories`, оле оскільки вони можуть використовувати довільне визначення, методи мають бути залишені абстрактними в класі `Database`. Для контрасту, метод `foodNamed`може бути визначений в абстрактному класі `Database`, як показано в Лістингу 29.7.
[source,scala]
----
abstract class Database {
  def allFoods: List[Food]
  def allRecipes: List[Recipe]

  def foodNamed(name: String) =
    allFoods.find(f => f.name == name)

  case class FoodCategory(name: String, foods: List[Food])
  def allCategories: List[FoodCategory]}
----
Лістинг 29.7 - Клас `Database` з абстрактними методами.

Об'єкт `SimpleDatabase` має бути оновлений для наслідування від абстрактного класу `Database`, як показано в Лістингу 29.8.
[source,scala]
----
object SimpleDatabase extends Database {
  def allFoods = List(Apple, Orange, Cream, Sugar)

  def allRecipes: List[Recipe] = List(FruitSalad)

  private var categories = List(
    FoodCategory("fruits", List(Apple, Orange)),
    FoodCategory("misc", List(Cream, Sugar)))

  def allCategories = categories
}
----
Лістинг 29.8 - Об'єкт `SimpleDatabase` як субклас `Database`.

Тепер окремий модуль переглядача, отриманий як примірник класу `Browser`, вказує, яку базу даних використовувати, як показано в Лістингу 29.9.
[source,scala]
----
object SimpleBrowser extends Browser {
  val database = SimpleDatabase
}
----
Лістинг 29.9 - Об'єкт `SimpleBrowser` як субклас `Browser`.

Ви можете використовувати ці більш підключувані модулі так само, як раніше:
[source,scala]
----
scala> val apple = SimpleDatabase.foodNamed("Apple").get
apple: Food = Apple

scala> SimpleBrowser.recipesUsing(apple)
res1: List[Recipe] = List(fruit salad)
----
Однак тепер ви можете створити другу мок базу даних, та використовувати з нею той самий клас переглядача, як показано в Лістингу 29.10:
[source,scala]
----
object StudentDatabase extends Database {
  object FrozenFood extends Food("FrozenFood")

  object HeatItUp extends Recipe(
    "heat it up",
    List(FrozenFood),
    "Microwave the 'food' for 10 minutes.")

  def allFoods = List(FrozenFood)
  def allRecipes = List(HeatItUp)
  def allCategories = List(
    FoodCategory("edible", List(FrozenFood)))
}

object StudentBrowser extends Browser {
  val database = StudentDatabase}
----
Лістинг 29.10 - Студентська база даних та переглядач.

29.4 Поділ модулей на трейти
----------------------------
Часто модуль дуже великий, щоб комфортабельно міститись в одному файлі. Коли це трапляється, ви можете використовувати трейти для поділу модуля на окремі файли. Наприклад, уявімо, що ви бажаєте перенести код категоризації з головного файлу `Database` до свого власного. Ви можете створити трейт для кода, як показано в Лістингу 29.11.
[source,scala]
----
trait FoodCategories {
  case class FoodCategory(name: String, foods: List[Food])
  def allCategories: List[FoodCategory]
}
----
Лістинг 29.11 - Трейт для категорій їжі.

Тепер клас `Database` може міксувати трейт `FoodCategories` замість визначення `FoodCategory` та `allCategories` самому, як показано в Лістингу 29.12:
[source,scala]
----
abstract class Database extends FoodCategories {
  def allFoods: List[Food]
  def allRecipes: List[Recipe]
  def foodNamed(name: String) =
    allFoods.find(f => f.name == name)
}
----
Лістинг 29.12 - Клас `Database`, що міксує трейт `FoodCategories`.

Ви можете спробувати, та поділити `SimpleDatabase` на два трейти, один для їжі, та один для рецептів. Це дозволить вам визначити `SimpleDatabase`, як показано в Лістингу 29.13:
[source,scala]
----
object SimpleDatabase extends Database
  with SimpleFoods with SimpleRecipes
----
Лістинг 29.13 - Об'єкт `SimpleDatabase`, повністю складений з міксінів.

Трейт `SimpleFoods` може виглядати як показано в Лістингу 29.14:
[source,scala]
----
trait SimpleFoods {
  object Pear extends Food("Pear")
  def allFoods = List(Apple, Pear)
  def allCategories = Nil
}
----
Лістинг 29.14 - Трейт `SimpleFoods`.

Доки все добре, але нажаль постає проблема, якщо ви спробуєте визначити трейт `SimpleRecipes`, ось так: 
[source,scala]
----
trait SimpleRecipes { // Не компілюється
  object FruitSalad extends Recipe(
    "fruit salad",
    List(Apple, Pear), // Uh oh
    "Mix it all together."
  )

  def allRecipes = List(FruitSalad)
}
----
Проблема в тому, що `Pear` розміщений в іншому трейті, відносно того, який його використовує, так що він за полем зору. Компілятор не має уяви, що `SimpleRecipes` ще колись буде зміксований з `SimpleFoods`.

Однак є спосіб, як ви можете сказати це компілятору. Scala провадить тип `self` саме для цієї ситуації. Технічно тип `self` є очікуваний тип для `this`, кожного разу коли `this` споминається в класі. Прагматично тип `self` вказує вимоги на кожному конкретному класі, до якого міксується цей трейт. Якщо ви маєте трейт, який використовується тільки тоді, коли міксується з іншим трейтом або трейтами, тоді ви маєте вказати, що ці інші трейти повинно мати на увазі. В цьому випадку досить задати тип `self` для `SimpleFoods`, як показано в Лістингу 29.15:
[source,scala]
----
trait SimpleRecipes {
  this: SimpleFoods =>

  object FruitSalad extends Recipe(
    "fruit salad",
    List(Apple, Pear), // Now Pear is in scope
    "Mix it all together."
  )
  def allRecipes = List(FruitSalad)
}
----
Лістинг 29.15 - Трейт `SimpleRecipes` з типом `self`.

Маючи цей новий тип `self`, `Pear` тепер доступний. Неявно посилання до `Pear` іде як `this.Pear`. Це безпечно, бо любий суцільний клас, що міксує `SimpleRecipes`, також має бути субтипом `SimpleFoods`, що означає, що `Pear` буде членом. Абстрактні субкласи та трейти не мають слідувати цьому обмеженню, але оскільки вони не можуть утворити примірники за допомогою `new`, немає ризику, що посилання `this.Pear` схибить.

29.5 Зв'язування часу виконання
-------------------------------
Модулі Scala можуть бути зв'язані разом під час виконання, та ви можете обрати, які модулі будуть зв'язуваться з якими, в залежності від обчислень часу виконання. Наприклад, Лістинг 29.16 показує малу програму, що обирає базу даних під час виконання, і потім роздруковує всі яблучні рецепти в ній:
[source,scala]
----
object GotApples {
  def main(args: Array[String]) = {
    val db: Database =
      if(args(0) == "student")
        StudentDatabase
      else
        SimpleDatabase

  object browser extends Browser {
    val database = db
  }

  val apple = SimpleDatabase.foodNamed("Apple").get

  for(recipe <- browser.recipesUsing(apple))
    println(recipe)
  }  
}
----
Лістинг 29.16 - Застосування, що динамічно обирає реалізацію модуля.

Тепер, якщо ви використовуєте базу даних `simple`, ви знайдете рецепт для фруктового салату. Якщо ви використовуєте базу даних `student`, ви взагалі не знайдете рецептів з використанням яблук:
[source,scala]
----
$ scala GotApples simple
fruit salad
$ scala GotApples student
$
----

Конфігураця за допомогою Scala кода
-----------------------------------
Ви можете здивуватись, чи ви не зповзли до проблеми жорстких посилань оригінальних прикладів в цій главі, оскільки об'єкт `GotApples`, показаний в Лістингу 29.16, містить жорсткі посилання на обох, `StudentDatabase` та `SimpleDatabase`. Тут різниця в тому, що жорсткі посилання локалізовані в одному файлі, що може бути замінений.

Кожне модулярне застосування потребує деякий спосіб вказати дійсну реалізацію модуля, що треба використовувати в певній ситуації. Ця дія "конфігурації" застосування буде по визначенню включати іменування конкретинх реалізацій модуля. Наприклад, в застосуванні Spring ви конфігуруєте через назву реалізацій в зовнішньому файлі XML. В Scala ви можете сконфігурувати через сам код Scala. Перевага використання джерела Scala над XML для конфігурації в тому, що процес виконання вашого файла конфігурації через компілятор Scala викриє любі помилки набору перед його дійсним застосуванням.

29.6 Відстеження примірників модуля
-----------------------------------
Крім використання того самого кода, різні модулі переглядача та бази даних, створені в попередньому розділі, насправді розділяють модулі. Це означає, що кожний модуль має свій власний вміст, включаючи любі вкладені класи. `FoodCategory` в `SimpleDatabase`, наприклад, інший клас від `FoodCategory` в `StudentDatabase`!
[source,scala]
----
scala> val category = StudentDatabase.allCategories.head
category: StudentDatabase.FoodCategory =
FoodCategory(edible,List(FrozenFood))

scala> SimpleBrowser.displayCategory(category)
<console>:21: error: type mismatch;
found   : StudentDatabase.FoodCategory
required: SimpleBrowser.database.FoodCategory
          SimpleBrowser.displayCategory(category)
                                        ^
----                                        
Якщо замість цього ви бажаєте, щоб всі `FoodCategorys` були тими самими, ви можете досягти цього через перемііщення визначення `FoodCategory` за межі класу або трейта. Вибір за вами, але так як воно написане, кожна `Database` отримує свій власний, унікальний клас `FoodCategory`.

Оскільки два класи `FoodCategory`, показані в цьому прикладі, насправді різні, компілятов був правий, коли скаржився. Однак іноді ви можете натрапити на випадок, коли два типа такі ж самі, але компілятор не може верифікувати їх. Ви будете бачити, що компілятор скаржиться, що два типи не однакові, однак ви, як програміст, знаеєте що це так.

В таких випадках ви можете часто полагодити проблему з використанням типів синглтонів. Наприклад, в програмі `GotApples` перевірка типів не знає, що `db` та `browser.database` такі ж самі. Це спричинить помилку типу, якщо ви спробуєте передати категорії між двома об'єктами:
[source,scala]
----
object GotApples {
  // таке саме визначення...
  for (category <- db.allCategories)
    browser.displayCategory(category)
// ...
}
GotApples2.scala:14: error: type mismatch;
found   : db.FoodCategory
required: browser.database.FoodCategory
      browser.displayCategory(category)
                              ^
one error found
----
Щоб уникнути цієї помилки вам треба поінформувати перевірку типів, що вони є тим самим об'єктом. Ви можете зробити це, змінивши визначення `browser.database`, як показано в Лістингу 29.17:
[source,scala]
----
object browser extends Browser {
  val database: db.type = db
}
----
Лістинг 29.17 - Використання типу синглтону.

Це визначення таке саме, як раніше, за винятком що `database` має дивно виглядаючий тип `db.type`. `.type` в кінці означає, що це тип синглтон. Тип синглтон екстремально специфічний, та має лише один об'єкт; в цьому випадку будь-який об'єкт, на який посилаєтся `db`. Звичайно такі типи дуже специфічні, щоб бути корисними, ось чому компілятор неохоче вставляє їх автоматично. Однак в цьому випадку тип синглтон дозволяє компілятору знати, що `db` та `browser.database` той самий об'єкт — досить інформації, щоб прибрати помилку типу.

29.7 Висновок
-------------
Ця глава показала, як використовувати об'єкти Scala як модулі. На додаток до простих статичних модулів, цей підхід надає вам різні шляхі для створення абстрактних, переналаштовуваних модулів. Існує навіть більше прийомів абстрагування, ніж показано, оскільки будь-що, що робить для класа, також робить для класа, задіяного для реалізації модуля. Як завжди, скільки з цієї потужності ви задієте має бути справою смаку.

Модулі є частиною програмування в великому, і, таким чином, з ними важко експериментувати. Вам треба велика програма, доки різниця дійсно стане помітною. Тим не менше, після читання цієї глави ви знаєте, про які можливості Scala слід згадати, коли ви бажаєте програмувати в модульному стилі. Думайте про ці прийоми, коли ви пишете ваші власні великі програми, та розпізнавайте ці шаблони прогрумавання, коли ви бачите їх в коді інших людей.
