:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

Глава 2
-------

Перші кроки в Scala
===================
Прийшов час написати деякий код на Scala. Перед тим, як ми почнемо заглиблений туторіал Scala, ми покладемо дві глави, що дасть нам більшу картину Scala, та більш важливо, дасть вам написати код. Ми закликаємо вас справді спробувати всі приклади коду, представлені в цій главі, та наступному, куди ми теж дійдемо. Простий шлях почати вивчати Scala, це програмувати на ній.

Щоб виконати приклади в цій главі, вам слідує мати стандартну інсталяцію Scala. Щоб отримати її, перейдіть до http://www.scala-lang.org/downloads та слідуйте інструкціям для своєї платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans. Для кроків в цій главі ми вважатимемо, що ви використовуєте дистрибутив Scala з scala-lang.org.footnote:[Ми тестували приклади в цій книзі на Scala версії 2.11.7.]

Якщов ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, що дозволить вам почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий матеріал може видатись вам трохи містичним. Але не хвилюйтесь. Щоб ви жваво набрали швидкість ми полишили деякі деталі. Все буде пояснене в трохи "пожарному" стилі в наступних главах. На додаток ми вставили декілька зносок в ціх наступних двох главах, що вказують вам на пізніші розділи книги, де ви знайдете більш докладні пояснення.

Крок 1. Навчаємось викорстовувати інтерпретатор Scala
----------------------------------------------------- 
Простіший спосіб розпочати зі Scala є використання інтерпретатора Scala, інтерактивної  "оболонки" для написання Scala виразів та програм. Інтерпретатор, що називається scala, буде обчислювати вирази, які ви набираєте, та друкувати отримане значення. Ви використовуєте його, набравши scala в командній підказці:footnote:[Якщо ви використовуєте Windows, вам буде треба друкувати команду scala у вікно "Command Prompt" DOS.]
----
$ scala
Welcome to Scala version 2.11.7
Type in expressions to have them evaluated.
Type :help for more information.
scala>
----
Після того, як ви наберете вираз, такий як 1 + 2, та нажмете enter:
----
scala> 1 + 2
----
Інтерпретатор надрукує:
----
res0: Int = 3
----

Цей рядок включає:

* автоматично згенероване або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає результат 0),
* дві крапки (:), за якими іде тип виразу (Int),
* знак рівнсоті (=),
* значення, отримане від обчислення виразу (3).

Тип `Int` є назвою класа `Int` в пакунку `scala`. Пакунки в Scala подібні до пакунків в Java: вони поділяють глобальний простір імен, та провадять механізм для приховування інформації.footnote:[Якщо ви не знайомі з пакунками Java, ви можете думати про них, як про впроваджене повне ім'я класу. Оскільки Int є членом пакунку scala, "Int" є простим ім'ям класу, та "scala.Int" є його повним ім'ям. Деталі щодо пакунків пояснюються в Главі 13.] Значення класу `Int` відповідають значенням `Java` `int`. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку `scala`. Наприклад, `scala.Boolean` відповідає до Java `boolean`. `scala.Float` відповідає до Java `float`. Та коли ви компілюєте ваш Scala код в байткод Java, компілятор Scala коли можливо буде використовувати примітивні типи Java, щоб надати вам переваги продуктивності примітивних типів.

Ідентифікатор `resX` може бути використаний в подальших рядках. Наприклад, оскільки res0 був встановлений в 3 до цього, res0 * 3 буде давати 9:
----
scala> res0 * 3
res1: Int = 9
----
Щоб надрукувати необхідне, але недостатнє привітання Hello, world!, наберіть:
----
scala> println("Hello, world!")
Hello, world!
----
Функція `println` друкує переданий рядок на стандартний вивід, подібно до `System.out.println` в Java.

Крок 2. Визначаємо декілька змінних
-----------------------------------
Scala має два типи змінних, `vals` та `vars`. `val` подібні до `final` змінних в Java. Коли ініціалізована, `val` ніколи не може бути перепризначеною. На відміну від цього, `var`, подібно до не-фінальної змінної в Java. `var` може бути переприсвоєна на протязі свого життя. Ось визначення `val` definition:
----
scala> val msg = "Hello, world!"
msg: String = Hello, world!
----
Це твордження вводить `msg` як ім'я для рядка "Hello, world!". Тип `msg` є `java.lang.String`, оскільки рядки в `Scala` реалізовані через клас Java `String`.

Якщо ви визначали змінні в Java, ви зауважили тут одну вбивчу різницю: ані `java.lang.String`, ані `String` не з'являються ніде в визначенні `val`. Цей приклад ілюструє вивід типу, здатність Scala здогадуватись про типи, які ви оминули. В цьому випадку, оскільки ініціалізували `msg` рядковим літералом, Scala виводить тип `msg` як `String`. Коли інтерпретатор Scala (або компілятор) може вивести це, часто є кращим дозволити йому зробити це, ніж заповнювати код непотрібними, явними анотаціями типів. Однак ви можете вказати тип явно, якщо бажаєте, та іноді ви, вірогідно, повинні. Явна анотація типу може одночасно переконатись, що компілятор Scala виводить типи як задумано, і так само прислужитись в якості корисної документації для майбутніх читачів коду. На відміну від Java, коли ви вказуєте тип змінної перед її ім'ям, в Scala ви вказуєте тип змінної після її ім'ям, відокремлений двома крапками. Наприклад:
----
scala> val msg2: java.lang.String = "Hello again, world!"
msg2: String = Hello again, world!
----
Або, оскільки типи `java.lang` видимі в частині простих імен для програм Scala, просто:footnote:[Просте ім'я java.lang.String є String.]
----
scala> val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!
----
Переходя до оригінального `msg`, тепер, коли вона визначена, ви можете використовувати її як очікується, наприклад:
----
scala> println(msg)
Hello, world!
----
Що ви не можете робити з `msg`, зважаючи що вона `val`, не `var`, це переприсвоїти її.footnote:[Однак в інтерпретаторі ви можете визначити нове val з іменем, що вже використовувалось до цього. Цей механізм пояснено в Розділі 7.7.] Наприклад, дивіться, як інтерпретатор скаржиться, коли ви намагаєтесь зробити наступне:
----
scala> msg = "Goodbye cruel world!"
<console>:8: error: reassignment to val
msg = "Goodbye cruel world!"
^
----
Якщо переприсвоєння саме те, чого ви бажаєте, вам треба вкористовувати `var`, як тут:
----
scala> var greeting = "Hello, world!"
greeting: String = Hello, world!
----
Оскільки `greeting` є `var` а не `val`, ви можете переприсвоїти її пізніше. Якщо ви пізнаше будете почуватись буркотливим, ви можете, наприклад, змінити ваше привітання на таке:
----
scala> greeting = "Leave me alone, world!"
greeting: String = Leave me alone, world!
----
Щоб ввести щось в інтерпретатор, що займатиме декілька рядків, просто продовжуйте друкувати доки не скінчите, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.
----
scala> val multiLine =
|
"This is the next line."
multiLine: String = This is the next line.
----
Якщо ви зрозуміли, що набрали щось невірно, але інтерпретатор ще чекає для додаткового вводу, ви можете вийти, натиснувши enter двічі:
----
scala> val oops =
|
|
You typed two blank lines.
Starting a new command.
scala>
----
В залишку книги ми полишимо вертикальні стовпчики, щоб зробити код простішим для читання (та простіше копіювати та вставляти з PDF eBook в інтерпретатор).

Крок 3. Визначаємо деякі функції
--------------------------------
Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:
----
scala> def max(x: Int, y: Int): Int = {
  if (x > y) x
  else y
}
max: (x: Int, y: Int)Int
----
Визначення функцій починається з `def`. Ім'я функції, в нашому випадку `max`, за яким слідує розділений комами список параметрі в дужках. Анотація типу має слідувати за кожним параметром функції черед дві крапки, оскільки компілятор Scala (і інтерпретатор, вле відтепер ми будемо казати тільки компілятор) не виводить типи параметрів функцій. В цьому прикладі функція на ім'я `max` приймає два параметри, `x` та `y`, обоє типу `Int`. Після того, як ви закрили дужки списку параметрів `max`, ви знайдете інішу анотацію типу `: Int`. Це визначає тип результату самої функції `max`.footnote:[В Java тип значення, що повертається з метода, є його типом повернення. В Scala та сама концепція називається типом результата.] За типом результату іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить один вираз `if`, що обирає або `x` або `y`, що більше, як результат функції `max`. Як продемонстровано тут, в Scala `if` вираз може видавати значення, подібно то тримісного оператора в Java. Наприклад, вираз Scala  `if (x > y) x else y` поводить себе подібно до `(x > y) ? x : y` в Java. Знак рівності, що стоїть перед тілом функції, дає підказку, що з точки зору функціонального світу, функція визначає вираз, що видає значення. Базова структура функції ілюстрована на Малюнку 2.1.

Малюнок 2.1 - базова форма визначення функції в Scala.

Іноді компілятор Scala буде потребувати, щоб ви вказували тип результату функції. Якщо функція рекурсивна,footnote:[Функція називається рекурсивною, якщо вона викликає сама себе.] наприклад, ви маєте явно вказати тип результату функції. Однак в випадку `max` ви можете випустити тип результату, і компілятор буде виводити його.footnote:[Тим не менш, часто є гарною ідеєю вказати тип результата функції явно, навіть коли компілятор не потребує цього. Така анотація типу може зробити код простішим до читання, оскільки читач на повинен вивчати тіло функції, щоб з'ясувати виведений тип результата.] Також, якщо функція складається тільки з одного твердження, ви можете опціонально випустити і фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:
----
scala> def max(x: Int, y: Int) = if (x > y) x else y
max: (x: Int, y: Int)Int
----
Коли ви визначили функцію, ви можете викликати її:
----
scala> max(3, 5)
res4: Int = 5
----
Ось визначення функції, що не приймає параметрів, та не повертає цікавих результатів:
----
scala> def greet() = println("Hello, world!")
greet: ()Unit
----
Коли ви визначаєте функцію `greet()`, інтерпретатор буде відповідати `greet: ()Unit`.  "greet" є, звичайно, іменем функції. Порожні дужки вказують, що функція не сприймає параметрів. Та `Unit` є тип повернення `greet`. Тип результата `Unit` вказує, що функція не повертає цікавих значень. Тип Scala `Unit` подібний на тип Java `void`; фактично, кожинй метод, що повертає в Java `void`, відзеркалюється на метод Scala, що повертає `Unit`. Методи з типом результата `Unit`, таким чином, виконуються тільки для заради їх побічних ефектів. В випадку greet(), побічний ефект є дружнє привітання, роздруковане на стандартний вихід.

На наступному кроці ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, ввівші :quit або :q.
----
scala> :quit
$
----

Крок 4. Пишемо деякі Scala скрипти
----------------------------------
Хоча Scala розроблена допомогти в побудові дуже велико-маштабованих систем, вона також гарно маштабується донизу до скриптинга. Скрипт це тільки послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть це в файл з назвою `hello.scala`:
----
println("Hello, world, from a script!")
----
потім виконайте:footnote:[Ви можете виконати скрипт без набирання "scala" під Unix та Windows, використовуючи синтаксис "pound-bang", що показаний в Додатку A.]
----
$ scala hello.scala
----
Та ви маєте отримати наступне привітання:
----
Hello, world, from a script!
----
Аргументи командного рядка скрипта Scala доступні через масив Scala з назвою `args`. В Scala масиви починаються з нуля, та ви отримуєте доступ до елементів через вказання індексу в дужкає. Так що перший елемент в масиві Scala з назвою `steps` є `steps(0)`, не `steps[0]`, як в Java. Щоб спробувати це, наберіть наступне в новий файл з назвою `helloarg.scala`:
----
// Say hello to the first argument
println("Hello, " + args(0) + "!")
----
потім виконайте:
----
$ scala helloarg.scala planet
----
В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як `args(0)`. Таким чином ви можете побачити:
----
Hello, planet!
----
Зауважте, що цей скрипт містить коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та любі символи між /* та */. Цей приклад також показує, як рядки конкатенуються (поєднуються) за допомогою оператора + . Це робить як ви очікуєте. Вираз "Hello, " + "world!" призведе до рядка "Hello, world!".

Крок 5. Цикл з while; рішення з if
----------------------------------
Щоб спробувати `while`, наберіть наступне в файл на ім'я `printargs.scala`:
[source,scala]
----
var i = 0
while (i < args.length) {
  println(args(i))
  i += 1
}
----
NOTE: Хоча приклади в цьому розділі допомагають зрозуміти цикли `while`, вони не демонструють кращий стиль Scala. В настурному розділі ви побачите кращі підходи уникнути ітерації по масивах за допомогою індексів.

Цей скрипт починається з визначення змінної `var i = 0`. Вивід типів надає `i` тип  `scala.Int`, оскільки це тип початкового значення, 0. Конструкція `while` в наступному рядку призводить до того, що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз `i < args.length` буде `false`. `args.length` дає довжину масива `args`. Блок містить два твердження, кожне зсунуте на два проміжки, рекомендований відступ в Scala. Перше твердження, `println(args(i))`, друкує i-тий аргумент командного рядка. Наступне твердження, `i += 1`, інкрементує (збільшує) i на один. Зауважте, що відомі з Java ++i та i++ не роблять в Scala. Щоб виконати інкремент в Scala, вам треба сказати або i = i + 1 або i += 1. Виконайте цей скрипт за допомогою наступної команди:
----
$ scala printargs.scala Scala is fun
----
Ви маєте побачити:
----
Scala
is
fun
----
Для ще більшої розваги наберіть наступний код в файлі на ім'я `echoargs.scala`:
[source,scala]
----
var i = 0
while (i < args.length) {
  if (i != 0)
    print(" ")
  print(args(i))
  i += 1
}
println()
----
В цій версії ми замінили виклик `println` на виклик `print`, так що всі ці аргументи будуть друкуватись на тому самому рядку. Щоб зробите читабельним, ви вставляєте один проміжок перед кожним аргументом, за винятком першого, через конструкцію `if (i != 0)`. Оскільки `i != 0` буде `false` перший раз, коли ви проходите через цикл, проміжок не буде надрукований перед першим аргументом. Нарешті, ви додали ще один `println` в кінці, щоб отримати перевод рядка після друку всіх аргументів. Ваш вивід тепер є досить гарним. Якщо ви виконаєте цей скрипт за допомогою такої команди:
----
$ scala echoargs.scala Scala is even more fun
----
Ви отримаєте:
----
Scala is even more fun
----
Зауважте, що в Scala, як і в Java, ви маєте покладати логічні вирази для `while` або для `if` в дужки. (Іншими словами, ви не можете сказати в Scala речі як `if i < 10`, як ви можете в таких мовах, як Ruby. Ви маєте сказати `if (i < 10)` в Scala). Інша подібність до Java в тому, що коли блок `if` має тільки одне твердження, ви можете опціонально випустити фігурні дужки, як демонструєтсья твердженням `if` в `echoargs.scala`. І хоча ми не бачили жодної з них, Scala використовує крапку з комою для розділення тверджень, як і Java, за тим винятком, що в Scala кома з крапкою дуже часто опціональна, що дає деяке розслаблення мізинцю правої руки. Однак якщо ви перебуваєте в дещо більш балакучому настрої, ви можете записати скрипт `echoargs.scala` наступним чином:
[source,scala]
----
var i = 0;
while (i < args.length) {
  if (i != 0) {
    print(" ");
  }
  print(args(i));
  i += 1;
}
println();
----

Крок 6. Ітеруємо за допомогою foreach та for
--------------------------------------------
Хоча ви можете не уявляти цього, коли ви пишете цикли `while` в попередньому кроці, ви програмуєте в імперативному стилі. В вмперативному стилі, що є стилам, який ви звичайно використовуєте з мовами як Java, C++ та C, ви видаєте одну імперативну команду за раз, ітеруючи за допомогою циклів, та часто змінюєте стан, загальний для різних функцій. Scala дозволяє вам програмувати імперативно, але коли ви будете знати Scala краще, ви будете частіше знаходити себе за програмуванням в більш функціональному стилі. Фактично, одна з головних цілей цієї книги є допомогти вам стати так само комфортним з функціональним стилем, як вам є з імперативним стилем.

Одна з головних характеристик функціональної мови в тому, що функції є першокласними конструкціями, і це є дуже вірно в Scala. Наприклад, інший (значно більше стислий) шлях надрукувати кожний аргумент командного рядка:
[source,scala]
----
args.foreach(arg => println(arg))
----
В цьому коді ви викликаєте метод foreach на `args`, та передаєте йому функію. В цьому випадку ви передаєте функціональний літерал, що приймає один параметр на ім'я `arg`. Тілом функції є `println(arg)`. Якщо ви наберете код вище в новий файл з назвою `pa.scala` та виконаєте його командою:
----
$ scala pa.scala Concise is nice
----
Ви можете побачили:
----
Concise
is
nice
----
В попередньому прикладі інтерпретатор Scala виводить тип `arg` як `String`, оскільки `String` є типом елементів масива, для якого ми викликаємо foreach. Якщо ви схильні бути більш явним, ви можете вказати ім'я типу. Але коли ви зробите це, вам доведеться огорнути аргумент в дужки (що є нормальною формою синтаксиса в жодному разі):
----
args.foreach((arg: String) => println(arg))
----
Виконання цього скрипта має ту саму поведінку, що і попереднього.

Якщо ви в настрої бути трохи стислішим, ніж більш явним, ви можете отримати перевагу від спеціалного скорочення в Scala. Якщо функціональний літерал складається з одного твердження, що приймає один аргумент, вам не треба явно називати та сказувати аргумент.footnote:[Це скорочення, що називається частково визначеною функцією, описане в Розділі 8.6.] Таким чином, наступний код також робить:
----
args.foreach(println)
----
Щоб підсумувати, синтаксис для функціонального літерала є список іменованих параметрів в дужках, стрілка вправо, та потім тіло функції. Синтаксис проілюстрований на Малюнку 2.2.

Малюнок 2.2 - Синтаксис функціонального літерала в Scala.

Тепер, в цій точці ви можете здивуватись, що трапилось з тіми надійними циклами `for`, до яких ви звикли при використанні імперативних мов, таких як Java або C. В спробі спрямувати вас в функціональному напрямку, в Scala доступний тільки функціональний родич  `for` (що називається виразом `for`). Хоча ви не побачите його повної потужності та виразності, доки не досягнете (або не заглянете наперед) Розділ 7.3, ми дамо вам побіжний погляд. В новому файлі на ім'я `forargs.scala` наберіть наступне:
[source,scala]
----
for (arg <- args)
  println(arg)
----
Дужки після `for` містять `arg <- args`.footnote:[Ви можете казати "в" для символа <- . Ви будете читати for (arg <- args), таким чином, як "для arg в args."] Зправа від символа `<-` є знакомий масив `args`. Зліва від `<-` є `arg`, ім'я `val`, не `var`. (Оскільки це завжди `val`, ви просто пишете один `arg`, не `val arg`). Хоча `arg` може виглядати як `var`, оскільки вона буде отримувати нове значення на кожній ітерації, насправді це `val`: `arg` не може бути переприсвоєний в тілі виразу. Замість цього, для кожного елементу масива `args` буде створений новий `val arg` та ініціалізований значенням елемента. Після чого буде виконане тіло `for`.

Якщо ви виконаєте скрипт `forargs.scala` командою:
----
$ scala forargs.scala for arg in args
----
Ви побачите:
----
for
arg
in
args
----
Вираз `for` в Scala може робити набагато більше ніж це, але цей приклад достатнім для початку. Ми покажемо вам більше щодо `for` в Розділі 7.3 та Главі 23.

Висновок
--------
В цій главі ми вивчили деякі основи Scala, та, надіємось, скористались можливостю написати трохи Scala коду. В наступній главі мо продовжимо цей вступний огляд, та займемось більш складними темами.
