:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

Глава 2
-------

Перші кроки в Scala
===================
Прийшов час написати деякий код на Scala. Перед тим, як ми почнемо заглиблений туторіал Scala, ми покладемо дві глави, що дасть нам більшу картину Scala, та більш важливо, дасть вам написати код. Ми закликаємо вас справді спробувати всі приклади коду, представлені в цій главі, та наступному, куди ми теж дійдемо. Простий шлях почати вивчати Scala, це програмувати на ній.

Щоб виконати приклади в цій главі, вам слідує мати стандартну інсталяцію Scala. Щоб отримати її, перейдіть до http://www.scala-lang.org/downloads та слідуйте інструкціям для своєї платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans. Для кроків в цій главі ми вважатимемо, що ви використовуєте дистрибутив Scala з scala-lang.org.footnote:[Ми тестували приклади в цій книзі на Scala версії 2.11.7.]

Якщов ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, що дозволить вам почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий матеріал може видатись вам трохи містичним. Але не хвилюйтесь. Щоб ви жваво набрали швидкість ми полишили деякі деталі. Все буде пояснене в трохи "пожарному" стилі в наступних главах. На додаток ми вставили декілька зносок в ціх наступних двох главах, що вказують вам на пізніші розділи книги, де ви знайдете більш докладні пояснення.

Крок 1. Навчаємось викорстовувати інтерпретатор Scala
----------------------------------------------------- 
Простіший спосіб розпочати зі Scala є використання інтерпретатора Scala, інтерактивної  "оболонки" для написання Scala виразів та програм. Інтерпретатор, що називається scala, буде обчислювати вирази, які ви набираєте, та друкувати отримане значення. Ви використовуєте його, набравши scala в командній підказці:footnote:[Якщо ви використовуєте Windows, вам буде треба друкувати команду scala у вікно "Command Prompt" DOS.]
----
$ scala
Welcome to Scala version 2.11.7
Type in expressions to have them evaluated.
Type :help for more information.
scala>
----
Після того, як ви наберете вираз, такий як 1 + 2, та нажмете enter:
----
scala> 1 + 2
----
Інтерпретатор надрукує:
----
res0: Int = 3
----

Цей рядок включає:

* автоматично згенероване або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає результат 0),
* дві крапки (:), за якими іде тип виразу (Int),
* знак рівнсоті (=),
* значення, отримане від обчислення виразу (3).

Тип `Int` є назвою класа `Int` в пакунку `scala`. Пакунки в Scala подібні до пакунків в Java: вони поділяють глобальний простір імен, та провадять механізм для приховування інформації.footnote:[Якщо ви не знайомі з пакунками Java, ви можете думати про них, як про впроваджене повне ім'я класу. Оскільки Int є членом пакунку scala, "Int" є простим ім'ям класу, та "scala.Int" є його повним ім'ям. Деталі щодо пакунків пояснюються в Главі 13.] Значення класу `Int` відповідають значенням `Java` `int`. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку `scala`. Наприклад, `scala.Boolean` відповідає до Java `boolean`. `scala.Float` відповідає до Java `float`. Та коли ви компілюєте ваш Scala код в байткод Java, компілятор Scala коли можливо буде використовувати примітивні типи Java, щоб надати вам переваги продуктивності примітивних типів.

Ідентифікатор `resX` може бути використаний в подальших рядках. Наприклад, оскільки res0 був встановлений в 3 до цього, res0 * 3 буде давати 9:
----
scala> res0 * 3
res1: Int = 9
----
Щоб надрукувати необхідне, але недостатнє привітання Hello, world!, наберіть:
----
scala> println("Hello, world!")
Hello, world!
----
Функція `println` друкує переданий рядок на стандартний вивід, подібно до `System.out.println` в Java.

Крок 2. Визначаємо декілька змінних
-----------------------------------
Scala має два типи змінних, `vals` та `vars`. `val` подібні до `final` змінних в Java. Коли ініціалізована, `val` ніколи не може бути перепризначеною. На відміну від цього, `var`, подібно до не-фінальної змінної в Java. `var` може бути переприсвоєна на протязі свого життя. Ось визначення `val` definition:
----
scala> val msg = "Hello, world!"
msg: String = Hello, world!
----
Це твордження вводить `msg` як ім'я для рядка "Hello, world!". Тип `msg` є `java.lang.String`, оскільки рядки в `Scala` реалізовані через клас Java `String`.

Якщо ви визначали змінні в Java, ви зауважили тут одну вбивчу різницю: ані `java.lang.String`, ані `String` не з'являються ніде в визначенні `val`. Цей приклад ілюструє вивід типу, здатність Scala здогадуватись про типи, які ви оминули. В цьому випадку, оскільки ініціалізували `msg` рядковим літералом, Scala виводить тип `msg` як `String`. Коли інтерпретатор Scala (або компілятор) може вивести це, часто є кращим дозволити йому зробити це, ніж заповнювати код непотрібними, явними анотаціями типів. Однак ви можете вказати тип явно, якщо бажаєте, та іноді ви, вірогідно, повинні. Явна анотація типу може одночасно переконатись, що компілятор Scala виводить типи як задумано, і так само прислужитись в якості корисної документації для майбутніх читачів коду. На відміну від Java, коли ви вказуєте тип змінної перед її ім'ям, в Scala ви вказуєте тип змінної після її ім'ям, відокремлений двома крапками. Наприклад:
----
scala> val msg2: java.lang.String = "Hello again, world!"
msg2: String = Hello again, world!
----
Або, оскільки типи `java.lang` видимі в частині простих імен для програм Scala, просто:footnote:[Просте ім'я java.lang.String є String.]
----
scala> val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!
----
Переходя до оригінального `msg`, тепер, коли вона визначена, ви можете використовувати її як очікується, наприклад:
----
scala> println(msg)
Hello, world!
----
Що ви не можете робити з `msg`, зважаючи що вона `val`, не `var`, це переприсвоїти її.footnote:[Однак в інтерпретаторі ви можете визначити нове val з іменем, що вже використовувалось до цього. Цей механізм пояснено в Розділі 7.7.] Наприклад, дивіться, як інтерпретатор скаржиться, коли ви намагаєтесь зробити наступне:
----
scala> msg = "Goodbye cruel world!"
<console>:8: error: reassignment to val
msg = "Goodbye cruel world!"
^
----
Якщо переприсвоєння саме те, чого ви бажаєте, вам треба вкористовувати `var`, як тут:
----
scala> var greeting = "Hello, world!"
greeting: String = Hello, world!
----
Оскільки `greeting` є `var` а не `val`, ви можете переприсвоїти її пізніше. Якщо ви пізнаше будете почуватись буркотливим, ви можете, наприклад, змінити ваше привітання на таке:
----
scala> greeting = "Leave me alone, world!"
greeting: String = Leave me alone, world!
----
Щоб ввести щось в інтерпретатор, що займатиме декілька рядків, просто продовжуйте друкувати доки не скінчите, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.
----
scala> val multiLine =
|
"This is the next line."
multiLine: String = This is the next line.
----
Якщо ви зрозуміли, що набрали щось невірно, але інтерпретатор ще чекає для додаткового вводу, ви можете вийти, натиснувши enter двічі:
----
scala> val oops =
|
|
You typed two blank lines.
Starting a new command.
scala>
----
В залишку книги ми полишимо вертикальні стовпчики, щоб зробити код простішим для читання (та простіше копіювати та вставляти з PDF eBook в інтерпретатор).

Крок 3. Визначаємо деякі функції
--------------------------------
Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:
----
scala> def max(x: Int, y: Int): Int = {
  if (x > y) x
  else y
}
max: (x: Int, y: Int)Int
----
Визначення функцій починається з `def`. Ім'я функції, в нашому випадку `max`, за яким слідує розділений комами список параметрі в дужках. Анотація типу має слідувати за кожним параметром функції черед дві крапки, оскільки компілятор Scala (і інтерпретатор, вле відтепер ми будемо казати тільки компілятор) не виводить типи параметрів функцій. В цьому прикладі функція на ім'я `max` приймає два параметри, `x` та `y`, обоє типу `Int`. Після того, як ви закрили дужки списку параметрів `max`, ви знайдете інішу анотацію типу `: Int`. Це визначає тип результату самої функції `max`.footnote:[В Java тип значення, що повертається з метода, є його типом повернення. В Scala та сама концепція називається типом результата.] За типом результату іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить один вираз `if`, що обирає або `x` або `y`, що більше, як результат функції `max`. Як продемонстровано тут, в Scala `if` вираз може видавати значення, подібно то тримісного оператора в Java. Наприклад, вираз Scala  `if (x > y) x else y` поводить себе подібно до `(x > y) ? x : y` в Java. Знак рівності, що стоїть перед тілом функції, дає підказку, що з точки зору функціонального світу, функція визначає вираз, що видає значення. Базова структура функції ілюстрована на Малюнку 2.1.

Малюнок 2.1 - базова форма визначення функції в Scala.

Іноді компілятор Scala буде потребувати, щоб ви вказували тип результату функції. Якщо функція рекурсивна,footnote:[Функція називається рекурсивною, якщо вона викликає сама себе.] наприклад, ви маєте явно вказати тип результату функції. Однак в випадку `max` ви можете випустити тип результату, і компілятор буде виводити його.footnote:[Тим не менш, часто є гарною ідеєю вказати тип результата функції явно, навіть коли компілятор не потребує цього. Така анотація типу може зробити код простішим до читання, оскільки читач на повинен вивчати тіло функції, щоб з'ясувати виведений тип результата.] Також, якщо функція складається тільки з одного твердження, ви можете опціонально випустити і фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:
----
scala> def max(x: Int, y: Int) = if (x > y) x else y
max: (x: Int, y: Int)Int
----
Коли ви визначили функцію, ви можете викликати її:
----
scala> max(3, 5)
res4: Int = 5
----
Ось визначення функції, що не приймає параметрів, та не повертає цікавих результатів:
----
scala> def greet() = println("Hello, world!")
greet: ()Unit
----
Коли ви визначаєте функцію `greet()`, інтерпретатор буде відповідати `greet: ()Unit`.  "greet" є, звичайно, іменем функції. Порожні дужки вказують, що функція не сприймає параметрів. Та `Unit` є тип повернення `greet`. Тип результата `Unit` вказує, що функція не повертає цікавих значень. Тип Scala `Unit` подібний на тип Java `void`; фактично, кожинй метод, що повертає в Java `void`, відзеркалюється на метод Scala, що повертає `Unit`. Методи з типом результата `Unit`, таким чином, виконуються тільки для заради їх побічних ефектів. В випадку greet(), побічний ефект є дружнє привітання, роздруковане на стандартний вихід.

На наступному кроці ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, ввівші :quit або :q.
----
scala> :quit
$
----

Крок 4. Пишемо деякі Scala скрипти
----------------------------------
Хоча Scala розроблена допомогти в побудові дуже велико-маштабованих систем, вона також гарно маштабується донизу до скриптинга. Скрипт це тільки послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть це в файл з назвою `hello.scala`:
----
println("Hello, world, from a script!")
----
потім виконайте:footnote:[Ви можете виконати скрипт без набирання "scala" під Unix та Windows, використовуючи синтаксис "pound-bang", що показаний в Додатку A.]
----
$ scala hello.scala
----
Та ви маєте отримати наступне привітання:
----
Hello, world, from a script!
----
Аргументи командного рядка скрипта Scala доступні через масив Scala з назвою `args`. В Scala масиви починаються з нуля, та ви отримуєте доступ до елементів через вказання індексу в дужкає. Так що перший елемент в масиві Scala з назвою `steps` є `steps(0)`, не `steps[0]`, як в Java. Щоб спробувати це, наберіть наступне в новий файл з назвою `helloarg.scala`:
----
// Say hello to the first argument
println("Hello, " + args(0) + "!")
----
потім виконайте:
----
$ scala helloarg.scala planet
----
В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як `args(0)`. Таким чином ви можете побачити:
----
Hello, planet!
----
Зауважте, що цей скрипт містить коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та любі символи між /* та */. Цей приклад також показує, як рядки конкатенуються (поєднуються) за допомогою оператора + . Це робить як ви очікуєте. Вираз "Hello, " + "world!" призведе до рядка "Hello, world!".

Крок 5. Цикл з while; рішення з if
----------------------------------
Щоб спробувати `while`, наберіть наступне в файл на ім'я `printargs.scala`:
----
var i = 0
while (i < args.length) {
  println(args(i))
  i += 1
}
----
NOTE: Хоча приклади в цьому розділі допомагають зрозуміти цикли `while`, вони не демонструють кращий стиль Scala. В настурному розділі ви побачите кращі підходи уникнути ітерації по масивах за допомогою індексів.

Цей скрипт починається з визначення змінної `var i = 0`. Вивід типів надає `i` тип  `scala.Int`, оскільки це тип початкового значення, 0. Конструкція `while` в наступному рядку призводить до того, що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз `i < args.length` буде `false`. `args.length` дає довжину масива `args`. Блок містить два твердження, кожне зсунуте на два проміжки, рекомендований відступ в Scala. Перше твердження, `println(args(i))`, друкує i-тий аргумент командного рядка. Наступне твердження, `i += 1`, інкрементує (збільшує) i на один. Зауважте, що відомі з Java ++i та i++ не роблять в Scala. Щоб виконати інкремент в Scala, вам треба сказати або i = i + 1 або i += 1. Виконайте цей скрипт за допомогою наступної команди:
----
$ scala printargs.scala Scala is fun
----
Ви маєте побачити:
----
Scala
is
fun
----
For even more fun, type the following code into a new file with the name echoargs.scala:
----
var i = 0
while (i < args.length) {
  if (i != 0)
    print(" ")
  print(args(i))
  i += 1
}
println()
----
In this version, you've replaced the println call with a print call, so that all the arguments will be printed out on the same line. To make this readable, you've inserted a single space before each argument except the first via the if (i != 0) construct. Since i != 0 will be false the first time through the while loop, no space will get printed before the initial argument. Lastly, you've added one more println to the end, to get a line return after printing out all the arguments. Your output will be very pretty indeed. If you run
this script with the following command:
----
$ scala echoargs.scala Scala is even more fun
----
You'll get:
----
Scala is even more fun
----
Note that in Scala, as in Java, you must put the boolean expression for a while or an if in parentheses. (In other words, you can't say in Scala things like if i < 10 as you can in a language such as Ruby. You must say if (i < 10) in Scala.) Another similarity to Java is that if a block has only one statement, you can optionally leave off the curly braces, as demonstrated by the if statement in echoargs.scala. And although you haven't seen any of them, Scala does use semicolons to separate statements as in Java, except that in Scala the semicolons are very often optional, giving some welcome relief to your right little finger. If you had been in a more verbose mood, therefore, you could have written the echoargs.scala script as follows:
----
var i = 0;
while (i < args.length) {
  if (i != 0) {
    print(" ");
  }
  print(args(i));
  i += 1;
}
println();
----

Крок 6. Ітеруємо за допомогою foreach та for
--------------------------------------------
Although you may not have realized it, when you wrote the while loops in the previous step, you were programming in an imperative style. In the imperative style, which is the style you normally use with languages like Java, C++, and C, you give one imperative command at a time, iterate with loops, and often mutate state shared between different functions. Scala enables you to program imperatively, but as you get to know Scala better, you'll likely often find yourself programming in a more functional style. In fact, one of the main aims of this book is to help you become as comfortable with the functional style as you are with imperative style.

One of the main characteristics of a functional language is that functions are first class constructs, and that's very true in Scala. For example, another (far more concise) way to print each command line
argument is:
----
args.foreach(arg => println(arg))
----
In this code, you call the foreach method on args and pass in a function. In this case, you're passing in a function literal that takes one parameter named arg. The body of the function isprintln(arg). If you type the above code into a new file named pa.scala and execute with the command:
----
$ scala pa.scala Concise is nice
----
You should see:
----
Concise
is
nice
----
In the previous example, the Scala interpreter infers the type of arg to be String, since String is the element type of the array on which you're calling foreach. If you'd prefer to be more explicit, you can mention the type name. But when you do, you'll need to wrap the argument portion in parentheses (which is the normal form of the syntax anyway):
----
args.foreach((arg: String) => println(arg))
----
Running this script has the same behavior as the previous one.

If you're in the mood for more conciseness instead of more explicitness, you can take advantage of a special shorthand in Scala. If a function literal consists of one statement that takes a single argument, you need not explicitly name and specify the argument.footnote:[Це скорочення, що називається частково визначеною функцією, описане в Розділі 8.6.] Thus, the following code also works:
----
args.foreach(println)
----
To summarize, the syntax for a function literal is a list of named parameters, in parentheses, a right arrow, and then the body of the function. This syntax is illustrated in Figure 2.2.

Figure 2.2 - The syntax of a function literal in Scala.

Now, by this point you may be wondering what happened to those trusty for loops you have been accustomed to using in imperative languages, such as Java or C. In an effort to guide you in a functional direction, only a functional relative of the imperative for (called a forexpression) is available in Scala. While you won't see their full power and expressiveness until you reach (or peek ahead to) Section 7.3, we'll give you a glimpse here. In a new file named forargs.scala, type the following:
----
for (arg <- args)
  println(arg)
----
The parentheses after the "for" contain arg <- args.footnote:[Ви можете казати "в" для символа <- . Ви будете читати for (arg <- args), таким чином, як "для arg в args."] To the right of the <- symbol is the familiar args array. To the left of <- is "arg", the name of a val, not a var. (Because it is always aval, you just write "arg" by itself, not "val arg".) Although arg may seem to be a var, because it will get a new value on each iteration, it really is a val: arg can't be reassigned inside the body of the for expression. Instead, for each element of the args array, a new arg val will be created and initialized to the element value, and the body of the for will be executed.

If you run the forargs.scala script with the command:
----
$ scala forargs.scala for arg in args
----
You'll see:
----
for
arg
in
args
----
Scala's for expression can do much more than this, but this example is enough to get you started. We'll show you more about for in Section 7.3 and Chapter 23.

Висновок
--------
In this chapter, you learned some Scala basics and, hopefully, took advantage of the opportunity to write a bit of Scala code. In the next chapter, we'll continue this introductory overview and get into more advanced topics.
