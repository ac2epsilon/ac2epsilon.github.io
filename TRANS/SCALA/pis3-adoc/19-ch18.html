<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__18">Глава 18</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Змінні об'єкти</h1>
<div class="paragraph"><p>В попередньому розділі ми звернули увагу на функціональні (незмінні) об'єкти. Ми зробили це, оскільки ідея об'єктів без жодного змінного стану заслуговує бути краще відомою. Однак це також чудово можливо визначати в Scala об'єкти зі змінним станом. Такі змінні об'єкти часто спливають природно, коли ви бажаєте змоделювати об'єкти в реальному світі, що змінюються з часом.</p></div>
<div class="paragraph"><p>Ця глава пояснює, що таке змінні об'єкти, та що провадить Scala в термінах синтаксису для їх вираження. Ми також введемо більше дослідження симуляції дискретних подій, що включатиме змінні об'єкти, так само, як побудову внутрішнього DSL для визначення цифрових схем для симуляції.</p></div>
<div class="sect1">
<h2 id="_18_1_____">18.1 Що робить об'єкт змінним?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете спостерігати принципову різницю між чисто функціональним об'єктом і змінним об'єктом, навіть без погляду на реалізацію об'єкта. Коли ви викликаєте метод або отримуєте поле на деякому функціональному об'єкті, ви будете завжди отримувати один той самий результат.</p></div>
<div class="paragraph"><p>Наприклад, беручи список символів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="sc">&#39;c&#39;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>застовування <code>cs.head</code> буде завжди повертати <code>'a'</code>. Це буде саме так, навіть якщо відбудеться довільне число операцій зі списком <code>cs</code> між місцем, де він визначений, та місцем, де відбувається доступ до <code>cs.head</code>.</p></div>
<div class="paragraph"><p>З іншого боку, для зміноого об'єкту результат виклику метода або доступ до поля може залежати  від того, які операції до цього застосовувались до об'єкту. Гарний приклад змінного об'єкту є банківській рахунок. Лістинг 18.1 показує спрощену реалізацію банківського рахунку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BankAccount</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">bal</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">balance</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">bal</span>

  <span class="k">def</span> <span class="n">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">bal</span> <span class="o">+=</span> <span class="n">amount</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="n">bal</span><span class="o">)</span> <span class="kc">false</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="n">bal</span> <span class="o">-=</span> <span class="n">amount</span>
      <span class="kc">true</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.1 - Змінний клас банківського рахунку.</p></div>
<div class="paragraph"><p>Клас <code>BankAccount</code> визначає приватну змінну, <code>bal</code>, і три публічні методи: <code>balance</code> повертає поточний баланс; <code>deposit</code> додає сумму до <code>bal</code>; та <code>withdraw</code> намагається списати надану сумму з <code>bal</code>, при цьому вважаючи, що залишковий баланс не буде від'ємним. Значення, що повертає <code>withdraw</code>, є <code>Boolean</code>, вказуючи, чи запитані фонди були вдало списані.</p></div>
<div class="paragraph"><p>Навіть якщо ми нічого не знаємо про внутрішню роботу класу <code>BankAccount</code>, ви все ще можете сказати, що <code>BankAccounts</code> є змінними об'єкти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">account</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="n">account</span><span class="k">:</span> <span class="kt">BankAccount</span> <span class="o">=</span> <span class="nc">BankAccount</span><span class="k">@</span><span class="mi">21</span><span class="n">cf775d</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">account</span> <span class="n">deposit</span> <span class="mi">100</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">account</span> <span class="n">withdraw</span> <span class="mi">80</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">account</span> <span class="n">withdraw</span> <span class="mi">80</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що два останні списання в попередній взаємодії повернули різні результати. Перша операція списання повернула <code>true</code>, оскільки банківський рахунок містив достатньо коштів, щоб дозволити списання. Друга операція, хоча така сама, як і перша, повертає <code>false</code>, оскільки баланс на рахунку було зменшено, так що він більше не покриває запитані кошти. Так що, як це зрозуміло, банківські рахунки мають змінній стан, оскільки та сама операція може повертати різні результати в різний час.</p></div>
<div class="paragraph"><p>Ви можете подумати, що змінність <code>BankAccount</code> безпосередньо наочна, оскільки він містить визначення <code>var</code>. Змінність та <code>var</code> звичайно ідуть рука в руку, але речі не завжди так чітко окреслені. Наприклад, клас може бути змінним без визначення або наслідування любих <code>var</code>, оскільки він перенаправляє викликів методів до інших об'єктів, що мають змінний стан. Зворотнє також можливе: клас може містити <code>var</code>, та все одне залишатись чисто функціональним. Прикладом може бути клас, що кешує результат коштовної операції в полі для цілей оптимізації. Щоб зрозуміти приклад, розглянемо наступний неоптимізований клас <code>Keyed</code> з коштовною операцією <code>computeKey</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Keyed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">computeKey</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// це займає деякий час</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>За умови, що <code>computeKey</code> не читає та не записує жодні <code>var</code>, ви можете зробити <code>Keyed</code> більш ефективним через додавання кешу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MemoKeyed</span> <span class="k">extends</span> <span class="nc">Keyed</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">keyCache</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">computeKey</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">keyCache</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="n">keyCache</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">computeKey</span><span class="o">)</span>
    <span class="n">keyCache</span><span class="o">.</span><span class="n">get</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Використання <code>MemoKeyed</code> замість <code>Keyed</code> може прискорити речі, бо коли результат операції <code>computeKey</code> запитується в  другий раз, замість виконання <code>computeKey</code> ще раз може бути повернене значення, збережене в полі <code>keyCache</code>. Але, за винятком цього прискорення, поведінка класу <code>Keyed</code> та <code>MemoKeyed</code> в точності така сама. Відповідно, якщо <code>Keyed</code> є чисто функціональним, так само буде <code>MemoKeyed</code>, навіть якщо він містить переприсвоювану змінну.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_2____">18.2 Переприсвоєння змінних та властивостей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете виконати дві фундаментальні операції на переприсвоюваних змінних: отримати її значення, або встановити її в нове значення. В бібліотеках, таких, як JavaBeans, ці операції часто інкапсульовані в окремі методи геттера та сеттера, що повинні бути визначені явно.</p></div>
<div class="paragraph"><p>В Scala кожна <code>var</code>, що є не-приватним членом деякого об'єкту, одночасно неявно визначає методи геттера та сеттера. Однак ці геттери та сеттери іменуються інакше, ніж за Java домовленістю. Геттер <code>var x</code> називається просто <code>x</code>, тоді як сеттер називається <code>x_=</code>.</p></div>
<div class="paragraph"><p>Наприклад, якщо воно з'являється в класі, визначення <code>var</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">hour</span> <span class="k">=</span> <span class="mi">12</span>
</pre></div></div></div>
<div class="paragraph"><p>генерує геттер <code>hour</code>, та сеттер <code>hour_=</code>, на додаток до переприсвоюваного поля. Поле завжди маркується як <code>private[this]</code>, що означає, що воно може отримувати доступ тільки з об'єкта, що містить його. З іншого боку, геттер та сеттер отримують ту саму оглядовість, що і оригінальна <code>var</code>. Якщо визначення <code>var</code> є публічним, таким будуть його геттер та сеттер. Якщо воно <code>protected</code>, вони також будуть <code>protected</code>, і так далі.</p></div>
<div class="paragraph"><p>Наприклад, розглянемо клас <code>Time</code>, показаний на Лістингу 18.2, що визначає дві публічні змінні, з назвами <code>hour</code> та <code>minute</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">var</span> <span class="n">minute</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.2 - Клас з публічними <code>var</code>.</p></div>
<div class="paragraph"><p>Ця реалізація в точності еквівалентна до визначення класу, показаному в Лістингу 18.3. В визначенні, показаному в Лістингу 18.3, імена локальних полів <code>h</code> та <code>m</code> обрані довільно, так щоб вони не стикались з любими іменами, що вже використовуються.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">h</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.3 - Як публічні <code>var</code> розширюються в методи геттерів та сеттерів.</p></div>
<div class="paragraph"><p>Цікавий аспект щодо цього розширення <code>var</code> в геттери та сеттери в тому, що ви за бажанням також можете визначити геттери та сеттери напряму, замість визначення <code>var</code>. Через визначення ціх методів напряму ви можете інтерпретувати операції доступу до змінної, або присвоєння змінної, як вам завгодно. Наприклад, варіант класу <code>Time</code>, показаний в Лістингу 18.4, містить вимоги, щоб перехоплювати всі присвоєння до годин та хвилин з нелегальними значеннями.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="o">)</span>
    <span class="n">h</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span> <span class="k">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="o">)</span>
    <span class="n">m</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.4 - Визначення методів геттера та сеттера напряму.</p></div>
<div class="paragraph"><p>Деякі мови мають спеціальні синтаксичні конструкції для змінно-подібних кількостей, що не є звичайними змінними, де їх сеттери та геттери можуть бути перевизначені. Наприклад, C# має властивості, що виконують цю роль. Ефективно, довленість Scala завжди інтерпретувати змінну як пару з сеттера та геттера надає вам ті самі можливості, що і властивості C#, без потреби в спеціальному синтаксисі.</p></div>
<div class="paragraph"><p>Властивості можуть служити для багатьох різних призначень. В прикладі, показаному в Лістингу 18.4, сеттери примушують виконання інваріантів, таким чином захищаючи змінну від присвоєння нелегальних значень. Також ви можете використовувати властивість для журналювання всіх доступів до сеттера та геттера змінної. Або ви можете інтегрувати змінні з подіями, наприклад, для нотифікації деяких методів підписчикив, кожного разу, коли змінна модифікується (ви побачите приклади цього в Главі 35).</p></div>
<div class="paragraph"><p>Також можливо, і іноді корисно, визначити геттер та сеттер без асоційованого поля. Наприклад, Лістинг 18.5 показує клас <code>Thermometer</code>, що інкапсулює змінну <code>temperature</code>, що може бути прочитана та оновлена. Температури можуть бути виражені в градусах Цельсія або Фаренгейта. Цей клас дозволяє вам отримати та встановити температуру в будь-яких одиницях.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Thermometer</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="k">_</span>

  <span class="k">def</span> <span class="n">fahrenheit</span> <span class="k">=</span> <span class="n">celsius</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span>

  <span class="k">def</span> <span class="n">fahrenheit_=</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">celsius</span> <span class="k">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">-</span> <span class="mi">32</span><span class="o">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">fahrenheit</span> <span class="o">+</span> <span class="s">&quot;F/&quot;</span> <span class="o">+</span> <span class="n">celsius</span> <span class="o">+</span> <span class="s">&quot;C&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.5 - Визначення геттера та сеттера без асоційованого поля.</p></div>
<div class="paragraph"><p>Перший рядок тіла цього класу визначає <code>var</code>, <code>celsius</code>, що буде містити температуру в градусах Цельсія. Змінна <code>celsius</code> напочатку встановлена в значення по замовчанню, через вказання <code>_</code> як "ініціалізуючого значення" змінної. Більш точно, ініціалізатор <code>= _</code> поля присвоює нульове значення до цього поля. Нульове значення залежить від типу поля. Це <code>0</code> для числових типів, <code>false</code> для логічних, <code>null</code> для типів посилань. Це те саме, якби та сама змінна була визначена в Java без ініціалізатора.</p></div>
<div class="paragraph"><p>Зауважте, що ви не можете просто відкинути ініціалізатор <code>= _</code> в Scala. Якщо ви напишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span>
</pre></div></div></div>
<div class="paragraph"><p>це декларує абстрактну змінну, не неініціалізовану зміну.<span class="footnote"><br />[Абстрактні змінні будуть пояснені в Главі 20.]<br /></span></p></div>
<div class="paragraph"><p>За визначенням змінної <code>celsius</code> іде геттер, <code>fahrenheit</code>, та сеттер, <code>fahrenheit_=</code>, що отримує доступ до такої самої температури, але в градусах Фаренгейту. Немає окремого поля, що містить поточне значення температури в фаренгейтах. Замість цього, методи геттера та сеттера для значень фаренгейта автоматично конвертують з градусів Цельсія, відповідно. Ось приклад взаємодії з об'єктом <code>Thermometer</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Thermometer</span>
<span class="n">t</span><span class="k">:</span> <span class="kt">Thermometer</span> <span class="o">=</span> <span class="mf">32.0F</span><span class="o">/</span><span class="mf">0.0</span><span class="n">C</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">celsius</span> <span class="k">=</span> <span class="mi">100</span>
<span class="n">t</span><span class="o">.</span><span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">100.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Thermometer</span> <span class="o">=</span> <span class="mf">212.0F</span><span class="o">/</span><span class="mf">100.0</span><span class="n">C</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="k">=</span> <span class="o">-</span><span class="mi">40</span>
<span class="n">t</span><span class="o">.</span><span class="n">fahrenheit</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">40.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Thermometer</span> <span class="o">=</span> <span class="o">-</span><span class="mf">40.0F</span><span class="o">/-</span><span class="mf">40.0</span><span class="n">C</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_3____">18.3 Дослідження: симуляція дескретних подій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Залишок цієї глави, поміж іншим, показує розширений приклад, як змінні об'єкти можуть бути комбіновані зі значеннями першокласних функцій в цікавий спосіб. Ви побачите розробку та реалізацію симулятора для цифрових пристроїв. Це завдання розбите на декілька субпроблем, кожне з яких цікаві самі по собі.</p></div>
<div class="paragraph"><p>Спочатку, ви побачите невелику мову для цифрових пристроїв. Визначення цієї мови буде висвічувати загальний метод для вбудованих домен-специфічних мов (DSL) в основній мові, як Scala. Друге, ми представимо простий, але загальний фреймворк для симуляції дискретних подій. Його головне завдання буде відстеження дій, що виконуються в симульованому часу. Нарешті, ми покажемо, як програми дискретної симуляції можуть бути структуровані та побудовані. Ідея такої симуляції є моделювання фізичних об'єктів через симульовані об'єкти, та використання фреймворка симуляції для моделювання фізичного часу.</p></div>
<div class="paragraph"><p>Приклад взятий з класичного підручника <em>Structure and Interpretation of Computer Programs</em> від Abelson та Sussman [Abe96]. Що тут відрізняється, це те, що мова реалізації є Scala замість Scheme, та що різні аспекти приклада структуровані в шари програмного забезпечення: один для фреймворка симуляції, інший для базового пакунку симуляції схем, третій для бібліотеки визначених користувачем пристроїв, та останній шар для кожного окремого симульованого пристрою. Кожний з рівнів виражений як клас, та більш специфічні шари наслідують від більш загальних.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>Розуміння симуляції дескретних подій, представленої в цій главі, займе деякий час. Якщо ви відчуваєте, що замість цього бажаєте зайнятись вивченням Scala, безпечно перейти далі, до наступної глави.</p></div>
<div class="paragraph"><p>Малюнок 18.1 - Базові ключі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_4____">18.4 Мова для цифрових пристроїв</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми почнемо з "малої мови" для опису дискретних цифрових пристроїв. Цифровий пристрій побудований з дротів та функціональних блоків. Дроти передають сигнали, що перетворюються функціональними блоками. Сигнали представлені як логічні рівні: <code>true</code> для вімкненого сигналу, <code>false</code> для вимкненого.</p></div>
<div class="paragraph"><p>Малюнок 18.1 показує базові функціональні блоки (або вентилі):</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>Інвертор</em>, що обертає свій сигнал.
</p>
</li>
<li>
<p>
<em>ТА-вентиль</em>, що встановлює свій вихід в кон'юкцію своїх входів.
</p>
</li>
<li>
<p>
<em>АБО-вентиль</em>, що встановлює свій вихід в діз'юкцію своїх входів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ці вентилі достатні для побудови всіх інших функціональних блоків. Ключі мають затримки, так що вихід з вентиля буде змінюватись тільки через деякий час після зміни входу.</p></div>
<div class="paragraph"><p>Ми опишемо елементи цифрової схеми через наступний набір класів та функцій Scala. Перше, існує клас <code>Wire</code> для дротів. Ми можемо конструювати дроти таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
</pre></div></div></div>
<div class="paragraph"><p>або, еквівалентно, але коротше, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
</pre></div></div></div>
<div class="paragraph"><p>Друге, існують три процедури, що "виготовляють" базові вентилі, що нам знадобляться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span>
<span class="k">def</span> <span class="n">andGate</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span>
<span class="k">def</span> <span class="n">orGate</span><span class="o">(</span><span class="n">o1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">o2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що є незвичним, беручи функціональну схильність Scala, це те, що ці процедури конструюють вентилі як побічний ефект, замість повернення сконструйованих вентилів в якості результата. Наприклад, виклик <code>inverter(a, b)</code> покладає інвертор між дротами <code>a</code> та <code>b</code>. З'ясовується, що таке побічно-ефектне конструювання спрощує конструювання складних пристроїв поступово. Також, хоча методи більш часто мають імена-дієслова, ці називаються як прикметники, що вказує на вентилі, що вони виробляють. Це відображує декларативну природу DSL: це має описувати схему, а не дії по їх створенню.</p></div>
<div class="paragraph"><p>Більш складні функціональні блоки можуть бути побудовані з базових вентилів. Наприклад, метод, показаний в Лістингу 18.6, конструює напів-суматор. Метод <code>halfAdder</code> приймає два входи, <code>a</code> та <code>b</code>, та продукує суму, <code>s</code>, визначене як <code>s = (a + b) % 2</code> та перенос, <code>c</code>, визначене як <code>c = (a + b) / 2</code>. Діаграма напів-суматора показана на Малюнку 18.2.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
  <span class="n">orGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
  <span class="n">andGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">inverter</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
  <span class="n">andGate</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.6 - Метод <code>halfAdder</code>.</p></div>
<div class="paragraph"><p>Малюнок 18.2 - Схема напів-суматора.</p></div>
<div class="paragraph"><p>Зауважте, що <code>halfAdder</code> є параметризованим функціональним блоком, так само, як три методи, що конструюють примітивні вентилі. Ви можете використовувати метод <code>halfAdder</code> для побудови більш складних схем. Наприклад, Лістинг 18.7 визначає повний однобітний суматор, показаний на Малюнку 18.3, що приймає два входи, <code>a</code> та <code>b</code>, так само, як вхідний перенос, <code>cin</code>, та який продукує на виході <code>sum</code>, визначений як <code>sum = (a + b + cin) % 2</code>, та вихідний перенос, визначений як <code>cout = (a + b + cin) / 2</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cin</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span>
    <span class="n">sum</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cout</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">,</span> <span class="n">c2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
  <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">cin</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">)</span>
  <span class="n">halfAdder</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
  <span class="n">orGate</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">,</span> <span class="n">cout</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.7 - Метод <code>fullAdder</code>.</p></div>
<div class="paragraph"><p>Клас <code>Wire</code> та функції <code>inverter</code>, <code>andGate</code>, та <code>orGate</code> представляють малу мову, за допомогою якої користувачі можуть визначати цифрові пристрої. Це гарний приклад визначення <em>внутрішнього</em> DSL, домен-специфічної мови, визначеної як бібліотека в основній мові, замість бути реалізованій сама по собі.</p></div>
<div class="paragraph"><p>Малюнок 18.3 - Схема повного суматора.</p></div>
<div class="paragraph"><p>Реалізація DSL пристроїв все ще має бути пропрацьована. Оскільки призначення визначення пристрою в DSL є симуляція пристрою. має сенс базувати реалізацію DSL на загальному API для симуляції дескретних подій. Наступні два розділи будуть презентувати спочатку API симуляції, та потім реалізацію DSL пристроїв зверху нього.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_5_api_">18.5 API симуляції</h2>
<div class="sectionbody">
<div class="paragraph"><p>API симуляції показаний в Лістингу 18.8. Він складається з класа <code>Simulation</code> в пакунку <code>org.stairwaybook.simulation</code>. Конкретна бібліотека симуляції наслідує цей клас, та додає до неї домен-специфічну функціональність. Елементи класу <code>Simulation</code> представлені в цьому розділі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Simulation</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">Action</span> <span class="o">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">time</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">action</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">curtime</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">currentTime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">curtime</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">agenda</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">],</span>
      <span class="n">item</span><span class="k">:</span> <span class="kt">WorkItem</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">time</span><span class="o">)</span> <span class="n">item</span> <span class="o">::</span> <span class="n">ag</span>
    <span class="k">else</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">block</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">item</span> <span class="k">=</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">currentTime</span> <span class="o">+</span> <span class="n">delay</span><span class="o">,</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">block</span><span class="o">)</span>
    <span class="n">agenda</span> <span class="k">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">agenda</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">next</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">agenda</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">item</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
        <span class="n">agenda</span> <span class="k">=</span> <span class="n">rest</span>
        <span class="n">curtime</span> <span class="k">=</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span>
        <span class="n">item</span><span class="o">.</span><span class="n">action</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">afterDelay</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;*** simulation started, time = &quot;</span> <span class="o">+</span>
        <span class="n">currentTime</span> <span class="o">+</span> <span class="s">&quot; ***&quot;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">agenda</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">next</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.8 - Клас <code>Simulation</code>.</p></div>
<div class="paragraph"><p>Симуляція дискретних подій виконує визначені користувачем дії у вказаний час. Дії, що визначені в субкласі конкретної симуляції, всі поділяють єдиний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Action</span> <span class="o">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Це твердження визначає <code>Action</code> як псевдоним для типу процедури, що приймає порожній список параметрів, та повертає <code>Unit</code>. <code>Action</code> є <em>членом типу</em> класу <code>Simulation</code>. Ви можуту думати про це, як про більш читаєме ім'я для типу <code>() =&gt; Unit</code>. Члени типів будуть описані в деталях в Розділі 20.6.</p></div>
<div class="paragraph"><p>Час, в який виконується дія, є симульований час; він не має нічого спільного зі справжнім часом "годинника на стіні". Симульований час представлений просто як ціле. Поточний симульований час утримується як приватна змінніа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">var</span> <span class="n">curtime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна має публічний метод аксессора, що повертає поточний час:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">currentTime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">curtime</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця комбінація приватної змінної з публічним аксессором використовується для переконання, що поточний час не може бути модифікований за межами класу <code>Simulation</code>. Кінець кінцем, звичайно ви не бажаєте, щоб ваші об'єкти симуляції маніпулювали поточним часом, можливо, за винятком, якщо ваша модель симуляції подорожує в часі.</p></div>
<div class="paragraph"><p>Дія, що має бути виконана у вказаний час, називається робочим елементом. Робочий елемент реалізований як наступний клас:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">time</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">action</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми робимо клас <code>WorkItem</code> кейс класом, оскільки є синтаксичні зручності, що витікають з цього: ви можете використовувати метод фабрики <code>WorkItem</code>, щоб створити примірники класу, та ви задурно отримуєте аксессори для параметрів конструктора <code>time</code> та <code>action</code>. Також зауважте, що клас <code>WorkItem</code> вкладений в клас <code>Simulation</code>. Вкладені класи в Scala розглядаються подібно до Java. Розділ 20.7 надасть більше деталей.</p></div>
<div class="paragraph"><p>Клас <code>Simulation</code> утримує порядок денний з усіх залишених робочих елементів, що ще не були виконані. Робочі елементи впорядковані по симульованому часу, в який вони мають виконуватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">var</span> <span class="n">agenda</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Список <code>agenda</code> буде підтримуватись в потрібному впорядкованому вигляді через метод <code>insert</code>, що оновлює його. Ви можете бачити <code>insert</code>, коли той викликається з <code>afterDelay</code>, що є єдиним шляхом додати робочий елемент до розкладу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">block</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">item</span> <span class="k">=</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">currentTime</span> <span class="o">+</span> <span class="n">delay</span><span class="o">,</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">block</span><span class="o">)</span>
  <span class="n">agenda</span> <span class="k">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">agenda</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як натякає ім'я, цей метод вставляє дію (надану як <code>block</code>) в розклад, так що вона планується для виконання з затримкою в одиницях часу, після поточного часу симуляції. Наприклад, наступний виклик буде створювати новий робочий елемент, що буде виконаний в симульований час <code>currentTime + delay</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span> <span class="o">{</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Код, що буде виконаний, міститься в другому аргументі метода. Формальний параметр для цього аргумента має тип <code>=&gt; Unit</code> (тобто, це обчислення типу <code>Unit</code>, що передається по імені). Згадайте, що параметри за-ім'ям не обчислюються коли передаються в метод. Так що в виклику вище <code>count</code> буде інкрементовано тільки коли фреймворк симуляції викликає дію, що зберігається в робочому елементі. Зауважте, що <code>afterDelay</code> є карованою функцією. Це гарний приклад принципу, викладеного в Розділі 9.5, що каровані функції можуть використовуватись, щоб зробити виклик метода більш схожим на вбудований синтаксис. Створений робочий елемент все ще потребує бути вставленим в розклад. Це робиться через метод <code>insert</code>, що підтримує інваріант, згідно якого <code>agenda</code> впорядкована за часом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">],</span>
    <span class="n">item</span><span class="k">:</span> <span class="kt">WorkItem</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">time</span><span class="o">)</span> <span class="n">item</span> <span class="o">::</span> <span class="n">ag</span>
  <span class="k">else</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Основа класу <code>Simulation</code> визначений методом <code>run</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">afterDelay</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;*** simulation started, time = &quot;</span> <span class="o">+</span>
      <span class="n">currentTime</span> <span class="o">+</span> <span class="s">&quot; ***&quot;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">agenda</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">next</span><span class="o">()</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей метод постійно вибирає перший елемент в <code>agenda</code>, видаляє його з розкладу, та виконує його. Він робить це, доки в роскладі більше не залишиться елементів, що не були виконані. Кожний крок виконується через метод <code>next</code>, що визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">next</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">agenda</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">item</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="n">agenda</span> <span class="k">=</span> <span class="n">rest</span>
      <span class="n">curtime</span> <span class="k">=</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span>
      <span class="n">item</span><span class="o">.</span><span class="n">action</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>next</code> декомпонує потоний розклад за допомогою порівняння шаблонів на перший елемент, <code>item</code>, та залишок списку робочих елементів, <code>rest</code>. Він видаляє передній елемент з поточного розкладу, встановлює симульований час <code>curtime</code> до часу робочого елементу, та виконує дію робочого елемента.</p></div>
<div class="paragraph"><p>Зауважте, що <code>next</code> може бути викликаний тільки якщо розклад непорожній. Немає <code>case</code> для порожнього списку, так що ви будете отримувати виключення <code>MatchError</code>, якщо ви спробуєте викликати <code>next</code> на порожньому розкладі.</p></div>
<div class="paragraph"><p>Фактично, компілятор Scala буде звичайно попереджати вас, що ви пропустили один з можливих шаблонів для списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Simulator</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">19</span><span class="kt">:</span> <span class="kt">warning:</span> <span class="kt">match</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">exhaustive!</span>
<span class="n">missing</span> <span class="n">combination</span>     <span class="nc">Nil</span>

    <span class="n">agenda</span> <span class="k">match</span> <span class="o">{</span>
    <span class="o">^</span>
<span class="n">one</span> <span class="n">warning</span> <span class="n">found</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку, відсутній <code>case</code> не є проблемою, оскільки ви знаєте, що <code>next</code> викликається на непорожньому розкладі. Таким чином, ви можете побажати відключити попередження. Ви бачили в Розділі 15.5, що це може бути зроблене через додавання анотації <code>@unchecked</code> до виразу селектора в порівнянні шаблонів. Ось чому код <code>Simulation</code> використовує <code>(agenda: @unchecked) match</code>, не <code>agenda match</code>. Це все. Це може виглядати як дивовижно малий код для фреймворка симуляції. Ви можете здивуватись, як цей фреймворк може потенційно підтримувати цікаві симуляції, якщо все, що він робить, це виконує список робочих елементів? Фактично, потужність фреймворку симуляції походить від факту, що дії, що зберігаються в робочих елементах, самі можуть встановлювати подальші робочі елементи в розклад під час виконання. Це робить можливим мати довготриваючі симуляції, розвинені з простого початку.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_6__">18.6 Симуляція схеми</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наступний крок є використання фреймворку симуляції для реалізації домен-специфічної мови для пристроїв, показаної в Розділі 18.4. Згадайте, що DSL пристроїв складається з класа для дротів, та методів, що створюють ТА-вентилі, АБО-вентилі та інвертори. Всі вони містяться в класі <code>BasicCircuitSimulation</code>, що розширює фреймворк симуляції. Цей клас показаний в Лістингах 18.9 та 18.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.simulation</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BasicCircuitSimulation</span> <span class="k">extends</span> <span class="nc">Simulation</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nc">InverterDelay</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nc">AndGateDelay</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nc">OrGateDelay</span><span class="k">:</span> <span class="kt">Int</span>

  <span class="k">class</span> <span class="nc">Wire</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">sigVal</span> <span class="k">=</span> <span class="kc">false</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">actions</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Action</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

    <span class="k">def</span> <span class="n">getSignal</span> <span class="k">=</span> <span class="n">sigVal</span>

    <span class="k">def</span> <span class="n">setSignal</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">sigVal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sigVal</span> <span class="k">=</span> <span class="n">s</span>
        <span class="n">actions</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">())</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">addAction</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="n">actions</span> <span class="k">=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">actions</span>
      <span class="n">a</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">invertAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">inputSig</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="n">afterDelay</span><span class="o">(</span><span class="nc">InverterDelay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">output</span> <span class="n">setSignal</span> <span class="o">!</span><span class="n">inputSig</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">input</span> <span class="n">addAction</span> <span class="n">invertAction</span>
  <span class="o">}</span>
<span class="c1">// продовження в Лістингу 18.10...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.9 - Перша половина класу <code>BasicCircuitSimulation</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// ...продовження з Лістингу 18.9</span>
  <span class="k">def</span> <span class="n">andGate</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">andAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">a1Sig</span> <span class="k">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="k">val</span> <span class="n">a2Sig</span> <span class="k">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="n">afterDelay</span><span class="o">(</span><span class="nc">AndGateDelay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">output</span> <span class="n">setSignal</span> <span class="o">(</span><span class="n">a1Sig</span> <span class="o">&amp;</span> <span class="n">a2Sig</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">a1</span> <span class="n">addAction</span> <span class="n">andAction</span>
    <span class="n">a2</span> <span class="n">addAction</span> <span class="n">andAction</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">orGate</span><span class="o">(</span><span class="n">o1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">o2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">orAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">o1Sig</span> <span class="k">=</span> <span class="n">o1</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="k">val</span> <span class="n">o2Sig</span> <span class="k">=</span> <span class="n">o2</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="n">afterDelay</span><span class="o">(</span><span class="nc">OrGateDelay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">output</span> <span class="n">setSignal</span> <span class="o">(</span><span class="n">o1Sig</span> <span class="o">|</span> <span class="n">o2Sig</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">o1</span> <span class="n">addAction</span> <span class="n">orAction</span>
    <span class="n">o2</span> <span class="n">addAction</span> <span class="n">orAction</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">probe</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wire</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">probeAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">currentTime</span> <span class="o">+</span>
          <span class="s">&quot; new-value = &quot;</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getSignal</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">wire</span> <span class="n">addAction</span> <span class="n">probeAction</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.10 - Друга половина класу <code>BasicCircuitSimulation</code>.</p></div>
<div class="paragraph"><p>Клас <code>BasicCircuitSimulation</code> декларує три абстрактні методи, що представляють затримки базових вентилів: <code>InverterDelay</code>, <code>AndGateDelay</code>, та <code>OrGateDelay</code>. Дійсні затримки невідомі на рівні цього класу, оскікльи вони залежать від технології пристроїв, що будуть симульовані. Ось чому затримки залишені абстрактними в класі <code>BasicCircuitSimulation</code>, так що їх суцільне визначення делеговано до субкласів.<span class="footnote"><br />[Імена ціх методів затримки починаються з великої літери, оскільки вони представляють константи. Вони є методами, так що вони можуть бути перекриті в субкласах. Ви винайдете, як робити ті самі речі з <code>val</code> в Розділі 20.3.]<br /></span> Реалізація інших членів класу <code>BasicCircuitSimulation</code> описана далі.</p></div>
<div class="sect2">
<h3 id="__wire">Клас Wire</h3>
<div class="paragraph"><p>Дріт має підтримувати три базові дії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>getSignal: Boolean</code>: повертає поточний сигнал на дроті.
</p>
</li>
<li>
<p>
<code>setSignal(sig: Boolean)</code>: встановлює сигнал на дроті в <code>sig</code>.
</p>
</li>
<li>
<p>
<code>addAction(p: Action)</code>: приєднує вказану процедуру <code>p</code> до дій на дроті. Ідея полягає в тому, що всі процедури дій, приєднані до деякого дроту, будуть використовуватись кожний раз, коли сигнал на дроті змінюється. Типово акції додаються до дроту через компоненти, приєднані до дроту. Приєднана дія виконується один раз, коли вона додається до дроту, та після цього кожний раз, коли сигнал на дроті змінюється.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ось реалізація класу <code>Wire</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Wire</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">sigVal</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">actions</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Action</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

  <span class="k">def</span> <span class="n">getSignal</span> <span class="k">=</span> <span class="n">sigVal</span>

  <span class="k">def</span> <span class="n">setSignal</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">sigVal</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sigVal</span> <span class="k">=</span> <span class="n">s</span>
      <span class="n">actions</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">())</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">addAction</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">actions</span> <span class="k">=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">actions</span>
    <span class="n">a</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дві приватні змінні складають стан дроту. Змінна <code>sigVal</code> представляє поточний сигнал, та змінна <code>actions</code> представляє процедури дій, наразі приєднані до дроту. Одна цікава реалізація метода є <code>setSignal</code>: коли сигнал на дроті змінюється, нове значення зберігається в змінній <code>sigVal</code>. Більше того, всі дії, приєднані до дроту, виконуються. Зауважте скорочений синтаксис для виконання цього: <code>actions foreach (_ ())</code> застосовує функцію <code>_ ()</code> до кожного елементу в списку <code>actions</code>. Як описане в Розділі 8.5, функція <code>_ ()</code> є скороченням до <code>f =&gt; f ()</code> — тобто, вона приймає функцію (назвемо її <code>f</code>), та застосовує її до порожнього списку параметрів.</p></div>
</div>
<div class="sect2">
<h3 id="__code_inverter_code">Метод <code>inverter</code></h3>
<div class="paragraph"><p>Єдиний ефект від створення інвертора в тому, що на його вхідному дроті встановлюється дія. Ця дія викликається кожний раз, коли дія інсталюється, та потім кожного разу, коли сигнал на дроті змінюється. Ефект дії в тому, що значення на виході інвертора встановлюється (через <code>setSignal</code>) на протилежність вхідного значення. Оскільки вентилі інверторів мають затримки, ця зміна повинна набувати ефекту тільки після <code>InverterDelay</code> одиниць симульованого часу після того, як вхідне значення було змінене, та дія була виконана. Це підказує наступну реалізацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">invertAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">inputSig</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">getSignal</span>
    <span class="n">afterDelay</span><span class="o">(</span><span class="nc">InverterDelay</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">output</span> <span class="n">setSignal</span> <span class="o">!</span><span class="n">inputSig</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">input</span> <span class="n">addAction</span> <span class="n">invertAction</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект метода <code>inverter</code> є додавання <code>invertAction</code> до вхідного дроту. Ця дія, коли викликана, бере вхідний сигнал, та встанавлює іншу дію, що інвертує вихідний сигнал в симульованому розкладі. Ця інша дія буде виконана через <code>InverterDelay</code> одиниць симульованого часу. Зауважте, як метод використовує метод <code>afterDelay</code> фреймворка симуляції для створення нового робочого елемента, що буде виконаний в майбутньому.</p></div>
</div>
<div class="sect2">
<h3 id="__code_andgate_code__code_orgate_code">Методи <code>andGate</code> та <code>orGate</code></h3>
<div class="paragraph"><p>Реалізація ТА-вентилів аналогічна реалізації інверторів. Призначення ТА-вентилів є вивід кон'юкції його вхідних сигналів. Це має відбуватись через <code>AndGateDelay</code> одиниць симульованого часу після зміни одного з його вхідних сигналів. З цього випливає наступна реалізація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">andGate</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">andAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">a1Sig</span> <span class="k">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">getSignal</span>
    <span class="k">val</span> <span class="n">a2Sig</span> <span class="k">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">getSignal</span>
    <span class="n">afterDelay</span><span class="o">(</span><span class="nc">AndGateDelay</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">output</span> <span class="n">setSignal</span> <span class="o">(</span><span class="n">a1Sig</span> <span class="o">&amp;</span> <span class="n">a2Sig</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">a1</span> <span class="n">addAction</span> <span class="n">andAction</span>
  <span class="n">a2</span> <span class="n">addAction</span> <span class="n">andAction</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект метода <code>andGate</code> є додавання <code>andAction</code> до обох його вхідних дротів, <code>a1</code> та <code>a2</code>. Ця дія, коли викликається, отримує обоє вхідні сигнали, та інсталює іншу дію, що встанавлює вихідний сигнал в кон'юкцію обох вхідних сигналів. Ця інша дія буде виконана після <code>AndGateDelay</code> одиниць симульованого часу. Зауважте, що вихід буде перерахований, якщо любий з вхідних дротів зміниться. Ось чому та сама акція <code>andAction</code> інсталюється для обох вхідних дротів, <code>a1</code> та <code>a2</code>. Метод <code>orGate</code> реалізований подібно, за винятком того, що він виконує логічне АБО замість логічного ТА.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Вивід симуляції</h3>
<div class="paragraph"><p>Щоб виконати симулятор, вам треба спосіб інспектувати зміни сигналів на дротах. Щоб досягти цього, ви можете симулювати дію покладання проби на дріт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">probe</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wire</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">probeAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">currentTime</span> <span class="o">+</span>
        <span class="s">&quot; new-value = &quot;</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getSignal</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">wire</span> <span class="n">addAction</span> <span class="n">probeAction</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект процедури <code>probe</code> є встановити <code>probeAction</code> на обраний дріт. Як звичайно, встановлена дія виконується кожний раз, коли сигнал на дроті змінюється. В цьому випадку вона просто друкує ім'я дроту (що передається як перший параметр до <code>probe</code>), так само, як і поточний час симуляції, та нове значення на дроті.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Запуск симулятора</h3>
<div class="paragraph"><p>Після всіх ціх підготувань настав час побачити симулятор в дії. Щоб визначити суцільну симуляцію, вам треба наслідувати від класу фреймворка симуляції. Щоб побачити щось цікаве, ми створимо клас абстрактної симуляції, що розширює <code>BasicCircuitSimulation</code>, та містить визначення методів для напів-суматора та повного суматора, як вони були представлені раніше в цій главі в Лістингах 18.6 та 18.7, відповідно. Цей клас, що ми назвемо  <code>CircuitSimulation</code>, показаний на Лістингу 18.11.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.simulation</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">CircuitSimulation</span>
  <span class="k">extends</span> <span class="nc">BasicCircuitSimulation</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
    <span class="n">orGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
    <span class="n">andGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
    <span class="n">inverter</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
    <span class="n">andGate</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cin</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span>
    <span class="n">sum</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cout</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">,</span> <span class="n">c2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
    <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">cin</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">)</span>
    <span class="n">halfAdder</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
    <span class="n">orGate</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">,</span> <span class="n">cout</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.11 - Клас <code>CircuitSimulation</code>.</p></div>
<div class="paragraph"><p>Суцільна симуляція пристрою буде об'єктом, що наслідує від класа <code>CircuitSimulation</code>. Об'єкт все ще потребує виправлення затримок вентилів відповідно до технології реалізації пристрою, яка симулюється. Нарешті, вам також треба буде визначити суцільний пристрій, що має бути симульований. Ви можете зробити ці кроки інтерактивно в інтерпретаторі Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">org.stairwaybook.simulation._</span>
<span class="k">import</span> <span class="nn">org.stairwaybook.simulation._</span>
</pre></div></div></div>
<div class="paragraph"><p>Зпершу вирішимо затримки вентилів. Визначимо об'єкт (назвемо її <code>MySimulation</code>), що провадить деякі числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">MySimulation</span> <span class="k">extends</span> <span class="nc">CircuitSimulation</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nc">InverterDelay</span> <span class="k">=</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nc">AndGateDelay</span> <span class="k">=</span> <span class="mi">3</span>
        <span class="k">def</span> <span class="nc">OrGateDelay</span> <span class="k">=</span> <span class="mi">5</span>
      <span class="o">}</span>
<span class="n">defined</span> <span class="n">module</span> <span class="nc">MySimulation</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ви збираєтесь постійно отримувати доступ до членів об'єкта <code>MySimulation</code>, імпортування об'єкту підтримує подальший код коротшим:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">MySimulation._</span>
<span class="k">import</span> <span class="nn">MySimulation._</span>
</pre></div></div></div>
<div class="paragraph"><p>Далі - пристрій. Визначте чотири дроти, та покладіть проби на два з них:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">input1</span><span class="o">,</span> <span class="n">input2</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">carry</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
<span class="n">input1</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">111089</span><span class="n">b</span>
<span class="n">input2</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">14</span><span class="n">c352e</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">37</span><span class="n">a04c</span>

<span class="n">carry</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">1</span><span class="n">fd10fa</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">probe</span><span class="o">(</span><span class="s">&quot;sum&quot;</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span>
<span class="n">sum</span> <span class="mi">0</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">probe</span><span class="o">(</span><span class="s">&quot;carry&quot;</span><span class="o">,</span> <span class="n">carry</span><span class="o">)</span>
<span class="n">carry</span> <span class="mi">0</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що проби безпосередньо друкують вивід. Це тому, що кожна дія, встановлена на дроті, перший раз виконується при встановленні дії.</p></div>
<div class="paragraph"><p>Тепер визначимо напів-суматор, під'єднавши дроти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">halfAdder</span><span class="o">(</span><span class="n">input1</span><span class="o">,</span> <span class="n">input2</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">carry</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, встановимо сигнали, один за одним, на двох вхідних дротах, та запустимо симуляцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">input1</span> <span class="n">setSignal</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">()</span>
<span class="o">***</span> <span class="n">simulation</span> <span class="n">started</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">0</span> <span class="o">***</span>
<span class="n">sum</span> <span class="mi">8</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">input2</span> <span class="n">setSignal</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">()</span>
<span class="o">***</span> <span class="n">simulation</span> <span class="n">started</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">8</span> <span class="o">***</span>
<span class="n">carry</span> <span class="mi">11</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">sum</span> <span class="mi">15</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_18_7_">18.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава поєднала дві техніки, що спочатку виглядають окремими: змінний стан та функції вищих порядків. Змінний стан був використаний для симуляції фізичних сутностей, чий стан змінюється з часом. Функції вищих порядків були використані в фреймворку симуляції, щоб виконувати дії у вказаних точках симульованого часу. Вони також були використані в симуляціях пристроїв, що асоціюють дії зі змінами стану. По дорозі ви бачили простий шлях для визначення домен-специфічної мови як бібліотеки. Це, можливо, досить для однієї глави!</p></div>
<div class="paragraph"><p>Якщо ви хочете залишитись трохи довше, ви можете за бажанням спробувати більше прикладів симуляцій. Ви можете комбінувати напів-суматори та повні суматори для створення більших пристроїв, або розробити нові прилади з визначених досі базових вентилів, та симулювати їх. В наступній главі ми вивчимо щодо параметризації типів в Scala, і побачимо інший приклад, де комбінація функціонального та імперативного підходів дає гарні рішення.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-04 06:28:32 EET
</div>
</div>
</body>
</html>
