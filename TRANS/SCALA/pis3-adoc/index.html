<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Програмування на Scala, 3тє видання</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Програмування на Scala, 3тє видання</h1>
<span id="author">Martin Odersky, Lex Spoon, Bill Venners</span><br />
<span id="revnumber">version 3.0,</span>
<span id="revdate">2016-12</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_______scala">Подяки за ранішні редакції Програмування на Scala</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="content">Програмування на Scala є, можливо, одною з кращих книжок з програмування, що я будь-коли читав. Мені подобається стиль написання, краткість та глибина викладення. Книжка, здається, відповідає на кожне запитання, як тілько воно спадає мені на думку - вона завжди на крок попереду мене. Автори не тільки надають деякий код та викладають речі як належне. Вони дають вам саму суть, так що ви дійсно розумієте що відбувається. Мені це дійсно подобається.</div>
<div class="attribution">
<em>Chief Software Architect</em><br />
&#8212; Ken Egervari
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala написано ясно, глибоко, та їй легко слідувати. Вона має чудові приклади та сповнена чудовими підказками. Вона дозволила нашій організації опанувати мову Scala швидко та ефективно. Ця книжка чудова для кожного програміста, хто намагається налаштувати свою голову на гнучкість та елегантність мови Scala.</div>
<div class="attribution">
<em>власник Morroni Technologies Inc.</em><br />
&#8212; Larry Morroni
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala служить як чудовий туторіал по мові Scala. Просування по книзі іде гладко, де кожна глава будується на концепціях та прикладах, описаних в попередніх главах. Книга турбується про глибоке пояснення конструкцій мови, часто провадячи приклади того, як мова відрізняється від Java. Так само, як і головна мова, також є деяке покриття бібліотек, як контейнери та актори. Я знайшов книгу простою до проробки, і це, можливо, одна з кращих написаних технічних книжок, що я читав останні часом. Я справді можу рекомендувати цю книжку любому програмісту, що бажає знайти більше щодо мови Scala.</div>
<div class="attribution">
&#8212; Matthew Todd
</div></div>
<div class="quoteblock">
<div class="content">Я здивований зусиллями, здісненими авторами Програмування на Scala. Ця книга є неоціненним керівництвом до того, що я називаю платформою Scala: рушій до кращого кодування, постійне натхнення до розробки та реалізації маштабованого програмного забезпечення. Якби я тільки мав Scala в її сучасному зрілому стані, та цю книжку в далекому 2003му році, коли я спів-розробляв та реалізував частини інфраструктури порталу Олімпійськіх Ігор 2004 в Афінах! Всім читачам: не важливо, який ваш програмістській бекграунд, я відчуваю ви знайдете програмування на Scala вивільняючим, та ця книга буде вірним другом в цій подорожі.</div>
<div class="attribution">
<em>Software Consultant & Researcher</em><br />
&#8212; Christos KK Loverdos
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala є довершеним глибинним вступом до Scala,та це також чудове посилання. Я хочу сказати, що вона займає видатне місце на моїй книжній полиці, і крім цього я все ще ношу її з собою майже будь-де, куди я іду.</div>
<div class="attribution">
<em>президент ArdenTex</em><br />
&#8212; Brian Clapper
</div></div>
<div class="quoteblock">
<div class="content">Чудова книга, гарно написана з осмисленими прикладами. Я можу рекомендувати її як для досвідчених програмістів, так і для початківців.</div>
<div class="attribution">
&#8212; Howard Lovatt
</div></div>
<div class="quoteblock">
<div class="content">Книга Програмування на Scala не тільки про те, як, але, більш важливо, чому слід розробляти програми на цій новій мові програмування. Прагматичний підхід в введені до потужності комбінування об'єктно-орієнтовного та функціонального програмування, залишає читача без жодних сумнівів, чим насправді є Scala.</div>
<div class="attribution">
<em>CEO/засновник EXPRO I.T. & консультант</em><br />
&#8212; Dr. Ervin Varga
</div></div>
<div class="quoteblock">
<div class="content">Це чудове введення до функціонального програмування для ОО програмістів. Навчання щодо ФП було моєю головною ціллю, але я також познайомився з деякими милими сюрпризами Scala, як кейс класи та порівняння шаблонів. Scala є інтригуючою мовою, та ця книжка гарно розмовідає про це. Завжди є гарна лінія, вздовж якої треба іти в книжці вступу до мови, між надання дуже багато, та нестачею достатньої інформації. Я знайшов, що Програмування на Scala досягла ідеального балансу.</div>
<div class="attribution">
<em>Programmer Analyst</em><br />
&#8212; Jeff Heon
</div></div>
<div class="quoteblock">
<div class="content">Я придбав ранішню електронну версію книжки Програмування на Scala від Odersky, Spoon та Venners, та безпосередньо став фанатом. На додаток до факту, що вона містить найбільш всеосяжну інформацію щодо мови, існує декілька ключових особливостей електронного формату, що вразили мене. Я ніколи не бачив посилань в PDF, що служать не тільки для закладок, але також провадять активні посилання з таблиці змісту та індексів. Я не знаю, чому більше авторів не використовують цю можливість, оскільки це дійсно радість для читача. Інша можливість, якою я був вражений, були посилання на форуми ("Discuss"), та спосіб надсилати коментарі ("Suggest") до авторів по електронній пошті. Можливість коментувати сама по собі не є незвичною, але проста вставка номера сторінки, що генерується для надсилання авторам, є важливою для обох, авторів та читачів. Я доклав більше коментарів, ніж я мав би, якби процес був би більш важкий. Читайте Програмування на Scala заради вмісту, але якщо ви читаєте електронну версію, обов'язково отримайте переваги від цифрових можливостей, які автори подбали вбудувати в книжку!</div>
<div class="attribution">
<em>засновник/консультант SRT Solutions</em><br />
&#8212; Dianne Marsh
</div></div>
<div class="quoteblock">
<div class="content">Ясність та технічна повнота є відзнакою любої гарно написаної книжки, та я вітаю Martin
Odersky, Lex Spoon та Bill Venners з тим, що вони зробили цю роботу дуже гарно! Книжка Programming in Scala починається з встановлення гарного фундаменту з базовими концепціями,та просуває користувача на середній рівень, та далі. Ця книга беззаперечно обов'язкова для придбання для кожного, що прагне вивчити Scala.</div>
<div class="attribution">
<em>Enterprise Architecture & GMAC Financial Services</em><br />
&#8212; Jagan Nambi
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala приємно читається. Це одна з тих гарно написаних технічних книжок, що провадять глибоке та повне покриття предмету в екстремально стислій та елегантній манері. Книга організована в дуже природний та логічний спосіб. Вона однаково гарно пристосована для зацікавлених технологістів, які просто бажають залишатись на піці поточних трендів, та професіоналів, що шукають глибокого розуміння основних можливостей  мови, та обгрунтувань її дизайну. Я дуже рекомендую її всім зацікавленим в фіункціональному програмуванні взагалі. Для розробників Scala ця книга безумовно є обов'язковою для читання.</div>
<div class="attribution">
<em>Software Architect/Lead Programmer @ Greystone Inc.</em><br />
&#8212; Igor Khlystov
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala прямо точиться кількістю важкої роботи, що пішла до неї. Я ніколи до цього не читав книжку в стилі туторіала, що виконує роль вступу, і при цьому є повною: в їх (помилковій) спробі бути доступними, та не "засмучувати" читача, більшість туторіалів замовчують аспекти предмета, що дуже просунутий для поточного обговорення. Це залишає дуже поганий присмак, бо ніхто не може бути впевнений, якого розуміння ви вже досягли. Завжди існує деяка залишкова "магія", що не була пояснена, та  взагалі не може бути зрозумілою читачеві. Ця книжка нуколи не робить цього, вона нічого не приймає на віру: кожна деталь або достатньо пояснена, або надається посилання на подальше пояснення. Дійсно, текст екстенсивно посилається на себе та індексований, так що формує повну картину складної теми відносно просто.</div>
<div class="attribution">
<em>Enterprise Java Architect</em><br />
&#8212; Gerald Loeffler
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala від Martin Odersky, Lex Spoon та Bill Venners: в часи, коли гарні книжкі є рідкістю, це чудове введення для програмістів середнього рівня дійсно є винятнковим. Ви знайдете тут все, щоб вивчити цю мову програмування.</div>
<div class="attribution">
&#8212; Christian Neukirchen
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>Programmmin in Scala, Third Edition
Martin Odersky, Lex Spoon, Bill Venners
Artima Press
Walnut Creek, California
   Martin Odersky є створювачем мови Scala та професором EPFL in Lausanne, Switzerland.
   Lex Spoon робив над Scala протягом двох років разом з Martin Odersky.
   Bill Venners є президентом Artima, Inc.</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_">Передмова</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви обрали чудовий час взяти до рук цю книгу! Сприйняття Scala продовжує пришвидшуватись, наша спільнота вирує, та навкола пропозиції роботи. Чи ви програмуєте для розваги чи для прибутку (або обоє), обіцяна Scala радість та продуктивність робить супротив складним. Щодо мене, дійсна радість програмування походить від протистояння цікавим викликам, за допомогою простих, витончених рішень. Місія Scala не тільки в тому, щоб зробити це можливим, але приємним, і ця книга покаже вам як.</p></div>
<div class="paragraph"><p>Зпочатку я експериментував з Scala 2.5, та миттєво був втугнутий в її синтаксичну та концептуальну впорядкованість. Коли я натрапив на нерегулярність, що параметри типів самі не можуть мати параметри типів, я (боязко) підійшов до Martin Odersky на конференції в 2006, та запронував стажування, щоб позбутись цього обмеження. Моя контриб'юція була сприйнята, що привнесло підтримку поліморфізм конструкторів типів в Scala 2.7 та вище. З тих пір я робив над більшістю інших частин компілятора. В 2012 я пішов з пост-докторської практики в лабораторії Martin на керівника команди Scala в Typesafe, по мірі того, як Scala, з версією 2.10, подорослішала від своїх прагматичних академічних коренів до надійної мови рівня корпорації.</p></div>
<div class="paragraph"><p>Scala 2.10 була поворотною точкою від швидко розвинених, багатих можливостями релізів, базованих на академічних дослідах, в напрямку фокусування на спрощенні та збільшенні прийняття адаптації підприємствами. Ми змістили нашу увагу на проблеми, які неможливо описати в дисертаціях, такі, як бінарна сумісність між головними релізами. Щоб збалансувати стабільність з нашим бажанням продовжувати розробку та покращення платформи Scala, ми робимо в напрямку меньшої головної бібліотеки, яку ми збираємось стабілізувати, при цьому розвиваючи платформу як ціле. Щоб зробити це можливим, мій перший проект в якості технічного керівника Scala був початок модулярізації стандартної бібліотеки Scala в 2.11.</p></div>
<div class="paragraph"><p>Щоб зменшити частоту змін, Typesafe також вирішила поперемінно змінювати бібліоттеку та компілятор. Ця редакція Програмування на Scala відноситься до Scala 2.12, що буде релізом компілятора, який матиме новий бек-енд та оптимізатор, щоб отримати більше від нових можливостей Java 8. Для взаємодії з Java, та насолодження тими ж перевагами від оптимізації JVM, Scala компілює функції в той самий байткод, що і компілятор Java 8. Подібно, трейти Scala тепер компілюються в інтерфейси Java з методами по замовчанню. Обоє схеми компіляції зменшують магію, яку мали виконувати старіші компілятори Scala, більш тісно наближаючи нас до платформи Java, при цьому покращуючи обоє, час компіляції та продуктивність часу виконання, з гладшою бінарною сумісністю!</p></div>
<div class="paragraph"><p>Це покращення до платформи Java 8 дуже захоалююче для Scala, та це дуже приємно бачити, що Java рівняється на тренд, який Scala встановлювала протягом дисятиріччя! Без жодного сумніву, що Scala провадить значно більш функціональний досвід програмування, з незмінністю по замовчанню, уніформним трактуванням виразів (навряд чи в цій книзі можливо побачити твердження return), співпадіння шаблонів, варіативність в місці визначення (варіативність в місці використання Java робить створення субтипів функції незграбним), і так далі! Кажучи прямо, існує дещо в функціональному програмуванні, ніж милий синтаксис для лямбди.</p></div>
<div class="paragraph"><p>В якості розпорядників мови, наша ціль є розробляти основу мови, так само, як зрощувати екосистему. Scala є успішною, оскільки вона має багато чудових бібліотек, видатні IDE та інструменти, та дружніх і завжди готових допомогти членів нашої спільноти. Я глибоко насолоджуюсь своєю першою декадою зі Scala — як реалізатор мови, це є великим збудженням і натхненням бачити стільки програмістів, що насолоджуються Scala в безлічі напрямків.</p></div>
<div class="paragraph"><p>Я люблю програмувати на Scala, і маю надію ви полюбите також. Від імені спільноти Scala вітаю вас!</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Adriaan Moors
San Francisco, CA
January 14, 2016</code></pre>
</div></div>
<div class="sect1">
<h2 id="__2">Подяки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато людей доклали до цієї книги, та до матеріалів, які вона розкриває. Ми вдячні всім їм.</p></div>
<div class="paragraph"><p>Scala сама по собі була колективним зусиллям багатьох людей. Розробці та реалізації версії 1.0 допомагали Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman та Matthias Zenger. Phil Bagwell, Antonio Cunei, Iulian Dragos, Gilles Dubochet, Miguel Garcia, Philipp Haller, Sean McDirmid, Ingo Maier, Donna Malayeri, Adriaan Moors, Hubert Plociniczak, Paul Phillips, Aleksandar Prokopec, Tiark Rompf, Lukas Rytz та Geoffrey Washburn приєднали зусилля для розробки другої та поточної версії мови та інструментів.</p></div>
<div class="paragraph"><p>Gilad Bracha, Nathan Bronson, Caoyuan, Aemon Cannon, Craig Chambers, Chris Conrad, Erik Ernst, Matthias Felleisen, Mark Harrah, Shriram Krishnamurti, Gary Leavens, David MacIver, Sebastian Maneth, Rickard Nilsson, Erik Meijer, Lalit Pant, David Pollak, Jon Pretty, Klaus Ostermann, Jorge Ortiz, Didier Rémy, Miles Sabin, Vijay Saraswat, Daniel Spiewak, James Strachan, Don Syme, Erik Torreborre, Mads Torgersen, Philip Wadler, Jamie Webb, John Williams, Kevin Wright та Jason Zaugg окреслили дизайн мови, щедро подоілившись своїми ідеями з нами в живих та надихаючих дискусіях, через контриб'юцію важливих частин коду до зусиль відкритого коду, так само, як і через коментарі до попередніх версій цього документу. Дописувачі в список розсилки Scala також надали дуже корисний зворотній зв'язок, що допоміг нам покращити мову та інструменти.</p></div>
<div class="paragraph"><p>George Berger працював наполегливо, щоб зробити процес побудови та веб присутність книги роблячими гладко. Як результат, цей проект був чудово вільний від технічних непередбачуваностей.</p></div>
<div class="paragraph"><p>Багато людей надали нам цінний зворотній зв'язок щодо ранішніх версій цього тексту. Подяки надходять до Eric Armstrong, George Berger, Alex Blewitt, Gilad Bracha, William Cook, Bruce Eckel, Stéphane Micheloud, Todd Millstein, David Pollak, Frank Sommers, Philip Wadler, and Matthias Zenger. Також дякуємо до групи Silicon Valley Patterns, за їх дуже корисний огляд: Dave Astels, Tracy Bialik, John Brewer, Andrew Chase, Bradford Cross, Raoul Duke, John P. Eurich, Steven Ganz, Phil Goodwin, Ralph Jocham, Yan-Fa Li, Tao Ma, Jeffery Miller, Suresh Pai, Russ Rufer, Dave W. Smith, Scott Turnquest, Walter Vannini, Darlene Wallach та Jonathan Andrew Wolter. Та нам приємно подякувати Dewayne
Johnson та Kim Leedy за їх допомогу з оформленням обкладинки, та Frank Sommers за його роботу з індексом.</p></div>
<div class="paragraph"><p>Нам також приємно поширити особливі подяки всім нашим читачам, що надали коментарі. Ваші коментарі дуже корисні для нас в окресленні цієї, навіть кращої книжки. Ми не можемо надрукувати імена всіх, хто надіслав коментарі. але ось імена тих читачів, які надіслали щонайменьше п'ять коментарів на протязі стадії eBook PrePrint®, через клацання на посиланні Suggest, впорядковані від найбільшого загального числа надісланих коментарів, та потім за алфавітом. Подякі до: David Biesack, Donn Stephan, Mats Henricson, Rob Dickens, Blair Zajac, Tony Sloane, Nigel Harrison, Javier Diaz Soto, William Heelan, Justin Forder, Gregor Purdy, Colin Perkins, Bjarte S. Karlsen, Ervin Varga, Eric
Willigers, Mark Hayes, Martin Elwin, Calum MacLean, Jonathan Wolter, Les Pruszynski, Seth Tisue, Andrei Formiga, Dmitry Grigoriev, George Berger, Howard Lovatt, John P. Eurich, Marius Scurtescu,Jeff Ervin, Jamie Webb, Kurt Zoglmann, Dean Wampler, Nikolaj Lindberg, Peter McLain, Arkadiusz Stryjski, Shanky Surana, Craig Bordelon, Alexandre Patry, Filip Moens, Fred Janon, Jeff Heon, Boris Lorbeer, Jim Menard, Tim Azzopardi, Thomas Jung, Walter Chang, Jeroen Dijkmeijer, Casey Bowman, Martin Smith, Richard Dallaway, Antony Stubbs, Lars Westergren, Maarten Hazewinkel, Matt Russell, Remigiusz Michalowski, Andrew Tolopko, Curtis Stanford, Joshua Cough, Zemian Deng, Christopher Rodrigues Macias, Juan Miguel Garcia Lopez, Michel Schinz, Peter Moore, Randolph Kahle, Vladimir Kelman, Daniel Gronau, Dirk Detering, Hiroaki Nakamura, Ole Hougaard, Bhaskar Maddala, David Bernard, Derek Mahar, George Kollias, Kristian Nordal, Normen Mueller, Rafael Ferreira, Binil
Thomas, John Nilsson, Jorge Ortiz, Marcus Schulte, Vadim Gerassimov, Cameron Taggart, Jon-Anders Teigen, Silvestre Zabala, Will McQueen та Sam Owen.</p></div>
<div class="paragraph"><p>Ми також бажаемо подякувати тим, хто надіслав коментарі та помилки після друку перших двох видань, включаючи Felix Siegrist, Lothar Meyer-Lerbs, Diethard Michaelis, Roshan Dawrani, Donn Stephan, William Uther, Francisco Reverbel, Jim Balter, and Freek de Bruijn, Ambrose Laing, Sekhar Prabhala, Levon Saldamli, Andrew Bursavich, Hjalmar Peters, Thomas Fehr, Alain O&#8217;Dea, Rob Dickens, Tim Taylor, Christian Sternagel, Michel Parisien, Joel Neely, Brian McKeon, Thomas Fehr, Joseph Elliott, Gabriel da Silva Ribeiro, Thomas Fehr, Pablo Ripolles, Douglas Gaylor, Kevin Squire, Harry-Anton Talvik, Christopher Simpkins, Martin Witmann-Funk, Jim Balter, Peter Foster, Craig Bordelon, Heinz-Peter Gumm, Peter Chapin, Kevin Wright, Ananthan Srinivasan, Omar Kilani, Donn Stephan, Guenther Waffler.
Lex would like to thank Aaron Abrams, Jason Adams, Henry and Emily Crutcher, Joey Gibson, Gunnar Hillert, Matthew Link, Toby Reyelts, Jason Snape, John та Melinda Weathers, та всім членам Atlanta Scala Enthusiasts за багато корисних дискусій щодо розробки мови, її матеатичних засадах, та як презентувати Scala працюючим інженерам.</p></div>
<div class="paragraph"><p>Спеціальна подяка для Dave Briccetti та Adriaan Moors за огляд третього видання, та до Marconi Lanna за не тільки огляд, але за надання мотивації для третього видання, надаючи розмову, озаглавлену "Що нового з часів Програмування на Scala."</p></div>
<div class="paragraph"><p>Bill має подякувати Gary Cornell, Greg Doench, Andy Hunt, Mike Leonard, Tyler Ortman, Bill
Pollock, Dave Thomas та Adam Wright за провадження розуміння та поради по друку книжки. Bill також дякує Dick Wall за взаємодію над курсом Escalate Stairway to Scala, що значною частиною базується на цій книжці. Наші багато років досвіду викладання Stairway to Scala допомогло зробити цю книжку краще. Нарешті, Bill має подякувати Darlene Gruendl та Samantha Woolf за їх допомогу в тому, щоб третє видання було закінчене.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__3">Вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця книжка є туторіалом по мові програмування Scala, написану людьми, напряму причетними до розробки Scala. Наша ціль полягає в тому, щоб читаючи цю книжку ви могли навчитись всьому, що треба, щоб бути продуктивним Scala програмістом. Всі приклади в цій книжці компілюються за допомогою Scala версії 2.11.7, за винятком тих, що відмічені 2.12, що компілюються за допомогою 2.12.0-M3.</p></div>
<div class="sect2">
<h3 id="_____">Кому слідує читати цю книжку</h3>
<div class="paragraph"><p>Головна цільова аудієнція для цієї книжки є програмісти, які бажають навчитись програмуванню на Scala. Якщо ви бажаєте робити ваш наступний проект на Scala, тоді ця книжка для вас. На додаток, книжка має бути цікавою для програмістів, що бажають розширити свої горизонти через навчання нових концепцій. Наприклад, якщо ви Java програміст, читання цієї книжки відкриє вас до багатьох концепцій з функціонального програмування, так само, як просунутих об'єктно-орієнтовних ідей. Ми віримо, що навчання  Scala, та стоячих за нею ідей, може допомогти стати кращим програмістом, загалом.</p></div>
<div class="paragraph"><p>Передбачається загальне знання програмування. Хоча Scala є гарною першою мовою програмування, це не книжка для навчання програмуванню.</p></div>
<div class="paragraph"><p>З іншого боку, ніякого спеціального знання мов програмування не потрібне. Навіть якщо більшість людей використовують Scala на платформі Java, ця книга не очікує, що ви знаєте щось про Java. Однак ми очікуємо, що багато читачів будуть знайомі з Java, так що часом порівнюємо Scala з Java, щоб допомогти таким читачам розуміти відмінності.</p></div>
</div>
<div class="sect2">
<h3 id="____">Як використовувати цю книгу</h3>
<div class="paragraph"><p>Оскільки головне призначення цієї книжки служити туторіалом, рекомендований спосіб читати цю книгу в порядку глав, зпочатку до кінця. Ми дуже намагались викладати одну тему за раз, та пояснюємо нові теми тільки в термінах тем, що ми вже розглянули. Таким чином, якщо ви пересунетесь в кінець, що скоріше підхопити щось, ви можете винайти, що це пояснено в термінах концепцій, що ви не зовсім розумієте. Доки ви читаєте глави по порядку, ми вважаємо, що ви знайдете досить прямолінійним отримати знання в Scala, по одному кроку за раз.</p></div>
<div class="paragraph"><p>Якщо ви бачите невідомий вам термін, будьте певні, що перевірили глосарій та індекс. Багато читачів будуть швидко переглядати частини книжки, і це непогано. Глосарій та індекс можуть допомогти вам надолужити, якщо ви проскочили щось дуже швидко.</p></div>
<div class="paragraph"><p>Після того, як ви прочитали книжку один раз, вона може також служити посиланням мови. Існує формальна специфікація мови Scala, але специфікація мови намагається бути точною, ціною читабельності. Хоча ця книга не покриває кожної деталі Scala, вона досить повна, та може служити як доступне посилання до мови, по мірі як ви ставатимете більш адаптованим в програмуванні Scala.</p></div>
</div>
<div class="sect2">
<h3 id="___scala">Як навчатись Scala</h3>
<div class="paragraph"><p>Ви можете багато чому навчитись про Scala, просто читаючи цю книжку від корки до корки. Однак, ви можете навчитись Scala швидше та більш глибоко, якщо зробите декілька додаткових речей.</p></div>
<div class="paragraph"><p>Зпершу, ви можете отримати вигоду від багатьох прикладів програм, включених в цю книжку. Набираючи їх самотужки є шляхом змісити ваші думки проходити через кожний рядок коду. Пробуючи варіації є шляхом зробити це більш веселим, та переконатись, що ви дійсно розумієте, як вони працюють.</p></div>
<div class="paragraph"><p>Друге, пристаньте до багатьох онлайн форумів. Таким чином ви та інші інтузіасти Scala можете допомагати один одному. Є багато списків розсилки, дискусійних форумів, чат кімнат, wiki, та декілька Scala-специфічних фідів статей. Витратьте деякий час для пошуку такого, що задовільняє вашим інформаційним потребам. Ви будете витрачати значно меньше часу за вирішенням простих проблем, так що ви зможете витрачати час на глибші, більш важливі питання.</p></div>
<div class="paragraph"><p>Нарешті, коли ви прочитаєте досить, оберіть собі власний програмний проект. Робіть над малою програмою від початку, або розробляйте додаток до більшої програми. Ви можете зайти тільки так далеко, читаючи.</p></div>
</div>
<div class="sect2">
<h3 id="__ebook">Можливості eBook</h3>
<div class="paragraph"><p>Ця книжка доступна в обох, паперовій формі та PDF eBook. eBook не просто електронна копія паперової версії книжки. Хоча вміст той самий, що і в паперовій версії, eBook була прискіпливо розроблена та оптимізована для читання на комп'ютерному екрані.</p></div>
<div class="paragraph"><p>Перша річ, що треба зауважити, це що більшість посилань в eBook і гіперпосиланнями. Якщо ви виберете главу, малюнок, або елемент глосарію, ваш PDF переглядач  повинене перенести вас прямо до обраного елементу, так що вам не знадобиться гортати, щоб знайти його.</p></div>
<div class="paragraph"><p>Додатково, знизу кожної сторінки в eBook є декілька навігаційних посилань. Посилання Обкладинка, Огляд та Вміст перенесуть вас на вступні сторінки книжки. Глосарій та Індекс посилаються на частини посилань книжки. Нарешті, посилання Обговорення перенесе вас до онлайн форуму, де ви обговорюєте питання з другими читачами, авторами та ширшою спільнотою Scala. Якщо ви знайдете помилку друку, або щось, що ви вважаєте має пояснюватись краще, будь ласка клацніть на посилання Зауваження, що перенесе вас до онлайн веб застосування, де ви можете надати зворотній зв'язок авторам.</p></div>
<div class="paragraph"><p>Хоча та сама сторінка з'являється в eBook як і в друкованій книжці, порожні сторінки видалені, та залишені сторінки перенумеровані. Сторінки пронумеровані по-різному, так що вам простіше визначати номери сторінок PDF при друці тільки частини eBook. Таким чином, сторінки в eBook є нумеровані саме так, як їх нумероватиме PDF переглядач.</p></div>
</div>
<div class="sect2">
<h3 id="__">Типографічні домовленості</h3>
<div class="paragraph"><p>Перший раз, коли визначається <em>термін</em>, він виділяється прописом. Малий приклад коду як  <code>x + 1</code>, записується інлайн моноширинним шрифтом. Більші приклади коду покладаються в моноширинні блоки запозичень, як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">hello</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли показується інтерактивна оболонка, відповіді від оболонки показуються легшим шрифтом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>scala&gt; <span class="m">3</span> + <span class="m">4</span>
res0: <span class="nv">Int</span> <span class="o">=</span> <span class="m">7</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Огляд вмісту</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Глава 1 "Маштабована мова", надає вам огляд дизайну Scala, разом з міркуваннями, історією, що стоять за нею.
</p>
</li>
<li>
<p>
Глава 2 "Перші кроки в Scala", показує вам, як робити декілька базових завдань програмування в Scala, не вдаючись в великі деталі щодо того, як воно робить. Ціль цієї глави є змусити ваші пальці почати друкувати та виконувати код Scala.
</p>
</li>
<li>
<p>
Глава 3 "Наступні кроки в Scala", показує вам декілька більш базових програмних завдань,  що будуть допомагати вам швидко набрати темп в Scala. Після завершення цієї глави, ви повинні бути в змозі почати використовувати Scala для простих скриптових задач.
</p>
</li>
<li>
<p>
Глава 4 "Класи та об'єкти", розпочинає глибинне покриття Scala з визначення його базових об'єктно-орієнтованих будівельних блоків та інструкцій щодо того, як компілювати та виконувати застосування Scala.
</p>
</li>
<li>
<p>
Глава 5 "Базові типи та операції", розкриває базові типи Scala, їх літерали, операції, що ви можете виконувати з ними, як роблять преоритети та асоційованість, та що таке збагачені обертки.
</p>
</li>
<li>
<p>
Глава 6 "Функціональні об'єкти", занурюється більш глибоко в об'єктно-орієнтовні можливості Scala, використовуючи функціональні (тобто незмінні) раціональні числа в якості приклада.
</p>
</li>
<li>
<p>
Глава 7 "Вбудовані керівні структури", показує вам, як використовувати вбудовані структури керування Scala: if, while, for, try, та match.
</p>
</li>
<li>
<p>
Глава 8 "Функції та замикання", провадить глибинне пояснення функцій, базових будівельних блоків функціональних мов.
</p>
</li>
<li>
<p>
Глава 9 "Абстракції керування", показує, як розширювати базові керуючі структури Scala через визначення ваших власних керівних абстракцій.
</p>
</li>
<li>
<p>
Глава 10 "Композиція та наслідування", обговорює більше з підтримки Scala об'єктно-орієнтовного програмування. Теми не такі фундаментальні, як ті що в Главі 4, але вони часто постають на практиці.
</p>
</li>
<li>
<p>
Глава 11 "Ієрархія Scala", пояснює ієрархію наслідування Scala, та обговорює її універсальні методи та нижні типи.
</p>
</li>
<li>
<p>
Глава 12 "Трейти", розказує про механізм Scala для міксін композиції. Глава показує, як роблять трейти, описує загальні використання, та пояснює, як трейти покращують традиційне множинне наслідування.
</p>
</li>
<li>
<p>
Глава 13 "Пакунки та імпорти", обговорює проблеми програмування в широкому сенсі, включаючи пакунки вищого рівня, твердження імпорту, та модифікатори контроля доступа, як <code>protected</code> та <code>private</code>.
</p>
</li>
<li>
<p>
Глава 14 "Твердження та тести", показує механізм тверджень Scala, та надає тур по декількох інструментах для написання тестів в Scala, зокрема фокусуючись на ScalaTest.
</p>
</li>
<li>
<p>
Глава 15 "Кейс класи та співпадіння шаблонів", вводять конструкції-близьнюки, що підтримують вас при написанні регулярних, неінкапсульованих структур даних. Кейс класи та співпадіння шаблонів зокрема корисні для дерево-подібних рекурсивних даних.
</p>
</li>
<li>
<p>
Глава 16 "Робота зі списками", пояснює в деталях списки, що, можливо, найбільш загально уживані структури даних в програмах Scala.
</p>
</li>
<li>
<p>
Глава 17 "Робота з іншими колекціями", показує вам, як використовувати базові колекції Scala, такі як списки, масиси, кортежі, множини та мапи.
</p>
</li>
<li>
<p>
Глава 18 "Змінні об'єкти", пояснює змінні об'єкти, та синтаксис, що провадить Scala для їх вираження. Глава завершується практичним заняттям на симуляцію дискретних подій, що показує деякі змінні об'єкти в дії.
</p>
</li>
<li>
<p>
Глава 19 "Типова параметризація", пояснює деякі з прийомів для приховування інформації, введеної в Главі 13 з допомогою конкретного прикладу: розробкою класу для чисто функціональних черг. Глава будується до визначення варіантності типових параметрів, та як це взаємодіє з приховуванням інформації.
</p>
</li>
<li>
<p>
Глава 20 "Абстрактні члени", описує всі типи абстрактних членів, як підтримує Scala; не тільки методи, але також поля та типи, можуть бути декларовані як абстрактні.
</p>
</li>
<li>
<p>
Глава 21 "Неявні переткорення та параметри", розкриває дві конструкції, що можуть допомогти вам оминути нудних деталей джерельного коду, та дозволяючи компілятору надати їх замість цього.
</p>
</li>
<li>
<p>
Глава 22 "Реалізація списків", описує реалізацію класу List. Важливо розуміти, як списки роблять в Scala, і більше того, реалізація демонструє використання деяких можливостей Scala.
</p>
</li>
<li>
<p>
Глава 23 "Переосмислені вирази for", показує як вирази for транслюються на виклики map, flatMap, filter та foreach.
</p>
</li>
<li>
<p>
Глава 24 "Колекції поглиблено", Надає детальний тур по бібліотеці колекцій.
</p>
</li>
<li>
<p>
Глава 25 "Архитектура колекцій Scala", показує як побудована бібліотека колекцій, та як ви можете реалізувати свої власні колекції.
</p>
</li>
<li>
<p>
Глава 26 "Екстрактори", показує, як робити співпадіння шаблонів з довільними класами, не тільки з кейс класами.
</p>
</li>
<li>
<p>
Глава 27 "Анотації", показує, як робити з розширенням мови через анотації. Глава описує декілька стандартних анотацій, та показує, як робити ваші власні.
</p>
</li>
<li>
<p>
Глава 28 "Робота з XML", пояснює, як обробляти XML в Scala. Глава показує вам ідіоми генерації XML, його розбір, та обробку, коли він вже розібраний.
</p>
</li>
<li>
<p>
Глава 29 "Модулярне програмування з використанням об'єктів", показує, як ви можете використовувати об'єкти Scala як модульну систему.
</p>
</li>
<li>
<p>
Глава 30 "Еквівалентність об'єктів", вказує на деякі проблеми, які треба розглядати, коли пишете метод <code>equals</code>. Є декільки ловушок, що треба уникнути.
</p>
</li>
<li>
<p>
Глава 31 "Комбінація Scala та Java", обговорює проблеми, що постають, коли комбінуєте Scala та Java разом в одному проекті, та рекомендовані методи щодо їх подолання.
</p>
</li>
<li>
<p>
Глава 32 "Ф'ючерси та конкурентність", показує вам, як використовувати Scala Future. Хоча ви можете використовувати примітиви конкуренції платформи Java для Scala програм, ф'ючерси можуть допомогти вам уникнути мертвого блокування та стану гонок, що зачумлюють традиційний підхід "потоки та блокування" до конкуренції.
</p>
</li>
<li>
<p>
Глава 33 "Комбінаторний розібр", показує, як побудувати парсери з використанням бібліотеки Scala парсерних комбінаторів.
</p>
</li>
<li>
<p>
Глава 34 "Програмування користувацького інтерфейсу", надає швидкий тур бібліотеки Scala, що спрощує програмування GUI за допомогою Swing.
</p>
</li>
<li>
<p>
Глава 35 "Електронна таблиця SCells", зв'язує все разом, показуючи повне застосування електронної таблиці, написане на Scala.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="__4">Ресурси</h3>
<div class="paragraph"><p>На <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>, головному веб ресурсі для Scala, ви знайдете останній реліз Scala та посилання на документацію та ресурси спільноти. Для більш стиснутої сторінки з посиланнями навідайтесь на сайт книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>. Щоб поспілкуватись з іншими читачами цієї книжки, перевірте форум Programming in Scala Forum,
за адресою: <a href="http://www.artima.com/forums/forum.jsp?forum=282">http://www.artima.com/forums/forum.jsp?forum=282</a>.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Джерельний код</h3>
<div class="paragraph"><p>Ви можете завантажити ZIP файл, що містить джерельний код цієї книги, що випущений пді відкритою ліцензією Apache 2.0, с зайта книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>.</p></div>
</div>
<div class="sect2">
<h3 id="__5">Помилки</h3>
<div class="paragraph"><p>Хоча ця книжки була щільно переглянута та перевірена, помилки всеж-таки неодмінно будуть прослизати. Для (надіємось, короткого) списку помилок друку для цієї книжки навідайтесь на <a href="http://booksites.artima.com/programming_in_scala_3ed/errata">http://booksites.artima.com/programming_in_scala_3ed/errata</a>. Якщо ви знайшли помилку, будь ласка повідомьте про неї за носиланням нижче URL, так що ми виправимо її при наступному друці або виданні цієї книжки.
:ascii-ids:
:doctype: book
:source-highlighter: pygments</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__1">Глава 1</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___4">Маштабована мова</h1>
<div class="paragraph"><p>Ім'я Scala означає "scalable language", тобто маштабована мова. Мова названа так, оскільки вона була розроблена зростати разом з потребами своїх користувачів. Ви можете застосувати Scala до широкого диапазону програмних завдань, від написання невеликіх скриптів, до побудови великих систем.<span class="footnote"><br />[Scala вимовляється skah-lah.]<br /></span></p></div>
<div class="paragraph"><p>До Scala легко дістатись. Вона працює на стандартній Java платформі, та без проблем взаємодіє з усіма бібліотеками Java. Це досить гарна мова для напсання скриптів, що стягають разом Java компоненти. Але вона може застосувати свою потужність навіть більше для побудови великих систем та фреймворків реюзабельних компонент.</p></div>
<div class="paragraph"><p>Технічно Scala є сумішшю об'єктно-орієнтованих та функціональних програмних концепцій в статично типізованій мові. Зплав об'єктно-орієнтовного та функціонального програмування виявляється в багатьох різних аспектах Scala; воно, можливо, більш проникаюче, ніж в любій іншій широко уживаній мові. Два стилі програмування мають доповнюючі сильні сторони, коли доходить до маштабованості. Функціональні програмні конструкції Scala роблять простим будувати цікаві речі швидко, з простих частин. Її об'єктно-орієнтовні конструкції спрощують структурувати більші системи, та адаптувати їх до нових вимог. Комбінація двох стилів в Scala робить можливим виражати нові типи програмних шаблонів та компонентних абстракцій. Це також призводить до виразного та стислого стилю програмування. Та оскільки вона така піддатлива, програмування на Scala може бути дуже втішним.</p></div>
<div class="paragraph"><p>Ця початкова глава відповідає на запитання "чому Scala?". Вона дає високорівневий погляд на дизайн Scala та міркування позаду неї. Після читання глави ви повинні мати базове відчуття того, що таке є Scala, та які типи задач вона може допомогти виконати. Хоча ця книжка є туторіалом в Scala, ця глава насправді не є частиною туторіала. Якщо вам нетерпляче хочеться почати писати деякий Scala код, вам слідує перестрибнути далі до Глави 2.</p></div>
<div class="sect1">
<h2 id="_1_1______">1.1 Мова, що зростає разом з вами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Програми різного розміру схильні потребувати різних програмних конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця програма встановлює мапу з країн та їх столиць, модифікує мапу, додаючи нову прив'язку ("Japan" &#8594; "Tokyo"), та друкує столицю, що асоційована з країною France.<span class="footnote"><br />[Будь ласка, слідуйте за нами, якщо ви не розумієте всі деталі цієї програми. Вони будуть пояснені в наступних двох главах.]<br /></span> Нотація в цьому прикладі високорівнева, до діла, та не захаращена зайвими крапками з комою або анотаціями типів. Дійсно, відчувається що це сучасна "скриптова" мова, Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що має відношення до приклада вище, в тому, що всі вони підтримують конструкцію "асоціативної мапи" в синтаксисі мови.</p></div>
<div class="paragraph"><p>Асоциативні мапи дуже корисні, оскільки вони дозволяють утримувати програми чіткими та лаконічними, але іноді ви можете не погодитись з їх філософією "один розмір підходить всім", оскільки вам треба контролювати властивості мап, які ви використовуваєте в вашій програмі, в більше гарно-контрольований спосіб. Scala надає вам цей гарний контроль, якщо ви потребуєте його, оскільки мапи в Scala не є синтаксисом мови. Вони є бібліотечними абстракціями, які ви можете розширити та адаптувати.</p></div>
<div class="paragraph"><p>В програмі вище ви отримали реалізацію Map по замовчанню, але ви можете легко змінити це. Ви можете, наприклад, вказати окрему реалізацію, таку як HashMap або TreeMap, або визвати метод <code>par</code> що отримати <code>ParMap</code>, що виконує операції паралельно. Ви можете вказати значення по замовчанню для мапи, або ви можете переписати любий інший метод мапи, яку ви створюєте. В кожному випадку, ви можете використовувати той самий простий синтаксис доступу для мап, що і в прикладі вище.</p></div>
<div class="paragraph"><p>Цей приклад показує, що Scala дати вам обоє, зручність та гнучкість. Scala має набір зручних конструкцій, що допомагають вам стартовати швидко, та дозволяють вам програмувати в приємно стислому стилі. В той же час, ви маєте впевненість, що ви не переростете мову. Ви завжди можете підкроїти програму до ваших потреб, оскільки все базується на бібліотечних модулях, які ви можете обрати та адаптувати, якщо треба.</p></div>
<div class="sect2">
<h3 id="___">Вирощування нових типів</h3>
<div class="paragraph"><p>Eric Raymond ввів собор та базар як дві метафори софтверної розробки.<span class="footnote"><br />[Raymond, The Cathedral and the Bazaar. [Ray99]]<br /></span> Собор майже досконала будівля, що займає довгий час доки збудується. Коли вже побудований, він стоїть незмінний довгий час. На відміну від цього базар адаптується та розширюється кожного дня, людьми, що роблять на ньому. В роботі Raymond базар є метафорою розробки програм з відкритим кодом. Guy Steele зауважив в розмові про "зростаючу мову", що ту саму різницю можна застосувати до дизайна мови.<span class="footnote"><br />[Steele, Growing a language. [Ste99]]<br /></span> Scala є значно більше базаром, ніж собором, в сміслі, що вона розроблена бути розширеною та адаптованою людьми, що програмують на ній. Заміть провадити всі конструкції, що можуть будь-коли вам знадобитись в "досконало повній мові", Scala покладає в ваші руки інструменти для побудови таких конструкцій.</p></div>
<div class="paragraph"><p>Ось приклад. Багато застосувань потребують тип цілих, що може стати довільно великим без переповнення або "циклічного переносу" арифметичних операцій. Scala визначає такий тип в бібліотечному класі scala.BigInt. Ось визначення метода, що використовує цей тип, що обчислює факторіал переданого цілого значення:<span class="footnote"><br />[factorial(x), або в математичній нотації x!, є результатом обчислення 1 * 2 * &#8230; * x, де 0! визначене як 1.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ми викличемо <code>factorial(30)</code>, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">265252859812191058636308480000000</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt виглядає як вбудований тип, оскільки ви можете використовувати цілі літерали та оператори, як * та - зі значеннями цього типу. Але це все ще клас, що визначений в стандартній бібліотеці.<span class="footnote"><br />[Scala іде зі стандартною бібліотекою, дещо з якої буде показане в цій книжці. Для додаткової інформації ви можете звернутись до документації Scaladoc по бібліотеці, що доступна в дистрибутиві та онлайн <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>.]<br /></span> Якщо клас був би відсутній, було б прямолінійним для кожного програміста Scala написати реалізацію, наприклад, через огортання Java класу java.math.BigInteger (фактично, саме так реалізований клас Scala).</p></div>
<div class="paragraph"><p>Звичайно, ви можете використовувати клас Java напряму. Але результат і близько не такий приємний, бо хоча Java дозволяє вам створювати нові типи, ці типи не дуже виглядають як природна підтримка мови:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.math.BigInteger</span>
<span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInteger</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInteger</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ZERO</span><span class="o">)</span>
    <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span>
  <span class="k">else</span>
    <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">subtract</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt є представником багатьох інших число-подібних типів - великих десятичних, комплексних чисел, раціональних чисел, довірчих інтервалів, поліноміалів - список продовжується. Деякі мови програмування реалізують деяки з ціх типів природно. Наприклад, Lisp, Haskell та Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але кожна мова, що намагається реалізувати всі з ціх абструкцій одночасно, просто стане дуже великою, щоб бути керованою. Що ще більше, навіть якщо б така мова могла б існувати, деякі застосування напевно могли б отримати переваги від інших число-подібних типів, що не були включені. Так що спроба запровадити все в одній мові маштабується не дуже добре. Замість цього Scala дозволяє користувачам вирощувати та адаптувати мову в напрямках, які ї потрібні, визначаючи прості-в-використанні бібліотеки, що виглядають як природна підтримка мови.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Вирощування нових керуючих структур</h3>
<div class="paragraph"><p>Попередній приклад демонструє, що Scala дозвляє вам додавати нові типи, що можуть бути такі ж зручні в використанні, що і вбудовані типи. Той же принцип розширення також стосується до керуючих структур. Цей різновид розширюваності ілюстрований Akka, Scala API до "актор-базованого" конкурентного програмування.</p></div>
<div class="paragraph"><p>По мірі того, як багатоядерні процесори будуть продовжувати розмножуватись в наступні роки, досягнення прийнятної продуктивності може підвищувати потребу, щоб ви використовували більше парлелизма в ваших програмах. Часто це буде означати переписування вашого коду, так, щоб розподілити обчислення між декількома конкурентними потоками. Нажаль, створення надійних багатопоточних застосувань доведено складна задача на практиці. Модель поточності Java побудована навколо загальної пам'яті та блокування, модель, яку часто складно промислити, особливо коли система зростає в розмірі та складності. Складно бути впевненим, що ви не маєте стану гонок або мертвого блокування, що десь причаїлись — дещо, що не проявилось під час тестування, але може проявитись під час використатння. Як можливо безпечніша альтернатива є архитектура передачі повідомлень, така, як підхід "акторів", використаний в мові програмування Erlang.</p></div>
<div class="paragraph"><p>Java іде з багатою, основаною на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, так само, як любе інше Java API. Однак існує Akka, що є додатковою бібліотекою Scala, яка реалізує модель акторів, подібних то таких в Erlang.</p></div>
<div class="paragraph"><p>Актори є абстракцією конкурентності, що може бути реалізвана поверху потоків. Вони комунікують через надсилання повідомлень один одному. Актор може виконувати дві базові операції, надсилання та отримання повідомлення. Операція <code>send</code>, позначена знаком наголосу(!), надсилає повідомлення актору. Ось приклад, в якому актор називається <code>recipient</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>recipient ! msg</code></pre>
</div></div>
<div class="paragraph"><p>Надсилання асинхронне; тобто, надсилаючий актор може продовжувати безпосередньо, без очікування щоб повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, в якому накопичуються повідомлення. Актор обробляє повідомлення, що надійшли в поштову скриньку через блок <code>receive</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Msg1</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg1</span>
  <span class="k">case</span> <span class="nc">Msg2</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg2</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Блок <code>receive</code> складається з декількох <code>case</code>, кожний з яких опитує поштову скриньку за шаблоном повідомлення. Перше повідомлення в скриньці, що співпаде з любим <code>case</code>, буде обране, та для нього виконується відповідна дія. Як тільки скринька більше не містить повідомлень, актор призупиняється, та очікує подальших входящих повідомлень.</p></div>
<div class="paragraph"><p>Як приклад, ось простий актор Akka, що реалізує сервіс калькулятора контрольних сум:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Data</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">byte</span>
    <span class="k">case</span> <span class="nc">GetChecksum</span><span class="o">(</span><span class="n">requester</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">checksum</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">requester</span> <span class="o">!</span> <span class="n">checksum</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зпочатку цей актор визначає локальну змінну на ім'я <code>sum</code> з початковим значенням нуль. Далі він визначає блок <code>receive</code>, що буде обробляти повідомлення. Якщо він отримає повідомлення Data, він додає збережений байт до змінної <code>sum</code>. Якщо отримано повідомлення GetChecksum, актор обчислює контрольну суму для поточного значення <code>sum</code>, та надсилає результат назад до запитувача, використовуючи надсилання повідомлення <code>requester ! sum</code>. Поле <code>requester</code> вбудоване в повідомлення GetChecksum; воно звичайно посилається актора, що зробив запит.</p></div>
<div class="paragraph"><p>Ми не очікуємо, що ви повністю розумієте приклад з актором на цей момент. Скоріше, що важливе щодо цього прикладу в плані маштабованості, це те, що ані блок <code>receive</code>, ані повідомлення <code>send</code> (!) не є вбудовані операції в Scala. Навіть вважаючи, що блок <code>receive</code> може виглядати та діяти дуже подібними до вбудованих керівних конструкцій, фактично це метод, визначений в бібліотеці акторів Akka. Подібно до цього, навіть вважаючи, що <em>!</em> виглядає як вбудований оператор, він також є тільки методом, визначеним в бібліотеці акторів Akka. Обоє з ціх конструкцій повністю незалежні від мови програмування Scala.</p></div>
<div class="paragraph"><p>Синтаксис блоку <code>receive</code> та <code>send</code> (!) вигладає в Scala здебільшого як вони виглядають в Erlang, але в Erlang ці конструкції вбудовані в мову. Akka також реалізує більшість з інших конкурентних програмних конструкцій Erlang, таких, як моніторинг схибивших акторів та тайм-аути. Кінець кінцем, модель акторів виявилась дуже приємним засобом для вираження конкурентних та розподілених обчислень. Навіть якщо вони визначені в біблиотеці, актори можуть відчуватись як інтегральна частина мови Scala.</p></div>
<div class="paragraph"><p>Цей приклад ілюструє, як ви можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Звичайно, вам знадобляться гарні архітектори та програмісти, щоб зробити це. Але вирішальна річ в тому, що це можливо — ви можете розробляти та реалізувати абстракції в Scala, що адресують радикально нові галузі застосування, та все ще відчувати це як природну підтримку мови при використанні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_2___scala_">1.2 Що робить Scala маштабованою?</h2>
<div class="sectionbody">
<div class="paragraph"><p>На маштабованість впливає багато факторів, в диапазоні від синтаксичних деталей до абстрактних конструкцій компонент. Однак якщо б нам доводилось назвати тільки один аспект Scala, що допомагає маштабованості, ми б обрали комбінацію об'єктно-орієнтованого та функціонально програмування (гаразд, ми змахлювали, насправді це два аспекти, але вони пов'язані).</p></div>
<div class="paragraph"><p>Scala іде далі, ніж всі інші гарно-відомі мови в справі зплавлення об'єкто-орієнтовного та функціонального програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції як дві окремі концепції, в Scala значення функції є об'єктом. Функціональні типи є класами, що можуть наслідуватись субкласами. Це може виглядати нічим іншим, ніж академічними тонкощами, але це має глибокі наслідки для маштабованості. Фактично, показана раніше концепція актора не могла б бути реалізованою без цієї уніфікації функцій та об'єктів. Цей розділ дає огляд шляху Scala по змішуванню об'єктно-орієнтовної та функціональної концепцій.</p></div>
<div class="sect2">
<h3 id="_scala____">Scala є об'єктно-орієнтовна</h3>
<div class="paragraph"><p>Об'єктно-орієнтоване програмування було назвичайно успішним. Починаючи з Simula в середині 60х та Smalltalk в 70х, воно зараз доступне в більшій кількості мов, ніж навпаки. В деяких галузях об'єкти повністю перебрали все на себе. Хоча немає точного визначення того, що означає об'єкт-орієнтовне, але ясно, що це щось щодо об'єктів, що апелює до програмістів.</p></div>
<div class="paragraph"><p>В принципі, мотивація для об'єктно-орієнтовного програмування дуже проста: всі, крім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, це покласти дані та операції в деяку форму контейнерів. Чудова ідея об'єктно-орієнтовного програмування це зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як і дані, та що вони самі по собі є значеннями, що можуть зберігатись в інших контейнерах, або передані як параметри до операцій. Такі контейнери називаються об'єктами. Alan Kay, винахідник Smalltalk, зауважував, що в такий спосіб найпростіший об'єкт має ті самі принципи конструкції, що і цілий компьп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом.<span class="footnote"><br />[Kay, "The Early History of Smalltalk." [Kay96]]<br /></span> Так що об'єкти мають багато чого докласти до маштабованості мови: та сама технологія застосовується до конструкції малих, так само як і до великих програм.</p></div>
<div class="paragraph"><p>Навіть якщо об'єктно-орієнтоване програмування було мейнстримом протягом довгого часу, є відносно мало мов, що послідували за Smalltalk в протисканні цього конструктивного принипу до його логічного висновку. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні значення в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтовного програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнюівати речі, та обмежувати маштабованість.</p></div>
<div class="paragraph"><p>Для контрасту Scala є об'єктно-орієнтовною мовою в чистій формі: кожне значення є об'єктом, та кожна операція є викликом метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви насправді викликаєте метод на ім'я + , визначений в класі Int. Ви можете визначити методи з оператор-подібними назвами, які потім клієнти вашого API використовують для використання в операторній нотації. Ось як розробник Akka API акторів дозволив вам використовувати вирази, такі як <code>requester ! sum</code>, показані в попередньому прикладі: ! є методом класу Actor.</p></div>
<div class="paragraph"><p>Scala є більш досвідченою, ніж багато інших мови, коли йдеться про композицію об'єктів. Прикладом є трейти Scala. Трейти подібні до інтерфейсів в Java, але вони також можуть мати реалізації методів, та навіть поля.<span class="footnote"><br />[Починаючи з Java 8, інтерфейси можуть мати реалізації методів по замовчанню, але вони не надають всі можливості трейтів Scala.]<br /></span> Об'єкти конструюються через композицію міксінів, що бере методи класу, та додає до них члени декількох трейтів. В цей спосіб різні аспекти класів можуть бути інкапсульовані в різні трейти. Це виглядає трохи схожим на множинне наслідування, але відрізняється, коли річ доходить до деталей. Це робить трейти більш "плагабельними", ніж класи. Зокрема, вони уникають класичних проблем "діамантового наслідування" множинних інтерфейсів, що виникає, коли деякий клас наслідується через декілька різних шляхів.</p></div>
</div>
<div class="sect2">
<h3 id="_scala__">Scala є функціональною</h3>
<div class="paragraph"><p>На додаток до того, що вона є чистою об'єктно-орієнтовною мовою, Scala також є повно-функціональною функціональною мовою. Ці ідеі функціонального програмування старіші ніж (електронні) комп'ютері. Їх основи були покладені в лямбда обчисленні Alonzo Church, що було розроблене в 1930х. Першою функціональною мовою був Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. Протягом довгого часу функціональне програмування було дещо на узбіччі — популярне в академічних колах, але не так широко використане в індустрії. Однак в останні роки намітилась зростаюча зацікавленість в функціональному програмуванні та технологіях.</p></div>
<div class="paragraph"><p>Функціональне програмування направляється двома головними ідеями. Перша ідея в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з тим самим статусом, що і, скажімо, ціле або рядок. Ви можете передати функції як аргументи в інші функції, повернути їх як результат з функції, або зберігати їх в змінних. Ви також можете визначити функцію всередині іншої функції, так само, як ви можете визначити ціле значення всередині функції. Та ви можете визначити функції без надання їм імен, скрапляючи ваш код функціональними літералами так просто, як ви можете записати цілий літерал, як 42.</p></div>
<div class="paragraph"><p>Функції, що є першокласними значеннями, провадять зручні засоби для абстрагування над операціями, та створення нових керівних структур. Це узагальнення функцій провадить чудову виразність, що часто призводить до дуже виразних та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, бібліотека тестування ScalaTest пропонує конструкцію <code>eventually</code>, що приймає функцію як аргумент. Це використовується приблизно так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">iterator</span>
<span class="n">eventually</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="n">shouldBe</span> <span class="mi">3</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Код всередині <code>eventually</code> — твердження, <code>it.next() shouldBe 3</code> — огорнуте в функцію, що передається без виконання до метода <code>eventually</code>. Для сконфігурованого проміжку часу, <code>eventually</code> буде виконувати функцію, доки буде виконуватись твердження.</p></div>
<div class="paragraph"><p>В більшості традиційних мов, для контрасту, функції не є значеннями. Мови, що є значення функцій, часто відсувають їх на другій план. Наприклад, указателі на функції в C та C++ не мають того самого статусу, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись тільки на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення в своєму оточенні. Також вони не дозволяють визначати неіменовані функціональні літерали.</p></div>
<div class="paragraph"><p>Друга головна ідея функціонального програмування в тому, що операції програми мають відзеркалювати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці.  Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масив символів. Символи в рядку можуть бути змінені індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку на кому, всередині того самого об'єкта рядка. В Java та Scala, з іншого боку, рядок є послідовність символі в математичному сенсі. Заміна символа в рядку, використовуючи вираз як s.replace(";","."), повертає новий об'єкт рядка, що є іншим від s. Інший шлях виразити те саме, це сказати, що рядкі незмінні в Java, тоді як вони змінні в Ruby. Так що з погляду тільки на рядки, Java є функціональною мовою, тоді як Ruby ні. Незмінні структури даних є один з наріжних каменів функціонального програмування. Бібліотеки Scala визначають значно більше незмінних типів даних, крім тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, тапли, мапи та множини.</p></div>
<div class="paragraph"><p>Інший шлях затвердити цю другу ідею функціонального програмування є те, що методам не слідує мати любі побічні ефекти. Вони мають комунікувати зі своїм оточенням тільки через прийняття аргументів, та повернення результатів. Наприклад, метод <code>replace</code> в класі Java String підходить під цей опис. Він приймає рядок та два символи, та видає новий рядок, де всі появлення одного символа замінюється на інший. Немає іншого ефекту виклику <code>replace</code>. Методи як <code>replace</code> називаються референційно прозорими, що означає, що для кожного взятого вводу виклик методу може бути замінений на свій результат, без впливу на семантику програми.</p></div>
<div class="paragraph"><p>Функціональні мови заохочують незмінні структури даних та референсно прозорі методи. Деякі функціональні мови навіть вимагають їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є назвою для програмування зі змінними даними та побічними ефектами. Але Scala загалом робить простим уникати імперативних конструкцій, коли ви бажаєте цього, бо існують гарні функціональні альтернативи.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_3__scala">1.3 Чому Scala?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Чи Scala для вас? Вам доведеться зрозуміти та прийняти рішення самостійно. Ми винайшли, що насправді багато причин, крім маштабованості, щоб програмувати на Scala. В цьому розділі будуть розглянуті чотири з найбільш важливих аспектів: сумісність, краткість, високорівневі абстракції та розвинена статична типізація.</p></div>
<div class="sect2">
<h3 id="_scala___2">Scala є сумісною</h3>
<div class="paragraph"><p>Scala не потребує, щоб ви зістрибували назад з платформи Java, щоб зробити крок вперед від мови Java. Вона дозволяє вам додати вартість до існуючого коду — щоб будувати на тому, що вже маєте, оскільки вона була розроблена для безшовної взаємодії з Java.<span class="footnote"><br />[Зпочатку була реалізація Scala, що робила на платформі .NET, але вона більше не активна. Останнім часом все більше популярною стає реалізація Scala, що робить на JavaScript, Scala.js.]<br /></span> Програми Scala компілюються на байткоди JVM. Її продуктивність часу виконання звичано співпадає з Java програмами. Код Scala може викликати методи Java, отримувати доступ до полів Java, наслідувати від Java класів, та реалізувати Java інтерфейси. Ніщо з цього не потребує спеціального синтаксису, явного визначення інтерфейсів, або зклеючого коду. Фактично, весь код Scala дуже тяжко використовує Java бібліотеки, часто без того, щоб програміст переймався цім фактом.</p></div>
<div class="paragraph"><p>Інший аспект повної взаємодії є те, що Scala потужно пере-використовує типи Java. Scala <code>Int</code> представлений як примітивне ціле Java типу <code>int</code>, <code>Float</code> представлені як <code>float</code>, <code>Boolean</code> як <code>boolean</code>, і так далі. Масиви Scala відображуються на масиві Java. Scala також пере-використовує багато зі стандартних бібліотечних типів Java. Наприклад, тип рядкового літерала "abc" в Scala є <code>java.lang.String</code>, та підійняті виключення мають бути субкласом <code>java.lang.Throwable</code>.</p></div>
<div class="paragraph"><p>Scala не тільки пере-використовує Java типи, але також "принаряджує" їх, щоб зробити їх кращими. Наприклад, методи підтримки рядків в Scala, як <code>toInt</code> або <code>toFloat</code>, що конвертують рядок на ціле або на число з плаваючою крапкою. Так що ви можете писати <code>str.toInt</code> замість <code>Integer.parseInt(str)</code>. Як це може бути досягнуте без руйнування сумісності? Клас Java String напевне не має метода <code>toInt</code>! Фактично, Scala має дуже загальне рішення для вирішення цього тертя між розширеним дизайном бібліотек, та взаємодією. Scala дозволяє вам вирішити неявні перетворення, що завжди застосовуються, коли типи не будуть звичайно співпадати, або коли обираються неіснуючі члени. В випадку вище, коли шукається метод <code>toInt</code> для рядка, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String на примірник класу Scala StringOps, що визначає такий член. Це перетворення буде потім неявно застосоване перед виконанням операції <code>toInt</code>. Код Scala також може викликатись з кода Java. Іноді це більш тонка матерія, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш розвинених можливостей Scala мають бути закодовані, перед тим, як іх можна буде відобразити на Java. Глава 31 пояснює деталі.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___3">Scala є стислою</h3>
<div class="paragraph"><p>Програми Scala мають схильність бути короткими. Програмісти на Scala повідомляють зменшення числа рядків до десяти раз, порівняно з Java. Це може бути екстремальним випадком. Більш консервативне очікування може бути таким: типова Scala програма має бути приблизно в половину довжини за числом рядків, до такої самої програми, написаної на Java. Меньше рядків коду означає не тільки менше друку, але також менше зусиль по читанню та розумінню програм, та менші можливості для дефектів. Існують різні фактори, що докладаються до цього зменшення рядків коду.</p></div>
<div class="paragraph"><p>Перше, синтаксис Scala уникає деяких шаблонів, що обтяжують Java програми. Наприклад, крапка з комою є опціональною в Scala, та звичано відкидається. Також є декілька інших площин, де синтаксис Scala менш шумлячий. Як приклад, порівняйте, як ви пишете класи та конструктори в Java та Scala. В Java клас з конструктором часто виглядає подібно до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// це Java</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala ви скоріше всього замість цього напишете таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код компілятор Scala спродукує клас, що має дві приватні змінні примірника, <code>Int</code> на ім'я <code>index</code> та <code>String</code> на ім'я <code>name</code>, та конструктор, що приймає первинні значення для ціх змінних в якості параметрів. Код цього конструктора буде ініціалізувати дві змінні примірника значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча Java версія.<span class="footnote"><br />[Єдина реальна різниця в тому, що змінні примірника, вироблені в випадку Scala, будуть фінальні. Ви навчитесь, як робити їх не-фінальними в Розділі 10.6.]<br /></span> Клас Scala швидше писати, протіше читати, та більш важливо - менше схильний до помилок, ніж Java клас.</p></div>
<div class="paragraph"><p>Вивід типів Scala є іншим фактором, що докладається до її стислості. Повторювана інформація інйормація про типи може бути відкинута, так що програми стають менш захащені та більш читабельні.</p></div>
<div class="paragraph"><p>Але, можливо, найбільш важливим ключем до компактного коду є код, що ви не маєте писати, бо він вже зроблений в бібліотеці за вас. Scala надає вам інструменти для визначення потужних бібліотек, що дають вам захопити та виділити загальну поведінку. Наприклад, різні аспекти класів бібліотеки можуть бути виділені в трейти, що можуть потім бути зміксовані разом в гнучкий спосіб. Або методи бібліотеки можуть бути параметризовані за допомогою операцій, що дозволяє вам визначати конструкції, які ефективно є вашими власними керівними структурами. Разом ці конструкції дозволяють визначення бібліотек, що одночасно високорівневі та гнучки в використанні.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___4">Scala є високорівневою</h3>
<div class="paragraph"><p>Програмісти постійно борються зі складністю. Щоб програмувати продуктивно, ви маєте розуміти код, з яким ви робите. Надскладний код був причиною падіння багатьох софтверних проектів. Нажаль, важливі програми звичано мають складні вимоги. Такої складності неможливо уникнути; замість цього єю треба керувати.</p></div>
<div class="paragraph"><p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракції в інтерфейсах, що ви розробляєте і якими користуєтесь. Як приклад, уявіть, що ви маєте змінну <code>String name</code>, та ви бажаєте визначити, чи містить цей рядок символи в великому реєстрі. До Java 8 ви могли написати такий цикл:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// this is Java</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
         <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
         <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як в Scala ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">nameHasUpperCase</span> <span class="k">=</span> <span class="n">name</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Код Java сприймає рядки як низьковірневі сутнсті, по яких можна крокувати символ за символом в циклі. Код Scala сприймає той самий рядок як високорівневу послідовність символів, до якої можливо робити запити за допомогою предикатів. Зрозуміло, що код Scala значно коротший, та — для тренованого ока — простіший для розуміння, ніж Java код. Так що код Scala менше заважує до загального бюджету складності. Він також дає вам менше можливостей робити помилки.</p></div>
<div class="paragraph"><p>Предикат _.isUpper є прикладом функціонального літералу в Scala.<span class="footnote"><br />[Функціональні літерали можуть бути названі предикатами, якщо тип їх результату Boolean.]<br /></span> Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи це символ верхнього реєстра.<span class="footnote"><br />[Це використання підкреслення як заповнювача для аргументів описане в Розділі 8.5.]<br /></span></p></div>
<div class="paragraph"><p>Java 8 вводить підтримку для лямбда та потоків, що дозволяє вам виконувати подібну операцію в Java. Ось як це може виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span>
<span class="c1">// це Java 8</span>
<span class="n">name</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">anyMatch</span><span class="o">(</span>
    <span class="o">(</span><span class="kt">int</span> <span class="n">ch</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">ch</span><span class="o">)</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це велике покращення над ранішніми версіями Java, код Java 8 все ще більше балакучий, ніж еквівалентний код Scala. Ця додаткова "важкість" Java коду, так само, як довгі традиції циклів Java, можуть заохотити багатьох Java програмістів за браком нових методів, як <code>exists</code>, просто писати цикли, та жити з підвищеною складністю їх кода.</p></div>
<div class="paragraph"><p>З іншого боку, функціональні літерали в Scala насправді легковажні, так що вони використовуютсья часто. Коли ви знатимете Scala краще, ви будете знаходити більше і більше можливостей для визначення та використання ваших власних керівних абстракцій. Ви побачите, що це допомагає уникати дублікації коду, і, таким чином, утримують ваш код коротним та чистішим.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування Scala також пропонує високорівневі принципи розмірковувати про програмування. Ключова ідея в тому, що ці функції є референтно прозорими — застосування функції характеризується тільки її результатом. Таким чином ви можете вільно замінити застосування функції на праву сторону функції (тобто тіло, що слідує за знаком рівняння), не турбуючись щодо жодних побічних ефектів. Цей принцип надає багато корисних законів, які ви можете задіяти для кращого розуміння або для рефакторинга вашого коду. Як приклад, ще раз візьмемо метод <code>exists</code>, описаний вище. Цей метод має задовільняти наступному правилу: для кожної послідовності <code>s</code>, та для кожної пари предикатів <code>p</code> та <code>q</code> має виконуватись таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">q</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">||</span> <span class="n">q</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, опитуючи ту саму послідовність двома предикатами p та q, та роблячи АБО з результатами є те саме, що перевірити один предикат, що одночасно перевіряє на p або q. Правило, подібне до цього, вочевідь корисне для написання та рефакторингу програм. Однак, якщо <code>exists</code> має побічні ефекти, загалом не буде коректно припускати існування такого закону, оскільки ліва частина виконує <code>exists</code> двічі для кожного елемента послідовності, тоді як права частина виконується тільки один раз для кожного елементу. Так що це є прикладом, коли чисто функціональний код призводить до додаткових правил, і корисний для розуміння та рефакторингу вашого коду.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування також прибирає проблеми накладання, що трапляються в імперативному програмуванні. Накладання трапляється, коли декілька змінних посилаються на той самий об'єкт. Це підіймає деякі тернисті запитання та ускладнення. Наприклад, чи зміна поля <code>r.x</code> також впливатиме на <code>s.x</code>? Це відбуватиметься, якщо <code>r</code> та <code>s</code> посилаються на той самий об'єкт. На практиці дуже складно відслідити такі накладання. З іншого боку, незмінні правила можуть вільно поділятись, оскільки копія не відрізняється від загального посилання. Ця перевага є практично ключовою, коли ви пишете конкурентний код. (Ось чому Java має незмінні рядки).</p></div>
</div>
<div class="sect2">
<h3 id="_scala___5">Scala статично типізована</h3>
<div class="paragraph"><p>Статичні системи типів класифікують змінні та вирази відповідно до властивостей значень, що вони зберігають на обчислюють. Scala виділяється як мова з дуже розширеною статичною системою типів. Починаючи від системи типів вкладених класів, подібних до Java, вона дозволяє вам параметризувати типи за допомогою дженериків, комбінувати типи з використанням перетинів, та приховувати деталі типів з використанням абстрактних типів.<span class="footnote"><br />[Дженеріки обговорюються в Главі 19; перетини (тобто, A with B with C) в Главі 12; та абстрактні типи в Главі 20.]<br /></span> Це дає міцний фундамент для будівництва та компонування ваших власних типів, так що ви можете розробити інтерфейси, що одночасно безпечні, та гнучкі в використанні.</p></div>
<div class="paragraph"><p>Якщо вам подобаються динамічні мови, такі як Perl, Python, Ruby, або Groovy, ви можете винайти трохи дивним, що статична система типів Scala попала в перелік як одна з сильних сторін. Кінець кінцем, відсутність статичної системи типів наводиться як одна з головних переваг динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми над балакучими, заважають програмістам виражати себе так, як вони бажають, та роблять неможливим деякі шаблони динамічних модифікацій софтверних систем. Однак часто ці аргументи не ідуть проти самої ідеі статичних типів взагалі, але проти окремих систем типів, що сприймаються як дуже балакучі або негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись замітив: "Я не проти типів, але я не знаю жодної системи типів, що не є суцільною біллю, так що я все ще люблю динамічні типи".<span class="footnote"><br />[Kay, поштою щодо значення об'єктно-орієнтовного програмування. [Kay03]]<br /></span></p></div>
<div class="paragraph"><p>Ми надіємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільною біллю". Фактично, вона адресує дві звичайні турботи щодо статичної типізації: балакучість іникається через вивід типів, та гнучкість досягається через співпадіння шаблонів та декльіка нових шляхів писати та компонувати типи. Коли ці перешкоди прибрані з нашого шляху, класичні переваги статичних типів можуть бути краще помічені. Серед найбільш важливих з ціх переваг є перевіряємі властивості програмних абстракцій, безпечний рефакторинг, та краща документація.</p></div>
<div class="paragraph"><p><strong>Перевіряємі властивості.</strong> Статичні системи типів можуть забезпечити відсутність певних помилок часу виконання. Наприклад, вони можуть доказати такі властивості: <code>Boolean</code> не буде доданий до цілого; приватні змінні не отримують доступ поза меж класу; функції застосовуються до відповідного числа аргументів; тільки рядки будь-коли будуть додаватись до множини рядків.</p></div>
<div class="paragraph"><p>Інші відомі помилки не виявляються сьогоднішніми статичними системами типів. Наприклад, вони зазвичай не будуть не-терміновані функції, порушення меж масивів, або ділення на ноль. Вони також не детектують, що ваша програма не відповідає її специфікації (вважаємо що така специфікація є, саме так!). Статичні системи типів, мають бути звільнені, як не дуже корисні. Аргумент, що надається, що оскільки такі системи можуть виявляти тільки прості помилки, тоді як юніт тести провадять більш екстенсивне покриття, чому треба борсатись зі статичними типами взагалі? Ми впевнені, що ці аргументи позбавлені змісту. Хоча статичні системи типів напевне не можуть замінити юніт тести, вони можуть зменшити число потрібних юніт тестів, пілчкуючись про деякі властивості, для яких інакше знадобились би тести. Подібним чином, юніт тести не можуть замінити статичну типізацію. Кінець кінцем, як казав Edsger Dijkstra, тестування може тільки довести наявність присутності помилок, та ніколи їх відсутність.<span class="footnote"><br />[Dijkstra, "Notes on Structured Programming." [Dij70]]<br /></span> Так що гарантії, що надає статична типізація, може бути слабкою, але це реальні гарантії в формі, яку не може забезпечити ніяка кількість тестів.</p></div>
<div class="paragraph"><p><strong>Безпечний рефакторинг.</strong> Статичні системи типів провадять страховку, що дозволяє вам робити зміни в базі коду з високою мірою довіри. Розглянемо примірник рефакторингу, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто підігнати всі рядки, що видають помилку типу. Коли ви скінчите з цім, ви впевнені, що найшли всі місця, що треба змінити. Те саме вірно для багатьох інших випадків простого рефакторингу, як зміни імені методу, або переміщення методів з одного класу до іншого. В усіх ціх випадках перевірка статичного типу буде провадити досить акуратності, щоб нова система робила так само, як стара.</p></div>
<div class="paragraph"><p><strong>Документація.</strong> Статичні типи є документацією програми, що перевіряється компілятором на коректність. На відміну від звичайних коментарів, анотації типів ніколи не можуть застаріти (щонайменьше якощ файл коду, що містить їх, недавно проходив через компілятор). Більше того, компілятори і інтегровані середовища розробки (IDE) можуть використовувати анотації типів для провадження кращої контекстної підказки. Наприклад, IDE може відображувати всі члени, доступні для вибору, через визначення статичного типу виразу, на якому робиться вибір, та перегляд членів цього типу.</p></div>
<div class="paragraph"><p>Навіть хоча статичні типи загалом корисні для документації програми, вони можуть інколи бути надокучливі, коли вони захаращують програму. Типово, корисна документація - це те, що читачі програми не можуть просто вивести самі по собі. В визначенні метода як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>корисно знати, що аргумент має бути <code>String</code>. Або, з іншого боку, щонайменьше одна з двох анотацій в наступному прикладі є подразником:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
</pre></div></div></div>
<div class="paragraph"><p>Зрозуміло, що має бути достатньо сказати тільки один раз, що <code>x</code> є <code>HashMap</code> з <code>Int</code> в якості ключа, та <code>Strings</code> як значення; немає потреби повторювати ту саму фразу двічі. Scala має дуже складну систему виводу типів, що дозволяє вам оминати майже всю інформацію типів, що звичайно сприймається як надокучлива. В попередньому прикладі наступні дві менш дратливі альтернативи також будуть робити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>ВИвід типів в Scala може зайти досить далеко. Фактично, не є рідкістю для користувацького кода, взагалі не мати явних типів. Таким чином, програми Scala часто виглядають трохи як програми, написані на динамічно типізованій скриптоівій мові. Це вірно зокрема для кода клієнтськіх застосувань, що зліплюють разом попередньо написані бібліотечні компоненти. Це менш вірно для самих компонент бібліотек, оскільки вони часто вживають дуже складні типи, щоб забезпечити гнучкі шаблони застосування. Це просто природно. Кінець кінцем, сигнатури типів членів, що складають інтерфейс реюзабельного компонента, повинен бути наданий явно, оскільки вони складають основну частину контракту між компонентом та його клієнтами.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_4__scala">1.4 Корені Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Дизайн Scala бів під впливом багатьох мов програмування, та ідей в дослідженні програмних мов. Фактично, тільки декілька можливостей Scala чисто нові; більшість вже мали застосування в деякій формі в інших мовах. Інновація Scala в основному походить від того, як вона покладає ці конструкції разом. В цьому розділі ми перелічимо головні впливи на розробку Scala. Список не може бути вичерпним — існує дуже багато розумних ідей коло розробки мови програмування, щоб перелічити тут їх всі.</p></div>
<div class="paragraph"><p>На поверхневому рівні Scala адоптує значну частину синтаксиса Java та C#, що, в свою чергу, позичає більшість зі своїх синтаксичних домовленостей від C та C++. Вирази, твердження та блокі здебільшо як в Java, так само, як синтаксис класів, пакунків та імпортів.<span class="footnote"><br />[Головне відхидення від Java в плані синтаксису для анотацій типу, це "змінна: типу" замість "тип змінної" в Java. Постфіксний синтаксис типу в Scala копіює Pascal, Modula-2, або Eiffel. Головна причина для цього відхилення має відношення до виводу типів, що часто дозволяє вам оминути тип змінної або тип повернення метода. Використання синтаксису "змінна: типу" просте - тільки опустіть крапку з комою та тип. Але в C-style синтаксисі "тип змінної" ви не можете просто відкинути тип; більше намає маркера що почалась декларація. Вам знадобиться деяке альтернативне ключове слово, щоб бути заповнювачем для відсутнього типу (C# 3.0, що робить деякий вивід типів, використовує <code>var</code> для ціх цілей). Таке альтернативне ключове слово виглядає більш притягнутим, та менш регулярним, ніж підхід Scala.]<br /></span> Крім синтаксиса Scala адоптує багато інших елементів Java, такі як базові типи, її бібліотеки типів, та її модель виконання.</p></div>
<div class="paragraph"><p>Scala також заборгувала багатьом іншим мовам. Її уніформна об'єктна модель започаткована  Smalltalk, і згодом прийнята Ruby. Її ідея про універсальне вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, більш пізніше, в Beta та gbeta. Її принцип уніформного доступу для виклику методів та виборів полів надходить від Eiffel. Її підхід до функціонального програмування є дуже подібним до духу сім'ї мов ML, таких як SML, OCaml та F#, в якості видатних членів. Багато високорівневих функцій в стандартній бібліотеці Scala також присутні в ML або Haskell. Неявні параметри були мотивовані класами типів Haskell; вони досягли аналогічних результатів в більше класичной об'єктно-орієнтовному оточенні. Головна актор-базована бібліотека конкурентності, Akka, дуже надихалась Erlang.</p></div>
<div class="paragraph"><p>Scala не є першою мовою, що наголошує на маштабованості та розширюваності. Історичні корені розширюваної мови, що може перетинати різні області застосування, знаходяться в статті Peter Landin 1966го року,"The Next 700 Programming Languages."<span class="footnote"><br />[Landin, "The Next 700 Programming Languages." [Lan66]]<br /></span> (Мова, описана в цьому документі, Iswim, стоїть поряд з Lisp як один з першопроходців функціональних мов). Специфічна ідея трактувати інфіксний оператор як функцію можна прослідкувати до Iswim та Smalltalk. Інша важлива ідея є дозволити функціональні літерали (або блоки) в якості параметрів, що дозвоялє бібліотекам визначати керівні структури. Знову, це тягнеться назад до Iswim та Smalltalk. Smalltalk та Lisp обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх, домен-специфічних мов. C++ є іншою маштабованою мовою, що може бути адаптований та розширений через перевантаження операторів, та його систему шаблонів; порівняно зі Scala він побудований на ніжньому рівні, більш системно-орієнтовному ядрі. Scala також не є першою мовою, що інтегрує функціональне та об'єкт-орієнтовне програмування, хоча вона, можливо, зашла найбільш далеко в цьому напрямку. Інші мови, що інтегрували деякі елементи функціонального програмування в об'єкто-орієнтовне програмування (OOP) включають Ruby, Smalltalk та Python. На Java платформі, Pizza, Nice, Multi-Java — та сама Java 8  — мають розширене Java-подібне ядро з функціональними ідеями. Також існують здебільше функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F#, та PLT-Scheme.</p></div>
<div class="paragraph"><p>Scala також привнесла деякі інновації до поля мов програмування. Наприклад, її абстрактні типи провадять більше об'єктно-орієнтовної альтернативи до дженерік типів, її трейти дозволяють гнучкі збірки компонент, та її екстрактори провадять незалежний від представлення спосіб співпадіння шаблонів. Ці інновації були представлені в документах на конференціях з мов програмування в останні роки.<span class="footnote"><br />[Для додаткової інформації дивіться [Ode03], [Ode05], та [Emi07] в бібліографії.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_1_5_">1.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми дали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Напевне, Scala не є срібною кулею, що магічно зробить вас більш продуктивним. Щоб просуватись, вам знадобиться містецьки застосувати Scala, та це буде потребувати деякого навчання та практики. Якщо ви прийшли до Scala від Java, найбільш викличний аспект у вивченні Scala може включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книжки м'яко провести вас кривою навчання Scala, по кроку за раз. Ми вважаємо, що ви знайдете це корисним інтелектуальним досвідом, що розширить ваші горизонти, та змусить вас думати інакше щодо розробки програм. Надіємось, що ви також отримаєте задоволення та натхнення від програмуванн на Scala.</p></div>
<div class="paragraph"><p>В наступній главі ми почнемо з вами писати деякий Scala код.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2_2">Глава 2</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala">Перші кроки в Scala</h1>
<div class="paragraph"><p>Прийшов час написати деякий код на Scala. Перед тим, як ми почнемо заглиблений туторіал Scala, ми покладемо дві глави, що дасть нам більшу картину Scala, та більш важливо, дасть вам написати код. Ми закликаємо вас справді спробувати всі приклади коду, представлені в цій главі, та наступному, куди ми теж дійдемо. Простий шлях почати вивчати Scala, це програмувати на ній.</p></div>
<div class="paragraph"><p>Щоб виконати приклади в цій главі, вам слідує мати стандартну інсталяцію Scala. Щоб отримати її, перейдіть до <a href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a> та слідуйте інструкціям для своєї платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans. Для кроків в цій главі ми вважатимемо, що ви використовуєте дистрибутив Scala з scala-lang.org.<span class="footnote"><br />[Ми тестували приклади в цій книзі на Scala версії 2.11.7.]<br /></span></p></div>
<div class="paragraph"><p>Якщов ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, що дозволить вам почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий матеріал може видатись вам трохи містичним. Але не хвилюйтесь. Щоб ви жваво набрали швидкість ми полишили деякі деталі. Все буде пояснене в трохи "пожарному" стилі в наступних главах. На додаток ми вставили декілька зносок в ціх наступних двох главах, що вказують вам на пізніші розділи книги, де ви знайдете більш докладні пояснення.</p></div>
<div class="sect1">
<h2 id="__1____scala">Крок 1. Навчаємось викорстовувати інтерпретатор Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Простіший спосіб розпочати зі Scala є використання інтерпретатора Scala, інтерактивної  "оболонки" для написання Scala виразів та програм. Інтерпретатор, що називається scala, буде обчислювати вирази, які ви набираєте, та друкувати отримане значення. Ви використовуєте його, набравши scala в командній підказці:<span class="footnote"><br />[Якщо ви використовуєте Windows, вам буде треба друкувати команду scala у вікно "Command Prompt" DOS.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala
Welcome to Scala version 2.11.7
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Після того, як ви наберете вираз, такий як 1 + 2, та нажмете enter:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; 1 + 2</code></pre>
</div></div>
<div class="paragraph"><p>Інтерпретатор надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>res0: Int = 3</code></pre>
</div></div>
<div class="paragraph"><p>Цей рядок включає:</p></div>
<div class="ulist"><ul>
<li>
<p>
автоматично згенероване або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає результат 0),
</p>
</li>
<li>
<p>
дві крапки (:), за якими іде тип виразу (Int),
</p>
</li>
<li>
<p>
знак рівнсоті (=),
</p>
</li>
<li>
<p>
значення, отримане від обчислення виразу (3).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Тип <code>Int</code> є назвою класа <code>Int</code> в пакунку <code>scala</code>. Пакунки в Scala подібні до пакунків в Java: вони поділяють глобальний простір імен, та провадять механізм для приховування інформації.<span class="footnote"><br />[Якщо ви не знайомі з пакунками Java, ви можете думати про них, як про впроваджене повне ім'я класу. Оскільки Int є членом пакунку scala, "Int" є простим ім'ям класу, та "scala.Int" є його повним ім'ям. Деталі щодо пакунків пояснюються в Главі 13.]<br /></span> Значення класу <code>Int</code> відповідають значенням <code>Java</code> <code>int</code>. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку <code>scala</code>. Наприклад, <code>scala.Boolean</code> відповідає до Java <code>boolean</code>. <code>scala.Float</code> відповідає до Java <code>float</code>. Та коли ви компілюєте ваш Scala код в байткод Java, компілятор Scala коли можливо буде використовувати примітивні типи Java, щоб надати вам переваги продуктивності примітивних типів.</p></div>
<div class="paragraph"><p>Ідентифікатор <code>resX</code> може бути використаний в подальших рядках. Наприклад, оскільки res0 був встановлений в 3 до цього, res0 * 3 буде давати 9:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; res0 * 3
res1: Int = 9</code></pre>
</div></div>
<div class="paragraph"><p>Щоб надрукувати необхідне, але недостатнє привітання Hello, world!, наберіть:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println("Hello, world!")
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Функція <code>println</code> друкує переданий рядок на стандартний вивід, подібно до <code>System.out.println</code> в Java.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2___">Крок 2. Визначаємо декілька змінних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має два типи змінних, <code>vals</code> та <code>vars</code>. <code>val</code> подібні до <code>final</code> змінних в Java. Коли ініціалізована, <code>val</code> ніколи не може бути перепризначеною. На відміну від цього, <code>var</code>, подібно до не-фінальної змінної в Java. <code>var</code> може бути переприсвоєна на протязі свого життя. Ось визначення <code>val</code> definition:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg = "Hello, world!"
msg: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Це твордження вводить <code>msg</code> як ім'я для рядка "Hello, world!". Тип <code>msg</code> є <code>java.lang.String</code>, оскільки рядки в <code>Scala</code> реалізовані через клас Java <code>String</code>.</p></div>
<div class="paragraph"><p>Якщо ви визначали змінні в Java, ви зауважили тут одну вбивчу різницю: ані <code>java.lang.String</code>, ані <code>String</code> не з'являються ніде в визначенні <code>val</code>. Цей приклад ілюструє вивід типу, здатність Scala здогадуватись про типи, які ви оминули. В цьому випадку, оскільки ініціалізували <code>msg</code> рядковим літералом, Scala виводить тип <code>msg</code> як <code>String</code>. Коли інтерпретатор Scala (або компілятор) може вивести це, часто є кращим дозволити йому зробити це, ніж заповнювати код непотрібними, явними анотаціями типів. Однак ви можете вказати тип явно, якщо бажаєте, та іноді ви, вірогідно, повинні. Явна анотація типу може одночасно переконатись, що компілятор Scala виводить типи як задумано, і так само прислужитись в якості корисної документації для майбутніх читачів коду. На відміну від Java, коли ви вказуєте тип змінної перед її ім'ям, в Scala ви вказуєте тип змінної після її ім'ям, відокремлений двома крапками. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg2: java.lang.String = "Hello again, world!"
msg2: String = Hello again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Або, оскільки типи <code>java.lang</code> видимі в частині простих імен для програм Scala, просто:<span class="footnote"><br />[Просте ім'я java.lang.String є String.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Переходя до оригінального <code>msg</code>, тепер, коли вона визначена, ви можете використовувати її як очікується, наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println(msg)
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Що ви не можете робити з <code>msg</code>, зважаючи що вона <code>val</code>, не <code>var</code>, це переприсвоїти її.<span class="footnote"><br />[Однак в інтерпретаторі ви можете визначити нове val з іменем, що вже використовувалось до цього. Цей механізм пояснено в Розділі 7.7.]<br /></span> Наприклад, дивіться, як інтерпретатор скаржиться, коли ви намагаєтесь зробити наступне:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; msg = "Goodbye cruel world!"
&lt;console&gt;:8: error: reassignment to val
msg = "Goodbye cruel world!"
^</code></pre>
</div></div>
<div class="paragraph"><p>Якщо переприсвоєння саме те, чого ви бажаєте, вам треба вкористовувати <code>var</code>, як тут:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; var greeting = "Hello, world!"
greeting: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Оскільки <code>greeting</code> є <code>var</code> а не <code>val</code>, ви можете переприсвоїти її пізніше. Якщо ви пізнаше будете почуватись буркотливим, ви можете, наприклад, змінити ваше привітання на таке:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; greeting = "Leave me alone, world!"
greeting: String = Leave me alone, world!</code></pre>
</div></div>
<div class="paragraph"><p>Щоб ввести щось в інтерпретатор, що займатиме декілька рядків, просто продовжуйте друкувати доки не скінчите, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val multiLine =
|
"This is the next line."
multiLine: String = This is the next line.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви зрозуміли, що набрали щось невірно, але інтерпретатор ще чекає для додаткового вводу, ви можете вийти, натиснувши enter двічі:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val oops =
|
|
You typed two blank lines.
Starting a new command.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>В залишку книги ми полишимо вертикальні стовпчики, щоб зробити код простішим для читання (та простіше копіювати та вставляти з PDF eBook в інтерпретатор).</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3___">Крок 3. Визначаємо деякі функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
}
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Визначення функцій починається з <code>def</code>. Ім'я функції, в нашому випадку <code>max</code>, за яким слідує розділений комами список параметрі в дужках. Анотація типу має слідувати за кожним параметром функції черед дві крапки, оскільки компілятор Scala (і інтерпретатор, вле відтепер ми будемо казати тільки компілятор) не виводить типи параметрів функцій. В цьому прикладі функція на ім'я <code>max</code> приймає два параметри, <code>x</code> та <code>y</code>, обоє типу <code>Int</code>. Після того, як ви закрили дужки списку параметрів <code>max</code>, ви знайдете інішу анотацію типу <code>: Int</code>. Це визначає тип результату самої функції <code>max</code>.<span class="footnote"><br />[В Java тип значення, що повертається з метода, є його типом повернення. В Scala та сама концепція називається типом результата.]<br /></span> За типом результату іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить один вираз <code>if</code>, що обирає або <code>x</code> або <code>y</code>, що більше, як результат функції <code>max</code>. Як продемонстровано тут, в Scala <code>if</code> вираз може видавати значення, подібно то тримісного оператора в Java. Наприклад, вираз Scala  <code>if (x &gt; y) x else y</code> поводить себе подібно до <code>(x &gt; y) ? x : y</code> в Java. Знак рівності, що стоїть перед тілом функції, дає підказку, що з точки зору функціонального світу, функція визначає вираз, що видає значення. Базова структура функції ілюстрована на Малюнку 2.1.</p></div>
<div class="paragraph"><p>Малюнок 2.1 - базова форма визначення функції в Scala.</p></div>
<div class="paragraph"><p>Іноді компілятор Scala буде потребувати, щоб ви вказували тип результату функції. Якщо функція рекурсивна,<span class="footnote"><br />[Функція називається рекурсивною, якщо вона викликає сама себе.]<br /></span> наприклад, ви маєте явно вказати тип результату функції. Однак в випадку <code>max</code> ви можете випустити тип результату, і компілятор буде виводити його.<span class="footnote"><br />[Тим не менш, часто є гарною ідеєю вказати тип результата функції явно, навіть коли компілятор не потребує цього. Така анотація типу може зробити код простішим до читання, оскільки читач на повинен вивчати тіло функції, щоб з'ясувати виведений тип результата.]<br /></span> Також, якщо функція складається тільки з одного твердження, ви можете опціонально випустити і фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int) = if (x &gt; y) x else y
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Коли ви визначили функцію, ви можете викликати її:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; max(3, 5)
res4: Int = 5</code></pre>
</div></div>
<div class="paragraph"><p>Ось визначення функції, що не приймає параметрів, та не повертає цікавих результатів:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</code></pre>
</div></div>
<div class="paragraph"><p>Коли ви визначаєте функцію <code>greet()</code>, інтерпретатор буде відповідати <code>greet: ()Unit</code>.  "greet" є, звичайно, іменем функції. Порожні дужки вказують, що функція не сприймає параметрів. Та <code>Unit</code> є тип повернення <code>greet</code>. Тип результата <code>Unit</code> вказує, що функція не повертає цікавих значень. Тип Scala <code>Unit</code> подібний на тип Java <code>void</code>; фактично, кожинй метод, що повертає в Java <code>void</code>, відзеркалюється на метод Scala, що повертає <code>Unit</code>. Методи з типом результата <code>Unit</code>, таким чином, виконуються тільки для заради їх побічних ефектів. В випадку greet(), побічний ефект є дружнє привітання, роздруковане на стандартний вихід.</p></div>
<div class="paragraph"><p>На наступному кроці ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, ввівші :quit або :q.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; :quit
$</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="__4___scala_">Крок 4. Пишемо деякі Scala скрипти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча Scala розроблена допомогти в побудові дуже велико-маштабованих систем, вона також гарно маштабується донизу до скриптинга. Скрипт це тільки послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть це в файл з назвою <code>hello.scala</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>println("Hello, world, from a script!")</code></pre>
</div></div>
<div class="paragraph"><p>потім виконайте:<span class="footnote"><br />[Ви можете виконати скрипт без набирання "scala" під Unix та Windows, використовуючи синтаксис "pound-bang", що показаний в Додатку A.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala hello.scala</code></pre>
</div></div>
<div class="paragraph"><p>Та ви маєте отримати наступне привітання:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, world, from a script!</code></pre>
</div></div>
<div class="paragraph"><p>Аргументи командного рядка скрипта Scala доступні через масив Scala з назвою <code>args</code>. В Scala масиви починаються з нуля, та ви отримуєте доступ до елементів через вказання індексу в дужкає. Так що перший елемент в масиві Scala з назвою <code>steps</code> є <code>steps(0)</code>, не <code>steps[0]</code>, як в Java. Щоб спробувати це, наберіть наступне в новий файл з назвою <code>helloarg.scala</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>// Say hello to the first argument
println("Hello, " + args(0) + "!")</code></pre>
</div></div>
<div class="paragraph"><p>потім виконайте:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala helloarg.scala planet</code></pre>
</div></div>
<div class="paragraph"><p>В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як <code>args(0)</code>. Таким чином ви можете побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, planet!</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що цей скрипт містить коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та любі символи між /* та */. Цей приклад також показує, як рядки конкатенуються (поєднуються) за допомогою оператора + . Це робить як ви очікуєте. Вираз "Hello, " + "world!" призведе до рядка "Hello, world!".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__5___while___if">Крок 5. Цикл з while; рішення з if</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб спробувати <code>while</code>, наберіть наступне в файл на ім'я <code>printargs.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Хоча приклади в цьому розділі допомагають зрозуміти цикли <code>while</code>, вони не демонструють кращий стиль Scala. В настурному розділі ви побачите кращі підходи уникнути ітерації по масивах за допомогою індексів.</td>
</tr></table>
</div>
<div class="paragraph"><p>Цей скрипт починається з визначення змінної <code>var i = 0</code>. Вивід типів надає <code>i</code> тип  <code>scala.Int</code>, оскільки це тип початкового значення, 0. Конструкція <code>while</code> в наступному рядку призводить до того, що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз <code>i &lt; args.length</code> буде <code>false</code>. <code>args.length</code> дає довжину масива <code>args</code>. Блок містить два твердження, кожне зсунуте на два проміжки, рекомендований відступ в Scala. Перше твердження, <code>println(args(i))</code>, друкує i-тий аргумент командного рядка. Наступне твердження, <code>i += 1</code>, інкрементує (збільшує) i на один. Зауважте, що відомі з Java <code>i та i</code> не роблять в Scala. Щоб виконати інкремент в Scala, вам треба сказати або i = i + 1 або i += 1. Виконайте цей скрипт за допомогою наступної команди:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala printargs.scala Scala is fun</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala
is
fun</code></pre>
</div></div>
<div class="paragraph"><p>Для ще більшої розваги наберіть наступний код в файлі на ім'я <code>echoargs.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій версії ми замінили виклик <code>println</code> на виклик <code>print</code>, так що всі ці аргументи будуть друкуватись на тому самому рядку. Щоб зробите читабельним, ви вставляєте один проміжок перед кожним аргументом, за винятком першого, через конструкцію <code>if (i != 0)</code>. Оскільки <code>i != 0</code> буде <code>false</code> перший раз, коли ви проходите через цикл, проміжок не буде надрукований перед першим аргументом. Нарешті, ви додали ще один <code>println</code> в кінці, щоб отримати перевод рядка після друку всіх аргументів. Ваш вивід тепер є досить гарним. Якщо ви виконаєте цей скрипт за допомогою такої команди:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala echoargs.scala Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Ви отримаєте:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що в Scala, як і в Java, ви маєте покладати логічні вирази для <code>while</code> або для <code>if</code> в дужки. (Іншими словами, ви не можете сказати в Scala речі як <code>if i &lt; 10</code>, як ви можете в таких мовах, як Ruby. Ви маєте сказати <code>if (i &lt; 10)</code> в Scala). Інша подібність до Java в тому, що коли блок <code>if</code> має тільки одне твердження, ви можете опціонально випустити фігурні дужки, як демонструєтсья твердженням <code>if</code> в <code>echoargs.scala</code>. І хоча ми не бачили жодної з них, Scala використовує крапку з комою для розділення тверджень, як і Java, за тим винятком, що в Scala кома з крапкою дуже часто опціональна, що дає деяке розслаблення мізинцю правої руки. Однак якщо ви перебуваєте в дещо більш балакучому настрої, ви можете записати скрипт <code>echoargs.scala</code> наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">();</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__6____foreach__for">Крок 6. Ітеруємо за допомогою foreach та for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча ви можете не уявляти цього, коли ви пишете цикли <code>while</code> в попередньому кроці, ви програмуєте в імперативному стилі. В вмперативному стилі, що є стилам, який ви звичайно використовуєте з мовами як Java, C++ та C, ви видаєте одну імперативну команду за раз, ітеруючи за допомогою циклів, та часто змінюєте стан, загальний для різних функцій. Scala дозволяє вам програмувати імперативно, але коли ви будете знати Scala краще, ви будете частіше знаходити себе за програмуванням в більш функціональному стилі. Фактично, одна з головних цілей цієї книги є допомогти вам стати так само комфортним з функціональним стилем, як вам є з імперативним стилем.</p></div>
<div class="paragraph"><p>Одна з головних характеристик функціональної мови в тому, що функції є першокласними конструкціями, і це є дуже вірно в Scala. Наприклад, інший (значно більше стислий) шлях надрукувати кожний аргумент командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">arg</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому коді ви викликаєте метод foreach на <code>args</code>, та передаєте йому функію. В цьому випадку ви передаєте функціональний літерал, що приймає один параметр на ім'я <code>arg</code>. Тілом функції є <code>println(arg)</code>. Якщо ви наберете код вище в новий файл з назвою <code>pa.scala</code> та виконаєте його командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala pa.scala Concise is nice</code></pre>
</div></div>
<div class="paragraph"><p>Ви можете побачили:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Concise
is
nice</code></pre>
</div></div>
<div class="paragraph"><p>В попередньому прикладі інтерпретатор Scala виводить тип <code>arg</code> як <code>String</code>, оскільки <code>String</code> є типом елементів масива, для якого ми викликаємо foreach. Якщо ви схильні бути більш явним, ви можете вказати ім'я типу. Але коли ви зробите це, вам доведеться огорнути аргумент в дужки (що є нормальною формою синтаксиса в жодному разі):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach((arg: String) =&gt; println(arg))</code></pre>
</div></div>
<div class="paragraph"><p>Виконання цього скрипта має ту саму поведінку, що і попереднього.</p></div>
<div class="paragraph"><p>Якщо ви в настрої бути трохи стислішим, ніж більш явним, ви можете отримати перевагу від спеціалного скорочення в Scala. Якщо функціональний літерал складається з одного твердження, що приймає один аргумент, вам не треба явно називати та сказувати аргумент.<span class="footnote"><br />[Це скорочення, що називається частково визначеною функцією, описане в Розділі 8.6.]<br /></span> Таким чином, наступний код також робить:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach(println)</code></pre>
</div></div>
<div class="paragraph"><p>Щоб підсумувати, синтаксис для функціонального літерала є список іменованих параметрів в дужках, стрілка вправо, та потім тіло функції. Синтаксис проілюстрований на Малюнку 2.2.</p></div>
<div class="paragraph"><p>Малюнок 2.2 - Синтаксис функціонального літерала в Scala.</p></div>
<div class="paragraph"><p>Тепер, в цій точці ви можете здивуватись, що трапилось з тіми надійними циклами <code>for</code>, до яких ви звикли при використанні імперативних мов, таких як Java або C. В спробі спрямувати вас в функціональному напрямку, в Scala доступний тільки функціональний родич  <code>for</code> (що називається виразом <code>for</code>). Хоча ви не побачите його повної потужності та виразності, доки не досягнете (або не заглянете наперед) Розділ 7.3, ми дамо вам побіжний погляд. В новому файлі на ім'я <code>forargs.scala</code> наберіть наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Дужки після <code>for</code> містять <code>arg &lt;- args</code>.<span class="footnote"><br />[Ви можете казати "в" для символа &#8592; . Ви будете читати for (arg &#8592; args), таким чином, як "для arg в args."]<br /></span> Зправа від символа <code>&lt;-</code> є знакомий масив <code>args</code>. Зліва від <code>&lt;-</code> є <code>arg</code>, ім'я <code>val</code>, не <code>var</code>. (Оскільки це завжди <code>val</code>, ви просто пишете один <code>arg</code>, не <code>val arg</code>). Хоча <code>arg</code> може виглядати як <code>var</code>, оскільки вона буде отримувати нове значення на кожній ітерації, насправді це <code>val</code>: <code>arg</code> не може бути переприсвоєний в тілі виразу. Замість цього, для кожного елементу масива <code>args</code> буде створений новий <code>val arg</code> та ініціалізований значенням елемента. Після чого буде виконане тіло <code>for</code>.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте скрипт <code>forargs.scala</code> командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala forargs.scala for arg in args</code></pre>
</div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for
arg
in
args</code></pre>
</div></div>
<div class="paragraph"><p>Вираз <code>for</code> в Scala може робити набагато більше ніж це, але цей приклад достатнім для початку. Ми покажемо вам більше щодо <code>for</code> в Розділі 7.3 та Главі 23.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__6">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми вивчили деякі основи Scala, та, надіємось, скористались можливостю написати трохи Scala коду. В наступній главі мо продовжимо цей вступний огляд, та займемось більш складними темами.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3_2">Глава 3</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala_2">Наступні кроки в Scala</h1>
<div class="paragraph"><p>Ця глава продовжує вступ до Scala з попередньої глави. В цій главі ми введемо декілька більш складних можливостей. Коли ви скінчите цю главу, ви будете мати досить знань, щоб почати писати корисні скрипти на Scala. Як і з попередньою главою, ми рекомендуємо вам спробувати ці приклади, по мірі проходження. Кращий спосіб отримати відчуття Scala є почати писати Scala код.</p></div>
<div class="sect1">
<h2 id="__7_____">Крок 7. Параметризація масивів за допомогою типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala ви можете створити примірники об'єктів або примірники класів, використовуючи <code>new</code>. Коли ви створюєте примірник об'єкту в Scala, ви можете параметризувати його за допомогою значень або типів. Параметризація означає "конфігурація" примірника, коли ви створюєте його. Ви параметризуєте примірник значеннями, через передачу об'єктів до конструктора в дужках. Наприклад, наступний код Scala створює нового <code>java.math.BigInteger</code>, та параметризує його значенням "12345":</p></div>
<div class="listingblock">
<div class="content">
<pre><code>val big = new java.math.BigInteger("12345")</code></pre>
</div></div>
<div class="paragraph"><p>Ви параметризуєте примірник типами, коли вказуєте один або більше типів в прямокутних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі <code>greetStrings</code> є значенням типу <code>Array[String]</code>("масив рядків"), що ініціалізований довжиною 3 через його параметризацію значенням 3 в першому рядку кода. Якщо ви запустите код з Лістинга 3.1 як скрипт, ви побачите ще одне привітання <code>Hello, world!</code>. Зауважте, що коли ви параметризуєте примірник обома, типом та значенням, тип іде першим в своїх прямокутних дужках, за якими іде значення в дужках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.1 - Параметризація масива за допомогою типа.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Хоча код в Лістингу 3.1 демонструє важливі концепції, він не показує рекомендований спосіб створювання та ініціалізації масивів в Scala. Ви побачите кращий спосіб в Лістингу 3.2 далі.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо ви знаходитесь в більш явному настрої, ви можете вказати тип <code>greetStrings</code> явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги вивід типів Scala, цей рядок кода семантично еквівалнтний до першого дійсного рядка Лістинга 3.1. Але ця форма демонструє, що хоча частина параметризації типа (імена типів в прямокутних дужках) формує частину типу примірника, частина параметризації значенням (значення в дужках) - ні. Тип <code>greetStrings</code> є <code>Array[String]</code>, не Array[String](3).</p></div>
<div class="paragraph"><p>Наступні три рядка кода з Лістинга 3.1 ініціалізують кожний елемент масиву <code>greetStrings</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви в Scala отримують доступ покладанням індексу в дужках, не прямокутних дужках, як в Java. Таким чином нульовий елемент масива є <code>isgreetStrings(0)</code>, та не <code>greetStrings[0]</code>.</p></div>
<div class="paragraph"><p>Ці три рядка кода ілюструють важливу концепцію для розуміння того, як Scala розглядає визначення <code>val</code>. Коли ви визначаєте змінну за допомогою <code>val</code>, змінна не може бути переприсвоєна, але об'єкт, на який вона посилається, потенційно все ще може бути змінений. Як в цьому випадку, ви не можете переприсвоїти <code>greetStrings</code> на інший масив; <code>greetStrings</code> буде завжди вказувати на той самий примірник <code>Array[String]</code>, яким він був ініціалізований. Але ви можете змінити елементи цього <code>Array[String]</code> з часом, так що сам масив є змінним.</p></div>
<div class="paragraph"><p>Два заключні рядка в Лістингу 3.1 містять вираз <code>for</code>, що друкує кожний елемент <code>greetStringsarray</code> по черзі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший рядок коду в цьому виразі <code>for</code> ілюструє інше загальне правило Scala: якщо метод приймає тільки один параметр, ви можете викликати його без крапки або дужок. В цбому прикладі <code>to</code> насправді є методом, що приймає один аргумент Int. Код <code>0 to 2</code> трансформується в виклик метода <code>(0).to(2)</code>. <span class="footnote"><br />[Цей метод to насправді повертає не масив, але інший різновид послідовності, що містить значення 0, 1 та 2, по якому ітерує for. Послідовності та інші колекції будуть описані в Главі 17.]<br /></span> Зауважте, що цей синтаксис робить, тільки якщо ви явно вказуєте отримувача виклику метода. Ви не можете написати <code>println 10</code>, але ви можете написати <code>Console println 10</code>.</p></div>
<div class="paragraph"><p>Scala технічно не має перевантаження операторів, оскільки вона насправді не має операторів в традиційному сенсі. Замість цього, такі символи, як +, -, * та / можуть бути використані в іменах методів. Таким чином, коли ви друкуєте <code>1 + 2</code> в Scala інтерпретаторі на Кроці 1, ви насправді викликаєте метод з назвою <code>+</code> на <code>Int</code> об'єкті <code>1</code>, передаючи <code>2</code> як параметр. Як ілюстровано на Малюнку 3.1, ви можете альтернативно записати <code>1 + 2</code>, використовуючи традиційний синтаксис виклику метода, <code>(1).+(2)</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.1 - В Scala всі операції є викликами методів.</p></div>
<div class="paragraph"><p>Інша важлива ідея, ілюстрована цім прикладом, це надати вам розуміння того, чому масиви надають доступ через дужки в Scala. Scala має меньше особливих випадків, ніж Java. Масиви є простими примірниками класів, як любі інші класи в Scala. Коли ви застосовуєте дужки, що оточують одне або більше значень до змінної, Scala буде трансформувати код в виклик методу з назвою <code>apply</code> на цій змінній. Так що <code>greetStrings(i)</code> перетвориться на <code>greetStrings.apply(i)</code>. Таким чином, доступ до елемент масива в Scala є простим викликом метода, як любий інший. Цей принцип не ообмежуєть до масивів: любе застосування об'єктів до деяких аргументів в дужках буде трпнсформоване в виклик метода <code>apply</code>. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкта дійсно визначає метод <code>apply</code>. Так що це не особливий випадок; це загальне правило.</p></div>
<div class="paragraph"><p>Подібним чином, коли робиться просвоєння до змінної, до якої застовані дужки з одним або більше аргументом, компілятор буде трансформувати це в виклик метода <code>update</code>, що приймає аргументи в дужках, а такж об'єкт з правого боку від знака рівності. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings(0) = "Hello"</code></pre>
</div></div>
<div class="paragraph"><p>буде трансформовано на:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings.update(0, "Hello")</code></pre>
</div></div>
<div class="paragraph"><p>Таким чином, наступне симантично еквівалентне до коду з лістинга 3.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello&quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;, &quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;world!\n&quot;</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mf">0.</span><span class="n">to</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala досягає концептуальної простоти, трактуючи все, від масивів та виразів, як об'єкти з методами. Ви не маєте пам'ятати особливі випадки, такі, як розбіжності в Java між примітивами та їх відповідними огортаючими типами, або між масивами та звичайними об'єктаи. Більше того, ця одноманітність не накладає значних витрат продуктивності. Компілятор Scala використовує в скомпільованому коді масиви Java, примітивні типи, та природну арифметику, де це можливо.</p></div>
<div class="paragraph"><p>Хоча приклади, що ви бачили на цей момент в цьому кроці, компілюються та виконуються досить гано, Scala провадить більш стислий спосіб для створення та ініціалізації масивів, який в будете звичайно використовувати (Лістинг 3.2). Цей код створює новий масив довжиною три, ініціалізований переданими рядками, <code>"zero"</code>, <code>"one"</code>, <code>"two"</code>. Компілятор виводить тип масива, як <code>Array[String]</code>, оскільки ви передали йому рядки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.2 - Створення та ініціалізація масиву.</p></div>
<div class="paragraph"><p>Що ви насправді робите в Лістингу 3.2, це виклик методу фабрики, під назвою <code>apply</code>, що створює та повертає новий масив. Цей метод <code>apply</code> приймає змінне число аргументів,<span class="footnote"><br />[Список аргументів змінної довжини, або повторювані параметри, описані в Розділі 8.8.]<br /></span> та визначений на об'єкті компанйоні Array. Ви навчитесь більше щодо об'єктов компанйонів в Розділі 4.3. Якщо ви Java програміт, ви можете думати про це, як про виклик статичного методу на ім'я <code>apply</code> на класі <code>Array</code>. Більш балакучий шлях викликати той самий метод <code>apply</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames2</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__8__">Крок 8. Використання списків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна з виликих ідей функціонального стилю програмування є методи, що не мають побічних ефектів. Єдиною дією метода повинне бути обчислення та повернення значення. Деякі переваги, що будуть отримані коли ви приймете цей підхід, в тому, що методи стають менш  заплутаними, і таким чином, більш надійні та використовувані. Інша перевага (в статично типізованій мові) в тому, що все, що входить і виходить з метода перевіряється контролем типів, так що логічні помилки більш вірогідно проявлять себе як помилки типів. Застосування цієї функціональної філософії до світу об'єктів означає зробити об'єкти незмінними.</p></div>
<div class="paragraph"><p>Як ви бачили, масиви Scala є змінними послідовностями об'єктів, що всі поділяють той самий тип. Наприклад, <code>Array[String]</code> містить тільки рядки. Хоча ви не можете змінити довжину масива, після того, як був створений екземпляр, ви можете змінити значення його елементів. Таким чином, масиви є змінні об'єкти.</p></div>
<div class="paragraph"><p>Для незмінних послідовностей об'єктів, що поділяють той самий тип, ви можете використати клас Scala <code>List</code>. Так само, як і з масивами, <code>List[String]</code> містить тільки рядки. Список Scala <code>List</code>, <code>scala.List</code>, відрізняється від типу Java <code>java.util.List</code> в тому, що списки Scala <code>List</code> завжди незмінні (тоді як списки Java <code>List</code> можуть бути змінні). Більш загально, Scala <code>List</code> розроблений дозволити функціональний стиль програмування. Створити список просто, та Лістинг 3.3 показує як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.3 - Створення та ініціалізація списку.</p></div>
<div class="paragraph"><p>Код в Лістингу 3.3 встановлює нову <code>val</code> на ім'я <code>oneTwoThree</code>, ініціалізовану як <code>new List[Int]</code> з цілими елементами 1, 2 та 3.<span class="footnote"><br />[Вам не треба казати new List, оскільки "List.apply()" визначений як метод фабрика на об'єкті компанйоні scala.List. Ви будете читати більше про об'єкти компанйони в Розділі 4.3.]<br /></span> Оскільки <code>List</code> незмінні, вони поводяться трохи подібно до рядків в Java: коли ви викликаєте метод на списку, з імені якого випливає, що список буде змінений, він замість цього створює та повертає нове значення. Наприклад, <code>List</code> має метод на ім'я <code>:::</code> для конкатенації списків. Ось як ви використовуєте його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwo</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">threeFour</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThreeFour</span> <span class="k">=</span> <span class="n">oneTwo</span> <span class="o">:::</span> <span class="n">threeFour</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwo</span> <span class="o">+</span> <span class="s">&quot; and &quot;</span> <span class="o">+</span> <span class="n">threeFour</span> <span class="o">+</span> <span class="s">&quot; were not mutated.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Thus, &quot;</span> <span class="o">+</span> <span class="n">oneTwoThreeFour</span> <span class="o">+</span> <span class="s">&quot; is a new list.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви виконаєте цей скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</code></pre>
</div></div>
<div class="paragraph"><p>Можливо найбільш загальний оператор, якім ви будете користатись зі списками, є <code>::</code>, що вимовляється як "cons". Cons ставить новий елемент до початку існуючого списку, та повертає отриманий список. Наприклад, якщо ви викличете цей скрипт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">twoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">twoThree</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2, 3)</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">В виразі 1 <code>::</code> twoThree, <code>::</code> є методом свого правого операну, списку <code>twoThree</code>. Ви можете запідозрити, що щось не так з асоціативністю метода <code>::</code>, але насправді є просте правило, що треба пам'ятати: якщо метод використовується в операторній нотації, такі, як <code>a * b</code>, метод викликається на лівому операнді, як <code>a.*(b)</code> — за винятком, коли метод закінчується на двокрапку. Якщо ім'я метода закінчується на двокрапку, метод викликається на правому операнді. Таким чином, в 1 <code>::</code> twoThree, метод <code>::</code> викликається на <code>twoThree</code>, передаючи 1: <code>twoThree.::(1)</code>. Асоціативність операторів буде детально дискутована в Розділі 5.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Приймаючи, що скороченим шляхом вказати порожній список є <code>Nil</code>, одним з методів ініціалізувати нові списки є поєднання разом елементів за допомогою оператора <code>cons</code>, з Nil в якості останнього елемента. Причина, з якої вам треба Nil в кінці полягає в тому, що <code>::</code> визначене для класа List. Якщо ви намагатиметесь просто сказати 1 <code>::</code> 2 <code>::</code> 3, це не буде компілюватись, оскільки 3 є Int, що не має метода <code>::</code>. Наприклад, наступний скрипт буде продукувати той самий вихід, що і попередній, <code>List(1, 2, 3)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala List напакований корисними методами, багато з яких показані в Таблиці 3.1. Повна потужність списків буде розкрита в Главі 16.</p></div>
<div class="sect2">
<h3 id="______2">Чому не додавати до списків?</h3>
<div class="paragraph"><p>Клас List пропонує операцію <code>append</code> — вона записується як <code>:+</code> та пояснена в Главі  24 — але ця операція рідко використовується, оскільки час, що займає додати до списку зростає лінійно з розміром списку, тоді як постановка в початок за допомогою <code>::</code> займає сталий час. Якщо ви бажаєте побудувати список ефективно через додавання елементів, ви можете додавати їх в початок, то коли все буде зроблене зробити реверс (обертання) списку. Або ви можете використовувати <code>ListBuffer</code>, змінний список, що пропонує операцію <code>append</code>, та потім, коли все зроблено, викликати <code>toList</code>. <code>ListBuffer</code> буде описаний в Розділі  22.2.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі методи та використання List</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке        </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span> <span class="n">або</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Порожній List</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;Cool&quot;</span><span class="o">,</span> <span class="s">&quot;tools&quot;</span><span class="o">,</span> <span class="s">&quot;rule&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Cool", "tools", "rule"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">thrill</span> <span class="k">=</span> <span class="s">&quot;Will&quot;</span> <span class="o">::</span> <span class="s">&quot;fill&quot;</span> <span class="o">::</span> <span class="s">&quot;until&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Will", "fill", "until"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;d&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Конкатенує два списки (повертає новий List[String] зі значеннями "a", "b", "c", "d")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає елемент з індексом 2 (від нуля) списку thethrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">count</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Рахує число число рядків-елементів в thrill, чия довжина 4 (повертає 2)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без перших двох елементів (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">dropRight</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без двох правих елементів (повертає List("Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">==</span> <span class="s">&quot;until&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Визначає, чи існує елемент-рядок в thrill, що має значення "until" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів thrill, по порядку, що мають довжину 4 (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">forall</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;l&quot;</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи всі елементи в списку thrill закінчуються на літеру "l" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Виконує твердження print на кожному рядку в списку thrill (друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">print</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Те саме що і попередньє, але стисліше (також друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">head</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає перший елемент в списку thrill (повертає "Will")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">init</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає з усіх, крім останнього, елементів в списку thrill (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">isEmpty</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи є список thrill (повертає false)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">last</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає останній елемент в списку thrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає число елементів в списку thrill (повертає 3)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;y&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, отриманий від додавання "y" до кожного елемента-рядка в списку thrill (повертаєList ("Willy", "filly", "untily"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;, &quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Робить рядок з усіх елементів списку (повертає "Will, fill, until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filterNot</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів списку thrill, по порядку, крім тих, що мають довжину 4 (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">reverse</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що складається з усіх елеменітв списку thrill в зворотньому порядку (повертає List("until", "fill", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">sort</span><span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що містить всі елементи thrill в алфавітному порядку по першій літері, переведеній в нижній реєстр (повертає List("fill", "until", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">tail</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill мінус перший елемент (повертає List("fill", "until"))</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__9__">Крок 9. Використання таплів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Інший корисний контейнерний об'єкт є тапл. Як списки, тапли є нехмінними, але на відміну від списків, тапли можуть містити різні типи елементів. Коли список може бути List[Int] або aList[String], тапл може містити обоє, ціле та рядок, одночасно. Тапли дуже корисні, наприклад, коли ви повертаєте декілька об'єктів з метода. В той час, коли в Java ви будете часто створювати JavaBean-подібний клас, що міститиме декілька повертаємих значень, в Scala ви можете просто повернути тапл. Та це просто: щоб ініціалізувати тапл, що містить деякий об'єкти, просто покладіть об'єкти в дужки, розділені комами. Як тільки ви маєте примірник таплу, ви можете отримати доступ до його індивідуальних об'єктів через крапку, підкреслення, та 1-базований індекс елементів. Приклад показаний на Лістингу 3.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">pair</span> <span class="k">=</span> <span class="o">(</span><span class="mi">99</span><span class="o">,</span> <span class="s">&quot;Luftballons&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.4 - Creating and using a tuple.</p></div>
<div class="paragraph"><p>В першому рядку Лістинга 3.4 ви створюєте новий тапл, що містить ціле 99 як перший елемент, та рядок "Luftballons" як другий елемент. Scala виводить тип тапла як <code>Tuple2[Int, String]</code>, та надає цей тип до змінної <code>pair</code>, також. В другому рядку ви отримуєте доступ до поля _1, що буде продукувати перший елемент, <code>99</code>. "." в другому рядку є та сама крапка, яку ви використовуєте для доступу до поля або для виклику метода. В цьому випадку ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>99
Luftballons</code></pre>
</div></div>
<div class="paragraph"><p>Справжній тип тапла залежить від числа елементів, яке він містить, та від типів ціх елементів. Таким чином, тип <code>(99, "Luftballons")</code> є <code>Tuple2[Int, String]</code>. Тип <code>('u', 'r', "the", 1, 4, "me")</code> є <code>Tuple6[Char, Char, String, Int, Int, String]</code>.<span class="footnote"><br />[Хоча концептуально ви можете створити тапли любої довжини, наразі бібліотека Scala визначає їх до Tuple22.]<br /></span></p></div>
<div class="sect2">
<h3 id="_____3">Доступ до елементів тапла</h3>
<div class="paragraph"><p>Ви можете здивуватись, чому ви не можете отримати доступ до елементів тапла як до елементів списку, наприклад, як <code>pair(0)</code>. Причина є в тому, що для списка метод <code>apply</code> завжди повертає той самий тип, але кожний елемент тапла може бути різного типу: _1 може мати одит тип результату, _2 інший, і так далі. Ці числа _N базуються не одиниці, замість нуля, оскільки починати з 1 є традицією, встановленою іншими мовами зі статичними типизованими таплами, як Haskell та ML.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__10____">Крок 10. Використання множин та мап</h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки Scala націлена допомогти вам отриати переваги від обох, функціонального та імперативного стилів, її бібліотеки колекцій наголошують на різниці між змінними та незмінними колекціями. Наприклад, масиви завжди змінні; списки завжди незмінні. Scala також провадить змінні та незмінні альтернативи для множин та мап, але використовує ті ж самі прості імена для обої версій. Для множин та мап Scala моделює змінність в ієрархії класів.</p></div>
<div class="paragraph"><p>Наприклад, Scala API містить базовий трейт для множин, де трейт схожий на Java інтерфейс. (Ви знайдете більше щодо трейтів в Главі 12). Потім Scala провадить два субтрейти, один для змінних множин, та інший для незмінних множин.</p></div>
<div class="paragraph"><p>Як ви можете бачити на Малюнку 3.2, ці три трейти всі поділяють те саме просте ім'я, <code>Set</code>. Однак їх повністю кваліфіковані імена відрізняються, оскільки кожний знаходиться в окремому пакунку. Конкретні класи множин в Scala API, такі як класи <code>HashSet</code>, показані на Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java ви "реалізуєте" інтерфейси, в Scala ви "розширюєте" або "міксуєте" трейти). Таким чином, якщо ви бажаєте використати HashSet, ви маєте обрати між змінним та незмінним варіаціями, в залежності від ваших потреб. Спосіб по замовчанню створити множину показаний на Лістингу 3.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jetSet</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Boeing&quot;</span><span class="o">,</span> <span class="s">&quot;Airbus&quot;</span><span class="o">)</span>
<span class="n">jetSet</span> <span class="o">+=</span> <span class="s">&quot;Lear&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">jetSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;Cessna&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.5 - Створення, ініціалізація та використання незмінної множини.</p></div>
<div class="paragraph"><p>Малюнок 3.2 - Ієрархія класів для множин Scala.</p></div>
<div class="paragraph"><p>В першому рядук кода в Лістингу 3.5 ви визначаєте нову <code>var</code> на ім'я <code>jetSet</code>, та ініціалізуєте її незмінною множиною, що має два рядка, "Boeing" та "Airbus". Як показує приклад, ви можете створити множини в Scala подібно до того, як ви створюєте списки та масиви: через виклик метода фабрики з назвою <code>apply</code> на об'єкті компанйоні Set. В Лістингу 3.5 ви визиваєте <code>apply</code> на об'єкті компанйоні для  <code>scala.collection.immutable.Set</code>, що повертає примірник по замовчанню, незмінний <code>Set</code>. Компілятор Scala виводить тип <code>jetSet</code> як незмінний <code>Set[String]</code>.</p></div>
<div class="paragraph"><p>Щоб додати новий елемент до множини ви застосовуєте виклик + на множині, передаючи новий елемент. На обох, змінній та незмінній множині метод + буде створювати та поверне нову множину з доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною. Хоча змінні множини пропонують справжній метод <code>+=</code>, незмінні множини ні.</p></div>
<div class="paragraph"><p>В цьому випадку другий рядок коду, <code>jetSet += "Lear</code>, в основному є скороченням для:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">jetSet</span> <span class="k">=</span> <span class="n">jetSet</span> <span class="o">+</span> <span class="s">&quot;Lear&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, в другому рядку Лістингу 3.5 ви переприсвоююте <code>jetSet var</code> новою множиною, що містить "Boeing", "Airbus", та "Lear". Нарешіт, в останньому рядку Лістингу 3.5 іде друк того, чи містить або ні множина рядок "Cessna". (Як ви і очікували, друкується false).</p></div>
<div class="paragraph"><p>Якщо ви бажаєте змінну множину, вам треба використовувати імпорт, як показано в Лістингу 3.6:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">movieSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Hitch&quot;</span><span class="o">,</span> <span class="s">&quot;Poltergeist&quot;</span><span class="o">)</span>
<span class="n">movieSet</span> <span class="o">+=</span> <span class="s">&quot;Shrek&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">movieSet</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.6 - Створення, ініціалізація та використання змінної множини.</p></div>
<div class="paragraph"><p>В першому рядку Лістингу 3.6 ви імпортуєте <code>Set</code>. Як і з Java, твердження <code>import</code> дозволяє вам використовувати просте ім'я, таке як  <code>Set</code>, замість довшого, повністю кваліфікованого імені. Як результат, коли ви кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі <code>scala.collection.mutable.Set</code>. В цьому рядку ви ініціалізуєте <code>movieSet</code> новою змінною, що містить рядки "Hitch" та "Poltergeist". Наступний рядок додає "Shrek" до змінної множини, викликаючи метод <code>+=</code> до множини, передаючи йому рядок "Shrek". Як зазначалось раніше, <code>+=</code> насправді є методом, визначеним на змінній множині. За вашим бажанням, замість <code>writingmovieSet += "Shrek"</code>, ви можете написати <code>movieSet.+=("Shrek")</code>.<span class="footnote"><br />[Оскільки множина в Лістингу 3.6 змінна, немає потреби переприсвоювати movieSet, ось чому вона може бути встановлена в val. До контрасту, використання += з незмінною множиною в Лістингу 3.5 потребує переприсвоєння jetSet, ось чому воно має бути var.]<br /></span></p></div>
<div class="paragraph"><p>Хоча реалізація множин по замовчанню, спродукована змінною та незмінною методами фабриками <code>Set</code>, буде достатньою в багатьох ситуаціях, часом ви можете побажати явно задати клас. Нащастя, синтаксис є подібним. Просто імпортуйте потрібний вам клас, та використовуйте метод фабрику на його об'єкті компанйоні. Наприклад, якщо вам треба незмінний <code>HashSet</code>, ви можете зробити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.immutable.HashSet</span>
<span class="k">val</span> <span class="n">hashSet</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="s">&quot;Tomatoes&quot;</span><span class="o">,</span> <span class="s">&quot;Chilies&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">hashSet</span> <span class="o">+</span> <span class="s">&quot;Coriander&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший корисний клас колекції в Scala є <code>Map</code>. Як і з множинами, Scala провадить змінну та незмінну версії <code>Map</code>, використовуючи ієрархію класів. Як ви можете побачити на Малюнку 3.3, ієрархія класів для мап виглядає мажйе так, як така для множин. Існує базовий трейт <code>Map</code> в пакунку <code>packagescala.collection</code>, і два субтрейти Maps: змінний Map в <code>scala.collection.mutable</code> та незмінний в <code>scala.collection.immutable</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.3 - Ієрархія класів для Scala мап.</p></div>
<div class="paragraph"><p>Реалізації Map, такі як <code>HashMaps</code>, показані в ієрархії на Малюнку 3.3, розширюють або змінний, або незмінний трейт. Ви можете створити та ініціалізувати мапи, використовуючи метди фабрики, подібні до таких для масивів, списків та множин.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">treasureMap</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;Go to island.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;Find big X on ground.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;Dig.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">treasureMap</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.7 - Створення, ініціалізація та використання змінної мапи.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 3.7 показує змінну мапу в дії. On the first line of Лістинг 3.7, you import the mutable Map. You then define a val named treasureMap, and initialize it with an empty mutable Map that has integer keys and string values. The map is empty because you pass nothing to the factory method (the parentheses in "Map[Int, String]()" are empty).<span class="footnote"><br />[Явна параметризація типу, "[Int, String]", є необхідною в Лістингу 3.7, оскільки без любих значень, переданих в метод фабрику компілятор не здатний вивести тип параметрів мапи. Для контрасту, компілятор може вивести тип параметрів зі значень, переданих до фабрики мапи, показаної в Лістингу 3.8, так що явних параметрів типу не треба.]<br /></span> На наступних трьох рядках ви додаєте до мапи пари ключ/значення, використовуючи методи <code>-&gt;</code> та <code>+=</code>. Як вже було проілюстровано, компілятор Scala трансформує двомісні вирази операцій, як <code>1 -&gt; "Go to island."</code> на <code>(1).-&gt;("Go to island.")</code>. Таким чином, коли ви кажете <code>1 -&gt; "Go to island."</code>, ви насправді викликаєте метод на ім'я <code>-&gt;</code> на цілому зі значенням <code>1</code>, передаючи йому рядок зі значенням "Go to island." Цей метод <code>-&gt;</code>, який ви можете викликати на об'єкті в програмі Scala, повертає дво-елементний тапл, що містить ключ та значення.<span class="footnote"><br />[Механізм Scala, що дозволяє вам викликати  &#8594; на любому об'єкті, неявне перетворення, буде розкрите в Главі 21.]<br /></span> Потім ви можете передати тапл до метода <code>+=</code> об'єкта мапи, на який посилається <code>treasureMap</code>. Нарешті, останній рядок друкує значення, що відповідає ключу 2 treasureMap.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте цей код, він надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Find big X on ground.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви обираєте незмінну мапу, імпорт непотрібний, бо незмінна є мапою по замовчанню. Приклад показаний в Лістингу 3.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">romanNumeral</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;I&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;II&quot;</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;III&quot;</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="s">&quot;IV&quot;</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="s">&quot;V&quot;</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">romanNumeral</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.8 - Створення, ініціалізація та використання незмінної мапи.</p></div>
<div class="paragraph"><p>Зважаючи на те, що тут немає імпортів, ви можете сказати, що <code>Map</code> в першому рядку Лістинга 3.8 ви отримаєте замовчання, <code>scala.collection.immutable.Map</code>. Ви передаєте п'ять таплів ключ/значення до метода фабрики мапи, що повертає незмінну <code>Map</code>, яка містить передані пари ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__11____">Крок 11. Вчимсоь розпізнавати функціональний стиль</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, Scala дозволяє вам програмувати в імперативному стилі, але заохочує вас адоптувати більш функціональний стиль. Якщо ви прийшли в Scala з імперативного бекграунда, наприклад, якщо ви Java програміст, одним з головних викликів, з яким ви стикаєтесь при вивченні Scala є зрозуміти, як програмувати в функціональному стилі. Ми розуміємо, що цей стиль зпочатку може бути незвичним, але в цій книзі ми намагаємось направляти вас в цьому переході. Це буде потребувати деякої роботи з вашого боку, і ми закликаємо докласти зусиль. Якщо ви прийшли з імперативного бекграунду, ми віримо, що вивчення програмування в функціональному стилі не тільки зробить вам кращим програмістом Scala, але також розширить ваші горизонти, та зробить кращим програмістом взагалі.</p></div>
<div class="paragraph"><p>Перший крок це розпізнати різницю між двома стилями в коді. Один промовистий знак - це якщо код містить любі <code>var</code>, вірогідно що він в імперативному стилі. Якщо код взагалі не містить — тобто, він містить тільки <code>val</code> — вірогідно він в функціональному стилі. Таким чином, одним шляхом рухатись в функціональному стилі є спробувати програмувати без <code>var</code>.</p></div>
<div class="paragraph"><p>Якщо ви походите з імперативного бекграунда, як Java, C++ або C#, ви можете думати про <code>var</code> як про звичану змінну, та про <code>val</code> як про спеціальний різновид змінних. З іншого боку, якщо ви походите з функціонального бекграунда, як Haskell, OCaml або Erlang, ви можете думати про <code>val</code> як про звичану змінну, та <code>var</code> як спробу святотацтва. Однак перспектива Scala полягає в тому, що <code>val</code> та <code>var`є просто два різні інструменти в вашому наборі, обоє корисні, та жодний не є втілення зла. Scala заохочує вас вивчати щодо `val</code>, але кінець кінцем отримати кращий інструмент, що знадобиться для вашої роботи. Однак навіть якщо ви згодні з цією збалансованою філософією, ви все одно можете на початку знайти складним, як позбавитись від <code>var</code> в своєму коді.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо наступний цикл <code>while</code>, адаптований з Глави 2, що використовує <code>var</code>, та є, таким чином, в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трансформувати цей шматок коду в більш функціональний стиль, поклавши край <code>var</code>, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>або так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад ілюструє одну перевагу від програмування з меншою кількістю <code>var</code>. Рефактований (більш функціональний) код є чистіший, більш стислий, та менш схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з якої Scala заохочує до функціонального стилю, в тому, що він може допомогти вам писати більш зрозумілий, менш схильний до помилок код.</p></div>
<div class="paragraph"><p>Але ви можете пійти навіть далі. Рефакторений метод <code>printArgs</code> не є повністю функціональним, бо він має побічні ефекти — в цьому випадку цей побічний ефект є друк у стандартний вихідний потік. Промовистий знак що функція має побічні ефекти, це коли тип її результата Unit. Якщо функція не повертає жодного цікавого значення, що і означає тип результата Unit, єдиним шляхом, яким функція може зробити зміни в світі, че через деякий різновид побічного ефекту. Більше функціональний підхід може бути в визначенні метода, що форматує передані <code>args</code> для друку, але тільки повертає форматований рядок, як показано в Лістингу 3.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">args</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.9 - A function without side effects or vars.</p></div>
<div class="paragraph"><p>Тепер ви дійсно функціональні: немає ні побічних ефектів, ні <code>var</code> в полі зору. Метод <code>mkString</code>, який ви можете викликати на любій ітерабельній колекції (включаючи масиви, списки, множини та мапи), повкртає рядок, що складається з викликів <code>toString</code> на кожному елементі, розділені переданим рядком. Таким чином, якщо аргументи складаються з трьох аргументів, "zero", "one", "two", <code>formatArgs</code> буде повертати <code>"zero\none\ntwo"</code>. Звичайно, ця функція насправді не друкує нічого назовні, як робив метод <code>printArgs</code>, але ви можете просто передати його результат до <code>println</code>, щоб досягти цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожна корисна програма, вірогідно, буде мати побічні ефекти в деякій формі; інакше, буде неможливо провадити значення до зовнішнього світу. Схильність до методів без побічних ефектів заохочує вас розробляти програми, де код з побічними ефектами мінімізований. Одна з переваг цього підходу в тому, щоце може допомогти вашим програмам простіше тестуватись.</p></div>
<div class="paragraph"><p>Наприклад, щоб протестувати любий з трьох методів <code>printArgs</code>, показаних раніше в цьому розділі, вам треба перевизначити <code>println</code>, перехопити переданий йому вивід, та переконатись, що там те, що ви очікуєте. Для контрасту, ви можете тестувати функцію <code>formatArgs</code>, просто перевіряючи її результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">formatArgs</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="s">&quot;zero\none\ntwo&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод Scala <code>assert</code> перевіряє переданий їй <code>Boolean</code>, та якщо воно <code>false</code>, підіймає <code>AssertionError</code>. Якщо передане <code>Boolean</code> є <code>true</code>, <code>assert</code> просто повертає керування. Ви навчитесь більше щодо тверджень в тестах в Главі 14.</p></div>
<div class="paragraph"><p>Кажучи це, майте на увазі, що ні <code>var</code>, ні побічні ефекти не є природним злом. Scala не є чисто функціональною мовою, що змушує вас програмувати все в функціональному стилі. Scala є гібридною, імперативно/функціональною мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще підходить до вирішуваної проблеми, і в таких випадках вам не треба боятись використовувати його. Однак щоб допомогти вам навчитись, як програмувати без <code>var</code>, ми покажемо вам багато специфічних прикладів коду з <code>var</code>, та як трансформувати ці <code>val</code> в Главі 7.</p></div>
<div class="sect2">
<h3 id="____scala_">Збалансоване ставлення для Scala програмістів</h3>
<div class="paragraph"><p>Схиляйтесь до <code>val</code>, незмінних об'єктів та методів без побічних ефектів. Спочатку розпочніть з них. Використовуйте <code>var</code>, змінні об'єкти та методи з побочними ефектами, коли ви маєте специфічні потреби, та обгрунтування для них.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__12____">Крок 12. Читання рядків з файла</h2>
<div class="sectionbody">
<div class="paragraph"><p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробки рядків в файлі. В цьому розділі ви побудуєте скрипт, що читає рядки з файла, та друкує їх, проставляючи напочату кількість символів в кожному рядку. Перша версія показана в Лістингу 3.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">())</span>
    <span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.10 - Читання рядків з файла.</p></div>
<div class="paragraph"><p>Цей скрипт починається з імпорту класу на ім'я <code>Source</code> з пакунка  <code>scala.io</code>. Потім він перевіряє, щоб побачити, що в командному рядку був вказаний хоча б один аргумент. Якщо так, перший аргумент інтерпретується як ім'я файла, що треба відкрити та обробити. Вираз <code>Source.fromFile(args(0))</code> намагається відкрити вказаний файл, та повертає об'єкт <code>Source</code>, на якому ви викликаєте <code>getLines</code>. Метод <code>getLines</code> повертає <code>Iterator[String]</code>, що провадить по одному рядку на кожній ітерації, відкидаючи символ кінця рядка. Вираз <code>for</code> ітерує по цім рядках, та друкує для кожноого довжину рядка, проміжок, та сам рядок. Якщо в командному рядку не надано жодного аргументу, фінальне твердження <code>else</code> буде друкувати повідомлення в стандартний потік помилок. Якщо ви покладете цей код в файл на ім'я <code>countchars1.scala</code>, та викличете його для самого себе командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala countchars1.scala countchars1.scala</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51 for (line &lt;- Source.fromFile(args(0)).getLines())
37 println(line.length + " " + line)
1 }
4 else
46 Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Хоча скрипт в своїй поточній формі друкує потрібну інформацію, ви можете побажати підрівняти числа, вирівняти вправо, та додати символ роздільника, так щоб вивід виглядав так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 | import scala.io.Source
 0 |
22 | if (args.length &gt; 0) {
 0 |
51 |   for (line &lt;- Source.fromFile(args(0)).getLines())
37 |     println(line.length + " " + line)
 1 | }
 4 | else
46 |   Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Щоб досягти цього, ви можете ітерувати по рядках двічі. На першому проході ви будете визначати максимальну довжину, достатню для любого підрахунку символів. На другому проході ви друкуєте вивід, використовуючи максимальну ширину, що обчислена раніше. Оскільки ви будете ітерувати по рядках двічі, ми можете також присвоїти їх до змінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
</pre></div></div></div>
<div class="paragraph"><p>Заключний <code>toList</code> потрібне, бо метод <code>getLines</code> повертає ітератор. Коли ви проходите через ітератор, він вже витрачений. Трансформуючи його в список через виклик <code>toList</code>, ви отримаєте здатність ітерувати так багато раз, як вам треба, ціною зберігання всіх рядків з файла, одночасно. Таким чином, змінна <code>lines</code> посилається на список рядків, що складають вміст файла, вказаного в командному рядку. Далі, оскільки ми будемо обчислювати ширину довжини кожного рядка двічі, по разу для кожної ітерації, ви можете виділити цей вираз в невелику функцію, що обчислює скільки символів в ширину буде займати довжина рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>З такою функцією ви можете обчислювати максимальну ширину таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span>
  <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">maxWidth</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ви ітеруєте по кожному рядку за допомогою вираза <code>for</code>, обчислює символьну ширину довжини рядка, і якщо вона довша ніж поточний максимум, присвоюється до <code>maxWidth</code>, <code>var</code>, що була ініціалізована як 0. (Метод <code>max</code>, який ви можете викликати на Int, повертає більше зі значень, того, на якому вона викликана, та переданого як параметр). Альтернативно, якщо ви обираєте знайти максимум без <code>var</code>, ви можете спочатку знайти довший рядок, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>reduceLeft</code> застосовує передану функцію до перших двох елементів в <code>lines</code>, потім застосовує її до результату першої операції та наступного елементу в <code>lines</code>, і так далі, по всьому списку. На кожному такому застосуванні результат буде довшим рядком, знайденим до цього моменту, оскільки передана функція, <code>(a, b) =&gt; if (a.length &gt; b.length) a else b</code>, повертає довший з переданих рядків. <code>reduceLeft</code> буде повертати результат останнього застосування функції, що в цьому випадку буде найдовшим рядком-елементом, що міститься в <code>lines</code>.</p></div>
<div class="paragraph"><p>Маючи цей результат, ви можете обчислити максимальну ширину, передаючи найдовший рядок в <code>towidthOfLength</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що лишається, це надрукувати рядки з відповідним форматуванням. Ви можете зробити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
<span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
<span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому виразі ви ще раз ітеруєте по рядках. Для кожного рядка ви спочатку обчислюєте число проміжків, потрібних перед довжиною рядка, та присвоюєте його до <code>numSpaces</code>. Потім ви створюєте рядок, що містить <code>numSpaces</code> проміжків за допомогою вираза <code>" " * numSpaces</code>. Нарешті ви друкуєте інформацію з бажаним форматуванням. Повний скрипт виглядає як показано на Лістингу 3.11:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
  <span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
    <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
  <span class="o">)</span>
  <span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
    <span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.11 - Друкування форматованого підрахунку символів для рядків в файлі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__7">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зі знанням, що ви отримали в цій главі, ви повинні бути здатні почати використовувати Scala для малих завдань, особливо скриптів. В подальших главах ми будемо занурюватись далі в ці теми, та введемо інші теми, що не які тут не було натяку.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__4_2">Глава 4</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____4">Класи та об'єкти</h1>
<div class="paragraph"><p>Тепер ви побачили основи класів та об'єетів Scala з попередніх двох символів. В цій главі ми проведемо вас трохи глибше. Ви навчитесь більше щодо класів, полів те методів, та отримаєте огляд виводу крапки з комою. Ми обсудимо об'єкти синглтонів, включаючи як їх використовувати для написання та виконання застосування Scala. Якщо ви знайомі з Java, ви знайдете, що концепції Scala є подібними, але не саме такі самі. Так що навіть якщо ви Java гуру, все одно це читання варте того.</p></div>
<div class="sect1">
<h2 id="_4_1____">4.1 Класи, поля та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас є проектом об'єкту. Коли ви визначаєте клас, ви можете створити об'єкти з проекту класу за допомогою ключового слова <code>new</code>. Наприклад, маючи визначення класа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
<span class="c1">// class definition goes here</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити об'єкти <code>ChecksumAccumulator</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Всередині визначення класа ви покладаєте поля та методи, що разом називаються членами. Поля, що ви визначаєте за допомогою <code>val</code> або <code>var</code>, є змінними, що посилаються на об'єкти. Методи, що ви визначаєте за допомогою <code>def</code>, містять виконавчий код. Поля зберігають стан, або дані об'єкта, тоді як методи використовують ці дані, щоб зробити обчислювальну роботу об'єкта. Коли ви створюєте примірник класу, середовище виконання відкладає деяку пам'ять для зберігання образу стану об'єкта (тобто вмісту його змінних). Наприклад, так ви визначаєте клас <code>ChecksumAccumulator</code>, та даєте йому поле <code>var</code> на ім'я <code>sum</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>та двічі створюєте його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
<span class="k">val</span> <span class="n">csa</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Зображення об'єктів в пам'яті може виглядати так:</p></div>
<div class="paragraph"><p>Оскільки <code>sum</code>, поле, деклароване в класі <code>ChecksumAccumulator</code>, є <code>var</code>, не <code>val</code>, ви можете пізніше переприсвоїти <code>sum</code> інше значення  <code>Int</code>, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">acc</span><span class="o">.</span><span class="n">sum</span> <span class="k">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер картинка може виглядати ось так:</p></div>
<div class="paragraph"><p>Одна річ, що треба зауважити щодо цього малюнка, в тому, що тут дві змінні <code>sum</code>, одна в об'єкті, не який посилається <code>acc</code>, та інша в об'єкті, на який посилається <code>csa</code>. Поля також відомі як взмінні примірника, бо кожний примірник отримує свій власний набір змінних. Колективно, змінні примірника-об'єкта складають образ пам'яті об'єкта. Ви бачите ілюстрацію цього тут, не тільки тому що ви бачите дві змінні <code>sum</code>, але і через те, що коли змінюєте одну, це не впливає на іншу.</p></div>
<div class="paragraph"><p>Інша річ, на яку слід звернути увагу в цьому прикладі, це те, що ви були в змозі змінити об'єкт, на який посилається <code>acc</code>, навіть якщо сам <code>acc</code> <code>val</code>. Що ви не можете робити з <code>acc</code> (або csa), з гляду на те, що вони <code>val</code>, не <code>var</code>, це переприсвоїти їм інший об'єкт. Наприклад, наступна спроба схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Не буде компілюватись, бо acc є val</span>
<span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, все, на що ви можете розраховувати, це що <code>acc</code> буде завжди посилатись на той самий об'єкт <code>ChecksumAccumulator</code>, яким його ініціалізували, але поля, що містяться всередині цього об'єкта, можуть змінюваться з часом.</p></div>
<div class="paragraph"><p>Один важливий шлях досягти надійності об'єкта, є переконатись, що стан об'єкта — значення його змінних примірника — залишаються валідними під час цілого життєвого циклу. Перший крок є заборонити зовнішньому світу напряму отримувати доступ до полів, зробивши поля приватними. Оскільки приватні поля досяжні тільки з методів, визначених в тому ж класі, весь код, що може оновити стан, буде локалізований в класі. Щоб декларувати приватне поле, покладіть модифікатор доступу <code>private</code> перед полем, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи таку декларацію <code>ChecksumAccumulator</code>, люба спроба отримати доступ до <code>sum</code> ззовні класу буде невдалою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
<span class="n">acc</span><span class="o">.</span><span class="n">sum</span> <span class="k">=</span> <span class="mi">5</span> <span class="c1">// Не буде компілюватись, оскільки `sum` є приватним</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Спосіб, в який ви робите члени публічними в Scala, це не вказувати явно жодного модифікатора доступу. Інакше кажучи, там, де ви кажете <code>public</code> в Java, ви просто нічого не кажете в Scala. Публічний рівень доступу в Scala обираєтьмя по замовчанню.</td>
</tr></table>
</div>
<div class="paragraph"><p>Тепер, коли <code>sum</code> є <code>private</code>, єдиний код, що може отримати доступ до <code>sum</code> є код, визначений всередині тіла самого класа. Таким чином, <code>ChecksumAccumulator</code> не буде дуже корисним, якщо ми не визначимо деякі методи для нього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">checksum</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>ChecksumAccumulator</code> має два методи, <code>add</code> та <code>checksum</code>, обоє з яких демонструють базову форму визначення функції, показану на Малюнку 2.1.</p></div>
<div class="paragraph"><p>Любі параметри метода можуть бути використані всередині метода. Одна важлива характеристика пreasonараметрів метода в Scala в тому, що вони <code>val</code>, не <code>var</code>.<span class="footnote"><br />[Причина, з якої параметри є val в тому, що про val простіше розмірковувати. Ви більше не дивитесь, щоб визначити, чи val було перепризначене, як ви маєте робити з var.]<br /></span> Таким чином, якщо ви спробуєте переприсвоїти параметр всередині метода в Scala, це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">b</span> <span class="k">=</span> <span class="mi">1</span> <span class="c1">// Не буде компілюватись, оскільки b є val</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча <code>add</code> та <code>checksum</code> в цій версії <code>ChecksumAccumulator</code> коректно реалізують бажану функціональність, ви можете виразити їх в більш стислому стилі. Перше, <code>return</code> в кінці метода <code>checksum</code> є надлишковим і може бути відкінуте. За відсутності явного твердження  <code>return</code>, метод Scala повертає останнє значення, обчислене методом.</p></div>
<div class="paragraph"><p>Рекомендованим стилем для методів є, фактично, уникати мати явний, а особливо декілька, тверджень <code>return</code>. Замість цього думайте про кожний метод як про вираз, що видає одне значення, яке він повертає. Ця філософія буде надихати вас робити методи досіть малими, та ділити великі методи на декілька меньших. З іншого боку, вибір дизайну залежить від контексту, та Scala спрощує написання методів, що мають декілька явних <code>returns</code>, якщо це те, що ви задумали.</p></div>
<div class="paragraph"><p>Оскільки все, що робить <code>checksum</code> це обчислення значення, він не потребує явного <code>return</code>. Інше скорочення для методів є те, що ви можете опустити фігурні дужки, якщо метод тільки обчислює одне результуюче значення. Якщо результуючий вираз короткий, його навіть можна покласи в той же рядок, що і сам <code>def</code>. Для виключної стислості ви можете відкинути тип результату, і Scala виведе його. З ціма змінами, клас <code>ChecksumAccumulator</code> виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span> <span class="k">=</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
  <span class="k">def</span> <span class="n">checksum</span><span class="o">()</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча компілятор Scala буде коректно виводити типи результату методів <code>add</code> та <code>checksum</code>, показаних в попередньому прикладі, читачам коду буде треба подумки вивести ці типи результату, через дослідження тіла методів. Як результат, часто краще явно провадити типи результату публічних методів, декларованих в класі, навіть якщо компілятор може вивести його за вас. Лістинг 4.1 показує цей стиль.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file ChecksumAccumulator.scala</span>
<span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span> <span class="o">}</span>
  <span class="k">def</span> <span class="n">checksum</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.1 - Фінальна версія класу ChecksumAccumulator.</p></div>
<div class="paragraph"><p>Методи з типом результата Unit, такі як метод <code>add</code> в ChecksumAccumulator, виконуються заради своїх побочних ефектів. Побічний ефект в основному визначений як зміна стану десь зовні до метода, або виконання операції I/O. В випадку <code>add</code> побічний ефект полягає в переприсвоєнні змінної <code>sum</code>. Метод, що виконується виключно ради побічних ефектів, також відомий як процедура.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_2____">4.2 Вивід крапки з комою</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala програмах крапка з комою в кінці твердження часто є опціональними. Ви можете ставити їх, якщо бажаєте, але не зобов'язані робити це, якщо рядок сам по собі розташований на одному рядку. З іншого боку, крапка з комою обов'язкові, якщо ви маєте декілька тверджень в одному рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span><span class="o">;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте ввести твердження, що займає декілька рядків, більшість часу ви можете просто покласти її, і Scala поділить тврдження в коректному місці. Наприклад, наступне трактується як однорядкове твердження:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;too small&quot;</span><span class="o">)</span>
<span class="k">else</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;ok&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак часом Scala буде ділити твердження на дві частини проти вашого бажання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span>
<span class="o">+</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Це розбирається як два твердження, <code>x</code> та <code>+y</code>. Якщо вашим наміром було розібрати це як одне твердження <code>x + y</code>, ви завжди можете огорнути це в дужки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span>
<span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно, ви можете покласти <code>+</code> в кінці рядка. Тільки з цієї причини, коли ви зціплююте інфіксні операції, такі як <code>+</code>, є загальним стилем Scala покладати оператор в кінці рядка, а не напочатку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span>
<span class="n">y</span> <span class="o">+</span>
<span class="n">z</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="______3">Правила виводу крапок з комою</h3>
<div class="paragraph"><p>Точні правила для розділення тверджень дивуюче прості, як для того, як гарно вони роблять. Коротко, кінці рядків трактуються як крапка з комою, за винятком коли вірне одна умова з наступних:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Розглядаємий рядок завершується на слово, яке не може бути легальним в кінці твердження, таке, як крапка або інфіксний оператор.
</p>
</li>
<li>
<p>
Наступний рядок починається зі слова, що не може починати твердження.
</p>
</li>
<li>
<p>
Рядок завершується, коли відкриті дужки (&#8230;) або [&#8230;], оскільки вони в жодному разі не можуть містити декілька тверджень.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_3___">4.3 Об'єкти синглтонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, один спосіб, в який Scala більш об'єктно-орієнтована, ніж Java, це що класи в Scala. Замість цього,  Scala має об'єкти синглтонів. Визначення об'єкта синглтона виглядає як визначення класу, за винятком того, що замість ключового слова <code>class</code> ви використовуєте ключове слово <code>object</code>. Лістинг 4.2 показує приклад.</p></div>
<div class="paragraph"><p>Об'єкт синглтона на цій фігурі названий <code>ChecksumAccumulator</code>, те саме, що і ім'я класу в попередньому прикладі. Коли сінглтон поділяє те саме ім'я з класом, він називається об'єктом компанйоном класа. Ви маєте обох, клас та його об'єкт компанйон в тому ж джерельному файлі. Клас називається компанйон класом об'єкта синглтона. Клас та його об'єкт компанйон можуть отримувати доступ до приватних членів один одного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file ChecksumAccumulator.scala</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">object</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">calculate</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
      <span class="n">cache</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">toByte</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="n">acc</span><span class="o">.</span><span class="n">checksum</span><span class="o">()</span>
      <span class="n">cache</span> <span class="o">+=</span> <span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">cs</span><span class="o">)</span>
      <span class="n">cs</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.2 - Об'єкт компанйон для класа ChecksumAccumulator.</p></div>
<div class="paragraph"><p>Об'єкт сінглтон <code>ChecksumAccumulator</code> має один метод з назвою <code>calculate</code>, що приймає <code>String</code>, та обчислює контрольну суму для символів в <code>String</code>. Він також має одне приватне поле, <code>cache</code>, змінну мапу, в якій кешуються попередньо обчислені контрольні суми.<span class="footnote"><br />[Ми використовуємо тут кеш, щоб показати об'єкт синглтон з полем. Кеш, такий як цей, є оптимізацією продуктивності, що міняє пам'ять на час обчислення. Загалом, ви мали б використовувати такий архів, тільки якщо натрапили на проблему продуктивності, яку може вирішити кеш, та можливо використовувати слабку мапу, таку як <code>WeakHashMap</code> в <code>scala.collection.jcl</code>, так що елементи цього кеша підпали б під збирання сміття, коли з пам'ятю стало скрутно.]<br /></span> Перший рядок цього метода, <code>if (cache.contains(s))</code>, перевіряє кеш, чи переданий рядок вже існує як ключ в кеші. Якщо так, він просто повертає відображене значення, кеш(і). Інакше, він виконує варіант <code>else</code>, що обчислює контрольну суму. Перший рядок <code>else</code> визначає <code>val</code> на ім'я <code>acc</code>, та ініціалізує її новим примірником <code>ChecksumAccumulator</code>.<span class="footnote"><br />[Оскільки ключове слово  <code>new</code> використовується тільки для створення класів, новий створений тут об'єкт є примірником класу <code>ChecksumAccumulator</code>, не об'єкта синглтона з тим самим іменем.]<br /></span> Наступний рядок є виразом <code>for</code>, що проходить по кожному символу в переданому рядку, конвертуючи символ на Byte, через виклик toByte на ньому, та передає його до метода  <code>add</code> примірника <code>ChecksumAccumulator</code>, на який посилається <code>acc</code>. Після завершення виразу <code>for</code>, наступний рядок метода викликає <code>checksum</code> на <code>acc</code>, що отримує контрольну суму для переданого <code>String</code>, та зберігає його в <code>val</code> на ім'я <code>cs</code>. В наступному рядку, <code>cache += (s -&gt; cs)</code>, переданий рядок-ключ відзеркалюється на ціле значення контрольної суми, і ця пара ключ-значення додається до мапи <code>cache</code>. Останній вираз метода, <code>cs</code>, запевняє, що контрольна сума є результатом метода.</p></div>
<div class="paragraph"><p>ЯКщо ви Java програміст, один спосіб щоб думати про об'єкт синглтон як про домівку для любих статичних методів, що ви могли написати в  Java. Ви можете викликати методи на об'єкті синглтоні, використовуючи подібний синтаксис: ім'я об'єкта синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати метод <code>calculate</code> об'єкта синглтона таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">ChecksumAccumulator</span><span class="o">.</span><span class="n">calculate</span><span class="o">(</span><span class="s">&quot;Every value is an object.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак об'єкт синглтон є більше, ніж утримувач статичних методів. Це першокласний об'єкт. Ви можете думати про ім'я об'єкта синглтона, таким чином, як про "тег імені", приєднаного до об'єкту:</p></div>
<div class="paragraph"><p>Визначення об'єкта синглтона не визначає тип (на рівні абстракції Scala). Маючи тільки визначення об'єкту ChecksumAccumulator, ви не зможете створити змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator визначається через клас компанйон об'єкта синглтона. Однак, синглтон об'єкти розширюють суперклас, та можуть міксувати трейти. Беручи, що кожний об'єкт синглтон є примірником свого суперкласу та примішаних трейтів, ви можете викликати його методи через ці типи, посилатись на нього через змінні ціх типів, та передавати його методам, що очікують ці типи. Ми покажемо деякі приклади об'єктів синглтонів, що наслідують від класів та трейтів в Главі 13.</p></div>
<div class="paragraph"><p>Одна відмінність між класами та об'єктами синглтонами в тому, що синглтон об'єкт не може приймати параметрів, тоді як клас може. Оскільки ви не можете створити примірник синглтон об'єкта за допомогою ключового слова <code>new</code>,ви не маєте способа передати йому параметри. Кожний синглтон об'єкт був реалізований як примірник синтетичного класу, на який посилається статична змінна, так що вони мають ту саму семантику ініціалізації, що і статики в Java.<span class="footnote"><br />[Ім'я синтетичного класу є ім'я об'єкту, плюс знак долару. Таким чином, синтетичний клас для об'єкта синглтона на ім'я ChecksumAccumulator є ChecksumAccumulator$.]<br /></span> Зокрема, об'єкт синглтон буде ініціалізований, коли код отримає до нього доступ в перший раз.</p></div>
<div class="paragraph"><p>Синглтон, що не поділяє те саме ім'я з класом компанйоном, називається окремим об'єктом. Ви можете використовувати окремі об'єкти для багатьох призначень, включаючи збір пов'язаних допоміжних методів, або визначення точки входу в застосування Scala. Цей випадок застосування показаний в наступному розділі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_4__scala">4.4 Застосування Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб виконати Scala програму, ви маєте надати ім'я окремого об'єкта синглтона з методом <code>main</code>, що приймає один параметр, <code>Array[String]</code>, та має тип результата Unit. Любий окремий об'єкт з методом <code>main</code> відповідної сигнатури, може бути використаний як вхідна точка в застосування. Приклад показаний в Лістингу 4.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file Summer.scala</span>
<span class="k">import</span> <span class="nn">ChecksumAccumulator.calculate</span>
<span class="k">object</span> <span class="nc">Summer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
       <span class="n">println</span><span class="o">(</span><span class="n">arg</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.3 - Застосування Summer.</p></div>
<div class="paragraph"><p>Ім'я об'єкта синглтона в Лістенгу 4.3 є Summer. Його метод <code>main</code> має відповідну сигнатуру, так що ви можете використовувати його як застосування. Перше твердження в файлі є імпорт метода <code>calculate</code>, визначеного в об'єкті ChecksumAccumulator в попередньому прикладі. Це твердження <code>import</code> дозволяє вам використовувати просте ім'я метода в залишку файла.<span class="footnote"><br />[Якщо ви Java програміст, ви можете думати про цей імпорт, як про можливість статичного імпорту, введену в Java 5. Однак в Scala є одна різниця, в тому, що ви можете імпортувати члени з любого об'єкта, не тільки з об'єктів синглтонів.]<br /></span> Тіло метода <code>main</code> просто друкує кожний аргумент, та контрольну суму для аргумена, відділену роздільником.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Scala неявно імпортує члени пакунків <code>java.lang</code> та <code>scala</code>, так само, як члени об'єкта синглтона на ім'я <code>Predef</code>, в кожний джерельний файл Scala. <code>Predef</code>, що знаходиться в пакунку <code>scala</code>, містить багато корисних методів. Наприклад, коли ви кажете <code>println</code> в джерельному файлі Scala, насправді ви викликаєте <code>println</code> на <code>Predef</code>. (<code>Predef.println</code> обертається, та викликає <code>Console.println</code>, що робить реальну роботу). Коли ви кажете <code>assert</code>, ви викликаєте <code>Predef.assert</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Щоб виконати застосування Summer, покладіть код з Лістинга 4.3 в файл з назвою Summer.scala. Оскільки <code>Summer</code> використовує <code>ChecksumAccumulator</code>, покладіть код для <code>ChecksumAccumulator</code>, обоє, клас, показаний в Лістингу 4.1, та його об'єкт компанйон, показаний в Лістингу 4.2, в файл на ім'я <code>ChecksumAccumulator.scala</code>.</p></div>
<div class="paragraph"><p>Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви покладали публічні класи в файл з іменем класа — наприклад, ви поклали клас <code>SpeedRacer</code> в файл <code>SpeedRacer.java</code> — в Scala ви можете називати <code>.scala</code> файли як побажаєте, не важливо, які Scala класи або код ви покладете до них. Однак загалом, в випадку не-скриптів, є рекомендованим стилем називати файли по іменах класів, які вони містять, як це зроблено в Java, так що програмісти можуть більш просто знайти класи, шукаючи по іменах файлів. Цей підхід, що ми прийняли для двох файлів в цьому  прикладі, <code>Summer.scala</code> та <code>ChecksumAccumulator.scala</code>.</p></div>
<div class="paragraph"><p>Ні <code>ChecksumAccumulator.scala</code>, ані <code>Summer.scala</code> не є скриптами, бо закінчуються на визначення. Скрипт, для контрасту, має завершуватись на вираз результату. Так що якщо ви спробуєте виконати <code>Summer.scala</code> як скрипт, інтерпретатор Scala буде скаржитись, що <code>Summer.scala</code> не завершується на вираз результату (вважаємо, звичайно, що ви не додали якийсь вираз після визначення об'єкта  <code>Summer</code>). Замість цього, вам буде треба насправді скомпілювати ці файли за допомогою Scala компілятора, та потім виконати отримані файли <code>class</code>. Один шлях зробити це є використання <code>scalac</code>, що є базовим компілятором Scala, ось так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scalac ChecksumAccumulator.scala Summer.scala</code></pre>
</div></div>
<div class="paragraph"><p>Це компілює ваш джерельний файл, але може бути відчутна затримка перед завершенням компіляції. Причина в тому, що кожного разу, коли запускається компілятор, він витрачає час, скануючі вміст jar файлів, та роблячи іншу роботу з ініціалізації, перед тим, як він навіть тільки погляне не нові джерельні файли, яки ви надіслали йому. З цієї причини дистрибутив Scala також включає демон компіляції Scala з назвою <code>fsc</code> (fast Scala compiler). Ви використовуєте його таким чином:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fsc ChecksumAccumulator.scala Summer.scala</code></pre>
</div></div>
<div class="paragraph"><p>Перший раз, як ви запустите <code>fsc</code>, він створить локальний демон сервера, підключений до порту вашого комп'ютера. Потім він буде надсилати список файлів на компіляцію до демона через порт, і демон буде компілювати ці файли. Наступний раз, коли ви виконаєте <code>fsc</code>, демон вже буде запущений, так що <code>fsc</code> буде просто посилати список файлів до демона, що буде безпосередньо компілювати ці файли. Використовуючи <code>fsc</code>, вам треба чекати тільки щоб рантайм Java запустився в перший раз. Якщо ви колись побажаєте запинити демона <code>fsc</code>, ви можете зробити це за допомогою <code>fsc - shutdown</code>.</p></div>
<div class="paragraph"><p>Виконання любого з них, команди <code>scalac</code> або <code>fsc</code>, буде продукувати файли класів Java, які ви потім можете виконати через команду <code>scala</code>, ту саму команду, що ви використовували для виклику інтерпретатора в попередніх прикладах. Оданак замість надання їй файла з розширенням <code>.scala</code>, що містить код Scala для інтерпретації, як ви робили в кожному попередньому прикладі,<span class="footnote"><br />[Справжній механізм, який програма <code>scala</code> використовує для "інтерпретації" джерельного файлу Scala, є те, що вона компілює джерельний код Scala в байткоди Java, безпосередньо завантажує їх через завантажувач класів, та виконує їх.]<br /></span> в цьому випадку ви дасте їй ім'я окремого об'єкту, що має метод <code>main</code> з відповідною сигнатурою. Ви можете виконати застосування Summer, таким чином, набравши:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala Summer of love</code></pre>
</div></div>
<div class="paragraph"><p>Ви побачите контрольні суми, роздруковані для двох аргументів командного рядка:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>of: -213
love: -182</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_5__app">4.5 Трейт App</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить трейт <code>scala.App</code>, що може зберігти вам деякий час за друком. Хоча ми ще не розглянули все, що вам треба для розуміння саме як цей трейт робить, ми припускаємо, що ви бажаєте знати про це саме зараз, будь-що. Лістинг 4.4 показує приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">ChecksumAccumulator.calculate</span>
<span class="k">object</span> <span class="nc">FallWinterSpringSummer</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">season</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;fall&quot;</span><span class="o">,</span> <span class="s">&quot;winter&quot;</span><span class="o">,</span> <span class="s">&quot;spring&quot;</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">season</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">season</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.4 - Використання трейта App.</p></div>
<div class="paragraph"><p>Щоб використати цей трейт, зпочатку ви пишете <code>extends App</code> після імені вашого синглтон об'єкта. Потім замість писати метод <code>main</code>, ви кладете код, що ви б мали покласти в метод <code>main</code>, прямо між фігурними дужками об'єкта синглтона. Ви можете отримати доступ до аргументів командного рядка через масив рядків на ім'я <code>args</code>. Це все. Ви можете компілювати та виконувати це застосування, так само як любе інше.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_6_">4.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала вам основи класів та об'єктів в Scala, та показала вам, як компілювати та виконувати застосування. В наступній главі ми вивчимо базові типи Scala, та як їх використовувати.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__5_2">Глава 5</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____5">Базові типи і операції</h1>
<div class="paragraph"><p>Тепер, коли ви побачили класи і об'єкти в дії, настав гарний час подивитись на базові типи та операції Scala більш глибоко. Якщо ви знайомі з Java, ви будете раді узнати, що базові типи і операції  Java мають те саме значення в Scala. Однак є деякі цікаві розбіжності, що роблять цю главу варту прочитання, навіть якщо ви досвідчений Java розробник. Оскільки деякі аспекти Scala, розглянуті в цій главі в основі ти самі, що і в Java, ми вставили зауваження, що ці частини Java розробники можуть пропустити.</p></div>
<div class="paragraph"><p>В цій главі ви отримаєте огляд базових класів Scala, включаючи  <code>String</code> та типи значень, <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>, <code>Double</code>, <code>Char</code>, та <code>Boolean</code>. Ви вивчите операції, що ви можете виконувати з ціма типами, включаючи те, як робить преоритетність операторів в виразах Scala. Ви також вивчите, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи додаткові операції, крім тих, що підтримуються в Java.</p></div>
<div class="sect1">
<h2 id="_5_1___">5.1 Деякі базові типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Декілька фундаментальних типів Scala, разом и диапазонами знічень ціх типів, яки вони можуть приймати, показані в Таблиці 5.1. Загалом типи <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code> та <code>Char</code> називаються інтегральними типами. Інтегральні типи разом з <code>Float</code> та <code>Double</code> називаються числовими типами.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі базові типи</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Диапазон</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="left" valign="top"><p class="table">8-бітне ціле зі знаком (від -2<sup>7</sup> до 2<sup>7</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="left" valign="top"><p class="table">16-бітне ціле зі знаком (від -2<sup>15</sup> до 2<sup>15</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="left" valign="top"><p class="table">32-бітне ціле зі знаком (від -2<sup>31</sup> до 2<sup>31</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="left" valign="top"><p class="table">64-бітне ціле зі знаком (від -2<sup>63</sup> до 2<sup>63</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="left" valign="top"><p class="table">16-бітний беззнаковий символ Unicode (від 0 до 2<sup>16</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">послідовність Char</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="left" valign="top"><p class="table">32-бітне IEEE 754 з плаваючою крапкою одинарна точність</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="left" valign="top"><p class="table">64-бітне IEEE 754 з плаваючою крапкою подвійна</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="left" valign="top"><p class="table">true або false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Всі крім <code>String</code>, що знаходиться в пакунку <code>java.lang</code>, всі типи, показані в Таблиці 5.1 є членами пакунку <code>scala</code>.<span class="footnote"><br />[Пакунки, що були коротко описані на Кроці 1 в Главі 2, будуть розглянуті глибоко в Главі 13.]<br /></span> Наприклад, повне ім'я <code>Int</code> є <code>scala.Int</code>. Однак беручи, що всі члени з пакунку <code>scala</code> та <code>java.lang</code> автоматично імпортуються в кожний джерельний файл Scala, ви можете використовувати самі прості імена (тобто імена як Boolean, Char, або String) будь-де.</p></div>
<div class="paragraph"><p>Допитливі Java розробники зауважать, базові типи Scala мають ті самі диапазони, що і відповідні типи в Java. Це дозволяє компілятору  Scala трансформувати примірники значень Scala, такі як <code>Int</code> або <code>Double</code>, до примітивних типів Java в спродукованому байткоді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2_">5.2 Літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі базові типи, перелічені в Таблиці 5.1 можуть бути записані як літерали. Літерал - це шлях написати стале значення прямо в коді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java_">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис більшосі літералів, показаних в цьому розділі, є саме таким, як і в Java, так що якщо ви майстер Java, ви можете безпечно пропустити більшість цього розділу. Деякі розбіжності з описаних тут ви можете прочитати щодо Scala літералів для сирих рядків та символів, а також про інтерполяцію рядків. Також Scala не підтримує восьмиричні літерали; цілі літерали, що починаються з нуля, такі як  031, не будуть компілюватись.</p></div>
<div class="sect2">
<h3 id="___5">Цілі літерали</h3>
<div class="paragraph"><p>Цілі літерали для типів <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code> ідуть в двох форматах: десятичному та шістнадцятиричному. Від того, з чого починається літерал, залежить основа числа. Якщо число починається з 0x або 0X, це шістнадцятирічне (основа 16), та може містити цифри від 0 до 9, так само як літери в верхньому або нижньому реєстрі від A до F. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hex</span> <span class="k">=</span> <span class="mh">0x5</span>
<span class="n">hex</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hex2</span> <span class="k">=</span> <span class="mh">0x00FF</span>
<span class="n">hex2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">magic</span> <span class="k">=</span> <span class="mh">0xcafebabe</span>
<span class="n">magic</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">889275714</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що оболонка Scala завжди друкує цілі значення по основі 10, не важливо, якою формою літерала ви ініціалізували її. Таким чином, інтерпретатор відображує значення змінної <code>hex2</code>, що ви ініціалізували літералом <code>0x00FF</code> як десятичне <code>255</code>. (Звичайно, ви не маєте вірити нам на слово. Гарний спосіб почати відчувати мову є спробувати твердження в інтерпретаторі по мірі читання цієї глави.) Якщо число починається з не-нульової цифри, воно десяткове (основа
10). Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec1</span> <span class="k">=</span> <span class="mi">31</span>
<span class="n">dec1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">31</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec2</span> <span class="k">=</span> <span class="mi">255</span>
<span class="n">dec2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec3</span> <span class="k">=</span> <span class="mi">20</span>
<span class="n">dec3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо цілий літерал закінчується на L або l, це <code>Long</code>; інакше це <code>Int</code>. Деякі приклади <code>Long</code> літералів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">prog</span> <span class="k">=</span> <span class="mi">0</span><span class="nc">XCAFEBABEL</span>
<span class="n">prog</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">3405691582</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">tower</span> <span class="k">=</span> <span class="mi">35L</span>
<span class="n">tower</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">35</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">of</span> <span class="k">=</span> <span class="mi">31</span><span class="n">l</span>
<span class="n">of</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">31</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>Int</code> літерал присвоюється змінній <code>Short</code> або <code>Byte</code>, литерал розглядається як би він був <code>Short</code> або <code>Byte</code>, доки значення літерала в валідному диапазоні. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">little</span><span class="k">:</span> <span class="kt">Short</span> <span class="o">=</span> <span class="mi">367</span>
<span class="n">little</span><span class="k">:</span> <span class="kt">Short</span> <span class="o">=</span> <span class="mi">367</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">littler</span><span class="k">:</span> <span class="kt">Byte</span> <span class="o">=</span> <span class="mi">38</span>
<span class="n">littler</span><span class="k">:</span> <span class="kt">Byte</span> <span class="o">=</span> <span class="mi">38</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____6">Літерали з плаваючою крапкою</h3>
<div class="paragraph"><p>Літерали з плаваючою крапкою складаються з десятичних цифр, опціонально містять десятичну крапку, опціонально далі іде E або e та експонента. Деякі приклади літералів з плаваючою крапкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">big</span> <span class="k">=</span> <span class="mf">1.2345</span>
<span class="n">big</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.2345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bigger</span> <span class="k">=</span> <span class="mf">1.2345e1</span>
<span class="n">bigger</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">12.345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">biggerStill</span> <span class="k">=</span> <span class="mi">123</span><span class="n">E45</span>
<span class="n">biggerStill</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.23E47</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що частина експоненти означає ступінь десяти, на яку домножається інша частина. Таким чином 1.2345e1 є 1.2345 разів по 10<sup>1</sup>, що є 12.345. Якщо літерал з плаваючою крапкою завершується на F або f, це <code>Float</code>; інакше це <code>Double</code>. Опціонально, літерал з плаваючою крапкою <code>Double</code> може завершуватись на D або d. Деякі приклади літералів <code>Float</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">little</span> <span class="k">=</span> <span class="mf">1.2345F</span>
<span class="n">little</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">1.2345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">littleBigger</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5f</span>
<span class="n">littleBigger</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">300000.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Це останнє значення, виражене як <code>Double</code> може приймати такі (ті інші) форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">anotherDouble</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5</span>
<span class="n">anotherDouble</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">300000.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">yetAnother</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5D</span>
<span class="n">yetAnother</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">300000.0</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___6">Символі літерали</h3>
<div class="paragraph"><p>Символьні літерали складаються з Unicode символа між поодинокими лапками, такі як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="sc">&#39;A&#39;</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">A</span>
</pre></div></div></div>
<div class="paragraph"><p>На додаток до провадження явного символа між поодинокими лапками, ви можете сказати символ, використовуючи кодову точку Unicode. Щоб зробити це, запишіть \u, за якими чотири шіснадцятиричних цифри кодовою точки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="sc">&#39;\u0041&#39;</span>
<span class="n">d</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">A</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="sc">&#39;\u0044&#39;</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">D</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, такі Unicode символи можуть з'являтись будь-де в програмі Scala. Наприклад, ви можете також написати ідентифікатор таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">B</span><span class="o">\</span><span class="n">u0041</span><span class="o">\</span><span class="n">u0044</span> <span class="k">=</span> <span class="mi">1</span>
<span class="nc">BAD</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей ідентифікатор розглядається як ідентичний до BAD, результат двох Unicode символів в коді вище. Загалом це погана ідея називати ідентифікатори таким чином, оскільки їх важко читати. Скоріше цей синтаксис призначений щоб дозволити джерельним файлам Scala, що містять не-ASCII Unicode символи бути представленими в ASCII.</p></div>
<div class="paragraph"><p>Нарешті, існують також декілька літералів, представлених спеціалними ескейп виключеннями, показаними в Таблиці 5.2. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">backslash</span> <span class="k">=</span> <span class="sc">&#39;\\&#39;</span>
<span class="n">backslash</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="o">\</span>
</pre></div></div></div>
<div class="paragraph"><p>Специальні символи, ескейп послідовності</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Літерал </th>
<th align="center" valign="top"> Значення</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">\n</p></td>
<td align="center" valign="top"><p class="table">перевод рядка (\u000A)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\b</p></td>
<td align="center" valign="top"><p class="table">сторно (\u0008)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\t</p></td>
<td align="center" valign="top"><p class="table">табуляція (\u0009)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\f</p></td>
<td align="center" valign="top"><p class="table">нова сторінка (\u000C)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\r</p></td>
<td align="center" valign="top"><p class="table">повернення каретки (\u000D)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\"</p></td>
<td align="center" valign="top"><p class="table">подвійні лапки (\u0022)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\'</p></td>
<td align="center" valign="top"><p class="table">поодинокі лапки (\u0027)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\\</p></td>
<td align="center" valign="top"><p class="table">зворотня коса (\u005C)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="___7">Рядкові літерали</h3>
<div class="paragraph"><p>Рядкові літерали складаються з символів в подвійних лапках:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hello</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">hello</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span>
</pre></div></div></div>
<div class="paragraph"><p>Стнтаксис символів в дужках той самий, як і в символьних літералах. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">escapes</span> <span class="k">=</span> <span class="s">&quot;\\\&quot;\&#39;&quot;</span>
<span class="n">escapes</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">\</span><span class="err">&quot;&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки цей синтаксис незручний для рядків, що містять багато ескейп послідовностей, або рядків, що перетинають багато рядків,  Scala включає особливий синтаксис для сирих рядків. Ви починаєте та завершуєте сирий рядок трьома подвійними лапками поспіль ("""). Внутрішність сирого рядка може містити любі символи, будь-що, включаючи нові рядки, лапки, спеціальні символи, за винятком, зрозуміло, тьох подвійних лапок повпіль. Наприклад, наступна програма друкує повідомлення використовуючи сирий рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">&quot;&quot;&quot;Welcome to Ultamix 3000.</span>
<span class="s">           Type &quot;HELP&quot; for help.&quot;&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак виконання цього кода не продукує саме те, що задумане:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Welcome to Ultamix 3000.
           Type "HELP" for help.</code></pre>
</div></div>
<div class="paragraph"><p>Проблема в тому, що початкові проміжки в другому рядку включені в рядок! Щоб допомогти в цій загальній ситуації, ви можете викликати для рядків stripMargin. Щоб використати цей метод, покладіть символ роздільника (|) спереду кожного рядка, та потім викличте  <code>stripMargin</code> для цілого рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">&quot;&quot;&quot;|Welcome to Ultamix 3000.</span>
<span class="s">           |Type &quot;HELP&quot; for help.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">stripMargin</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер код поводиться як задумано:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Welcome to Ultamix 3000.
Type "HELP" for help.</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="___8">Символьні літерали</h3>
<div class="paragraph"><p>Символьний літерал записується <code>'ident</code>, де <code>ident</code> може бути любим ідентифікатором з літер та цифр. Такі літерали відображуються на примірники передвизначеного класу <code>scala.Symbol</code>. Зокрема, літерал <code>'cymbal</code> буде розширений компілятором до виклику метода фабрики: <code>Symbol("cymbal")</code>. Символьні літерали типово використовуються в ситуаціях, де ви можете використовувати ідентифікатор в динамічно типизованих мовах. Наприклад, ви можете побажати визначити метод, що оновлює запис в базі даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
<span class="c1">// code goes here</span>
<span class="o">}</span>
<span class="n">updateRecordByName</span><span class="k">:</span> <span class="o">(</span><span class="kt">Symbol</span><span class="o">,</span><span class="kt">Any</span><span class="o">)</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод приймає в якості параметра символ, що вказує ім'я поля запису,в яке траба внести зміни. В динамічно типизованих ви можете визвати цю операцію, передаючи в метод недекларований ідентифікатор поля, але в Scala це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class="n">favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="kt">value</span> <span class="kt">favoriteAlbum</span>
<span class="n">updateRecordByName</span><span class="o">(</span><span class="n">favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього, і майже так стисло, ви можете передати символьний літерал:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class=" -Symbol">&#39;favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З символом ви можете робити не дуже багато чого, крім з'ясувати його ім'я:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class=" -Symbol">&#39;aSymbol</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">Symbol</span> <span class="o">=</span> <span class=" -Symbol">&#39;aSymbol</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nm</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="n">nm</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">aSymbol</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша річ, що варта уваги, це те, що символи інтерновані. Якщо ви пишете той самий літерал двічі, обоє вирази будуть посилатись на той самий об'єкт <code>Symbol</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___9">Логічні літерали</h3>
<div class="paragraph"><p>Тип Boolean має два літерала, <code>true</code> та <code>false</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bool</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">bool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fool</span> <span class="k">=</span> <span class="kc">false</span>
<span class="n">fool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Це все щодо цього. Тепер ви буквально експерт в Scala.<span class="footnote"><br />[фігурально кажучи]<br /></span></p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_3__">5.3 Інтерполяція рядків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala включає гнучкий механізм для інтерполяції рядків, що дозполяє вам вбудовувати вирази в рядкові літерали. Її найбільш загальний випадок викорстання є провадження стислої та читабельної альтернативи до конкатенації рядків. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;reader&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="s">s&quot;Hello, </span><span class="si">$name</span><span class="s">!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>s"Hello, $name!"</code> є обробляємий рядковий літерал. Оскільки літера <code>s</code> безпосередньо передує відкриваючим лапкам, Scala скала буде використовувати інтерполяцію рядка <code>s</code> для обробки літерала. Цей <code>s</code> інтерполятор буде обчислювати кожний вбудований вираз, викликаючи <code>toString</code> для кожного результата, та замінює вбудовані вирази в літералі на ці результати. Таким чином, <code>s"Hello, $name!"</code> дає <code>"Hello, reader!"</code>, той самий результат, що і <code>"Hello, " + name + "!"</code>.</p></div>
<div class="paragraph"><p>Ви можете покласти любий вираз після знаку долара ($) в оброблюваний рядковий літерал. Для одно-змінних виразів, ви часто можете ім'я змінної після знаку долару. Scala буде інтерпретувати всі символи до першого не-ідентифікаторного символа як вираз. Якщо вираз включає не-ідентифікаторні символи, ви маєте покласли його в фігурні дужки, з відкриваючою дужкою прямо за знаком долара. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">s&quot;The answer is </span><span class="si">${</span><span class="mi">6</span> <span class="o">*</span> <span class="mi">7</span><span class="si">}</span><span class="s">.&quot;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">The</span> <span class="n">answer</span> <span class="n">is</span> <span class="mf">42.</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala провадить два інші інтерполятора по замовчанню: <code>raw</code> та <code>f</code>. Інтерпретатор рядків <code>raw</code> поводиться як <code>s</code>, за винятком того, що він не розпізнає сивольні літерали ескейп послідовності (такі як показані в Таблиці 5.2). Наприклад, наступне твердження друкує чотири зворотні косі, не дві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">raw&quot;No\\\\escape!&quot;</span><span class="o">)</span> <span class="c1">// prints: No\\\\escape!</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерполятор рядка <code>f</code> дозволяє вам додати вам інструкції форматування в стилі <code>printf</code> для вбудованих виразів. Ви покладаєте інструкції після виразу, починаючи зі знака відсотків (%), використовуючи синтаксис, заданий в <code>java.util.Formatter</code>. Наприклад, ось як ви можете форматувати число pi</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">f&quot;</span><span class="si">${</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="si">}</span><span class="s">%.5f&quot;</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mf">3.14159</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви не провадите інструкцій форматування для вбудованого виразу, рядковий інтерпретатор <code>f</code> буде по замовчанню вважати <code>%s</code>, що означає, що буде підставлено значення <code>toString</code>, так само як інтерпретатор рядків <code>s</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="s">&quot;Pi&quot;</span>
<span class="n">pi</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Pi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="s">f&quot;</span><span class="si">$pi</span><span class="s"> is approximately </span><span class="si">${</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="si">}</span><span class="s">%.8f.&quot;</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Pi</span> <span class="n">is</span> <span class="n">approximately</span> <span class="mf">3.14159265</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala інтерполяція рядків реалізована через переписування кода під час компіляції. Компілятор буде трактувати любий вираз, що складається з ідентифікатора, безпосередньо за яким іде подвійни лапки рядкового літералу, є виразом інтерполятора рядка. Інтерпретатори рядків <code>s</code>, <code>f</code>, та <code>raw</code> реалізовані через цей загальний механізм. Бібліотеки та користувачі можуть визначати інші інтерполятори рядків для інших цілей.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_4___">5.4 Оператори та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить потужний набір операторів для своїх базових типів. Як згадувалось в попередніх главах, ці операції насправді є милим синтаксисом для звичайних викликів методів. Наприклад, <code>1 + 2</code> насправді означає те саме, що <code>1.+(2)</code>. Іншими словами, клас <code>Int</code> містить метод <code>+</code>, що приймає <code>Int</code> та повертає результат <code>Int</code>. Цей метод <code>+ викликається, коли ви додаєте два `Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// Scala invokes 1.+(2)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб переконатись в цьому, ви можете написати вираз явно як виклик метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sumMore</span> <span class="k">=</span> <span class="mf">1.</span><span class="o">+(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">sumMore</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, <code>Int</code> містить декілка перевантажених методів <code>+</code>, що приймають різні типів параметрів.<span class="footnote"><br />[3]<br /></span> For example, Int has another method, also named +, that takes and returns a Long. If you add a Longto an Int, this alternate + method will be invoked, as in:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">longSum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2L</span>
<span class="n">longSum</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// Scala invokes 1.+(2L)</span>
</pre></div></div></div>
<div class="paragraph"><p>Символ <code>+</code> є оператором — інфіксним оператором, якщо бути точнішим. Операторна нотація не обмежена до методів, як <code>+</code>, що виглядають як оператори в інших мовах. Ви можете використовувати любий метод в операторній натації. Наприклад, клас <code>String</code> має метод <code>indexOf</code>, що приймає один параметр <code>Char</code>. Метод <code>indexOf</code> шукає рядок на перше співпадіння вказаного символа, та повертає його індекс, або <code>-1</code>, якщо вона не знайшла символ. Ви можете використовувати <code>indexOf</code> як оператор, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">indexOf</span> <span class="sc">&#39;o&#39;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1">// Scala invokes s.indexOf(&#39;o&#39;)</span>
</pre></div></div></div>
<div class="paragraph"><p>На додаток, <code>String</code> пропонує перевантажений метод <code>indexOf</code>, що приймає два параметри, символ, що треба шукати, та індекс, з якого починати. (Інший метод <code>indexOf</code>, показаний попередньо, починає з індексу 0, початку <code>String</code>.) Навіть якщо цей метод <code>indexOf</code> приймає два аргументи, ви можете використовувати його в операторній нотації. Але коли ви викликаєте метод, що приймає декілька аргументів використовуючи операторну нотацію, ви маєте поклачти ці аргументи в дужках. Наприклад, ось як ви використовуєте цей інший <code>indexOf</code> як оператор (продовжуючи попередній приклад):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">indexOf</span> <span class="o">(</span><span class="sc">&#39;o&#39;</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="c1">// Scala invokes s.indexOf(&#39;o&#39;, 5)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="______4">Любий метод може бути оператором</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala оператори не є особливим мовним синтаксисом; любий метод може бути оператором. Що робить метод оператором, це те, як ви використовуєте його. Коли ви пишете <code>s.indexOf('o')</code>, <code>indexOf</code> не є оператором. Але коли ви пишете <code>s indexOf 'o'</code>, <code>indexOf</code> є оператором, оскільки ви використовуєте його в операторній нотації.</p></div>
<div class="paragraph"><p>Досі ви бачили приклади інфіксної операторної нотації, що означає, що викликаємий метод сидить між об'єктом і параметром (або параметрами), які ви бажаєте передати в метод, як в <code>7 + 2</code>. Scala також має дві інші операторні нотації: префіксну та постфіксну. В префіксній нотації ви кладете метод перед об'єктом, на якому ви викликаєте метод (наприклад, <code>-</code> в <code>-7</code>). В постфіксній нотації ви кладете метод після об'єкта (наприклад, <code>toLong</code> в <code>7 toLong</code>).</p></div>
<div class="paragraph"><p>Для контрасту до інфіксної нотації, де оператори мають два операнди, один зліва та інший зправа, префіксні та постфіксні оператори є унарними: вони приймають тільки один операнд. В префіксній нотації операнд іде зправа від операнда. Деякі приклади префіксних операторів є <code>-2.0</code>, <code>!found</code>, та <code>~0xFF</code>. Як і з інфіксними операторами, ці префіксні оператори є скороченнями до виклику методів. Однак в цьому випадку ім'я метода має <code>unary_</code> перед символом оператора. Наприклад, Scala буде трансформувати вираз <code>-2.0</code> в виклик метода <code>(2.0).unary_-</code>. Ви можете продемонструвати це собі, набравши виклик метода обоє, через операторну нотацію та явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="c1">// Scala invokes (2.0).unary_-</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mf">2.0</span><span class="o">).</span><span class="n">unary_-</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдині ідентифікатори, що можуть бути викортстані як префіксні оператори, є <code>\+</code>, <code>-</code>, <code>!</code>, та <code>~</code>. Таким чином, якщо ви визначите метод на ім'я <code>unary_!</code>, ви можете викликати цей метод на значенні або змінній відповідного типу, використавши префіксну операторну нотацію, таку як <code>!p</code>. Але якщо ви визначите метод <code>unary_*</code>, ви не будете в змозі використовувати префіксну операторну нотацію, бо <code>*</code> не є одним з чотирьох ідентифікаторів, що можуть використовуватись в префіксних операторах. Ви можете викликати метод звичайно, як <code>inp.unary_*</code>, але якщо ви спробуєте визвати його через <code>*p</code>, Scala буде розбирати його, якби ви записали <code>*.p</code>, що, можливо, не те, що ви мали на увазі!<span class="footnote"><br />[Однак не все втрачено. Існує вкрай слабкий шанс, що ваша програма з *p може компілюватись як C++.]<br /></span></p></div>
<div class="paragraph"><p>Постфіксні оператори є методи, що не приймають аргументів, коли вони викликаються без крапки та дужок. В Scala ви можете відкинути пусті дужки на виклику метода. Домовленість полягає в тому, що ви залишаєте дужки, якщо метод має побічні ефекти, як в println(), але ви можете не вживати їх, якщо метод не має побічних ефектів, як в <code>toLowerCase</code> викликане на <code>String</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">toLowerCase</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому останньому випадку метода, що не потребує аргументів, ви можете альтернативно відкинути крапку, і використовувати постфіксну операторну нотацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">toLowerCase</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку <code>toLowerCase</code> використовується як постфіксний оператор на операнді <code>s</code>.</p></div>
<div class="paragraph"><p>Таким чином, щоб побачити, які оператори ви можете використовувати з базовими типами Scala, все що вам дійсно треба зробити, це подивитись на методи, задекларовані в класах типу в документації Scala API. Зважаючи, що це Scala туторіал, однак, ми надамо вам швидкий тур по більшості з ціх методів в наступних декільках розділах.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java__2">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато аспектів Scala, описані в залишку цієї глави, такі ж самі, що і в Java. Якщо ви практикуючий Java гуру в розквиті, ви можете безпечно пропустити все до Розділу 5.8, що описує як Scala відрізняється від Java в сфері еквівалентності об'єктів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_5__">5.5 Арифметичні оператори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете викликати арифметичні методи через інфіксну операторну нотацію для додавання (+), віднімання (-), множення (*), ділення (/), та залишку (%) на любих числових типах. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">+</span> <span class="mf">2.3</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;b&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2L</span> <span class="o">*</span> <span class="mi">3L</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">4</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">11</span> <span class="o">%</span> <span class="mi">4</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">11.0f</span> <span class="o">/</span> <span class="mf">4.0f</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">2.75</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">11.0</span> <span class="o">%</span> <span class="mf">4.0</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли обоє, лівий та правий операнди є інтегральними типами (<code>Int</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code>), оператор <code>/</code> буде казати вам цілу частину від ділення, без залишку. Оператор <code>%</code> вказує залишок від цілого ділення.</p></div>
<div class="paragraph"><p>Залишок з плаваючою крапкою, що ви отримаєте за допомогою <code>%</code> не є тим, що визначений в стандарті IEEE 754. Залишок IEEE 754 використовує округлююче ділення, не відсікаюче ділення, при обчисленні залишка, так що повністю інше від операції цілого залишку. Якщо ви дійсно бажаєте залишок IEEE 754, ви можете викликати <code>IEEEremainder</code> зі <code>scala.math</code>, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="nc">IEEEremainder</span><span class="o">(</span><span class="mf">11.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Числові типи також пропонують унарний префіксний оператор <code>+</code> (метод <code>unary_+</code>) та <code>-</code> (метод <code>unary_-</code>), що дає вам вказати, чи є літеральне число позитивним або негативним (додатним або від'ємним), як в <code>-3</code> або <code>+4.0</code>. Якщо ви не вказуєте унарний <code>+</code> або <code>-</code>, літеральне число розглядається як позитивне. Унарний <code>+</code> існує виключно для симетрії з <code>-</code>, але не має ефекту. Унарний <code>-</code> може також використовуватись для обернення змінної. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">neg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="mi">3</span>
<span class="n">neg</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="o">+</span><span class="mi">3</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">neg</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_6____">5.6 Відносні та логічні операції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете порівняти числові типи за допомогою відносних методів: більше ніж (&gt;), менше ніж (&lt;), більше або рівне (&gt;=), менше або рівне (&#8656;), що дають результат типу Boolean. На додаток ви можете використати унарний оператор <code>!</code> (метод <code>unary_!</code>), щоб інвертувати значення Boolean. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">3.5f</span> <span class="o">&gt;=</span> <span class="mf">3.6f</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">untrue</span> <span class="k">=</span> <span class="o">!</span><span class="kc">true</span>
<span class="n">untrue</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Логічні методи, ТА (<code>&amp;&amp;</code> та <code>&amp;</code>), АБО (<code>||</code> та <code>|</code>), приймають <code>Boolean</code> операнди в інфіксній нотації, та видають Boolean результат. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">toBe</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">toBe</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">question</span> <span class="k">=</span> <span class="n">toBe</span> <span class="o">||</span> <span class="o">!</span><span class="n">toBe</span>
<span class="n">question</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">paradox</span> <span class="k">=</span> <span class="n">toBe</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">toBe</span>
<span class="n">paradox</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Операції <code>&amp;&amp;</code> та <code>||</code> короткого обчислення, як в Java: вирази, побудовані з ціх операторів, обчислюються так далеко, як треба для визначення результату. Іншими словами, права частина виразів <code>&amp;&amp;</code> та <code>||</code> не буде обчислюватись, якщо ліва визначає результат. Наприклад, як ліва сторона виразу ТА буде обчислена як <code>false</code>, результат виразу буде обчислений як <code>false</code>, так що права частина не буде обчислена. Подібно,якщо ліва частина виразу АБО обчисляється до <code>true</code>, результат виразу буде однозначно <code>true</code>, так що права сторона не буде обчислюватись.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">salt</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;salt&quot;</span><span class="o">);</span> <span class="kc">false</span> <span class="o">}</span>
<span class="n">salt</span><span class="k">:</span> <span class="o">()</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">pepper</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pepper&quot;</span><span class="o">);</span> <span class="kc">true</span> <span class="o">}</span>
<span class="n">pepper</span><span class="k">:</span> <span class="o">()</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">pepper</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">salt</span><span class="o">()</span>
<span class="n">pepper</span>
<span class="n">salt</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">salt</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pepper</span><span class="o">()</span>
<span class="n">salt</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому виразі викликаються <code>pepper</code> та <code>salt</code>, але в другому викликається тільки <code>salt</code>. Припускаючи, що <code>salt</code> повертає <code>false</code>, немає потреби викликати <code>pepper</code>. Якщо ви бажаєте обчислити праву сторону в любому випадку, використовуйте оператори <code>&amp;</code> та <code>|</code>. Метод <code>&amp;</code> виконує логічне ТА, <code>|</code> логічне АБО, але не скорочено, як <code>&amp;&amp;</code> та <code>||</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">salt</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">pepper</span><span class="o">()</span>
<span class="n">salt</span>
<span class="n">pepper</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">falseNote</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете зацікавитись, як може працювати, якщо оператори всього лише методи. Звичайно всі аргументи обчислюються перед входом в метод, так що як метод уникає обчислення свого второго аргумента? Відповідь полягає в тому, що всі методи Scala мають можливість відкладати обчислення своїх аргументів, або навіть відмовлятись обчислювати їх взагалі. Можливість називається параметри за-ім'ям, та обговорюється в Розділі 9.5.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_7__">5.7 Побітові операції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala дозволяє вам виконувати операції з окремими бітами цілих типів за допомогою декількох побітових методів. Оператори настіпні: побітне ТА (&amp;), побітне АБО (|), побітне XOR (!АБО) (^).<span class="footnote"><br />[ Метод побітне XOR виконує ексклюзивне АБО на операторах. Ідентичні біти дають 0. Різні біти дають 1. Таким чином, 0011 ^ 0101 дає 0110.]<br /></span>Унарний побітовий оператор (<code>~</code>, метод <code>unary_~</code>) інвертує кожний біт свого операнда. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">^</span> <span class="mi">3</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">1</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший вираз, <code>1 &amp; 2</code>, побітно перевіряє біти в 1 (0001) та 2 (0010), що дає 0 (0000). Другий вираз, <code>1 | 2</code>, побітно складає біти тих же операндів, даючи 3 (0011). Третій вираз, <code>1 ^ 3</code>, побітно виконує   xor для 1 (0001) та 3 (0011), даючи 2 (0010). Заключний вираз, <code>~1</code>, інвертує кожний біт в 1 (0001), даючи -2, що в бінарній формі виглядає як 11111111111111111111111111111110.</p></div>
<div class="paragraph"><p>Цілі типи Scala також пропонують три методи зсуву: зсув вліво (&lt;&lt;), зсув вправо (&gt;&gt;), та беззнаковий зсув вправо (&gt;&gt;&gt;). Методи зсува, коли використовуються в інфіксній операторні нотації, зсувають ціле значення лівого операнда на кількість біт, заданих правим оператором. Зсув вправо та беззнаковий зсув вліво заповнюють нові біти нулями. Зсув вправо заповнює ліві біти знаковим (старшим) бітом. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">31</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>-1 в двійниковій системі є 11111111111111111111111111111111. В першому прикладі, -1 &gt;&gt; 31, -1 зсувається вправо на 31 позицій. Оскільки <code>Int</code> складається з 32 біт, ця операція ефективно рухає самий лівий біт, доки він не стане самий правий.<span class="footnote"><br />[Самий лівий біт цілого типу є бітом знаку. Якщо самий лівий біт 1, число від'ємне. Якщо 0 число додатнє.]<br /></span> Наш метод &gt;&gt; заповнює одиницями при зсуві вправо, оскільки лівий біт -1 є 1, результат ідентичний до оригіналу лівого операну, 32 біти одиниць, або -1. В другому прикладі -1 &gt;&gt;&gt; 31, самий лівий біт знову зсувається в саму праву позицію, але на цей раз заповнюється нулями. Результат на цей раз буде двоїчне 00000000000000000000000000000001, або 1. В фінальному прикладі, 1 &lt;&lt; 2, лівий операнд, 1, зсувається вліво на ді позиції, даючи бінарне 00000000000000000000000000000100, або 4.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_8___">5.8 Еквівалентність об'єктів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви бажаєте порівняти два об'єкти на еквівалентність, ви можете використовувати або <code>==</code> або його інверсію <code>!=</code>. Ось декілька простих прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">2</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці операції насправді застосовуються для всіх об'єктів, не тільки для базових типів. Так що ви можете, наприклад, застосувати <code>==</code> для порівняння списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ідучи далі, ви можете порівняти два об'єкта, що мають різні типи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви навіть можете порівняти з <code>null</code>, або з чимось, що може бути <code>null</code>. Виключення не спрацює:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span>
<span class="n">res38</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="kc">null</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите, <code>==</code> було майстерно зроблене, так що ви отримаєте в більшості випадків тілкьи ту еквівалентність, яку побажаєте. Це досягається дуже простим правилом: спочатку перевіряється ліва сторона щодо <code>null</code>. Якщо це не <code>null</code>, викликається метод <code>equals</code>. Оскільки <code>equals</code> є методом, точне порівняння, що ви отримаєте, залежить від типу лівого аргументу. Оскільки перевірка на <code>null</code> автоматична, ви не повинні перевіряти самостійно.<span class="footnote"><br />[Автоматична перевірка не дивиться на праву частину, але любий адекватний метод <code>equals</code> повинен повертати <code>false</code>, якщо аргумент є <code>null</code>.]<br /></span>Цей різновид порівняння видасть <code>true</code> на різних об'єктах, доки їх вміст той самий, та їх методи <code>equals</code> написані на основі їх вмісту. Наприклад, ось порівняння між двома рядками, що мають ті самі п'ять літер:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="s">&quot;he&quot;</span> <span class="o">+</span> <span class="s">&quot;llo&quot;</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___scala___java">Як == в Scala відрізняється від Java</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Java ви можете використовувати <code>==</code> для порівняння обох, примітивних та типів посилань. На примітивних типах Java <code>==</code> перевіряє еквівалентінсть значень, як в Scala. На типах посилань, однак, Java <code>==</code> порівнює еквівалентність посилань, що означає, що дві змінні посилаються на той самий об'єкт в купі JVM. Scala також провадить здатність порівняти еквівалентність посилань, під ім'ям <code>eq</code>. Однак <code>eq</code> та його протилежність, <code>ne</code>, застосовується тільки для об'єктів. що напряму відзеркалюються на Java об'єкти. Повні деталі щодо <code>eq</code> та <code>ne</code> надаються в Розділі 11.1 та 11.2. Також дивіться Главу 30 щодо того, як писати гарний метод <code>equals</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_9____">5.9 Преоритети та асоціативність операторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Преоритет операторів визначає, яка частина виразу обчислюється перед іншими частинами. Наприклад, вираз <code>2 + 2 * 7</code> обчислюється до <code>16</code>, не <code>28</code>, оскільки оператор <code>*</code> має вищий преоритет, ніж оператор <code>+</code>. Таким чином, частина множення обчислюється перед частиною додавання. Ви можете, звичайно, використати дужки для прояснення порядку обчислення, або щоб перекрити преоритети. Наприклад, якщо ви дійсно бажаєте отримати результат виразу вище 28, ви можете записати вираз таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">*</span> <span class="mi">7</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги, що Scala не має операторів як таких, а тільки спосіб використовувати методи в операторній нотації, ви можете здивуватись, як роблять преоритети операцій. Scala визначає преоритет базуючись на першому символі методів, використаних в операторній нотації (є одне виключення з цього правила, що буде продискутоване на наступних сторінках). Якщо ім'я метода починається з <code>*</code>, наприклад, він буде мати вищий преоритет, ніж метод, що починається з <code>+</code>. Таким чином, <code>2 + 2 * 7</code> буде еквівалентне до <code>2 + (2 * 7)</code>. Подібно, <code>a  b *** c` (в якому `a`, `b`, та 'c' є змінні, а `</code> та <code>***</code> є методи) буде обчислене як <code>a  (b *** c)`, оскікльки метод `***` має вищий преоритет, ніж метод `</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.3: Преоритети операцій</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі спеціальні символи)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">* / %</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">+ -</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">:</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">= !</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">&lt;</p></td>
<td align="right" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">&amp;</p></td>
<td align="center" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">|</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі літери)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі оператори присвоєння)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Таблиця 5.3 показує преоритети, надані першим літерам метода в порярдку зменшення преоритету, де символи на одному рядку мають один преоритет. Чим вище символ в цій таблиці, тим вищий преоритет методів, що починаються з цього символа. Ось приклад, що ілюструє вплив преоритетів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">32</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>&lt;&lt;</code> починається з символа <code>&lt;</code>, що стоїть нижче в Таблиці 5.3, ніж символ <code>+</code>, що є першим та єдиним символом метода <code>+</code>. Таким чином, <code>&lt;&lt;</code> буде мати нижчий преоритет, ніж <code>+</code>, і вираз буде обчислений починаючи з метода <code>+</code>, потім метода <code>&lt;&lt;</code>, як в <code>2 &lt;&lt; (2 + 2)</code>. <code>2 + 2</code> є <code>4</code>, за нашими підрахунками, та <code>2 &lt;&lt; 4</code> дає <code>32</code>. Якщо ми поміняємо оператори, ви отримаєте інший результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">16</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки перші символи такі самі, що в попередньому прикладі, методи будуть викликані в тому самому порядку. Спочатку буде викликаний метод <code>+</code>, потім метод <code>&lt;&lt;</code>. Так що <code>2 + 2</code> знову дасть 4, та <code>4 &lt;&lt; 2</code> є <code>16</code>.</p></div>
<div class="paragraph"><p>Одне виключення з правила преоритетів, до якого ми посилались раніше, стосується  операторів присвоєння, що завершуються на знак рівності. Якщо оператор закінчується на знак рівності(=), і це не один з операторів порівняння: <code>&gt;=</code>, <code>==</code>, або <code>!=</code>, тоді преоритет оператора такий самий, як в простого присвоєння (=). Тобто, він меньший ніж преоритет любого іншого оператора. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">*=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>значить те саме, що і:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">*=</span> <span class="o">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>оскільки <code>*=</code> класифікується як оператор присвоєння, чий преоритет нижчий, ніж <code>+</code>, навіть незважаючи, що перший символ оператора <code>*</code>, що мало б підказувати преоритет, вищий за <code>+</code>.</p></div>
<div class="paragraph"><p>Коли декілька операторів з однаковим преоритеттом стоять поряд в виразі, асоциативність операторів визначає групування. Асоциативність операторів в Scala визначається останнімсимволом. Як зазначалось в Главі 3, любий метод, що завершується на симол <code>:</code> викликається не своєму правому операнді. Методи, що завершуються на любий інший символ, роблять навпаки: вони викликаються на своєму лівому операнді, передаючи правий операнд.</p></div>
<div class="paragraph"><p>Так що <code>a * b</code> дає <code>a.*(b)</code>, але <code>a:::b</code> дає <code>b.:::(a)</code>.</p></div>
<div class="paragraph"><p>Оданк неважливо, яку асоциативніть має оператор, його операнди завжди використовуються зліва направо. Так що якщо <code>a</code> є виразом, що не тільки просте посилання на незмінне значення, тоді <code>a:::b</code> більш точно трактується як в наступному блоці:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">{</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">a</span><span class="o">;</span> <span class="n">b</span><span class="o">.:::(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому блоці <code>a</code> все одне обчислюється раніше за <code>b</code>, та потім результат передається до метода <code>b.:::</code>.</p></div>
<div class="paragraph"><p>Це правило асоціативності також відіграє роль, коли декілька оператоорів з однаковим преоритетом стоять поряд. Якщо метод завершується на <code>:</code>, вони групуються зліва направо. Наприклад, <code>a:::b:::c</code> трактується як <code>a:::(b:::c)</code>. Але <code>a * b * c</code>, для контрасту, трактується як <code>(a * b) * c</code>. Преоритетність операторів я частиною мови Scala. Вам не треба лякатись використовувати її. Тим не менш, є гарним стилем використовувати дужки для прояснення, які операції ідуть за якими в виразі. Можливо, єдині преоритети, на які ви можете дійсно розраховувати, що інші програмісти мають знати без підглядання, це мультиплікативні оператори: <code>*</code>, <code>/</code>, та <code>%</code>, мають преоритет над аддитивними, <code>+</code> та <code>-</code>. Так що навіть якщо <code>a + b &lt;&lt; c</code> дає бажаний вами результат без дужок, додаткова ясність, яку дасть запис <code>(a + b) &lt;&lt; c</code>, може зменшити частоту, з якою ваш колега буде використовувати ваше ім'я в операторній нотації, наприклад, вигукуючи в розпачі "<code>bills !*&amp;\^%~ code!</code>".<span class="footnote"><br />[Тепер в маєте бути в змозі зрозуміти, що маючи цей код, компілятор Scala буде викликати (bills.!*&amp;\^%~(code)).!().]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_10__">5.10 Багаті огортки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете викликати значно більше методів на базових типах Scala, ніж показано в Таблиці 5.4. Ці методи доступні через неявні перетворення, прийом, що буде описаний в деталях в Главі 21. Все що вам покі що треба знати, це що для кожного базового типу, описаного в цій главі, також існує "багата огортка", що провадить декілька додаткових методів. Таким чином, щоб подивитись всі доступні методи для базового типу, вам слід дивитись документацію API по багатій огортці для базового типу. Ці класи перелічені в Таблиці 5.5.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.4: Деякі багаті операції</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Код </th>
<th align="center" valign="top"> Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="n">max</span> <span class="mi">5</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">5</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="n">min</span> <span class="mi">5</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mf">2.7</span> <span class="n">abs</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">2.7</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mf">2.7</span> <span class="n">round</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">-3L</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mf">1.5</span> <span class="n">isInfinity</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">0</span><span class="o">)</span> <span class="n">isInfinity</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">true</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="n">to</span> <span class="mi">6</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Range(4, 5, 6)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;bob&quot;</span> <span class="n">capitalize</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">"Bob"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;robert&quot;</span> <span class="n">drop</span> <span class="mi">2</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">"bert"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.5: Багаті типи огортки</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Багата огортка</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichByte</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichShort</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichInt</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichLong</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichChar</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichFloat</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichDouble</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichBoolean</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="center" valign="top"><p class="table">scala.collection.immutable.StringOps</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_11_">5.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Головний висновок з цієї глави в тому, що операції в Scala є викликами методів, та що для базових типів Scala існують неявні перетворення до збагачених типів, що додають це більше корисних методів. В наступній главі ми покажемо, що це значить розробляти об'єкти в функціональному стилі, що дає нові реалізації операторів, які ви бачили в цій главі.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__6_2">Глава 6</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____2">Функціональні об'єкти</h1>
<div class="paragraph"><p>З розумінням основ Scala, яке ви отримали від попередніх глав, ви готові до розробки більш наповнених можливістями класів в Scala. В цій главі ми зробимо наголос не класах, що визначають функціональні об'єкти, або об'єкти, що не мають жодного змінного стану. В якості роблячого прикладу, ми створимо декілька варіантів класу, що моделює раціональні числа як незмінні об'єкти. По ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного програмування в Scala: параметри класів та конструктори, методи та оператори, приватні члени, перекриття, перевірку передумов, перевантаження та посилання на себе.</p></div>
<div class="sect1">
<h2 id="_6_1___rational">6.1 Специфікація класа Rational</h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Раціональне число</em> є таке, що може бути виражене як відношеня <code>n/d</code>, де <code>n</code> та <code>d</code> є цілі, за винятком того, що <code>d</code> не може бути нулем. <code>n</code> називається чисельником, та <code>d</code> знаменником. Приклади раціональних чисел є 1/2, 2/3, 112/239, та 2/1. Порівняно з числами з плаваючою крапкою, раціональні числа мають перевагу в тому, що дробі представлені точно, без округлення або апроксимації.</p></div>
<div class="paragraph"><p>Клас, який ми будемо розробляти в цей главі, має моделювати поведінку раціональних чисел, включаючи можливіть додавати їх, віднімати, множити та ділити. Щоб додати двоє раціональних числа, вам треба зпочатку отримати загальний знаменник, потім додати два чисельника. Наприклад, щоб додати <code>1/2 + 2/3</code>, ви множите обі частини лівого операнда на 3, та обі частини правого операнда на 2, що дає вам <code>3/6 + 4/6</code>. Додавання двох чисельників дає вам результат, <code>7/6</code>. Щоб помножити два раціональні числа, ви просто множите їх чисельники, та множите їх займенники. Таким чином, <code>1/2 * 2/5</code> дає <code>2/10</code>, що може бути представлено більш компактно в "нормалізованій" формі як <code>1/5</code>. Ви ділите обмінюючи чисельник та займенник правого операнда, та потім виконуєте множення. Наприклад, <code>1/2 / 3/5</code> є те саме, що <code>1/2 * 5/3</code>, або <code>5/6</code>.</p></div>
<div class="paragraph"><p>Одне, можливо тривіальне, спостереження полягає в тому, що раціональні числа не мають змінного стану. Ви можете дадати одне раціональне до іншого, але результат буде новим раціональним числом. Оригінальні числа не будуть "змінені". Незмінний клас <code>Rational</code>, що ми будемо розробляти в цій главі, буде мати ту саму властивість. Кожне раціональне число буде представлене одним об'єктом <code>Rational</code>. Коли ми додаємо два об'єкти <code>Rational</code>, ви будете створювати новий об'єкт <code>Rational</code> щоб утримувати суму. Ця глава надасть вам  побіжне враження, як Scala дозволяє вам писати бібліотеки, що відчуваються як природна підтримка мови. Наприклад, в кінці цієї глави ви будете в змозі зробити це з класом <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoThirds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">twoThirds</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">oneHalf</span> <span class="o">/</span> <span class="mi">7</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">twoThirds</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">17</span><span class="o">/</span><span class="mi">42</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_2__rational">6.2 Конструювання Rational</h2>
<div class="sectionbody">
<div class="paragraph"><p>Гарне місце почати розробку класа <code>Rational</code> є вирішити, як програмісти клієнти будуть створювати новий об'єкт <code>Rational</code>. Зважаючи, що ми приняли рішення зробити об'єкти <code>Rational</code> незмінними, ми потребуємо, щоб клієнти надали всі дані, що треба для примірника (в цьому випадку чисельник та займенник), коли вони конструюють примірник. Таким чином, ми почнемо розробку з такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з перших речей, що треба зауважити щодо цього рядка кода, це те, що якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча ви можете, звичайно, якщо бажаєте). Ідентифікатори <code>n</code> та <code>d</code> в дужках після імені класу <code>Rational</code>, називаються параметрами класу. Компілятор Scala збере докупи ці параметри класу, та створить первинний конструктор, що матиме саме два параметри.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_____7">Компроміс незмінних об'єктів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Незмінні об'єкти пропонують декілька переваг над змінним об'єктами, та один потенційний недолік. Перше, незмінні об'єкти часто простіше продумуються, ніж змінні, бо вони не мають складних просторів стану, що змінюються з часом. Друге, ви можете передавати незмінні об'екти довкола досить вільно, тоді як вам може знадобитись робити захисні копії змінних об'єктів, перед тим, як передаватий їх в інший код. Третє, немає способу для двох потоків, що одночасно отримують доступ до незмінного об'єкту, пошкодити його стан, коли він вже відповідно створений, бо потік взагалі не може змінити стан незмінного. Четверте, незмінні об'єкти роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт зміниться після того, як він покладений, наприклад, в <code>HashSet</code>, цей об'єкт може бути не знайдений наступний раз, коли ви шукаєте в <code>HashSet</code>.</p></div>
<div class="paragraph"><p>Головний недолік незмінних об'єктів в тому, що вони іноді потребують копіювання великого об'єктного графа, тоді як оновлення може бути зроблене на місці. В деяких випадках це може бути незручно виразити, і також може стати вузьким місцем продуктивності. Як результат, не нє рідкістю для бібліотек провадити змінні альтернативи до незмінних класів. Наприклад, клас <code>StringBuilder</code> є змінною альтернативою до незмінного  <code>String</code>. Ми надамо вам більше інформації щодо розробки змінних класів в Scala в Главі 18.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Цей початковий приклад <code>Rational</code> підкреслює різницю між Java та Scala. В Java класи мають конструктори, що можуть приймати параметри; тоді як в Scala класи самі можуть приймати параметри. Нотація Scala більше стисла — параметри класу можуть бути використані напряму в тілі класу; немає потреби визначати поля та писати присвоєння, що копіюють параметри конструктора в поля. Це може дати значну економію в шаблонному коді, особливо для малих класів.</td>
</tr></table>
</div>
<div class="paragraph"><p>Компілятор Scala буде компілювати любий код, який ви покладете в тіло класа, що не є частиною поля або визначення метода, в первинний конструктор. Наприклад, ви можете надрукувати повідомлення зневадження таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Created &quot;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи цей код, компілятор Scala покладе виклик до <code>println</code> в первинний конструктор <code>Rational</code>. Таким чином, виклик <code>println</code> буде друкувати своє повідолениня зпевадження, коли ви будете створювати новий примірник <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="nc">Created</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="nc">Rational</span><span class="k">@</span><span class="mi">2591</span><span class="n">e0c9</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_3___tostring">6.3 Реалізація метода toString</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли ви створили примірник <code>Rational</code> в попередньому прикладі, інтерпретатор надрукував <code>Rational@90110a</code>. Інтерпретатор отримав цей, дещо дивно вигладаючий, рядок викликаючи <code>toString</code> на об'єкті <code>Rational</code>. По замовченню клас <code>Rational</code> наслідує реалізацію <code>toString</code>, визначену в класі <code>java.lang.Object</code>, що просто друкує ім'я класу, символ <code>@</code>, та шістнадцятирічне число. Метод <code>toString</code> початково призначений для допомоги програмістам, провадячи інформацію, що може використовуватись для друкування повідомлень зневадження, журналювання повідомлень, звітів про збій тестів, та виводу інтерпретатора та знаваджувача. Результат, що наразі провадиться <code>toString</code>, не особливо корисний, бо він не надає жодного натяку щодо значення раціонального числа. Більш корисна реалізація <code>toString</code> може друкувати значення чисельника та займенника Rational. Ви можете <em>перекрити</em> реалізацію по замовчанню, через додавання метода <code>toString</code> до класу <code>Rational</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>override</code> попереду визначення метода сигналить, що попереднє визначення перекривається (більше про це в Главі 10). Оскільки числа <code>Rational</code> тепер будуть гарно відображатись, ми видалили твердження  <code>println</code>, що ми поклали в тіло попередньої версії класа <code>Rational</code>. Ви можете протестувати нову поведінку  <code>Rational</code> в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">7</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_4__">6.4 Перевірка передумов</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми звернемо нашу увагу на проблему з поточною поведінкою первинного конструктора. Як зазначалось на початку цієї глави, раціональні числа не можуть мати нуль в якості займенника. Однак зараз первинний конструктор приймає нуль, переданий для <code>d</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з переваг об'єктно-орієнтовного програмування є те, що воно дозволяє вам інкапсулювати дані в об'єкті, так що ви можете бути впевнені, що дані валідні на протязі його життя. В випадку незмінних об'єктів, таких як <code>Rational</code>, це означає, що вам треба переконатись, що дані валідні при конструюванні об'єкта. Зважаючи, що нульовий займенник є невілідним станом для числа Rational, вам не слідує дозволити конструювання  <code>Rational</code>, якщо нуль передається в параметрі <code>d</code>.</p></div>
<div class="paragraph"><p>Кращий шлях підійти до цієї проблеми є визначити передумову в первинному конструкторі, що <code>d</code> не має бути нулем. Передумова є обмеження на значення, передані в метод або конструктор, вимога, якій має задовільняти вікликаюча сторона. Один спосіб зробити це є використанян <code>require</code>,<span class="footnote"><br />[Метод <code>require</code> визначений в окремому об'єкті <code>Predef</code>. Як зазначено в Главі 4.4, члени <code>Predef</code> імпортуються автоматично в кожний файл Scala.]<br /></span> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>require</code> приймає один логічний параметр. Якщо передане значення є <code>true</code>, <code>require</code> поверне керування звичайно. Інакше <code>require</code> буде запобігати створенню об'єкта, через виклик <code>IllegalArgumentException</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_5__">6.5 Додавання полів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли первинний конструктор відповідно перевіряє виконання передумови, ми звернемо нашу увагу на підтримку додавання. Щоб зробити це, ми визначимо публічний метод <code>add</code> на класі <code>Rational</code>, що приймає інше <code>Rational</code> як параметр. Щоб утримувати <code>Rational</code> незмінним, метод <code>add</code> не має додавати передане раціональне число до себе. Скоріше, він має створити та повернути нове <code>Rational</code>, що міститиме суму. Ви можете подумати, що можете написати <code>add</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Не буде компілюватись</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="o">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак, маючи цей код, компілятор буде скаржитись:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^</code></pre>
</div></div>
<div class="paragraph"><p>Хоча параметри класу <code>n</code> та <code>d</code> в полі зору коду вашого метода <code>add</code>, ви можете отримувати доступ до їх значень тільки для об'єкта, на якому був викликаний метод <code>add</code>. Таким чином, коли ви кажете <code>n</code> або <code>d</code> в реалізцаії <code>add</code>, компілятор буде щасливий провадити значення для ціх параметрів класу. Але він не дає вам казати <code>that.n</code> або <code>that.d</code>, оскільки це не посилається на об'єкт <code>Rational</code>, на якому був визваний <code>add</code>.<span class="footnote"><br />[Насправді, ви можете додати Rational до себе, в якому випадку це буде посилатись на об'єкт, на якому викликається <code>add</code>. Але оскільки ви можете передати любий об'єкт <code>Rational</code> до <code>add</code>, компілятор все ще не дає вам сказати <code>that.n</code>.]<br /></span> Щоб отримати чисельник та займенник на <code>that</code>, вам треба перетворити їх на поля. Лістинг 6.1 показує, як ви можете додати ці поля до класу <code>Rational</code>.<span class="footnote"><br />[В Розділі 10.6 ви прочитаєте щодо параметричних полів, що провадять скорочення для написання того самого кода.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">d</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.1 - Rational з полями.</p></div>
<div class="paragraph"><p>В версії <code>Rational</code>, показаній в Лістингу 6.1 ми дадали два поля на ім'я <code>numer</code> та <code>denom</code>, та ініціалізували їх значеннями параметрів класу, <code>n</code> та <code>d</code>.<span class="footnote"><br />[Навіть якщо <code>n</code> та <code>d</code> використовуються в тілі класу, виходячи з того, що вони використовуються тільки в конструкторах, компілятор Scala не буде створювати поля для них. Таким чином, маючи цей код компілятор Scala буде генерувати клас з двома полями <code>Int</code>, одне для <code>numer</code> та одне для <code>denom</code>.]<br /></span> Ми змінили реалізацію <code>toString</code> та <code>add</code>, так що вони використовують поля, а не параметри класу. Ця версія <code>Rational</code> компілюється. Ви можете протестувати її, додавши деякі раціональні числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoThirds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">twoThirds</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="n">add</span> <span class="n">twoThirds</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша річ, яку ви можете зробити тепер, але не могли раніше, є доступ до значень чисельника та займенника з поза меж об'єкта. Просто отримайте доступ до публічних полів <code>numer</code> та <code>denom</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">numer</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">denom</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_6___">6.6 Посилання на себе</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ключове слово <code>this</code> посилається на примірник об'єкту, на якому був визваний метод, який наразі виконується, або в випадку конструктора - примірник об'єкта, що створюється. Як приклад, розглянемо додавання метода  <code>lessThan</code>, що перевіряє, що дане Rational меньше ніж параметр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lessThan</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>this.numer</code> посилається на чисельник об'єкта, на якому викликане <code>lessThan</code>. Ви також можете облишити цей префікс, та записати тільки <code>numer</code>; дві нотифікації є еквівалентними. Як приклад того, що ви не можете робити без <code>this</code>, розглянемо додавання метода <code>max</code> до класу <code>Rational</code>, що повертає більше з даного раціонального та аргумента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">lessThan</span><span class="o">(</span><span class="n">that</span><span class="o">))</span> <span class="n">that</span> <span class="k">else</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут перше <code>this</code> є надлишковим. Ви можете відкинути його, та записати: <code>lessThan(that)</code>. Але друге <code>this</code> представляє результат метода, в випадку, коли перевірка поверне <code>false</code>; коли ми оминемо його, нам нічого не залишиться повертати!</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_7__">6.7 Додаткові конструктори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді вам треба декілька конструкторів класу. В Scala конструктори, крім первинного, називаються додатковими конструкторами. Наприклад, раціональне число з займенником 1 може бути записане більш лаконічно як один чисельник. Наприклад, замість <code>5/1</code>, ви можете записати лише 5. Таким чином, це було б гарно, якщо замість запису <code>Rational(5, 1)</code>, програмісти клієнти могли просто писати <code>new Rational(5)</code>. Це буде потребувати додавання додаткового конструктора до <code>Rational</code>, що приймає лише один аргумент, чисельник, з займенником передвизначеним як 1. Лістинг 6.2 показує, на що це може бути схоже.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">d</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// додатковий конструктор</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.2 - Rational з додатковим конструктором.</p></div>
<div class="paragraph"><p>Додаткові конструктори в Scala починаються з <code>def this(...)</code>. Тіло додаткового конструктора <code>Rational</code> просто викликає первинний конструктор, передаючи йому всій єдиний аргумент, <code>n</code>, як чисельник, та 1 як займенник. Ви можете бачити додатковий конструктор в дії, написавши таке в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala кожний зовнішінй конструктор має викликати інший конструктор того самого класу в якості першої дії. Іншими словами, перше твердження в кожному додатковому конструкторі кожного класа Scala буде мати форму <code>this(...)</code>. Викликаний конструктор є або первинним конструктором (як в прикладі <code>Rational</code>), або інший додатковий конструктор, що текстуально іде перед викликаючим конструктором. Нетто ефект з цього правила в тому, що кожний виклик конструктора в Scala згодом буде закінчувати викликом первинного конструктора класу. Первинний конструктор, таким чином, є єдиною точкою входу класу.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Якщо ви знакомі з Java, ви можете здивуватись, чому правила Scala для конструкторів трохи більш обмежуючі, ніж в Java. В Java конструктор в якості першой дії має або викликати інший конструктор того самого класу, або напряму викликати конструктор суперкласу. В класах Scala тільки первинний конструктор може викликати конструктор суперкласу. Збільшення обмеження в Scala насправді є компроміс дизайну, який треба заплатити за більшу стислість та простоту констуркторів Scala, порівняно з Java. Суперкласи та деталі, як взаємодіють виклики конструкторів та наслідування, пояснені в Главі 10.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_8____">6.8 Приватні поля та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередній версії <code>Rational</code> ми просто ініціалізували <code>numer</code> як <code>n</code> та <code>denom</code> як <code>d</code>. Як результат, чисельник та займенник <code>Rational</code> можуть бути більші, ніж треба. Наприклад, дріб <code>66/42</code> може бути нормалізована до екввалентної скороченої форми, <code>11/7</code>, але первинний конструктор <code>Rational</code> наразі не робить цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">66</span><span class="o">/</span><span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб нормалізувати число і такий спосіб, нам треба розділити чисельник та займенник на їх спільний дільник. Наприклад, найбільший дільник для <code>66</code> та <code>42</code> є <code>6</code>. (Іншими словами, 6 є більшим цілим, що рівно ділить обоє, 66 та 42.) Ділення обох, чисельника та займенника <code>66/42</code> на <code>6</code> дає скорочену форму, 11/7. Лістинг 6.3 показує спосіб, як зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
  <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.3 - Rational з приватним полем та методом.</p></div>
<div class="paragraph"><p>В цій версії Rational ми додали приватне поле <code>g</code>, та модифікували ініціалізатори для <code>numer</code> та <code>denom</code>. (Ініціалізатор є код, що ініціалізує змінну; наприклад, <code>n / g</code>, що ініціалізує <code>numer</code>.) Оскільки <code>g</code> є приватним, доступ до неї може відбуватись тільки з тіла класу, але не ззовні. Ми також додали приватний метод, <code>gcd</code>, що обчислює найбільший загальний дільник двох переданих <code>Int</code>. Наприклад, <code>gcd(12, 8)</code> є <code>4</code>. Як ви бачили в Розділі 4.1, щоб зробити поле або метод приватними, ви просто можете покласти ключове слово <code>private</code> перед його визначенням. Призначення приватного "допоміжного метода" <code>gcd</code> є виділити код, потрібний для якоїсь іншої частини класу, в цьому випадку первинному конструктору. Щоб переконатись, що <code>g</code> завжди додатнє, ми передаємо абсолютні значення <code>n</code> та <code>d</code>, що ми отримали через виклик на них метода <code>abs</code>, метод, що ви можете викликати на кожному <code>Int</code> щоб отримати його абсолютне значення.</p></div>
<div class="paragraph"><p>Компілятор Scala буде покладати код для ініціалізаторів трьох полів <code>Rational</code> в первинний конструктор, в порядку як вони з'являються в джерельному коді. Таким чином, ініціалізатор <code>g</code>, <code>gcd(n.abs, d.abs)</code>, буде виконуватись перед іншими двома, оскільки він іде першим в тексті. Поле <code>g</code> буде ініціалізоване результатом, найбільшим загальним дільником абсолютних значень параметрів класу, <code>n</code> та <code>d</code>. Поле <code>g</code> потім використовується в ініціалізаторах <code>numer</code> та <code>denom</code>. Після ділення <code>n</code> та <code>d</code> на їх найбільший загальний дільник, <code>g</code>, кожний <code>Rational</code> буде сконструйований в його нармалізованій формі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">11</span><span class="o">/</span><span class="mi">7</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_9__">6.9 Визначення операцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поточна реалізація додавання <code>Rational</code> є OK, але може бути зроблене зручнішим в роботі. Ви можете спитати себе, чому ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>якщо <code>x</code> та <code>y</code> є цілі або з плаваючою крапкою, але ви маєте писати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або щонайменше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="n">add</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>якщо вони раціональні числа. Немає переконливої причини, чому має бути саме так. Раціональні числа є числами, як любі інші числа. В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з плаваючою крапкою.</p></div>
<div class="paragraph"><p>Чому ми не повинні використовувати природні арифметичні оператори для них? В Scala ви можете робити це. В залишку глави ми покажемо вам як.</p></div>
<div class="paragraph"><p>Перший крок є замінити <code>add</code> на звичайний математичний символ. Це прямолінійне, бо <code>+</code> є легальним ідентифікатором в Scala. Ми можемо просто визначили метод з <code>+</code> в якості імені. Поки ми вже в цьому, ми можемо також реалізувати метод на ім'я <code>*</code>, що виконує множення. Результат показаний в Лістингу 6.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">gdef</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.4 - Rational з операторними методами.</p></div>
<div class="paragraph"><p>Коли клас <code>Rational</code> визначений в цей спосіб, тепер ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Як завжди, операторний синтаксис в останньому рядку еквівалентний до викликуу метода. Ви можете також записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.+(</span><span class="n">y</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>але це не читабельне.</p></div>
<div class="paragraph"><p>Інша річ, що треба зауважити, є приймаючи до уваги правила Scala для преоритетів операторів, описані в Розділі 5.9, метод <code>*</code> буде притулятись більш тісно, ніж метод <code>+</code> для <code>Rationals</code>. Іншими словами, вираз, що включає операції <code>+</code> та <code>*</code> на <code>Rationals</code> буде поводитись як очікується. Наприклад, <code>x + x * y</code> буде виконуватись як <code>x + (x * y)</code>, не <code>(x + x) * y</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">66.10</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___scala_2">Ідентифікатори в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили два найбільш важливі способи сформувати ідентифікатор в Scala: алфавітно-цифрові та оператори. Scala має дуже гнучки правила для формування ідентифікаторів. Кірм двох форм ви також бачили тут дві інші. Всі чотири форми створенні ідентифікатоірв описані і цьому розділі. Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення, за яким можуть далі слідувати літери, цифри або підкреслення. Символ <code>$</code> також рахується як літера; однак, вона зарезервована для ідентифікатором, згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах по повинні містити символи <code>$</code>, навіть якщо це і буде компілюватись; якщо вони будуть, це може призвести до стикання імен з ідентифікаторами, згенерованих компілятором Scala.</p></div>
<div class="paragraph"><p>Scala слідує домовленості Java використання кемел-кейсу в ідентифікаторах,<span class="footnote"><br />[Цей стиль іменування ідентифікаторів названий кемел-кейс (верблюжий реєстр), оскільки ідентифікатори HaveHumps мають вбудовані великі літери.]<br /></span> такі як <code>toString</code> та <code>HashSet</code>. Хоча підкреслення є легальні в ідентифікаторах, вони не використовуються так часто в Scala програмах, частково щоб бути узгодженою з Java, але також оскільки підкреслення мають багато інших не-ідентифікаторних використань в Scala коді. Як результат, накраще уникати ідентифікаторів, як <code>to_string</code>, <code>__init__</code>, або <code>name_</code>.</p></div>
<div class="paragraph"><p>Кемел-кейс імена полів, параметрів методів, локальних змінних та функцій повинні починатись з літери в нижньому реєстрі, наприклад: <code>length</code>, <code>flatMap</code> та <code>s</code>. Кемел-кейс імена класів та трейтів повинні починатись з літери в верхньому реєстрі, наприклад: <code>BigInt</code>, <code>List</code> та <code>UnbalancedTreeMap</code>.<span class="footnote"><br />[В Розділі 16.5 ви побачите, що іноді ви бажаєте надати спеціальному типу класу, відомому як кейс клас, ім'я, що повністю складається з символів операторів. Наприклад, Scala API має клас на ім'я <code>::</code>, що спрощує співпадіння шаблонів для List.]<br /></span></p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Один наслідок з використання заключного підкреслення в ідентифікаторі є в тому, що якщо ви спробуєте, наприклад, написати декларацію, як цю: <code>val name_: Int = 1</code>, ви отримаєте помилку компілятора. Компілятор буде думати, що ви намагаєтесь декларувати <code>val</code> на ім'я <code>name_:</code>. Щоб змісити це компілюватись, вам треба вставити додатковий проміжок перед двокрапкою, як тут: <code>val name_ : Int = 1</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Один шлях, в який домовленості Scala відходять від Java включають імена констант. В Scala слово <code>constant</code> означає на просто <code>val</code>. Навіть якщо <code>val</code> має залишатись сталою після ініціалізації, це все ще змінна. Наприклад, параметри методів є <code>vals</code>, але кожний раз, коли визивається метод, ці <code>val</code> може містити різні значення. <code>constant</code> більш стійкі. Наприклад, <code>scala.math.Pi</code> визначена щоб бути значенням подвійної точності, найближчим до дійсного значення <code>π</code>, відношення довжини кола до його диаметру. Це значення навряд чи зміниться будь-коли; таким чином, <code>Pi</code> явно є константою. Ви можете також використовувати константи для надання імен значенням, що інакше були б магічними числами в коді: літеральні значення без пояснення, що в гіршому випадку з'являються в декількох місцях. Ви можете також побажати визначити константи для використання в співпадінні шаблонів, приклади використання яких описані в Розділі 15.2. В Java домовленість полягає в використанні імен констант з великих літер, з підкресленнями в якості роздільнииків слів, таких як <code>MAX_VALUE</code> або <code>PI</code>. В Scala домовленість просто така, щоб перша літера була великою. Таким чином, константи, названі в стилі Java, такі як <code>X_OFFSET</code>, будуть робити як Scala константи, але домовленість Scala використовувати кемел-кейс для констант, такі як <code>XOffset</code>.</p></div>
<div class="paragraph"><p>Операторний ідентифікатор складається з одного або більше операторних символів. Операторні символи є друковані ASCII символи, такі як <code>+</code>, <code>:</code>, <code>?</code>, <code>~</code> або <code>#</code>.<span class="footnote"><br />[Більш точно, операторний символ належить до множини Unicode математичних символів (Sm) або інших символів (So), або до 7-бітних ASCII символів, що не є літерами, цифрами, дужками, прямокутними дужками, фігурними дужками, поодинокими та подвійними лапками, або підкресленням, крапкою, крапкою з комою, комою, або апострофом.]<br /></span> Ось деякі приклади операторних ідентифікаторів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">+</span>
<span class="o">++</span>
<span class="o">:::</span> <span class="o">&lt;?&gt;</span>
<span class="o">:-&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор Scala буде всредині "колдувати" з операторними ідентифікаторами, щоб перетворити їх на легальні  Java ідентифікатори з вбудованими символами <code>$</code>. Наприклад, ідентифкатор <code>:-&gt;</code> внутрішньо буде представлений як <code>$colon$minus$greater</code>. Якщо ви колись побажаєте отримати доступ до цього ідентифікатора з Java кода, вам знадобиться використовувати цю внутрішню репрезентацію.</p></div>
<div class="paragraph"><p>Оскільки операторні ідентифікатори в Scala можуть стати довільно довгі, існує мала різниця між Java та Scala. В Java ввод <code>x&lt;-y</code> буде розібране як чотири лексичні символі, так що це буде еквівалентне до <code>x &lt; - y</code>. В Scala <code>&lt;-</code> буде розібране як єдиний ідентифікатор, даючи <code>x &lt;- y</code>. Якщо ви бажаєте першу інтерпретацію, вам треба відокремити символи <code>&lt;</code> та <code>-</code> проміжками. Це навряд чи буде проблемою на практиці, бо дуже мало людей пишуть <code>x&lt;-y</code> в Java, без вставлення проміжків або дужок між операторами.</p></div>
<div class="paragraph"><p>Змішений ідентифікатор складається з алфавітно-цифрового ідентифікатора, за яким слідує підкреслення, та операторний ідентифікатор. Наприклад, <code>unary_+</code> використовується як ім'я метода, що визначає унарний оператор <code>+</code>. Або <code>myvar_=</code>, що використовується як ім'я метода, що визначає оператор присвоєння. На додаток, змішані ідентифікатори в формі <code>myvar_=</code> генеруються компілятором Scala для підтримки властивостей (більше про це в Главі 18).</p></div>
<div class="paragraph"><p>Літеральний ідентифікатор є довільним рядком, оточений зворотніми апострофами `&#8230;\`. Деякі приклади літеральних ідентифікатоірв:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">`x`</span>
<span class="n">`&lt;clinit&gt;`</span>
<span class="n">`yield`</span>
</pre></div></div></div>
<div class="paragraph"><p>Ідея в тому, що ви покладаєте любий рядок, що допустимий під час виконання, як ідентифікатор між апострофами. Результат завжди є Scala ідентифікатор. Це робить навіть якщо ім'я в апострофах буде зарезервованим словом Scala. Типове використання є доступ до статичного метода <code>yield</code> в класі Java Thread. Ви не можете писати <code>Thread.yield()</code>, оскільки <code>yield</code> є зарезервованим словом Scala. Однак ви можете все ще назвати метод в апострофах, тобто <code>Thread.`yield</code>()`.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_11__">6.11 Перевантаження методів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Повернемось до класу <code>Rational</code>. З останніми змінами ви тепер можете робити операції додавання та множення в природний спосіб на раціональних числах. Але одна річ все ще відсутня - це змішана арифметика. Наприклад, ви не можете множити раціональне число на ціле, оскільки операнди <code>*</code> завжди мають бути <code>Rational</code>. Так що для раціонального числа <code>r</code> ви не можете написати <code>r * 2</code>. Ви маєте писати <code>r * new Rational(2)</code>, що не таке гарне.</p></div>
<div class="paragraph"><p>Щоб зробити <code>Rational</code> навіть ще зручнішим, ми додаємо методи до класу, що виконують змішане додавання та множення на раціональних числах та цілих. Доки ми тут, ми також додаємо методи для віднімання та ділення. Результат показаний на Лістингу 6.5.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">i</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.5 - Rational з перевантаженими методами.</p></div>
<div class="paragraph"><p>Тепер є дві версії для кожного арифметичного метода: одна що приймає раціональне в якості аргумента, та інша, що приймає ціле. Іншими словами, ім'я кожного з ціх методів перевантажене, оскільки кожне ім'я може використовуватись для декількох методів. Наприклад, ім'я <code>+</code> використовується одним методом, що приймає <code>Rational</code>, та інший, що приймає <code>Int</code>. В виклику метода компілятор обирає версію перевантаженого методу, що коректно співпадає з типами аргументів. Наприклад, якщо аргумент <code>y</code> в <code>x.+(y)</code> є <code>Rational</code>, компілятор буде обирати метод <code>+</code>, що приймає параметр <code>Rational</code>. Але якщо аргумент є цілим, компілятор обере метод <code>+</code>, що приймає параметр <code>Int</code>. Якщо ви спробуєте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">9</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите, що викликаний метод <code>*</code> визначений в кожному випадку по типу правого операнду.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">процес Scala з розрішення перевантажених методів дуже подібний до Java. В жодному разі обрана перевантажена версія є однією, що найкраще співпадає зі статичними типами аргументів. Іноді немає версії для унікального кращого співпадіння; в такому випадку компілятор видасть вам помилку "ambiguous reference".</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_12__">6.12 Неявні перетворення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви можете написати <code>r * 2</code>, ви можете також побажати обміняти операнди, як <code>2 * r</code>. Нажаль, це все ще не робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">overloaded</span> <span class="kt">method</span> <span class="kt">value</span> <span class="kt">*</span> <span class="kt">with</span>
<span class="n">alternatives</span><span class="k">:</span>
<span class="o">(</span><span class="kt">x:</span> <span class="kt">Double</span><span class="o">)</span><span class="kt">Double</span> <span class="kt">&lt;and&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="nc">Float</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="nc">Long</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Short</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="nc">Int</span>
<span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="o">(</span><span class="nc">Rational</span><span class="o">)</span>
<span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема тут в тому, що <code>2 * r</code> еквівалентне до <code>2.*(r)</code>, так що це виклик метода на числі 2, що є цілим. Але клас <code>Int</code> не містить метода множення, що приймає аргумент <code>Rational</code> — він не може, бо клас <code>Rational</code> не є стандартним класом в бібліотеці Scala.</p></div>
<div class="paragraph"><p>Однак є інший шлях вирішити цю проблему в Scala: ви можете створити неявне перетворення, що автоматично конвертує цілі на раціональні числа в разі потреби. Спробуйте додавання цього рядка в інтерпретатор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це викликає метод перетвоерння з <code>Int</code> до <code>Rational</code>. Модифікатор <code>implicit</code> попереду метода каже компілятору застосувати його автоматично в декількох ситуаціях. З визначеним перетворенням, ви можете повторити спробу приклада, що схибив до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб неявне перетворення працювало, воно має бути в полі зору. Якщо ми покладемо визначення неявного метода в клас <code>Rational</code>, він не буде в полі зору інтерпретатора. Поки ви повинні визначати його прямо в інтерпретаторі. Як ви здогадались з цього приклада, неявні перетворення дуже потужний прийом, щоб зробити бібліотеки більш гнучкими та більш зручними для використання. Оскільки вони такі потужні, вони можуть бути легко невірно використані. Ви побачите більше щодо неявних перетворень, включаючи шляхи занести їх в поле зору коли треба, в Главі 21.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_13__">6.13 Слово попередження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як демонструє ця глава, створення методів з іменами операторів та визначення неявних перетворень може допомогти вам розробляти бібліотеки, для яких клієнтськіій код є стислим та легко зрозумілим. Scala дає вам велику пропозицію щодо потужності, щоб розробляти такі прості-в-використанні бібліотеки. Але майте на увазі, що з силою іде відповідальність.</p></div>
<div class="paragraph"><p>Використані без майстерності, обоє, операторні методи та неявні перетворення можуть дати поштовх клієнтському коду, що складно читати та розуміти. Оскільки неявні перетворення застосовуються неявно компілятором, не явно прописані в коді, може бути неочевидним для програмістів клієнтів, що невні перетворення були застосовані. Та хоча операторні методи будуть звичайно робити клієнтський код більш стислим, вони будуть робити його краще читаємим тільки в тій мірі, в якій програмісти клієнітв будуть здатні розпізнавати та запам'ятовувати значення кожного оператора. Ціль, яку ви маєте тримати в голові, коли розробляєте бібліотеки, це не просто зрообити можливим підвищити стислість клієнтського кода, але також читабельний, зрозумілий клієнтський код. Стислість часто буде великою часткою читабельності, але ви можете зайти в стислості дуже далеко. Розробляючі бібліотеки, що дозволяють стислість зі смаком, та в той же час зрозумілий клієнтський код, ви можете допомогти програмістам клієнтів робити продуктивно.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_14_">6.14 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили багато аспектів класів в Scala. Ви бачили, як додавати параметри до класу, визначати декілька конструкторів, визначати оператори як методи, та налаштовувати класи, так щоб користування їми було природним. Можливо, більш важливо, ви побачили, що визначення та використання незмінних об'єктів є досить натуральним шляхом кодувати в Scala.</p></div>
<div class="paragraph"><p>Хоча фінальна версія <code>Rational</code>, показана в цій главі, задовільняє всім вимогам, встановленим напочатку глави, він все ще може покращений. Ми будемо фактично повертатись до цього прикладу пізніше в цій книзі. Наприклад, в Главі 30 ми вивчемо, як перекривати <code>equals</code> та <code>hashcode</code>, щоб дозволити <code>Rationals</code> краще поводитись при порівнянні за допомогою <code>==</code> або покладаючись в хеш таблиці. В Главі 21 ви навчитесь, як покласти визначення неявних методів в об'єкт компанйон <code>Rational</code>, так що вони можуть бути більш легко покладені в поле зору, коли програмісти клієнтів роблять з <code>Rationals</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__7_2">Глава 7</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____3">Вбудовані керівні структури</h1>
<div class="paragraph"><p>Scala має тільки декілька вбудованих керівних структур. Все, що є, це тільки: <code>if</code>, <code>while</code>, <code>for</code>, <code>try</code>, <code>match</code>, та виклики функцій. Причина, з якої Scala має їх так мало, в тому, що вона включає функціональні літерали з моменту свого створення. Замість накопичення в своєму синтаксисі однієї за одною високорівневих керівних структір, Scala накопичує їх в бібліотеках. (Глава 9 покаже в точності, як це зроблене.) Ця глава покаже ті декілька керівних структур, що є вбудованими.</p></div>
<div class="paragraph"><p>Одна річ, що ви помітите, це що майже всі керівні структури в Scala призводять до деякого результату. Цей підхід взятий від функціональних мов, де програми розглядаються як обчислення значення, так що компоненти програми також повинні обчислювати значення. Ви також можете розглядати цей підхід як логічний висновок з тренду, що вже присутній в імперативних мовах. В імперативних мовах виклики функцій можуть повертати значення, навіть коли викликана функція так само гарно може просто оновити значення вихідної змінної, переданої як аргумент. На додаток, імперативні мови часто мають тримісний оператор (такий як оператор <code>?:</code> в C, C++ та Java), що ефективно поводиться як <code>if</code>, але результатом є значення. Scala адаптує цю модель тримісного оператора, але називає його <code>if</code>. Іншими словами,в Scala <code>if</code> може повертати значення. Потім Scala продовжує цей тренд, маючи <code>for</code>, <code>try</code> та <code>match</code>, що також повертають значення.</p></div>
<div class="paragraph"><p>Програмісти можуть використовувати ці значення для спрощення свого коду, так само, якби вони використовували значення повернуті з функцій. Без цієї можливості програміст має створювати тимчасові змінні, тільки щоб зберігати результати, що обчислюються всередині керівної структури. Видалення ціх змінних робить код  трохи простішим, та він також запобігає багатьом вадам, коли ви встановлюєте змінну в одній гілці, але забуваєте встановити в іншому.</p></div>
<div class="paragraph"><p>Загалом, базові керівні структури Scala, мінімальні як вони є, провадяться всі основи з імперативних мов. Більше того, вони дозволяють скоротити ваш код, узгоджена маючі значення результату. Щоб показати, як це робить, давайте подивимось на базові керівні структури Scala.</p></div>
<div class="sect1">
<h2 id="_7_1__em_if_em">7.1 Вирази <em>if</em></h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala <code>if</code> робить так само, як і в багатьох інших мовах. Він перевіряє умову, і потім виконує одну з двох гілок коду, в залежності чи умова виконується. Ось загальний приклад, написаний в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">filename</span> <span class="k">=</span> <span class="s">&quot;default.txt&quot;</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
  <span class="n">filename</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код декларує змінну <code>filename</code>, та ініціалізує її значенням по замовчанню. Потім він виконує вираз <code>if</code>, щоб перевірити, чи програмі були надані якісь аргументи. Якщо це так, значення змінної змінюється, щоб вона містила значення, вказане в списку аргументів. Якщо аргументи не надані, змінна залішається встановленою в значення по замовчанню.</p></div>
<div class="paragraph"><p>Цей код може бути записаний краще, оскільки, як зазначалось в Кроці 3 в Главі 2, в Scala <code>if</code> є виразом, що повертає значення. Лістинг 7.1 показує, як ви можете досягти того самого ефекту, що і в попередньому прикладі, без використання жодних <code>var</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filename</span> <span class="k">=</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">else</span> <span class="s">&quot;default.txt&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.1 - Ідіома Scala для умовної ініціалізації.</p></div>
<div class="paragraph"><p>На цей раз <code>if</code> має дві гілки. Якщо аргументи не порожні, буде обраний перший елемент, <code>args(0)</code>; інакше буде обране значення по замовчанню. Вираз <code>if</code> має результат в вигляді обраного значення, і змінна <code>filename</code> ініціалізується цім значенням. Цей код трохи коротший, але його справжня перевага в тому, що він використовує <code>val</code> замість <code>var</code>. Використання <code>val</code> є функціональним стилем, і це допомагає вам майже в той спосіб, що і використання фінальних змінних в Java. Це каже читачам коду, що змінна ніколи не буде змінюватись, вберігаючи їх від сканування всього коду в полі зору змінної, дивлячись, чи вона не змінилась.</p></div>
<div class="paragraph"><p>Друга перевага використовувати <code>val</code> замість <code>var</code> в тому, що вони краще підтримують розуміння рівнянь. Введене значення еквівалентне до виразу, що обчислює його, припускаючи, що вираз не має побічних ефектів. Таким чином, кожного разу, коли ви збираєтесь записати ім'я змінної, замість нього ви можете записати вираз. Наприклад, замість <code>println(filename)</code>, ви можете просто записати це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;default.txt&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вибір за вами. Ви можете записати це любим способом. Використання <code>vals</code> допомагає вам безпечно робити цей тип рефакторингу, по мірі того, як ваш код буде розвиватись з часом. Шукайте можливості використовувати <code>val</code>. Вони можуть зробити ваш код більш простим для читання, та простішим для рефакторингу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_2__while">7.2 Цикли while</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala&#8217;s while loop behaves as in other languages. It has a condition and a body, and the body is executed over and over as long as the condition holds true. Listing 7.2 shows an example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">gcdLoop</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">var</span> <span class="n">b</span> <span class="k">=</span> <span class="n">y</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">temp</span> <span class="k">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="k">=</span> <span class="n">b</span> <span class="o">%</span> <span class="n">a</span>
    <span class="n">b</span> <span class="k">=</span> <span class="n">temp</span>
  <span class="o">}</span>
  <span class="n">b</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.2 - Обчислення найбільшого загального дільника за допомогою цикла <code>while</code>.</p></div>
<div class="paragraph"><p>Scala також має цикл <code>do-while</code>. Він робить як цикл <code>while</code>, за винятком того, що він перевіряє умову після тіла циклу, а не до. Лістинг 7.3 показує скрипт Scala, що використовує <code>do-while</code> для відлуння рядків, введених в стандартний вивід, докі не буде введений порожній рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">()</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Read: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.3 - Читання зі стандартного вводу за допомогою do-while.</p></div>
<div class="paragraph"><p>Конструкції <code>while</code> та <code>do-while</code> називаються "циклами", а не виразами, оскільки вони не продукують цікавого значення. Тип результата є <code>Unit</code>. Існує одне значення цього (та загалом тільки одне) типу <code>Unit</code>. Воно називається юніт значенням, та записується <code>()</code>. Існування <code>()</code> є тим, як Scala <code>Unit</code> відрізняється від Java <code>void</code>. Спробуйте це в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">greet</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">)</span> <span class="o">}</span>
<span class="n">greet</span><span class="k">:</span> <span class="o">()</span><span class="kt">Unit</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">()</span> <span class="o">==</span> <span class="n">greet</span><span class="o">()</span>
<span class="n">hi</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки перед тілом немає знаку рівняння, <code>greet</code> визначене як процедура з типом результата <code>Unit</code>. Таким чином, <code>greet</code> повертає юніт значення <code>()</code>. Це підтверджується в наступному рядку: порівнюючи результат <code>greet</code> на рівність з юніт значенням <code>()</code>, що дає <code>true</code>.</p></div>
<div class="paragraph"><p>Одна інша конструкція, що має результат в вигляді юніт значення, що релевантне тут, є переприсвоєння до <code>vars</code>. Наприклад, коли ви намагаєтесь читати рядки в Scala, використовуючи наступну ідіому Java, цикл <code>while</code> (та C і C++), ви потрапите в небезпеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="c1">// Це не робить!</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Read: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви компілюєте цей код, Scala надасть вам попередження, що порівняння значень типів <code>Unit</code> та <code>String</code> з використанням <code>!=</code> буде завжди давати <code>true</code>. Тоді як в Java присвоєння скінчиться присвоєнням значення (в цьому випадку рядка зі стандартного вводу), в Scala присвоєння завжди зкінчиться юніт значенням, <code>()</code>. Таким чином, значення присвоєння <code>line = readLine()</code> завжди буде <code>()</code>, та ніколи не буде <code>""</code>. Як результат, умова цього цикла <code>while</code> ніколи не буде <code>false</code>, і, таким чином, цикл ніколи не завершиться.</p></div>
<div class="paragraph"><p>Оскікльки цикл <code>while</code> не призводить до значення, він часто відсутній в чисто функціональних мовах. Такі мови мають вирази, а не цикли. Тим не менш, Scala включає цикл <code>while</code>, оскільки деякі імперативні рішення можуть бути більш читабельні, особливо для програмістів з переважно імперативним досвідом. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує процес докі деяка умова не зміниться, цикл <code>while</code> може виразити це напряму, тоді як функціональна альтернатива, що вірогідно використовуватиме рекурсію, може бути менш очевидною для деяких читачів коду.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 7.4 показує альтернативний шлях визначити найбільший загальний дільник двох чисел.<span class="footnote"><br />[Функція gcd, показана в Лістингу 7.4, використовує той самий підхід, що використовується в подібно-названій функції, спершу показаній в Лістингу 6.3, щоб обчислювати найбільший загальний дільник для класу Rational. Головна різниця в тому, що замість Int, gcd з Лістингу 7.4 робить з Long.]<br /></span> Беручи деякі два значення для <code>x</code> та <code>y</code>, функція <code>gcd</code>, показана в Лістингу 7.4 буде повертати той самий результат, що і <code>gcdLoop</code> функція, показана в Лістингу 7.2. Різниця між ціма двома підходами а тому, що <code>gcdLoop</code> написана в імперативному стилі, використовуючи <code>var</code> та цикл <code>while</code>, тоді як <code>gcd</code> написане в більш функціональному стилі, що включає рекурсію (<code>gcd</code> викликає себе), та не потребує <code>var</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.4 - Обчислення найбільшого загального дільника за допомогою рекурсії.</p></div>
<div class="paragraph"><p>Загалом, ми рекомендуємо вас кидати виклик циклам <code>while</code> в вашому коді, так само, як ви кидаєте виклик <code>var</code>. Фактично, цикли <code>while</code> та <code>var</code> часто ідуть рука об руку. Оскільки цикли <code>while</code> не видають результату, щоб призвести до якіхось змін в вашій програмі, цикл  <code>while</code> буде звичайно оновлювати <code>var</code> або виконувати I/O. Ви можете бачити це в дії в <code>gcdLoop</code>, показаному раніше. По мірі того, як цикл <code>while</code> робить свою справу, він оновлює <code>var</code> <code>a</code> та <code>b</code>. Таким чином, ми радимо вам бути трохи підозрілим щодо циклів <code>while</code> в вашому коді. Якщо немає гарного обгрунтування для окремого використання циклів <code>while</code> або <code>do-while</code>, спробуйте знайти спосіб зробити те саме без них.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_3__for">7.3 Вирази for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вираз <code>for</code> в Scala є швейцарським розкладним ножем ітерації. Він дозволяє комбінувати декілька простих інструментів в різний спосіб, щоб виразити широку різноманітність ітерацій. Прості використання дозволяють вирішувати загальні завдання, такі, як ітерація по послідовності цілих. Більш розвинені вирази можуть ітерувати по декількох колекціях різних типів, фільтрувати елементи на основі довільних умов, та продукувати нові колекції.</p></div>
<div class="sect2">
<h3 id="____4">Ітерації по колекціях</h3>
<div class="paragraph"><p>Простіша річ, що ви можете зробити за допомогою <code>for</code> це ітерувати по всіх елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що друкує всі файли в поточній директорії. I/O виконується з використанням Java API. Зпочатку ми створюємо <code>java.io.File</code> на поточній директорії,".", та викликаємо його метод <code>listFiles</code>. Цей метод повертає масив з об'єктів <code>File</code>, по одному для кожної директорії та файлу, що містяться в поточній директорії. Ми зберігаємо отриманий масив в змінній <code>filesHere</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

<span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.5 - Перелічує файли в поточній директорії за допомогою вираза <code>for</code>.</p></div>
<div class="paragraph"><p>За допомогою синтаксиса <code>file &lt;- filesHere</code>, що називається <em>генератором</em>, ми ітеруємо по елементах <code>filesHere</code>. В кожній ітерації ініціалізується нова <code>val</code> на ім'я <code>file</code> зі значенням елемента. Компілятор виводить тип <code>file</code> як <code>File</code>, оскільки <code>filesHere</code> має тип <code>Array[File]</code>. Для кожної ітерації буде виконане тіло вираза, <code>println(file)</code>. Оскільки в <code>File</code> метод <code>toString</code> видає ім'я файла або директорії, будуть роздруковані імена всіх файлів та директорій в поточній директорі.</p></div>
<div class="paragraph"><p>Синтаксис виразу <code>for</code> робить для любого типу колекції, не тільки для масивів.<span class="footnote"><br />[Щоб бути точним, вираз зправа від символа <code>&lt;-</code> в виразі for може бути любого типу, що має певні методи (в цьому випадку foreach) з відповідними сигнатурами. Деталі щодо того, як компілятор Scala обробляє вирази <code>for</code> описані в Главі 23.]<br /></span> Один зручний особливий випадок є тип <code>Range</code>, що ви похопцем бачили в Таблиці 5.4. Ви можете створити <code>Range</code> з використанням синтаксису як <code>1 to 5</code>, та можете ітерувати по ньому за допомогою <code>for</code>. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
<span class="nc">Iteration</span> <span class="mi">1</span>
<span class="nc">Iteration</span> <span class="mi">2</span>
<span class="nc">Iteration</span> <span class="mi">3</span>
<span class="nc">Iteration</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви не бажаєте включати верхню межу диапазона в значення, по яких піде ітерація використовуйте <code>until</code> замість <code>to</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
<span class="nc">Iteration</span> <span class="mi">1</span>
<span class="nc">Iteration</span> <span class="mi">2</span>
<span class="nc">Iteration</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітерація по цілим, як ця, є загальною в Scala, але не так сильно, як в інших мовах. В інших мовах ви можете використати цю можливість для ітерації по масиву, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Не загальне в Scala...</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">filesHere</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">filesHere</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз <code>for</code> вводить змінну <code>i</code>, встановлює її по черзі в коже ціле між <code>0</code> та <code>filesHere.length - 1</code>, та виконує тіло виразу для кожного встановленого <code>i</code>. Для кожного встановленого <code>i</code>, <code>i`тий елемент `filesHere</code> отримується та обробляється.</p></div>
<div class="paragraph"><p>Причина, з якої цей тип ітерації менш загальний в Scala в тому, що ви можете ітерувати по колекції напряму. Коли ви робите це, ваш код стає коротшим, та ви обходите багато "помилкових помилок", що можуть виникати, коли ви ітеруєте по масивах. Маєте ви почати з 0 або 1? Маєте ви додавати -1, +1, або нічого до фінального значення? На такі запитання легко відповісти, але також легко відповісти помилково. Безпечніше взагалі повністю уникати таких запитань.</p></div>
</div>
<div class="sect2">
<h3 id="__8">Фільтрація</h3>
<div class="paragraph"><p>Іноді ви не бажаєте ітерувати по повній колекції; ви бажаєте відфільтрувати її до деякої підмножини. Ви можете зробити це за допомогою вираза <code>for</code> через додавання фільтра, твердження <code>if</code> всередині дужок <code>for</code>. Наприклад, код, показаний в Лістингу 7.6, перелічує тільки ті файли в поточній директорії, чиї імена закінчуються на <code>.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>
<span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
  <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.6 - Пошук файлів <code>.scala</code> використовуючи <code>for</code> з фільтром.</p></div>
<div class="paragraph"><p>Ви можете альтернативно досягти тієї самої цілі за допомогою цього коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
<span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код дає той самий вихід, що і попередній код, та, можливо, виглядає більш знайомим для програмістів з імперативним підгрунтям. Однак імперативна форма є тільки цибулиною, оскільки цей часний вираз <code>for</code> викликається тільки для побічного ефекту друкування, і має результатом юніт значення <code>()</code>. Як буде показано далі в цьому розділі, вираз <code>for</code> названий "виразом", оскільки він може давати в результаті цікаве значення, колекцію, тип якої визначається твердженням <code>&lt;-</code> виразу <code>for</code>.</p></div>
<div class="paragraph"><p>Ви можете включити більше фільтрів, якщо ви бажаєте. Просто продовжуйте додавати фільтри <code>if</code>. Наприклад, щоб бути екстра захищеним, код в Лістингу 7.7 друкує тільки файли, але не директорії. Він робить це через додавання фільтрів, що перевіряють метод <code>isFile</code> для файлів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">isFile</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.7 - Використання декількох фільтрів в виразі <code>for</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___10">Вкладена ітерація</h3>
<div class="paragraph"><p>Якщо ви додасте декілька тверджень <code>&lt;-</code>, ви отримаєте вкладені "цикли". Наприклад, вираз <code>for</code>, показаний в Лістингу 7.8 має два вкладених цикли. Зовнішній цикл ітерує по <code>filesHere</code>, та внутрішній ітерує по <code>fileLines(file)</code> для кожного файлу, що закінчується на <code>.scala</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">java.io.File</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
<span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">);</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
  <span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
<span class="n">grep</span><span class="o">(</span><span class="s">&quot;.*gcd.*&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.8 - Використання декількох генераторів в виразі <code>for</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте, ви можете використовувати фігурні дужки замість звичайних дужок щоб оточити генератори та фільтри. Одна з переваг використання фігурних дужок в тому, що ви можете відкинути деякі з крапок з комою, що потрібні вам, коли ви використовуєте дужки, бо, як пояснено в Розділі 4.2, компілятор Scala не буде виводити коми з крапками, коли знаходиться в дужках.</p></div>
</div>
<div class="sect2">
<h3 id="_____8">Серед-поточні прикріплення змінних</h3>
<div class="paragraph"><p>Зауважте, що в попередньому коді повторюється вираз <code>line.trim</code>. Це нетривіальне обчислення, так що ви можете побажати обчислити його тільки один раз. Ви можете зробити це, прикріпивши результат до нової змінної, використовуючи знак рівності (=). Прикріплена змінна буде створена, та використовується як звичайна <code>val</code>, тільки без ключового слова <code>val</code>. Лістинг 7.9 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
  <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>
  <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
<span class="o">}</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">trimmed</span><span class="o">)</span>
<span class="n">grep</span><span class="o">(</span><span class="s">&quot;.*gcd.*&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.9 - Серед-поточне присвоєння в виразі <code>for</code>.</p></div>
<div class="paragraph"><p>В Лістингу 7.9 змінна на ім'я <code>trimmed</code> вводиться посеред виразу <code>for</code>. Ця змінна ініціалізована результатом <code>line.trim</code>. Потім залишок виразу використовує її в двох місцях, один раз в <code>if</code>, та ще раз в <code>println</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____5">Продукування нової колекції</h3>
<div class="paragraph"><p>Хоча доки всі приклади тільки оперували з ітерованими значеннями, та потім забували їх, ви також можете генерувати значення, що буде запам'ятовуватись на кожній ітерації. Щоб зробити це, ви ставите перед тілом виразу <code>for</code> ключове слово <code>yield</code>. Наприклад, ось функція, що ідентифікує файли <code>.scala</code>, та зберігає їх в масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">scalaFiles</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний раз, коли виконується тіло виразу, воно продукує одне значення, в цьому разі просто <code>file</code>. Коли вираз <code>for</code> завершується, результат буде включати всі з отриманих значень, що міститимуться в одній колекції. Тип отриманої колекції базується на типі колекцій, оброблених в твердженнях ітерації. В цьому випадку результат буде  <code>Array[File]</code>, оскільки <code>filesHere</code> є масивом, і тип отриманого виразу є <code>File</code>.</p></div>
<div class="paragraph"><p>Будьте уважні, поміж всього, коли ви розташовуєте ключове слово <code>yield</code>. Синтаксис виразу <code>for-yield</code> виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">clauses</span> <span class="k">yield</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p><code>yield</code> іде перед всім тілом. Навіть якщо тіло є блок, оточений фігурними дужками, покладіть <code>yield</code> перед першою фігурною дужкою, не перед останнім виразом в блоці. Уникайте спокуси писати речі, подібні до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">yield</span> <span class="n">file</span> <span class="c1">// Синтаксична помилка!</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, вираз <code>for</code>, показаний в Лістингу 7.10 спочатку трансформує <code>Array[File]</code> на ім'я <code>filesHere</code>, що містить всі файли в поточній директорії, до такого, що містить тільки файли <code>.scala</code>. Для кожного з них він генерує <code>Iterator[String]</code>, результат метода <code>fileLines</code>, чиє визначення показане в Лістингу 7.8. <code>Iterator</code> пропонує методи <code>next</code> та <code>hasNext</code>, що дозволяють вам ітерувати по колекції елементів. Цей внутрішній ітератор трансформується в інший ітератор ` Iterator[String]<code>, який містить тільки обрізані рядки, що містять субрядок `"for"</code>. Нарешті, для кожного з них, видається ціла довжина. Результатом цього виразу <code>for</code> є <code>Array[Int]</code>, що містить довжини.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">forLineLengths</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>
    <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="s">&quot;.*for.*&quot;</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.10 - Трансформування <code>Array[File]</code> на <code>Array[Int]</code> з допомогою <code>for</code>.</p></div>
<div class="paragraph"><p>В цій точці ви бачили всі головні функції виразів Scala <code>for</code>, але ми пройшли по них дуже швидко. Більш докладне покриття виразів <code>for</code> надається в Главі 23.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_4______try">7.4 Обробка виключень за допомогою виразів try</h2>
<div class="sectionbody">
<div class="paragraph"><p>Виключення Scala поводяться як в багатьох інших мовах. Замість повернення значення в в нормальний спосіб, метод може завершитись викликом виключення. Викликач метода може або перехопити та обробити це виключення, або він може сам по собі завершитись, що спричинить поширення виключення до викликача викликача. Виключення розповсюджується в такий спосіб, розкручуючи стек викликів, доки метод не обробить його, або доки не залишиться методів.</p></div>
<div class="sect2">
<h3 id="___11">Виклик виключень</h3>
<div class="paragraph"><p>Виклик виключення в Scala виглядає так само, як і в Java. Ви створюєте об'єкт виключення, та потім закидаєте його ключовим словом <code>throw</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це може виглядати трохи парадоксальним, в Scala <code>throw</code> є виразом, що має тип результа. Ось приклад, коли тип результата має значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">half</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">else</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;n must be even&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут трапиться, коли <code>n</code> є парним - <code>half</code> буде ініціалізоване до половини <code>n</code>. Якщо воно не парне, буде викликане виключення перед тим, як <code>half</code> взагалі зможе бути ініціалізоване. Через це, безпечно трактувати закидання виключення як взагалі будь-який тип. Любий контекст, що намагатиметься використовувати повернення з <code>throw</code>, ніколи не зможе цього зробити, так що не слід чекати ніякої шкоди.</p></div>
<div class="paragraph"><p>Технічно <code>throw</code> виключення має тип <code>Nothing</code>. Ви можете використовувати <code>throw</code> як вираз, навіть якщо він ніколи нічого не обчислює. Цей невеликий шматок технічної гімнастики може виглядати збоченим, але часто корисний в випадках, як попередній приклад. Одна з гілок <code>if</code> обчислює значення, тоді як інша закидає виключення, та обчислює <code>Nothing</code>. Тип цілого виразу <code>if</code> після цього є типом тієї гілки, що щось обчислює. Тип <code>Nothing</code> дискутується далі в Розділі 11.3.</p></div>
</div>
<div class="sect2">
<h3 id="___12">Перехоплення виключень</h3>
<div class="paragraph"><p>Ви перехоплюєте виключення, використовуючи синтаксис, показаний в Лістингу 7.11 Синтаксис для тверджень <code>catch</code> був обраний за його узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння шаблонів, потужна можливість, коротко описана в цій главі, та в більших деталях в Главі 15.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>
<span class="k">import</span> <span class="nn">java.io.FileNotFoundException</span>
<span class="k">import</span> <span class="nn">java.io.IOException</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">&quot;input.txt&quot;</span><span class="o">)</span>
<span class="c1">// Використовуємо та зачиняємо файл</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">FileNotFoundException</span> <span class="o">=&gt;</span> <span class="c1">// Обробляємо відсутній файл</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">IOException</span> <span class="o">=&gt;</span> <span class="c1">// Обробляємо помилки I/O</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.11 - Твердження <code>try-catch</code> clause in Scala.</p></div>
<div class="paragraph"><p>Поведінка цього виразу <code>try-catch</code> така сама, як і інших мов з виключенями. Тіло виконується, та якщо виникає виключення, кожне твердження <code>catch</code> викликається по черзі. В цьому прикладі, якщо виникає включення типу <code>FileNotFoundException</code>, буде виконане перше твердження. Якщо тип виключення <code>IOException</code>, виконується друге твердження. Якщо виключення не одного з ціх типів, <code>try-catch</code> завершиться, та виключення розповсюдиться далі.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Одна різниця, що ви швидко зауважите, в тому, що на відміну від Java, Scala не вимагає від вас перехоплювати перевірені виключення, або декларувати їх в твердженні <code>throws</code>. Ви можете декларувати <code>throws</code>, якщо бажатєте, за допомогою анотації <code>@throws</code>, але це не вимагається. Дивіться Розділ 31.2 для додаткової інформації щодо <code>@throws</code>.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="__finally">Твердження finally</h3>
<div class="paragraph"><p>Ви можете огорнути вираз за допомогою твердження <code>finally</code>, якщо ви бажаєте виконати деякий код, не важливо як скінчиться вираз. Наприклад, ви можете побажати переконатись, що відкритий файл буде закритий, навіть якщо метод завершується виникненням виключення. Лістинг 7.12 показує приклад.<span class="footnote"><br />[Хоча ви маєте завжди оточувати твердження case в catch в дужки, try та finally не потребують дужок, якщо вони містять тільки один вираз. Наприклад, ви можете написати: try t() catch { case e: Exception &#8658; &#8230; } finally f().]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>
<span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">&quot;input.txt&quot;</span><span class="o">)</span>
<span class="k">try</span> <span class="o">{</span>
<span class="c1">// Використовуємо файл</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
  <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="o">()</span> <span class="c1">// Переконуємось що зачинили файл</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.12 - Твердження <code>try-finally</code> в Scala.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Лістинг 7.12 показує ідиоматичний спосіб переконатись, що об'єкт не-з-пам'яті, такий як файл, сокет або з'єднання з базою даних, є зачинений. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок <code>try</code>, в якому ви використовуєте ресурс. Нарешті, ви зачиняєте ресурс в блоці <code>finally</code>. Ця ідіома є тою самою в Scala, як в Java; альтернативно, в Scala ви можете задіяти прийом з назвою <em>шаблон позичання</em>, щоб досягти цієї цілі більш стисло. Шаблон позичання буде описаний в Розділі 9.4.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="___13">Отримання значення</h3>
<div class="paragraph"><p>Як і з багатьма іншими керівними структурами Scala, <code>try-catch-finally</code> повертає значення. Наприклад, Лістинг 7.13 показує, як ви можете спробувати розібрати URL, але використати значення по замовчанню, якщо URL погано сформований. Результатом є те, що полишає твердження <code>try</code>, якщо не виникло виключення, або відповідний код <code>catch</code>, якщо виключення виникло і було перехоплене. Якщо виключення було закинуте, але не перехоплене, вираз взагалі не має результату. Значення, обчислене в твердженні <code>finally</code>, якщо таке є, відкидається. Звичайно в <code>finally</code> робиться деякий різновид очищення, такий як закриття файлів. Звичайно, вони не мають змінювати значення, обчислене в головному тілі або блоці <code>catch</code> твердження <code>try</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.net.URL</span>
<span class="k">import</span> <span class="nn">java.net.MalformedURLException</span>
<span class="k">def</span> <span class="n">urlFor</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">MalformedURLException</span> <span class="o">=&gt;</span>
      <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="s">&quot;http://www.scala-lang.org&quot;</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.13 - Твердження <code>catch</code>, що надає значення.</p></div>
<div class="paragraph"><p>Якщо ви знайомі з Java, вам зрозуміло, що поведінка Scala відрізняється від Java <code>try-finally</code> тільки в тій частині, що остання не повертає значення. Як і в Java, якщо твердження <code>finally</code> включає явне твердження <code>return</code>, або закидає виключення, значення повернення або виключення буде "анулювати" любі попередні значення, що походять з блоку <code>try</code> або з одного з його тверджень <code>catch</code>. Наприклад, маючи таке, скоріше надумане, визначення функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">finally</span> <span class="k">return</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>виклик f() дає 2. Для контрасту, маючи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">g</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span> <span class="mi">1</span> <span class="k">finally</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>виклик g() дає 1. Обоє з ціх функцій показують поведінку, що може здивувати багатьох програмістів, так що зазвичай краще уникати повернення значень з твердження <code>finally</code>. Кращий спосіб думати про блок <code>finally</code>, як про спосіб переконатись, що відбувся деякий побічний ефект, такий як зачинення відкритого файлу.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_5__match">7.5 Вирази match</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala вираз <code>match</code> дозволяють вам обрати з декількох альтернатив, так само, як твердження <code>switch</code> в інших мовах. Загалом, вираз <code>match</code> дозволяє вам зробити вибір, використовуючі довільні шаблони, що будуть описані в Главі 15. Загальна форма може почекати. Доки розглянемо тільки використання <code>match</code> для обрання між декількома альтернативами.</p></div>
<div class="paragraph"><p>Як приклад, скрипт в Лістингу 7.14 читає назву їжі зі списку аргументів, та друкує додаток до цієї їжі. Цей вираз <code>match</code> перевіряє <code>firstArg</code>, що була встановлена в перший аргумент зі списку аргументів. Якщо рядок є <code>"salt"</code>, друкується <code>"pepper"</code>, та якщо рядок <code>"chips"</code>, друкується <code>"salsa"</code>, і так далі. Випадок по замовчанню вказаний підкресленням (<code>_</code>), підстановочним символом, що часто використовується в Scala як заміщувач для повністю невідомого значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">firstArg</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
<span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`&quot;salt&quot;`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pepper&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;chips&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;salsa&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;eggs&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;bacon&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;huh?&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.14 - Вираз <code>match</code> з побічними ефектами.</p></div>
<div class="paragraph"><p>Існує декілька важливих відмінностей від твердження Java <code>switch</code>. Одна в тому, що любий різновид констант, так само як і інших речей, може використовуватись в <code>case</code> в Scala, не тільки цілі типи, enum, та константи рядків в твердженнях Java <code>case</code>. В Лістингу 7.14 альтернативами є рядки. Інша відмінність в тому, що нема переривань <code>break</code> в кінці кожної альтернативи. Замість цього, <code>break</code> є неявним, і немає провалювання від однієї альтернативи до іншої. Загальний випадок — відсутність провалювання — стає коротший, та уникається джерело помилок, оскільки програмісти більше не провалюватимуться випадково.</p></div>
<div class="paragraph"><p>Однак найбільш значуща різниця з Java <code>switch</code> може полягати в тому, що вирази <code>match</code> повертають значення. В попередньому прикладі кожна з альтернатив в виразі <code>match</code> друкує значення. Також гарно буде робити повернення значення, ніж його друк, як показано в Лістингу  7.15. Значення, що є результатом цього виразу <code>match</code>, зберігається в змінній <code>friend</code>. Крім того, що код став коротший (в любому випадку за числом токенів), код тепер розрізняє дві різні турботи: спочатку він обирає їжу, та потім друкує її.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">firstArg</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
<span class="k">val</span> <span class="n">friend</span> <span class="k">=</span>
  <span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;salt&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;pepper&quot;</span>
    <span class="k">case</span> <span class="s">&quot;chips&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;salsa&quot;</span>
    <span class="k">case</span> <span class="s">&quot;eggs&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;bacon&quot;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;huh?&quot;</span>
  <span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="n">friend</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.15 - Вираз <code>match</code>, що продукує значення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_6___break__continue">7.6 Життя без break та continue</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви, можливо, помітили, що ми не споминули <code>break</code> або <code>continue</code>. Scala полишила ці дві команди, оскільки вони не дуже гарно перетинаються з функціональними літералами, можливістю, описаною в наступній главі. Ясно, що значить <code>continue</code> означає в циклі <code>while</code>,але що воно може значити в функціональному літералі? Хоча Scala підтримує обоє, імперативний та функціональний стилі програмування, в цьому випадку вона трохи схиляється до функціонального програмування, в обмін на спрощення мови. Однак не турбуйтесь. Існує багато шляхів програмувати без <code>break</code> та <code>continue</code>, та якщо ви отримаєте переваги функціональних літералів, ці альтернативи можуть часто бути коротші, ніж оригінальний код.</p></div>
<div class="paragraph"><p>Найпростіший підхід є замінити кожний <code>continue</code> на <code>if</code>, та кожний <code>break</code> на логічну змінну. Логічна змінна вказує, чи оточуючий цикл має продовжуватись. Наприклад, уявімо, що ви шукаєте в списку аргументів рядок, що закінчується на <code>".scala"</code> але не починається на дефіс. В Java ви можете — якщо ви великий прихильник циклів <code>while</code>, <code>break</code> та <code>continue</code> — написати наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="c1">// Це Java</span>
<span class="kt">boolean</span> <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб перекласти цей Java код прямо на Scala, замість робити <code>if</code> та потім <code>continue</code>, ви можете написати <code>if</code>, що оточує весь залишок цикла <code>while</code>. Щоб позбавитись <code>break</code>, ви можете звичайно додати логічну змінну, що вказує, чи варто продовжувати, але в цьому випадку ми можемо повторно використати <code>foundIt</code>. Викорисистовуючи обоє з ціх трюків, код приходить до вигляду, як показано на Лістингу 7.16.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="n">foundIt</span> <span class="k">=</span> <span class="kc">false</span>

<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">foundIt</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
      <span class="n">foundIt</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="o">}</span>
  <span class="n">i</span> <span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.16 - Цикл без <code>break</code> або <code>continue</code>.</p></div>
<div class="paragraph"><p>Цей Scala код в Лістингу 7.16 досить подібний до оригінального Java коду. Всі базові частини все ще тут, і в тому ж порядку. Є дві переприсвоювані змінні та цикл <code>while</code>. В циклі є перевірка, що <code>i</code> менше ніж <code>args.length</code>, перевірка на <code>"-"</code>, та перевірка на <code>".scala"</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте позбутись <code>var</code> в Лістингу 7.16, один підхід, що ви можете спробувати, це переписати цикл як рекурсивну функцію. Ви можете, наприклад, визначити функцію <code>searchFrom</code>, що приймає ціле на вході, шукає з цього місця, та потім повертає індекс потрібного аргументу. Використовуючи цей прийом, код буде виглядати, як показано в Лістингу 7.17:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="n">i</span>
  <span class="k">else</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">i</span> <span class="k">=</span> <span class="n">searchFrom</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.17 - Рекурсивна альтернатива до циклів з <code>var</code>.</p></div>
<div class="paragraph"><p>Версія в Лістингу 7.17 дає змістовне ім'я тому, що робить функція, та вона використовує рекурсію для заміни циклу. Кожне <code>continue</code> замінюється рекурсивним викликом з аргументом <code>i + 1</code>, що ефективно просуває до наступного аргументу. Багато людей знаходять, що цей стиль програмування простіший для розуміння, як тільки вони переходять до використання рекурсії.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Компілятор Scala насправді не видасть рекурсивну функцію для коду, показаному на Лістингу 7.17. Оскільки всі рекурсівні виклики в позиції хвостового-виклику, компілятор буде генерувати код, подібний до циклу <code>while</code>. Кожний рекурсивний виклик буде реалізований як стрибок в зворотньому напрямку на початок функції. Оптимізація хвостового виклику обговорюється в Розділі 8.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо після всієї цієї дискусії ви все ще потребуєте використовувати <code>break</code>, існує допомого з боку стандартної бібліотеки Scala. Клас <code>Breaks</code> в пакунку <code>scala.util.control</code> пропонує метод <code>break</code>, що може бути використаний для виходу з оточуючого блоку, що відмічений як <code>breakable</code>. Ось приклад, як може бути застосований цей наданий бібліотекою метод <code>break</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.control.Breaks._</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">in</span><span class="o">))</span>

<span class="n">breakable</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;? &quot;</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="n">break</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде читати непусті рядки зі стандартного входу. Коли користувач введе порожній рядок, керування потоком вийде з оточуючого  <code>breakable</code>, і разом з цім з циклу <code>while</code>. Клас <code>Breaks</code> реалізує  <code>break</code> через закидання виключення, що перехоплюється оточуючим застосуванням метода <code>breakable</code>. Таким чином, виклик до <code>break</code> не обов'язково повинен бути в тому самому методі, що викликає <code>breakable</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_7___">7.7 Поле зору змінної</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили вбудовані керівні структури Scala, ми будемо використовувати їх в цьому розділі для пояснення, як поле зору робить в Scala.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java__3">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви Java програміст, ви знайдете, що правила поля зору в Scala майже ідентичні до Java. Одна різниця між Java та Scala в тому, що  Scala дозволяє вам визначати змінні з тим самим ім'ям у вкладених блоках. Так що якщо ви Java програміст, ви маєте щанайменьше передивитись цей розділ.</p></div>
<div class="paragraph"><p>Декларації змінинх в Scala програмах мають поле зору, яке визначає, де ви можете використовувати ім'я. Найбільш загальни приклад поля зору полягаеє в тому, що фігурні дужки загалом вводять нове поле зору, так що будь-що, визначене в фігурних дужках виходить з поля зору після закриваючої фігурної дужки.<span class="footnote"><br />[Є декілька виключень з цього правила, оскільки в Scala ви іноді використовуєте фігурні дужки замість дужок. Один приклад цього різновиду використання фігурних дужок альтернативний синтаксис виразу <code>for</code>, описаний в Розділі 7.3.]<br /></span> Як ілюстрацію розгліянемо функцію, показану в Лістингу  7.18.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printMultiTable</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">1</span>
<span class="c1">// в полі зору тільки i</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="mi">1</span>
<span class="c1">// в полі зору i та j</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="o">).</span><span class="n">toString</span>
<span class="c1">// в полі зору  i, j, prod</span>
      <span class="k">var</span> <span class="n">k</span> <span class="k">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">length</span>
<span class="c1">// в полі зору i, j, prod, k</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">print</span><span class="o">(</span><span class="n">prod</span><span class="o">)</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
 <span class="c1">// в полі зору i та j; prod та k вийшли</span>
  <span class="o">}</span>
  <span class="n">println</span><span class="o">()</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c1">// в полі зору все ще i; j, prod, k вийшли</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.18 - Поле зору змінних при друкуванні таблиці множення.</p></div>
<div class="paragraph"><p>Функція <code>printMultiTable</code>, показана в Лістингу 7.18, друкує таблицю множення.<span class="footnote"><br />[Функція <code>printMultiTable</code>, показана в Лістингу 7.18 написана в імперативному стилі. Ми зробимо її рефактор в функціональному стилі в наступному розділі.]<br /></span> Перше твердження цієї функції вводить змінну на ім'я <code>i</code>, та ініціалізує її цілим <code>1</code>. Потім ви можете використовувати ім'я <code>i</code> в залишку функції.</p></div>
<div class="paragraph"><p>Наступне твердження в <code>printMultiTable</code> є цикл <code>while</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете використовутати тут <code>i</code> також, бо вона все ще в полі зору. В першому твердженні в циклі <code>while</code> ви вводите іншу змінну, не цей раз з назвою <code>j</code>, та знову ініціалізуємо її в <code>1</code>. Оскільки змінна <code>j</code> була визначена в відкритих фігурних дужках циклу <code>while</code>, вона може бути вкористана тільки в циклі <code>while</code>. Якщо ви спробуєте зробити щось з <code>j</code> після зачинення фігурних дужок цикла <code>while</code>, після коментаря, що каже, що <code>j</code>, <code>prod</code>, та <code>k</code> за полем зору, ваша програма не буде компілюватись.</p></div>
<div class="paragraph"><p>Всі змінні, визначені в цьому прикладі — <code>i</code>, <code>j</code>, <code>prod</code>, <code>k</code> — є локальними змінними. Такі змінні "локальні" для функції, в якій вони визначені. Кожного разу, коли функція викликається, використовується новий набір локальних змінних.</p></div>
<div class="paragraph"><p>Коли змінна визначена, ви не можете визначити нову змінну з тим самим ім'ям в тому ж самому полі зору. Наприклад, наступний скрипт з двома змінними на ім'я <code>a</code> в тому ж полі зору не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// Не компілюється</span>
<span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку ви можете визначити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. Наступний скрипт буде компілюватись та виконуватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// Чудово компілюється</span>
  <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>При виконанні показаний перед цім скрипт буде друкувати 2, та потім 1, оскільки <code>a</code> визначене в фігурних дужках, є іншою змінною, яка в полі зору доки не будуть закриті фігурні дужки.<span class="footnote"><br />[Доречі, в цьому випадку крапка з комою є необхідними після першого визначення <code>a</code>, оскільки механізм виводу крапки з комою Scala не буде ставити її в цьому випадку.]<br /></span> Одна різниця між Scala та Java в тому, що Java не дозволить вам створити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. В програмі Scala внутрішня змінна, як кажуть, <em>затінює</em> змінну з таким же ім'ям, оскільки зовнішня змінна стає невидимою у внутрішньому полі зору.</p></div>
<div class="paragraph"><p>Ви могли вже зазначити в інтерпретаторі дещо, що виглядає як затінення, :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>В інтерпретаторі ви можете повторно використовувати імена змінних за покликом вашого серця. Поміж інших речей, це дозволяє вам змінити вашу думку, якщо ви зробили помилку, коли перший раз визначали змінну в інтерпретаторі. Ви можете робити це, бо інтерпретатор відкриває нове вкладене поле зору для кожного нового твердження, яке ви набираєте. Таким чином, ви можете віалізувати попередній інтерпретований код так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
  <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код буде компілюватись та виконуватись як Scala скрипт, та, як і код, набраний в інтерпретаторі, буде друкувати 2. Майте на увазі, що такий код буде дуже бентежливий для читачів, оскільки імена змінних приймають нові значення у вкладених полях зору. Зазвичай краще створити нове, осмислене ім'я, ніж затінювати зовнішню змінну.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_8_____">7.8 Рефакторинг коду в імперативному стилі</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб допомогти вам отримати уявлення про функціональний стиль, в цьому розділі ми зробимо рефакторинг імперативного підходу до друку таблиці множеннчя, показаного в Лістингу 7.18. Наша функціональна альтернатива показана на Лістингу 7.19.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Повертає рядок як послідовність</span>
<span class="k">def</span> <span class="n">makeRowSeq</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">col</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="o">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">col</span><span class="o">).</span><span class="n">toString</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">prod</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">padding</span> <span class="o">+</span> <span class="n">prod</span>
  <span class="o">}</span>

<span class="c1">// Повертає рядок як рядок</span>
<span class="k">def</span> <span class="n">makeRow</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">makeRowSeq</span><span class="o">(</span><span class="n">row</span><span class="o">).</span><span class="n">mkString</span>

<span class="c1">// Повертає таблицю як рядок</span>
<span class="k">def</span> <span class="n">multiTable</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">tableSeq</span> <span class="k">=</span> <span class="c1">// послідовність сирих рядків</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span>
      <span class="k">yield</span> <span class="n">makeRow</span><span class="o">(</span><span class="n">row</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">tableSeq</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span><span class="nc">Listing</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>7.19 - Функціональний спосіб створити таблицю множення.</p></div>
<div class="paragraph"><p>Імперативний стиль виявляє себе в Лістинуг 7.18 в два способи. Перше, виклик <code>printMultiTable</code> має побічний ефект: друк таблиці множення на стандартний вивід. В Лістингу 7.19 ми зробили рефакторинг функції, так що вона повертає таблицю множення як рядок. Оскільки функція більше не друкує, ми переіменували її на <code>multiTable</code>. Як зазначалось до цього, одна з переваг функцій, вільних від побічних ефектів, в тому, що їх легче тестувати. Щоб протестувати <code>printMultiTable</code>, вам знадобиться якось перевизначити <code>print</code> та <code>println</code>, так що ви зможете перевірити вивід на коректність. Ви можете тестувати <code>multiTable</code> більш просто, перевіряючи рядок її результата.</p></div>
<div class="paragraph"><p>Інший промовистий знак імперативного стилю в <code>printMultiTable</code> є її цикл <code>while</code> та <code>var</code>. Для контрасту, функція <code>multiTable</code> використовує <code>val</code>, вирази <code>for</code>, допоміжні функції та виклики до <code>mkString</code>.</p></div>
<div class="paragraph"><p>Ми виділили дві допоміжні функції, <code>makeRow</code> та <code>makeRowSeq</code>, щоб спростити читанян кода. Функція <code>makeRowSeq</code> використовує вираз <code>for</code>, чий генератор ітерує по номерах стовпчиків від 1 до 10. Тіло цього <code>for</code> обчислює добуток рядка та стовпчика, визначає відступ для результату, та видає результат конкатенації рядків відступу та добутку. Результатом виразу <code>for</code> буде послідовність (деякий субклас <code>scala.Seq</code>), до міститиме ці отримані рядки як елементи. Інша допоміжна функція, <code>makeRow</code>, просто викликає <code>mkString</code> на результаті, повернутому <code>makeRowSeq</code>. <code>mkString</code> буде конкатенувати рядки в послідовності, та поверне їх як один рядок.</p></div>
<div class="paragraph"><p>Метод <code>multiTable</code> зпочатку ініціалізує <code>tableSeq</code> результатом виразу <code>for</code>, чий генератор ітерує по номерах рядків від 1 до 10, та для кожного викликає <code>makeRow</code>, щоб отримати рядок. Цей рядок отримається через <code>yield</code>; так що результатом виразу буде послідовність рядків. Єдине завдання, що залишилось, це конвертувати рядки в один рядок. Це робить виклик <code>mkString</code>, та оскільки ми передаємо <code>"\n"</code>, ми отримуємо символ нового рядка між кожним рядком. Якщо ви передасте рядок, повернутий <code>multiTable</code>, до <code>println</code>, ви побачите той самий вивід, що продукує і виклик <code>printMultiTable</code>.</p></div>
<div class="literalblock">
<div class="content">
<pre><code> 1  2  3  4  5  6  7  8  9 10
 2  4  6  8 10 12 14 16 18 20
 3  6  9 12 15 18 21 24 27 30
 4  8 12 16 20 24 28 32 36 40
 5 10 15 20 25 30 35 40 45 50
 6 12 18 24 30 36 42 48 54 60
 7 14 21 28 35 42 49 56 63 70
 8 16 24 32 40 48 56 64 72 80
 9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_9_">7.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вбудовані керівні структури Scala є мінімальними, але вони роблять свою справу. Вони роблять подібно до своїх імперативних еквівалентів, але оскільки вони схильні повертати значення, вони також підтримують функціональний стиль. Що також важливо, вони уважні щодо того, що вони оминають, таким чином лишаючи простір для однієї з найбільш потужних можливостей Scala, функціональних літералів, що будуть описані в наступній главі.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__8_2">Глава 8</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____6">Функції та замикання</h1>
<div class="paragraph"><p>Коли програма стає більшою, вам треба якийсь спосіб поділити її на меньші, більш керовані частини. Щоб поділити поток керування, Scala пропонує підхід, знайомий всім досвідченим програмістам: поділення коду на функції. Фактично, Scala пропонує декілька способів визначити фінкції, які не присутні в Java. Крім методів, що є функціями, що є членами деякого об'єкту, також є функції, що вкладені в функції, функціональні літерали, та функціональні значення. Ця глава бере вас в тур по всім цім різновидам функцій в Scala.</p></div>
<div class="sect1">
<h2 id="_8_1_">8.1 Методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Найбільш загальний спосіб визначити функцію є член деякого об'єкта; така функція називається методом. Наприклад, Лістинг 8.1 показує два методи, що разом читають файл з заданим ім'ям, та друкують всі рядки, чия довжина перевищує задану довжину. Кожний надрукований рядок має префікс з імені файлу, де він з'являєтья.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>

<span class="k">object</span> <span class="nc">LongLines</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">processFile</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">source</span><span class="o">.</span><span class="n">getLines</span><span class="o">())</span>
      <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">width</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 8.1 - <code>LongLines</code> з приватним методом <code>processLine</code>.</p></div>
<div class="paragraph"><p>Метод <code>processFile</code> приймає ім'я файлу та ширину як параметри. Він створює об'єкт <code>Source</code> з файла, в генераторі виразу <code>for</code>, викликає <code>getLines</code> на <code>source</code>. Як зазначається на Кроці 12 в Главі 3, <code>getLines</code> повертає ітератор, що провадить один рядок з файла на кожній ітерації, виключаючи символ нового рядка. Вираз <code>for</code> обробляє кожний з ціх рядків, викликаючи допоміжний метод <code>processLine</code>. Метод <code>processLine</code> приймає три параметри: ім'я файлу, ширину та рядок. Він перевіряє, чи довжина рядка більша, ніж задана довжина, і якщо це так, друкує ім'я файла, дві крапки та рядок.</p></div>
<div class="paragraph"><p>Щоб використовувати <code>LongLines</code> з командного рядка, ми створимо застосування, що очікує довжину рядка в якості свого першого аргументу командного рядка, та інтерпретує подальші аргументи як імена файлів:<span class="footnote"><br />[І цій книжці ми зазвичай не будемо перевіряти аргументи командного рядка на валідність в застосування-прикладах, обоє, щоб зберігти дерева, та зменшити шаблонний код, що може затьмарити важливий код приклада. Компромісом є те, що замість продукувати корисне повідомлення про помилку, коли отриманий поганий ввід, наше приклад застосування буде закидати виключення.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">FindLongLines</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">width</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toInt</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
      <span class="nc">LongLines</span><span class="o">.</span><span class="n">processFile</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як ви використовуєте це застосування для пошуку рядків в <code>LongLines.scala</code>, що понад 45 символів в довжину (такий тільки один):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala FindLongLines 45 LongLines.scala
LongLines.scala: def processFile(filename: String, width: Int) = {</code></pre>
</div></div>
<div class="paragraph"><p>Доки все це дуже подібне до того, що ми робити в любій об'єктно-орієнтовній мові. Однак концепція функції в  Scala є більш загальною, ніж метод. Інші шляхи Scala для вираженян функцій будуть пояснені в наступних розділах.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_2__">8.2 Локальні функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Конструкція метода <code>processFile</code> в попередньму розділі демонструє важливий принцип розробки в стилі функціонального програмування: програми мають бути розкладені на багато малих функцій, кожна з яких робить добре визначене завдання. Окремі функції часто досить малі. Перевага цього стилю в тому, що він дає програмісту багато будівельних блоків, що можуть бути гнучко скомпоновані для виконання більш складних речей. Кожний будівельний блок має бути досить простим, щоб бути індивідуально зрозумілим.</p></div>
<div class="paragraph"><p>Одна проблема з цім підходом в тому, що всі імена допоміжних функцій можуть заповнити простір імен програми. В інтерпретаторі це невелика проблема, але коли функції запаковані в повторно використовувані класи та об'єкти, бажано приховати допоміжні функції від клієнтів класу. Вони часто не мають сенсу окремо, та ви часто бажаєте зберігти досить гнучкості видалити допомжіну функцію, якщо потім перепишете клас в інший спосіб.</p></div>
<div class="paragraph"><p>В Java ваш головний інструмент для цієї цілі є приватний метод. Підхід приватних методів робить в Scala також, як демонструє Лістинг 8.1, але Scala пропонує додатковий підхід: ви можете визначити функцію всередині іншої функції. Так само, як локальні змінні, такі локальні функції видимі тільки в своєму оточуючому блоці. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">processFile</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">width</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">source</span><span class="o">.</span><span class="n">getLines</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі ми зробили рефакторинг оригінальної версії <code>LongLines</code>, показаної в Лістингу 8.1, трансформуючи приватний метод <code>processLine</code> в локальну функцію <code>processFile</code>. Щоб зробити це, ми видалили модифікатор <code>private</code>, який може бути застосований (і тілько коли потрібно) тільки для методів, та поклали визначення <code>processLine</code> всередину визначення <code>processFile</code>. Як локальна функція, <code>processLine</code> в полі зору <code>processFile</code>, але недоступна ззовні. Однак тепер, коли <code>processLine</code> визначена всередині <code>processFile</code>, стає можливим ще одне покращення. Зауважте, як <code>filename</code> та <code>width</code> передаються незмінними до допоміжної функції? Це не є необхідним, бо локальні функції можуть отримувати доступ до параметрів оточуючої їх функції. Ви можете просто використовувати параметри зовнішньої функції <code>processLine</code>, як показане в Лістингу 8.2.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>

<span class="k">object</span> <span class="nc">LongLines</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">processFile</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">processLine</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">width</span><span class="o">)</span>
        <span class="n">println</span><span class="o">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">source</span><span class="o">.</span><span class="n">getLines</span><span class="o">())</span>
      <span class="n">processLine</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 8.2 - <code>LongLines</code> з локальною функцією <code>processLine</code>.</p></div>
<div class="paragraph"><p>Простіше, чи не так? Це використання параметрів оточуючою функції є загальним та корисним прикладом загального вкладання, яке провадить Scala. Вкладання та поле зору, описані в Розділі 7.7, стосуються всіх конструкцій Scala, включаючи функції. Це простий принцип, але дуже потужний, особливо в мові з першокласними функціями.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_3__">8.3 Першокласні функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має першокласні функції. Не тільки вона визначає функції та викликає їх, але ви можете писати функції як неіменовані літерали, та потім передавати їх як значення. Ми ввели функціональні літерали в Главі 2, та показані в базовому синтаксисі на Малюнку 2.2.</p></div>
<div class="paragraph"><p>Функціональний літерал компілюється в клас, екземпляр якого створюється під час виконання, що і є значенням функції.<span class="footnote"><br />[Кожне функціональне значення є примірником деякого класу, що розширює один з <code>FunctionNtraits</code> в пакунку <code>scala</code>, такий як <code>Function0</code> для функцій без параметрів, <code>Function1</code> для функцій з одним параметром, і так далі. Кожний трейт <code>FunctionN</code> має метод <code>apply</code>, що використовується для виклику функції.]<br /></span> Таким чином, різниця між функціональними літералами і значеннями в тому, що функціональні літерали існують в джерельному коді, тоді як значення функцій існують як об'єкт під час виконання. Різниця в основному така, як між класами (джерельний код) та об'єктами (час виконання).</p></div>
<div class="paragraph"><p>Ось простий приклад функціонального літерала, що додає одиницю до числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p><code>=&gt;</code> означає, що ця функція конвертує річ зліва (любе ціле <code>x</code>) на річ зправа <code>(x + 1)</code>. Так що ця функція конвертує любе ціле <code>x</code> на <code>x + 1</code>. Значення функцій є об'єктами, так що ви можете зберігати їх в змінних, якщо бажаєте. Вони також функції, так що ви можете викликати їх, використовуючи звичайну нотацію виклику функцій з дужками. Ось приклад того і іншого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">increase</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">increase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки в цьому прикладі <code>increase</code> є <code>var</code>, пізніше ви можете присвоїти їй інше функціональне значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">9999</span>
<span class="n">increase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10009</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте більше ніж одне твердження в функціональному літералі, оточіть його тіло в фігурні дужки, та покладіть твердження по одному на рядок, таким чином формуючи блок. Так само, як в методі, коли обчислюється функціональний літерал всі твердження будуть обчислені, та буде повернуте значення з функції, що відповідає обчисленню останнього виразу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;We&quot;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;are&quot;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;here!&quot;</span><span class="o">)</span>
  <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>

<span class="n">increase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="nc">We</span>
<span class="n">are</span>
<span class="n">here</span><span class="o">!</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви бачили всі принаддя функціональних літералів та функціональних значень. Багато Scala бібліотек дають вам можливіть використовувати їх. Наприклад, метод <code>foreach</code> доступний для всіх колекцій.<span class="footnote"><br />[Метод <code>foreach</code> визначений в трейті <code>Traversable</code>, це загальний супертрейт для <code>List</code>, <code>Set</code>, <code>Array</code>, та <code>Map</code>. Дивіться Главу 17 щодо деталей.]<br /></span> Він приймає функцію як аргумент, та викликає цю функцію для кожного елемента. Ось як він може використовуватись для друку всіх елементів списка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">someNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">someNumbers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">-</span><span class="mi">11</span>
<span class="o">-</span><span class="mi">10</span>
<span class="o">-</span><span class="mi">5</span>
<span class="mi">0</span>
<span class="mi">5</span>
<span class="mi">10</span>
</pre></div></div></div>
<div class="paragraph"><p>Як інший приклад, типи колекцій мають метод <code>filter</code>. Цей метод відбирає елементи колекції, що проходять наданий користувачем тест. Цей тест надається використовуючи функцію. Наприклад, функція <code>function (x: Int) =&gt; x &gt; 0</code> може використовуватись для фільтрації. Ця функція відзеркалює додатні цілі на <code>true</code>, та всі інші на <code>false</code>. Ось як використовувати її з фільтром:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи, як <code>foreach</code> та <code>filter</code> описані далі в цій книжці. Глава 16 каже про їх використання в класі <code>List</code>. Глава 17 обговорює їх використання з іншими типами колекцій.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_4____">8.4 Короткі форми функціональних літералів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить декілька шляхів для відкидання надлишкової інформації, та написання функціональних літералів більш скорочено. Придивіться краще до ціх можливостей, оскільки вони дозволяють вам видалити безлад з вашого кода.</p></div>
<div class="paragraph"><p>Один шлях зробити функціональні літерали більш короткими, це відкинути типи парамертів. Такім чином, попередній приклад з <code>filter</code> може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">((</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор Scala знає, що <code>x</code> має бути цілим, оскільки він бачить, що ви безпосередньо фикористовуєте функцію для фільтрації списку цілих (на який посилається <code>someNumbers</code>). Це називається цільовий тип, оскільки цільове використання виразу (в цьому випадку аргумент до <code>someNumbers.filter()</code>) може впливати на тип цього виразу (в цьому випадку для визначення типу параметра <code>x</code>). Точні деталі цільової типізації не є важливі. Ви можете просто почати написання функціонального літералу без типу аргументу, та якщо компілятор збентежений додайте тип. З часом ви набудете відчуття, в яких ситуаціях компілятор може або не може вирішити загадку.</p></div>
<div class="paragraph"><p>Другий шлях видалити непотрібні символи, це прибрати дужки коло параметра, чий тип виведений. В попередньому прикладі дужки коло <code>x</code> непотрібні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_5__">8.5 Синтаксис замінника</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб зробити функціональний функціонал ще більш стислим, ви можете використовувати підкреслення для одного або більше параметрів, доки кожний параметр з'являється тільки один раз в функціональному літералі. Наприклад, <code>_ &gt; 0</code> є дуже коротка нотація для функції, що перевіряє, чи значення більше за нуль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете думати про підкреслення як про "порожнє місце" в виразі, що треба "заповнити". Пусте місце буде заповнене аргументом функції, кожний раз, коли функція викликається. Наприклад, приймаючи, що <code>someNumbers</code> було тут ініціалізоване як <code>valueList(-11, -10, -5, 0, 5, 10)</code>, метод <code>filter</code> буде замінювати порожнє місце в <code>_ &gt; 0</code> спочатку на <code>-11</code>, як в <code>-11 &gt; 0</code>, потім на <code>-10</code>, як в <code>-10 &gt; 0</code>, потім на <code>-5</code>, як в <code>- 5 &gt; 0</code>, і так далі, до кінця <code>List</code>. Таким чином, функція <code>literal _ &gt; 0</code>, еквівалентна до трохи більш балакучої <code>x =&gt; x &gt; 0</code>, як продемонстроване тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Іноді, коли ви використовуєте підкреслення як замінники для параметрів, компілятор може не мати досить інформації, щоб вивести відсутні типи параметрів. Наприклад, уявімо, що ви пишете окреме  <code>_ + _</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">missing</span> <span class="kt">parameter</span> <span class="k">type</span> <span class="kt">for</span> <span class="kt">expanded</span>
<span class="n">function</span> <span class="o">((</span><span class="n">x$1</span><span class="o">,</span> <span class="n">x$2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x$1</span><span class="o">.</span><span class="nc">$plus</span><span class="o">(</span><span class="n">x$2</span><span class="o">))</span>
       <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>In such cases, you can specify the types using a colon, like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function2</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>_ + _</code> розширюється до літерала для функції, що приймає два параметри. Ось чому ви можете писати цю коротку форму, тільки якщо кожний параметр з'являється в функціональному літералі рівно один раз. Декілька підкреслень означають декілька параметрі, не повторне використання одного параметра. Перше підкреслення представляє перший параметр, друге підкреслення - другий параметр, третє підкреслення третій параметр, і так далі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_6___">8.6 Частково застосовані функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча попередні приклади замінюють підкреслення на окремі параметри, ви також можете замітити цілий список параметрів на підкреслення. Наприклад, скоріше, ніж писати <code>println(_)</code>, ви можете написати <code>println _</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala розглядає цю коротку форму так, якби ми написали наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, підкреслення в цьому випадку не є замінником для одного параметру. Це замінник для цілого списку параметрів. Пам'ятайте, що вам треба залишити один проміжок між ім'ям функції та підкресленням; інакше компілятор буде думати, що ви посилаєтесь на інший символ, як, наприклад, мето на ім'я <code>println_</code>, що навряд чи існує.</p></div>
<div class="paragraph"><p>Коли ви використовуєте підкреслення в цей спосіб, ви пишете частково застосовану функцію. В Scala, коли ви викликаєте функцію, передаючи любі необхідні аргументи, ви застосовуєте цю функцію до аргументів. Наприклад, маючи наступну функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="n">sum</span><span class="k">:</span> <span class="o">(</span><span class="kt">a:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">b:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете застосувати функцію <code>sum</code> до аргументів <code>1</code>, <code>2</code>, та <code>3</code> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>ЧАстково застосована функція є вираз, до якого ви не застосували всі аргументи, потрібні для функції. Замість цього ви надаєте деякі, або жодних з потрібних аргументів. Наприклад, щоб створити вираз частково застосованої функції, що включає <code>sum</code>, якій ви не надаєте жодної з трьох потрібних аргументів, ви просто ставите підкреслення після <code>sum</code>. Результуюча функція потім може бути збережена в змінній. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">sum</span> <span class="k">_</span>
<span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function3</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код, компілятор Scala створює примірник функції, що приймає три цілі параметри, відсутні в виразі частково застосованої функції <code>sum _</code>, та присвоює посилання на значення цієї нової функції до змінної <code>a</code>. Потім ви застосовуєте три аргументи до значення цієї нової функції, яка в свою чергу викликає <code>sum</code>, передаючи ті самі три параметри:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось що тільки но тут відбулось: змінна на ім'я <code>a</code> посилається на об'єкт з функціональним значенням. Це функціональне значення є примірником класу, згенерованого автоматично компілятором Scala з <code>sum _</code>, вираза частково застосованої функції. Згенерований компілятором клас має метод <code>apply</code>, що приймає три аргументи.<span class="footnote"><br />[Згенерований клас розширює трейт <code>Function3</code>, що декларує метод <code>apply</code> з трьома аргументами.]<br /></span> Метод <code>apply</code> згенерованого класу приймає три аргументи, оскільки рівно стільки аргументів не вистачає в виразі <code>sum _</code>. Компілтор Scala транслює вираз <code>a(1, 2, 3)</code> на виклик меетода значення <code>apply</code>, передаючи три аргументи, <code>1</code>, <code>2</code>, та <code>3</code>. Таким чином, <code>a(1, 2, 3)</code> є скороченням для:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей метод <code>apply</code>, визначений в автоматично згенерованому класі компілятором Scala з виразу <code>sum _</code>, просто пересилає ці три невистачаючі параметри до <code>sum</code>, та повертає результат. В цьому випадку, <code>apply</code> викликає <code>sum(1, 2, 3)</code>, та повертає те, що повертає <code>sum</code>, наразі <code>6</code>. Інший спосіб думати про цей різновид виразів, в яких підкреслення використовується для представлення цілого списку параметрів, як про шлях перетворити <code>def</code> в функціональне значення. Наприклад, якщо ви маєте локальну функцію, таку як <code>sum(a: Int, b: Int, c: Int): Int</code>, ви можете "огорнути" її в функціональне значення, чий метод <code>apply</code> матиме той самий список параметрів та типи результата. Потім ви застосовуєте <code>apply</code> цього функціонального значення до деяких аргументів, який, в свою чергу, застосовує <code>sum</code> до тих самих аргументів, та повертає повернутий результат. Хоча ви не можете присвоїти метод або вкладену функцію до змінної, або передати її як аргумент до іншої функції, ви можете робити ці речі, якщо ви огорнете метод або вкладену функцію в функціональне значення, поставивши підкреслення після її імені.</p></div>
<div class="paragraph"><p>Тепер, хоча <code>sum _</code> безумовно частково застосована функція, в такий спосіб вам може не виглядати очевидним, чому вона названа саме так. Вона має це ім'я, оскільки ви не застосовуєте цю функцію до всіх аргументів. В випадку <code>sum _</code>, ви не застосували її до жодного аргументу. Але ви також можете виразити частково застосовану функцію, надавши тільки деякі з потрібних аргументів. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">Int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку ви надали перший та останній аргумент до <code>sum</code>, але не до середнього аргументу. Оскікльки один аргумент відсутній, компілятор Scala генерує функціональний клас, чий метод <code>apply</code> приймає один аргумент. Коли викликаний з одним аргументом, метод <code>apply</code> цієї згенерованої функції викликає <code>sum</code>, передаючи <code>1</code>, аргумент, переданий до функції, та <code>3</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку <code>b.apply</code> викликає <code>sum(1, 2, 3)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>І в цьому випадку <code>b.apply</code> викликає <code>sum(1, 5, 3)</code>.</p></div>
<div class="paragraph"><p>Якщо ви пишете частково застосовану функцію, в якій ви залишаєте всі параметри, таку як <code>println _</code> або <code>sum _</code>, ви можете виразити її більш стисло, відкинувши підкреслення, коли функція потрібна в цьому місці в коді. Наприклад, замість друкувати кожне число в <code>someNumbers</code> (визначена тут) ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете просто записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця остання форма дозволяється тільки в місціх, де потрібна функція, таких, як виклик  <code>foreach</code> в цьому прикладі. В цьому випадку компілятор знає що потрібна функція, оскільки <code>foreach</code> вимагає, щоб в якості аргумента була передана функція. В ситуаціях, коли функція не вимагається, спроба використати цю форму спричинить помилку компіляції. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">sum</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">missing</span> <span class="kt">arguments</span> <span class="kt">for</span> <span class="kt">method</span> <span class="kt">sum</span><span class="o">;</span>
<span class="n">follow</span> <span class="k">this</span> <span class="n">method</span> <span class="k">with</span> <span class="err">`</span><span class="k">_</span><span class="err">&#39;</span> <span class="k">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">treat</span> <span class="n">it</span> <span class="n">as</span> <span class="n">a</span>
<span class="n">partially</span> <span class="n">applied</span> <span class="n">function</span>
       <span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">sum</span>
               <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="n">sum</span> <span class="k">_</span>
<span class="n">d</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function3</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">d</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">60</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_7_">8.7 Замикання</h2>
<div class="sectionbody">
<div class="paragraph"><p>Докі в цій главі всі приклади функціональних літералів посилались тільки для переданих параметрів. Наприклад, в <code>(x: Int) =&gt; x &gt; 0</code>, єдиною змінною, що використовується в тілі функції, <code>x &gt; 0</code>, <code>x</code>, що визначається як параметр функції. Однак ви можете посилатись на змінні, визначені деінде:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span> <span class="c1">// наскільки much?</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція додає <code>more</code> до свого аргументу, але що таке <code>more</code>? З точки зору цієї функції, <code>more</code> є <em>вільна змінна</em>, оскільки сам функціональний літерал сам по собі не надає їй значення. На відміну, змінна <code>x</code> є <em>прив'язаною змінною</em>, оскільки вона має значення в контексті функції: вона визначена як єдиний параметр функції, <code>Int</code>. Якщо ви спробуєте використати цей функціональний літера сам по собі, без деякого <code>more</code>, визначеного в полі зору, компілятор буде скаржитись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="kt">value</span> <span class="kt">more</span>
               <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
                               <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="____7">Чому завершуюче підкреслення?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис Scala для частково застосованих функцій підкреслює різницю між компромісами дизайну Scala, та класичних функціональних мов, таких як <code>Haskell</code> або <code>ML</code>. В ціх мовах, частково застосовані функції розглядаються як звичайний випадок. Більше того, ці мови мають досить сувору статичну систему типів, що зазвичай буде підкреслювати кожну помилку з частковим застосуванням, що ви можете зробити. Scala дотримується значно блищого відношення до імперативних мов, таких як Java, де метод, що не застосовується до всіх своїх аргументів розглядається як помилка. Більше того, об'єктно-орієнтовні традиції субтипізації і універсального кореневого типу приймає деякі програми, що мали б розглядатись як помилкові в класичних функціональних мовах.</p></div>
<div class="paragraph"><p>Наприклад, скажімо, ви переплутали метод <code>drop(n: Int)</code> в <code>List</code> з <code>tail()</code>, і, таким чином, забули, що вам треба передати число до <code>drop</code>. Ви можете записати <code>println(drop)</code>. Коли б Scala приймала класичну функціональну традицію, що частково застосовані функції гарні будь-де, цей код пройшов би перевірку типів. Однак ви можете бути здивовані знайти, що результат, який буде друкувати це твердження <code>println</code>, буде завжди <code>&lt;function&gt;</code>! Що відбуєеться, це те, що вираз <code>drop</code> буде трактуватись як функціональний об'єкт. Оскільки  <code>println</code> приймає об'єкти любого типу, це буде компілюватись OK, але це матиме непередбачуваний результат.</p></div>
<div class="paragraph"><p>Щоб уникати ситуацій як така, Scala звичайно потребує, щоб ви вказували аргументи функцій, що зщалишились, явно, навіть якщо вони вказані так просто, як символом <code>_</code>. Scala дозволяє вам відкинути <code>_</code> тільки коли очікується функціональний тип. З іншого боку, той же функціональний літерал буде робити добре, доки доступне дещо на ім'я <code>more</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">more</span> <span class="k">=</span> <span class="mi">1</span>
<span class="n">more</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">addMore</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
<span class="n">addMore</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addMore</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Функціональне значення (об'єкт), що створений під час виконання з цього функціонального літерала, називається <em>замиканням</em>. Назва походить з дії "замикання" функціонального літерала, через "захоплення" прив'язок його вільних змінних. Функціональний літерал без вільних змінних, такий як <code>(x: Int) =&gt; x + 1</code>, називається <em>замкненим термом</em>, де <em>терм</em> це фрагмент джерельного коду. Таким чином, функціональне значення, створене під час виконання з цього функціонального літерала не є замиканням в суворішому сенсі, оскікльи <code>(x: Int) =&gt; x + 1</code> вже замкнений як є написаний. Але кожний функціональний літерал з вільними змінними, як <code>(x: Int) =&gt; x + more</code>, є <em>відкритим термом</em>. Таким чином, любе функціональне значення, створене під час виконання з <code>(x: Int) =&gt; x + more</code> буде, по визначення, потребувати, щоб прив'язка до вільної змінної  <code>more</code> була захоплена. Отримане функціональне значення, що буде містити посилання на захоплену змінну <code>more</code>, називається замиканням, оскільки значення функції є кінцевим продуктом дії замикання відкритого терму <code>(x: Int) =&gt; x + more</code>.</p></div>
<div class="paragraph"><p>This example brings up a question: What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change. For example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">more</span> <span class="k">=</span> <span class="mi">9999</span>
<span class="n">more</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9999</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addMore</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10009</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтуітивно, замикання Scala захоплюють самі змінні, не значення, на які посилаються змінні.<span class="footnote"><br />[На відміну, внутрішні класи Java взагалі не дозволяють вам отримувати доступ до непостійних змінних в оточуючому полі зору, так що немає різниці між захопленням змінної, та захопленням її поточного значення.]<br /></span> Як показує попередній приклад, замикання, створене для <code>(x: Int) =&gt; x + more</code> бачить зміни в <code>more</code>, зроблені за межами замикання. Те саме вірно в зворотньому напрямку. Зміни, зроблені в замиканні до захопленої змінної, видимі за межами замикання. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">someNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">someNumbers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="k">_</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад використовує обхідний шлях до підрахунку суми чисел в <code>List</code>. Змінна <code>sum</code> знаходиться в оточуючому полі зору відносно функціонального літерала <code>sum += _</code>, що додає числа до <code>sum</code>. Навіть зважаючи, що це замикання модифікує <code>sum</code> під час виконання, результуючий загал, <code>-11</code>, все ще видимий за межами замикання.</p></div>
<div class="paragraph"><p>Що буде, якщо замикання має доступ до деякої змінної, що має декілька різних копій по мірі роботи програми? Наприклад, якщо замикання використовує локальну змінну деякої функції, та функція викликається декілька раз? ЯКий примірник цієї змінної буде використовуватись при кожному доступі?</p></div>
<div class="paragraph"><p>Тільки одна відповідь узгоджена з залишком мови: використовується той примірник, що був активний під час створення замикання. Наприклад, ось функція, що створює та повертає замикання "збільшити":</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">makeIncreaser</span><span class="o">(</span><span class="n">more</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний раз, коли викликається ця функція, вона буде створювати нове замикання. Кожне замикання буде отримувати доступ до змінної <code>more</code>, що була активною під час створення змінної.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">inc1</span> <span class="k">=</span> <span class="n">makeIncreaser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">inc1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">inc9999</span> <span class="k">=</span> <span class="n">makeIncreaser</span><span class="o">(</span><span class="mi">9999</span><span class="o">)</span>
<span class="n">inc9999</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви викликаєте <code>makeIncreaser(1)</code>, створюється та повертається замикання, що захоплює значення <code>1</code> як прив'язку для <code>more</code>. Подібним чином, коли ви викликаєте <code>makeIncreaser(9999)</code>, повертається замикання, що захоплює значення <code>9999</code> для <code>more</code>. Коли ви застосовуєте ці замикання для аргументів (в цьому випадку є тільки один аргумент, <code>x</code>, що має бути переданий), результат, що повертається, залежить від того, як було визначене <code>more</code> при створенні замикання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">inc1</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">inc9999</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10009</span>
</pre></div></div></div>
<div class="paragraph"><p>Немає різниці, що <code>more</code> в цьому випадку є параметром до виклику метода, який вже завершився. Компілятор Scala переставляє речі в випадках як цей, так що захоплений параметр живе в кіпі, замість стеку, і, таким чином, може пережити виклик метода, що створює його. Ця перестановка турботливо виконується автоматично, так що вам не треба про це турбуватись. Обчислюйте любу змінну, яку побажаєте: <code>val</code>, <code>var</code>, або параметр.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_8____">8.8 Спеціальні форми виклику функцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Більшість функцій та викликів функцій, які вам трапляться, будуть такі, які ви вже бачили в цій главі. Функція буде мати фіксоване число параметрів, виклик буде мати так же число аргументів, та аргументи будуть вказані в такому ж порядку та числі, що і параметри.</p></div>
<div class="paragraph"><p>Одонак, оскільки виклики функцій є такими центральними для програмування в Scala, були додані декілька особливих форм визначення та викликів функцій, що націлені на вирішення особливих потреб. Scala підтримує повторювані параметри, іменовані аргументи та значення по замовчанню.</p></div>
<div class="sect2">
<h3 id="_repeated_parameters">Repeated parameters</h3>
<div class="paragraph"><p>Scala дозволяє вам вказати, що вписок параметрів до функції може бути повторений. Це дозволяє клієнтам передати до функції список аргументів змінної довжини. Щоб позначити повторюваний параметр, поставьте зірочку після типу параметру. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">echo</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span> <span class="k">=</span>
<span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="n">echo</span><span class="k">:</span> <span class="o">(</span><span class="kt">args:</span> <span class="kt">String*</span><span class="o">)</span><span class="kt">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначений таким чином, <code>echo</code> може бути викликаний з нулем або багатьма аргументів <code>String</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">)</span>
<span class="n">one</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world!&quot;</span><span class="o">)</span>
<span class="n">hello</span>
<span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>Всередині функції тип повторюваного параметру є <code>Array</code> декларованого типу параметру. Таким чином, тип <code>args</code> всередині функції <code>echo</code>, що декларований як тип <code>String*</code> насправді є <code>Array[String]</code>. Тим не менш, якщо ви маєте масив відповідного типу, ви можете спробувати передати його як повторюваний параметр, але отримаєте помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;What&#39;s&quot;</span><span class="o">,</span> <span class="s">&quot;up&quot;</span><span class="o">,</span> <span class="s">&quot;doc?&quot;</span><span class="o">)</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">What</span><span class=" -Symbol">&#39;s</span><span class="o">,</span> <span class="n">up</span><span class="o">,</span> <span class="n">doc</span><span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>    <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">required</span> <span class="k">:</span> <span class="kt">String</span>
              <span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб досягти цього, вам треба додати аргумент масиву з двокрапкою, та символ <code>_*</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
<span class="nc">What</span><span class=" -Symbol">&#39;s</span>
<span class="n">up</span>
<span class="n">doc</span><span class="o">?</span>
</pre></div></div></div>
<div class="paragraph"><p>ЦЯ нотація каже компілятору передати кожний елемент <code>arr</code> як окремий аргумент, ніж всі разом як один аргумент.</p></div>
</div>
<div class="sect2">
<h3 id="___14">Іменовані аргументи</h3>
<div class="paragraph"><p>В звичайному виклику функції аргументи в виклику співпадають один до одного в порядку параметрів викликаної функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">speed</span><span class="o">(</span><span class="n">distance</span><span class="k">:</span> <span class="kt">Float</span><span class="o">,</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span>
         <span class="n">distance</span> <span class="o">/</span> <span class="n">time</span>
<span class="n">speed</span><span class="k">:</span> <span class="o">(</span><span class="kt">distance:</span> <span class="kt">Float</span><span class="o">,</span> <span class="kt">time:</span> <span class="kt">Float</span><span class="o">)</span><span class="nc">Float</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">speed</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому виклику <code>100</code> відповідає до <code>distance</code>, та <code>10</code> до <code>time</code>. <code>100</code> та <code>10</code> співпадають в тому ж порядку, в якому перелічені формальні параметри.</p></div>
<div class="paragraph"><p>Іменовані аргументи дозволяють передати вам аргументи в функцію в іншому порядку. Синтаксис просто полягає в тому, що перед кожним аргументом стоіть ім'я параметру та знак рівності. Наприклад, наступний виклик до <code>speed</code> еквівалентний до <code>speed(100,10)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">speed</span><span class="o">(</span><span class="n">distance</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Called with named arguments, the arguments can be reversed without changing the meaning:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; speed(time = 10, distance = 100)
res29: Float = 10.0</code></pre>
</div></div>
<div class="paragraph"><p>Також можливо змішувати позиційні та іменовані аргументи. В цьому випадку позщиційні аргументи ідуть першими. Іменовані аргументи найбільш часто використовуються в комбінації зі заначеннями параметрів по замовчанню.</p></div>
</div>
<div class="sect2">
<h3 id="_____9">Значення параметрів по замовчанню</h3>
<div class="paragraph"><p>Scala дозволяє вам вказувати значення по замовчанню для параметрів функцій. Аргумент для кожного такого параметру може бути опціонально пропущений в виклику функції, та в такому випадку відповідний аргумент буде заповнений значенням по замовчанню.</p></div>
<div class="paragraph"><p>Приклад показаний в Лістингу 8.3. Функція <code>printTime</code> маж один параметр, <code>out</code>, і він має значення по замовчанню <code>Console.out</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printTime</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">java.io.PrintStream</span> <span class="o">=</span> <span class="n">`Console.out`</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;time = &quot;</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Listing 8.3 - Параметр зі значенням по замовчанню.</p></div>
<div class="paragraph"><p>Якщо ви викличете функцію як <code>printTime()</code>, таким чином не вказуючи аргумента, що буде вказувати на пристрій виводу <code>out</code>, тоді <code>out</code> буде встановлений в його значення по замовчанню, <code>Console.out</code>. Ви можете також викликати функцію з явним потоком виводу. Наприклад, ви можете надіслати журналювання до стандарного виводу помилок, викликавши функцію як <code>printTime(Console.err)</code>. Параметри по замовчанню особливо корисні, коли використовуються в комбінації з іменованими параметрами. В Лістигу 8.4 функція <code>printTime2</code> має два опціональні параметри. Параметр <code>out</code> має по замовчанню значення <code>Console.out</code>, та параметр <code>divisor</code> має значення по замовчанню <code>1</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printTime2</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">java.io.PrintStream</span> <span class="o">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">out</span><span class="o">,</span>
               <span class="n">divisor</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span>
<span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;time = &quot;</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()/</span><span class="n">divisor</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 8.4 - Функція з двома параметрами, що мають значення по замовчанню.</p></div>
<div class="paragraph"><p>Функція <code>printTime2</code> може бути викликана як <code>printTime2()</code> щоб мати обоє свої параметри заповненими їх значеннями по замовчанню. Однак через іменовані аргументи один з параметрів може бути заданий, коли інший буде встановлений по замовчанню. Щоб вказати вихідний потік, викличте функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">printTime2</span><span class="o">(</span><span class="n">out</span> <span class="k">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб задати дільник часу, викличте його так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">printTime2</span><span class="o">(</span><span class="n">divisor</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_9__">8.9 Хвостова рекурсія</h2>
<div class="sectionbody">
<div class="paragraph"><p>В розділі 7.2 ми згадували, що для трансформації цикла <code>while</code>, що оновлює <code>var</code>, на більш функціональний стиль, що використовує тільки <code>val</code>, ви можете іноді потребувати використання рекурсії. Ось приклад рекурсивоної функції, що апроксимує значення, постійно покращуючи здогадку, доки вона не стане досить гарною:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">approximate</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span> <span class="n">guess</span>
  <span class="k">else</span> <span class="n">approximate</span><span class="o">(</span><span class="n">improve</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція як ця часто використовується в проблемах пошуку, з відповідними реалізаціями <code>isGoodEnough</code> та <code>improve</code>. Якщо ви бажаєте, щоб функція <code>approximate</code> виконувались скоріше, ви можете підпасти в спокусу написати цикл <code>while</code>, що спробувати пришвидшити її, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">approximateLoop</span><span class="o">(</span><span class="n">initialGuess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">guess</span> <span class="k">=</span> <span class="n">initialGuess</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span>
    <span class="n">guess</span> <span class="k">=</span> <span class="n">improve</span><span class="o">(</span><span class="n">guess</span><span class="o">)</span>
  <span class="n">guess</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Яка з двох версій <code>approximate</code> переважає? В термінах краткості та уникнення <code>var</code> перша, функціональна, перемагає. Але імперативний підхід, можливо, більш ефективний? Фактично, якщо заміряти час виконання, з'ясується, що вони майже ідеально однакові!</p></div>
<div class="paragraph"><p>Це може виглядати несподіванкою, оскільки рекурсивний виклик виглядає значно більш "коштовним", чи простий стрибок з кінця циклу на початок. Однак в випадку <code>approximate</code> вище компілятор Scala здатний застосувати важливу оптимізацію. Зверніть увагу, що рекурсивний виклик є останєю річчю, що трапляється в обчисленні тіла функції <code>approximate</code>. Функції як <code>approximate</code>, що викликають себе як свою останню дію, називаються хвостово рекурсивними. Компілятор Scala детектує хвостову рекурсію, та замінює його на стрибок назад, на початок функції, після оновлення параметрів функції новими значеннями.</p></div>
<div class="paragraph"><p>Мораль цього в том, що ви не повинні цураитсь використання рекурсивних алгоритмів для вирішення ваших проблем. Часто рекурсивне рішення є більш елегантним та стислим, ніж базований на циклі. Як рішення має хвостову рекурсію, не виникне ніякого навантаження часу виконання, що треба сплачувати.</p></div>
<div class="sect2">
<h3 id="______5">Трасування функцій з хвостовою рекурсією</h3>
<div class="paragraph"><p>Функція з хвостовою рекорсією не буде будувати новий фрейм стека для кожного виклика; всі виклики будуть викликатись в одному фреймі. Це може бути несподіванкою для програмістів, коли вони переглядатимуть трасу стеку програми, що схибила. Наприклад, ця функція викликає сама себе деяке число разів, та потім закидає виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">boom</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;boom!&quot;</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">boom</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція не має хвостової рекурсії, оскільки вона виконує операцію інкремента після рекурсивного виклику. Ви отримаєте те що очікували, якщо запустите цю програму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">boom</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">boom!</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="o">...</span>

<span class="n">Оптимізаця</span> <span class="n">хвостової</span> <span class="n">рекурсії</span>
</pre></div></div></div>
<div class="paragraph"><p>Скомпільований код для <code>approximate</code> в основному є те саме, що і скомпільований код для <code>approximateLoop</code>. Обоє функції компілюються до тих самих тринадцяти інструкцій байткоду Java. Якщо ви подивитесь на байткод, згенерований компілятором Scala для метода з хвостовою рекурсією, <code>approximate</code>, ви побачите, що хоча обоє, <code>isGoodEnough</code> та <code>improveare</code> викликаються в тілі метода, <code>approximate</code> - ні. Компілятор Scala оптимізував геть рекурсивний виклик:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">double</span> <span class="n">approximate</span><span class="o">(</span><span class="n">double</span><span class="o">);</span>
  <span class="nc">Code</span><span class="k">:</span>
  <span class="err">0</span><span class="kt">:</span>    <span class="kt">aload_0</span>
  <span class="mi">1</span><span class="k">:</span>    <span class="kt">astore_3</span>
  <span class="mi">2</span><span class="k">:</span>    <span class="kt">aload_0</span>
  <span class="mi">3</span><span class="k">:</span>    <span class="kt">dload_1</span>
  <span class="mi">4</span><span class="k">:</span>    <span class="kt">invokevirtual</span> <span class="k">#</span><span class="err">24</span><span class="o">;</span> <span class="c1">//Method isGoodEnough:(D)Z</span>
  <span class="mi">7</span><span class="k">:</span>    <span class="kt">ifeq</span>  <span class="err">12</span>
  <span class="err">10</span><span class="kt">:</span>   <span class="kt">dload_1</span>
  <span class="mi">11</span><span class="k">:</span>   <span class="kt">dreturn</span>
  <span class="mi">12</span><span class="k">:</span>   <span class="kt">aload_0</span>
  <span class="mi">13</span><span class="k">:</span>   <span class="kt">dload_1</span>
  <span class="mi">14</span><span class="k">:</span>   <span class="kt">invokevirtual</span> <span class="k">#</span><span class="err">27</span><span class="o">;</span> <span class="c1">//Method improve:(D)D</span>
  <span class="mi">17</span><span class="k">:</span>   <span class="kt">dstore_1</span>
  <span class="mi">18</span><span class="k">:</span>   <span class="kt">goto</span> <span class="err">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви тепер модифікуєте <code>boom</code>, так, щоб вона тепер стала хвостово рекурсивною:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">bang</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;bang!&quot;</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">bang</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">bang</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">bang!</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>НА цей раз ви бачите тільки один фрейм стеку для <code>bang</code>. Ви можете думати, що <code>bang</code> впала до того, як викликати себе, але це не той випадок. Якщо ви думаєте, що ви можете бути збентежені через хвостовою оптимізацією, коли переглядаєте на трасу стеку, ви можете відключити її, надавши наступний аргумент до оболонки <code>scala</code> або компілятору <code>scalac</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>-g:notailcalls</code></pre>
</div></div>
<div class="paragraph"><p>Коли вказана ця опція ви знову отримаєте довшу трасу стеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">bang</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">bang!</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span> <span class="o">...</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____8">Обмеження хвостової рекурсії</h3>
<div class="paragraph"><p>Використання хвостової рекурсії в Scala є досить обмеженої, оскільки набір інструкцій JVM робить реалізацію більш розвинених форм хвостової рекурсії дуже складною. Scala тільки оптимізує прямі рекурсивні виклики назад, до тої самої функції, що робить виклики. Якщо рекурсія непряма, оптимізація неможлива:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isEven</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="kc">true</span> <span class="k">else</span> <span class="n">isOdd</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">def</span> <span class="n">isOdd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="kc">false</span> <span class="k">else</span> <span class="n">isEven</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також не отримаєте хвостову оптимізацію, якщо фінальний виклик іде до функціонального значення. Розгляньте наприклад наступний рекурсивний код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">funValue</span> <span class="k">=</span> <span class="n">nestedFun</span> <span class="k">_</span>
<span class="k">def</span> <span class="n">nestedFun</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span> <span class="n">funValue</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення змінної <code>funValue</code> посилається на функціональне значення, що в основному огортає виклик до <code>nestedFun</code>. Коли ви застосовуєте функціональне значення до аргументу, він робить свій хід, застосовує <code>nestedFun</code> до того самого аргументу, та повертає результат. Таким чином, ви маєте надію, що компілятор Scala буде робити хвостову оптимізацію, але в цьому випадку цього не буде. Оптимізація хвостового виклику обмежена до ситуацій, коли метод або вкладена функція викликає себе напряму в якості своєї останньої операції, без проходженню через функціональне значення, або деякий інший посередник. (Якщо ви досі не повністю розумієте хвостову рекурсію, дивіться Розділ 8.9).</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_10_">8.10 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала вам гранд тур по функціях в Scala. На додаток до методів, Scala провадить локальні функції, функціональні літерали та функціональні значення. На додаток до нормальних функціональних викликів Scala провадить частково застосовані функції, та функції з повторюваними параметрами. Коли можливо, функціональні виклики реалізовані як оптимізовані хвостові виклики, і, таким чином, багато гарно виглядаючих рекурсивних функцій роблять так само швидко, як і оптимізовані вручну версії, що використовують цикли <code>while</code>. Наступна глава буде будуватись на ціх засадах, та покаже, як багата підтримка функцій в Scala допомагає вам абстрогуватись над керуванням.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__9">Глава 9</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___15">Абстракції керування</h1>
<div class="paragraph"><p>В Главі 7 ми вказали, що Scala не має багато вбудованих абстракцій керування, оскільки вона надає вам можливість створювати ваші власні. В попередній главі ви навчились щодо функціональних значень. В цій главі ми покажемо вам, як застосовувати функціональні значення для створення нових абстракцій керування. По ходу справи ми вивчимо, що таке карування та параметри за ім'ям.</p></div>
<div class="sect1">
<h2 id="_9_1___">9.1 Зменьшення дублікації коду</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі функції поділяються на загальні частини, що є ті самі за кожного виклику функції, та незагальні частини, що можуть змінюватись від одного виклику до іншого. Загальні частини знаходяться в тілі функції, тоді як незагальні частини мають бути надані через аргументи. Коли ви використовуєте функцію як аргумент, незагальна частина алгоритму сама є деяким іншим алгоритмом! За кожного виклику такої функції ви можете передати інше функціональне значення як аргумент, і викликана функція буде, за своїм вибором, викликати передане функціональне значення. Ці <em>функції вищих порядків</em> — функції, що приймають функції як параметри, даватимуть вам додаткові можливості стиснути та спростити код.</p></div>
<div class="paragraph"><p>Одна з вигод функцій вищого порядку в тому, що вони надають можливість створювати керівні абстракції, які дозволяють вам зменшити дублікацію кода. Наприклад, уявімо, що ви пишете переглядач файлів, і ви бажаєте впровадити API, що дозволяє користувачам шукати файли, які співпадають з деяким критерієм. Перше, ви додаєте можливість пошуку файлів, чиє ім'я закінчується на певний рядок. Це надасть можливість вашим користувачам шукати, наприклад, всі файли з розширенням <code>.scala</code>. Ви можете провадити таке API, визначивши публічний метод <code>filesEnding</code> в об'єкті синглтоні, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">FileMatcher</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

  <span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
      <span class="k">yield</span> <span class="n">file</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>filesEnding</code> отримує список з усіх файлів в поточній директорії, використовуючи приватний допоміжний метод <code>filesHere</code>, потім фільтрує їх на сонові того, чи ім'я кожного файлу завершується на вказаний користувачем суфікс. Зважаючи що <code>filesHere</code> є приватним, метод <code>filesEnding</code> є єдиним доступним методом в  <code>FileMatcher</code>, API, що ви провадите для своїх користувачів.</p></div>
<div class="paragraph"><p>Докі все гарно, і немає коду, що повторюється. Однак пізніше ви вирішуєте дозволити людям шукати на основі любої частини імені файла. Це гарно, коли користувачі не пам'ятають, чи вони назвали файл <code>phb-important.doc</code>, <code>stupid-phb-report.doc</code>, <code>may2003salesdoc.phb</code>, або якось зовсім інакше; вони можуть тільки запам'ятати, що десь в імен з'являється <code>phb</code>. Ви повертаєтесь до роботи, і додаєте цю функцію до вашого <code>FileMatcher API</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція робить так само, як <code>filesEnding</code>. Вона шукає <code>filesHere</code>, перевіряє ім'я, та повертає файл, якщо ім'я співпадає. Одна різниця в тому, що ця функція використовує <code>contains</code> замість <code>ofendsWith</code>.</p></div>
<div class="paragraph"><p>Пройшли місяці, і програма стала більш успішною. З часом ви отримуєте запит від декількох досвідчених користувачів, які бажають шукати на основі регулярних запитів. Ці недбалі хлопці мають величезні каталоги з тисячами файлів, і вони бажають робити такі речі, як шукати всі файли <code>pdf</code>, що мають десь в назві <code>"oopsla"</code>. Щоб підтримати їх, ви пишете цю функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>ДОсвідчені програмісти зауважать всі ці повторення, та поміркують, чи не можна все це винести в загальну допоміжну функцію. Однак, якщо зробити це в очевидний спосіб не буде робити. Ви, можливо, хотіли б зробити щось таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="kc">null</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей підхід буде робити в деяких динамічних мовах, але Scala не дозволяє зліплювати код разом під час виконання, як тут. Так що ви можете зробити?</p></div>
<div class="paragraph"><p>Функціональні значення провадять відповідь. Хоча ви не можете передати по колу ім'я метода як значення, ви можете досягти того ж ефекту, передаючи по колу функціональне значення, що викликає метод за вас. В цьому випадку ви можете додати до метода параметр <code>matcher</code>, чиє єдине призначення є перевіряти ім'я файлу відносно деякого запиту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">matcher</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">matcher</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">,</span> <span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій версії метода, вираз <code>if</code> тепер використовує <code>matcher</code> для перевірки імені файла відносно запиту. Що в точності це перевіряє залежить від того, що вказане як <code>matcher</code>. Тепер погляньте на тип самого <code>matcher</code>. Це функція, і таким чином має <code>=&gt;</code> в своєму типі. Ця функція приймає два рядкових аргумента, ім'я файлу та запит, та повертає логічне значення, так що тип цієї функції є <code>(String, String) =&gt; Boolean</code>.</p></div>
<div class="paragraph"><p>Маючи цей новий допоміжний метод <code>filesMatching</code> ви можете спростити три пошукові методи, щоб вони викликати допоміжний метод, якому передається відповідна функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>

<span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>

<span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Функціональні літерали, показані в цьому прикладі, використовують синтаксис замінників, введений в попередній главі, що, можливо, не є досі природним для вас. Так що ось роз'яснення як роблять замінники: функціональний літерал</p></div>
<div class="listingblock">
<div class="content">
<pre><code>_.endsWith(_)</code></pre>
</div></div>
<div class="paragraph"><p>використаний в методі <code>filesEnding</code>, означає те саме, що і:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fileName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>filesMatching</code> приймає функцію, що потребує два аргумента <code>String</code>, вам не треба вказувати типи його аргументів; ви можете просто писати <code>(fileName, query) =&gt; fileName.endsWith(query)</code>. Оскільки параметри використовуються тільки по одному разу кожний в тілі функції (тобто, перший параметр, <code>fileName</code>, використовується першим в тілі, та другий параметр, <code>query</code>, використовується другим), ви можете використовувати синтаксис замінників: <code>_.endsWith(_)</code>. Перше підкреслення є замінником для першого параметру, імені файлу, та друге підкреслення замінником для другого параметру, рядка запиту.</p></div>
<div class="paragraph"><p>Цей код вже спрощений, але насправді він може бути ще коротший. Зауважте, що щапит був переданий до <code>filesMatching</code>, але <code>filesMatching</code> нічого не робить з <code>query</code>, крім того, що передає назад, до функції <code>matcher</code>. Це пересилання туди і назад непотрібне, оскільки викликач вже знає <code>query</code>, з якого починати! Ви можете також видалити параметр <code>query</code> з <code>filesMatching</code> та <code>matcher</code>, тим самим спростивши код так, як показано в Лістингу 9.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">FileMatcher</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">matcher</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">matcher</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">))</span>
      <span class="k">yield</span> <span class="n">file</span>

  <span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.1 - Використання замикань для зменьшення дублікації коду.</p></div>
<div class="paragraph"><p>Цей приклад демонструє спосіб, в який першокласні функції можуть допомогти уникнути дублікації коду, коли б це було дуже складно зробити без них. Наприклад, в Java ви можете створити інтерфейс, що містить метод, що приймає <code>String</code> та повертає <code>Boolean</code>, потім створити та передати примірники анонімних внутрішніх класів, що реалізують цей інтерфейс до <code>filesMatching</code>. Хоча цей підхід буде видаляти дублікацію, якої ми бажаємо уникнути, він буде, в той самий час, стільки ж, або більше, нового коду. Таким чином, вигоди не вартують ціли, і ви можете так само гарно жити з дублікацією.</p></div>
<div class="paragraph"><p>Більше того, цей приклад демонструє, як замикання можуть допомогти зменшити дублікацію коду. Функціональні літерали, використані в попередньому прикладі, такі як <code>_.endsWith(_)</code> та <code>_.contains(_)</code>, під час виконання утворюють примірники функціональних значень, що не є замиканнями, бо вони не захоплюють жодних вільних змінних. Обі змінні, використані в вирарзі, наприклад, <code>_.endsWith(_)</code>, представлені підкресленнями, що означає, що вони взяті з аргументів функції. Таким чином, <code>_.endsWith(_)</code> використовує дві прив'язані змінні, і жодних вільних змінних. Для контрасту, функціональний літерал <code>_.endsWith(query)</code>, використана в останньому прикладі, містить прив'язану змінну, аргумент, представлений підкресленням, та одну вільну змінну на ім'я <code>query</code>. Це так тільки через те, що Scala підтримує замикання, так що ви були в змозі видалити параметр <code>query</code> з <code>filesMatching</code> в самому останньому прикладі, тим самим ще більше скоротивши код.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_2___">9.2 Спрощення клієнтського кода</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад демонструє, що функції вищого порядку можуть допомогти зменьшити дублікацію кода, коли ви реалізуєте API. Але важливе використання функцій вищого порядку є покладання їх в саме API, щоб зробити клієнтський код більш стислим. Гарний приклад надається методами циклів спеціального призначення на типах колекцій Scala.<span class="footnote"><br />[Ці методи циклів спеціального призначення визначені в трейті <code>Traversable</code>, що розширюється <code>List</code>, <code>Set</code>, та <code>Map</code>. Дивіться Главу 17 щодо дискусії.]<br /></span> Багато з них перелічені в Таблиці 3.1 в Главі 3, але поки ми поглянемо тільки на один приклад, щоб побачити, чому ці методи такі користні.</p></div>
<div class="paragraph"><p>Розглянемо метод <code>exists</code>, що визначає, чи передане значення міститься в колекції. Звичайно, ви можете шукати елементи, маючи <code>var</code> ініціалізоване в <code>false</code>, в циклі переглядадти колекцію, перевіряючи кожний елемент, та встановити <code>var</code> в <code>true</code>, якщо ви знайдете те, що шукаєте. Ось метод, що використовує цей підхід для визначення, чи переданий <code>List</code> містить від'ємне число:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsNeg</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">exists</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">num</span> <span class="k">&lt;-</span> <span class="n">nums</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">exists</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="n">exists</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви визначите цей метод в інтерпретаторі, ви зможете викликати його ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак більш стислий шлях визначити цей метод, це викликати функцію вищого порядку <code>exists</code> на переданому <code>List</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsNeg</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">nums</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця версія <code>containsNeg</code> видає той самий резільтат, що і попередній:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>exists</code> представляє абстракцію керування. Це циклічна конструкція особливого призначення, запровадженна бібліотекою Scala, скоріше ніж вбудована в мову Scala, як <code>while</code> або <code>for</code>. В попередньому розділі функція вищого порядку, <code>filesMatching</code>, зменьшує дублікацію коду в реалізації об'єкта <code>FileMatcher</code>. Метод <code>exists</code> провадить подібну перевагу, але оскільки <code>exists</code> є публічним в API колекцій Scala, дублікація коду, який він зменшує, є клієнтський код цього API. Якщо б не існував <code>exists</code>, і ви б бажали написати метод <code>containsOdd</code> для перевірки, чи список містить непарні числа, ви б могли написати це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsOdd</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">exists</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">num</span> <span class="k">&lt;-</span> <span class="n">nums</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
      <span class="n">exists</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">exists</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви порівняєте тіло <code>containsNeg</code> з таким в <code>containsOdd</code>, ви знайдете, що все повторюється, за винятком умови перевірки в виразі <code>if</code>. Використовуючи <code>exists</code>, замість ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsOdd</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">nums</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тіло кода в цій версії знову ідентичне до тіла відповідного метода <code>containsNeg</code> (версія, що використовує <code>exists</code>), за винятком того, що відрізняється умова, по якій виконується пошук. Знову, кількість дублікованого коду є значно меньшим, оскільки вся циклічна інфраструктура виділена в самий метод <code>exists</code>. В стандартній бібліотеці Scala існує багато інших циклічних методів. Як і з <code>exists</code>, вони часто можуть скоротити ваш код, якщо ви розпізнаєте можливість використати їх.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_3_">9.3 Карування</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Главі 1 ми казали, що Scala дозволяє вам створювати нові абстракції керування, що "відчуваються як природна підтримка мови". Хоча приклади, що ви бачили досі, напевне є абстраціями керування, навряд що хтось помилково зплутає їх з природною підтримкою мови. Щоб зрозуміти, як створити абстракції керування, що відчуваються більш подібно до розширень мови, зпочатку вам треба зрозуміти прийом функціонального програмування, що називається <em>карування</em>. Карована функція застосовується до декількох списків аргументів, замість тільки одного. Лістинг 9.2 показує звичайну, некаровану функцію, що додає два <code>Int</code> параметри, <code>x</code> та <code>y</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">plainOldSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">plainOldSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">plainOldSum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3L</span><span class="n">isting</span> <span class="mf">9.2</span> <span class="o">-</span> <span class="nc">Defining</span> <span class="n">and</span> <span class="n">invoking</span> <span class="n">a</span> <span class="s">&quot;plain old&quot;</span> <span class="n">function</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>На відміну, Лістинг 9.3 показує подібну функцію, що є карованою. Замість одного списку з двох <code>Int</code>, ви застосовуєте цю функцію до двох списків, по одному параметру <code>Int</code> кожний.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">curriedSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">curriedSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)(</span><span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">Int</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.3 - Визначення та виклик карованої функції.</p></div>
<div class="paragraph"><p>Що тут відбувається, це коли ви викликаєте <code>curriedSum</code>, насправді ви отримуєте два традиційні виклики функцій, пліч-о-пліч. Перший виклик функції приймає один параметр <code>Int</code> на ім'я <code>x</code>, та повертає значення функції для другої функції. Ця друга функція приймає <code>Int</code> параметр <code>y</code>. Ось функція на ім'я <code>first</code>, що діє в дусі, що мав би робити перший традиційний виклик функції <code>curriedSum</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">first</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосовуючи першої функції до 1 — іншими словами, викликаючи першу функцію, та передаючі їй 1 — дає другу функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">second</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосовуючи другу функцію до 2 дає результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці функції, <code>first</code> та <code>second</code>, є просто ілюстраціями процесу карування. Вони напряму не пов'язані до функції <code>curriedSum</code>. Тим не менш, існує спосіб отримати дійсне посилання на "другу" функцію <code>curriedSum</code>. Ви можете використовувати нотацію замінників для використання <code>curriedSum</code> в частково застосованому функціональному виразі, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">onePlus</span> <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="k">_</span>
<span class="n">onePlus</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Підкреслення в <code>curriedSum(1)_</code> є замінником для другого списку параметрів.<span class="footnote"><br />[В попередній главі, коли нотація замінників була застосована в традиційному методі, як <code>println _</code>, ви маєте залишати проміжок між ім'ям та підкресленням. В цьому випадку ви не змушені робити це, оскільки хоча <code>println_</code> є легальним ідентифікатором в Scala, <code>curriedSum(1)_</code> - ні.]<br /></span> Результатом буде посилання на функцію, що, коли буде викликана, додає один до свого єдиного аргумента <code>Int</code>, та повертає результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">onePlus</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Та ось як ви отримуєте функцію, що додає два до свого єдиного аргументу <code>Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoPlus</span> <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="k">_</span>
<span class="n">twoPlus</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">twoPlus</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_4____">9.4 Написання нових керівних структур</h2>
<div class="sectionbody">
<div class="paragraph"><p>В мові з першокласними функціями ви можете ефективно створити нові керівні структури, навіть якщо синтаксис мови фіксований. Все що вам треба зробити - це створити методи, що приймають функції як аргументи. Наприклад, ось керівна структура <code>twice</code>, що повторює операцію два рази, та повертає результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">twice</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">twice</span><span class="k">:</span> <span class="o">(</span><span class="kt">op:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="nc">Double</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">twice</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">7.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>op</code> в цьому прикладі є <code>Double =&gt; Double</code>, що означає, що це функція, що приймає одне <code>Double</code> в якості аргументу, та повертає інше <code>Double</code>. Кожного разу, коли ви знайдете шаблон керування, повторюваний в декількох частинах вашого коду, вам слідує подувати про реалізацію його як нової керуючої структури. Раніше в цій главі ви бачили <code>filesMatching</code>, дуже спеціалізований керівний шаблон. Тепер розглянемо більш широко використовуваний шаблон кодування: відкрити ресурс, виконувати операції з ним, та потім зачинити ресурс. Ви можете захопити це в керівній абстракції, використовуючи метод, подібний до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">op</span><span class="k">:</span> <span class="kt">PrintWriter</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">op</span><span class="o">(</span><span class="n">writer</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи такий метод, ви можете використати його таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">withPrintWriter</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&quot;date.txt&quot;</span><span class="o">),</span>
  <span class="n">writer</span> <span class="k">=&gt;</span> <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевага від використання цього метода в тому, що це <code>withPrintWriter</code>, а не код користувача, переконується, що в кінці файл буде зачинений . Так що неможливо забути зачинити файл. Цей прийом називається <em>шаблоном позичання</em>, оскікльи функція абстракції керування, така як <code>withPrintWriter</code>, відкриває ресурс, та "позичає" його функції. Наприклад, <code>withPrintWriter</code> в попередньому прикладі позичає <code>PrintWriter</code> функції <code>op</code>. Коли функція завершується, вона сигналить, що вона більше не потребує "запозичений" ресурс. Потім ресурс зачиняється в блоці <code>finally</code>, щоб переконатись, що він напевне зачинений, безвідносно від того, чи функція завершилась через нормальне повернення, або через закидання виключення.</p></div>
<div class="paragraph"><p>Один зі шляхів, як ви можете зробити, щоб код клієнта виглядав як вбудована структура керування, це використовувати фігурні дужки замість дужок для оточення списку аргументів. В любому виклику метода в Scala, в якому ви передаєте рівно один аргумент, ви можете обрати використовувати фігурні дужки для оточення аргумента замість дужок. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span> <span class="o">{</span> <span class="s">&quot;Hello, world!&quot;</span> <span class="o">}</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В другому прикладі ви використали фігурні дужки замість дужок, щоб оточити аргументи <code>println</code>. Однак цей прийом з фігурними дужками буде робить, тілкьи якщо ви передаєте один аргумент. Ось спроба порушити це правило:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">g</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">substring</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">1</span><span class="k">:</span> <span class="kt">error:</span> <span class="err">&#39;</span><span class="o">;</span><span class="err">&#39;</span> <span class="n">expected</span> <span class="n">but</span> <span class="sc">&#39;,&#39;</span> <span class="n">found</span><span class="o">.</span>
        <span class="n">g</span><span class="o">.</span><span class="n">substring</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span> <span class="o">}</span>
                       <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ви намагаєтесь передати два аргументи до <code>substring</code>, ви отримуєте помилку, коли ви намагаєтесь оточити ці аргументи фігурними дужками. Замість цього вам треба використовувати дужки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">wo</span>
</pre></div></div></div>
<div class="paragraph"><p>Призначення цієї здатності замінювати дужки на фігурні дужки для передачі одного аргумента, є дозволити програмісту клієнта писати функціональні літерали між фігурними дужками. Це може зробити виклик метода більш подібним до абстракції керування. Розгляньте визначений до цього метод <code>withPrintWriter</code> як приклад. В його самій останній формі <code>withPrintWriter</code> приймає два аргументи, так що ви не можете використовувати фігурні дужки.</p></div>
<div class="paragraph"><p>Тим не менш, оскільки функція, передана в <code>withPrintWriter</code> є останнім аргументом в списку, ви можете виконати карування для підтягування першого аргументу, <code>File</code>, в окремий список аргументів. Це залишить функцію як окремий параметр в другому списку аргументів. Лістинг 9.4 показує, як вам треба перевизначити <code>withPrintWriter</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="kt">PrintWriter</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">op</span><span class="o">(</span><span class="n">writer</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.4 - Використання шаблона позичання для запису в файл.</p></div>
<div class="paragraph"><p>Нова версія відрізняється від старої тільки в тому, що тепер в нас два списки параметрів, з одним параметром в кожному, замість одного списку параметрів з двома параметрами. В показаній тут попередній версії <code>withPrintWriter</code> ви бачили <code>...File, op...</code>. Але в цій версії ви бачите <code>...File)(op...</code>. Беручи до уваги визначення вище, ви можете викликати метод з більш приємним синтаксисом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&quot;date.txt&quot;</span><span class="o">)</span>

<span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="o">{</span> <span class="n">writer</span> <span class="k">=&gt;</span>
  <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі перший список аргументів, що містить один аргумент <code>File</code>, записаний в оточенні дужок. Другий список аргументів, що містить один функціональний аргумент, оточений в фігурні дужки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_5____">9.5 Параметри за ім'ям</h2>
<div class="sectionbody">
<div class="paragraph"><p>Метод <code>withPrintWriter</code>, показаний в попередньому розділі, відрізняється від вбудованих керівних структур мови, таких як <code>if</code> та <code>while</code>, тому що код між фігурними дужками приймає аргумент. Функція, передана до <code>withPrintWriter</code> потребує один аргумент типу PrintWriter. Цей аргумент показаний як <code>writer =&gt;</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="o">{</span> <span class="n">writer</span> <span class="k">=&gt;</span>
  <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але що, якщо ви бажаєте реалізувати дещо більш подібне до <code>if</code> або <code>while</code>, де немає значення, що треба передати в код між фігурними дужками? Щоб допомогти в таких ситуаціях Scala провадить параметри за іменем.</p></div>
<div class="paragraph"><p>В якості конкретного прикладу, уявімо ви бажаєте реалізувати конструкцію твердження <code>myAssert</code>. <span class="footnote"><br />[Ми назвемо це <code>myAssert</code>, не <code>assert</code>, оскільки Scala провадить свій власний <code>assert</code>, що буде описане в Розділі 14.1.]<br /></span> Функція <code>myAssert</code> буде приймати функціональне значення на вході, та звірятись з флагом, щоб вирішити, що робити. Якщо флаг встановлений, <code>myAssert</code> буде викликати передану функцію, та перевіряти, чи вона повертає <code>true</code>. Якщо флаг не встановлений, <code>myAssert</code> буде тихо взагалі нічого не робити.</p></div>
<div class="paragraph"><p>Без параметрів за ім'ям ви можете записати <code>myAssert</code> десь так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">assertionsEnabled</span> <span class="k">=</span> <span class="kc">true</span>
<span class="k">def</span> <span class="n">myAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначення гарне, але її використання трохи незручне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">myAssert</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете дійсно схилятись до відкидання пустого списку параметрів та символа <code>=&gt;</code> в функціональному літералі, та записати код таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">myAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// Не буде робити, оскільки відсутнє () =&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри за ім'ям існують саме для того, щоб це було можливо зробити. Щоб створити параметр за ім'ям, ви даєте параметру тип, що починається з <code>=&gt;</code> замість <code>() =&gt;</code>. Наприклад, ви можете змінити параметр предикату <code>myAssert</code> в параметр за ім'ям, змінивши його тип <code>() =&gt; Boolean</code> на <code>=&gt; Boolean</code>. Лістинг 9.5 показує, як це має виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">byNameAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.5 - Використання параметра за ім'ям.</p></div>
<div class="paragraph"><p>Тепер ви можете відкинути пустий параметр у властивості, що ви бажаєте перевірити. Результат в тому, що  <code>byNameAssert</code> виглядає точно як вбудована структура керування:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">byNameAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип за ім'ям, в якому відкидається пустий список параметрів, <code>()</code>, дозволений тільки для параметрів. Немає такого, як змінна за ім'ям або поле за ім'ям. Тепер ви можете здивуватись, чому ви не можете просто написати  <code>myAssert</code>, використовуючи простий старий <code>Boolean</code> для типу його параметра, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">boolAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, це формулювання також легальне, та код з використанням ціє версії <code>boolAssert</code> все ще буде виглядати точно як раніше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">boolAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тим не менш, існує одна відмінінсть між ціма двома підходами, яку важливо зазначити. Оскільки тип параметру <code>boolAssert</code> є <code>Boolean</code>, вираз всередині дужок в <code>boolAssert(5 &gt; 3)</code> обчислюється перед викликом до <code>boolAssert</code>. Вираз <code>5 &gt; 3</code> дає <code>true</code>, що передається до <code>boolAssert</code>. Для контрасту, оскільки тип параметра предикату <code>byNameAssert</code> є <code>=&gt; Boolean</code>, вираз в дужках в <code>byNameAssert(5 &gt; 3)</code> не обчислюється перед викликом до <code>byNameAssert</code>. Замість цього буде створено функціональне значення, метод <code>apply</code> якого буде обчислювати <code>5 &gt; 3</code>, та це функціональне значення буде передане в <code>byNameAssert</code>.</p></div>
<div class="paragraph"><p>Таким чином, різниця між двома підходами в тому, що якщо твердження відключене, ви побачите тільки побічний ефект цього виразу, який може мати вираз в дужках для <code>boolAssert</code>, але не для <code>byNameAssert</code>. Наприклад, якщо твердження відключені, спроба перевірити <code>x / 0 == 0</code> буде видавати виключення в випадку <code>boolAssert</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">5</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">assertionsEnabled</span> <span class="k">=</span> <span class="kc">false</span>
<span class="n">assertionsEnabled</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">boolAssert</span><span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span>
<span class="o">...</span> <span class="mi">33</span> <span class="n">elided</span>
</pre></div></div></div>
<div class="paragraph"><p>Але спроба виконати той самий код в випадку <code>byNameAssert</code> не дає виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">byNameAssert</span><span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_6_">9.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава показала вам, як багата функціональна підтримка в Scala використовується для побудови абстракцій керування. Ви можете використовувати функції в вашому коді для виділення загальних шаблонів керування, та ви можете отримати переваги функцій вищих порядків в бібліотеці Scala, щоб повторно використовувати шаблони керування, що є загальними поміж коду всіх програмістів. Ми також розглянули, як використовувати карування та параметри за ім'ям, так що ваші власні функції вищих порядків можуть бути використані зі стислим синтаксисом.</p></div>
<div class="paragraph"><p>В попередній та цій главі ви бачили досить багато інформації щодо функцій. Наступні декілька глав повертатимуть назад, до обговорення більш об'єктно-орієнтовних можливостей мови.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__10">Глава 10</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____9">Композиція та наслідування</h1>
<div class="paragraph"><p>Глава 6 вводить деякі базові об'єктно-орієнтовні аспекти Scala. Ця глава підхоплює там, де полишила Глава 6, та занурюється в підтримку в Scala об'єктно-орієнтовного програмування в значно більших деталях. Ми будемо порівнювати два фундаментальні співвідношення між класами: композицію та наслідування. Композиція означає, що один клас зберігає посилання на інший, використовуючи цей клас для допомоги в виконанні своєї міссії. Наслідування є відношенням суперклас/субклас. На додаток до ціх тем, ми будемо обговорювати абстрактні класи, методи без параметрів, розширення класів, перекриття методів та полів, параметрічні поля, виклик конструкторів суперкласу, поліморфізм та динамічна прив'язка, фінальні члени та класи, та об'єкти та методи фабрик.</p></div>
<div class="sect1">
<h2 id="_10_1___">10.1 Бібліотека двохмірного розташування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як робочий приклад в цій главі ми створимо бібліотеку для побудови та відображення прямокутника, заповненого текстом. Для зручності бібліотека буде провадити методи фабрики на ім'я <code>elem</code>, що конструює елементи з переданих даних. Наприклад, ви будете в змозі створити елемент розташування, що містить рядок, використовуючи метод фабрики з наступною сігнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, елементи будуть змодельовані за допомогою типу на ім'я <code>Element</code>. Ви зможете викликати <code>above</code> або <code>beside</code> на <code>element</code>, передаючи другий елемент, щоб створити новий елемент, який є комбінацією двох. Наприклад, наступний вираз буде конструювати більший елемент, що складається з двох колонок, кожна висотою 2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">column1</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="n">above</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;***&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">column2</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;***&quot;</span><span class="o">)</span> <span class="n">above</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">)</span>
<span class="n">column1</span> <span class="n">beside</span> <span class="n">column2</span>
</pre></div></div></div>
<div class="paragraph"><p>Друк результате цього виразу буде давати вам таке:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hello ***
*** world</code></pre>
</div></div>
<div class="paragraph"><p>Елементи розташування є гарним прикладом системи, в якій об'єкти можуть бути сконструйовані з простих частин за допомогою оераторів композиції. В цій главі ми будемо визначати класи, що дозволять конструювання об'єктів-елементів з масивів, ліній та прямокутників. Ці базові об'єкти елементів будуть простими частинами. Ми також визначимо операції композиції <code>above</code> та <code>beside</code>. Такі компонуючі оператори також часто називають <em>комбінаторами</em>, оскікльи вони комбінують елементи в деякій галузі в нові елементи.</p></div>
<div class="paragraph"><p>Думаючи в термінах комбінаторів загалом гарний підхід розробки бібліотеки: це відплачується - думати про фундаментальні шляхи конструювання об'єктів в домені застосування. Що таке прості об'єкти? В який спосіб найбільш цікаві об'єкти можуть бути сконструйовані з простіших? Як комбінатори поводяться разом? Які комбінатори найбільш загальні? Чи вони задовільняють цікавим законам? Якщо ви маєте гарні відповіді на ці запитання, розробка вашої бібліотеки на вірному шляху.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_2__">10.2 Абстрактні класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наше перше завдання є визначити тип <code>Element</code>, що предаставляє елементи розташування. Оскільки елементи є двохвимірні прямокутники символів, має сенс включити член <code>contents</code>, що посалається на вміст елемента розташування. Цей <code>contents</code> може бути представлений як масив рядків, до кожний рядок представляє лінію. Таким чином, тип результата, що повертається <code>contents</code> буде <code>Array[String]</code>. Лістинг 10.1 показує, як це буде виглядати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.1 - Визначення абстрактного метода та класа.</p></div>
<div class="paragraph"><p>В цьому класі <code>contents</code> декларовано як метод, що не має реалізації. Іншими словами, метод є абстрактним членом класа <code>Element</code>. Клас з абстрактинми методами має сам бути визначений як абстрактний, що робиться додаванням модифікатора <code>abstract</code> перед ключовим словом <code>class</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>abstract</code> означає, що клас може мати абстрактні члени, що не мають реалізації. Як результат, ви не можете створити примірник абстрактного класу. Якщо ви спробуєте зробити це, ви отримаєте помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Element</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Element</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span>
    <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span>
       <span class="k">new</span> <span class="nc">Element</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Пізніше в цій главі ви побачите, як створити субкласи класа <code>Element</code>, для яких ви будете в змозі створити примірники, оскільки вони заповнюють відсутнє визначення дла <code>contents</code>.</p></div>
<div class="paragraph"><p>Зауважте, що метод <code>contents</code> в класі <code>Element</code> не має модифікатора <code>abstract</code>. Метод є абстрактним, якщо він не має реалізації (тобто знака рівності або тіла). На відміну від Java, для декларацій методів модифікатор <code>abstract</code> не потрібен (та не дозволений). Методи, що мають реалізцію, називаються <em>суцільними</em>.</p></div>
<div class="paragraph"><p>Інша частка термінології відрізняє декларації та визначення. Клас <code>Element</code> <em>декларує</em> абстрактний метод <code>contents</code>, але наразі не <em>визначає</em> конкретинх методів. Однак в наступному розділі ми розширимо <code>Element</code>, визначаючи деякі суцільні методи.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_3____">10.3 Визначення методів без параметрів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми додамо методи до <code>Element</code>, що з'ясовують його ширину та довжину, як показано в Лістингу 10.2. Метод <code>height</code> повертає число рядків в <code>contents</code>. Метод <code>width</code> повертає довжину першого рядка, або повертає нуль, якщо в елементі немає нічого. (Це означає, що ви не можете визначити елемент з висотою нуль, та ненульовою шириною.)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.2 - Визначення методів без параметрів, <code>width</code> та <code>height</code>.</p></div>
<div class="paragraph"><p>Зауважте, що жодний з трьох методів <code>Element</code> не має списку параметрів, навіть порожнього. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">width</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>метод визначений без дужок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Такі <em>безпараметричні</em> методи є досить загальними в Scala. На відміну, методи, визначені з порожніми дужками, такі як <code>def height(): Int</code>, називаються <em>методами з порожніми дужками</em>. Рекомендована домовленість є використовувати безпараметричні методи, коли немає параметрів, і метод отримує доступ до змінного стану тільки через читання полів містячого об'єкта (зокрема, він не змінює змінний стан). Ця домовленість підтримує принцип уніфіормного доступу,<span class="footnote"><br />[Meyer, Object-Oriented Software Construction [Mey00]]<br /></span> який каже, що клієнтський код не має зазнати впливу від рішення реалізувати атрибут як поле або метод.</p></div>
<div class="paragraph"><p>Наприклад, ми можемо реалізувати <code>width</code> та <code>height</code> елемента як поля, замість методів, просто змінивши <code>def</code> в кожному визначенні на <code>val</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">height</span> <span class="k">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">val</span> <span class="n">width</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дві пари визначень повністю еквівалентні з клієнтської точки зору. Єдине що відрізняється, це те, що доступ до поля може бути трохи швидший, ніж виклик метода, оскільки значення полів попередньо обчислені при ініціалізації класа, замість бути обчислені при кожному виклику метода. З іншого боку, поля потребують додаткового простору в пам'яті в кожному елементі <code>Element</code>. Так що це залежить від профілю використання класа, чи атрибут краще представляти як поле чи метод, і цей профіль використання може змінитись з часом. Суть в тому, що клієнти класа <code>Element</code> не мають зазнати впливу, коли змінюється внутрішнє представлення.</p></div>
<div class="paragraph"><p>Зокрема, клієнт класу <code>Element</code> не має бути переписаний, якщо поле цього класа буде змінено на функцію доступу, доки ця функція є чистою (тобто вона не має жодних побічних ефектів, та не залежить від змінного стану). Клієнт не має турбуватись в жодному випадку.</p></div>
<div class="paragraph"><p>Доки все гарно. Але все ще є невелике ускладнення, що має справу з тим, як Java обробляє речі. Проблема в тому, що Java не реалізує принцип уніформного доступу. Так що існує <code>string.length()</code> в Java, не <code>string.length</code>, навіть якщо <code>array.length</code>, не <code>array.length()</code>. Нічого і казати, що це дуже бентежить.</p></div>
<div class="paragraph"><p>Щоб полатати цю дірку, Scala є дуже ліберальною, коли доходить до міксування безпараметричних методів, та методів з порожніми дужками. Зокрема, ви можете перекрити безпараметричні методи методом порожніх дужок, та навпаки. Ви також можете відкинути порожні дужки при виклику функції, що не приймає аргументів. Наприклад, наступні два рядка обоє є легальними в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">toString</span>
<span class="s">&quot;abc&quot;</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>В принципі можливо відкинути всі порожні дужки в викликах функцій Scala. Однак все ще рекомендовано писати порожні дужки, коли викликаний метод представляє більше ніж властивість об'єкта отримувача. Наприклад, порожні дужки на місці, коли метод виконує I/O, записує переприсвоювані змінні (<code>var</code>), або читає <code>var</code> окрім полів отримувача, прямо або непрямо через використання змінних об'єктів. Таким чином, список параметрів діє як візуальна підказка, що виклик запускає деякі цікаві обчислення. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;hello&quot;</span><span class="o">.</span><span class="n">length</span> <span class="c1">// немає (), бо немає побічних ефектів</span>
<span class="n">println</span><span class="o">()</span> <span class="c1">// краще не відкидати ()</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб підсумувати, в Scala заохочується визначати методи, що не приймають параметрів, та не мають побічних ефектів, як безпараметричні методи (тобто відкидаючи порожні дужки). З іншого боку, вам ніколи не слід визначати метод, що має побічні ефекти, без дужок, оскільки виклики цього метода потім будуть виглядати як вибір поля. Так що ваші клієнти можуть бути здивовані, коли побачать побічні ефекти.</p></div>
<div class="paragraph"><p>Подібним чином, коли ви викликаєте функцію, що має побічний ефект, переконайтесь, що коли писали виклик включили порожні дужки. Інший спосіб думати про це: коли функція, що ви викликаєте, виконує операцію, використовуйте дужки. Але якщо вона просто провадить доступ до властивості, прибирайте дужки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_4__">10.4 Розширення класів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нам все ще треба бути в змозі створювати нові об'єкти елементів. Ви вже бачили, що <code>new Element</code> не може бути використаний для цього, оскільки <code>Element</code> є абстрактним. Таким чином, щоб створити примірник елемента, нам треба створити субклас, що розширює <code>Element</code>, та реалізує абстрактний метод <code>contents</code>. Лістинг 10.3 показує можливий спосіб зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.3 - Визначення <code>ArrayElement</code> як субкласа <code>Element</code>.</p></div>
<div class="paragraph"><p>Клас <code>ArrayElement</code> визначений для розширення класу <code>Element</code>. Так само, як в Java, ви використовуєте твердження <code>extends</code> після імені класу, щоб виразити цей факт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Малюнок 10.1 - Діаграма класів для <code>ArrayElement</code>.</p></div>
<div class="paragraph"><p>Таке твердження <code>extends</code> має два ефекти: це дає класу <code>ArrayElement</code> наслідувати всі неприватні члени від класу <code>Element</code>, та це робить тип <code>ArrayElement</code> субтипом типу <code>Element</code>. Зважаючи що <code>ArrayElement</code> розширює <code>Element</code>, клас <code>ArrayElement</code> називається субкласом класу <code>Element</code>. І навпаки, <code>Element</code> є суперкласом <code>ArrayElement</code>. Якщо ви приберете твердження <code>extends</code>, компілятор Scala неявно вважатиме, що ваш клас розширює <code>scala.AnyRef</code>, що на Java платформі є те саме, що і клас <code>java.lang.Object</code>. Таким чином, клас <code>Element</code> неявно розширює клас <code>AnyRef</code>. Ви можете бачити ці відношення наслідування на Малюнку 10.1.</p></div>
<div class="paragraph"><p>Наслідування означає, що всі члени суперкласа також є членами субкласу, з двома виключеннями. Перше, приватні члени суперкласу не наслідуються в субкласі. Друге, члени суперкласа не наслідуються, якщо член з таким же ім'ям та параметрами вже реалізовані в субкласі. В такому випадку ми кажемо, що субклас <em>перекриває</em> член в суперкласі. Якщо член субкласу є суцільним, та член суперкласу є абстрактним, ми також кажемо, що суцільний член реалізує абстрактний.</p></div>
<div class="paragraph"><p>Наприклад, метод <code>contents</code> в <code>ArrayElement</code> перекриває (або, альтернативно, реалізує) абстрактний метод <code>contents</code> в класі <code>Element</code>.<span class="footnote"><br />[Одна проріха в цьому дизайні в тому, що оскільки повернутий масив є змінним, клієнти можуть змінити його. Для книжки ми будемо підтримувати речі простими, але коли <code>ArrayElement</code> є частиною реального проекта, ви можете розглянути можливість повертати захисну копію масива замість цього. Інша проблема полягає в тому, що ми досі не переконались, що кожний елемент <code>String</code> масиву  <code>contents</code> має ту саму довжину. Це може бути вирішене через перевірку передумови в первинному конструкторі, за закиданні виключення, якщо вона порушується.]<br /></span> Для контрасту, клас <code>ArrayElement</code> наслідує методи <code>width</code> та <code>height</code> від класа <code>Element</code>. Наприклад, маючи <code>ArrayElement ae</code>, ви можете запитати його <code>width</code> використовуючи <code>ae.width</code>, так, якби <code>width</code> було визначене в класі <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ae</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">))</span>
<span class="n">ae</span><span class="k">:</span> <span class="kt">ArrayElement</span> <span class="o">=</span> <span class="nc">ArrayElement</span><span class="k">@</span><span class="mi">39274</span><span class="n">bf7</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ae</span><span class="o">.</span><span class="n">width</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p>Створення субтипів означає, що значення субкласу може бути використане, коли потрібне значення суперкласу. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна <code>e</code> визначена як тип <code>Element</code>, так що його значення ініціалізації також має бути <code>Element</code>. Фактично, значення ініціалізації є <code>ArrayElement</code>. Це OK, оскільки клас <code>ArrayElement</code> розширює клас <code>Element</code>, і як результат, тип <code>ArrayElement</code> сумісний з типом <code>Element</code>.<span class="footnote"><br />[Для додаткової перспективи на різницю між суперкласом та субкласом дивіться входження глассарію щодо субтипів.]<br /></span></p></div>
<div class="paragraph"><p>Малюнок 10.1 також показує порівняння відношень, що існують між <code>ArrayElement</code> та <code>Array[String]</code>. Це відношення називається композицією, та  клас <code>ArrayElement</code> є "скомпонований" з класу <code>Array[String]</code>, тому що компілятор Scala буде покладати в двійниковий клас, що він генерує для <code>ArrayElement</code>, поле, що містить посилання на переданий масив <code>conts</code>. Ми обговоримо деякі рішення дизайну композиції та наслідування далі в цій главі, в Розділі 10.11.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_5____">10.5 Перекриття методів та полей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Принцип уніформного доступу є тільки одним аспектом, коли Scala розглядає поля та методи в більш уніформний спосіб, ніж Java. Інша різниця в тому, що в Scala поля та методи належать до того самого простору імен. Це робить можливим для поля перекривати метод без параметрів. Наприклад, ви можете змінити реалізацію <code>contents</code> в класі <code>ArrayElement</code> з метода на поле, без модифікації визначення абстрактного метода <code>contents</code> в класі <code>Element</code>, як показано в Лістингу 10.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.4 - Перекриття метода без параметрів за допомогою поля.</p></div>
<div class="paragraph"><p>Поле <code>contents</code> (визначене як <code>val</code>) в цій версії <code>ArrayElement</code> є чудово гарною реалізацією метода без параметрів <code>contents</code> (декларований за допомогою <code>def</code>) в класі <code>Element</code>. З іншої сторони, в Scala заборонено визначати поле та метод з тим самим ім'ям в тому самому класі, хоча це дозволено в Java.</p></div>
<div class="paragraph"><p>Наприклад, цей Java клас буде чудово компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="kd">class</span> <span class="nc">CompilesFine</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але відповідний клас Scala не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WontCompile</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// Не буде компілюватись, оскільки поле</span>
  <span class="k">def</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">1</span>         <span class="c1">// та метод мають те саме ім&#39;я</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Загалом, Scala має лише два простору імен для визначень, на відміну від чотирьох в Java. Чотири простори імен в Java є поля, методи, типи та пакунки. На відміну в Scala лише два простори імен:</p></div>
<div class="ulist"><ul>
<li>
<p>
значення (поля, методи, пакунки та об'єкти синглтони)
</p>
</li>
<li>
<p>
types (імена класів та трейтів)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Причина, з якої Scala покладає поля та методи в той самий простір імен в точності та, щоб ви могли перекривати методи без параметірв за допомогою <code>val</code>, дещо, чого ви не можете робити в Java.<span class="footnote"><br />[Причина, з якої в Scala пакунки подіяють той самий простір імен, що поля і методи - бо це дозволяє вам імпортувати пакунки (на додаток до тільки імен типів) та поля і методи об'єктів синглтонів. Це знову дещо, чого ви не можете в Java. Це буде описане в Розділі 13.3.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_6___">10.6 Визначення параметричних полів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знову розглянемо визначення класу <code>ArrayElement</code>, показану в попередній главі. Він мав параметр <code>conts</code>, чиє єдине призначення є бути скопійованим в поле <code>contents</code>. Ім'я параметра <code>conts</code> було обране саме так, щоб воно могло виглядати подібно до імені поля  <code>contents</code>, насправді не перетинаючись з ним. Це "сморід коду," ознака, що може бути непотрібна надмірність або повторення у вашому коді.</p></div>
<div class="paragraph"><p>Ви можете уникнути сморіду коду, комбінуючи параметр та поле в одному визначенні параметричного коду, як показано в Лістингу 10.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.5 - Визначення <code>contents</code> як параметричного поля.</p></div>
<div class="paragraph"><p>Зауважте, що тепер параметр <code>contents</code> має перед собою <code>val</code>. Це скорочення, що одночасно визначеє параметр та поле з тим самим полем. Зокрема, клас <code>ArrayElement</code> тепер має (неперепризначуване) поле <code>contents</code>, до якого можна отримати з поза меж класу. Поле ініціалізоване значенням параметру. Це так, якби клас був написаний наступним чином, де <code>x123</code> є довільним свіжим ім'ям для параметру:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">x123</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">x123</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Також ви можете перед параметром класу поставити <code>var</code>, в якому випадку відповідне поле буде переприсвоюване. Нарешті, можливо додати модифікатори, такі як <code>private</code>, <code>protected</code>,<span class="footnote"><br />[Модифікатор <code>protected</code>, що надає доступ до субкласів, буде розкритий в деталях в Главі 13.]<br /></span> або <code>override</code> до ціх параметричних полів, так само, як ви можете зробити для любих інших членів методів. Наприклад, розгляньте визначення наступних класів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cat</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">dangerous</span> <span class="k">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Tiger</span> <span class="o">(</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">dangerous</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Cat</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначення <code>Tiger</code> є скороченням для наступного альтернативного визначення класу, з перекриттям члена <code>dangerous</code> та приватним членом <code>age</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Tiger</span><span class="o">(</span><span class="n">param1</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span> <span class="n">param2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Cat</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">dangerous</span> <span class="k">=</span> <span class="n">param1</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">age</span> <span class="k">=</span> <span class="n">param2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Обоє члени ініціалізовані від відповідних парамтрів. Ми довільно обираємо імена для ціх параметрів, <code>param1</code> та <code>param2</code>. Важлива річ була щоб вони не перетинались з іншими іменами в полі зору.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_7___">10.7 Виклик конструкторів суперкласу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви маєте повну систему, що складається з двох класів: абстрактного класу <code>Element</code>, що розширений суцільним класом <code>ArrayElement</code>. Ви можете також уявити собі для вираження елемента. Наприклад, клієнти можуть виявити бажання створити елемент розташування, що складається з однієї лінії, взятої як рядок. Об'єктно-орієнтовне програмування робить простим розширення системи за допомогою нових варіантів даних. Ви можете просто додавати субкласі. Наприклад, Лістинг 10.6 показує клас <code>LineElement</code>, що поширює <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.6 - Викликання конструктора суперкласа.</p></div>
<div class="paragraph"><p>Оскікльи <code>LineElement</code> розширює <code>ArrayElement</code>, та конструктор <code>ArrayElement</code> приймає параметр (<code>Array[String]</code>), <code>LineElement</code> потребує передати аргумент до первинного конструктора його суперкласу. Щоб викликати конструктор суперкласу, ви просто покладаєте аргумент або аргументи, що ви бажаєте передати, в дужках, що слідують за ім'ям суперкласу. Наприклад, клас <code>LineElement</code> передає <code>Array(s)</code> до первинного конструктора <code>ArrayElement</code>, покладаючи в його в дужки після імені суперкласа <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>З новим субкласом ієрархія наслідування для елементів розташування зараз виглядає, як показано на Малюнку 10.2.</p></div>
<div class="paragraph"><p>Малюнок 10.2 - Діаграма класів для <code>LineElement</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_8___override">10.8 Використання модифікатора override</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зауважте, що визначення <code>width</code> та <code>height</code> в <code>LineElement</code> має модифікатор <code>override</code>. В розділі 6.3 ви бачили цей модифікатор в визначенні метода <code>toString</code>. Scala потребує такого модифікатора для всіх членів, що перекривають суцільний метод в батьківському класі. Модифікатор є опціональним, якщо член реалізує абстрактний член з тим самим ім'ям. Модифікатор заборонений, якщо член не перекриває або не реалізує деякий член в базовому класі. Оскільки <code>height</code> та <code>width</code> в класі <code>LineElement</code> перекривають суцільні визначення в класі <code>Element</code>, <code>override</code> є обов'язковим.</p></div>
<div class="paragraph"><p>Це правило провадить корисну інформацію для компілятора, що допомагає уникати деяких складних для відлову помилок, та робить еволюцію безпечнішою. Наприклад, якщо ви випадково невірно назвали метод, або випадково дали йому інший список параметрів, компілятор відповість повідомленням про помилку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="nc">LineElement</span><span class="o">.</span><span class="n">scala</span>
<span class="o">.../</span><span class="nc">LineElement</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">50</span><span class="kt">:</span>
<span class="n">error</span><span class="k">:</span> <span class="kt">method</span> <span class="kt">hight</span> <span class="kt">overrides</span> <span class="kt">nothing</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hight</span> <span class="k">=</span> <span class="mi">1</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Домовленість перекриття навіть більше важливе, коли доходить до еволюції системи. Скажімо, ви визначаєте бібліотеку з методів малювання 2D. Ви зробили її публічно доступною, та вона широко уживана. В наступній версії бібліотеки ви бажаєте додати до вашого базового класа <code>Shape</code> новий метод з такою сигнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">hidden</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>Ваш новий метод буде використовуватись в різних методах малювання, щоб визначити, чи треба малювати фігуру. Це може призвести до значного прискорення, але ви не можете зробити це без ризику поламати клієнтській код. Кінець кінцем, клієнт міг вже визначити субклас <code>Shape</code> з іншою реалізацією <code>hidden</code>. Можливо, клієнській метод насправді робить отримуючий об'єкт зникаючим, замість перевіряти, чи об'єкт прихований. Оскільки дві версії <code>hidden</code> перекривають один одний, ваші методи малювання скінчать тим, що робитимуть об'єкти знікаючими, що напевне не те, чого ви бажаєте!</p></div>
<div class="paragraph"><p>Ці "випадкові перекриття" є найбільш загальною маніфестацією того, що називається проблемою "крихких базових класів". Проблема в тому, що якщо ви додаєте нові члени до базових класів (які ми звичайно називаємо суперкласами) в ієрархії класів, ми ризикуємо зламати клієнтській код. Scala не може повністю вирішити проблему крихкіх базових класів, але він покращує ситуацію, порівняно з Java.<span class="footnote"><br />[В Java 1.5 була введена анотація <code>@Override</code>, що робить подібно до модифікатор Scala <code>override</code>, але на відміну від Scala <code>override</code>, це не вимагається.]<br /></span> Якщо бібліотека малювання та її клієнти були написані на Scala, тоді оригінальна клієнтська реалізація <code>hidden</code> не може мати модифікатора  <code>override</code>, оскільки на той час немає іншого метода з цім ім'ям.</p></div>
<div class="paragraph"><p>Як тільки ви додасте метод <code>hidden</code> до другої версії вашого класу фігури, перекомпіляція клієнта буде давати помилку, подібну до наступної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">.../</span><span class="nc">Shapes</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">6</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">error</span> <span class="kt">overriding</span> <span class="kt">method</span>
     <span class="n">hidden</span> <span class="n">in</span> <span class="k">class</span> <span class="nc">Shape</span> <span class="n">of</span> <span class="k">type</span> <span class="o">()</span><span class="kt">Boolean</span><span class="o">;</span>
<span class="n">method</span> <span class="n">hidden</span> <span class="n">needs</span> <span class="err">`</span><span class="k">override</span><span class="err">&#39;</span> <span class="n">modifier</span>
<span class="k">def</span> <span class="n">hidden</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, замість помилкової поведінки ваш клієнт отримає помилку часу компіляції, що, зазвичай, значно краще.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_9_____">10.9 Поліморфізм та динамічне зв'язування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви бачили в Розділі 10.4, що змінна типу <code>Element</code> може посилатись на об'єкт типу <code>ArrayElement</code>. Ім'я цього феномену є <em>поліморфізм</em>, що означає "багато форм". В цьому випадку, об'єкти <code>Element</code> можуть мати багато форм.<span class="footnote"><br />[Цей різновид поліморфізму називається поліморфізмом субтипізації. Інший різновид поліморфізму в Scala називається універсальним поліморфізмом, та обговорюється в Главі 19.]<br /></span></p></div>
<div class="paragraph"><p>Доки ви бачили дві такі форми: <code>ArrayElement</code> та <code>LineElement</code>. Ви можете створити більше форм <code>Element</code>, через визначення нових субкласів <code>Element</code>. Наприклад, ви можете визначити нову форму <code>Element</code>, що має задані ширину та довжину, та повністю заповнений наданим символом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UniformElement</span><span class="o">(</span>
  <span class="n">ch</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">toString</span> <span class="o">*</span> <span class="n">width</span>
  <span class="k">def</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">height</span><span class="o">)(</span><span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ієрархія наслідування для класа <code>Element</code> тепер виглядає як показано на Малюнку 10.3. Як результат, Scala буде приймати всі наступні присвоєння, оскільки тип присвоюваних виразів відповідає до типу визначенної змінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">e1</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">))</span>
<span class="k">val</span> <span class="n">ae</span><span class="k">:</span> <span class="kt">ArrayElement</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LineElement</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">e2</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="n">ae</span>
<span class="k">val</span> <span class="n">e3</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">UniformElement</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви перевірите ієрархію наслідування, ви знайдете, що для кожного з ціх чотирьох визначень <code>val</code>, тип виразу зправа від знаку рівності нижче типу <code>val</code>, що ініціалізується зліва знаку рівності.</p></div>
<div class="paragraph"><p>Малюнок 10.3 - Ієрархія класу елементів розташування.</p></div>
<div class="paragraph"><p>Однак друга частина історії в тому, що виклики ціх методів не змінній і виразах зв'язані динамічно. Це означає, що справжня реалізація метода визначається під час виконання, на основі класу об'єкта, не на основі типу змінної або виразу. Щоб продемонструвати цю поведінку, ми тимчасово видалимо всі існуючі члени з нашого класу <code>Element</code>, та додамо в <code>Element</code> метод з назвою <code>demo</code>. Ми перекриємо <code>demo</code> в <code>ArrayElement</code> та <code>LineElement</code>, але не в <code>UniformElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Element&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ArrayElement</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;ArrayElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">LineElement</span> <span class="k">extends</span> <span class="nc">ArrayElement</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;LineElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// UniformElement наслідує demo від Element</span>
<span class="k">class</span> <span class="nc">UniformElement</span> <span class="k">extends</span> <span class="nc">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви введете цей код в інтерпретатор, потім ви можете визначитицей метод, що приймає <code>Element</code>, та викликає на ньому <code>demo</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">e</span><span class="o">.</span><span class="n">demo</span><span class="o">()</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви передасте <code>ArrayElement</code> до <code>invokeDemo</code>, ви побачите повідомлення, що вказує, що була викликана реалізація demo з ArrayElement, навіть хоча тип змінної <code>e</code>, на якому викликається demo, є <code>Element</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">)</span>
<span class="nc">ArrayElement</span><span class=" -Symbol">&#39;s</span> <span class="n">implementation</span> <span class="n">invoked</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, якщо ви передасте <code>LineElement</code> до <code>invokeDemo</code>, ви побачите повідомлення, що вказує, що була викликана реалізація <code>demo</code> з <code>LineElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="k">new</span> <span class="nc">LineElement</span><span class="o">)</span>
<span class="nc">LineElement</span><span class=" -Symbol">&#39;s</span> <span class="n">implementation</span> <span class="n">invoked</span>
</pre></div></div></div>
<div class="paragraph"><p>Поведінка коли передається <code>UniformElement</code> може зпочатку виглядати підозрілою, але вона коректна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">invokeDemo</span><span class="o">(</span><span class="k">new</span> <span class="nc">UniformElement</span><span class="o">)</span>
<span class="nc">Element</span><span class=" -Symbol">&#39;s</span> <span class="n">implementation</span> <span class="n">invoked</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>UniformElement</code> не перекриває <code>demo</code>, він наслідує реалізацію <code>demo</code> від свого суперкласу, <code>Element</code>. Таким чином, реалізація <code>Element</code> є коректною реалізацією <code>demo</code>, коли клас об'єкта є <code>UniformElement</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_10___">10.10 Декларація фінальних членів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді, коли розробляється ієрархія наслідування, ви бажаєте переконатись, що член не може бути перекритий в субкласах. В Scala, як і в Java, ви робите це, додаючи модифікатор <code>final</code> до члена. Як показано в Лістингу 10.7, ви можете покласти модифікатор <code>final</code> на <code>demo</code> метод в <code>ArrayElement</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;ArrayElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.7 - Декларування фінального методу.</p></div>
<div class="paragraph"><p>Маючи цю версію <code>ArrayElement</code>, спроба перекрити <code>demo</code> в субкласі <code>LineElement</code> не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">18</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">error</span> <span class="kt">overriding</span> <span class="kt">method</span> <span class="kt">demo</span>
   <span class="n">in</span> <span class="k">class</span> <span class="nc">ArrayElement</span> <span class="n">of</span> <span class="k">type</span> <span class="o">()</span><span class="kt">Unit</span><span class="o">;</span>
<span class="n">method</span> <span class="n">demo</span> <span class="n">cannot</span> <span class="k">override</span> <span class="k">final</span> <span class="n">member</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
                 <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Також часом ви бажаєте переконатись, що цілий клас не може мати субкласів. Щоб зробити це, просто декларуйте цілий клас фінальним, додаючи модифікатор <code>final</code> до декларації класу. Наприклад, Лістинг 10.8 показує, як ви можете декларувати фінальний <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">class</span> <span class="nc">ArrayElement</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">demo</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;ArrayElement&#39;s implementation invoked&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.8 - Декларування фінального класу.</p></div>
<div class="paragraph"><p>З цією версією <code>ArrayElement</code>, люба спроба визначити субклас не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span> <span class="err">18</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">illegal</span> <span class="kt">inheritance</span> <span class="kt">from</span> <span class="kt">final</span> <span class="kt">class</span>
    <span class="nc">ArrayElement</span>
  <span class="k">class</span> <span class="nc">LineElement</span> <span class="k">extends</span> <span class="nc">ArrayElement</span> <span class="o">{</span>
                            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми видалимо модифікатор <code>final</code> та метод <code>demo</code>, та повернемось до ранішньої реалізації сімейства <code>Element</code>. В залишку глави ми зфокусуємо нашу увагу на завершенні робочої версії бібліотеки розташування.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_11____">10.11 Використання композиції та наслідування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Композиція та наслідування є двома шляхами визначити новий клас в термінах іншого існуючого класа. Якщо те, чого ви шукаєте, це просте повторне використання коду, ви маєте обрати композицію замість наслідування. Тільки наслідування потерпає від проблеми крихких базових класів, коли ви можете ненавмисно зашкодити субкласам через зміни в суперкласі.</p></div>
<div class="paragraph"><p>Одне питання, що ви можете запитати себе щодо відношення наслідування, чи моделює воно відношення "..є примірником..".<span class="footnote"><br />[Meyers, Effective C++ [Mey91]]<br /></span> Наприклад, це буде досить дотепним сказати, що <code>ArrayElement</code> <em>є примірником</em> <code>Element</code>. Інше питання, що ви можете запитати, це чи те, чи колись клієнти забажають використовувати тип субкласів як тип суперкласу.<span class="footnote"><br />[Eckel, Thinking in Java [Eck98]]<br /></span> В випадку <code>ArrayElement</code>, ми очевидно очікуємо, що клієнти бажатимуть використовувати <code>ArrayElement</code> як <code>Element</code>.</p></div>
<div class="paragraph"><p>Якщо ви задасте ці питання щодо відношень наслідування, показаних на Малюнку 10.3, чи якесь з відношень виглядає підозріло? Закрема, чи виглає це очевидним, що <code>LineElement</code> <em>є примірником</em> <code>ArrayElement</code>? Чи ви думаєте, що клієнтам колись знадобиться використовувати <code>LineElement</code> як <code>ArrayElement</code>?</p></div>
<div class="paragraph"><p>Фактично, ми визначили <code>LineElement</code> як субклас <code>ArrayElement</code> в основному для повторного використання визначення <code>contents</code> з <code>ArrayElement</code>. Можливо, було б краще визначити <code>LineElement</code> як прямий субклас <code>Element</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В попередній версії <code>LineElement</code> має відношення наслідування з <code>ArrayElement</code>, від якого він наслідує <code>contents</code>. Тепер він має відношення композиції з <code>Array</code>: він має посилання на масив з рядків зі свого власного поля <code>contents</code>.<span class="footnote"><br />[Клас <code>ArrayElement</code> також має відношення композиції з <code>Array</code>, оскільки його параметричне поле <code>contents</code> містить посилання на масив з рядків. Код для <code>ArrayElement</code> показаний в Лістингу 10.5. Його відношення композиції представлене на діаграмі класу як діамант, наприклад, як показано на Малюнку 10.1.]<br /></span> Маючи цю реалізацію <code>LineElement</code>, ієрархія наслідування для <code>Element</code> тепер виглядає так, як на Малюнку 10.4.</p></div>
<div class="paragraph"><p>Малюнок 10.4 - Ієрархія класів з переробленим <code>LineElement</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_12__code_above_code_code_beside_code__code_tostring_code">10.12 Реалізація <code>above</code>, <code>beside</code> та <code>toString</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми реалізуємо метод <code>above</code> в класі <code>Element</code>. Покладання одного елементу над іншим означає конкатенацію двох значень <code>contents</code> для елементів. Так що перша чернетка метода <code>above</code> може виглядати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Операція <code>++</code> конкатенує два масиви. Масиви в Scala представлені масивами Java, але підтримують значно більше методів. Більш точно, масиви в Scala можуть бути конвертовані в примірники класу <code>scala.Seq</code>, що представляє собою послідовність-подібні структуру, та містить декілька методів для доступу та перетворення послідовностей. Деякі інші методи масивів будуть пояснені в цій главі, та більш докладна дискусія буде надана в Главі 17.</p></div>
<div class="paragraph"><p>Фактично, попередньо показаний код не дуже достатній, оскільки він не дозволяє вам покладати вам елементи різної ширини один зверху іншого. Щоб утримувати речі в цьому розділі простими, ми залишимо це як є, та передаватимемо до <code>above</code> тільки елементи однієї ширини. В Розділі 10.14 ми зробимо покращення до <code>above</code>, так щоб клієнти могли використовувати його для комбінування елементів з різною шириною.</p></div>
<div class="paragraph"><p>Наступний метод, що треба реалізувати, є <code>beside</code>. Щоб покласти два елементи один поряд з іншим, ми створимо новий елемент, в якому кожна лінія утворюється від канкатенації відповідних ліній з двох елементів. Як і раніше, щоб утримувати речі простими, ми почнемо з припущення, що два елементи мають ту саму висоту. Це призводить до наступного дизайну метода <code>beside</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">contents</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">contents</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>beside</code> спочатку розміщує новий масив <code>contents</code>, та заповнює його вмістом відповідних елементів масива в <code>this.contents</code> та <code>that.contents</code>. В фіналі він продукує новий <code>ArrayElement</code>, що містить новий <code>contents</code>.</p></div>
<div class="paragraph"><p>Хоча ця реалізація <code>beside</code> робить, це імперативний стиль, промовистим знаком чого є цикл в якому ми проходимо по масиву. Альтернативно, метод може бути скорочений до одного вирау:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span>
  <span class="k">for</span> <span class="o">(</span>
        <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>
      <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут є два масива, <code>this.contents</code> та <code>that.contents</code>, що трансформуються в масив з пар (що називаютсья <code>Tuple2s</code>) використовуючи оператор <code>zip</code>. Оператор <code>zip</code> бере відповідні елементи зі своїх двох операндів, та формує масив з пар. Наприклад, цей вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">zip</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>обчислюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо один з двох масивів довший за інший, <code>zip</code> буде відкидати зайві елементи. В виразі вище третій елемент лівого операнда, <code>3</code>, не формує частину результату, оскільки він не має відповідного елемента в правому операнді.</p></div>
<div class="paragraph"><p>Після цього поєднаний масив ітерується в виразу <code>for</code>. Тут синтаксис <code>for ((line1, line2) &lt;- ...)</code> дозволяє вам назвати обоє елементи з пари в одному шаблоні (тобто, тепер <code>line1</code> тепер відповідає першому елементу з пари, та <code>line2</code> відповідає другому). Система співпадіння з шаблонами в Scala буде описана в деталях в Главі 15. Доки ви можете думати про це як про спосіб визначити дві <code>val</code>, <code>line1</code> та <code>line2</code>, на кожному кроці ітерації.</p></div>
<div class="paragraph"><p>Вираз <code>for</code> має частину <code>yield</code>, і, таким чином, видає результат. Результат буде того самого типу, що і вираз, по якому іде ітерація (тобто, це масив). Кожний елемент масиву є результатом конкатенації відповідних рядків, <code>line1</code> та <code>line2</code>. Так що ваш останній результат цього коду є той самий, що і в першій версії <code>beside</code>, але оскільки він уникає індексації масиву, цей результат отриманий в менш схильний до помилок спосіб.</p></div>
<div class="paragraph"><p>Вам все ще треба спосіб відображати елементи. Як звичайно, це робиться через визначення метода <code>toString</code>, що повертає елемент, відформатований як рядок. Ось визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація <code>toString</code> задіє <code>mkString</code>, що визначене для всіх послідовностей, включаючи масиви. Як ви бачили в Розділі 7.8, вирази, як <code>arr mkString sep</code> повертає рядок, що складається з усіх елементів масива <code>arr</code>. Кожний елемент відзеркалюється на рядок, через виклик для кожного елементу <code>toString</code>. Рядок роздільника, sep, вставляється між послідовними рядками елементів. Так що вираз <code>contents mkString "\n"</code> форматує масив <code>contents</code> як рядок, де кожний елемент масива з'являється на окремому рядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span><span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">(</span>
        <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>
      <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
    <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.9 - Клас <code>Element</code> з <code>above</code>, <code>beside</code> та <code>toString</code>.</p></div>
<div class="paragraph"><p>Зауважте, що <code>toString</code> не має порожнього списку параметрів. Це слідує рекомендаціям для принципа уніформного доступу, оскільки <code>toString</code> є чистим методом, що не приймає жодних параметрів. З додаванням ціх трьох методів, клас <code>Element</code> тепер виглядає як показано в Лістингу 10.9.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_13____">10.13 Визначення об'єкта фабрики</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви маєте ієрархію класів для елементів розташування. Ця ієрархія може бути представлена вашим клієнтам "як є", але ви також можете обрати приховати ієрархію за лаштунками об'єкта фабрики.</p></div>
<div class="paragraph"><p>Об'єкт фабрики містить методи, що конструюють інші об'єкти. Потім клієнти використовують ці методи фабрики, замість конструювання об'єктів напряму за допомогою <code>new</code>. Перевага цього підходу до створення об'єктів в тому, що створення об'єктів може бути централізоване, і деталі того, як об'єкти представлені класами може бути приховане. Це приховування одночасно зробить вашу бібліотеку простішою для розуміння клієнтами, оскільки показані меньше деталей, та провадить вам більше можливостей пізніше змінити реалізацію вашої бібліотеки, не руйнуючи код клієнта.</p></div>
<div class="paragraph"><p>Перше завдання в конструюванні фабрики для ваших об'єктів розташування є обрати, де мають бути розміщені методи фабрики. Чи мають вони бути членами об'єкта синглтона, або класа? Що повинно викликати містячий об'єкт або клас? Існую багато можливостей. Прямолінійне рішення є створити об'єкт компанйон класа <code>Element</code>, та зробити його об'єктом фабрикою для елементів розміщення. Таким чином, вам треба показати вашим клієнтам тільки комбінацію класа/об'єкта, та ви можете приховати три класа реалізації,<code>ArrayElement</code>, <code>LineElement</code>, та <code>UniformElement</code>.</p></div>
<div class="paragraph"><p>Лістинг 10.10 є дизайном об'єкта <code>Element</code>, що слідує цій схемі. Об'єкт  <code>Element</code> містить три перевантажені варіанти метода <code>elem</code>, та кожний конструює різний тип об'єкта розташування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">contents</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">chr</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">UniformElement</span><span class="o">(</span><span class="n">chr</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.10 - Об'єкт фабрики з методом фабрики.</p></div>
<div class="paragraph"><p>З появою ціх методів фабрик має сенс змінити реалізацію класа <code>Element</code>, так щоб він шов через методи фабрик <code>elem</code>, скоріше ніж створювати нові примірники <code>ArrayElement</code> напряму. Щоб викликати методи фабрик, не кваліфікуючи їх іменем об'єкта синглтона, <code>Element</code>, ми будемо імпортувати <code>Element.elem</code> на верхньому рівні джерельного файла. Іншими словами, замість виклику методів фабрик як <code>Element.elem</code> зсередини класу <code>Element</code>,ми імпортуємо <code>Element.elem</code>, так що ви можете просто викликати методи фабрик по їх простому імені, <code>elem</code>. Лістинг 10.11 показує, як буде виглядати клас Element після ціх змін.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="n">elem</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="n">elem</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">(</span>
        <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>
      <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
    <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.11 - Клас <code>Element</code> після рефакторинга з додавання методів фабрик.</p></div>
<div class="paragraph"><p>На додаток, маючи методи фабрик, тепер субкласи <code>ArrayElement</code>, <code>LineElement</code>, <code>UniformElement</code> можуть бути приватними, оскільки вони більше не мають отримувати доступ напряму від клієнтів. В Scala ви можете визначати класи та об'єкти синглтони. Один спосіб зробити субкласи <code>Element</code> приватними - це покласти їх в об'єкт синглтон <code>Element</code>, та декларувати їх там приватними. Класи будуть все ще доступні до трьох методах фабрик <code>elem</code>, де вони потрібні. Лістинг 10.12 показує, як це буде виглядати.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_14___">10.14 Підвищення та розширення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нам треба одне останнє покращення. Версія <code>Element</code>, показана в Лістингу 10.11, не є повністю достатньою, оскільки вона не дозволяє клієнтам покладати елементи з різною шириною один на одний, або класти поряд елементи з різною висотою. Наприклад, обчислення наступних виразів не буде робити коректно, оскільки другий рядок в комбінованому елементі довший, ніж в першому:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">))</span> <span class="n">above</span>
<span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;world!&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, обчислення наступного виразу не буде робити потрібним чином, оскільки перший <code>ArrayElement</code> має висоту два, а другий висоту один:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span> <span class="n">beside</span>
<span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.13 показує приватний допоміжний метод, <code>widen</code>, що приймає ширину, та повертає <code>Element</code> такої ширини. Результат містить вміст цього <code>Element</code>, відцентрований та вирівняний зліва та зправа додатковими проміжками, як треба щоб досягти потрібної ширини. Лістинг 10.13 також показує подібний метод, <code>heighten</code>, що виконує ту саму функцію в вертикальному напрямку. Метод <code>widen</code> викликається в <code>above</code>, щоб переконатись, що <code>Element</code>, покладений над будь-яким іншим, матиме ту саму ширину. Подібно до цього, метод <code>heighten</code> викликається в <code>beside</code>, щоб переконатись, що елементи, розташовані поряд, мають ту саму ширину. З такими змінами бібліотека розташування готова до використання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Element</span> <span class="o">{</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span>
      <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="o">}</span>

    <span class="k">private</span> <span class="k">class</span> <span class="nc">UniformElement</span><span class="o">(</span>
      <span class="n">ch</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span>
      <span class="k">override</span> <span class="k">val</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
      <span class="k">override</span> <span class="k">val</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span>
    <span class="o">)</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
      <span class="k">private</span> <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">toString</span> <span class="o">*</span> <span class="n">width</span>
      <span class="k">def</span> <span class="n">contents</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">height</span><span class="o">)(</span><span class="n">line</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">contents</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">chr</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nc">UniformElement</span><span class="o">(</span><span class="n">chr</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
      <span class="k">new</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.12 - Приховування реалізації за допомогою приватних класів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>

  <span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">this1</span> <span class="k">=</span> <span class="k">this</span> <span class="n">widen</span> <span class="n">that</span><span class="o">.</span><span class="n">width</span>
    <span class="k">val</span> <span class="n">that1</span> <span class="k">=</span> <span class="n">that</span> <span class="n">widen</span> <span class="k">this</span><span class="o">.</span><span class="n">width</span>
    <span class="n">elem</span><span class="o">(</span><span class="n">this1</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that1</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">this1</span> <span class="k">=</span> <span class="k">this</span> <span class="n">heighten</span> <span class="n">that</span><span class="o">.</span><span class="n">height</span>
    <span class="k">val</span> <span class="n">that1</span> <span class="k">=</span> <span class="n">that</span> <span class="n">heighten</span> <span class="k">this</span><span class="o">.</span><span class="n">height</span>
    <span class="n">elem</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">((</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">this1</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that1</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
      <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">widen</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">width</span><span class="o">)</span> <span class="k">this</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">left</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">width</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">right</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">w</span> <span class="o">-</span> <span class="n">width</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
      <span class="n">left</span> <span class="n">beside</span> <span class="k">this</span> <span class="n">beside</span> <span class="n">right</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">heighten</span><span class="o">(</span><span class="n">h</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">&lt;=</span> <span class="n">height</span><span class="o">)</span> <span class="k">this</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">top</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="o">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">height</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">bot</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">height</span> <span class="o">-</span> <span class="n">top</span><span class="o">.</span><span class="n">height</span><span class="o">)</span>
      <span class="n">top</span> <span class="n">above</span> <span class="k">this</span> <span class="n">above</span> <span class="n">bot</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">&quot;\n&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.13 - <code>Element</code> з методами <code>widen</code> та <code>heighten</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_15___">10.15 Складаємо все разом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цікавий спосіб потренуватись з майже всіма елементами бібліотеки розташування - це написати програму, що малює спіраль з заданим числом граней. Ця програма Spiral, показана в Лістингу 10.14, що робить саме це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">object</span> <span class="nc">Spiral</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">space</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">corner</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">spiral</span><span class="o">(</span><span class="n">nEdges</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">direction</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">nEdges</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
      <span class="n">elem</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">sp</span> <span class="k">=</span> <span class="n">spiral</span><span class="o">(</span><span class="n">nEdges</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="o">(</span><span class="n">direction</span> <span class="o">+</span> <span class="mi">3</span><span class="o">)</span> <span class="o">%</span> <span class="mi">4</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">verticalBar</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;|&#39;</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">height</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">horizontalBar</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">,</span> <span class="n">sp</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
        <span class="o">(</span><span class="n">corner</span> <span class="n">beside</span> <span class="n">horizontalBar</span><span class="o">)</span> <span class="n">above</span> <span class="o">(</span><span class="n">sp</span> <span class="n">beside</span> <span class="n">space</span><span class="o">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="o">(</span><span class="n">sp</span> <span class="n">above</span> <span class="n">space</span><span class="o">)</span> <span class="n">beside</span> <span class="o">(</span><span class="n">corner</span> <span class="n">above</span> <span class="n">verticalBar</span><span class="o">)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">direction</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
        <span class="o">(</span><span class="n">space</span> <span class="n">beside</span> <span class="n">sp</span><span class="o">)</span> <span class="n">above</span> <span class="o">(</span><span class="n">horizontalBar</span> <span class="n">beside</span> <span class="n">corner</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="o">(</span><span class="n">verticalBar</span> <span class="n">above</span> <span class="n">corner</span><span class="o">)</span> <span class="n">beside</span> <span class="o">(</span><span class="n">space</span> <span class="n">above</span> <span class="n">sp</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">nSides</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toInt</span>
    <span class="n">println</span><span class="o">(</span><span class="n">spiral</span><span class="o">(</span><span class="n">nSides</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.14 - Застосування Spiral.</p></div>
<div class="paragraph"><p>Оскікльи <code>Spiral</code> є окремий об'єкт з методом <code>main</code> відповідної сигнатури, це застосування Scala. Spiral приймає один аргумент командного рядка як ціле, та малює спіраль з заданим числом граней. Наприклад, ви можете намалювати шісти-гранну спіраль, як показано зліва, та більші спіралі, які показані зправа.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala Spiral 6    $ scala Spiral 11   $ scala Spiral 17
+-----              +----------         +----------------
|                   |                   |
| +-+               | +------+          | +------------+
| + |               | |      |          | |            |
|   |               | | +--+ |          | | +--------+ |
+---+               | | |  | |          | | |        | |
                    | | ++ | |          | | | +----+ | |
                    | |    | |          | | | |    | | |
                    | +----+ |          | | | | ++ | | |
                    |        |          | | | |  | | | |
                    +--------+          | | | +--+ | | |
                                        | | |      | | |
                                        | | +------+ | |
                                        | |          | |
                                        | +----------+ |
                                        |              |
                                        +--------------+</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_16_">10.16 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цьому розділі ви бачили більше концепцій, пов'язаних з об'єктно-орієнтовним програмуванням в Scala. Поміж іншого, вам зустрілись абстрактні класи, наслідквання та субтипи, ієрархії класів, параметричні поля та перекриття методів. Ви мали розвинути відчуття конструювання нетривіальних ієрархій в Scala. Ми будемо знову робити з бібліотекою розташувань в Главі 14.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__11">Глава 11</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__scala">Ієрархія Scala</h1>
<div class="paragraph"><p>Тепер, коли ви бачили деталі наслідування класів в попередньому розділі, настав гарний час зробити крок назад, та подивитись на ієрархію класів в цілому. В Scala кожний клас наслідує від загального суперкласа на ім'я <code>Any</code>. Оскільки кожний клас є субкласом <code>Any</code>, методи, визначені в <code>Any</code> є "універсальними" методами: вони можуть бути викликані на любих об'єктах. Scala також визначає деякі цікаві класи знизу ієрархії, <code>Null</code> та <code>Nothing</code>, що, загалом, діють як загальні субкласи. Наприклад, так само, як <code>Any</code> є суперкласом для кожного іншого класу, <code>Nothing</code> є субкласом кожного іншого класа. В цій главі ми надамо вам тур по ієрархії класів Scala.</p></div>
<div class="sect1">
<h2 id="_11_1___scala">11.1 Ієрархія класів Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Малюнок 11.1 показує контур ієрархії класів Scala. Нагорі ієрархії класів знаходиться клас <code>Any</code>, що визначає методи, включаючі наступні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">def</span> <span class="o">==(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">final</span> <span class="k">def</span> <span class="o">!=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="o">##</span><span class="k">:</span> <span class="kt">Int</span>
<span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span>
<span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки кожний клас наслідує від <code>Any</code>, кожний об'єкт в програмі Scala може бути порівняні з використанням <code>==</code>, <code>!=</code>, або <code>equals</code>; хешовані з використанням <code>##</code> або <code>hashCode</code>; та форматовані з використанням <code>toString</code>. Методи рівності або нерівності, <code>==</code> та <code>!=</code> декларовані як фінальні в класі <code>Any</code>, так що вони не можуть бути перекриті в субкласах. Метод <code>==</code> загалом те саме, що і <code>equals</code>, та <code>!=</code> завжди протилежність до <code>equals</code>.<span class="footnote"><br />[Один випадок, коли <code>==</code> напряму не викликає <code>equals</code>, це для боксованих числових класів Java, такіх, як <code>Integer</code> або <code>Long</code>. В Java <code>new Integer(1)</code> не еквівалентне як <code>equal</code> до <code>new Long(1)</code>, навіть не зважаючи, що для примітивів <code>1 == 1L</code>. Оскільки Scala є більш регулярною мовою, ніж Java, було необхідним скорегувати цю невідповідність через особливий метод == для ціх класів. Подібно, метод <code>##</code> провадить Scala версію хешування, що така сама, як і Java <code>hashCode</code>, за винятко боксованих числових типів, де він робить узгоджено з <code>==</code>. Наприклад, <code>new Integer(1)</code> та <code>new Long(1)</code> хешуються <code>##</code> однаково, не зважаючи на те, що в Java їх <code>hashCode</code> різні.]<br /></span> Так що індивідуальні класи можуть вирішувати, що означає <code>==</code> або <code>!=</code> через перекриття метода <code>equals</code>. Ми покажемо приклад пізніше в цій главі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____scala_3">Ієрархія класів в Scala.</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кореневий клас <code>Any</code> має два субкласи: <code>AnyVal</code> та <code>AnyRef</code>. <code>AnyVal</code> є батьківським класом для класів значень в Scala. Хоча ви можете визначити ваші власні класи значень (дивіться Розділ 11.4), існують дев'ять класів значень, вбудованих в Scala: <code>Byte</code>, <code>Short</code>, <code>Char</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>, <code>Unit</code>. Перші вісім з них відповідають примітивним класам Java, та їх значення представлені під час виконання як примітивні значення Java. Примірники ціх класів всі написані як літерали в Scala. Наприклад, <code>42</code> є примірником of <code>Int</code>, <code>'x'</code> є примірником <code>Char</code>, та <code>false</code> примірник <code>Boolean</code>. Ви не можете створити примірники ціх класів використовуючи <code>new</code>. Це досягається "трюком", так що класи значень всі визначені одночасно абстрактними та фінальними.</p></div>
<div class="paragraph"><p>Так що якщо ви запишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Int</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span> <span class="n">cannot</span> <span class="n">be</span>
<span class="n">instantiated</span>
       <span class="k">new</span> <span class="nc">Int</span>
       <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший клас значення, <code>Unit</code>, грубо відповідає до типу Java <code>void</code>; він використовується як тип результате метода, що інакше не повертає цікавого результата. <code>Unit</code> має єдине значення примірника, що записується <code>()</code>, як обговорюється в Розділі 7.2.</p></div>
<div class="paragraph"><p>Як пояснюється в Главі 5, класи значення підтримують звичайні арифметичні та логічні оператори, як методи. Наприклад, <code>Int</code> має методи на ім'я <code>+</code> та <code>*</code>, та <code>Boolean</code> має методи на ім'я <code>||</code> та <code>&amp;&amp;</code>. Класи значень також наслідують всі методи від класу <code>Any</code>. Ви можете протестувати це в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mf">42.</span><span class="n">toString</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">42.</span><span class="n">hashCode</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">42</span> <span class="n">equals</span> <span class="mi">42</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що простір класів значень плаский; всі класи значень є субтипами <code>scala.AnyVal</code>,але вони не є субкласами один одного. Замість цього, існують неявні перетворення між різними типами класів значень. Наприклад, примірник класу <code>scala.Int</code> за потреби автоматично розширюється (через неявне перетворення) на примірник класу <code>scala.Long</code>.</p></div>
<div class="paragraph"><p>Як зазначається в Розділі 5.10, неявні перетворення також використовуються для додавання більшої функціональності до типів значень. Наприклад, тип <code>Int</code> підтримує всі з операторів нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">42</span> <span class="n">max</span> <span class="mi">43</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">43</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">42</span> <span class="n">min</span> <span class="mi">43</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">5</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range.Inclusive</span>
<span class="k">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">3.</span><span class="n">abs</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(-</span><span class="mi">3</span><span class="o">).</span><span class="n">abs</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як це робить: методи <code>min</code>, <code>max</code>, <code>until</code>, <code>to</code> та <code>abs</code> всі визначені в класі <code>scala.runtime.RichInt</code>, та існує неявне перетворення від класа <code>Int</code> на <code>RichInt</code>. Перетворення набирає чинності, коли на <code>Int</code> викликається метод, що невизначений в <code>Int</code>, але визначений в <code>RichInt</code>. Подібні "бустерні класи" та неявні перетворення існують також для інших класах значень. Неявні перетворення будуть дискутуватись детально в Главі 21.</p></div>
<div class="paragraph"><p>Інший субклас кореневого класа <code>Any</code> є клас <code>AnyRef</code>. Це базовий клас всіх класів посилань в Scala. Як зазначалось раніше, на Java платформі <code>AnyRef</code> фактично є псевдонімом для класа <code>java.lang.Object</code>. Так що класи, написані на Java, так само, як класи, написані на Scala, всі наслідують від <code>AnyRef</code>.<span class="footnote"><br />[Причина, з якої існує псевдонім <code>AnyRef</code>, замість простого використання імені <code>java.lang.Object</code>, є факт, що  Scala була початково розроблена для роботи на обох платформах Java та .NET. На .NET  <code>AnyRefwas</code> є псевдонімом до <code>System.Object</code>.]<br /></span> Таким чином, один зі способів думати про <code>java.lang.Object</code>, є спосіб, як <code>AnyRef</code> реалізований на платформі Java. Так що, хоча ви можете використовувати <code>Object</code> та <code>AnyRef</code> взаємозамінно в програмах Scala на Java платформі, рекомендованим стилем є повсякчасне використання <code>AnyRef</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_11_2___">11.2 Як реалізовані примітиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як це все реалізоване? Фактично, Scala зберігає цілі в той самий спосіб, що і Java — як 32-бітні слова. Це важливо для ефективності на JVM, і також для взаємодії з бібліотеками Java. Стандартні операції, як додавання або множення, реалізовані як примітивні операції. Однак Scala використовує "дублюючий" клас <code>java.lang.Integer</code>, коли ціле має виглядати як (Java) об'єкт. Це трапляється, наприклад, коли викликається метод <code>toString</code> на цілому числі, або коли присвоюються ціле до змінної типу <code>Any</code>. Цілі типу <code>Int</code> при необхідності прозоро конвертуються до "боксованих цілих" типу <code>java.lang.Integer</code>.</p></div>
<div class="paragraph"><p>Все це виглядає як авто-боксування в Java 5, і насправді досить подібно. Однак є одна значна різниця: боксування в Scala значно менш помітне, ніж боксування в Java. Спробуйте наступне в Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="n">boolean</span> <span class="n">isEqual</span><span class="o">(</span><span class="n">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">));</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви, звичайно, отримаєте <code>true</code>. Тепер змініть типи аргументів <code>isEqual</code> на <code>java.lang.Integer</code> (або <code>Object</code>, результат буде той самий):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="n">boolean</span> <span class="n">isEqual</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">));</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви знайдете, що тепер ви отримуєте <code>false</code>! Що відбувається, це число <code>421`боксується  двічі, так що аргументи для `x</code> та <code>y</code> є двома різними об'єктами. Оскільки <code>==</code> означає рівність посилань, та <code>Integer</code> є типом посилання, та результат буде <code>false</code>. Це один з аспектів, який показує, що Java не є чистою об'єктно-орієнтовною мовою. Існує різниця між примітивними типами, та типами посилань, що можливо ясно спостерігати.</p></div>
<div class="paragraph"><p>Тепер спробуємо той самий експеримент в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isEqual</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">isEqual</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">)</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isEqual</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">isEqual</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Any</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Any</span><span class="o">)</span><span class="nc">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Операція еквівалентності <code>==</code> в Scala розроблений бути прозорим з точки зору представлення типу. Для типів значень це природна (числова та логічна) рівність. Для типів посилань, інших ніж боксовані числові типи Java, <code>==</code> трактується як псевдоним для метода <code>equals</code>, наслідуваного від <code>Object</code>. Цей метод в оригіналі визначений як референсна еквівалентність, але перекритий багатьма субкласами для реалізації їх природної нотації рівності. Це також означає, що в Scala ви ніколи не попадете в гарно відому ловушку Java, що стосується порівняння рядків. В Scala порівняння рідків робить як повинно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="s">&quot;abcd&quot;</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cd</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="s">&quot;abcd&quot;</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cd</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>В Java результат порівняння <code>x</code> з <code>y</code> буде <code>false</code>. Програміст має використовувати <code>equals</code> в цьому випадку, але про це легко забути.</p></div>
<div class="paragraph"><p>Однак є ситуації, коли вам потрібна рівність посилань, замість визначеної користувачем рівності. Наприклад, в деяких ситуаціях, де ефективність є понад усе, ви, можливо, вирішите хешувати класи, та порівнювати їх примірники на рівність посилань.<span class="footnote"><br />[Ви хешуєте примірники класу, кешуючи всі примірники, які ви створюєте в слабкій колекції. Потім, кожного разу, коли вам треба новий примірник класу, ви спочатку перевіряєте кеш. Якщо кеш вже має елемент, еквівалентний до того, що ви збираєтесь створити, ви можете повторно використати існуючий примірник. Як результат цього механізму, любі два примірника, що еквівалентні згідно <code>equals()</code>, також є еквівалентні згідно рівності посилань.]<br /></span> Для ціх випадків клас <code>AnyRef</code> визначає додатковий метод <code>eq</code>, що не може бути перекритий, та реалізований як рівність посилання (тобто, він поводиться як <code>==</code> в Java для типів посилань). Також є доповнення до <code>eq</code>, що називається <code>ne</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abc</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abc</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="n">eq</span> <span class="n">y</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="n">ne</span> <span class="n">y</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Еквівалентність в Scala обговорюється далі в Главі 30.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_11_3__">11.3 Нижні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знизу ієрархії типів на Малюнку 11.1 ви бачите два класи, <code>scala.Null</code> та <code>scala.Nothing</code>. Це особливі типи, що обробляють деякі "пограничні випадки" об'єктно-орієнтовної системи типів Scala в уніформний спосіб.</p></div>
<div class="paragraph"><p>Клас <code>Null</code> є типом посилання <code>null</code>; це субклас кожного класу посилань (тобто, кожного класу, що сам наслідує від <code>AnyRef</code>). <code>Null</code> не сумісний з типами значень. Наприклад, ви не можете присвоїти значення <code>null</code> до цілого значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="kc">null</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">an</span> <span class="kt">expression</span> <span class="kt">of</span> <span class="k">type</span> <span class="kt">Null</span> <span class="kt">is</span> <span class="kt">ineligible</span>
<span class="k">for</span> <span class="k">implicit</span> <span class="n">conversion</span>
       <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="kc">null</span>
                    <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>Nothing</code> є на самому дні ієрархії класів Scala; це субтип кожного іншого типу. Однак не існує жодного примірника цього типу. Чому може бути сенс мати тип без значень? Як обговорюється в Розділі 7.4, одне використання <code>Nothing</code> є сигналювання щодо ненормального завершення.</p></div>
<div class="paragraph"><p>Наприклад, існує метод <code>error</code> в об'єкті <code>Predef</code> стандартної бібліотеки Scala, що визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">error</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип повернення <code>error</code> є <code>Nothing</code>, що каже користувачам, що метод не буде повертати значення звичайним чином (замість цього він закидає виключення). Оскільки <code>Nothing</code> є субтипом кожного іншого типу, ви можете використовувати методи, як <code>error</code>, в дуже гнучкі способи. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">divide</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">else</span> <span class="n">error</span><span class="o">(</span><span class="s">&quot;can&#39;t divide by zero&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Гілка <code>then`умовного виразу, `x / y</code>, має тип <code>Int</code>, тоді як гілка <code>else</code> викликає <code>error</code>, та має тип <code>Nothing</code>. Оскільки <code>Nothing</code> є субтипом <code>Int</code>, тип цілого виразу є <code>Int</code>, як це і вимагається.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_11_4_____">11.4 Визначення ваших власних класів значення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Розділі 11.1, ви можете визначити ваші власні класи значень, щоб покращити ті, що вже є вбудовані. Як і вбудовані класи значень, примірник вашого класу значення буде звичайно компілюватись в Java бійткод, що не використовує клас огортки. В контекстах, коли огортка потрібна, як в коді дженериків, значення буде боксоване та розбоксоване автоматично.</p></div>
<div class="paragraph"><p>Тільки певні класи можуть бути перетворені в класи значень. Щоб клас був класом значення, він повинен мати рівно один параметр, і він не повинен містити всередині нічого, за винятком <code>def</code>. Більше того, жодний інший клас не може розширяти клас значення, та клас значення не може перевизначати <code>equals</code> або <code>hashCode</code>.</p></div>
<div class="paragraph"><p>Щоб визначити клас значення, зробіть його субкласом <code>AnyVal</code>, та покладіть <code>val</code> перед одним параметром. Ось приклад класу значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dollars</span><span class="o">(</span><span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="s">&quot;$&quot;</span> <span class="o">+</span> <span class="n">amount</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як описано в Розділі 10.6, префікс <code>val</code> дозволяє параметру <code>amount</code> бути досяжним як поле. Наприклад, наступний код створює примірник класу значення, що отримує значення з поля:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">money</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollars</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>
<span class="n">money</span><span class="k">:</span> <span class="kt">Dollars</span> <span class="o">=</span> <span class="n">$1000000</span>

<span class="n">scala</span><span class="o">&gt;</span><span class="n">money</span><span class="o">.</span><span class="n">amount</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1000000</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі <code>money</code> посилається на примірник класу значення. Його тип в джерельному коді Scala буде <code>Dollars</code>, але скомпільований байткод Java буде напряму використовувати тип  <code>Int</code>.</p></div>
<div class="paragraph"><p>Цей приклад визначає метод <code>toString</code>, і компілятор здогадується, коли його використовувати. Ось чому друк <code>money</code> дає <code>$1000000</code> зі знаком долара, але друк <code>money.amount</code> дає <code>1000000</code>. Ви навіть можете визначити декілька типів значень, що одночасно підтримуються тим самим значенням <code>Int</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SwissFrancs</span><span class="o">(</span><span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; CHF&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть не зважаючи, що обоє, <code>Dollars</code> та <code>SwissFrancs</code> представлені як цілі, це робить добре, коли вони використовуються разом в полі зору:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dollars</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollars</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
<span class="n">dollars</span><span class="k">:</span> <span class="kt">Dollars</span> <span class="o">=</span> <span class="n">$1000</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">francs</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SwissFrancs</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
<span class="n">francs</span><span class="k">:</span> <span class="kt">SwissFrancs</span> <span class="o">=</span> <span class="mi">1000</span> <span class="nc">CHF</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="____10">Уникнення монокультури типів</h3>
<div class="paragraph"><p>Щоб отримати найбільшу вигоду від ієрархії класів Scala, намагайтесь визначати нові класи для кожної галузевої концепції, навіть коли можливо використати той самий клас для різних призначень. Навіть, якщо такий клас є так званим <em>крихітним типом</em> без методів або полів, визначення додаткових класів є шляхом допомогти компілятору бути корисним для вас.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що ви пишете деякий код для генерації HTML. В HTML ім'я стиля представлений як рядок. Так само як ідентифікатори якорів. Сам HTML також є рядком, так що, якщо ви бажаєте, ви можете визначити допоміжний код з використанням рядків, щоб представляти все це, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">title</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">anchor</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">style</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="s">s&quot;&lt;a id=&#39;</span><span class="si">$anchor</span><span class="s">&#39;&gt;&lt;h1 class=&#39;</span><span class="si">$style</span><span class="s">&#39;&gt;</span><span class="si">$text</span><span class="s">&lt;/h1&gt;&lt;/a&gt;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця сигнатура типу має чотири рядки в собі! Такий за-рядковано типізований код технічно строго типізований, але оскільки все в полі зору має тип <code>String</code>, компілятор не може допомогти вам детектувати використання одного, коли ви мали на увазі написати інше. Наприклад, він не зупинить вас від цієї пародії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">title</span><span class="o">(</span><span class="s">&quot;chap:vcls&quot;</span><span class="o">,</span> <span class="s">&quot;bold&quot;</span><span class="o">,</span> <span class="s">&quot;Value Classes&quot;</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">id</span><span class="o">=</span><span class=" -Symbol">&#39;bold</span><span class="err">&#39;</span><span class="o">&gt;&lt;</span><span class="n">h1</span> <span class="n">class</span><span class="o">=</span><span class=" -Symbol">&#39;Value</span>
    <span class="nc">Classes</span><span class="err">&#39;</span><span class="o">&gt;</span><span class="n">chap</span><span class="k">:</span><span class="kt">vcls&lt;/h1&gt;&lt;/a&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей HTML геть перекручений. Призначений для відображення текст <code>"Value Classes"</code> був використаний як клас стилю, та відображений текст є <code>"chap.vcls"</code>, що був задуманий як якір. Щоб довершити все, насправді ідентифікатор якоря є <code>"bold"</code>, що мав бути класом стилю. Не зважаючи на цю комедію помилок, компілятор не вимовив ані слова.</p></div>
<div class="paragraph"><p>Компілятор міг бути більш корисним, якщо ви визначите крихітні типи для кожної доменної концепції. Наприклад, ви можете визначити малий клас для стилю, ідентифікатора якоря, тексту для відображення та HTML. Оскільки ці класи мають один параметр, і не мають членів, вони можуть бути визначені як класи значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Anchor</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">Style</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">Text</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">Html</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці класи можливо написати версію <code>title</code>, що має менш тривіальну сигнатуру типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">title</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">Text</span><span class="o">,</span> <span class="n">anchor</span><span class="k">:</span> <span class="kt">Anchor</span><span class="o">,</span> <span class="n">style</span><span class="k">:</span> <span class="kt">Style</span><span class="o">)</span><span class="k">:</span> <span class="kt">Html</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">Html</span><span class="o">(</span>
    <span class="s">s&quot;&lt;a id=&#39;</span><span class="si">${</span><span class="n">anchor</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s">&#39;&gt;&quot;</span> <span class="o">+</span>
    <span class="s">s&quot;&lt;h1 class=&#39;</span><span class="si">${</span><span class="n">style</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s">&#39;&gt;&quot;</span> <span class="o">+</span>
    <span class="n">text</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span>
    <span class="s">&quot;&lt;/h1&gt;&lt;/a&gt;&quot;</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви спробуєте використати цю версію з аргументами в невірному порядку, компілятор тепер може детектувати помилку. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">title</span><span class="o">(</span><span class="k">new</span> <span class="nc">Anchor</span><span class="o">(</span><span class="s">&quot;chap:vcls&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Style</span><span class="o">(</span><span class="s">&quot;bold&quot;</span><span class="o">),</span>
           <span class="k">new</span> <span class="nc">Text</span><span class="o">(</span><span class="s">&quot;Value Classes&quot;</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Anchor</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Text</span>
                <span class="k">new</span> <span class="nc">Anchor</span><span class="o">(</span><span class="s">&quot;chap:vcls&quot;</span><span class="o">),</span>
                <span class="o">^</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">19</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Style</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Anchor</span>
                <span class="k">new</span> <span class="nc">Style</span><span class="o">(</span><span class="s">&quot;bold&quot;</span><span class="o">),</span>
                <span class="o">^</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">20</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Text</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Style</span>
                <span class="k">new</span> <span class="nc">Text</span><span class="o">(</span><span class="s">&quot;Value Classes&quot;</span><span class="o">))</span>
                <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_5_">11.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми показали вам класи нагорі та знизу ієрархії класів Scala. Тепер, коли ви отримали гарне підгрунтя щодо наслідування класів в Scala, ви готові для розуміння композиції міксінів. В наступній главі ви навчитесь щодо трейтів.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__12">Глава 12</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__13">Трейти</h1>
<div class="paragraph"><p>Трейти є фундаментальною одиницею повторного використання коду в Scala. Трейт енкапсулює визначення методів та полів, що потім може бути використані через його міксування з полями. На відміну від наслідування класів, в якому кожний клас має наслідувати від тільки одного суперкласу, клас може міксувати любе число трейтів. Ця глава показує вам, як роблять трейти, та показує два з найбільш загальних шляхів, як вони можуть бути корисні: розширення інтерфейсів до багатих, та визначення накладуваних модифікацій. Вона також показує, як використовувати трейти <code>Ordered</code> та <code>compares</code> як множинного наслідування в інших мовах.</p></div>
<div class="sect1">
<h2 id="_12_1___">12.1 Як роблять трейти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Визначення трейта виглядає так само, як визначення класу, з тією різницею, що він використовує ключове слово <code>trait</code>. Приклад показаний в Лістингу 12.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;I consume memory, therefore I am!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.1 - Визначення трейта <code>Philosophical</code>.</p></div>
<div class="paragraph"><p>Цей трейт з назвою <code>Philosophical</code>. Він не декларує суперкласа, так що як в класи, він має суперклас по замовчанню, <code>AnyRef</code>. Він визначає один метод, названий <code>philosophize</code>, що є суцільним. Це простий трейт, але достатній для того, як роблять трейти.</p></div>
<div class="paragraph"><p>Коли трейт визначений, він може бути зміксований з класом, використовуючи ключові слова <code>extends</code>, або <code>with</code>. Програмісти Scala "міксують" трейти, скоріше ніж наслідують від них, оскільки міксування трейту має важливі відмінності від множинного наслідування, яке можна знайти в інших мовах. Цей момент дискутується в Розділі 12.6. Наприклад, Лістинг 12.2 показує клас, що міксує трейт <code>Philosophical</code> з використанням <code>extends</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.2 - Міксування трейту використовуючи <code>extends</code>.</p></div>
<div class="paragraph"><p>Ви можете використовувати ключове слово <code>extends</code> для міксування трейта; в цьому випадку ви неявно наслідуєте від суперкласа трейта. Наприклад, в Лістингу 12.2 клас <code>Frog</code> є субкласом <code>AnyRef</code> (суперклас <code>Philosophical</code>), та міксує <code>Philosophical</code>. Методи, наслідувані від трейта, можуть бути використані так само, як і методи, наслідувані від суперкласа. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">frog</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Frog</span>
<span class="n">frog</span><span class="k">:</span> <span class="kt">Frog</span> <span class="o">=</span> <span class="n">green</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">frog</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="n">I</span> <span class="n">consume</span> <span class="n">memory</span><span class="o">,</span> <span class="n">therefore</span> <span class="n">I</span> <span class="n">am</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>Трейт також визначає тип. Ось приклад, в якому <code>Philosophical</code> використовується як тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">phil</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">frog</span>
<span class="n">phil</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">green</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">phil</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="n">I</span> <span class="n">consume</span> <span class="n">memory</span><span class="o">,</span> <span class="n">therefore</span> <span class="n">I</span> <span class="n">am</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>phil</code> є трейт <code>Philosophical</code>. Таким чином, змінна <code>phil</code> може бути ініціалізована любим об'єктом, чий клас міксує <code>Philosophical</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте міксувати трейт в клас, що явно розширює суперклас, ви використовуєте  <code>extends</code> для вказання суперкласа, та <code>mix</code> для підмішування трейта. Лістинг 12.3 показує приклад. Якщо ви бажаєте зміксувати декілька трейтів, ви додаєте більше тверджень <code>with</code>. Наприклад, маючи трейт <code>HasLegs</code>, ви можете міксувати обоє, <code>Philosophical</code> та <code>HasLegs</code> у <code>Frog</code>, як показане в Лістингу 12.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.3 - Mixing in a trait using with.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">HasLegs</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="k">with</span> <span class="nc">HasLegs</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.4 - Міксування декількох трейтів.</p></div>
<div class="paragraph"><p>В прикладі, що ви бачили дотепер, клас <code>Frog</code> наслідував реалізацію <code>philosophize</code> від трейта <code>Philosophical</code>. Альтернативно, <code>Frog</code> може перекривати <code>philosophize</code>. Синтаксис виглядає так, як і перекриття метода, декларованого в суперкласі. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;It ain&#39;t easy being &quot;</span> <span class="o">+</span> <span class="n">toString</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки це нове визначення <code>Frog</code> все ще міксує трейт <code>Philosophical</code>, ви можете використовувати його зі змінними цього типу. Але оскільки <code>Frog</code> перекриває реалізацію <code>Philosophical</code> для <code>philosophize</code>, ви отримаєте нову поведінку при його виклику:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">phrog</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Frog</span>
<span class="n">phrog</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">greenscala</span><span class="o">&gt;</span> <span class="n">phrog</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="nc">It</span> <span class="n">ain</span><span class=" -Symbol">&#39;t</span> <span class="n">easy</span> <span class="n">being</span> <span class="n">green</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій точці ви можете <em>philosophize</em> що трейти подібні до Java інтерфейсів з суцільними методами, але насправді вони можуть значно більше. Наприклад, трейти можуть декларувати поля та підтримувати стан. Фактично, ви можете робити будь-що в визначенні трейта, що ви можете робити в визначенні класу, та синтаксис виглядає так само, з двома виключеннями.</p></div>
<div class="paragraph"><p>Перше, трейт не може мати жодних параметрів "класу" (тобто параметрів, що передаються до первинного конструктора класу). Іншими словами, хоча ви можете визначити клас таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Наступна спроба визначити трейт не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">NoPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// Не компілюється</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите в Розділі 20.5, як обійти це обмеження.</p></div>
<div class="paragraph"><p>Інша різниця між класами та трейтами в тому, що в класах супер виклики статично прив'язані, в трейтах вони прив'язані динамічно. Якщо ви напишете <code>super.toString</code> в класі, ви точно знаєте, який метод реалізації буде викликаний. Однак коли ви пишете те саме в трейті, метод реалізації, що буде викликаний для <code>super</code> виклику невизначений на час визначення трейта. Скоріше реалізація для виклику буде визначена по новій кожного разу, коли трейт підміксовується в суцільний клас. Ця цікава поведінка <code>super</code> є ключем для можливості трейтів робити як накладувані модифікації, що будуть описані в Розділі 12.5. Правила для розрішення супер викликів будуть надані в Розділі 12.6.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_2_____">12.2 Тонкі інтерфейси проти багатих інтерфейсів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одне головне використання трейтів є автоматичне додавання методів до класу в термінах методів, що клас вже має. Тобто трейти можуть збагатити тонкий інтерфейс, перетворяючи його на багатий інтерфейс.</p></div>
<div class="paragraph"><p>Тонкі інтерфейси проти багатих інтерфейсів представляє загально зустріваний компроміс в об'єктно-орієнтовній розробці. Компроміс між реалізаторами та клієнтами інтерфейсу. Багатий інтерфейс має багато методів, що робить його зручним для викликаючого. Клієнти можуть обрати метод, що точно співпадає з потрібною їм функціональністю. З іншого боку, тонкий інтерфейс має меньше методів, і, таким чином, легше для реалізації. Однак клієнти, що викликають тонкий інтерфейс, мають писати більше коду. Маючи менший вибір методів, що можна викликати, вони мають менший за ідеальний вибір для своїх потреб, та пишуть додатковий код, щоб використати його.</p></div>
<div class="paragraph"><p>Інтерфейси Java більш часто тонкі, ніж багаті. Наприклад, <code>CharSequence</code>, що був введений в Java 1.4, є тонким інтерфейсом, загальним для всіх рядок-подібних класів, що містить послідовність символів. Ось його визначення, якщо дивитись на нього як на Scala трейт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">CharSequence</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">charAt</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Char</span>
  <span class="k">def</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">subSequence</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">CharSequence</span>
  <span class="k">def</span> <span class="n">toString</span><span class="o">()</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча більшість з дюжин методів в класі <code>String</code> можна застосувати до любого <code>CharSequence</code>, інтерфейс Java <code>CharSequence</code> декларує тільки чотири методи. Якщо б <code>CharSequence</code> замість цього включав повний інтерфейс <code>String</code>, це б наклало великий безлад на реалізаторів <code>CharSequence</code>. Кожний програміст, що реалізує <code>CharSequence</code> в Java, мав би перевизначати дюжини методів. Оскільки трейти Scala можуть суцільні методи, вони роблять багаті інтерфейси значно більш зручними.</p></div>
<div class="paragraph"><p>Додавання суцільного метода до трейта схиляє компроміс тонкий-багатий в напрямку багатих інтерфейсів. На відміну від Java, додавання суцільного метода до трейта Scala є одноразовим зусиллям. Вам треба тільки реалізовати метод один раз, в самому трейті, замість потреби повторно реалізовувати його для кожного класу, що міксується з цім трейтом. Таким чином, багаті інтерфейси вимагають меньшої роботи в Scala, ніж в мові без трейтів.</p></div>
<div class="paragraph"><p>Щоб збагатити інтерфейс з використанням трейтів, просто визначте трейт з малим числом абстрактних методів — тонку частину інтерфейса трейта — та потенційно велике число конкретних методів, всі реалізовані в термінах абстрактних методів. Потім ви можете міксувати збагачений трейт в клас, реалізувати тонку частину інтерфейсу, та опинитись з класом з цілим багатим інтерфейсом.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_3____">12.3 Приклад: прямокутні об'єкти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Графічні біблиотеки часто мають багато різних класів, що представляють дещо прямокутне. Деякими прикладами є вікна, бітові зображення, та регіони, обрані мишею. Щоб зробити ці прямокутні об'єкти зручними для використання, було б гарним, щоб бібліотека провадила геометричні запити, такі як <code>width</code>, <code>height</code>, <code>left</code>, <code>right</code>, <code>topLeft</code>, і так далі. Однак, існує багато таких методів, які було б добре мати, так що дописувачі бібліотеки мають великий безлад, провадячи їх до всіх прямокутних об'єктів в Java бібліотеці. Якщо така бібліотека була б написана на Scala, для контрасту, дописувач бібліотеки міг би використовувати трейти, щоб з легкістю запропонувати всі ці зручні методи для всіх класів, до яких побажає.</p></div>
<div class="paragraph"><p>Щоб побачити як це буде, спершу уявімо, як мав би виглядати код без трейтів. Мали б бути базові геометричні класи, як <code>Point</code> та <code>Rectangle</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">val</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span><span class="o">,</span> <span class="k">val</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас <code>Rectangle</code> приймає дві точки в його первинному конструкторі: координати верхнього-лівого та нижнього-правого кутів. Потім він реалізує багато зручних методів, такі як <code>left</code>, <code>right</code> та <code>width</code>, через виконання простих обчислень на ціх двох точках.</p></div>
<div class="paragraph"><p>Інший клас графічної бібліотеки може мати 2-D графічний віджет:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Pointdef</span>
  <span class="n">вуа</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що визначення <code>left</code>, <code>right</code> та <code>width</code> в точності такі самі в двох класів. Вони також будуть ті самі, крім декількох малих варіацій, в любих інших класах для прямокутних об'єктів.</p></div>
<div class="paragraph"><p>Ця репрезентація може бути усунута за допомогою збагаючуючого трейта. Трейт буде мати два абстрактні метода: один що повертатиме верхню-ліву координату об'єкта, та інший, що повертає нижню-праву координату. Потім він може надати суцільні реалізації всіх інших геометричних запитів. Лістинг 12.5 показує, як це буде виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Rectangular</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.5 - Визначення покращеного трейта.</p></div>
<div class="paragraph"><p>Клас <code>Component</code> може зміксувати трейт, щоб отримати всі геометричні методи, що провадить <code>Rectangular</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="k">extends</span> <span class="nc">Rectangular</span> <span class="o">{</span>
<span class="c1">// інші методи...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, сам <code>Rectangle</code> може міксувати трейт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">val</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span><span class="o">,</span> <span class="k">val</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Rectangular</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// інші методи...</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці визначення, ви можете створити <code>Rectangle</code>, та викликати геометричні методи, такі як <code>width</code> та <code>left</code> на ньому:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rect</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
           <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">))</span>
<span class="n">rect</span><span class="k">:</span> <span class="kt">Rectangle</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="k">@</span><span class="mi">5</span><span class="n">f5da68c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">left</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">right</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">width</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_4__">12.4 Впорядкований трейт</h2>
<div class="sectionbody">
<div class="paragraph"><p>Порівняння є інша галузь, де багаті інтерфейси є зручними. Коли ви порівнюєте два об'єкти, що є впорядкованими, зручно, якщо ви використовуєте простий виклик метода, щоб запитати щодо точного порівняння, яке ви бажаєте. Якщо ви бажаєте "менше ніж", ви можете викликати <code>&lt;</code>, та якщо ви бажаєте "меньше або рівне", ви бажаєте викликати <code>&lt;=</code>. З тонким інтерфейсом порівняння, ви можете мати лише метод <code>&lt;</code>, та ви можете іноді писати речі як <code>(x &lt; y) || (x == y)</code>. Багаті інтерфейси будуть провадити всі зі звичайних операторів порівняння, таким чином дозволяючи вам писати речі, як <code>x &lt;= y</code>.</p></div>
<div class="paragraph"><p>Перед поглядом на <code>Ordered</code>, уявімо, що б ви могли робити без нього. Уявімо, що ви взяли клас <code>Rational</code> з Глави 6, та додали до нього операції порівняння:<span class="footnote"><br />[Цей приклад базується на класі <code>Rational</code>, показаному в Лістингу 6.5, з доданими <code>equals</code>, <code>hashCode</code> та модифікаціями, що запевняють в позитивному займеннику.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// ...</span>
  <span class="k">def</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span>
  <span class="k">def</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="n">that</span> <span class="o">&lt;</span> <span class="k">this</span>
  <span class="k">def</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">that</span><span class="o">)</span>
  <span class="k">def</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">that</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">that</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас визначає чотири оператора порівняння (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, та <code>&gt;=</code>), та це класична демонстрація ціни визначення багатого інтерфейсу. Перше, зауважте, що три оператора порівнянь визначені в термінах першого. Наприклад, <code>&gt;</code> визначений як зворотній до <code>&lt;</code>, та <code>&lt;=</code> визначений буквально як "менше ніж або дорівнює". Далі, зауважте, що всі три з ціх методів будуть ті самі для любого іншого класу, який підтримує порівняння. Немає нічого особливого щодо раціональних чисел відносно <code>&lt;=</code>. В контексті порівняння <code>&lt;=</code> завжди використовується для позначення "меньше ніж або дорівнює". Загалом, присутнє багато шаблонного коду в цьому класі, який буде тим самим в іншому класі, що реалізує операції порівняння.</p></div>
<div class="paragraph"><p>Ця проблема така загальна, що Scala провадить трейт щоб допомогти вам з цім. Трейт має назву <code>Ordered</code>. Щоб використати його, ви заміняєте всі індивідуальні методи порівняння на єдиний метод <code>compare</code>. Потім трейт <code>Ordered</code> визначає <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, та <code>&gt;=</code> за вас в термінах цього одного метода. Таким чином, трейт <code>Ordered</code> дозволяє вам збагатити клас за допомогою методів порівнянь, через реалізацію тільки одного метода <code>compare</code>.</p></div>
<div class="paragraph"><p>Ось як тепер це виглядає, якщо ви визначите операції порівняння в <code>Rational</code> через використання трейта <code>Ordered</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span> <span class="o">{</span>
<span class="c1">// ...</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує тільки дві речі, що залишилось зробити. Перше, ця версія <code>Rational</code> міксує трейт  <code>Ordered</code>. На відміну від трейтів, що ви бачили дотепер, <code>Ordered</code> вимагає від вас вказати <em>параметр типу</em>, коли ви міксуєте його. Параметри типів не обговорюються в деталях до Глави 19, але поки все що вам треба знати, це що коли ви міксуєте клас з <code>Ordered</code>, насправді ви міксуєте <code>Ordered[C]</code>, де <code>C</code> є класом, елементи якого ми порівнюємо. В цьому випадку <code>Rational</code> міксується з <code>Ordered[Rational]</code>.</p></div>
<div class="paragraph"><p>Друга річ, що вам треба зрбити, це визначити метод <code>compare</code> для порівняння двох об'єктів. Цей метод буде порівнювати отримувача, <code>this</code>, з об'єктом, переданим як аргумент до метода. Він має повертати ціле число, що буде нуль, якщо об'єкти однакові, від'ємне, якщо отримувач менший за аргумент, та додатнє, якщо отримувач більший за аргумент.</p></div>
<div class="paragraph"><p>В цьому випадку, метод порівняння в <code>Rational</code> використовує формулу, базовану на конвертації дрібу до загального займенника, та потім віднімання отриманих чисельників. Маючи цей міксін та визначення <code>compare</code>, тепер клас <code>Rational</code> має всі чотири методи порівняння:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">half</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">half</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">third</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">third</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">half</span> <span class="o">&lt;</span> <span class="n">third</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">half</span> <span class="o">&gt;</span> <span class="n">third</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожного разу, коли ви реалізуєте клас, що впорядкований згідно деякого порівняння, ви маєте міксувати його з трейтом <code>Ordered</code>. Якщо ви зробите це, ви запровадите користувачів класа багатим набором методів порівняння.</p></div>
<div class="paragraph"><p>Зважайте, що трейт <code>Ordered</code> не визначає метод <code>equals</code> за вас, оскільки він не може цього зробити. Проблема в тому, що реалізація <code>equals</code> в термінах <code>compare</code> вимагає перевірки типу переданого об'єкту, та завдяки затиранню типів, сам по собі <code>Ordered</code> не може зробити цю перевірку. Таким чином, вам треба самому визначити <code>equals</code>, навіть якщо ви наслідуєте <code>Ordered</code>. Ви знайдете як це робити в Главі 30.</p></div>
<div class="paragraph"><p>Повний трейт <code>Ordered</code>, мінус коментарі та дещо для сумісності, виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>

  <span class="k">def</span> <span class="o">&lt;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&gt;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&lt;=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&gt;=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Не дуже турбуйтесь щодо <code>T</code> та <code>[T]</code>. Тут <code>T</code> є параметром типу, як описано в деталях в Главі 19. Для розуміння трейту <code>Ordered</code> просто думайте про нього, як про "той самий тип, що і отримувач". Потім ви можете бачити, що цей трейт визначає один абстрактний метод, <code>compare</code>, що, як очікується, буде порівнювати отримувач (<code>this</code>) з іншим об'єктом того самого типу, що і отримувач (<code>that</code>). Маючи цей метод, <code>Ordered</code> може провадити суцільні визначення для <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> та <code>&gt;=</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_5____">12.5 Трейти як накладувані модифікації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили одне головне затосування трейтів: перетворення тонких інтерфейсів в багаті. Тепер ми звернемось до другого головного застосування: провадити накладувані модифікації для класів. Трейти дозволяють <em>модифікувати</em> методи класів, і вони роблять це в такий спосіб, що дозволяє вам накладати ці модифікації одне на одне.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо накладання модифікацій для церги з цілих чисел. Черга буде мати дві операції: <code>put</code>, що покладає цілі в чергу, та <code>get</code>, що вибирає їх звідси. Черги побудовані як перший-увійшов перший-вийшов, так що <code>get</code> повинен повертати цілі в тому ж порядку, в якому вони були покладені <code>put</code> в чергу.</p></div>
<div class="paragraph"><p>Маючи клас, що реалізує таку чергу, ви можете визначити трейти для виконання модифікацій, як такі:</p></div>
<div class="ulist"><ul>
<li>
<p>
Doubling: подвоює всі цілі, що поставлені в чергу
</p>
</li>
<li>
<p>
Incrementing: збільшує всі цілі, що поставлені в чергу
</p>
</li>
<li>
<p>
Filtering: відфільтровує від'ємні цілі з черги
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ці три трейти представляють модифікації, оскільки вони модифікують поведінку класу підлеглої черги, скоріше, ніж самому визначати повний клас черги. Ці три також можна накладувати один на одний. Ви можете обрати любі з ціх трьох, зміксувати їх в клас, та отримати новий клас, який матиме всі модифікації, що ви обрали.</p></div>
<div class="paragraph"><p>Абстрактний клас <code>IntQueue</code> показаний на Лістингу 12.6. <code>IntQueue</code> має метод <code>put</code>, що додає нові цілі до черги, та метод <code>get</code>, що видлаяє та повертає їх. Базова реалізація <code>IntQueue</code>, що використовує <code>ArrayBuffer</code>, показана в Лістингу 12.7.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.6 - Абстрактний клас <code>IntQueue</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">class</span> <span class="nc">BasicIntQueue</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span> <span class="k">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.7 - <code>BasicIntQueue</code> реалізований з допомогою <code>ArrayBuffer</code>.</p></div>
<div class="paragraph"><p>Клас <code>BasicIntQueue</code> має приватне поле, що містить буферний масив. Метод <code>get</code> видаляє входження з одного кінця буфера, тоді як метод <code>put</code> додаєж елементи з іншого кінця. Ось як ця реалізація виглядає, коли ви використовуєте її:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="o">=</span> <span class="nc">BasicIntQueue</span><span class="k">@</span><span class="mi">23164256</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Доки все добре. Тепер поглянемо на використання трейтів для модифікації цієї поведінки. Лістинг 12.8 показує трейт, що подвоює цілі, по мірі того, як воні покладаються в чергу. Трейт <code>Doubling</code> має дві цікаві речі, що відбуваються. Перша це те, що він декларує суперклас <code>IntQueue</code>. Ця декларація означає, що трейт може бути міксований в клас, що також розширює <code>IntQueue</code>. Таким чином, ви можете міксувати <code>Doubling</code> в <code>BasicIntQueue</code>, але не в <code>Rational</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Doubling</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.8 - Трейт накладуваної модифікації <code>Doubling</code>.</p></div>
<div class="paragraph"><p>Друга цікава річ в тому, що трейт має супер виклик на методі, що визначений як абстрактний. Такі виклики нелегальні для звичайних класів, оскільки вони напевне будуть схиблювати під час виконання. Однак для трейта такий виклик насправді може бути успішним. Оскільки супер виклики в трейті динамічно зв'язані, супер виклик в трейті <code>Doubling</code> буде робити до тих пір, доки трейт міксований після іншого трейта або класа, що надає суцільне визначення методу.</p></div>
<div class="paragraph"><p>Цей механізм часто потрібний для трейтів, коли реалізуються накладувані модифікації. Щоб сказати компілятору, що ви робите це навмисно, ви маєте позначити такі методи як <code>abstract override</code>. Ця комбінація модифікаторів дозволена тільки для членів трейтів, не класів, і це означає, що трейт має бути зміксований в деякий клас, що має суцільне визначення розглядуваного метода.</p></div>
<div class="paragraph"><p>З таким простим трейтом можливі багато речей! Ось як виглядає використання цього трейта:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyQueue</span> <span class="k">extends</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">MyQueue</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MyQueue</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">MyQueue</span> <span class="o">=</span> <span class="nc">MyQueue</span><span class="k">@</span><span class="mi">44</span><span class="n">bbf788</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому рядку цієї сессії інтерпретатора ми визначаємо клас <code>MyQueue</code>,що розширює <code>BasicIntQueueand</code> з міксованим <code>Doubling</code>. Потім ми покладаємо <code>10</code> в чергу, але оскільки був доміксований <code>Doubling</code>, <code>10</code> було подвоєне. Коли ви отримаєте ціле з черги, це буде 20.</p></div>
<div class="paragraph"><p>Зауважте, що <code>MyQueue</code> не визначає новий код. Він просто ідентифікує клас та міксує трейт. В цій ситуації ви можете просто надати <code>BasicIntQueue with Doubling</code> напряму до <code>new</code>, замість визначення іменованого класу. Це буде виглядати як показано в Лістингу 12.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Doubling</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">141</span><span class="n">f05bf</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.9 - Міксування трейту при створенні екземпляру за допомогою <code>new</code>.</p></div>
<div class="paragraph"><p>Щоб побачити, як накладати модифікації, нам треба визначити інша два трейта модифікації, <code>Incrementing</code> та <code>Filtering</code>. Реалізації ціх трейтів показані в Лістингу 12.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Incrementing</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Filtering</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.10 - Накладувані модифікації в вигляді трейтів <code>Incrementing</code> та <code>Filtering</code>.</p></div>
<div class="paragraph"><p>Маючи ці модифікації ви можете тепер обирати, які саме ви бажаєте застосувати для певної черги. Наприклад, ось черга, що одначасно фільтрує від'ємні числа та додає одиницю до всіх чисел, які вона містить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">BasicIntQueue</span>
<span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Filtering</span><span class="o">)</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Incrementing</span> <span class="kt">with</span> <span class="kt">Filtering...</span>

<span class="kt">scala&gt;</span> <span class="kt">queue.put</span><span class="o">(</span><span class="kt">-</span><span class="err">1</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Порядок міксінів важливий.<span class="footnote"><br />[Коли трейт заміксований в клас, ви можете альтернативно називати його міксін.]<br /></span> Точні правила надаються в наступному розділі, але грубо кажучи, трейти, що стоять більш зправа, набувають чинності перші. Коли ви викликаєте метод або клас на міксіні, метод в трейті, що правіший, буде викликаний першим. Якщо метод визиває <code>super</code>, він викликає наступний трейт, що лівіше, і так далі. В попередньому прикладі <code>Filtering</code> <code>put</code> викликається першим, так що він для початку видаляє від'ємні цілі. <code>Incrementing</code> <code>put</code> викликається другим, так що він додає одиницю до цілих, що залишились.</p></div>
<div class="paragraph"><p>Якщо ви вмінити порядок, цілі спочатку будуть збільшені, та потім цілі, що все ще від'ємні, будуть відкинуті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">BasicIntQueue</span>
           <span class="k">with</span> <span class="nc">Filtering</span> <span class="k">with</span> <span class="nc">Incrementing</span><span class="o">)</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Filtering</span> <span class="kt">with</span> <span class="kt">Incrementing...</span>

<span class="kt">scala&gt;</span> <span class="kt">queue.put</span><span class="o">(</span><span class="kt">-</span><span class="err">1</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Загалом, код, що написаний в такому стилі дає вам добрі можливості щодо гнучкості. Ви можете визначити шістнадцять різних класів, міксуючи ці три трейти в різних комбінаціях на порядках. Це багато гнучкості для невеликого обсягу коду, так що ви маєте тримати очі відкритими в пошуках можливостей втілити в коді накладувані модифікації.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_6____">12.6 Чому не множинне наслідування?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Трейти є шляхом наслідувати від багатьох класо-подібних конструкцій, але вони відрізняються в важливий спосіб від множинного наслідування, що присутнє в інших мовах. Одна різниця є особливо важливою: інтерпретація <code>super</code>. З множинним наслідуванням метод, що викликається через <code>super</code> може бути викликаний саме там, де відбувається виклик. З трейтами викликаний метод визначається через лінеарізацію класів та трейтів, зміксованих в клас. Ця різниця дозволяє накладання модифікацій, описану в попередньому розділі.</p></div>
<div class="paragraph"><p>Перед тим, як поглянути на лінеарізацію, ми витратимо момент, та розглянемо, як накладати модифікації в мові з традиційним множинним наслідуванням. Уявімо наступний код, але на цей раз інтерпретований як множинне наслідування замість міксування трейтів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Множинне наслідування як експерімент</span>
<span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="c1">// який put має бути викликаний?</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше питання: який метод <code>put</code> буде викликаний, коли робиться цей виклик? Можливо, правило буде таке, що останній суперклас перемагає, в якому випадку буде викликаний <code>Doubling</code>. <code>Doubling</code> подвоїть свій аргумент, та викличе <code>super.put</code>, і це вже буде кінець. Інкрементація не відбудеться! Так само, якщо правило буде таке, що перший суперклас перемагає, отримана черга буде збільшувати цілі, але не подвоювати їх. Так що жодний порядок не буде робити.</p></div>
<div class="paragraph"><p>Ви можете також прокрутити таку можливість: дозволити програмістам вказати, який метод суперкласу вони мають на увазі, коли кажуть <code>super</code>. Наприклад, уявімо наступний Scala-подібний код, в якому <code>super</code> явно викликається на обох, <code>Incrementing</code> та <code>Doubling</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Експерименти з множинним наслідуванням</span>
<span class="k">trait</span> <span class="nc">MyQueue</span> <span class="k">extends</span> <span class="nc">BasicIntQueue</span>
    <span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Doubling</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Incrementing</span><span class="o">.</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// (Несправжня Scala)</span>
    <span class="nc">Doubling</span><span class="o">.</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей підхід дає нам нові проблеми (балакучість цього підходу є найменьшою з його проблем). Що відбудеться, це те, що метод <code>put</code> базового класу буде викликано двічі, перший раз для збільшеного значення, та ще раз для подвоєного значення, але жодного разу для збільшеного та подвоєного значення.</p></div>
<div class="paragraph"><p>Просто не існує гарного рішення цієї проблеми з використанням множинного наслідування. Вам доведеться переробити код в інший спосіб. Для контрасту, рішення з трейтами в Scala є прямолінійним. Ви просто міксуєте <code>Incrementing</code> та <code>Doubling</code>, та спеціальне трактування super в трейтах Scala робить всю іншу роботу. Тут дещо чітко відрізняється від традиційного множинного наслідування, але що? Як ми натякали перед цім, відповідь є лінеарізація. Коли ми створюємо примірник класу за допомогою <code>new</code>, Scala бере клас та всі його унаслідувані класи та трейти, та шакує їх в єдиний, лінійний порядок. Тоді,якщо ви викликаєте <code>super</code> в одному з ціх класів, викликаний метод є наступним в черзі. Якщо всі методи, крім останнього, викликають <code>super</code>, чистим результатом буде накладання поведінки.</p></div>
<div class="paragraph"><p>Точний порядок лінеарізації описаний в специфікації мови. Він трохи заскладний, але головна річ, що вам треба знати, це що при любій лінеаризації клас клас завжди лінеаризується перед усіма своїми суперкласами та доміксованими трейтами. Таким чином, коли ви пишете метод, що викликає <code>super</code>, цей метод напевне модифікує поведінку суперкласів і зміксованих трейтів, і іншого шляху немає.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Залишок цього розділу описує деталі лінеаризації. Ви можете безпечно пропустити залишок цього розділу, якщо ви не зацікавлені розуміти ці деталі просто зараз.</td>
</tr></table>
</div>
<div class="paragraph"><p>Головні властивості лінеаризації Scala проілючтровані на наступному прикладі: скажімо, ви маєте клас <code>Cat</code>, що наслідує від суперкласа <code>Animal</code>, та двох супертрейтів, <code>Furry</code> та <code>FourLegged</code>. <code>FourLegged</code>, в свою чергу, розширює трейт <code>HasLegs</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">Furry</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">HasLegs</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">FourLegged</span> <span class="k">extends</span> <span class="nc">HasLegs</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Furry</span> <span class="k">with</span> <span class="nc">FourLegged</span>
</pre></div></div></div>
<div class="paragraph"><p>Ієрархія наслідування та лінеаризація класу Cat показана на Малюнку 12.1. Наслідування використовує традиційну UML нотацію:<span class="footnote"><br />[Rumbaugh, et. al., The Unified Modeling Language Reference Manual. [Rum04]]<br /></span> стрілки з білими трикутними наконечниками означають наслідування, стрілки вказують на супертипи. Стрілки з темнішими, не трикутними наконечниками позначають лінеаризацію. Темніші стрілки вказують в напрямку, в якому будуть розрішуватись виклики <code>super</code>.</p></div>
<div class="paragraph"><p>Малюнок 12.1 - Ієрархія наслідування і лінеарізація класу Cat.</p></div>
<div class="paragraph"><p>Лінеаризація <code>Cat</code> обчислюється яз кінця в начало наступним чином. Остання частина лінеаризації <code>Cat</code> є лінеаризація його суперкласу <code>Animal</code>. Ця лінеаризація копіюється без всяких змін. (Лінеаризація кожного з ціх типів показана в Таблиці 12.) Оскільки  <code>Animal</code> явно не розширює суперклас, або не міксує якийсь трейт, він по замовчанню розширює <code>AnyRef</code>, що розширює <code>Any</code>. Таким чином лінеаризація <code>Animal</code> виглядає так:</p></div>
<div class="paragraph"><p>Друга з кінця частина є лінеаризація першого міксіна, трейта <code>Furry</code>, але всі класи, що вже знаходяться в лінеаризації <code>Animal</code> тепер відкидаються, так що кожний клас з'являється тільки один раз в лінеаризації <code>Cat</code>. Результат такий:</p></div>
<div class="paragraph"><p>За цім слідує лінеаризація <code>FourLegged</code>, де знову любі класи, що вже були скопійовані в лінеаризації суперкласів або першого міксіну відкидаються:</p></div>
<div class="paragraph"><p>Нарешті, перший клас в лінеаризації <code>Cat</code> є сам <code>Cat</code>:</p></div>
<div class="paragraph"><p>Коли кожний з ціх класів та трейтів викликає метод через <code>super</code>, викликається реалізація, що буде першою реалізацією зправа в лінеаризації.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 12.1 Лінеарізація типів в ієрархії Cat</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Тип </th>
<th align="center" valign="top"> Лінеаризація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right" valign="top"><p class="table">Animal</p></td>
<td align="left" valign="top"><p class="table">Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">Furry</p></td>
<td align="left" valign="top"><p class="table">Furry, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">FourLegged</p></td>
<td align="left" valign="top"><p class="table">FourLegged, HasLegs, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">HasLegs</p></td>
<td align="left" valign="top"><p class="table">HasLegs, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">Cat</p></td>
<td align="left" valign="top"><p class="table">Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_12_7___">12.7 Чи використовувати трейти?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли ви реалізуєте повторно використовувану колекцію поведінок, ви повинні прийняти рішення, чи ви бажаєте використати трейт або абстрактний клас. Немає надійного правила, але цей розділ містить декілька настанов, які треба зважити.</p></div>
<div class="paragraph"><p><em>Якщо поведінка не буде використовуватись повторно</em>, тоді робіть суцільний клас. Кінець кінцем це не повторно використовувана поведінка.</p></div>
<div class="paragraph"><p>_Якщо вона може бути використана в декількох непов'язаних класах_, зробіть трейт. Тільки трейти можуть бути зміксовані в різні частини ієрархії класів.</p></div>
<div class="paragraph"><p><em>Якщо ви бажаєте наслідувати від поведінки в Java коді</em>, використовуйте абстрактний клас. Оскільки трейти з кодом не мають близького Java аналогу, як правило незручно наслідувати від трейта в Java класі. В той же час, наслідувати від Scala класу є точно таким же, як наслідування від Java класу. Як одне виключення, трейт Scala з тільки одними абстрактними членами транслюється напряму в Java інтерфейс, так що ви можете вільно визначати такі трейти, навіть якщо очікуєте, що Java код буде наслідувати від них. Дивіться Розділ 31 щодо додаткової інформації по роботі з Java та Scala разом.</p></div>
<div class="paragraph"><p><em>Якщо ви плануєте розповсюджувати це в компільованій формі</em>, та ви очікуєте, що зовнішні групи будуть писати класи з наслідуванням від вашого коду, ви можете трохи ухилитись, використовуючи абстрактний клас. Проблема в тому, що коли трейт отримує або втрачає член, любі класи, що наслідують від нього, мають бути перекомпільовані, навіть якщо вони не змінились. Якщо зовнішні клієнти будуть тільки викликати поведінку, замість наслідувати від неї, тоді використання трейтів є гарним.</p></div>
<div class="paragraph"><p><em>Якщо ви все ще не знаєте</em>, навіть після розляду питань вище, тоді починайте створивши трейт. Ви завжди можете поміняти це пізніше, і, загалом, трейт тримає більше опцій відкритими.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_8_">12.8 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава показала вам як роблять трейти, та як використовувати їх в декількох загальних ідіомах. Ви побачили, як трейти подібні до множинного наслідування. Але, оскілкьи трейти інтерпретують <code>super</code> з використанням лінеаризації, вони одночасно уникають деяких складнощей традиційного множинного наслідування, та дозволяють вам накладати поведінку. Ви також бачили трейт <code>Ordered</code>, та навчились, як писати ваші власні збагачуючі трейти.</p></div>
<div class="paragraph"><p>Тепер, коли ви побачили всі ці грані, має сенс відступити назад, та зробити ще один погляд на трейти як на ціле. Трейти не тільки просто підтримують ідіоми, описані в цій главі; вони є фундаментальною одиницею коду, що повторно використовується через інтерфейс. Ось чому багато досвідчених Scala програмістів починають з трейтів, коли вони знаходяться на ранішній стадії реалізації. Кожний трейт може містити меньше ніж цілу концепцію, а тільки фрагмент концепції. По мірі застигання розробки фрагменти можуть бути скомбіновані в більш цілісні концеації через міксування трейтів.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__13_2">Глава 13</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____11">Пакунки та імпорти</h1>
<div class="paragraph"><p>Коли ви робите над програмою, особливо над великою, є важливим мінімізувати зчеплення — міру, в якій різні частини програми попокладаються одна на одну.Низьке зчеплення зменьшує ризик що малі, виглядаючі невинними зміни в одній частині програми, будуть мати руйнівні наслідки для іншої частини. Одним з шляхів зменшити зчеплення є писати в модулярному стилі. Ви поділяєте програму на декілька меньших модулів, кожна з яких має інутнішнє та зовнішнє. Коли робите всередині модуля, його реалізації, вам треба координуватись тільки з програмістами, що роблять тільки з тим самим модулем. Тільки коли ви маєте змінити зовнішність модуля, його інтерфейси, потрібно скоординувати дії з розробниками, що роблять з іншими модулями.</p></div>
<div class="paragraph"><p>Ця глава показує декілька конструкцій, що допомагають вам програмувати в модульному стилі. Він показує, як покласти речі в пакунок, зробити імена видимі через імпорт, та контролювати видимість через модифікатори доступу. Конструкції подібні по духу до конструкцій Java, але є деякі відмінності, звичайно щоб зробити речі дещо узгодженими, так що має сенс прочитати цю главу, навіть якщо ви вже знаєте Java.</p></div>
<div class="sect1">
<h2 id="_13_1____">13.1 Покладання коду в пакунки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Код Scala розташовується в глобальній ієрархії пакунків Java. Приклад коду, що ви бачили дотепер в цій книзі, знаходився в безіменному пакунку. Ви можете покласти код в іменовані пакунки в Scala в два способи. Перше, ви можете покласти вміст цілого файлу в пакунок, поставивши твердження <code>package</code> зверху файла, як показано в Лістингу 13.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets.navigation</span>
<span class="k">class</span> <span class="nc">Navigator</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.1 - Покладання вмісту цілого файла в пакунок.</p></div>
<div class="paragraph"><p>Твердження <code>package</code> в Лістингу 13.1 покладає клас <code>Navigator</code> в пакунок на ім'я <code>bobsrockets.navigation</code>. Імовірно, це програмне забезпечення навігації, розроблене Bob&#8217;s Rockets, Inc.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Оскільки код Scala є частиною екосистеми Java, рекомендовано слідувати домовленості Java щодо реверсно-доменного іменування для пакунків Scala, які ви випускаєте на публіку. Таким чином, краще ім'я для пакунку <code>Navigator</code> може бути <code>com.bobsrockets.navigation</code>. Однак в цій главі ми полишимо частку <code>com.</code>, щоб зробити приклади простіші до розуміння.</td>
</tr></table>
</div>
<div class="paragraph"><p>Інший спосіб покласи код в пакунок в Scala більш подібний на простори імен C#. Ви ставите за твердженням <code>package</code> розділ в фігурних дужках, що містить визначення, які підуть до пакунка. Цей синтаксис називається пакуванням. Пакування, показане в Лістингу 13.2, має той самий ефект, що і код в Лістингу 13.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets.navigation</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Navigator</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.2 - Довга форма для простої декларації пакунку.</p></div>
<div class="paragraph"><p>Для такого простого прикладу ви можете також використовувати синтаксичний цукор, показаний в Лістингу 13.1. Однак, одне використання більш загальної нотації є мати різні частині файлу в різних пакунках. Наприклад, ви можете вставити тести класа в той самий файл, що і оригінальний код, але покласти тести в окремі пакунки, як показано в Лістингу 13.3.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
<span class="c1">// В пакунку bobsrockets.navigation</span>
    <span class="k">class</span> <span class="nc">Navigator</span>

    <span class="k">package</span> <span class="nn">tests</span> <span class="o">{</span>
      <span class="c1">// В пакунку bobsrockets.navigation.tests</span>
      <span class="k">class</span> <span class="nc">NavigatorSuite</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.3 - Декілька пакунків в тому самому файлі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
    <span class="k">class</span> <span class="nc">Navigator</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.navigation.StarMap</span>
      <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StarMap</span>
    <span class="o">}</span>
    <span class="k">class</span> <span class="nc">StarMap</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Ship</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.navigation.Navigator</span>
    <span class="k">val</span> <span class="n">nav</span> <span class="k">=</span> <span class="k">new</span> <span class="n">navigation</span><span class="o">.</span><span class="nc">Navigator</span>
  <span class="o">}</span>
<span class="k">package</span> <span class="nn">fleets</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Fleet</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.Ship</span>
    <span class="k">def</span> <span class="n">addShip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Ship</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.4 - Скорочений доступ до класів та пакунків.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Ship</span>
<span class="o">}</span>
<span class="k">package</span> <span class="nn">bobsrockets.fleets</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Fleet</span> <span class="o">{</span>
<span class="c1">// Doesn&#39;t compile! Ship is not in scope.</span>
    <span class="k">def</span> <span class="n">addShip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Ship</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.5 - Символи в оточуючих пакунках не доступні автоматично.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// В файлі launch.scala</span>
<span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Booster3</span>
<span class="o">}</span>

<span class="c1">// В файлі bobsrockets.scala</span>
<span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
    <span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
      <span class="k">class</span> <span class="nc">Booster1</span>
    <span class="o">}</span>
    <span class="k">class</span> <span class="nc">MissionControl</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">booster1</span> <span class="k">=</span> <span class="k">new</span> <span class="n">launch</span><span class="o">.</span><span class="nc">Booster1</span>
      <span class="k">val</span> <span class="n">booster2</span> <span class="k">=</span> <span class="k">new</span> <span class="n">bobsrockets</span><span class="o">.</span><span class="n">launch</span><span class="o">.</span><span class="nc">Booster2</span>
      <span class="k">val</span> <span class="n">booster3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">_root_</span><span class="o">.</span><span class="n">launch</span><span class="o">.</span><span class="nc">Booster3</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
    <span class="k">class</span> <span class="nc">Booster2</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.6 - Доступ до прихованих імен пакунків.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_2______">13.2 Стислий доступ до пов'язаного коду</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли код поділений на ієрархію пакунків, це не тільки допомагає людям переглядати код. Це також каже компілятору, що код в тому самому пакунку пов'язаний в деякий спосіб один з одним. Scala отримує перевагу від цієї пов'язаності, дозволяючі короткі, некваліфіковані імена при доступу до кода, що знаходиться в тому самому пакунку.</p></div>
<div class="paragraph"><p>Лістинг 13.4 надає три прості приклади. Перше, як ви можете очікувати, клас може бути доступний зі свого власного пакунку без потреби вказання префіксу. Ось чому <code>new StarMap</code> компілюється. Клас <code>StarMap</code> знаходиться в тому самому пакунку, <code>bobsrockets.navigation</code>, що і вираз <code>new</code>, що отримує доступ, так що ім'я пакунка не треба ставити в якості префікса.</p></div>
<div class="paragraph"><p>Друге, сам пакунок може бути доступний зі свого містячого пакунку без потреби в префіксі. В Лістингу 13.4 подивіться, як створюється примірник класу <code>Navigator</code>. Вираз <code>new</code> з'являється в пакунку <code>bobsrockets</code>, що містить пакунок <code>bobsrockets.navigation</code>. Таким чином, він може отримати доступ до пакунку <code>bobsrockets.navigation</code> через просту навігацію.</p></div>
<div class="paragraph"><p>Третє, коли використовуються синтаксис пакування з фігурними дужками, всі імена, доступні в полі зору за межами пакування також доступні всередині його. Приклад в Лістингу 13.4 є спосіб, як <code>addShip()</code> створює новий <code>Ship</code>. Метод визначений в двох пакунках: зовнішній для <code>bobsrockets</code>, та внутрішній для <code>bobsrockets.fleets</code>. Оскільки <code>Ship</code> доступний в зовнішньому пакуванні, на нього можна посилатись всередині <code>addShip()</code>.</p></div>
<div class="paragraph"><p>Зауважте, що цей різновид доступу можливий тільки якщо ви явно вкладете пакування. Якщо ви пристанете на один пакунок на файл, тоді, як в Java, єдині доступні імена будуть ті, що визначені в поточному пакунку. В Лістингу 13.5 пакування <code>bobsrockets.fleets</code> було пересунуте на вищий рівень. Оскільки воно більше не оточене в пакуванні для <code>bobsrockets</code>,імена з <code>bobsrockets</code> не є безпосередньо в полі зору. Як результат, <code>new Ship</code> дає помилку компіляції. Якщо вкладання пакунків з фігурними дужками незручно зсуває ваш код вправо, ви можете також використовувати декілька тверджень <code>package</code> без дужок.<span class="footnote"><br />[Цей стиль декількох тверджень <code>package</code> без дужок називається зціпленими твердженнями <code>package</code>.]<br /></span> Наприклад, код нижче також визначає клас <code>Fleet</code> в двох вкладених пакунках, <code>bobrockets</code> та <code>fleets</code>, саме як ви бачили в Лістингу 13.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span>
<span class="k">package</span> <span class="nn">fleets</span>
<span class="k">class</span> <span class="nc">Fleet</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.Ship</span>
  <span class="k">def</span> <span class="n">addShip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Ship</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Один заключний трюк, про який важливо знати. Іноді ви закінчуєте кодування в дуже захащеному полі зору, де імена пакунків затіняють один одне. В Лістингу 13.6 поле зору класу <code>MissionControl</code> включає три окремі пакунки на ім'я <code>launch</code>! Існує один <code>launch</code> в <code>bobsrockets.navigation</code>, один в <code>bobsrockets</code>, та один на вищому рівні. Як ви будете посилатись на кожний з <code>Booster1</code>, <code>Booster2</code> та <code>Booster3</code>?</p></div>
<div class="paragraph"><p>Доступ до першого найпростіший. Посилання на <code>launch</code> само по собі перенесе вас до пакунку <code>bobsrockets.navigation.launch</code>, оскільки він в пакунку <code>launch</code>, визначеному в найближчому оточуючому полі зору. Таки чином ви можете посилатись на перший клас прискорювача просто як на <code>launch.Booster1</code>. Посилання на другий також не дуже заплутаний. Ви можете написати <code>bobrockets.launch.Booster2</code>, і буде зрозуміло, на який саме ви посилаєтесь. Це залишає питання третього класу прискорювача: як ви отримаєте доступ до <code>Booster3</code>, зважаючи, що вкладений пакунок <code>launch</code> затінює високорівневі об'єкти?</p></div>
<div class="paragraph"><p>Щоб допомогти в цій ситуації Scala провадить пакунок на ім'я <code>_root_</code>, який знаходиться за межами любого пакунку, що може написати користувач. Підходячи з іншого боку, кожний високорівневий пакунок, що ви можете написати, розглядається як член пакунку <code>_root_</code>. Наприклад, обоє, <code>launch</code> та <code>bobsrockets</code> з Лістингу 13.6 є членами пакунку <code>_root_</code>. Як результат, <code>_root_.launch</code> дає вам пакунок самого вищого рівня, та <code>_root_.launch.Booster3</code> позначає самий зовнішній клас прискорювача.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_3_">13.3 Імпорти</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala пакунки та їх члени можуть бути імпортовані з використанням твердження <code>import</code>. Імпортовані елементи потім можуть бути досяжні через просте ім'я, як <code>File</code>, на протилежність до вимоги кваліфікованого імені, як <code>java.io.File</code>. Наприклад, розглянемо код, показаний в Лістингу 13.7.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsdelights</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">)</span>

<span class="k">object</span> <span class="nc">Fruits</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;red&quot;</span><span class="o">)</span>
  <span class="k">object</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Fruit</span><span class="o">(</span><span class="s">&quot;orange&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span><span class="o">)</span>
  <span class="k">object</span> <span class="nc">Pear</span> <span class="k">extends</span> <span class="nc">Fruit</span><span class="o">(</span><span class="s">&quot;pear&quot;</span><span class="o">,</span> <span class="s">&quot;yellowish&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">menu</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Pear</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.7 - Улюблені фрукти Боба, готові до імпорту.</p></div>
<div class="paragraph"><p>Твердження <code>import</code> робить члени пакунку або об'єкта доступними за саме своїми іменами, без потреби ставити префікс з імені пакунку або об'єкта. Ось деякі прості приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// простий довтуп до Fruit</span>
<span class="k">import</span> <span class="nn">bobsdelights.Fruit</span>

<span class="c1">// простий довтуп до всіх членів з bobsdelights</span>
<span class="k">import</span> <span class="nn">bobsdelights._</span>

<span class="c1">// простий довтуп до всіх членів Fruits</span>
<span class="k">import</span> <span class="nn">bobsdelights.Fruits._</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший з ціх відповідає до імпорту поодинокого класу Java, та другий до імпорту Java на-потребу. Одна різниця в тому, що в Scala імпорти на-потребу записуються з кінцевим підкресленням (<code>_</code>) замість зірочки (<code>*</code>). (Кінец кінцем, <code>*</code> є валідним ідентифікатором в Scala!) Третє твердження <code>import</code> вище відповідає до Java імпорту статичних полів класа.</p></div>
<div class="paragraph"><p>Ці три імпорту дають вам смак того, що можуть робити імпорти, але імпорти в Scala насправді значно більш загальні. Для початку, імпорти в Scala можуть з'являтись будь-де, не тільки на початку одиниці компіляції. Також вони можуть посилатись на довільні значення. Наприклад, є можливим імпорт, показаний в Лістингу 13.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="k">:</span> <span class="kt">Fruit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">fruit._</span>
  <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;s are &quot;</span> <span class="o">+</span> <span class="n">color</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.8 - Імпортування членів звичайного (не синглтон) об'єкта.</p></div>
<div class="paragraph"><p>Метод <code>showFruit</code> імпортує все члени свого параметру <code>fruit</code>, що є типу <code>Fruit</code>. Наступне твердження <code>println</code> може посилатись на ім'я і колір напряму. Ці два посилання еквівалентні до <code>fruit.name</code> та <code>fruit.color</code>. Цей синтаксис є зокрема корисним, коли ви використовуєте об'єкти як модулі, що буде описане в Главі 29.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____scala_4">Гнучкі імпорти в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Твердження імпорту в Scala трохи більш гнучкі, ніж в Java. Є три принципові відмінності. В Scala імпорти:</p></div>
<div class="ulist"><ul>
<li>
<p>
можуть з'являтись будь-де
</p>
</li>
<li>
<p>
можуть посилатись на об'єкти (синглтони або звичайні), на додаток до пакунків
</p>
</li>
<li>
<p>
дозволяють вам переіменувати та приховати деякі з імпортованих членів
</p>
</li>
</ul></div>
<div class="paragraph"><p>Інший спосіб, в який імпорти Scala є гнучкими, є те, що вони можуть імпортувати самі пакунки, не тільки члени не-пакунки. Це просто природно, якщо ви думаєте про вкладені пакунки, які вкладені в їх оточуючих пакунках. Наприклад, в Лістингу 13.9  пакунок <code>java.util.regex</code> є імпортований. Це робить <code>regex</code> корисним як просте ім'я. Щоб отримати доступ до об'єкта синглтона <code>Pattern</code> з пакунку <code>java.util.regex</code>, ви можете просто сказати <code>regex.Pattern</code>, як показано в Лістингу 13.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.util.regex</span>
<span class="k">class</span> <span class="nc">AStarB</span> <span class="o">{</span>
<span class="c1">// Доступ до java.util.regex.Pattern</span>
  <span class="k">val</span> <span class="n">pat</span> <span class="k">=</span> <span class="n">regex</span><span class="o">.</span><span class="nc">Pattern</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="s">&quot;a*b&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.9 - Імпортування імені пакунку.</p></div>
<div class="paragraph"><p>Імпорти в Scala також можуть переіменовувати та приховувати члени. Це робиться через селектор імпорту, оточений в фігурні дужки, що слідує за об'єктом, з якого імпортуються члени. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці імпорти прості члени <code>Apple</code> та <code>Orange</code> з об'єкта <code>Fruits</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="nc">McIntosh</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує два члени, <code>Apple</code> та <code>Orange</code> з об'єкта <code>Fruits</code>. Однак, об'єкт <code>Apple</code> переіменований на <code>McIntosh</code>, так що цей об'єкт доступний як <code>Fruits.Apple</code> або <code>McIntosh</code>. Твердження переіменування завжди має форму <code>&lt;оригінальне-ім'я&gt; =&gt; &lt;нове-ім'я&gt;</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.sql.</span><span class="o">{</span><span class="nc">Date</span> <span class="k">=&gt;</span> <span class="nc">SDate</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує клас дати SQL як <code>SDate</code>, так що ви можете одночасно імпортувати звичайний клас дати Java, просто як <code>Date</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.</span><span class="o">{</span><span class="n">sql</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує пакунок <code>java.sql</code> як <code>S</code>, так що ви можете писати речі як <code>S.Date</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує всі члени з об'єкта <code>Fruits</code>. Це означає ту саму річ, що і <code>import Fruits._</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="nc">McIntosh</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує всі члени з об'єкта <code>Fruits</code>, але параіменовує <code>Apple</code> на <code>McIntosh</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Pear</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує всі члени з <code>Fruits</code>, за винятком <code>Pear</code>. Твердження в формі <code>&lt;оригінальне-ім'я&gt; =&gt; _</code> виключає <code>&lt;оригінальне-ім'я&gt;</code> з імен, що імпортовані. В певному сенсі переіменування дечого на <code>_</code> означає одночасне його приховування. Це корисне для уникнення неоднозначностей. Скажімо, ви маєте два пакунки, <code>Fruits</code> та <code>Notebooks</code>, що обоє визначають клас <code>Apple</code>. Якщо ви бажаєте отриати лише ноутбук на ім'я <code>Apple</code>, але не фрукт, ви все ще можете використовувати обоє імпорти на-потребу, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Notebooks._</span>
<span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде імпортувати всі <code>Notebooks</code> та всі <code>Fruits</code>, за винятком <code>Apple</code>.</p></div>
<div class="paragraph"><p>Ці приклади демонструють значну гнучкість, що пропонує Scala, коли доходить до імпорту членів вибірково, або навіть під іншими іменами. В підсумку, селектор імпорту може складатись з наступного:</p></div>
<div class="ulist"><ul>
<li>
<p>
Просте ім'я <code>x</code>. Це включає <code>x</code> в набір імпортованих імен.
</p>
</li>
<li>
<p>
Твердження переіменування <code>x =&gt; y</code>. Це робить член на ім'я <code>x</code> відомим під ім'ям <code>y</code>.
</p>
</li>
<li>
<p>
Твердження приховування <code>x =&gt; _</code>. Це виключає <code>x</code> з набору імпортованих імен.
</p>
</li>
<li>
<p>
Спіймати-всі <code>_</code>. Це імпортує всі члени, за винятком членів, зазначених в попередньому твердженні. Якщо надається символ спіймати-все, він має іти останнім в списку селекторів імпорту.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Простіші твердження імпорту, показані на початку цього розділу, можуть розглядатись як особливі скорочення тверджень імпорту з твердженням селектора. Наприклад, <code>import p._</code> еквівалентне до <code>import p.{_}</code>, та <code>import p.n</code> еквівалентне до <code>import p.{n}</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_4__">13.4 Неявні імпорти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala додає імпорти неявно до кожної програми. В основі, це виглядає так, якби три твердження імпорту були додані нагорі кожного джерельного файлу з розширенням <code>.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.lang._</span>  <span class="c1">// все в пакунку java.lang</span>
<span class="k">import</span> <span class="nn">scala._</span>      <span class="c1">// все в пакунку scala</span>
<span class="k">import</span> <span class="nn">Predef._</span>     <span class="c1">// все в об&#39;єкті Predef</span>
</pre></div></div></div>
<div class="paragraph"><p>Пакунок <code>java.lang</code> містить стандартні класи Java. Вони завжди неявно імпортовані в джерельні файли Scala.<span class="footnote"><br />[Scala також в оригіналі мала реалізацію на .NET, де замість цього був імпортований простір імен <code>System</code>, .NET аналог пакунку <code>java.lang</code>.]<br /></span> Оскільки <code>java.lang</code> імпортований неявно, ви можете писати, наприклад, <code>Thread</code>  замість <code>java.lang.Thread</code>.</p></div>
<div class="paragraph"><p>Як ви вже безсумнівно здогадались, пакунок <code>scala</code> містить стандартну бібліотеку Scala, з багатьма загальними класами та об'єктами. Оскільки <code>scala</code> імпортована неявно, ви можете писати, наприклад, <code>List</code> замість <code>scala.List</code>.</p></div>
<div class="paragraph"><p>Об'єкт <code>Predef</code> містить визначення типів, методів та неявних перетворень, що загально використовуються в програмах Scala. Наприклад, завдяки неявно імпортованому <code>Predef</code>, ви можете писати <code>assert</code> замість <code>Predef.assert</code>.</p></div>
<div class="paragraph"><p>Ці три твердження <code>import</code> розглядаються трохи особливо, в тому, що пізніші імпорти затінюють ранішні. Наприклад, клас <code>StringBuilder</code> визначений одночасно в пакунку <code>scala</code>, та, починаючи з Java версії 1.5, також в пакунку <code>java.lang</code>. оскільки імпорт <code>scala</code> затінює імпорт <code>java.lang</code>, просте ім'я <code>StringBuilder</code> буде посилатись на  <code>scala.StringBuilder</code>, не на <code>java.lang.StringBuilder</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_5__">13.5 Модифікатори доступу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Члени пакунків, класів або об'єктів, можуть бути помічені можифікаторами доступу <code>private</code> та <code>protected</code>. Ці модифікатори обмежують доступ до членів для окремих регіонів коду. Трактування Scala модифікаторів доступу приблизно слідує Java, але існують деякі важливі відмінності, що пояснюються в цьому розділі.</p></div>
<div class="sect2">
<h3 id="___16">Приватні члени</h3>
<div class="paragraph"><p>Приватні члени в Scala розглядаються подібно до Java. Член, відмічений <code>private</code> є видимі тільки всередині класу або об'єкту, що містить визначення члена. В Scala це правило стосується тільки внутрішніх класів. Ця трактовка більш узгоджена, але відрізняється від Java. Розглянемо приклад, показаний в Лістингу 13.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Inner</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;f&quot;</span><span class="o">)</span> <span class="o">}</span>
    <span class="k">class</span> <span class="nc">InnerMost</span> <span class="o">{</span>
      <span class="n">f</span><span class="o">()</span> <span class="c1">// OK</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="o">(</span><span class="k">new</span> <span class="nc">Inner</span><span class="o">).</span><span class="n">f</span><span class="o">()</span> <span class="c1">// помилка: f недоступна</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.10 - Як приватний доступ відрізняється в Scala та Java.</p></div>
<div class="paragraph"><p>В Scala доступ до <code>(new Inner).f()</code> є нелегальним, оскільки <code>f</code> декларована приватною в <code>Inner</code>, та доступ відбувається не зсередини класу <code>Inner</code>. Для контрасту, перший доступ до <code>f</code> в класі <code>InnerMost</code> є OK, оскільки цей доступ міститься в тілі класу <code>Inner</code>. Java буде дозволяти обоє доступи, оскільки вона дозволяє зовнішнім класам мати доступ до приватних членів інутрішніх класів.</p></div>
</div>
<div class="sect2">
<h3 id="___17">Захищені члени</h3>
<div class="paragraph"><p>Доступи до захищених членів в Scala також трохи більш обмежувані, ніж в Java. В Scala захицений член доступний тільки з субкласів класа, в якому він визначений. В Java такий доступ також можливий з інших класів в тому ж пакунку. В Scala існує інший метод досягти такого самого ефекту,<span class="footnote"><br />[Використовуючи кваліфікатори, описані в "Поле зору захищеності".]<br /></span> так що <code>protected</code> можна залишити як є. Приклад, показаний в Лістингу 13.11, ілюструє захищений доступ.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">p</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Super</span> <span class="o">{</span>
    <span class="k">protected</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;f&quot;</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Sub</span> <span class="k">extends</span> <span class="nc">Super</span> <span class="o">{</span>
    <span class="n">f</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Other</span> <span class="o">{</span>
    <span class="o">(</span><span class="k">new</span> <span class="nc">Super</span><span class="o">).</span><span class="n">f</span><span class="o">()</span> <span class="c1">// error: f is not accessible</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.11 - Як захищений доступ відрізняється в Scala та Java.</p></div>
<div class="paragraph"><p>В Лістингу 13.11 доступ до <code>f</code> в класі <code>Sub</code> є OK, оскільки <code>f</code> декларована як <code>protected</code> в <code>Super</code>, та <code>Subis</code> є субкласом <code>Super</code>. По контрасту, доступ до <code>f</code> в <code>Other</code> не дозволений, оскільки <code>Other</code> не наслідує від <code>Super</code>. В Java останній доступ також буде дозволений, бо <code>Other</code> в тому ж пакунку, що і <code>Sub</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___18">Публічні члени</h3>
<div class="paragraph"><p>Scala не має явного модифікатора для публічних членів: любий член, не відмічений <code>private</code> або <code>protected</code> є публічним. Публічні методи можуть бути доступні будь-де.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span>

<span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">bobsrockets</span><span class="o">]</span> <span class="k">class</span> <span class="nc">Navigator</span> <span class="o">{</span>
    <span class="k">protected</span><span class="o">[</span><span class="kt">navigation</span><span class="o">]</span> <span class="k">def</span> <span class="n">useStarChart</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
    <span class="k">class</span> <span class="nc">LegOfJourney</span> <span class="o">{</span>
      <span class="k">private</span><span class="o">[</span><span class="kt">Navigator</span><span class="o">]</span> <span class="k">val</span> <span class="n">distance</span> <span class="k">=</span> <span class="mi">100</span>
    <span class="o">}</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">speed</span> <span class="k">=</span> <span class="mi">200</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">navigation._</span>
  <span class="k">object</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">launch</span><span class="o">]</span> <span class="k">val</span> <span class="n">guide</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Navigator</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.12 - Гнучка видимість захищеності з модифікаторами доступа.</p></div>
</div>
<div class="sect2">
<h3 id="____12">Поле зору захищеності</h3>
<div class="paragraph"><p>Модифікатори доступу в Scala можуть бути доповнені за допомогою кваліфакаторів. Модифікатор в форматі <code>private[X]</code> або <code>protected[X]</code> означає, що доступ приватний або захищений "в межах" <code>X</code>, де <code>X</code> позначає деякий оточуючий пакунок, клас або об'єкт синглтон.</p></div>
<div class="paragraph"><p>Кваліфіковані модифікатори доступу надають вам гарний контроль над видимістю. Зокрема, вони дозволяють вам виражати варіанти досяжності Java, такі як приватний в пакунку, захищений в пакунку, або приватний в межах зовнішнього класу, що напряму не виражається простими модифікаторами в Scala. Але вони також дозволяють вам виражати правила доступності, що не можуть бути виражені в Java.</p></div>
<div class="paragraph"><p>Лістинг 13.12 представляє приклад з багатьма вжитими кваліфікаторами доступа. І цьому лістингу клас <code>Navigator</code> помічений як <code>private[bobsrockets]</code>. Це означає, що цей клас видимий у всіх класах та об'єктах, що містяться в пакунку <code>bobsrockets</code>. Зокрема, досутп до <code>Navigator</code> в об'єкті <code>Vehicle</code> дозволений, оскільки <code>Vehicle</code> міститься в пакунку <code>launch</code>, що міститься в <code>bobsrockets</code>. З іншого боку, весь код за межами пакунку <code>bobsrockets</code> не має доступу до класу <code>Navigator</code>.</p></div>
<div class="paragraph"><p>Цей прийом досить корисний в великих проектах, що обіймають декілька пакунків. Він дозволяє визначати речі, що видимі в декількох суб-пакунках, але залишаються приховані для клієнтів, зовнішніх відносно вашого проекту. Той самий прийом неможливий в Java. Там, коли визначення залишає межі свого безпосереднього пакунку, він стає видимий для загального світу.</p></div>
<div class="paragraph"><p>Зазвичай, кваліфікатор <code>private</code> може також бути безпосередньо оточуючим пакунком. Прикладом є модифікатор доступу <code>guide</code> в об'єкті <code>Vehicle</code> з Лістингу 13.12. Такий модифікатор доступу еквівалентний до пакунок-приватного доступу в Java.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 13.1 Ефекти приватних кваліфікаторів на LegOfJourney.distance</caption>
<col width="16%" />
<col width="83%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">немає модифікатора доступу</p></td>
<td align="left" valign="top"><p class="table">публічний доступ</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[bobsrockets]</p></td>
<td align="left" valign="top"><p class="table">доступ в зовнішньому пакунку</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[navigation]</p></td>
<td align="left" valign="top"><p class="table">те саме, що видимість в пакунку в Java</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[Navigator]</p></td>
<td align="left" valign="top"><p class="table">те саме, що <code>private</code> в Java</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[LegOfJourney]</p></td>
<td align="left" valign="top"><p class="table">те саме, що <code>private</code> в Scala</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[this]</p></td>
<td align="left" valign="top"><p class="table">доступ тільки в тому самому об'єкті</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Всі кваліфікатори також можуть бути застосовані до <code>protected</code>, з тим же значенням, що і <code>private</code>. Тобто, модифікатор <code>protected[X]</code> в класі <code>C</code> дозволяє доступ до відміченого визначення в усіх субкласах <code>C</code>, та також з оточуючому пакунку, класі, або об'єкті <code>X</code>. Наприклад, метод <code>useStarChart</code> в Лістингу 13.12 доступний в усіх субкласах <code>Navigator</code>, а також у всьому коді, що міститься в оточуючому пакунку <code>navigation</code>. Таким чином це в точності відповідає значенню <code>protected</code> в Java.</p></div>
<div class="paragraph"><p>Кваліфікатори <code>private</code> також можуть посилатись на оточуючий клас або об'єкт. Наприклад, змінна <code>distance</code> в класі <code>LegOfJourney</code> з Лістингу 13.12 помічений як <code>private[Navigator]</code>, так що він видимий будь-де в класі <code>Navigator</code>. Це надає ті самі можливості доступу, що приватні члени внутрішніх класів в Java. Модифікатор <code>private[C]</code>, де <code>C</code> є зовнішінй оточуючий клас, є те саме, що простий <code>private</code> в Java.</p></div>
<div class="paragraph"><p>Нарешті, Scala також має модифікатор доступу, що навіть більш обмежуючий, ніж <code>private</code>. Визначення, помічене <code>private[this]</code>, доступне тільки з того самого об'єкту, що містить визначення. Таке визначення називається об'єкт-приватне. Наприклад, визначення <code>speedin</code> в класі <code>Navigator</code> з Лістингу 13.12 є об'єкт-приватним. Це означає, що любий доступ має не тільки бути в класі <code>Navigator</code>, він має бути зроблений саме з того самого примірника <code>Navigator</code>. таким чином, доступ до <code>speed</code> та <code>this.speed</code> будуть легальними в межах <code>Navigator</code>.</p></div>
<div class="paragraph"><p>Наступний доступ, однак, не буде дозволено, навіть якщо він з'являється в класі  <code>Navigator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">other</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Navigator</span>
<span class="n">other</span><span class="o">.</span><span class="n">speed</span> <span class="c1">// цей рядок не буде компілюватись</span>
</pre></div></div></div>
<div class="paragraph"><p>Помітка члена як <code>private[this]</code> є гарантією, що він не буде видимий з інших об'єктів того самого класу. Це може бути корисно для документації. Це також інколи дозволяє вам писати більш загальні анотації варіантності (дивіться Розділ 19.7 щодо деталей).</p></div>
<div class="paragraph"><p>Щоб підсумувати, Таблиця 13.1 перелічує ефекти від приватних кваліфікаторів. Кожний рядок показує кваліфікований приватний модифікатор, і що він буде означати, якщо такий модифікатор буде приєднаний до змінної <code>distance</code>, декларованої в класі <code>LegOfJourney</code> в Лістингу 13.12.</p></div>
</div>
<div class="sect2">
<h3 id="______6">Видимість та об'єкт компанйон</h3>
<div class="paragraph"><p>В Java статичні члени та члени примірників належать до того самого класу, так що модифікатори доступу застосовуються до них одноманітно. Ви вже мали бачити, що в Scala немає статичних членів; замість ви можете створити об'єкт компанйон, що містить члени, що існують в одній копії. Наприклад, в Лістингу 13.13 об'єкт <code>Rocket</code> є компанйоном класу <code>Rocket</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rocket</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Rocket.fuel</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">canGoHomeAgain</span> <span class="k">=</span> <span class="n">fuel</span> <span class="o">&gt;</span> <span class="mi">20</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Rocket</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">fuel</span> <span class="k">=</span> <span class="mi">10</span>
  <span class="k">def</span> <span class="n">chooseStrategy</span><span class="o">(</span><span class="n">rocket</span><span class="k">:</span> <span class="kt">Rocket</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rocket</span><span class="o">.</span><span class="n">canGoHomeAgain</span><span class="o">)</span>
      <span class="n">goHome</span><span class="o">()</span>
    <span class="k">else</span>
      <span class="n">pickAStar</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">goHome</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
  <span class="k">def</span> <span class="n">pickAStar</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.13 - Доступ до приватних членів класу компанйона та об'єктів.</p></div>
<div class="paragraph"><p>Правила доступу Scala надають привелей об'єктам компанйонам та класам, коли ідеться про приватний або захищений доступ. Клас поділяє всі свої права доступу зі своїм об'єктом компанйоном, та навпаки. Зокрема, об'єкт може отримувати доступ до всіх приватних членів свого класу компанйона, так само, як клас може отримувати доступ до приватних членів об'єкта компанйона.</p></div>
<div class="paragraph"><p>Наприклад, клас <code>Rocket</code> з Лістингу 13.13 може отримати доступ до метода <code>fuel</code>, що декларований приватним в об'єкті <code>Rocket</code>. Аналогічно, об'єкт <code>Rocket</code> може отримати доступ до приватного метода <code>canGoHomeAgain</code> в класі <code>Rocket</code>.</p></div>
<div class="paragraph"><p>Одне виключення, де подібність між Scala та Java ламається, стосується захищених статичних членів. Захицені статичні члени в Java класі <code>C</code> може бути доступним у всіх субкласах <code>C</code>. Для контрасту, захищений член в об'єкті компанйоні не має сенсу, оскікльи об'єкт синглтон не має жодних субкласів.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_13_6___">13.6 Об'єкти пакунків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Доки єдиний код, що ми бачили доданим до пакунків, були класи, трейти та окремі об'єкти. Це найбільш загальні визначення, що розташовуються на верхньому рівні пакунка. Але Scala не обмежує вас лише цім — любий різновид визначення, що ви можете покласти в клас, також може бути на вищому рівні пакунка. Якщо ви маєте деякий допоміжний метод, що ви хочете помістити в поле зору цілого пакунку, дійте, та покладіть його прямо на верхній рівень пакунка.</p></div>
<div class="paragraph"><p>Щоб зробити це, покладіть визначення в об'єкті пакунка. Кожному пакунку дозволяється мати один об'єкт пакунку. Любі визначення, покладені в об'єкт пакунку, розглядаються як члени самого пакунку.</p></div>
<div class="paragraph"><p>Приклад показаний в Лістингу 13.14. Файл <code>package.scala</code> утримує об'єкт пакунку для пакунку <code>bobsdelights</code>. Синтаксично об'єкт пакунку виглядає більш подібно до пакуванян в фігурних дужках, показаних раніше в цій главі. Одна різниця в тому, що він включає ключеве слово <code>object</code>. Це об'єкт пакунку, не пакунок. Вміст фігурних дужок може включати любі визначення за вашим бажанням. В цьому випадку об'єкт пакунку включає допоміжний метод <code>showFruit</code> з Лістингу 13.8.</p></div>
<div class="paragraph"><p>Маючи це визначення, любий інший код в любому пакунку може імпортувати метод, так само, як він може імпортувати клас. Наприклад, Лістинг 13.14 також показує окремий об'єкт <code>PrintMenu</code>, що розміщений в окремому пакунку. <code>PrintMenu</code> може імпортувати допоміжний метод <code>showFruit</code> в той самий спосіб, як він може імпортувати клас <code>Fruit</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// В файлі bobsdelights/package.scala</span>
<span class="k">package</span> <span class="nn">object</span> <span class="n">bobsdelights</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="k">:</span> <span class="kt">Fruit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">fruit._</span>
    <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;s are &quot;</span> <span class="o">+</span> <span class="n">color</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// В файлі PrintMenu.scala</span>
<span class="k">package</span> <span class="nn">printmenu</span>
<span class="k">import</span> <span class="nn">bobsdelights.Fruits</span>
<span class="k">import</span> <span class="nn">bobsdelights.showFruit</span>

<span class="k">object</span> <span class="nc">PrintMenu</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">fruit</span> <span class="k">&lt;-</span> <span class="nc">Fruits</span><span class="o">.</span><span class="n">menu</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.14 - Об'єкт пакунку.</p></div>
<div class="paragraph"><p>Заглядаючи наперед, існують інші використання об'єктів пакунку для різновидів визначень, які ви ще не бачили. Об'єкти пакунку часто використовуються для пакет-поширених псевдонимів типів (Глава 20) та неявних перетворень (Глава 21). Пакунок <code>scala</code> вищого рівня має об'єкт пакунка, та його визначення доступні для всього Scala кода.</p></div>
<div class="paragraph"><p>Об'єкти пакунка компілюються до файлів класів на ім'я <code>package.class</code>, що розміщені в директорії пакунку, які вони доповнюють. Це корисно для утримання тієї ж домовленості для джерельних файлів. Так що ви типово можете покласти джерельний файл об'єкту пакунка <code>bobsdelights</code> з Лістингу 13.14 в файл на ім'я <code>package.scala</code>, що розташований в директорії <code>bobsdelights</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_7_">13.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили базові конструкції для поділу вашого коду на пакунки. Це дає вам простий та корисний різновид модульності, так що ви можете робити з дуже великим тілом кода, без того, щоб різні частини коду налазили один на одний. Система Scala є за духом така сама, що і пакунки Java, але існують деякі відмінності, де Scala обирає бути більш узгодженою або більш загальною.</p></div>
<div class="paragraph"><p>Заглядаючи наперед, Глава 29 описує більш гнучку модульну систему, ніж поділення на пакунки. На додаток до надання вам поділу коду на на декілька просторів імен, цей підхід дозволяє модулям бути параметризованими, та наслідувать один від одного. В наступній главі ми звернемо нашу увагу на твердження та юніт тести.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__14">Глава 14</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____13">Твердження та тести</h1>
<div class="paragraph"><p>Твердження та тести є два важливі шляхи, яким ви можете перевірити, що програмне забезпечення, яке ви пишете, поводиться так, як ви очікуєте. В цій главі ми покажемо декілька опцій, що ви маєте в Scala для написання та виконання тестів.</p></div>
<div class="sect1">
<h2 id="_14_1_">14.1 Твердження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Твердження в Scala написані як виклики попередньо визначеного метода <code>assert</code>.<span class="footnote"><br />[Метод <code>assert</code> визначений в об'єкті синглтоні <code>Predef</code>, чиї члени автоматично імпортуються в кожний джерельний файл Scala.]<br /></span> Вираз <code>assert(умова)</code> закидає <code>AssertionError</code>, якщо умова не дотримується. Існує також версія <code>assert</code> з двома аргументами: вираз <code>assert(умова, пояснення)</code> перевіряє умову, та, якщо воно не дотримується, закидає <code>AssertionError</code>, що містить надане пояснення. Тип пояснення <code>Any</code>, так що ви можете передати любий об'єкт в якості пояснення. Метод <code>assert</code> буде викликати <code>toString</code> не ньому, щоб отримати рядок пояснення, що покладається в <code>AssertionError</code>. Наприклад, в методі з назвою <code>above</code> класа <code>Element</code>, показаному в Лістингу 10.13, ви можете розмістити <code>assert</code> після виклику до <code>widen</code>, щоб переконатись, що поширені елементи мають однакову ширину. Це показано в Лістингу 14.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">above</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">this1</span> <span class="k">=</span> <span class="k">this</span> <span class="n">widen</span> <span class="n">that</span><span class="o">.</span><span class="n">width</span>
  <span class="k">val</span> <span class="n">that1</span> <span class="k">=</span> <span class="n">that</span> <span class="n">widen</span> <span class="k">this</span><span class="o">.</span><span class="n">width</span>
  <span class="n">assert</span><span class="o">(</span><span class="n">this1</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="n">that1</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">this1</span><span class="o">.</span><span class="n">contents</span> <span class="o">++</span> <span class="n">that1</span><span class="o">.</span><span class="n">contents</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.1 - Використання твердження.</p></div>
<div class="paragraph"><p>Інший шлях, як ви можете обрати зробити це, є перевірити ширини в кінці метода <code>widen</code>, прямо перед поверненням значення. Ви можете досягти цього через зберігання результату як <code>val</code>, виконуя твердження для результату, потім вказуючи <code>val</code> останнім, так що результат буде повернений, якщо твердження справджується. Однак ви можете зробити це більш стисло, за допомогою зручного метода в <code>Predef</code> на ім'я <code>ensuring</code>, як показано в Лістингу 14.2.</p></div>
<div class="paragraph"><p>Метод <code>ensuring</code> може бути використаний з любим типом результату завдяки неявному перетворенню. Хоча це виглядає в цьому коді так, якби ми викликали <code>ensuring</code> на результаті <code>widen</code>, що має тип <code>Element</code>, насправді викликаючи <code>ensuring</code> на типі, до якого <code>Element</code> неявно конвертоване. Метод <code>ensuring</code> приймає один аргумент, функцію предикати, що приймає тип результату та повертає <code>Boolean</code>, та передає результат в предикат. Якщо предикат повертає <code>true</code>, <code>ensuring</code> буде повертати результат; інакше  <code>ensuring</code> буде закидати <code>AssertionError</code>.</p></div>
<div class="paragraph"><p>В цьому прикладі предикат є <code>w &lt;= _.width</code>. Підкреслення є заповнювачем для одного аргумента, переданого до предикату, результату <code>Element</code> метода <code>widen</code>. Якщо ширина, передана як <code>w</code> до <code>widen</code> меньше або рівне до ширини результуючого <code>Element</code>, предикат буде давати результат <code>true</code>, та <code>ensuring</code> буде давати результат <code>Element</code>, на якому він був викликаний. Оскільки це останній вираз метода <code>widen</code>, сам <code>widen</code> потім буде мати результат <code>Element</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">widen</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">width</span><span class="o">)</span>
    <span class="k">this</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">left</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="o">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">width</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
    <span class="k">var</span> <span class="n">right</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39; &#39;</span><span class="o">,</span> <span class="n">w</span> <span class="o">-</span> <span class="n">width</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
    <span class="n">left</span> <span class="n">beside</span> <span class="k">this</span> <span class="n">beside</span> <span class="n">right</span>
  <span class="o">}</span> <span class="n">ensuring</span> <span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="k">_</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.2 - Використання <code>ensuring</code> для твердження щодо результата функції.</p></div>
<div class="paragraph"><p>Твердження можуть бути вімкнені та вимкнені з використанням флагів командного рядка JVM, <code>-ea</code> та <code>-da</code>. Коли ввімкнено, кожне твердження служить як малий тест, що використовує дійсні дані, що використовуються при виконанні програми. В залишку цієї глави ми сфокусуємось на написанні зовнішніх тестів, що провадять свої власні тестові дані, та виконуються незалежно від застосування.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_2___scala">14.2 Тестування в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви маєте багато опцій для тестування в Scala, від визнаних Java інструментів, таких як JUnit та TestNG, до інструментів, написаних на Scala, таких як ScalaTest, specs2, та ScalaCheck. В залишку цієї глави ми надамо вам швидкий тур по цім інструментам. Ми почнемо з ScalaTest.</p></div>
<div class="paragraph"><p>ScalaTest є найбільш гнучким фреймворком тестування Scala: він може бути налаштований для вирішення різних проблем. Гнучкість ScalaTest означає, що команди можуть використовувати такі стилі тестування, що найкраще підходять до їх потреб. Наприклад, для команд, знайомих з JUnit, стиль FunSuite буде відчуватись комфортабельним в знайомим. Лістинг 14.3 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.FunSuite</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSuite</span> <span class="k">extends</span> <span class="nc">FunSuite</span> <span class="o">{</span>

  <span class="n">test</span><span class="o">(</span><span class="s">&quot;elem result should have passed width&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.3 - Writing tests with FunSuite.</p></div>
<div class="paragraph"><p>Центральна концепція в ScalaTest є сюїта, колекція тестів. Тестом може бути будь-що з ім'ям, що може розпочатись, та або мати вдачу, або схибити, бути в стані очікування або скасованим. Трейт <code>Suite</code> є центральною одиницею композиції в ScalaTest. Сюїта декларує методи "життєвого цикла", що визначають шлях по замовчанню для виконання тесту, що може бути перекрите для налаштування того, як тести можуть бути написані або виконані.</p></div>
<div class="paragraph"><p>ScalaTest пропонує трейти стилів, що розширюють <code>Suite</code>, та перекривають методи життєвого циклу, щоб підтримувати різні стилі тестування. Він також провадить міксіни трейтів, що що перекривають методи життєвого циклу, щоб адресувати окремі потреби тестування. Ви визначаєте тестові класи через композицію стилів <code>Suite</code> та міксін трейтів, та визначаєте тестові сюїти, через композицію примірників <code>Suite</code>.</p></div>
<div class="paragraph"><p><code>FunSuite</code>, що розширюється тестовим класом, показаним на Лістингу 14.3, є прикладом тестового стилю. <code>Fun</code> в <code>FunSuite</code> означає функцію; <code>test</code> є методом, визначеним в  <code>FunSuite</code>, що викликається первинним конструктором <code>ElementSuite</code>. Ви вказуєте ім'я тесту як рядок в дужках, та сам код тестування між фігурними дужками. Тестовий код є функцією, переданою як параметр за-ім'ям до <code>test</code>, що реєструє її для подальшого виклику.</p></div>
<div class="paragraph"><p>ScalaTest інтегрований в загальні інструменти побудови (такі як sbt та Maven), та IDE (такі як IntelliJ IDEA та Eclipse). Також ви можете виконати <code>Suite</code> напряму, через застосування ScalaTest Runner, або з інтерпретатора Scala, просто викликавши на ньому <code>execute</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="k">new</span> <span class="nc">ElementSuite</span><span class="o">).</span><span class="n">execute</span><span class="o">()</span>
<span class="nc">ElementSuite</span><span class="k">:</span>
<span class="kt">-</span> <span class="kt">elem</span> <span class="kt">result</span> <span class="kt">should</span> <span class="kt">have</span> <span class="kt">passed</span> <span class="kt">width</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі стилі ScalaTest, включаючи <code>FunSuite</code>, розроблені для заохочення написання сфокусованих тестів з описовими назвами. На додаток, всі стилі генерують специфікація-подібний вихід, що може спростити комунікацію між зацікавленими сторонами. Стиль, що ви обираєте, диктує тільки те, як будуть виглядати декларації вашого тесту. Все інше в ScalaTest робить узгоджено в однаковий спосіб, не важливо, який стиль ви оберете.<span class="footnote"><br />[Більше деталей щодо ScalaTest досутпні на <a href="http://www.scalatest.org/.">3]<br /></span></a></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_3____">14.3 Інформативні звіти про збої</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тест в Лістингу 14.3 намагається створити елемент ширини 2, та стверджує, що ширина отриманого елементу, відповідно, 2. Коли твердження схибить, звіт про збій повинен включати ім'я файлу та номер рядка винного твердження, а також інформативне повідомлення про помилку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">width</span> <span class="k">=</span> <span class="mi">3</span>
<span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">org</span><span class="o">.</span><span class="n">scalatest</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="nc">TestFailedException</span><span class="k">:</span>
    <span class="err">3</span> <span class="kt">did</span> <span class="kt">not</span> <span class="kt">equal</span> <span class="err">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб запровадити описові повідомлення про помилки тверджень, ScalaTest аналізує вирази, передані в кожному виклику <code>assert</code> під час компіляції. Якщо ви бажаєте бачити навіть більш детальну інформацію щодо збоїв тверджень, ви можете використовувати ScalaTest <code>DiagrammedAssertions</code>, чиї повідомлення про помилки відображають діаграму виразу, передану до <code>assert</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">contains</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
<span class="n">org</span><span class="o">.</span><span class="n">scalatest</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="nc">TestFailedException</span><span class="k">:</span>

  <span class="kt">assert</span><span class="o">(</span><span class="kt">List</span><span class="o">(</span><span class="err">1</span><span class="o">,</span> <span class="err">2</span><span class="o">,</span> <span class="err">3</span><span class="o">).</span><span class="n">contains</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
         <span class="o">|</span>    <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>  <span class="o">|</span>        <span class="o">|</span>
         <span class="o">|</span>    <span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="kc">false</span>    <span class="mi">4</span>
         <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В ScalaTest методи <code>assert</code> не роблять різницю між дійсним та очікуваним результатом в повідомленнях помилок. Вони просто вказують, що лівий операнд не дорівнює правому операнду, або показує значення на діаграмі. Якщо ви бажаєте наголосити на різниці між дійсним та очікуваним, ви можете альтернативно використовувати метод ScalaTest  <code>assertResult</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">assertResult</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">ele</span><span class="o">.</span><span class="n">width</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи такий вираз, ви вказуєте, що ви очікуєте, що код між фігурними дужками дає результат <code>2</code>. Коли код в дужках дасть результат <code>3</code>, ви побачите повідомлення "Expected 2, but got 3" в звіті про збій тесту.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте перевірити, що метод закидає очікувані виключення, ви можете використовувати метод ScalaTest <code>assertThrows</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">assertThrows</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо код між фігурними дужками закидає інше виключення, ніж очікується, або не закидає виключення взагалі, <code>assertThrows</code> терміново переривається з <code>TestFailedException</code>. Ви отримаєте корисне повідомлення про помилку в звіті, таке як:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Expected IllegalArgumentException to be thrown,
  but NegativeArraySizeException was thrown.</code></pre>
</div></div>
<div class="paragraph"><p>З іншого боку, якщо код завершується терміново з примірником переданого класу виключення, <code>assertThrows</code> буде повертатись звичайно. Якщо ви бажаєте проінспектувати далі очікуване виключення, ви можете використовувати <code>intercept</code> замість <code>assertThrows</code>. Метод <code>intercept</code> робить так саме, як <code>asassertThrows</code>, за винятком того, що коли очікуване виключення спрацьовує, <code>intercept</code> повертає його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">caught</span> <span class="k">=</span>
  <span class="n">intercept</span><span class="o">[</span><span class="kt">ArithmeticException</span><span class="o">]</span> <span class="o">{</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span>
  <span class="o">}</span>

<span class="n">assert</span><span class="o">(</span><span class="n">caught</span><span class="o">.</span><span class="n">getMessage</span> <span class="o">==</span> <span class="s">&quot;/ by zero&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коротше, твердження ScalaTest тяжко роблять для провадження корисних повідомлень, що допомагатимуть вам діагностувати та поладнати проблеми в вашому коді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_4___">14.4 Тести як специфікації</h2>
<div class="sectionbody">
<div class="paragraph"><p>В стилі тестування <em>поведінко-рушійної розробки</em> (behavior-driven development, BDD), наголос робиться на написанні зрозумілих для людей специфікацій очікуваної поведінки коду, та додавання супроводжуючих тестів, які перевіряють код на задану поведінку. ScalaTest включає декілька трейтів, що спрощує цей стиль тестування. Приклад використання такого трейту, <code>FlatSpec</code>, показаний в Лістингу 14.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.FlatSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.Matchers</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="k">with</span> <span class="nc">Matchers</span> <span class="o">{</span>
  <span class="s">&quot;A UniformElement&quot;</span> <span class="n">should</span>
       <span class="s">&quot;have a width equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;have a height equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">ele</span><span class="o">.</span><span class="n">height</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;throw an IAE if passed a negative width&quot;</span> <span class="n">in</span> <span class="o">{</span>
    <span class="n">an</span> <span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="n">should</span> <span class="n">be</span> <span class="n">thrownBy</span> <span class="o">{</span>
      <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.4 - Специфікація та тестування поведінки за допомогою ScalaTest <code>FlatSpec</code>.</p></div>
<div class="paragraph"><p>В <code>FlatSpec</code> ви пишете тести як твердження специфікації. Ви починаєте писати з імені для субпроекту під тестом як рядок ("A UniformElement" в Лістингу 14.4), потім <code>should</code> (або <code>must</code> або <code>can</code>), потім рядок, що вказує частину поведінки, яка очікується від предмета, потім <code>in</code>. В фігурних дужках, що ідуть далі, ви пишете код, що перевіряє вказану поведінку. В наступних реченнях ви можете писати <code>it</code> для посилання до найбільш останнього взятого предмета. Коли виконується <code>FlatSpec</code>, він буде проганяти кожне речення специфікації як тест ScalaTest. При виконанні <code>FlatSpec</code> (та інші трейти специфікацій  ScalaTest) генерує вивід, що читається як специфікація. Наприклад, ось на що буде схожий вивід, якщо ви запустите <code>ElementSpec</code> з Лістинга 14.4 в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="k">new</span> <span class="nc">ElementSpec</span><span class="o">).</span><span class="n">execute</span><span class="o">()</span>
<span class="n">A</span> <span class="nc">UniformElement</span>
<span class="o">-</span> <span class="n">should</span> <span class="n">have</span> <span class="n">a</span> <span class="n">width</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">passed</span> <span class="n">value</span>
<span class="o">-</span> <span class="n">should</span> <span class="n">have</span> <span class="n">a</span> <span class="n">height</span> <span class="n">equal</span> <span class="n">to</span> <span class="n">the</span> <span class="n">passed</span> <span class="n">value</span>
<span class="o">-</span> <span class="n">should</span> <span class="k">throw</span> <span class="n">an</span> <span class="nc">IAE</span> <span class="k">if</span> <span class="n">passed</span> <span class="n">a</span> <span class="n">negative</span> <span class="n">width</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.4 також ілюструє домен-специфічну мову (domain-specific language, DSL) матчерів в ScalaTest. Міксуючи трейт <code>Matchers</code>, ви можете написати твердження, що читаються майже як природна мова. ScalaTest провадить багато матчерів в своєму DSL, та також дозволяє вам визначати нові матчери з власними повідомленнями. Матчери, показані в Лістингу 14.4 включають синтаксис <code>should be</code> та <code>an [...] should be thrownBy { ...}</code>. Як альтернатива, ви можете зміксувати <code>MustMatchers</code>, якщо ви бажаєте <code>must</code> замість <code>should</code>. Наприклад, міксування <code>MustMatchers</code> дозволить вам писати вирази, такі як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="n">must</span> <span class="n">be</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="n">map</span> <span class="n">must</span> <span class="n">contain</span> <span class="n">key</span> <span class="sc">&#39;c&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо останнє твердження схибить, ви побачите повідомлення про помилку, подібне до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Map</span><span class="o">(</span><span class="sc">&#39;a&#39;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">did</span> <span class="n">not</span> <span class="n">contain</span> <span class="n">key</span> <span class="sc">&#39;c&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тестовий фреймворк specs2 є інструментом з відкритим кодом, написаний на Scala Eric Torreborre, також підтримує стиль тестування BDD, але з іншим синтаксисом. Наприклад, ви можете використати specs2 для написання тесту, показаного в Лістингу 14.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.specs2._</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">object</span> <span class="nc">ElementSpecification</span> <span class="k">extends</span> <span class="nc">Specification</span> <span class="o">{</span>
  <span class="s">&quot;A UniformElement&quot;</span> <span class="n">should</span> <span class="o">{</span>
    <span class="s">&quot;have a width equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
      <span class="n">ele</span><span class="o">.</span><span class="n">width</span> <span class="n">must</span> <span class="n">be_==</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="s">&quot;have a height equal to the passed value&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">ele</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
      <span class="n">ele</span><span class="o">.</span><span class="n">height</span> <span class="n">must</span> <span class="n">be_==</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="s">&quot;throw an IAE if passed a negative width&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">must</span>
      <span class="n">throwA</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.5 - Специфікація та тестування поведінки за допомогою фреймворка specs2.</p></div>
<div class="paragraph"><p>Як і ScalaTest, specs2 провадить DSL. Ви можете бачити деякі приклади матчерів specs2 в дії в Лістингу 14.5 в рядках, що містять <code>must be_==</code> та <code>must throwA</code>.<span class="footnote"><br />[Ви можете завантажити specs2 на <a href="http://specs2.org/">http://specs2.org/</a>.]<br /></span> Ви можете використовувати specs2 окремо, але він також інтегрований з ScalaTest та JUnit, так що ви можете використати тести specs2 з ціма інструментами, також.</p></div>
<div class="paragraph"><p>Одна з великих ідей BDD в тому, що тести можуть бути використані для спрощення комунікації між людьми, які визначають, що програмне забезпечення має робити, людьми, що реалізують програмне забезпечення, та людьми, що визначають, коли програма завершена та робить. Хоча любий зі стилів ScalaTest або specs2 можуть бути використаний в цій манері, ScalaTest <code>FeatureSpec</code> навмисне розроблений для цього. Лістинг 14.6 показує приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest._</span>

<span class="k">class</span> <span class="nc">TVSetSpec</span> <span class="k">extends</span> <span class="nc">FeatureSpec</span> <span class="k">with</span> <span class="nc">GivenWhenThen</span> <span class="o">{</span>

  <span class="n">feature</span><span class="o">(</span><span class="s">&quot;TV power button&quot;</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">scenario</span><span class="o">(</span><span class="s">&quot;User presses power button when TV is off&quot;</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Given</span><span class="o">(</span><span class="s">&quot;a TV set that is switched off&quot;</span><span class="o">)</span>
      <span class="nc">When</span><span class="o">(</span><span class="s">&quot;the power button is pressed&quot;</span><span class="o">)</span>
      <span class="nc">Then</span><span class="o">(</span><span class="s">&quot;the TV should switch on&quot;</span><span class="o">)</span>
      <span class="n">pending</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.6 - Використання тестів для спрощення комунікації між зацікавленими сторонами.</p></div>
<div class="paragraph"><p>FeatureSpec розроблений для направлення спілкування щодо потреб до програмних систем: ви маєте ідентифікувати специфічні можливості, потім вказати ці можливості в термінах сценаріїв. Методи <code>Given</code>, <code>When</code> та <code>Then</code> (запроваджені трейтом <code>GivenWhenThen</code>) можуть допомогти сфокусувати обговорення на особливостях окремих сценаріїв. Виклик <code>pending</code> в кінці вказує, що ані тести, вні справжня поведінка не були реалізовані, тільки специфікація. Як тільки всі тести та задана поведінка будуть реалізовані, тести будуть пройдені, та вимоги можуть вважатись задовільненими.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_5____">14.5 Базоване на властивостях тестування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Інший корисний інструмент тестування для Scala є ScalaCheck, фреймворк з відкритим кодом, написаний Rickard Nilsson. ScalaCheck дозволяє вам задавати властивості, яким має підкорюватись код під тестуванням. Для кожної властивості ScalaCheck буде генерувати дані, та виконувати твердження, що перевіряють, чи властивість буде справджуватись. Лістинг 14.7 показує приклад використання ScalaCheck з ScalaTest <code>WordSpec</code>, що міксує трейт <code>PropertyChecks</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.WordSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.prop.PropertyChecks</span>
<span class="k">import</span> <span class="nn">org.scalatest.MustMatchers._</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">WordSpec</span> <span class="k">with</span> <span class="nc">PropertyChecks</span> <span class="o">{</span>
  <span class="s">&quot;elem result&quot;</span> <span class="n">must</span> <span class="o">{</span>
    <span class="s">&quot;have passed width&quot;</span> <span class="n">in</span> <span class="o">{</span>
      <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">whenever</span> <span class="o">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
          <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">width</span> <span class="n">must</span> <span class="n">equal</span> <span class="o">(</span><span class="n">w</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 14.7 - Написання властивість-базованих тестів за допомогою ScalaCheck.</p></div>
<div class="paragraph"><p><code>WordSpec</code> є класом стилю ScalaTest. Трейт <code>PropertyChecks</code> провадить декілька методів <code>forAll</code>, що дозволяють вам міксувати властивість-базовані тести з традиційними твердження-базованими або матчер-базованими тестами. В цьому прикладі ми перевіряємо властивість, якій має підкорюватись фабрика <code>elem</code>. Властивості ScalaCheck виражені як функціональне значення, що приймає як параметри дані, потрібні для твердження властивості. Ці дані будуть згенеровані ScalaCheck. У властивості, показаній в Лістингу 14.7, дані є ціле на ім'я <code>w</code>, що представляє ширину. В тілі функції ви бачите цей код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">whenever</span> <span class="o">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">width</span> <span class="n">must</span> <span class="n">equal</span> <span class="o">(</span><span class="n">w</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Твердження <code>whenever</code> вказує, що коли ліва частина вираза є <code>true</code>, вираз зправа має також бути <code>true</code>. Так що в цьому випадку, вираз в блоці має бути <code>true</code>, коли <code>w</code> є більше ніж <code>0</code>. Права частина виразу в цьому випадку буде давати <code>true</code>, якщо ширина, передана до фабрики <code>elem</code> є тою самою, що і <code>width</code> для Element, що повертається з фабрики.</p></div>
<div class="paragraph"><p>З цією малою кількістю коду ScalaCheck буде генерувати, можливо, сотні значень для керування тестуванням кожного з них, шукаючи значення, для якого властивість не справджується. Якщо властивість дає <code>true</code> для кожного значення, що пробує ScalaCheck, тест буде пройдений. Інакше тест завершиться несподівано з <code>TestFailedException</code>, що містить інформацію, включаючи значення, яке спричинило збій.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_6____">14.6 Організація та виконання тестів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кожний фреймворк, згаданий в цій главі, провадить деякий механізм для організації та виконання тестів. В цьому розділі ми надамо швидкий огляд підходу ScalaTest. Щоб отримати повну історію по кожному з ціх фреймворків, вам треба проконсультуватись з їх документацією.</p></div>
<div class="paragraph"><p>В ScalaTest ви організуєте великі тестові сюїти, вкладаючи <code>Suite</code> в <code>Suite</code>. Коли <code>Suite</code> виконується, вона буде виконувати свої вкладені сюїти, так само, як і їх тести. Вкладені <code>Suite</code> будуть в свою чергу виконувати свої вкладені <code>Suite</code>, і так далі. Таким чином, велика сюїта представлена як дерево об'єктів <code>Suite</code>. Коли ви виконуєте кореневу  <code>Suite</code> в дереві, всі сюїти в дереві будуть виконані.</p></div>
<div class="paragraph"><p>Ви можете вкладувати сюїти іручну або автоматично. Щоб вкладати вручну, ви або перекриваєте метод <code>nested</code> для вашої <code>Suite</code>, або передаєте всі <code>Suite</code>, що ви бажаєте вкласти, в конструктор класу <code>Suites</code>, який ScalaTest провадить саме для цієї цілі. Щоб вкласти сюїти автоматично, ви провадите імена пакунків до ScalaTest Runner, що буде визначати <code>Suite</code> автоматично, вкладати їх під кореневою <code>Suite</code>, та виконувати кореневу <code>Suite</code>.</p></div>
<div class="paragraph"><p>Ви можете визвати застосування ScalaTest Runner з командного рядка або через інструмент побудови, такий як <code>sbt</code>, <code>maven</code> або <code>ant</code>. Найпростіший спосіб викликати Runner з командного рядка через застосування <code>org.scalatest.run</code>. Це застосування очікує повністю кваліфіковане ім'я тестованого класу. Наприклад, щоб виконати тестовий клас, показаний в Лістингу 14.6, ви маєте компілювати його такою командою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="n">cp</span> <span class="n">scalatest</span><span class="o">.</span><span class="n">jar</span> <span class="nc">TVSetSpec</span><span class="o">.</span><span class="n">scala</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ви можете виконати його:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala -cp scalatest.jar org.scalatest.run TVSetSpec</code></pre>
</div></div>
<div class="paragraph"><p>Малюнок 14.1 - Вивід <code>org.scalatest.run</code>.</p></div>
<div class="paragraph"><p>За допомогою <code>-cp</code> ви покладаєте файл ScalaTest JAR на шлях до класів. (При завантаженні ім'я JAR файла буде включати номери версій вбудованих Scala та ScalaTest.) Наступний токен, <code>org.scalatest.run</code>, є повністю кваліфікованим іменем застосування. Scala буде виконувати це застосування, та передасть залишок токенів як аргументи командного рядка. Аргумент <code>TVSetSpec</code> вказує на сюїту, що треба виконати. Результат показаний на Малюнку 14.1.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_14_7_">14.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили приклади міксування тверджень напряму в промисловий код, так само, як і написання їх назовні, в тестах. Ви бачили, що як Scala програміст, ви можете отримати переваги від популярних тестових інструментів від спільноти Java, таких, як JUnit та TestNG, так само, як і від новіших інструментів, розроблених спеціально для Scala, таких як ScalaTest, ScalaCheck, та specs2. Обоє, твердження в коді та зовнішні тести можуть допомогти вам досягти цілі щодо якості вашого коду. Ми відчуваємо, що ці технології досить важливі, щоб виправдати короткий відступ від Scala туторіала, що представляє ця глава. Однак в наступній главі ми повернемось до туторіала по мові, та розглянемо дуже корисний аспект Scala: співпадіння шаблонів.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__15">Глава 15</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="______7">Кейс класи та порівняння шаблонів</h1>
<div class="paragraph"><p>Ця глава вводить <em>кейс класи</em> та <em>порівняння шаблонів</em>, споріднені конструкції, що підтримують вас коли ви пишете регулярні, не-інкапсульовані структури даних. Ці дві конструкції зокрема корисні для дерево-подібних рекурсивних даних.</p></div>
<div class="paragraph"><p>Якщо ви до цього програмували на функціональній мові, тоді ви, можливо, розпізнали порівняння шаблонів. Але кейс класи будуть новими для вас. Кейс класи це шлях Scala, щоб дозволити порівняння шаблонів на об'єктах, не потребуючи великої кількості кліше. Загалом, все що вам треба робити, це додати одне ключове слово case до кожного класу, що би бажаємо зробити придатним для порівняння.</p></div>
<div class="paragraph"><p>Ця глава починається з простого прикладу кейс класу та порівняння шаблонів. Потім вона проходить по всіх підтримуваних шаблонах, каже про роль закоркованих класів, дискутує тип <code>Option</code>, та показує деякі не-очевидні місця в мові, де використовується порівняння шаблонів. Нарешті, показаний більший, більш реалістичний приклад порівняння шаблонів.</p></div>
<div class="sect1">
<h2 id="_15_1__">15.1 Простий приклад</h2>
<div class="sectionbody">
<div class="paragraph"><p>Перед зануренням в усі правила та нюанси порівняння шаблонів, варто подивитись на простий приклад, щоб зрозуміти головну ідею. Скажімо, вам треба написати бібліотеку, що маніпулює арифметичними виразами, можливо як частину домен-специфічної мови, яку ви розробляєте.</p></div>
<div class="paragraph"><p>Перший крок подолання цієї проблеми є визначення вхідних даних. Щоб утримувати речі простими, ми сконцентруємось на арифметичних виразах, що складаються зі змінних, чисел, та одно- і дво-місних операціях. Це виражається через ієрархію Scala класів, показану в Лістингу 15.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.1 - Визначення кейс класів.</p></div>
<div class="paragraph"><p>Ієрархія включає абстрактний базовий клас <code>Expr</code> з чотирма субкласами, по одному для кожного типу виразу, що розглядається.<span class="footnote"><br />[Замість абстрактного класу, ми також можемо обрати змоделювати корінь ієрархії класів як трейт. Моделювання його як абстрактного класу може бути трохі більш ефективним.]<br /></span> Тіла всіх п'яти класів порожні. Як зазначалось раніше, в Scala ви можете відкинути фігурні дужки коло порожніх класів, якщо бажаєте, та що <code>class C</code> те саме, що і <code>class C {}</code>.</p></div>
<div class="sect2">
<h3 id="___19">Кейс класи</h3>
<div class="paragraph"><p>Інша варта уваги річ щодо декларацій на Лістингу 15.1 є те, що кожний клас має модифікатор <code>case</code>. Класи з таким модифікатором називаються кейс класами. Використання модифікатора змушує Scala компілятор додати деякі синтаксичні зручності до вашого класу.</p></div>
<div class="paragraph"><p>Перше, він додає метод фабрику з ім'ям класу. Це означає, наприклад, що ви можете писати <code>Var("x")</code> для конструювання об'єкту <code>Var</code>, замість трохи довшого <code>new Var("x")</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">Var</span> <span class="o">=</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи фабрик зокрема гарні, коли ви вкладаєте їх. Оскільки не існує шумлячих ключових слів <code>new</code>, розкиданих по коду, ви можете збагнути структуру вираза з одного погляду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">op</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">v</span><span class="o">)</span>
<span class="n">op</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Друга синтаксична зручність в тому, що всі ці аргументи в списку параметрів кейс класів неявно отримують префікс <code>val</code>, так що вони обробляються як поля:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">left</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Третє, компілятор додає "природні" реалізації методів <code>toString</code>, <code>hashCode</code> та <code>equals</code> до вашого класу. Вони будуть друкувати, хешувати, та порівнювати цілі дерева, що складається з вашого класу, та (рекурсивно), всіх його аргументів. Оскільки <code>==</code> в Scala завжди делегує до <code>equals</code>, це означає, що елементи кейс класів завжди порівнюються структурно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
<span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, компілятор додає метод <code>copy</code> до вашого класу, щоб робити модифіковані копії. Цей метод корисний для створення нових примірників класу, що такі самі, як і інший, за винятком того, що один або два аргументи відрізняються. Метод робить через використання іменованих та параметрів за замовчанням (дивіться Розділ 8.8). Ви вказуєте зміни, що ви б хотіли зробити, використовуючи іменовані параметри. Для любих параметрів, які ви не вказуєте, буде використано значення зі старого об'єкту. Як приклад, ось як ви можете зробити операцію, таку саму як <code>op</code>, за винятком того, що оператор змінений:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">operator</span> <span class="k">=</span> <span class="s">&quot;-&quot;</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(-,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі ці домовленості додають великі зручності за малу ціну. Ви мали написати лише модифікатор <code>case</code>, та ваші класи і об'єкти стають трохи більшими. Вони більші, оскільки згенеровані додаткові методи та додані неявні поля для кожного параметру конструктора. Однак найбільша вигода від кейс класів є те, що вони підтримують порівняння шаблонів.</p></div>
</div>
<div class="sect2">
<h3 id="___20">Порівняння шаблонів</h3>
<div class="paragraph"><p>Скажімо, ви бажаєте спростити арифметичні вирази тільки що представлених типів. Є багато можливих правил спрощення. Наступні три правила служать тільки для ілюстрації
:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span>  <span class="c1">// Подвійна зміна знаку</span>
<span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span> <span class="c1">// Додавання нуля</span>
<span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span> <span class="c1">// Множення на одинницю</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи порівняння шаблонів, ці правила можуть розгядатись майже так, якби вони формували основу функції спрощення в Scala, як показано на Лістингу 15.2. Функція <code>simplifyTop</code>, може використовуватись таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">))))</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>  <span class="c1">// Подвійна зміна знаку</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="c1">// Додавання нуля</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="c1">// Множення на одинницю</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.2 - Функція <code>simplifyTop</code>, що робить порівняння шаблонів.</p></div>
<div class="paragraph"><p>Права сторона <code>simplifyTop</code> складається з вираза <code>match</code>. <code>match</code> відповідає до <code>switch</code> в Java, але він записаний після вираза селектора. Іншими словами, це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">selector</span> <span class="k">match</span> <span class="o">{</span> <span class="n">alternatives</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">switch</span> <span class="o">(</span><span class="n">selector</span><span class="o">)</span> <span class="o">{</span> <span class="n">alternatives</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння шаблонів включає послідовність альтернатив, кожне починається з ключового слова <code>case</code>. Кожна альтернатива включає шаблон, та один або більше виразів, що будуть обчислені, якщо шаблон співпадає. Символ стрілки <code>=&gt;</code> відділяє шаблон від виразів.</p></div>
<div class="paragraph"><p>Вираз <code>match</code> обчислюється через спробу кожного з шаблонів по порядку, як вони записані. Перший шаблон, що співпаде, буде обраний, та частина, що стоїть за стрілкою, обирається та виконується.</p></div>
<div class="paragraph"><p><em>Шаблон константи</em> як <code>"+"</code> або <code>1</code> співпадає зі значеннями, що дорівнюють константі з точки зору <code>==</code>.</p></div>
<div class="paragraph"><p><em>Шаблон змінної</em> як <code>e</code> співпадає з любим значенням. Змінна після цього посилається на це значення в правій частині твердження <code>case</code>. В цьому прикладі зауважте, що перші три альтернативи обчислюються до <code>e</code>, змінної, що прив'язана в асоційованому шаблоні. Підстановочний шаблон <code>_</code> також співпадає з кожним значенням, але він не вводить ім'я змінної, що посилається на це значення. В Лістингу 15.2 зауважте, як <code>match</code> закінчується на випадок за замовчаню, що нічого не робить з виразом. Замість цього, він просто має результат <code>expr</code>, вираз, якій порівнюється.</p></div>
<div class="paragraph"><p><em>Шаблон конструктора</em> виглядає <code>UnOp("-", e)</code>. Цей шаблон співпадає з усіма значеннями типу <code>UnOpwhose</code>, чий перший аргумент співпадає з <code>"-"</code>, та чий другий аргумент співпадає з <code>e</code>. Зауважте, що аргументи до конструктора самі є шаблонами. Це дозволяє вам писати глибокі шаблони, використовуючи стислу нотацію.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Уявіть реалізцію тієї самої функціональності з використанням дизайну шаблону візитора!<span class="footnote"><br />[Gamma, et. al., Design Patterns [Gam95]]<br /></span>Майже так само незручно, уявіть його реалізацію як довгої послідовності тверджень <code>if</code>, перевірок та перетворень типів.</p></div>
</div>
<div class="sect2">
<h3 id="__code_match_code__code_switch_code">Порівняння <code>match</code> та <code>switch</code></h3>
<div class="paragraph"><p>Вирази <code>match</code> можуть розглядатись як узагальнення <code>switch</code> в стилі Java. Перемикачі в стилі Java можуть бути природно виражені як вирази <code>match</code>, де кожний шаблон є константою, та останній шаблон може бути підстановочним (що презентує випадок <code>default</code> в <code>switch</code>).</p></div>
<div class="paragraph"><p>Однак існує три відмінності, що треба мати на увазі: перше - <code>match</code> є виразом в Scala (тобто, він завжди повертає значення). Друге, вирази альтернатив в Scala ніколи не "провалюються" в наступний випадок. Третє, як жодний з шаблонів не співпадає, закидається виключення <code>MatchError</code>. Це означає, що ви завжди маєте переконатись, що покриті всі випадки, навіть якщо це означає додавання випадку за замовчанням, якій нічого не робить.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.3 - Шаблон <code>match</code> з порожнім випадком <code>"default"</code>.</p></div>
<div class="paragraph"><p>Лістинг 15.3 показує приклад. Другий випадок є необхідним, оскільки без нього вираз <code>match</code> буде викликати <code>MatchError</code> для кожного аргументу <code>expr</code>, що не є <code>BinOp</code>. В цьому прикладі для другого випадка немає коду, так що при виконанні випадка нічого не виконується. В любому випадку результат є одиничне значенню <code>()</code>, що також є результатом всього виразу <code>match</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_2__">15.2 Різновиди шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад показує декілька типів шаблонів в швидкій послідовності. Тепер затратимо хвилину, та детально поглянемо на кожний шаблон.</p></div>
<div class="paragraph"><p>Синтаксис шаблонів простий, так що не турбуйтесь щодо цього дуже сильно. Всі шаблони виглядають точно так, як відповідні вирази. Наприклад, маючи ієрархію з Лістингу 15.1, шаблон <code>Var(x)</code> співпадає з любим виразом змінної, пов'язуючи <code>x</code> з ім'ям змінної. Використовуючи вираз <code>Var(x)</code> — точно такий же синтаксис — перестворює еквівалентний об'єкт, вважаючи, що <code>x</code> вже прикріалений до імені змінної. Оскільки синтаксис шаблонів такий прозорий, головна річ, на яку варто звертати увагу, це тільки те, які шаблони взагалі можливі.</p></div>
<div class="sect2">
<h3 id="___21">Підстановочні шаблони</h3>
<div class="paragraph"><p>Підстановочний шаблон (<code>_</code>) співпадає взагалі з любим об'єктом. Ми вже бачили, як це використовується по замовчанню, в альтернативі спіймати-всіє:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// обробляє випадок за замовчанням</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Підстановки можуть також бути використані для ігнорування частини об'єкта, яка нас не цікавить. Наприклад, попередній приклад насправді не переймається, які елементи є в двомісній операції; він тільки перевіряє, чи це є це двомісною операцією, чи ні. Таким чином, код так само може використовувати підстановочний шаблон для елементів <code>BinOp</code>, як показано в Лістингу 15.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;It&#39;s something else&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.4 - Порівняння шаблонів з підстановочними шаблонами.</p></div>
</div>
<div class="sect2">
<h3 id="___22">Шаблони констант</h3>
<div class="paragraph"><p>Шаблон константи співпадає тільки сам з собою. В якості константи може бути використаний любий літерал. Наприклад, <code>5</code>, <code>true</code>, <code>"hello"</code> всі є шаблонами константами. Також в якості константи може використовуватись любий val або об'єкт синглтон. Наприклад, об'єкт синглтон <code>Nil</code> є шаблоном, що співпадає тільки з порожнім списком. Лістинг 15.5 показує деякі приклади шаблонів констант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="s">&quot;five&quot;</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="s">&quot;truth&quot;</span>
  <span class="k">case</span> <span class="s">&quot;hello&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;hi!&quot;</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">&quot;the empty list&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;something else&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.5 - Порівняння шаблонів з шаблонами константами.</p></div>
<div class="paragraph"><p>Ось як порівняння шаблонів, показане в Лістингу 15.5, виглядає в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">five</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">truth</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">the</span> <span class="n">empty</span> <span class="n">list</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">something</span> <span class="k">else</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___23">Шаблони змінні</h3>
<div class="paragraph"><p>Шаблон змінна співпадає з любим об'єктом, так само як підстановка. Але на відміну від підстановки, Scala прив'язує змінну до цього об'єкту. Потім ви можете використовувати цю змінну, щоб діяти на цьому об'єкті. Наприклад, Лістинг 15.6 показує порівняння шаблонів, що має особливий випадок для нуля, та випадок за замовчанням для всіх інших значень. Випадок за замовченням використовує шаблон змінної, яка надає ім'я значенню, не важливо що це є.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="s">&quot;zero&quot;</span>
  <span class="k">case</span> <span class="n">somethingElse</span> <span class="k">=&gt;</span> <span class="s">&quot;not zero: &quot;</span> <span class="o">+</span> <span class="n">somethingElse</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.6 - Порівняння шаблонів з шаблоном змінної.</p></div>
</div>
<div class="sect2">
<h3 id="____14">Змінна або константа?</h3>
<div class="paragraph"><p>Шаблони констант можуть мати символічні імена. Ви вже бачили це, коли ми використовували  <code>Nil</code> як шаблон. Ось пов'язаний приклад, де порівняння шаблонів задіє константи <code>E</code>(2.71828&#8230;) та <code>Pi</code> (3.14159&#8230;):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Pi</span> <span class="k">=&gt;</span> <span class="s">&quot;дивна математика? Pi = &quot;</span> <span class="o">+</span> <span class="nc">Pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">OK</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і очікувалось, <code>E</code> не дорівнює <code>Pi</code>, так що варіант "дивна математика" не використовується.</p></div>
<div class="paragraph"><p>Як компілятор Scala знає, що <code>Pi</code> є константою, імпортаваною з <code>scala.math</code>, а не змінна, що сама складає значення селектора? Scala використовує просте лексичне правило для вирішення неоднозначностей: просте ім'я, що починається з літери в нижньому реєстрі приймається як змінна шаблона; Всі інші посилання розглядаються як константи. Щоб побачити різницю, створіть псевдоним в нижньому реєстрі для <code>pi</code>, та спробуте виконати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="nc">Pi</span>
<span class="n">pi</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.141592653589793</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">&quot;strange math? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
<span class="o">}</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">strange</span> <span class="n">math</span><span class="o">?</span> <span class="nc">Pi</span> <span class="k">=</span> <span class="mf">2.718281828459045</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут компілятор навіть взагалі не дозволить вам додати випадок за замовчанням. Оскільки  <code>pi</code> є шаблоном змінної, вона буде співпадати з усіма входами, так що за нею жодний <code>case</code> не буде досяжний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
<span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">&quot;strange math? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">unreachable</span> <span class="kt">code</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
          <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви все ще можете використовувати ім'я в нижньому реєстрі для шаблогів констант, якщо вам так треба, але використовуючи один або два трюки. Перше, якщо константа є полем деякого об'єкта, ви можете поставити перед нею кваліфікатор. Наприклад, <code>pi</code> буде шаблоном змінної, але <code>this.pi</code> або <code>obj.pi</code> будуть константами, навіть якщо вони починаються з літер в нижньому реєстрі. Якщо це не робить (скажімо, тому що <code>pi</code> є локальною змінною), альтернативно ви можете оточити ім'я змінної в зворотні дефіси. Наприклад,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`pi`</code></pre>
</div></div>
<div class="paragraph"><p>знову буде інтерпретовано як константа, не як змінна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`pi`</span> <span class="k">=&gt;</span> <span class="s">&quot;дивна математика? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">OK</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, синтаксис з дефісами для ідентифікаторів використовуються в Scala для двох різних призначень, щоб допомогти вам кодувати у ваш спосіб за незвичних обставин. Тут ви бачили, як це використовується для трактування ідентифікатора в нижньому реєстрі як константи в порівнянні шаблонів. Раніше, в Розділі 6.10, ви бачили, що це також може бути використано для трактування ключового слова як звичайного ідентифікатора, тобто, коли ви пишете</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Thread.`yield`()</code></pre>
</div></div>
<div class="paragraph"><p><code>yield</code> буде розглядатись як ідентифікатор, не як ключове слово.</p></div>
</div>
<div class="sect2">
<h3 id="___24">Шаблони конструктори</h3>
<div class="paragraph"><p>Конструктори є те, де порівняння шаблонів стає дійсно потужним. Шаблоне конструктора виглядє як <code>BinOp("+", e, Number(0))</code>. Це складається з імені (<code>BinOp</code>), та потім з декількох шаблонів в дужках: <code>"+"</code>, <code>e</code> та <code>Number(0)</code>. Вважаючи, що ім'я означає кейс клас, такий шаблон означає, що спочатку перевіряється, що об'єкт є членом названого кейс класу, та потім перевіряє, що параметри конструктора об'єкта співпадають з наданими додатковими шаблонами.</p></div>
<div class="paragraph"><p>Ці додаткові шаблони означають, що шаблони Scala підтримують <em>глибоке порівняння</em>. Такі шаблони не тільки перевіряють наданий об'єкт високого рівня, але також вміст цього об'єкту щодо подальших шаблонів. Оскільки додаткові шаблони самі можуть бути шаблонами конструкторів, ви можете використовувати їх для перевірки довільної глибини вкладених об'єктів. Наприклад, шаблон, показаний в Лістингу 15.7, перевіряє, що об'єкт вищого рівня є <code>BinOp</code>, що його третій параметр конструктора є <code>Number</code>, та що значення поля цього числа є <code>0</code>. Цей шаблон довжиною в один рядок перевіряє на три рівня в глибину.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;a deep match&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.7 - Порівняння шаблонів з шаблоном конструктора.</p></div>
</div>
<div class="sect2">
<h3 id="___25">Шаблони послідовностей</h3>
<div class="paragraph"><p>Ви можете порівнювати з типами послідовностей, як <code>List</code> або <code>Array</code>, так само, як ви порівнюєте з кейс класами. Використовується той самий синтаксис, але тепер ви можете вказати число елементів в шаблоні. Лістинг 15.8 показує шаблон, що перевіряє в пошуках три-елементних списків, що починаються з нуля.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="o">=&gt;}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.8 - Шаблон послідовності фіксованої довжини.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте порівняти з послідовністю, не вказуючи наскільки довгі вони є, ви можете вказати <code>_*</code> як останній елемент шаблону. Цей цікаво-виглядаючий шаблон співпадає з любим числом елементів в послідовності, включаючи нуль елементів. Лістинг 15.9 показує приклад, що співпадає з любим списком, що починається з нуля, не важливо які вони за довжиною.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.9 - Шаблон послідовності довільної довжини.</p></div>
</div>
<div class="sect2">
<h3 id="___26">Шаблони таплів</h3>
<div class="paragraph"><p>Ви можете також порівнювати з таплами. Шаблон як <code>(a, b, c)</code> співпадає з довільним 3-таплом. Приклад показаний в Лістингу 15.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">tupleDemo</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;matched &quot;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.10 - Порівняння шаблонів з шаблоном тапла.</p></div>
<div class="paragraph"><p>Якщо ви завантажите в інтерпретатор метод <code>tupleDemo</code>, показаний в Лістингу 15.10, та передасте до нього тапл з трьох елементів, ви побачите:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">tupleDemo</span><span class="o">((</span><span class="s">&quot;a &quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">&quot;-tuple&quot;</span><span class="o">))</span>
<span class="n">matched</span> <span class="n">a</span> <span class="mi">3</span><span class="o">-</span><span class="n">tuple</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___27">Шаблони типів</h3>
<div class="paragraph"><p>Ви можете використовувати <em>шаблон типу</em> як зручну заміну для перевірки типу та приведення типів. Лістинг 15.11 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.11 - Порівняння шаблонів з шаблоном типу.</p></div>
<div class="paragraph"><p>Ось декілька прикладів виконання <code>generalSize</code> в інтерпретаторі Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="sc">&#39;b&#39;</span><span class="o">))</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="o">)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>generalSize</code> повертає розмір або довжину об'єктів різних типів. Його аргумент має тип <code>Any</code>, так що він може мати любе значення. Якщо аргументом є <code>String</code>, метод повертає довжину рядка. Шаблон <code>s: String</code> є шаблоном типу; він співпадає з кожним (не-null) примірником <code>String</code>. Шаблон змінної <code>s</code> після співпадіння посилається на цей рядок.</p></div>
<div class="paragraph"><p>Зауважте, що навіть якщо <code>s</code> та <code>x</code> посилаються на те саме значення, типом <code>x</code> є <code>Any</code>, тоді як типом <code>s</code> є <code>String</code>. Так що ви можете записати <code>s.length</code> в виразі альтернативи, що відповідає шаблону, але ви не можете написати <code>x.length</code>, оскільки тип <code>Any</code> не має члена <code>length</code>. Еквівалентний, але більш довготривалий шлях досягти такий самий ефект порівняння з шаблоном типу, включає перевірку типу, за яким слідує перетворення типу. Scala використовує інший синтаксис для цього, ніж Java. Скажімо, щоб протестувати, чи вираз <code>expr</code> має тип <code>String</code>, ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб привести той самий вираз до типу <code>String</code>, ви використовуєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи перевірку та приведення типів, ви можете переписати перший <code>case</code> попереднього виразу <code>match</code>, як показано в Лістингу 15.12.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="n">s</span><span class="o">.</span><span class="n">length</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.12 - Використання <code>isInstanceOf</code> та <code>asInstanceOf</code> (слабкий стиль).</p></div>
<div class="paragraph"><p>Оператори <code>isInstanceOf</code> та <code>asInstanceOf</code> розглядаються як передвизначені методи класу <code>Any</code>, що приймає параметр типу в прямокутних дужках. Фактично, <code>x.asInstanceOf[String]</code> є особливим випадком виклику метода з явним параметром типу <code>String</code>.</p></div>
<div class="paragraph"><p>Як ви, сподіваємось, вже зауважили, написання перевірки та приведення типів є скоріше балакучим в  Scala. Це зроблене навмисно, оскільки ця практика не заохочується. Звичайно ви зробите краще, якщо використаєте порівняння шаблонів з шаблоном типу. Це зокрема вірно, якщо вам треба зробити одночасно перевірку та приведення типу, оскільки обидві операції можна закатати в одне порівняння шаблону.</p></div>
<div class="paragraph"><p>Другий <code>case</code> виразу <code>match</code> в Лістингу 15.11 містить шаблон типу <code>m: Map[_, _]</code>. Цей шаблон співпадає з любим значенням, що є <code>Map</code> деякого довільного типу ключа та значення, да встановлює <code>m</code> як посилання на цю мапу. Таким чином, <code>m.size</code> гарно типізоване і повертає розмір мапи. Підкреслення в шаблоні типу, <span class="footnote"><br />[В шаблоні типу <code>m: Map[_, _]</code>, частина <code>Map[_, _]</code> називається шаблоном типу.]<br /></span> є подібними до замінників в інших шаблонах. Ви також можете використовувати замість цього змінні типів (в нижньому реєстрі).</p></div>
</div>
<div class="sect2">
<h3 id="___28">Затирання типів</h3>
<div class="paragraph"><p>Чи ви можете також перевірити мапу щодо певних типів елементів? Це може стати в нагоді, скажімо, для перевірки, чи певне значення є мапа з типу <code>Int</code> до типу <code>Int</code>. Давайте спробуємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">non-variable</span> <span class="k">type</span> <span class="kt">argument</span> <span class="kt">Int</span> <span class="kt">in</span> <span class="k">type</span>
<span class="kt">pattern</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="o">(</span><span class="n">the</span>
<span class="n">underlying</span> <span class="n">of</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">])</span> <span class="n">is</span> <span class="n">unchecked</span> <span class="n">since</span> <span class="n">it</span> <span class="n">is</span>
<span class="n">eliminated</span> <span class="n">by</span> <span class="n">erasure</span>
<span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala використовує модель затирання дженериків, так само як робить Java. Це означає, що під час виконання немає інформації щодо типів аргументів. Відповідно немає шляху визначити під час виконання, чи об'єкт <code>Map</code> був створений з двома аргументами <code>Int</code>, скоріше, ніж з двома аргументами інших типів. Все, що може зробити система, це визначити, що значення є Map з довільними типами параметрів. Ви можете перевірити цю поведінку, через застосування <code>isIntIntMap</code> до аргументів різних примірників класу <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;abc&quot;</span><span class="o">))</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше застосування повертає <code>true</code>, що виглядає коректним, але друге застосування також повертає <code>true</code>, що може бути сюрпризом. Щоб попередити вас щодо можливої не-інтуітивної поведінки в рантаймі, компілятор видає попередження, як таке, що ви бачили перед цім.</p></div>
<div class="paragraph"><p>Одне виключення до правила затирання є масиви, тому що вони обробляються окремо в Java, так само як в Scala. Тип елементів масива зберігається зі значенням масиву, так що ви можете порівнювати шаблони завдяки цьому.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">&quot;yes&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;no&quot;</span>
<span class="o">}</span>
<span class="n">isStringArray</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Any</span><span class="o">)</span><span class="kt">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">as</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">as</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">as</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">yes</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ai</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">ai</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">ai</span><span class="o">)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____15">Прив'язування змінних</h3>
<div class="paragraph"><p>На додаток до окремих шаблонів змінних, ви також можете додати змінну до любого іншого шаблону. Ви просто пишете ім'я змінної, знак <code>@</code>, та потім шаблон. Це дає вам шаблон з прив'язуванням змінної, що означає, що шаблон порівнюється як звичайно, і якщо співпадіння успішне, встановлює змінну в співпадаючий об'єкт, так само, як при звичайному шаблоні змінної.</p></div>
<div class="paragraph"><p>Як приклад, Лістинг 15.13 показує порівняння шаблонів, що шукає операцію абсолютного значення, яке застосоване два рази поспіль. Такі вирази можуть бути спрощені, щоб брати абсолютне значення тільки один раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="n">e</span> <span class="k">@</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.13 - Шаблон з прив'язуванням змінної (через знак @).</p></div>
<div class="paragraph"><p>Приклад, показаний в Лістингу 15.13, включає шаблон  прив'язування змінної, з <code>e</code> в якості змінної, та <code>UnOp("abs", _)</code> в якості шаблону. Якщо співпадіння цілого шаблону буде успішним, тоді частина, що співпадає з <code>UnOp("abs", _)</code>, буде доступна як змінна <code>e</code>. Результатом <code>case</code> є сама <code>e</code>, оскільки <code>e</code> має те саме значення, що і <code>expr</code>, але меньше на одну операцію абсолютного значення.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_3__">15.3 Захисники шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді синтаксичне порівняння шаблонів не є достатеьо точним. Скажімо, наприклад, ви має завдання сформулювати правило спрощення, що представляє вирази суми з двома однаковими операндами, такі як <code>e + e</code>, як множення на два (тобто, <code>e * 2</code>). В мові дерев <code>Expr</code> вираз як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>може бути трансформована цім правилом до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете спробувати виразити це правило таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">x</span> <span class="kt">is</span> <span class="kt">already</span> <span class="kt">defined</span> <span class="kt">as</span> <span class="kt">value</span> <span class="kt">x</span>
<span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
                   <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Це схибить, оскільки Scala обмежує шаблони до лінійності: змінна шаблона може з'являтись в шаблоні тільки один раз. Однак, ви можете пере-формулювати <code>match</code> за допомогою захисника шаблона, як показано в Лістингу 15.14:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
<span class="n">simplifyAdd</span><span class="k">:</span> <span class="o">(</span><span class="kt">e:</span> <span class="kt">Expr</span><span class="o">)</span><span class="kt">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.14 - Вираз <code>match</code> з захисником шаблону.</p></div>
<div class="paragraph"><p>Захисник шаблону іде після шаблону, та починається з <code>if</code>. Захисник може бути довільним логічним виразом, що звичайно посилається на змінні в шаблоні. Якщо захисник шаблону присутній, <code>match</code> буде успішним тільки якщо захисник обчислюється до <code>true</code>. Таким чином, перший <code>case</code> вище буде співпадати тільки з двомісними операціями з двома однаковими операндами.</p></div>
<div class="paragraph"><p>Деякі інші приклади захищених шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// співпадає тільки з додатними цілими</span>
<span class="k">case</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="err">0</span> <span class="kt">&lt;</span> <span class="kt">n</span> <span class="o">=&gt;</span> <span class="o">...</span>

<span class="c1">// співпадає тільки з рядками, що починаються на літеру &#39;a&#39;</span>
<span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">if</span> <span class="kt">s</span><span class="o">(</span><span class="err">0</span><span class="o">)</span> <span class="o">=</span><span class="k">=</span> <span class="sc">&#39;a&#39;</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_4__">15.4 Перекриття шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Шаблони випробовуються в порядку, в якому вони записані. Версія <code>simplify</code>, показана в Лістингу 15.15, представляє приклад, де порядок <code>case</code> має значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;-&#39; подвійна інверсія</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span>
   <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;0&#39; є нейтральним елементом для &#39;+&#39;</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;1&#39; є нейтральним елементом для `*&#39;</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.15 - Вираз <code>match</code>, в якому порядок <code>case</code> має значення.</p></div>
<div class="paragraph"><p>Версія <code>simplify</code>, показана в Лістингу 15.15, буде застосовувати правила спрощення будь-де в виразі, не тільки на вищому рівні, як робив <code>simplifyTop</code>. Він може походити від <code>simplifyTop</code> через додавання ще двох випадків для узагальнених одно- та дво-місних виразів (випадки чотири та п'ять в Лістингу 15.15).</p></div>
<div class="paragraph"><p>Четвертий випадок має шаблон <code>UnOp(op, e)</code>; тобто, від співпадає з кожною одномісною операцією. Оператор та операнд одномісної операції можуть бути довільними. Вони прив'язуються до змінних шаблону, <code>op</code> и <code>e</code>, відповідно. Альтернатива в цьому <code>case</code> застосовує <code>simplifyAll</code> рекурсивно до операнда <code>e</code>, та потім перебудовує ту саму одномісну операцію з (можливо) спрощеним операндом. П'ятий <code>case</code> для <code>BinOp</code> є аналогічним: це випадок "спіймати-все" <code>case</code> для довільних двомісних операцій, що рекурсивно застосовує метод спрощення до своїх двох операндів.</p></div>
<div class="paragraph"><p>В цьому прикладі є важливим, що випадкі спіймати-всі ідуть після більш специфічних правил спрощення. Якщо ви запишете їх в іншому порядку, тоді випадок спіймати-всі мав би виконуватись раніше, ніж специфічні випадки. В багатьох випадках компілятор навіть буде скаржитись, якщо ви спробуєте. Наприклад, ось вираз <code>match</code>, що не компілюється, оскілький перший <code>case</code> буде співпадати з усім, з чим може співпасти другий <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyBad</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
         <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyBad</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
         <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
       <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">unreachable</span> <span class="kt">code</span>
      <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
                                      <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_5__">15.5 Закорковані класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли б ви не писали порівняння шаблонів, вам треба переконатись, що ви розглянули всі можливі випадки. Іноді ви можете зробити це через додавання випадку за замовчанням до кінця <code>match</code>, але це має сенс, якщо існує доцільна поведінка за замовчанням. Що ви робитимете, якщо немає такого замовчання? Як ви будете почуватись впевнено, що покрили всі випадки?</p></div>
<div class="paragraph"><p>Ви можете отримати допомогу від Scala компілятора в визначенні пропущених комбінацій шаблонів в виразі <code>match</code>. Щоб зробити це, компілятор має бути в змозі сказати, які випадки є можливими. Загалом це неможливо в Scala, оскільки нові кейс класи можуть бути визначені в любий момент, та в довільних одиниціх компіляції. Наприклад, ніщо не завадить вам додати п'ятий кейс клас до ієрархії класу <code>Expr</code> в іншій одиниці компіляції, ніж та, де були визначені інші чотири випадки.</p></div>
<div class="paragraph"><p>Альтернативою є зробити суперклас вашого кейс класу закоркованим. Закоркований клас не може мати жодних субкласів, ніж ті, що знаходяться з мим в одному файлі. Це дуже корисно для порівняння шаблонів, оскільки це означає, що вам треба турбуватись тілкьи про субкласи, про які ви вже знаєте. Ще більше, ви також маєте більше підтримки з боку компілятора. Якщо ви порівнюєте кейс класи, що походять від закоркованого класу, компілятор буде помічати відсутні комбінації шаблонів повідомленнями попереджень.</p></div>
<div class="paragraph"><p>Якщо ви пишете ієрархію класів, призначених для порівняння шаблонів, ви маєте зробити їх закоркованими. Просто покладіть ключове слово <code>sealed</code> перед <code>class</code> зверху ієрархії. Програмісти, що використовують вашу ієрархію класів, після цього будуть почуватись зручно з порівнянням шаблонів. Таким чином, ключове слово <code>sealed</code> часто є ліцензією для порівняння шаблонів. Лістинг 15.16 показує приклад, в якому <code>Expr</code> перетворено на закоркований клас.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.16 - Закоркована ієрархія кейс класів.</p></div>
<div class="paragraph"><p>Тепер визначимо порівняння шаблонів, де пропущені деякі можливі варіанти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a variable&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви отримаєте попередження компілятора, подібне до наступного:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>warning: match is not exhaustive!
missing combination           UnOp
missing combination          BinOp</code></pre>
</div></div>
<div class="paragraph"><p>Паке попередження каже вам, що існує ризик що ваш код може продукувати виключення <code>MatchError</code>, оскільки деякі можливі шаблони (<code>UnOp</code>, <code>BinOp</code>) не оброблені. Попередження вказує на потенційне джерело збоїв під час виконання, так що це звичайно гарна допомога, щоб зробити ваш код вірним.</p></div>
<div class="paragraph"><p>Однак, часом ви можете натрапити на ситуацію, коли компілятор дуже прискіпливий, видаючи попередження. Наприклад, ви можете знати з контексту, що ви будете застосовувати описаний вище метод до виразів, що є або <code>Numbers</code> або <code>Vars</code>, так що ви знаєте, що він не спродукує <code>MatchError</code>. Щоб повідомлення пішло, ви можете додати третій випадок спіймати-всі до цього метода, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a variable&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span> <span class="c1">// Не має трапитись</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить, але це не ідеальне. Ви, можливо, не будете дуже щасливі, коли будете змушені додати код, якій ніколи не буде виконуватись (або ви так думаєте), просто попросивши компілятор помовчати.</p></div>
<div class="paragraph"><p>Більш полегшена альтернатива є додати анотацію <code>@unchecked</code> до вираза селектора в <code>match</code>. Це робиться таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a variable&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анотації описані в Главі 27. Загалом, ви можете додати анотацію до виразу в той самий спосіб, як ви додаєте тип: за виразом слідують дві крапки і ім'я анотації (зі знаком <em>@</em>). Наприклад, в цьому випадку ви додаєте анотацію <code>@unchecked</code> до змінної <code>e</code> за допомогою <code>e: @unchecked</code>. Анотація <code>@unchecked</code> має особливе значення для порівняння шаблонів. Якщо селектор `match`має цю анотацію, всебічна перевірка шаблону, що слідує, буде придушена.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_6__option">15.6 Тип Option</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має стандартний тип на ім'я <code>Option</code> для опціональних значень. Таке значення може бути в двох формах: <code>Some(x)</code>, де <code>x</code> є дійсним значенням, або об'єкт <code>None</code>, що представляє відсутність значення.</p></div>
<div class="paragraph"><p>Опціональні значення продукуються деякими зі стандартних операцій для колекцій Scala. Наприклад, метод <code>get</code> зі Scala <code>Map</code> продукує <code>Some(value)</code>, якщо значення, відповідне до наданого ключа, було знайдене, або <code>None</code>, якщо наданий ключ не визначений в <code>Map</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">capitals</span> <span class="k">=</span>
          <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">,</span> <span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">capitals</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Map</span><span class="o">(</span><span class="nc">France</span> <span class="o">-&gt;</span> <span class="nc">Paris</span><span class="o">,</span> <span class="nc">Japan</span> <span class="o">-&gt;</span> <span class="nc">Tokyo</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;France&quot;</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Paris</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;North Pole&quot;</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний шлях прийняти опціональні значення окремо - через порівняння шаблонів. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
         <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span>
         <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">&quot;?&quot;</span>
       <span class="o">}</span>
<span class="n">show</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="nc">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">(</span><span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;Japan&quot;</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Tokyo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">(</span><span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;France&quot;</span><span class="o">)</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Paris</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">(</span><span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;North Pole&quot;</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">?</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>Option</code> часто використовується в програмах Scala. Порівняйте це з домінуючою ідіомою Java, використовувати <code>null</code> для вказання відсутності значення. Наприклад, метод <code>get</code> в <code>java.util.HashMapreturns</code> повертає або значення, що зберігається в <code>HashMap</code>, або <code>null</code>, якщо значення не знайдене. Цей підхід робить для Java, але схильний до помилок, оскільки на практиці складно відстежувати, які змінні в програмі можуть приймати значення <code>null</code>.</p></div>
<div class="paragraph"><p>Якщо змінній дозволено бути <code>null</code>, тоді ви маєте пам'ятати перевіряти її на <code>null</code> кожного разу, коли ви використосуєте її. Якщо ви забудете перевірити, ви відкриєте можливість, щоб під час виконання отримати <code>NullPointerException</code>. Оскільки такі виключення не можуть траплятись дуже часто, може бути складно визначити помилку під час тестування. Для Scala цей підхід не робить взагалі, оскільки можливо зберігати значення типів в хеш мапах, але <code>null</code> не є легальним елементом для типу значення. Наприклад, <code>HashMap[Int, Int]</code> не може повертати <code>null</code> для позначення "нема елементу".</p></div>
<div class="paragraph"><p>Для контрасту Scala заохочує використання <code>Option</code> для індикації опціонального значення. Цей підхід до опціональних значень має декілька переваг над Java. Перше, це значно більш очевидне для читачів коду, що змінна, чий тип <code>Option[String]</code> є опціональний <code>String</code>, ніж змінна типу <code>String</code>, що може інколи бути <code>null</code>. Але більш важливо, що описана раніше помилка програмування, щодо використання змінної, що може бути <code>null</code> без попередньої перевірки її на <code>null</code>, в Scala стає помилкою типу. Якщо змінна має тип <code>Option[String]</code>, і ви намагаєтесь використовувати її як <code>String</code>, ваша Scala програма не буде компілюватись.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_7__">15.7 Шаблони кругом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Шаблони дозволені в багатьох частинах Scala, не тільки в окремих виразах <code>match</code>. Погляньте на деякі інші місця, де ви можете використовувати шаблони.</p></div>
<div class="sect2">
<h3 id="_____10">Шаблони в присвоєнні змінних</h3>
<div class="paragraph"><p>Кожного разу, коли ви визначаєте <code>val</code> або <code>var</code>, ви можете використовувати шаблон замість простого ідентифікатора. Наприклад, ви можете розібрати тапл на частини, та присвоїти кожній з частин свою власну змінну, як показане в Лістингу 15.17:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">myTuple</span> <span class="k">=</span> <span class="o">(</span><span class="mi">123</span><span class="o">,</span> <span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">myTuple</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">123</span><span class="o">,</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">number</span><span class="o">,</span> <span class="n">string</span><span class="o">)</span> <span class="k">=</span> <span class="n">myTuple</span>
<span class="n">number</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">123</span>
<span class="n">string</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abc</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.17 - Визначення декількох змінних одним присвоєнням.</p></div>
<div class="paragraph"><p>Ця конструкція досить корисна, коли робите з кейс класами. Якщо ви точно знаєте кейс клас, з яким ви працюєте, тоді ви можете деконструювати його в шаблоні. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">exp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">5</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="n">exp</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(*,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">5.0</span><span class="o">),</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=</span> <span class="n">exp</span>
<span class="n">op</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">*</span>
<span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">5.0</span><span class="o">)</span>
<span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_ase_code___">Послідовності <code>сase</code> як часткові функції</h3>
<div class="paragraph"><p>Послідовність випадків (тобто альтернативи) в фігурних дужках можуть бути використані будь-де, де може бути використаний функціональний літерал. В основному послідовність <code>case</code> є функціональним літералом. Змість мати одну точку входу та список параметрів, <code>case</code> послідовність має декілька точок входу, кожна зі своїм списком параметрів. Кожний <code>case</code> є точкою входу до функції, та параметри задаються шаблоном. Тіло кожної точки входу є правою стороною <code>case</code>.</p></div>
<div class="paragraph"><p>Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">withDefault</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тіло цієї функції має два <code>case</code> випадки. Перший <code>case</code> співпадає з <code>Some</code>, та повертає число в <code>Some</code>. Другий <code>case</code> співпадає з <code>None</code>, та повертає значення за замовчанням, нуль. Ось ця функція в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">withDefault</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">withDefault</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця можливість досить корисна для бібліотеки акторів Akka, оскільки вона дозволяє її методу <code>receive</code> бути визначеним як послідовність <code>cases</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Data</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">byte</span>
  <span class="k">case</span> <span class="nc">GetChecksum</span><span class="o">(</span><span class="n">requester</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">checksum</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">requester</span> <span class="o">!</span> <span class="n">checksum</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ще одне узагальнення нічого не коштує: послідовність випадків дає вам <em>часткову функцію</em>. Якщо ви застосуєте таку функцію до значення, яке вона не підтримує, вона згенерує виключення часу виконання. Наприклад, ось часткова функція, що повертає другий елемент зі списку цілих:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви компілюєте це, компілятор буде коректно попереджати, що порівняння не є вичерпним:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;console&gt;:17: warning: match is not exhaustive!
missing combination
Nil</code></pre>
</div></div>
<div class="paragraph"><p>Ця функція буде успішною, якщо ви передасте список з трьох елементів, але ні, якщо ви передасте порожній список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">))</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="n">scala</span><span class="o">.</span><span class="nc">MatchError</span><span class="k">:</span> <span class="kt">List</span><span class="o">()</span>
      <span class="kt">at</span> <span class="kt">$anonfun$1.apply</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">17</span><span class="o">)</span>
      <span class="kt">at</span> <span class="kt">$anonfun$1.apply</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">17</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте перевірити, чи часткова функція визначена, ви повинні спочатку сказати компілятору, що ви знаєте, що робите з частковими функціями. Тип <code>List[Int] =&gt; Int</code> включають всі функції зі списків цілих до цілих, чи є вони частковими, чи ні. Тип, що включає тільки часткові функції з масива цілих до цілих, записується <code>PartialFunction[List[Int],Int]</code>. Ось знову друга функція, на цей раз написана як тип часткової функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Часткові функції мають метод <code>isDefinedAt</code>, що може бути використана для тестування, чи функція визначена на певному значенні. В цьому випадку функція визначена для кожного списку, що мають щонайменше два елементу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">))</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Типовий приклад часткової функції є функціональний літерал порівняння шаблону, як той з попереднього прикладу. Фактично, такий вираз транслюється компілятором Scala на часткову функцію, через транслювання шаблону двічі — один раз для реалізації справжньої функції, та ще раз, щоб перевірити, чи функція визначена, чи ні.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Наприклад, функціональний літерал `{ case x :: y 
</dt>
<dd>
<p>
_ &#8658; y }` буде трансльований до наступного значення часткової функції:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">isDefinedAt</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця трансляція набуває ефекту, кожного разу, коли декларований тип функціонального літералу є <code>PartialFunction</code>. Якщо декларований тип є тільки <code>Function1</code>, або він відсутній, функціональний літерал замість цього транслюється до повної функції.</p></div>
<div class="paragraph"><p>Загалом, ви повинні намагатись робити з повними функціями, коли це можливо, оскільки використання часткових функцій дозволяє помилки часу виконання, з якими компілятор не може вам допомогти. З іншого боку, часткові функції часом дійсно корисні. Ви можете бути впевнені, що необроблене значення ніколи не буде надане. Альтернативно, ви можете використовувати фреймворк, що отримує часткові функції, і, таким чином, завжди буде перевіряти <code>isDefinedAt</code> перед викликом функції. Приклад останнього є приклад <code>receive</code>, наданий вище, де аргумент є частково визначеною функцією, визначена в точності для тих повідомлень, що викликаючий бажає обробити.</p></div>
</div>
<div class="sect2">
<h3 id="___code_for_code_">Шаблони в <code>for</code> виразах</h3>
<div class="paragraph"><p>Ви також можете використовувати шаблон в <code>for</code> виразі, як показано в Лістингу 15.18. Цей <code>for</code> вираз отримує пари ключ/значення мапи <code>capitals</code>. Кожна пара порівнюється з шаблоном <code>(country, city)</code>, що визначає дві змінні, <code>country</code> та <code>city</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">((</span><span class="n">country</span><span class="o">,</span> <span class="n">city</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">capitals</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;The capital of &quot;</span> <span class="o">+</span> <span class="n">country</span> <span class="o">+</span> <span class="s">&quot; is &quot;</span> <span class="o">+</span> <span class="n">city</span><span class="o">)</span>
<span class="nc">The</span> <span class="n">capital</span> <span class="n">of</span> <span class="nc">France</span> <span class="n">is</span> <span class="nc">Paris</span>
<span class="nc">The</span> <span class="n">capital</span> <span class="n">of</span> <span class="nc">Japan</span> <span class="n">is</span> <span class="nc">Tokyo</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.18 - Вираз <code>for</code> з шаблоном таплом.</p></div>
<div class="paragraph"><p>Шаблон пари, показаний в Лістингу 15.18 був особливий, оскільки порівняння з ним ніколи не може схибити. Зрозуміло, що <code>capitals</code> видає послідовність пар, так що ви можете бути певні, що кожна згенерована пара може бути порівняна з шаблоном пари. Але так само можливо, що шаблон може не співпасти зі згенерованим значенням. Лістинг 15.19 показує приклад, де відбувається саме це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;orange&quot;</span><span class="o">))</span>
<span class="n">results</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">apple</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">orange</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">results</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span>
<span class="n">apple</span>
<span class="n">orange</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.19 - Обирання елементів списку, що співпадають з шаблоном.</p></div>
<div class="paragraph"><p>Як ви можете бачити з цього прикладу, згенеровані значення, що не співпадають з шаблоном, будуть відкинуті. Наприклад, другий елемент <code>None</code> є результатом списку, що не співпадає з шаблоном <code>Some(fruit)</code>; таким чином, він не показаний на виході.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_8__">15.8 Більший приклад</h2>
<div class="sectionbody">
<div class="paragraph"><p>Після навчання різним формам шаблонів, ви можете бути зацікавлені побачити їх застосування в більшому прикладі. Запропоноване завдання є написати клас форматування виразів, що відображує арифметичні вирази в двомірному розташуванні. Ділення, такі як <code>x / (x + 1)</code> має друкуватись вертикально, через розташування чисельника зверху займенника, ось так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>   x
 -----
 x + 1</code></pre>
</div></div>
<div class="paragraph"><p>Як інший приклад, ось приклад <code>((a / (b * c) + 1 / n) / 3)</code> в двовимірному розташуванні:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>   a     1
 ----- + -
 b * c   n
 ---------
     3</code></pre>
</div></div>
<div class="paragraph"><p>З ціх прикладів виглядає, що клас (назвемо його <code>ExprFormatter</code>) буде мати справу з жонглюванням розміткою, так що має сенс використовувати бібліотеку розташування, розроблену в Главі 10. Ми також будемо використовувати сімейство кейс класів <code>Expr</code>, який ми бачили раніше в цій главі, та покладемо обоє, бібліотеку розташування з Глави 10 та форматування виразів з цієї глави в іменовані пакунки. Повний код приклада буде показаний в Лістингу 15.20 та 15.21.</p></div>
<div class="paragraph"><p>Корисний перший крок є концентрація на горизонтальному розташуванні. Стуруктурований вираз, як:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>BinOp("+",
  BinOp("*",
    BinOp("+", Var("x"), Var("y")),
      Var("z")),
  Number(1))</code></pre>
</div></div>
<div class="paragraph"><p>має друкувати <code>(x + y) * z + 1</code>. Зауважте, що дужки необхідні навколо <code>x + y</code>, але можуть бути опціональними навколо <code>(x + y) * z</code>. Щоб утримувати розташування як можливо стислішим, вашею ціллю має бути уникати дужок, коли вони надлишкові, при цьому переконавшись, що всі потрібні дужки присутні.</p></div>
<div class="paragraph"><p>Щоб знати, де треба поставити дужки, код має знати щодо відносних преоритетов кожного оператора, так що є гарною ідеєю спочатку поладнати це. Ви можете виразити відносні преоритети напряму, як літеральна мапа наступної форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Map</span><span class="o">(</span>
  <span class="s">&quot;|&quot;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;||&quot;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="s">&quot;&amp;&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;&amp;&amp;&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="o">...</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак це може включати деяку кількість обчислень преоритетов з вашого боку. Більш зручний підхід є просте визначення груп операторів зі збільшенням преоритетів, та потім обчислювати преоритети кожного оператора на цій основі. Лістинг 15.20 показує код.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.expr</span>
<span class="k">import</span> <span class="nn">org.stairwaybook.layout.Element.elem</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>

<span class="k">class</span> <span class="nc">ExprFormatter</span> <span class="o">{</span>
<span class="c1">// Містить оператори в групах за збільшенням преоритету</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">opGroups</span> <span class="k">=</span>
    <span class="nc">Array</span><span class="o">(</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;|&quot;</span><span class="o">,</span> <span class="s">&quot;||&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;&amp;&quot;</span><span class="o">,</span> <span class="s">&quot;&amp;&amp;&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;^&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;==&quot;</span><span class="o">,</span> <span class="s">&quot;!=&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;&lt;&quot;</span><span class="o">,</span> <span class="s">&quot;&lt;=&quot;</span><span class="o">,</span> <span class="s">&quot;&gt;&quot;</span><span class="o">,</span> <span class="s">&quot;&gt;=&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="s">&quot;-&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="s">&quot;%&quot;</span><span class="o">)</span>
    <span class="o">)</span>
<span class="c1">// Відзеркалення операторів на їх преоритети</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">precedence</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">assocs</span> <span class="k">=</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">opGroups</span><span class="o">.</span><span class="n">length</span>
        <span class="n">op</span> <span class="k">&lt;-</span> <span class="n">opGroups</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">op</span> <span class="o">-&gt;</span> <span class="n">i</span>
    <span class="n">assocs</span><span class="o">.</span><span class="n">toMap</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">unaryPrecedence</span> <span class="k">=</span> <span class="n">opGroups</span><span class="o">.</span><span class="n">length</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">fractionPrecedence</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">// продовження в Лістингу 15.21...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.20 - Верхня частина форматувальника виразів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// ...продовження Лістингу 15.20</span>
<span class="k">import</span> <span class="nn">org.stairwaybook.layout.Element</span>

<span class="k">private</span> <span class="k">def</span> <span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">enclPrec</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">elem</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">def</span> <span class="n">stripDot</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="n">endsWith</span> <span class="s">&quot;.0&quot;</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">s</span>
      <span class="n">elem</span><span class="o">(</span><span class="n">stripDot</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>

    <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">elem</span><span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="n">beside</span> <span class="n">format</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">unaryPrecedence</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">top</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">bot</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">,</span> <span class="n">top</span><span class="o">.</span><span class="n">width</span> <span class="n">max</span> <span class="n">bot</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">frac</span> <span class="k">=</span> <span class="n">top</span> <span class="n">above</span> <span class="n">line</span> <span class="n">above</span> <span class="n">bot</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">!=</span> <span class="n">fractionPrecedence</span><span class="o">)</span> <span class="n">frac</span>
      <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">frac</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">opPrec</span> <span class="k">=</span> <span class="n">precedence</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">opPrec</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">opPrec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">oper</span> <span class="k">=</span> <span class="n">l</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">r</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">&lt;=</span> <span class="n">opPrec</span><span class="o">)</span> <span class="n">oper</span>
      <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;(&quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">oper</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;)&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.21 - Нижня частина форматувальника виразів.</p></div>
<div class="paragraph"><p>Змінна <code>precedence</code> є мапою від операторів на їх преоритети, що є цілими, починаючи з 0. Вони обчислюються в виразі <code>for</code> з двома генераторами. Перший генератор продукує кожний індекс <code>i</code> для масиву <code>opGroups</code>. Другий генератор продукує кожний оператор <code>op</code> в <code>opGroups(i)</code>. Для кожного такого оператора вираз <code>for`видає асоціацію від оператора `op</code> на його індекс <code>i</code>. Таким чином, відносна позиція оператора в масиві береться як його преоритет.</p></div>
<div class="paragraph"><p>Асоціації записані як інфіксна стрілка, <code>op -&gt; i</code>. Так що ви бачите асоціації тільки як частину конструкції мапи, але вони також є значеннями сами по собі. Фактично, асоціація <code>op -&gt; i</code> є нічим іншим, ніж парою <code>(op, i)</code>.</p></div>
<div class="paragraph"><p>Тепер, коли ви поладнали преоритети всіх двомісних операторів, крім <code>/</code>, має сенс узагальнити цю концепцію, що також покриває одномісні оператори. Преоритети одномісних операторів вищі, ніж преоритет кожного двомісного оператора. Таким чином ми можете встановити <code>unaryPrecedence</code> (показане в Лістингу 15.20) в довжину масива <code>opGroups</code>,що на один більше, ніж преоритет операторів <code>*</code> та <code>%</code>. Преоритет дробі трактується інакше від інших операторів, оскількі дріб використовує вертикальне розташування. Однак, це буде зручним, присвоїти оператору ділення особливий преоритет зі значенням -1, так що ми будемо ініціалізувати <code>fractionPrecedence</code> в -1 (показане в Лістингу 15.20).</p></div>
<div class="paragraph"><p>Після ціх підготувань ви готові написати головний метод форматування. Цей метод приймає два аргумента: вираз <code>e</code>, типу <code>Expr</code>, та преоритет <code>enclPrec</code> оператора напряму оточуючого виразу <code>e</code>. (Якщо нема оточуючого оператора, <code>enclPrec</code> повинне бути нулем). Метод видає елемент розташування, що представляє двомірний масив символів.</p></div>
<div class="paragraph"><p>Лістинг 15.21 показує залишок класу <code>ExprFormatter</code>, що включає три метода. Перший метод, <code>stripDot</code>, є допоміжним методом. Наступний метод, приватний метод <code>format</code>, робить більшість роботи по форматуванню виразів. Останній метод, також названий <code>format</code>, є єдиним публічним методом в бібліотеці, що приймає вираз, який треба форматувати. Приватний метод <code>format</code> робить свою роботу, виконуючи порівняння шаблонів на різновиді виразу. Вираз <code>match</code> має п'ять випадків <code>case</code>. Ми обговоримо кожний <code>case</code> окремо.</p></div>
<div class="paragraph"><p>Перший case є:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є змінна, результат є елементом, сформованим з імені змінної.</p></div>
<div class="paragraph"><p>Другмй вираз є:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">stripDot</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="n">endsWith</span> <span class="s">&quot;.0&quot;</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
    <span class="k">else</span> <span class="n">s</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">stripDot</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є числом, результат є елементом, сформованим зі значення числа. Функція <code>stripDot</code> очищує вигляд чисел з плаваючою крапкою, відкидаючи любі суфікси <code>".0"</code> з рядка.</p></div>
<div class="paragraph"><p>Третій випадок наступний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="n">beside</span> <span class="n">format</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">unaryPrecedence</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є одномісною операцією <code>UnOp(op, arg)</code>, результатом буде сформований з операнда <code>op</code> та результата форматування аргумента <code>arg</code> з найвищим-можливим преоритетом оточення.<span class="footnote"><br />[Значення <code>unaryPrecedence</code> є найвищим можливим преоритетом, оскільки він ініціалізований на один більше, ніж преоритет операторів <code>*</code> та <code>%</code>.]<br /></span></p></div>
<div class="paragraph"><p>Це означає, що якщо <code>arg</code> є двомісною операцією (але не дрібом), вона завжди буде відображатись в дужках.</p></div>
<div class="paragraph"><p>Четвертий випадок <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">top</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">bot</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">,</span> <span class="n">top</span><span class="o">.</span><span class="n">width</span> <span class="n">max</span> <span class="n">bot</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">frac</span> <span class="k">=</span> <span class="n">top</span> <span class="n">above</span> <span class="n">line</span> <span class="n">above</span> <span class="n">bot</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">!=</span> <span class="n">fractionPrecedence</span><span class="o">)</span> <span class="n">frac</span>
  <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">frac</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є дробом, проміжний результат <code>frac</code> формується через розміщення форматованих операндів <code>left</code> та <code>right</code> зверху один одного, розділені елементом горизонтальної лінії. Ширина <code>width</code> горизонтальної лінії є максимум з ширин форматованих операндів. Цей проміжний результат є також фінальним результатом, тільки якщо дріб сам не з'являється як аргумент в іншій дробі. В останньому випадку з кожного боку <code>frac</code> додаються проміжки. Щоб зрозуміти чому, розглянемо вираз <code>(a / b) / c</code>.</p></div>
<div class="paragraph"><p>Без корекції ширини форматування цього виразу буде давати:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> a
 -
 b
 -
 c</code></pre>
</div></div>
<div class="paragraph"><p>Пробелма з таким форматуванням є доказ — незрозуміло, де є риска вищого рівня. Вираз вище може означати або <code>(a / b) / c</code>, або <code>a / (b / c)</code>. Щоб вирішити неоднозначність, треба додати проміжки до кожної сторони розташування вкладеного дробу <code>a / b</code>. Тоді розташування стає однозначним:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  a
  -
  b
 ---
  c</code></pre>
</div></div>
<div class="paragraph"><p>П'ятий, та останній, <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">opPrec</span> <span class="k">=</span> <span class="n">precedence</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">opPrec</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">opPrec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">oper</span> <span class="k">=</span> <span class="n">l</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">r</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">&lt;=</span> <span class="n">opPrec</span><span class="o">)</span> <span class="n">oper</span>
  <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;(&quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">oper</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;)&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей випадок стосується всіх інших двомісних операндів. Оскільки він іде після випадку, що починається як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>ви знаєте, що оператор <code>op</code> в шаблоні <code>BinOp(op, left, right)</code> не може бути діленням. Щоб форматувати таку двомісну операцію, вам знадобиться спочатку форматувати її операнди <code>left</code> та <code>right</code>. Параметр преоритету для форматування лівого операнда є преоритет <code>opPrec</code> оператора <code>op</code>, тоді як для правого операнда він на один більше. Така схема гарантує, що дужки також відображають коректну асоциативність.</p></div>
<div class="paragraph"><p>Наприклад, операція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">),</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>буде коректно оточена дужками, як "a - (b - c)". Проміжний результат <code>oper</code> потім формується через розміщення форматованих операндів <code>left</code> та <code>right</code> поряд, розділених оператором. Якщо преоритет поточного оператора менше, ніж преоритет оточуючого оператора, <code>oper</code> покладається між дужками; інакше він повертається як є.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.stairwaybook.expr._</span>

<span class="k">object</span> <span class="nc">Express</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ExprFormatter</span>

  <span class="k">val</span> <span class="n">e1</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span>
                      <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>

  <span class="k">val</span> <span class="n">e2</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span>
                      <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.5</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)))</span>

  <span class="k">val</span> <span class="n">e3</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="o">)+</span> <span class="s">&quot;\n\n&quot;</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">e</span> <span class="k">&lt;-</span> <span class="nc">Array</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="n">e3</span><span class="o">))</span> <span class="n">show</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.22 - Застосування, що друкує форматовані вирази.</p></div>
<div class="paragraph"><p>Це завершує розробку приватної функції <code>format</code>. Єдиний залишений метод є публічний метод <code>format</code>, що дозволяє програмістам клієнтів форматувати високорівневі вирази, не передаючи аргумент преоритетів. Лістинг 15.22 показує демо програму, що випробовує <code>ExprFormatter</code>.</p></div>
<div class="paragraph"><p>Зауважте, що навіть хоча ця програма не містить метод, вона все ще виконується, оскільки вона наслідує від трейту App. Ви можете виконувати програму <code>Express</code> такою командою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span> <span class="nc">Express</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде тавати наступний вивід:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> 1
 - * (x + 1)
 2

 x   1.5
 - + ---
 2    x

  1
  - * (x + 1)
  2
 -----------
   x   1.5
   - + ---
   2    x</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_9_">15.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви детально навчились щодо кейс класів та порівняння шаблонів. Використовуючи це, ви можете отримати переваги від декількох стислих ідіом, звичайно недоступних в об'єктно-орієнтовних мовах. Однак порівняння шаблонів в Scala іде далі, ніж описане в цій главі. Якщо ви бажаєте використати порівняння шаблонів на одному з ваших класів, але ви не бажаєте відкривати доступ до ваших класів в спосіб, як це роблять кейс класи, ви можете використовувати екстрактори, описані в Главі 26. В наступній главі ми звернемо нашу увагу на списки.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__16">Глава 16</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____16">Робота зі списками</h1>
<div class="paragraph"><p>Списки, можливо, є найбільш загально уживана структура даних в Scala програмах. Ця глава пояснює списки в деталях. Ми будемо презентувати багато загальних операцій, що можуть бути виконані на списках. Ми будемо також покривати деякі важливі принципи дизайну для програм, що роблять зі списками.</p></div>
<div class="sect1">
<h2 id="_16_1__">16.1 Спискові літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви вже бачили списки в попередніх главах, так що ви знаєте, що список містить елементи  <code>'a'</code>, <code>'b'</code>, та <code>'c'</code> записується як <code>List('a', 'b', 'c')</code>. Ось деякі інші приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;pears&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">diag3</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">)</span>
<span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Списки досить подібні до масивів, але є дві важливі відмінності. Перше, списки є незмінними, елементи списку не можуть бути змінені через присвоєння. Друге, списки мають рекурсивну структуру (тобто,  <em>зв'язаний список</em>),<span class="footnote"><br />[Для графічного представлення структури <code>List</code>, дивіться Малюнок 22.2.]<br /></span>, тоді як масиви пласкі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_2__list">16.2 Тип List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як і масиви, списки є гомогенними: елементи списків всі мають той самий тип. Тип списку, що мають елементи типу <code>T</code>, записується <code>List[T]</code>. Наприклад, ось ті самі чотири списки з доданими явними списками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">fruit</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;pears&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">diag3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">)</span>
<span class="k">val</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип списку в Scala є ковариантним. Це означає, що для кожної пари типів <code>S</code> та <code>T</code>, якщо <code>S</code> є субтипом <code>T</code>, тоді <code>List[S]</code> є субтипом <code>List[T]</code>. Наприклад, <code>List[String]</code> є субтипом <code>List[Object]</code>. Це природно, оскільки кожний список рядків може також розглядатись і як список об'єктів.<span class="footnote"><br />[Глава 19 дає більше деталей щодо коваріантності та інших типів варіантності.]<br /></span></p></div>
<div class="paragraph"><p>Зауважте, що порожній список має тип <code>List[Nothing]</code>. Ви бачили в Розділі 11.3, що <code>Nothing</code> є нижнім типом в ієрархії класів Scala. Це субтип кожного іншого типу Scala. Оскільки списки коваріантні, з цього слідує, що <code>List[Nothing]</code> є субтипом <code>List[T]</code> для любого типу <code>T</code>. Так що об'єкт порожнього списку, що має тип <code>List[Nothing]</code>, може також розглядатись як об'єкт кожного іншого типу списка в формі <code>List[T]</code>. Ось чому дозволяється писати код, подібний до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// List() також є типом List[String]!</span>
<span class="k">val</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_3__">16.3 Конструювання списків</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
Всі списки побудовані з двох фундаментальних будівельних блоків, <code>Nil</code> та <code>::</code> (вимовляється <code>cons</code>). <code>Nil</code> представляє порожній список. Інфіксний оператор <code>::</code> виражає розширення списку зпереду. Тобто, `x 
</dt>
<dd>
<p>
xs` представляє список, чий перший елемент є <code>x</code>, за яким слідує (елементи) список <code>xs</code>. Так що попередній список значень також може бути визначений наступним чином:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="s">&quot;apples&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s">&quot;oranges&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s">&quot;pears&quot;</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
<span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="o">(</span><span class="mi">3</span> <span class="o">::</span> <span class="o">(</span><span class="mi">4</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span>
<span class="k">val</span> <span class="n">diag3</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span> <span class="o">::</span>
            <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span> <span class="o">::</span>
            <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="nc">Nil</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Фактично, попередні визначення <code>fruit</code>, <code>nums</code>, <code>diag3</code>, та <code>empty</code> в термінах <code>List(...)</code> є тільки огортками, що розширюють ці визначення. Наприклад, <code>List(1, 2, 3)</code> створює `list1 :: (2 :: (3 
</dt>
<dd>
<p>
Nil))`.
</p>
</dd>
<dt class="hdlist1">
Оскільки вона завершується на дві крапки, операція <code>::</code> асоціюється зправа: <code>A :: B :: C</code> інтерпретується як `A :: (B 
</dt>
<dd>
<p>
C)`. Таким чином, ви можете відкинути дужки в попередніх визначеннях. Наприклад:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="mi">4</span> <span class="o">::</span> <span class="nc">Nil</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до попереднього визначення <code>nums</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_4____">16.4 Базові операції зі списками</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі операції зі списками можуть бути визначені в термінах наступних трьох:</p></div>
<div class="paragraph"><p><code>head</code> повертає перший елемент списку</p></div>
<div class="paragraph"><p><code>tail</code> повератає список, що складається з усіх елементів списку, крім першого</p></div>
<div class="paragraph"><p><code>isEmpty</code> повертає <code>true</code>, якщо список порожній</p></div>
<div class="paragraph"><p>Ці операції визначені як методи класу <code>List</code>. Деякі приклади показані в Таблиці 16.1. Методи <code>head</code> та <code>tail</code> визначені тільки для не-порожніх списків. Коли вибираються для порожніх списків, вони закидають виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Nil</span><span class="o">.</span><span class="n">head</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">head</span> <span class="kt">of</span> <span class="kt">empty</span> <span class="kt">list</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Як приклад того, як списки можуть оброблятись, розглянемо сортування елементів списку, що є числами, в порядку зростання. Один простий спосіб зробити це - сортування вставкою, що робить наступним чином: для сортування непорожнього списку `x 
</dt>
<dd>
<p>
xs`, сортується залишок <code>xs</code>, та перший елемент <code>x</code> вставляється в правильну позицію результата. Виражене як код Scala, алгоритм сортування вставкою виглядає так:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="n">insert</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">,</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>

<span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
</pre></div></div></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 16.1 Базові операції списків</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>empty.isEmpty</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>true</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>fruit.isEmpty</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>false</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>fruit.head</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>"apples"</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>fruit.tail.head</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>"oranges"</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>diag3.head</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>List(1, 0, 0)</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_5__">16.5 Шаблони списків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Списки також можуть бути розділені на частини з використанням порівнянь шаблонів. Шаблони списків відповідають один до однго з виразами списків. Ви можете або порівняти всі елементи списку з використанням шаблону в формі <code>List(...)</code>, або ви розбиваєте список на частини, використовуючи шаблон, скомпонований з оператора <code>::</code> та константи <code>Nil</code>.</p></div>
<div class="paragraph"><p>Ось різновид першого типу шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=</span> <span class="n">fruit</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">apples</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">oranges</span>
<span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">pears</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Шаблон <code>List(a, b, c)</code> співпадає зі списками довжини 3, та прив'язує три елементи до змінних шаблону, <code>a</code>, <code>b</code>, та <code>c</code>. Якщо ви не знаєте число елементів в списку заздалегідь, тоді краще замість цього порівнювати за допомогою <code>::</code>. Наприклад, шаблон `a :: b 
</dt>
<dd>
<p>
rest` співпадає зі списками довжини 2 або більше:
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_____11">Щодо порівняння шаблонів списків</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
Якщо ви розглядаєте можливі форми шаблонів, пояснених в Главі 15, ви можете винайти, що ні <code>List(...)</code> ані <code>::</code> не вигладають, як підходящі різновиди шаблонів, визначених там. Фактично, <code>List(...)</code> є примірником визначеного в бібліотеці шаблону екстрактора. Такі шаблони будуть обговорюватись в Главі 26. Шаблон <code>cons</code> <code>x :: xs</code> є особливим випадком шаблону інфіксної операції. Як вираз, інфіксна операція еквівалентна до виклику метода. Для шаблонів правила інші: в якості шаблона інфіксна операція, така, як <code>p op q</code> еквівалентна до <code>op(p, q)</code>. Тобто, інфіксний оператор <code>op</code> трактується як шаблон конструктора. Зокрема, шаблон <code>cons</code>, такий як `x 
</dt>
<dd>
<p>
xs`, трактується як <code>::(x, xs)</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Це підказує, що має бути клас на ім'я <code>::</code>, що відповідає до конструктора шаблону. Звісно, такий клас існує — його ім'я <code>scala.::</code>, та це саме той клас, що будує непорожні списки. Так що <code>::</code> існує двічі в Scala, один раз як ім'я, класу в пакунку <code>scala</code>, і знову як метод в класі <code>List</code>. Ефект метода <code>::</code> є продукувати примірник класу <code>scala.::</code>. Ви знайдете більше деталей щодо того, як реалізований клас <code>List</code>, в Главі 22.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=</span> <span class="n">fruit</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">apples</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">oranges</span>
<span class="n">rest</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">pears</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Розбиття списків на частити за допомогою шаблонів є альтернативою до їх поділення за допомогою базових методів <code>head</code>, <code>tail</code>, та <code>isEmpty</code>. Наприклад, ось знову сортування вставкою, на цей раз написана за допомогою порівняння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs1</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
                  <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Часто порівняння шаблонів зі списками ясніше, ніж їх декомпозиція за допомогою методів, так що порівняння шаблонів має стати частиною вашого інструментарія обробки списків.</p></div>
<div class="paragraph"><p>Це все що вам треба знати щодо списків в Scala, щоб використовувати їх коректно. Однак існує велика кількість методів, що захоплюють загальні шаблони операцій зі списками. Ці методи роблять програми обробки списків більш стислими, та часто яснішими. Наступні два розділи представляють найбільш важливі методи, визначені в класі <code>List</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_6______list">16.6 Методи першого порядка на класі List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цей розділ пояснює більшість методів першого порядка, визначених в класі <code>List</code>. Метод є першого порядку, якщо він не приймає жодних функцій як аргументів. Ми будемо також вводити деякі рекомендовані прийоми, щоб структурувати програми, що оперують на списках, використовуючи для цього два приклада.</p></div>
<div class="sect2">
<h3 id="____17">Конкатенація двох списків</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Операція, подібна до <code>::</code> є конкатенація списків, що записується як <code>:::</code>. На відміну від <code>::</code>, <code>:::</code> приймає два списка як операнди. Результатом `xs 
</dt>
<dd>
<p>
ys` є новий список, що містить всі елементи <code>xs</code>,за яким слідують всі елементи <code>ys</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">()</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і <code>cons</code>, конкатенація списків асоціюється зправа. Такий вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">:::</span> <span class="n">ys</span> <span class="o">:::</span> <span class="n">zs</span>
</pre></div></div></div>
<div class="paragraph"><p>інтерпретується так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">:::</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:::</span> <span class="n">zs</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____12">Принцип "Розділяй та володій"</h3>
<div class="paragraph"><p>Конкатенація (<code>:::</code>) реалізована як метод в класі <code>List</code>. Також можливо реалізувати конкатенацію "вручну", використовуючи порівняння шаблонів для списків. Є повчальним спробувати зробити це самостійно, оскільки це показує загальний шлях реалізації алгоритмів з використанням списків. Перше, ми домовимось щодо сигнатури для метода конкатенації, який ми назвемо <code>append</code>. Щоб не дуже змішувати все докупи, будемо вважати, що <code>append</code> визначений за межами класу <code>List</code>, так що він прийматиме два списки, що будуть канкатеновані, як параметри. Ці два списки мають домовитись щодо типу їх елементів, але цей тип може бути довільним. Це може бути виражене через надання <code>append</code> параметру типа,<span class="footnote"><br />[Параметр типу буде пояснений більш детально в Главі 19.]<br /></span>, що представляє тип елемента двох вхідних списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб розробити реалізацію <code>append</code>, слід пам'ятати принцип розробки "поділяй та володій" для програм з рекурсивними структурами даних, як списки. Багато алгоритмів над списками спочатку розділяють вхідний список на простіші випадки, використовуючи порівняння шаблонів. Це частина <em>роздліляй</em> цього принципу. Потім вони конструюють результат для кожного <code>case</code>. Якщо результат є непорожній список, деякі з його частин можуть бути сконструйовані через рекурсивні виклики того самого алгоритму. Це частина <em>володій</em> принципу.</p></div>
<div class="paragraph"><p>Щоб застосувати цей принцип до реалізації метода <code>append</code>, перше запитання, що треба запитати, це який зі списків порівнювати. Це трохи тривіальніше в випадку <code>append</code>, ніж для багатьох інших методів, оскікльи є два вибори. Однак, наступна фаза "володіння" каже вам, що вам треба сконструювати список, що складається з усіх елементів обох вхідних списків. Оскільки списки сконструйовані з кінця в напрямку початку, <code>ys</code> може залишатись як є, тоді як <code>xs</code> буде треба розбити на частини на поставити перед <code>ys</code>. Таким чином, має сенс сконцентруватись на <code>xs</code>, як джерелі для порівняння шаблонів. Найбільш загальне порівняння шаблонів зі списками є просте розрізнення порожніх та непорожніх списків. Так що це дає наступний контур метода <code>append</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="o">???</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="o">???</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що залишається, це заповнити два місця, відмічені <code>???</code>.<span class="footnote"><br />[Метод <code>???</code>, що закидає <code>scala.NotImplementedError</code>, та має тип результата <code>Nothing</code>, може бути використаний як тимчасова реалізація впродовж розробки.]<br /></span> Перше таке місце є альтернатива, де вхідний список <code>xs</code> порожній. В цьому випадку конкатенація видає другий список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Друге місце, залишене відкритим, є альтернатива, де вхідний список <code>xs</code> складається з деякого заголовка <code>x</code>, за яким слідує хвіст <code>xs1</code>. В цьому випадку результат також є непорожнім списком. Щоб сконструювати непорожній список, вам треба знати, якими має бути голова та хвіст цього списку. Ви знаєте, що перший елемент результуючого списку є <code>x</code>. Як щодо залишку елементів, вони можуть бути обчислені через додавання другого списку, <code>ys</code>, до залишку першого списку, <code>xs1</code>.</p></div>
<div class="paragraph"><p>Це завершує дизайн, та дає таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">append</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Обчислення другої альтернативи ілюструє частину "володій" принципа розділення та заволодіння: думайте спочатку, який контур бажаного виходу має бути, потім обчислюйте індивідуальні частини цього контура, використовуючи рекурсивні виклики алгоритма, коли це доцільно. Нарешті, сконструюйте вихід з ціх частин.</p></div>
</div>
<div class="sect2">
<h3 id="____code_length_code">Отримання довжини списку: <code>length</code></h3>
<div class="paragraph"><p>Метод <code>length</code> обчислює довжину списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">length</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>На списках, на відміну від масивів, <code>length</code> є відносно коштовною операцією. Він змушує подорожувати по цілому списку, щоб знайти кінець, і, таким чином, займає час, пропорційний до числу елементів в списку. Ось чому не є гарною ідеєю замінити тест, такий як <code>xs.isEmpty</code> на <code>xs.length == 0</code>. Результат двох тестів еквівалентний, але другий повільніший, зокрема якщо список <code>xs</code> довгий.</p></div>
</div>
<div class="sect2">
<h3 id="_____code_init_code__code_last_code">Доступ до кінця списку: <code>init</code> та <code>last</code></h3>
<div class="paragraph"><p>Ви вже знаєте базові операції, <code>head</code> та <code>tail</code>, що, відповідно, вибирає перший елемент списку, та залишок списку, крім першого елементу. Вони обоє мають операцію двійника: <code>last</code> повертає останній елемент (непорожнього) списку, тоді як <code>init</code> повертає список, що складається з усіх елементів, крім останнього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">abcde</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="sc">&#39;c&#39;</span><span class="o">,</span> <span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="sc">&#39;e&#39;</span><span class="o">)</span>
<span class="n">abcde</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">last</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">init</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як <code>head</code> та <code>tail</code>, ці методи закидають виключення, коли застосовуються до порожніх списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">().</span><span class="n">init</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">UnsupportedOperationException</span><span class="k">:</span> <span class="kt">Nil.init</span>
<span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="nc">List</span><span class="o">.</span><span class="n">init</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">544</span><span class="o">)</span>
<span class="n">at</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">().</span><span class="n">last</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">Nil.last</span>
<span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="nc">List</span><span class="o">.</span><span class="n">last</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">563</span><span class="o">)</span><span class="n">at</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>На відміну від <code>head</code> та <code>tail</code>, які обоє виконуються за сталий час, <code>init</code> та <code>last</code> подорожують по цілому списку, щоб отримати свій результат. Як результат, вони займають час, пропорційний до довжини списку.</p></div>
<div class="paragraph"><p>Є гарною ідеєю організувати ваші дані так, щоб більшість доступів приходились на початок списку, скоріше, ніж на останній елемент.</p></div>
</div>
<div class="sect2">
<h3 id="___code_reverse_code">Реверс списку: <code>reverse</code></h3>
<div class="paragraph"><p>Якщо в деякій точці обчислень алгоритм вимагає частого доступу до кінця списку, іноді буває кращим спочатку реверсувати список, та потім робити з результатом. Ось як це робиться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як всі інші операції зі списками, <code>reverse</code> створює новий список, скоріше ніж змінювати той, з яким робить. Оскільки списки незмінні, така заміна все одно не була б можливою. Щоб перевірити це, перевірте, що оригінальне значення <code>abcde</code> незмінне після операції <code>reverse</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Операції <code>reverse</code>, <code>init</code> та <code>last</code> задовільняють деяким законам, що може бути використане для міркувань щодо обчислень та для спрощення програм.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>reverse</code> є інверсією самого себе:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">reverse</span> <span class="nc">_equals_</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>reverse</code> перетворює <code>init</code> на <code>tail</code>, та <code>last</code> на <code>head</code>, за винятком того, що елементи реверсовані:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">init</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">tail</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">head</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">last</span>
<span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">last</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span>
</pre></div></div></div>
<div class="paragraph"><p>Реверс може бути реалізований з використанням конкатенації (<code>:::</code>), як наступний метод, <code>rev</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">rev</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">xs</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">rev</span><span class="o">(</span><span class="n">xs1</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Однак, цей метод менш ефективний, ніж дехто може сподіватись. Щоб вивчити складність <code>rev</code>, вважаючи, що список <code>xs</code> має довжину <code>n</code>. Зауважте, що існує <code>n</code> рекурсивних викликів до <code>rev</code>. Кожний виклик, крім останнього, включає конкатенацію списків. Конкатенація списків, `xs 
</dt>
<dd>
<p>
ys`, займає час, пропорційний до довжини свого першого аргументу, <code>xs</code>. Таким чином, загальна складність <code>rev</code> є:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">+</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Іншими словами, складність <code>rev</code> є квадратичною до довжини свого вхідного аргументу. Це невтішно, порівнюючи до реверсу змінного зв'язанного списку, що має лінійну складність. Однак поточна реалізація <code>rev</code> не є кращою можливою реалізацією. В прикладі, що починається тут, ви побачите, як прискорити її.</p></div>
</div>
<div class="sect2">
<h3 id="____code_drop_code_code_take_code_code_splitat_code">Префікси та суфікси: <code>drop</code>, <code>take</code>, <code>splitAt</code></h3>
<div class="paragraph"><p>Операції <code>drop</code> та <code>take</code> узагальнують <code>tail</code> та <code>init</code> в тому, що вони повертають довільні префікси або суфікси списку. Вираз <code>xs take n</code> повертає перші <code>n</code> елементів списку <code>xs</code>. Якщо <code>n</code> більше, ніж <code>xs.length</code>, повертається цілий список <code>xs</code>. Операція <code>xs drop n</code> повертає всі елементи списку <code>xs</code>, за винятком перших <code>n</code>. Якщо <code>n</code> більше, ніж <code>xs.length</code>, повертається порожній список.</p></div>
<div class="paragraph"><p>Операція <code>splitAt</code> розділяє список по наданому індексу, повертаючи пару з двох списків.<span class="footnote"><br />[Як зазначалось в Розділі 10.12, термін пара є неформальним ім'ям для <code>Tuple2</code>.]<br /></span> Вона визначається рівністю:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">take</span> <span class="n">n</span><span class="o">,</span> <span class="n">xs</span> <span class="n">drop</span> <span class="n">n</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак <code>splitAt</code> уникає подвійної подорожі по списку <code>xs</code>. Ось деякі приклади ціх трьох методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">take</span> <span class="mi">2</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">drop</span> <span class="mi">2</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">splitAt</span> <span class="mi">2</span>
<span class="n">res10</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span><span class="nc">List</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_apply_code__code_indices_code">Вибір елементів: <code>apply</code> та <code>indices</code></h3>
<div class="paragraph"><p>Вибір довільних елементів підтримується через метод <code>apply</code>; однак це менш поширена операція для списків, ніж для масивів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">apply</span> <span class="mi">2</span> <span class="c1">// рідкість в Scala</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і для інших типів, <code>apply</code> вставляється неявно, коли об'єкт з'являється в функціональній позиції в виклику метода. Так що рядок вище може бути скорочено:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// рідкість в Scala</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з причин, чому вибір довільного елемента є менш популярним для списків, ніж для масивів, в тому, що <code>xs(n)</code> займає час, пропорційний до індексу <code>n</code>. Фактично, <code>apply</code> просто визначена через комбінацію <code>drop</code> та <code>head</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">apply</span> <span class="n">n</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">drop</span> <span class="n">n</span><span class="o">).</span><span class="n">head</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення також робить зрозумілим, що індекси списків знаходяться в диапазоні від 0 до довжини списку мінус один, так само, як для масивів. Метод <code>indices</code> повертає список, що складається з усіх валідних індексів для даного списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">indices</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span><span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_flatten_code">Зплющення списка списків: <code>flatten</code></h3>
<div class="paragraph"><p>Метод <code>flatten</code> приймає список списків, та зплющує його до одного списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)).</span><span class="n">flatten</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toCharArray</span><span class="o">).</span><span class="n">flatten</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
<span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Він може бути застосований тільки до списків, всі елементи яких є списками. Спроба зплющити любі інші списки буде давати помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">flatten</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">implicit</span> <span class="kt">view</span> <span class="kt">available</span> <span class="kt">from</span> <span class="kt">Int</span> <span class="o">=&gt;</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">GenTraversableOnce</span><span class="o">[</span><span class="kt">B</span><span class="o">].</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">flatten</span>
<span class="o">^</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_zip_code__code_unzip_code">Стиснення списків: <code>zip</code> та <code>unzip</code></h3>
<div class="paragraph"><p>Операція <code>zip</code> приймає два списки, та формує список пар:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">indices</span> <span class="n">zip</span> <span class="n">abcde</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">scala.collection.immutable.IndexedSeq</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Char</span><span class="o">)]</span> <span class="k">=</span>
    <span class="nc">Vector</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span><span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">b</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">c</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="n">d</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо два списки мають різні довжини, любий неспівпавший елемент відкидається:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zipped</span> <span class="k">=</span> <span class="n">abcde</span> <span class="n">zip</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">zipped</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Char</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="n">a</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Корисний особливий випадок є <code>zip</code> списку з його індексом. Це робиться більш ефективно за допомогою метода <code>zipWithIndex</code>, що парує кожний елемент списку з позицією, де він з'являється в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">zipWithIndex</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Char</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="n">a</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">d</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span>
    <span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Любий список таплів також може бути змінений назад, та таплу списків, використовуючи метод <code>unzip</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">zipped</span><span class="o">.</span><span class="n">unzip</span>
<span class="n">res19</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
  <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">),</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи <code>zip</code> та <code>unzip</code> провадять один шлях для обробки декількох списків разом. Дивіться Розділ 16.9 для більш стислого шляху робити це.</p></div>
</div>
<div class="sect2">
<h3 id="___code_tostring_code__code_mkstring_code">Відображення списків: <code>toString</code> та <code>mkString</code></h3>
<div class="paragraph"><p>Операція <code>toString</code> повертає канонічну рядкову репрезентацію списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">toString</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте іншу репрезентацію, ви можете використати метод <code>mkString</code>. Операція <code>xs mkString (pre, sep, post)</code> включає чотири операнди: список <code>xs</code>, що буде відображений, рядок <code>prefix</code>, що буде відображений перед усіма елементами, рядок роздільника <code>sep</code>, що буде відображений між послідовними елементами, та рядок <code>postfix</code>, що буде відображений в кінці.</p></div>
<div class="paragraph"><p>Результатом операції є рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pre</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="o">...+</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">post</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>mkString</code> має два перевантажені варіанти, що дозволяють вам відкинути деякі або всі його пргументи. Перший вариант приймає тільки рядок роздільника:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">mkString</span> <span class="n">sep</span> <span class="nc">_equals_</span> <span class="n">xs</span> <span class="n">mkString</span> <span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">sep</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Другий варіант дозволяє вам оминути всі аргументи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">mkString</span> <span class="nc">_equals_</span> <span class="n">xs</span> <span class="n">mkString</span> <span class="s">&quot;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">mkString</span> <span class="o">(</span><span class="s">&quot;[&quot;</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">,</span> <span class="s">&quot;]&quot;</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">[</span><span class="kt">a</span>,<span class="kt">b</span>,<span class="kt">c</span>,<span class="kt">d</span>,<span class="kt">e</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">mkString</span> <span class="s">&quot;&quot;</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcde</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">mkString</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcde</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">mkString</span> <span class="o">(</span><span class="s">&quot;List(&quot;</span><span class="o">,</span> <span class="s">&quot;, &quot;</span><span class="o">,</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є варіанти методів <code>mkString</code>, названі <code>addString</code>, що додають сконструйований рядок до об'єкту <code>StringBuilder</code>,<span class="footnote"><br />[Це клас <code>scala.StringBuilder</code>, не <code>java.lang.StringBuilder</code>.]<br /></span>, скоріше ніж повертати результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">addString</span> <span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="s">&quot;(&quot;</span><span class="o">,</span> <span class="s">&quot;;&quot;</span><span class="o">,</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">;</span><span class="n">b</span><span class="o">;</span><span class="n">c</span><span class="o">;</span><span class="n">d</span><span class="o">;</span><span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи <code>mkString</code> та <code>addString</code> наслідуються від супертрейта <code>List</code>, трейта <code>Traversable</code>, так що вони також застосовуються до всіх інших колекцій.</p></div>
</div>
<div class="sect2">
<h3 id="___code_iterator_code_code_toarray_code_code_copytoarray_code">Перетворення списків: <code>iterator</code>, <code>toArray</code>, <code>copyToArray</code></h3>
<div class="paragraph"><p>Щоб перетворити дані між пласким світом масиву, та рекурсивним світом списків, ви можете використовувати метод <code>toArray</code> в класі <code>List</code>, та <code>toList</code> в класі <code>Array</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="n">abcde</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є метод <code>copyToArray</code>, що копіює список елементів в послідовні позиції в деякому масиві призначення. Операція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">copyToArray</span> <span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>копіює всі елементи списку <code>xs</code> до масива <code>arr</code>, починаючи з позиції <code>start</code>. Ви маєте переконатись, що масив призначення <code>arr</code> досить довгий, щоб містити список повністю. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">10</span><span class="o">)</span>
<span class="n">arr2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">copyToArray</span> <span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr2</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, якщо вам треба отримати доступ до елементів списку через ітератор, ви можете використовувати метод <code>iterator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">abcde</span><span class="o">.</span><span class="n">iterator</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">b</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____18">Приклад: сортування злиттям</h3>
<div class="paragraph"><p>Сортування вставкою, презентоване раніше, є стислим для написання, але не дуже ефективним. Його середня складність пропорційна квадрату довжини вхідного списку. Більш ефективний алгоритм є сортування злиттям.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___29">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цей приклад провадить іншу ілюстрацію принципу розділяй та володій, карування, а також корисну дискусію по алгоритмічній складності. Якщо ви бажаєте рухатись трохи швидше при першому проходженні цієї книги, ви можете безпечно пропустити Розділ 16.7.</p></div>
<div class="paragraph"><p>Сортування злиттям робить наступним чином: зпершу, якщо список має нуль або один елемент, він вже впорядкований, так що список може бути повернений без змін. Інши списки поділяються на два суб-списки, кожний містить близько половини елементів оригінального списку. Кожний субсписок впорядковується рекурсивним викликом, та отримані два відсортовані списки поєднуються операцією злиття.</p></div>
<div class="paragraph"><p>Для загальної реалізації сортування злиттям ви бажаєте залишити відкритим тип елементів списку, що будуть сортуватись, та функцію, що буде використана для порівняння елементів. Ви отримаєте функцію максімальної загальності, передавши ці два елементи як параметри. Це призводить до реалізації, показаній в Лістингу 16.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">msort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">less</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
    <span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">msort</span><span class="o">(</span><span class="n">less</span><span class="o">)(</span><span class="n">ys</span><span class="o">),</span> <span class="n">msort</span><span class="o">(</span><span class="n">less</span><span class="o">)(</span><span class="n">zs</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 16.1 - Функція сортування злиттям для List.</p></div>
<div class="paragraph"><p>Складність <code>msort</code> має порядок (<em>n log(n)</em>), де <code>n</code> є довжина вхідного списку. Щоб побачити чому, зауважте, що розділення списку на два та злиття двох відсортованих списків, кожне займає час, пропорційний до довжини списків-аргументів. Кожний рекурсивний виклик зменшує навпіл число елементів на вході, так що відбудеться  близько <code>log(n)</code> послідовних рекурсивних викликів, доки буде досягнуто базового випадку зі списками довжиною 1. Однак для довших списків кожний виклик відгалужує два інші виклики. Додаючи все разом, ми отримаємо, що на кожному рівні викликів <em>log(n)</em> кожний елемент оригінальних списків прийме участь в одній операції розділення, та в одній операції злиття.</p></div>
<div class="paragraph"><p>Таким чином, кожний рівень викликів має загальну вартість, пропорційну до <code>n</code>. Оскільки загалом <em>log(n)</em> рівнів виклику, ми отримаємо загальну вартість, пропорційну до <em>n log(n)</em>. Ця вартість не залежить від початкового розподілення елементів в списку, так що найгірша вартість є такою самою, що і середня вартість. Ця властивість робить сортування злиттям привабливим алгоритмом для сортування списків.</p></div>
<div class="paragraph"><p>Ось приклад того, як використовується <code>msort</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>msort</code> є класичним прикладом концепції карування, обговореної в Розділі 9.3. Карування робить простим спеціалізувати функцію для певних функцій порівняння. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">intSort</span> <span class="k">=</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="k">_</span>
<span class="n">intSort</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна <code>intSort</code> посилається на функцію, що приймає список цілих, та сортує їх в числовому порядку. Як описане в Розділі 8.6, підкреслення стоїть замість відсутнього списку аргументів. В цьому випадку відсутній аргумент це список, що має бути впорядкований. Як інший приклад, ось як ви можете визначити функцію, що сортує  список цілих в зворотньому числовому порядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">reverseIntSort</span> <span class="k">=</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="k">_</span>
<span class="n">reverseIntSort</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ви вже провадите функцію порівняння через карування, тепер вам треба провадити список для сортування, коли ви викликаєте функції <code>intSort</code> або <code>reverseIntSort</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mixedInts</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="n">mixedInts</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">intSort</span><span class="o">(</span><span class="n">mixedInts</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">reverseIntSort</span><span class="o">(</span><span class="n">mixedInts</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_7_____list">16.7 Методи вищих порядків класу List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато операцій зі списками мають подібну структуру. Декілька шаблонів з'являються раз за разом. Деякі приклади: трансформація кожного елементу списка в деякий спосіб, перевірка, чи властивість дотримується для всіх елементів в списку, виділення зі списку елементів, що задовільняють певному критерію, або комбінування елементів списку з використанням деякого оператора. В Java такі шаблони будуть зазвичай виражені ідіоматичними комбінаціями циклів <code>for</code> або <code>while</code>. В Scala вони можуть бути виражені більш стисло та напряму, використовуючи оператори вищих порядків,<span class="footnote"><br />[Під операторами вищих порядків ми розуміємо функції вищих порядків, використані в операторній нотації. Як зазначено в Розділі 9.1, функція є "вищого порядку", якщо вона сприймає одну або більше інших функцій в якості параметрів.]<br /></span> що реалізовані як методи в класі <code>List</code>. Ці оператори вищого порядку обговорюються в цьому розділі.</p></div>
<div class="sect2">
<h3 id="___code_map_code_code_flatmap_code_code_foreach_code">Відзеркалення списків: <code>map</code>, <code>flatMap</code>, <code>foreach</code></h3>
<div class="paragraph"><p>Операція <code>xs map f</code> бере як операнди список <code>xs</code> типу <code>List[T]</code>, та функцію <code>f</code> типу <code>T =&gt; U</code>. Вона повертає список, що утворюється застосуванням функції <code>f</code> до кожного елементу в <code>xs</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;the&quot;</span><span class="o">,</span> <span class="s">&quot;quick&quot;</span><span class="o">,</span> <span class="s">&quot;brown&quot;</span><span class="o">,</span> <span class="s">&quot;fox&quot;</span><span class="o">)</span>
<span class="n">words</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">the</span><span class="o">,</span> <span class="n">quick</span><span class="o">,</span> <span class="n">brown</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">)</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">eht</span><span class="o">,</span> <span class="n">kciuq</span><span class="o">,</span> <span class="n">nworb</span><span class="o">,</span> <span class="n">xof</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>flatMap</code> подібний до <code>map</code>, але він приймає функцію, що повертає список елементів в якості свого правого операнда. Він застосовує функцію до кожного елемена списку, та повертає конкатенацію всіх результатів функції. Різниця між <code>map</code> та <code>flatMap</code> проілюстрована в наступному прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span>
<span class="n">c</span><span class="o">,</span> <span class="n">k</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">n</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span>
<span class="n">n</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що коли <code>map</code> повертає список зі списків, <code>flatMap</code> повертає єдиний список, в якому всі елементи списку конкатеновані.</p></div>
<div class="paragraph"><p>Відмінність та взаємодія між <code>map</code> та <code>flatMap</code> також продемонстрована в наступному виразі, що конструює список з усіх пар <code>(i, j)</code>, таких що <code>1 ≤ j &lt; i &lt; 5</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span>
  <span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span>
<span class="o">)</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span>
<span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>List.range</code> є допоміжний метод, що створює список з усіх цілих в деякому диапазоні. Він використовується двічи в цьому прикладі: один раз для генерації списку цілих від <code>1</code> (включно) до <code>5</code> (виключно), та другий раз для генерації списку цілих від <code>1</code> до <code>i</code>, для кожного значення <code>i</code>, взятого з першого списку. <code>map</code> в цьому виразі генерує список таплів <code>(i, j)</code>, де <code>j &lt; i</code>. Зовнішній <code>flatMap</code> в цьому прикладі генерую цей список для кожного <code>i</code> між <code>1</code> та <code>5</code>, та потім конкатенує всі результати. Альтернативно, той самий список може бути сконструйований за допомогою виразу <code>for</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="k">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви вивчите більше щодо взаємодії між виразами <code>for</code> та операціями списків в Главі 23.</p></div>
<div class="paragraph"><p>Третя <code>map</code>-подібна операція є <code>foreach</code>. Однак на відміну від <code>map</code> та <code>flatMap</code>, <code>foreach</code> приймає процедуру (функцію, тип якої <code>Unit</code>) в якості правого операнда. Він просто застосовує процедуру до кожного елементу списку. Результат самої операції знову <code>Unit</code>; список результатів не збирається. Як приклад, ось стислий спосіб підсумувати всі числа в списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="k">_</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_filter_code_code_partition_code_code_find_code_code_takewhile_code_code_dropwhile_code_code_span_code">Фільтрування списків: <code>filter</code>, <code>partition</code>, <code>find</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>span</code></h3>
<div class="paragraph"><p>Операця <code>xs filter p</code> приймає як операнди список <code>xs</code> типу <code>List[T]</code>, та функцію предикат <code>pof</code> типу <code>T =&gt; Boolean</code>. Вона видає список всіх елементів <code>x</code> в <code>xs</code>, для яких <code>p(x)</code> є <code>true</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">the</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>partition</code> подібна до <code>filter</code>, але повертає пару списків. Один список містить всі елементи, для яких предикат є <code>true</code>, доки інший містить всі елементи, для яких предикат є <code>false</code>. Це визначено через еквівалентність:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">partition</span> <span class="n">p</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">filter</span> <span class="n">p</span><span class="o">,</span> <span class="n">xs</span> <span class="n">filter</span> <span class="o">(!</span><span class="n">p</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">partition</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res42</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>find</code> також подібний до <code>filter</code>, але він повертає перший елемент, що задовільняє наданому предикату, скоріше ніж всі такі елементи. Операція <code>xs find p</code> приймає список <code>xs</code> та предикат <code>ep</code> як операнди. Він повертає опціональне значення. Якщо існує елемент <code>x</code> в <code>xs</code>, для якого <code>p(x)</code> є <code>true</code>, повертається <code>Some(x)</code>. Інакше <code>p</code> є <code>false</code> для всіх елементів, та повертається <code>None</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">find</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">find</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператори <code>takeWhile</code> та <code>dropWhile</code> також приймають предикат як свій правий операнд. Операція <code>xs takeWhile p</code> бере найдовший префікс списку <code>xs</code>, такий що для кожного елементу в префіксі задовільняється <code>p</code>. Аналогічно, операція <code>xs dropWhile p</code> видаляє найдовший префікс зі списку <code>xs</code>, такий, що для кожного елементу в префіксі задовільняється <code>p</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">takeWhile</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res45</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span> <span class="n">startsWith</span> <span class="s">&quot;t&quot;</span><span class="o">)</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">quick</span><span class="o">,</span> <span class="n">brown</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>span</code> комбінує <code>takeWhile</code> та <code>dropWhile</code> в одній операції, так само, як <code>splitAt</code> комбінує <code>take</code> та <code>drop</code>. Він повертає пару з двох списків, визначених еквівалентістю:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">span</span> <span class="n">p</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">takeWhile</span> <span class="n">p</span><span class="o">,</span> <span class="n">xs</span> <span class="n">dropWhile</span> <span class="n">p</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і <code>splitAt</code>, <code>span</code> уникає подвійного подорожування списком <code>xs</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">span</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res47</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span><span class="nc">List</span><span class="o">(-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_forall_code__code_exists_code">Предикати на списках: <code>forall</code> та <code>exists</code></h3>
<div class="paragraph"><p>Операція <code>xs forall p</code> приймає як аргументи список <code>xs</code> та предикат <code>p</code>. Її результат є <code>true</code>, якщо всі елементи в списку задовільняють <code>p</code>. Відповідно, операція <code>xs exists p</code> повертає <code>true</code>, якщо існує елемент в <code>xs</code>, що задовільняє предикату <code>p</code>. Наприклад, щоб з'ясувати, чи матриця, представлена як список списків, має рядок з тільки нульовими елементами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">hasZeroRow</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span>
<span class="n">m</span> <span class="n">exists</span> <span class="o">(</span><span class="n">row</span> <span class="k">=&gt;</span> <span class="n">row</span> <span class="n">forall</span> <span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span>
<span class="n">hasZeroRow</span><span class="k">:</span> <span class="o">(</span><span class="kt">m:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span><span class="nc">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasZeroRow</span><span class="o">(</span><span class="n">diag3</span><span class="o">)</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_code__code_code">Згортання списків: <code>/:</code> та <code>:\</code></h3>
<div class="paragraph"><p>Інший загальний різновид операцій комбінують елементи списку за допомогою деякого оператору. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">sum</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="nc">_equals_</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>Це спеціальний примірник операції згортання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">sum</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">product</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="nc">_equals_</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>є особливим примірником цього оператора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">product</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
<span class="n">product</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Операція лівого згортання <code>(z /: xs) (op)</code> включає три об'єкти: початкове значення <code>z</code>, список <code>xs</code>, та двомісну операцію <code>op</code>. Результат згортання є <code>op</code>, застосований між послідовними елементами списку з префіксом <code>z</code>.</p></div>
<div class="paragraph"><p>Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">z</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">a</span><span class="o">),</span> <span class="n">b</span><span class="o">),</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або графічно:</p></div>
<div class="paragraph"><p>Ось інший приклад, що ілючтрує, як використовується <code>/:</code>. Щоб конкатенувати всі слова в списку рядків з проміжками між ними та напочатку, ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="s">&quot;&quot;</span> <span class="o">/:</span> <span class="n">words</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res49</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot; the quick brown fox&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дає зайвий проміжок на початку. Щоб видалити цей проміжок ви можете використати невелику варіацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">head</span> <span class="o">/:</span> <span class="n">words</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">the</span> <span class="n">quick</span> <span class="n">brown</span> <span class="n">fox</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>/:</code> продукує ліво-сторонні дерева операцій (його синтаксис з косою, що підіймається по ходу має бути відображенням цього). Оператор має <code>:\</code> як аналог, що продукує право-сторонні дерева. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">:\</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="n">op</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">op</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">op</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">z</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Або графічно:</p></div>
<div class="paragraph"><p>Оператор <code>:\</code> промовляється як праве згортання. Він включає ті самі три операнди що і ліве згортання, але перші два ідуть в зворотньому порядку: перший операнд є список для згортання, другий є початковим значенням.</p></div>
<div class="paragraph"><p>Для асоціативних операцій праве і ліве згортання еквівалентні, але може бути різниця в ефективності. Для приклада розгляньте операцію, відповідну до метода <code>flatten</code>, що конкатенує всі елементи в списку списків. Це може бути реалізоване за допомогою або лівого, або правого згортання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">flattenLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="o">/:</span> <span class="n">xss</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>

<span class="k">def</span> <span class="n">flattenRight</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Оскікльи конкатенація списку `xs 
</dt>
<dd>
<p>
ys` займає час, пропорційний до свого першого елемента <code>xs</code>, реалізація в термінах правого згортання в <code>flattenRight</code> більш ефективна, ніж реалізація лівого згортання в <code>flattenLeft</code>. Проблема в тому, що <code>flattenLeft(xss)</code> копіює перший елемент списку <code>xss.head</code> <code>n-1</code> разів, де <code>n</code> є довжина списку <code>xss</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Зауважте, що обоє версії <code>flatten</code> потребують анотацію типу на порожніх списках, що є початковим значенням згортання. Це через обмеженість виводу типів в Scala, що відмовляється виводити коректний тип списків автоматично. Якщо ви приберете анотацію, ви отримаєте наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">flattenRight</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
           <span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
           <span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
                              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб з'ясувати, чому вивід типів не здолав ситуацію, вам треба знати щодо типів методів <code>fold</code>, та як вони реалізовані. Більше про це в Розділі 16.10. Нарешті, хоча оператори <code>/:</code> та <code>:\</code> мають перевагу в тому, що напрямок косої нагадує графічне зображення відповідних ліво- та право-сторонніх дерев, та асоциативність символа двокрапки покладає початкове значення в ту саму позицію в виразі, що і в дереві, дехто може винайти результуючий код недостатньо інтуітивним. Якщо вам подобається, ви можете використовувати замість цього методи <code>foldLeft</code> та <code>foldRight</code>, що також визначені в класі <code>List</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_list_code___code_fold_code">Приклад: реверс <code>List</code> з використанням <code>fold</code></h3>
<div class="paragraph"><p>Раніше в цій главі ви бачили реалізацію метода <code>reverse</code>, названу <code>rev</code>, чий час виконання був квадратичним відносно довжини списку, який він обертав. Ось інша реалізація реверсу, що має лінійну ціну. Ідея полягає в використанні лівого згортання, базуючись на наступній схемі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">reverseLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">startvalue</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)(</span><span class="n">operation</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що залишилось, це заповнити частини <em>startvalue</em> та <em>operation</em>. Фактично, ви можете спробувати вгадати ці частини з деяких простих прикладів. Щоб вивести коректне значення для <code>startvalue</code>, ви можете почати з найменьшим можливим списком, <code>List()</code>, та рахувати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">властивостями</span> <span class="n">reverseLeft</span><span class="o">)</span>

<span class="n">reverseLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">шаблоном</span> <span class="n">reverseLeft</span><span class="o">)</span>

<span class="o">(</span><span class="n">startvalue</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">())(</span><span class="n">operation</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">визначенням</span> <span class="o">/:)</span>

<span class="n">startvalue</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, <em>startvalue</em> має бути <code>List()</code>. Щоб вивести другий операнд, ви можете взяти наступний найменььший список як приклад. Ви вже знаєте, що_startvalue_ є List(), так що ви можете рахувати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">властивостями</span>  <span class="n">reverseLeft</span><span class="o">)</span>

<span class="n">reverseLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">шаблоном</span> <span class="n">reverseLeft</span><span class="o">,</span> <span class="n">з</span> <span class="n">startvalue</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span>

<span class="o">(</span><span class="nc">List</span><span class="o">()</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">operation</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">визначенням</span> <span class="o">/:)</span>

<span class="n">operation</span><span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Таким чином, <em>operation</em> <code>(List(), x)</code> еквівалентне <code>List(x)</code>, що також може бути записане як `x 
</dt>
<dd>
<p>
List()<code>. Це підказує взяти за операцію оператор `::</code> з переставленими операндами. (Ця операція іноді називається <code>snoc</code>, з посиланням на <code>::</code>, що називається <code>cons</code>.) Ми підходимо до наступної реалізації для <code>reverseLeft</code>:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">reverseLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{(</span><span class="n">ys</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>І знову, анотація типу в <code>List[T]()</code> є необхідною, щоб вивід типів почав робити. Якщо ви аналізуєте складність <code>reverseLeft</code>, ви винайдете, що він застосовує операцію сталого часу (<code>snoc</code>) <code>n</code> раз, де <code>n</code> є довжиною списка аргумента. Таким чином, складність <code>reverseLeft</code> є лінійною.</p></div>
</div>
<div class="sect2">
<h3 id="___code_sortwith_code">Сортування списків: <code>sortWith</code></h3>
<div class="paragraph"><p>Операція <code>xs sortWith before</code>, де <code>xs</code> є списком, а <code>before</code> функцією, що може використовуватись для порівняння двох елементів, сортує елементи списку <code>xs</code>. Вираз <code>x before y</code> повинен повертати <code>true</code>, якщо <code>x</code> повинен іти перед <code>y</code> в бажаному впорядкуванні. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">quick</span><span class="o">,</span> <span class="n">brown</span><span class="o">,</span> <span class="n">the</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>sortWith</code> виконує сортування злиттям, подібне до алгоритму <code>msort</code>, показаному в останньому розділі. Але <code>sortWith</code> є методом класу <code>List</code>, тоді як <code>msort</code> визначений за межами списків.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_8____list">16.8 Методи об'єкта List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Досі всі операції, що ви бачили в цій главі, реалізовані як методи класу <code>List</code>, так що ви викликаєте їх на окремих об'єктах списків. Також є декілька методів в глобально досяжному об'єкті <code>scala.List</code>, що є об'єктом компанйоном класу <code>List</code>. Деякі з ціх операцій є методами фабрик, що створюють списки. Інші є операціями, що роблять зі списками деякої специфічної форми. Обоє типи методів будуть представлені в цьому розділі.</p></div>
<div class="sect2">
<h3 id="______code_list_apply_code">Створення списків зі своїх елементів: <code>List.apply</code></h3>
<div class="paragraph"><p>Ви вже бачили при нагоді літерали списків, такі як <code>List(1, 2, 3)</code>. Немає нічого особливого щодо їх синтаксису. Літерал як <code>List(1, 2, 3)</code> є простим застосуванням об'єкта <code>List</code> до елементів <code>1, 2, 3</code>. Тобто, це еквівалентно до <code>List.apply(1, 2, 3)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_list_range_code">Створення диапазона цілих: <code>List.range</code></h3>
<div class="paragraph"><p>Метод <code>range</code>, що ви мимохідь бачили раніше в дискусії про <code>map</code> та <code>flatmap</code>, створює список, що відповідає диапазону чисел. Його найпростіша форма є <code>List.range(from, until)</code>, що створює список з усіх чисел, що починається з <code>from</code>, та іде до <code>until</code> мінус один. Так що кінцеве значення, <code>until</code>, не формує частину диапазону.</p></div>
<div class="paragraph"><p>Також існує версія <code>range</code>, що приймає значення <code>step</code> як третій параметр. Ця операція буде давати списко елементів, що відстоять один від одного на відстані <code>step</code>. Значення <code>step</code> може бути додатнім або від'ємним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res56</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_list_fill_code">Створення уніформних списків: <code>List.fill</code></h3>
<div class="paragraph"><p>Метод <code>fill</code> створює список, що складається з нуля або більше копій того самого елемента. Він приймає два параметри: довжину створюваного списку, та елемент, що треба повторити. Кожний параметр наданий як окремий список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="sc">&#39;a&#39;</span><span class="o">)</span>
<span class="n">res57</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">hello</span><span class="o">,</span> <span class="n">hello</span><span class="o">,</span> <span class="n">hello</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо в <code>fill</code> надати більше ніж два аргументи, тоді він бути створювати багато-вимірні списки. Тобто він буде створювати списки списків, спискі списків списків, і так далі. Додаткові аргументи ідуть в першому списку аргументів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)(</span><span class="sc">&#39;b&#39;</span><span class="o">)</span>
<span class="n">res59</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_list_tabulate_code">Функція табуляції: <code>List.tabulate</code></h3>
<div class="paragraph"><p>Метод <code>tabulate</code> створює список, чиї елементи обчислені згідно наданої функції. Її аргументи такі самі, як для <code>List.fill</code>: перший аргумент `list`надає розмірність створюваного списку, та другий описує елементи списку. Єдина відміність в тому, що замість фіксованих елементів вони обчислюються функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">squares</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">tabulate</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span>
<span class="n">squares</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">16</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">multiplication</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">tabulate</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
<span class="n">multiplication</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">12</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">16</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_list_concat_code">Конкатенація декількох списків: <code>List.concat</code></h3>
<div class="paragraph"><p>Метод <code>concat</code> конкатенує елементи декількох списків. Списки, що будуть конкатеновані, надаються як прямі аргументи до <code>concat</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;c&#39;</span><span class="o">))</span>
<span class="n">res60</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;b&#39;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;c&#39;</span><span class="o">))</span>
<span class="n">res61</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">()</span>
<span class="n">res62</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_9____">16.9 Обробка декількох списків разом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Метод <code>zipped</code> на таплах узагальнює декілька загальних операцій для роботи з декількома списками замість одного. Одна така операція є <code>map</code>. Метод <code>map</code> для двох з'єднаних списків відображує пари елементів, скоріше ніж окремі елементи. Одна пара для перших елементів кожного списку, інша пара для другого елементу кожного списку, і так далі — так багато пар, що і довжина списків. Ось приклад його використання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res63</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">80</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що третій елемент другого списку відкидається. Метод <code>zipped</code> поєднує тільки стільки елементів, скільки з'являється в усіх списках одночасно. Любі додаткові елементи в кінці відкидаються.</p></div>
<div class="paragraph"><p>Існують також <code>zipped</code> аналоги для <code>exists</code> та <code>forall</code>. Вони подібні до версій з одним списком для ціх методів, за винятком, що вони оперують на елементах з декількох списків замість одного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">,</span> <span class="s">&quot;de&quot;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span>
        <span class="n">forall</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res64</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">,</span> <span class="s">&quot;de&quot;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span>
        <span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res65</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___30">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>В настуному (і заключному) розділі цієї глави ми зробимо огляд алгоритму виводу типів Scala. Якщо ви не зацікавлені в таких деталях прямо зараз, ви можете пропустити цілий розділ, та перейти прямо до підсумків.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_10_____scala">16.10 Розуміння алгоритма виводу типів Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна відмінність між попереднім використанням <code>sortWith</code> та <code>msort</code> стосується допустимих синтаксичних форм функції порівняння.</p></div>
<div class="paragraph"><p>Порівняйте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
<span class="n">res66</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>з:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res67</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Два виразу еквівалентні, але перший використовує довшу форму функції порівняння, з іменованими параметрами та явними типами. Другий використовує стислу форму, <code>(_ &gt; _)</code>, де іменовані параметри замінені на підкреслення. Звичайно, ви також можете використовувати першу, довшу форму порівняння в <code>sortWith</code>.</p></div>
<div class="paragraph"><p>Однак коротша форма не може бути використана з <code>msort</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">missing</span> <span class="kt">parameter</span> <span class="k">type</span> <span class="kt">for</span> <span class="kt">expanded</span>
<span class="n">function</span> <span class="o">((</span><span class="n">x$1</span><span class="o">,</span> <span class="n">x$2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x$1</span><span class="o">.</span><span class="nc">$greater</span><span class="o">(</span><span class="n">x$2</span><span class="o">))</span>
      <span class="n">msort</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб зрозуміти чому, вам треба знати деякі деталі алгоритму виводу типів в Scala. Виведення типів в Scala базується на потоці. В застосуванні методу <code>m(args)</code>, вивід типів спершу перевіряє, чи метод <code>m</code> має відомий тип. Якщо це так, цей тип використовується для виведення очікуваних типів аргументів. Наприклад, в <code>abcde.sortWith(_ &gt; _)</code>, тип <code>abcde</code> є <code>List[Char]</code>. Таким чином,  <code>sortWith</code> відомий як метод, що приймає аргумент типу <code>(Char, Char) =&gt; Boolean</code>, та продукує результат типу <code>List[Char]</code>. Оскільки параметри типу аргументів функції відомі, їх не треба записувати явно. Маючи те, що відомо про <code>sortWith</code>, вивід може здогадатись, що <code>(_ &gt; _)</code> має розширюватись до <code>((x: Char, y: Char) =&gt; x &gt; y)</code>, що <code>x</code> та <code>y</code> є деякими довільними новими іменами.</p></div>
<div class="paragraph"><p>Тепер розглянемо другий випадок, <code>msort(_ &gt; _)(abcde)</code>. Тип <code>msort</code> є карований, поліморфний тип методу, що приймає аргумент типу <code>(T, T) =&gt; Boolean</code> до функції від <code>List[T]</code> до <code>List[T]</code>, де <code>T</code> є досі невідомий тип. Метод <code>msort</code> потребує бути створений з параметром типу, перед тим як він може бути застосований до його аргументів.</p></div>
<div class="paragraph"><p>Оскільки точний тип примірника <code>msort</code> в застосуванні досі не відома, він не може бути використаний для виведення типу його першого аргументу. Вивід типу змінює свою стратегію в цьому випадку; він спочатку перевіряє аргументи методу, щоб визначити відповідний тип примірника метода. Однак, коли він отримує завдання перевірити тип скороченого функціонального літерала, <code>(_ &gt; _)</code>, він схибить, бо він не має інформації щодо типів неявних функціональних параметрів, що вказані як підкреслення.</p></div>
<div class="paragraph"><p>Один спосіб розв'язати проблему є передати явний параметр типу до <code>msort</code>, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">[</span><span class="kt">Char</span><span class="o">](</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
<span class="n">res68</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскікльи коректний тип примірника <code>msort</code> тепер відомий, він може бути використаний для вивідення типу аргументів. Інше можливе рішення є переписати метод <code>msort</code>, так що його параметри були переставлені місцями:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">msortSwapped</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">less</span><span class="k">:</span>
    <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
<span class="c1">// така сама реалізація, що і msort,</span>
<span class="c1">// але з переставленими аргументами</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер вивід типу буде успішний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msortSwapped</span><span class="o">(</span><span class="n">abcde</span><span class="o">)(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res69</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут трапилось, це те, що вивід використав відомий тип першого параметра, <code>abcde</code>, для визначення параметру типа <code>msortSwapped</code>. Як тільки точний тип <code>msortSwapped</code> став відомий, він, в свою чергу, може бути використаний для виведення типу другого параметру, <code>(_ &gt; _)</code>.</p></div>
<div class="paragraph"><p>Загалом, коли завданням є вивід параметру типу для поліморфного методу, вивід типу консультується з типами всіх значень аргументів в першому списку параметрів, але не з аргументами за його межами. Оскільки <code>msortSwapped</code> є карований метод з двома списками параметрів, не має потреби перевіряти другий аргумент (тобто, функціональне значення) для визначення параметру типа метода.</p></div>
<div class="paragraph"><p>Ця схема виведення підказує наступний принцип розробки бібліотеки: коли розробляється поліморфний метод, що приймає не-функціональні аргументи, та функціональний аргумент, поставьте функціональний аргумент останнім окремо, у власному карованому списку аргументів. В такий спосіб, коректний тип примірника метода може бути виведений з не-функціональних аргументів, і цей тип може, в свою чергу, бути використаний для перевірки типу функціонального аргументу. Загальний ефект в тому, що користувачі метода будуть в змозі надавати менше інформації типу, та писати літерали в більш компактний спосіб.</p></div>
<div class="paragraph"><p>Тепер перейдемо до більш складного випадку операції <code>fold</code>. Чому треба задавати явний параметр типу в такому виразі, як тіло метода <code>flattenRight</code>, показаного нижче?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип операції правого згортання поліморфний по двох змінних. Візьмемо вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">xs</span> <span class="o">:~</span><span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>xs</code> має бути списком деякого довільного типу <code>A</code>, скажімо,  <code>xs: List[A]</code>. Початкове значення <code>z</code> може бути деякого іншого типу <code>B</code>. Операція <code>op</code> після цього приймає два аргументи типів <code>A</code> та <code>B</code>, та повертає результат типу <code>B</code>, тобто, <code>op: (A, B) =&gt; B</code>. Оскільки тип <code>z</code> не пов'язаний до типу списка <code>xs</code>, вивід типу не має контекстної інформації для <code>z</code>.</p></div>
<div class="paragraph"><p>Тепер розглянемо вираз в помилковій версії <code>flattenRight</code>, також показаній тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span> <span class="c1">// це не буде компілюватись</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Початкове значення <code>z</code> в цьому <code>fold</code> є порожнім списком, <code>List()</code>, так що без додаткової інформації про тип, його тип виводиться як  <code>List[Nothing]</code>. Таким чином, вивід буде виводити, що тип <code>B</code> в <code>fold</code> є <code>List[Nothing]</code>. Таким чином, операція `(_ 
</dt>
<dd>
<p>
_)` у <code>fold</code>, як очікується, має бути такого типу:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це, очевидно, є можливим типом для операції, такої як <code>fold</code>, але це не дуже корисний тип! Він каже, що операція завжди приймає порожній список в якості другого аргументу, та завжди продукує порожній список як результат.</p></div>
<div class="paragraph"><p>Іншими словами, вивід типів стабілізується дуже рано для типу <code>List()</code>; він мав би дочекатись, доки він не побачить тип операції <code>op</code>. Так що (інакше дуже корисне) правило брати до уваги тільки перший розділ аргументів в застосуванні карованого метода для визначення типу метода, тут є коренем проблеми. З іншого боку, якщо це правило пом'якшити, вивід все ще не зможе надати тип для <code>op</code>, оскільки типи його параметрів не надані. Таким чином, це ситуація Catch-22, що може бути розрішена тільки через явну анотацію типу з боку програміста.</p></div>
<div class="paragraph"><p>Цей приклад підкреслює деякі обмеження локальної, базованої на потоці, схеми виводу типів в Scala. Вона не присутня в більш глобальному стилі виводу типів Hindley-Milner, що використовується в функціональних мовах, як ML або Haskell. Однак локальний вивід типів Scala значно краще поводиться з об'єктно-орієнтовними субтипами, ніж стиль Hindley-Milner. На щастя, обмеження виявляють себе тільки в граничних випадках, та звичайно просто лагодяться додаванням явних анотацій типів.</p></div>
<div class="paragraph"><p>Додавання анотацій типу також є корисною технікою зневадження, коли ви здивовані повідомленнями помилок типів, пов'язаних з поліморфними методами. Якщо ви невпевнені, що спричинило певну помилку типу, просто додайте аргументи типу або інші анотації типів, яка за вашою думкою коректна. Після цього ви будете в змозі швидко подивитись, в чому полягала реальна проблема.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_11_">16.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили багато шляхів роботи зі списками. Ви бачили базові операції, як <code>head</code> та <code>tail</code>, операції першого порядку, як <code>reverse</code>, операції вищого порядку, як <code>map</code>, та допоміжні методи в об'єкті <code>List</code>. По мірі цього ви трохи вивчили щодо того, як робить вивід типів Scala.</p></div>
<div class="paragraph"><p>Списки є реальною робочою конячкою в Scala, так що ви отримаєте перевагу, якщо будете знати, як використовувати її. З цієї причини ця глава глибоко занурюється в те, як використовувати списки. Однак списки є тільки одним різновидом колекцій, що підтримує Scala. наступна глава є широкою, скоріше ніж глибокою, та показує вам, як використовувати різноманітні типи колекцій в Scala.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__17">Глава 17</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____13">Робота з іншими колекціями</h1>
<div class="paragraph"><p>Scala має багату бібліотеку колекцій. Ця глава дає вам тур по найбільш загально уживаних типах колекцій та операціях, показуючи тільки частини, які ви будете використовувати найбільш часто. Глава 24 провадить більш повний тур по тому, що доступно, та Глава 25 покаже, як конструкції композиції Scala використовуються для провадження такого багатого API.</p></div>
<div class="sect1">
<h2 id="_17_1_">17.1 Послідовності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Типи послідовностей дозволяють вам робити з групами даних, впорядкованих один за одним. Оскільки елементи впорядковані, ви можете запросити перший елемент, другий елемент, 103й елемент, і так далі. В цій главі ми дамо вам короткий тур по найбільш важливим послідовностям.</p></div>
<div class="sect2">
<h3 id="__18">Списки</h3>
<div class="paragraph"><p>Можливо, найбільш важливий тип послідовністі, про який треба знати, це клас <code>List</code>, незмінний пов'язаний список, описаний в деталях в попередній главі. Списки підтримують швидке додавання та видалення елементів з початку списку, але вони не провадять швидкого доступу до довільних індексів, оскільки реалізація має лінійно ітерувати вздовж всього списку.</p></div>
<div class="paragraph"><p>Ця комбінація можливостей може виглядати дивною, але вони б'ють в яблучко, та гарно роблять з багатьма алгоритмами. Швидке додавання та видалення перших елементів означає, що порівняння шаблонів також робить гарно, як описано в Главі 15. Незмінність списків допомагає вам розробляти коректні, ефективні алгоритми, тому що вам ніколи не треба робити копії зі списків.</p></div>
<div class="paragraph"><p>Ось короткий приклад, що показує, як ініціалізувати список, та отримати доступ до його голови та хвоста:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">colors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">,</span> <span class="s">&quot;blue&quot;</span><span class="o">,</span> <span class="s">&quot;green&quot;</span><span class="o">)</span>
<span class="n">colors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">colors</span><span class="o">.</span><span class="n">head</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">red</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">colors</span><span class="o">.</span><span class="n">tail</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб нагадати собі про списки, дивіться Крок 8 в Главі 3. Ви можете знайти деталі використання списків в Главі 16. Списки також обговорюються в Главі 22, що провадить погляд на те, як списки реалізовані в Scala.</p></div>
</div>
<div class="sect2">
<h3 id="__19">Масиви</h3>
<div class="paragraph"><p>Масиви дозволяють вам зберігати послідовність елементів, та ефективно отримувати доступ до елемента в довільній позиції, або отримуючи, або оновлюючі елемент, рахуючи від нульового індексу. Ось як ви створюєте масив, розмір якого ви знаєте, але для якого ви досі не знаєте значень елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fiveInts</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">5</span><span class="o">)</span>
<span class="n">fiveInts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як ви ініціалізуєте масив, коли ви знаєте значення елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fiveToOne</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">fiveToOne</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви мають доступ в Scala, розташовуючи індекс в дужки, не в прямокутні дужки, як в Java. Ось приклад обох, доступу та зміни елемента масива:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fiveInts</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">fiveToOne</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fiveInts</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Масиви Scala представлені в той самий спосіб, що і масиви Java. Так що ви можете без проблем використовувати існуючі методи Java, що повертають масиви.<span class="footnote"><br />[Різниця в варіантності масивів Scala та Java — тобто, коли <code>Array[String]</code> є субтипом <code>Array[AnyRef]</code> — це буде розглядатись в Розділі 19.3.]<br /></span></p></div>
<div class="paragraph"><p>Ви мали бачити масиви в дії багато раз в попередніх главах. Основи в Кроці в Главі 3. Декіклька прикладів ітерування по елементах масивів за допомогою вираза <code>for</code> показані в Розділі 7.3. Масиви також яскраво фігурують в бібліотеці двомірних розташувань в Главі 10.</p></div>
</div>
<div class="sect2">
<h3 id="___31">Буфери списків</h3>
<div class="paragraph"><p>Клас <code>List</code> провадить швидкий доступ до голови списку, але не до кінця. Таким чином, коли вам треба побудувати список через додавання в кінець, розгляньте побудування списку навпаки, додаючи елементи до начала. Коли ви скінчите, викличте <code>reverse</code>, щоб отримати елементи в порядку, що вам потрібен.</p></div>
<div class="paragraph"><p>Інша альтернатива, що уникає операції <code>reverse</code>, це використання <code>ListBuffer</code>. <code>ListBuffer</code> є змінним об'єктом (що міститься в пакунку <code>scala.collection.mutable</code>), що може допомогти вам побудувати списки більш ефективно, коли вам треба дописувати в кінець. <code>ListBuffer</code> провадить сталий час виконання операцій додавання з обох кінців. Ви додаєте елементи за допомогою оператора <code>+=</code>, та ставите на початок за допомогою оператора <code>+=:</code>. Коли ви завершуєте побудову, ви можете отримати <code>List</code> через виклик <code>toList</code> на <code>ListBuffer</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">+=:</span> <span class="n">buf</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша причина використовувати <code>ListBuffer</code> замість <code>List</code> є запобігання потенційному переповненню стека. Якщо ви можете будувати список в бажаному порядку, додаючи спереду, але потрібний рекурсивний алгоритм не має хвостової рекурсії, замість цього ви можете використовувати вираз <code>for</code> або цикл <code>while</code> разом з <code>ListBuffer</code>. Ви побачите, як <code>ListBuffer</code> буде використаний в цей спосіб в Розділі 22.2.</p></div>
</div>
<div class="sect2">
<h3 id="___32">Буфери масивів</h3>
<div class="paragraph"><p><code>ArrayBuffer</code> подібний до масиву, за виключенням того, що ви можете додавати елементи з початку та з кінця послідовності. Доступні всі операції з масивами <code>Array</code>, хоча вони трохі повільніші, через прошарок обгортки в реалізації. Нові операції додавання та видалення мають сталий час в середньому, але часом потребують лінійного часу, бо реалізація потребує розміщувати новий масив, щоб зберігати вміст буфера.</p></div>
<div class="paragraph"><p>Щоб використовувати <code>ArrayBuffer</code>, ви маєте спочатку імпортувати його з пакунку змінних колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви створюєте <code>ArrayBuffer</code>, ви маєте вказати параметр типу, але ви не маєте вказувати довжину. <code>ArrayBuffer</code> буде підлаштовувати розміщений простір автоматично, по мірі необхідності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додавати до <code>ArrayBuffer</code> з використанням метода <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">12</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">15</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Доступні всі методи нормальних масивів. Наприклад, ви можете запитати в <code>ArrayBuffer</code> його довжину, або ви можете отримати елемент по його індексу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_stringops_code">Рядки (через <code>StringOps</code>)</h3>
<div class="paragraph"><p>Ще одна послідовність, про яку треба знати, це <code>StringOps</code>, що реалізує багато методів послідовностей. Оскільки <code>Predef</code> має неявне перетворення від <code>String</code> до <code>StringOps</code>, ви можете трактувати любий рядок як послідовність. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">hasUpperCase</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>
<span class="n">hasUpperCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasUpperCase</span><span class="o">(</span><span class="s">&quot;Robert Frost&quot;</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasUpperCase</span><span class="o">(</span><span class="s">&quot;e e cummings&quot;</span><span class="o">)</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі метод <code>exists</code> викликається на рядку на ім'я <code>s</code> в тілі методу <code>hasUpperCase</code>. Оскільки в самому класі String немає декларованого метода на ім'я <code>exists</code>, компілятор Scala буде неявно конвертувати <code>s</code> до <code>StringOps</code>, що має такий метод. Метод <code>exists</code> трактує рядок як послідовність символів, та буде повертати <code>true</code>, якщо любий з символів в верхньому реєстрі:[Код, наданий в Главі 1, презентує подібний приклад.]</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_2___">17.2 Множини та мапи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви вже бачили основи множин та мап в попередніх главах, починаючи з Кроку 10 в Главі 3. В цьому розділі ми маємо намір краще зрозуміти їх використання, та покажемо вам ще декілька прикладів.</p></div>
<div class="paragraph"><p>Як вже зазначалось, бібліотека колекцій Scala пропонує обоє, змінні та незмінні версії множин та мап. Ієрархія для множин показана на Малюнку 3.2, і ієрархія для мап на Малюнку 3.3. Як показують ці діаграми, прості імена <code>Set</code> та <code>Map</code> використовуються трьома трейтами кожний, що знаходяться в різних пакунках.</p></div>
<div class="paragraph"><p>По замовчанню, коли ви пишете <code>Set</code> або <code>Map</code>, ви отримаєте незмінний об'єкт. Якщо ви бажаєте змінний варіант, вам треба зробити явний імпорт. Scala дає вам простіший доступ до незмінних варіантів, як м'яке заохочення обирати їх, ніж їх змінні двійники. Простий доступ провадиться через об'єкт <code>Predef</code>, що неявно імпортується в кожний джерельний файл Scala. Лістинг 17.1 показує відповідні визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">+B</span><span class="o">]</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">val</span> <span class="nc">Map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span>
  <span class="k">val</span> <span class="nc">Set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 17.1 - Визначення по замовчанню для мап на множин в <code>Predef</code>.</p></div>
<div class="paragraph"><p>Ключове слово <code>type</code> використовується в <code>Predef</code> для визначення <code>Set</code> та <code>Map</code>, як псевдонимів для довших, повністю кваліфікованих імен незмінних трейтів множин та мап.<span class="footnote"><br />[Ключове слово <code>type</code> буде пояснено більш детально в Розділі 20.6.]<br /></span> Змінні <code>val</code> на ім'я  <code>Set</code> та <code>Map</code> ініціалізовані для посилань на об'єкти синглтони для незмінних <code>Set</code> та <code>Map</code>. Так що <code>Map</code> те саме, що <code>Predef.Map</code>, що визначений бути тим самий, що і <code>scala.collection.immutable.Map</code>. Це дотримується так само для типу <code>Map</code>, та об'єкта <code>Map</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте використовувати обоє, змінні та незмінні множини та мапи в тому самому джерельному файлі, один підхід є імпортувати ім'я пакунку, що містить змінні варіанти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете продовжувати посилатись на незмінні множини як <code>Set</code>, як і раніше, але тепер можете посилатись на змінну множину як на <code>mutable.Set</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mutaSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">mutaSet</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="___33">Використання множин</h3>
<div class="paragraph"><p>Ключева характеристика множин в тому, що вони будуть гарантувати щонайбільше одне входження об'єкту, в терміних <code>==</code>, що буде міститись в множині в кожний момент часу. Як приклад, ми будемо використовувати множину для підрахунку кількості різних слів в рядку.</p></div>
<div class="paragraph"><p>Метод <code>split</code> на <code>String</code> може розділити рядок на слова, якщо ви вкажете проміжки та символи пунктуації в якості роздільників слів. Регулярний вираз <code>"[ !,.]+"</code> буде достатнім: він вказує, що рядок має бути розділений в кожному місці, де є один або більше проміжків та/або символів пунктуації.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="s">&quot;See Spot run. Run, Spot. Run!&quot;</span>
<span class="n">text</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">See</span> <span class="nc">Spot</span> <span class="n">run</span><span class="o">.</span> <span class="nc">Run</span><span class="o">,</span> <span class="nc">Spot</span><span class="o">.</span> <span class="nc">Run</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wordsArray</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;[ !,.]+&quot;</span><span class="o">)</span>
<span class="n">wordsArray</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">See</span><span class="o">,</span> <span class="nc">Spot</span><span class="o">,</span> <span class="n">run</span><span class="o">,</span> <span class="nc">Run</span><span class="o">,</span> <span class="nc">Spot</span><span class="o">,</span> <span class="nc">Run</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб підрахувати різні слова, ви можете конвертувати їх в однаковий реєстр, та додати їх до множини. Оскільки множини виключають дублікати, кожне окреме слово буде з'являтись в множині рівно один раз.</p></div>
<div class="paragraph"><p>Перше, ви можете створити порожню множину, використовуючи порожній метод, впроваджений об'єктом компанйоном <code>Set</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">words</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім просто ітеруєте по словах за допомогою <code>for</code> виразу, конвертуєте кожне слово в нижній реєстр, та додаваєте його до змінної множини оператором <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">word</span> <span class="k">&lt;-</span> <span class="n">wordsArray</span><span class="o">)</span>
<span class="n">words</span> <span class="o">+=</span> <span class="n">word</span><span class="o">.</span><span class="n">toLowerCase</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Set</span><span class="o">(</span><span class="n">see</span><span class="o">,</span> <span class="n">run</span><span class="o">,</span> <span class="n">spot</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, текст містив рівно три відмінні слова: <code>spot</code>, <code>run</code>, та <code>see</code>. Найбільш загально використовувані методи для обох, змінних та незмінних множин, показані в Таблиці 17.1.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.1 Базові операції для множин</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>val nums = Set(1, 2, 3)</code></p></td>
<td align="left" valign="top"><p class="table">Створює незмінну множину (<code>nums.toString returnsSet(1, 2, 3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums + 5</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент (повертає <code>Set(1, 2, 3, 5)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums - 3</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент (повертає <code>Set(1, 2)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums ++ List(5, 6)</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементві (повертає <code>Set(1, 2, 3, 5, 6)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums -- List(1, 2)</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька елементів (повертає <code>Set(3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums &amp; Set(1, 3, 5, 7)</code></p></td>
<td align="left" valign="top"><p class="table">Робить перетин двох множин (повертає <code>Set(1, 3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.size</code></p></td>
<td align="left" valign="top"><p class="table">Повертає розмір множини (повертає <code>3</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.contains(3)</code></p></td>
<td align="left" valign="top"><p class="table">Перевіряє входження (повертає <code>true</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>import scala.collection.mutable</code></p></td>
<td align="left" valign="top"><p class="table">Робить змінні колекції простими для доступу</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>val words = mutable.Set.empty[String]</code></p></td>
<td align="left" valign="top"><p class="table">Створює порожню змінну множину (<code>words.toString</code> повертає <code>Set()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words += "the"</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент (<code>words.toString</code> повертає <code>Set(the)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words -= "the"</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент, якщо він існує (<code>words.toString</code> повертає <code>Set()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words ++= List("do", "re", "mi")</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементів (<code>words.toString</code> повертає <code>Set(do, re, mi)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words --= List("do", "re")</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька елементів (<code>words.toString</code> повертає <code>Set(mi)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words.clear</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи (<code>words.toString</code> повертає <code>Set()</code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="___34">Використання мап</h3>
<div class="paragraph"><p>Мапи дозволяють асоціювати значення з кожним елементом множини. Використання мапи виглядає подібним до використання масива, за винятком того, що замість індексування цілими числами, рахуючи від <code>0</code>, ви можете використовувати любий різновид ключів. Якщо ви імпортуєте ім'я зі змінного пакунку, ви можете створити порожню змінну мапу, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що коли ви створюєте мапу, ви маєте задати два типи. Перший тип для ключів мапи, та другий для значень. В цьому випадку ключі є рядками, та значення є цілими. Встановлення значень для мапи виглядає подібно для встановлення елементів в масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="s">&quot;there&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">hello</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">there</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, читання мапи подібне до читання масиву:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Складаючи все це разом, ось метод, що підраховує число раз, скільки разів кожне слово страпляється в рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">countWords</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
          <span class="k">for</span> <span class="o">(</span><span class="n">rawWord</span> <span class="k">&lt;-</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;[ ,!.]+&quot;</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">word</span> <span class="k">=</span> <span class="n">rawWord</span><span class="o">.</span><span class="n">toLowerCase</span>
            <span class="k">val</span> <span class="n">oldCount</span> <span class="k">=</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">counts</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="n">counts</span><span class="o">(</span><span class="n">word</span><span class="o">)</span>
              <span class="k">else</span> <span class="mi">0</span>
            <span class="n">counts</span> <span class="o">+=</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">oldCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
          <span class="o">}</span>
          <span class="n">counts</span>
        <span class="o">}</span>

<span class="n">countWords</span><span class="k">:</span> <span class="o">(</span><span class="kt">text:</span>
<span class="kt">String</span><span class="o">)</span><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">countWords</span><span class="o">(</span><span class="s">&quot;See Spot run! Run, Spot. Run!&quot;</span><span class="o">)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">spot</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">see</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці підрахунки, ви можете бачити, що цей текст каже більше про біг, та меньше про бачення.</p></div>
<div class="paragraph"><p>Спосіб, як робить цей код, в тому, що змінна мапа на ім'я <code>counts</code> відзеркалює кожне слово на кількість раз, скількі воно трапляється в тексті. Для кожного слова в тексті спочатку шукається старий лічильник, що збільшується на одиницю, та потім зберігається назад в <code>counts</code>. Зауважте використання <code>contains</code> для перевірки, чи слово вже відоме, чи ні. Якщо <code>counts.contains(word)</code> не є <code>true</code>, тоді слово ще невідоме, та для лічильника використовується нуль.</p></div>
<div class="paragraph"><p>Багато з загально уживаних методів, на обох, змінних та незмінних мап, показані в Таблиці Table 17.2.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.2 Загальні операції для мап</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>val nums = Map("i" -&gt; 1, "ii" -&gt; 2)</code></p></td>
<td align="left" valign="top"><p class="table">Створює незмінну мапу (<code>nums.toString</code> повертає <code>Map(i -&gt; 1, ii -
&gt; 2))</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums + ("vi" -&gt; 6)</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент (повертає <code>Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums - "ii"</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент (повертає <code>Map(i -&gt; 1)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums ++ List("iii" -&gt; 3, "v" -&gt; 5)</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементів (повертає <code>Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums -- List("i", "ii")</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька елементів (повертає <code>Map()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.size</code></p></td>
<td align="left" valign="top"><p class="table">Повертає розмір мапи (повертає <code>2</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.contains("ii")</code></p></td>
<td align="left" valign="top"><p class="table">Перевіряє входження (повертає <code>true</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums("ii")</code></p></td>
<td align="left" valign="top"><p class="table">Отримує значення вказаного ключа (повертає <code>2</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.keys</code></p></td>
<td align="left" valign="top"><p class="table">Повертає ключі (повертає <code>Iterable</code> по рядках <code>"i"</code> та <code>"ii"</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.keySet</code></p></td>
<td align="left" valign="top"><p class="table">Повертає ключі як множину (повертає <code>Set(i, ii)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.values</code></p></td>
<td align="left" valign="top"><p class="table">Повертає значення (повертає <code>Iterable</code> по цілим <code>1</code> та <code>2</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.isEmpty</code></p></td>
<td align="left" valign="top"><p class="table">Визначає, чи мапа порожня (повертає <code>false</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>import scala.collection.mutable</code></p></td>
<td align="left" valign="top"><p class="table">Спрощує досутп до змінних колекцій</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>val words = mutable.Map.empty[String, Int]</code></p></td>
<td align="left" valign="top"><p class="table">Створює порожню змінну мапу</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words += ("one" -&gt; 1)</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент мапи з <code>"one"</code> до <code>1</code> (<code>words.toString</code> повертає <code>Map(one -&gt; 1)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words -= "one"</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент мапи, якщо він існує (<code>words.toString</code> повертає <code>Map()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words ++= List("one" -&gt; 1, "two" -&gt; 2, "three" -&gt; 3)</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементів мапи (<code>words.toString</code> повертає <code>Map(one -
&gt; 1, two -&gt; 2, three -&gt; 3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words --= List("one", "two")</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька об'єктів (<code>words.toString</code> повертає <code>Map(three -&gt; 3)</code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="______8">Множини та мапи по замовчанню</h3>
<div class="paragraph"><p>Для більшості застосувань реалізації змінних та незмінних множин та мап, запроваджені фабриками <code>Set()</code>, <code>scala.collection.mutable.Map()</code>, тощо, скоріше будуть достатніми. Реалізації, проваджені ціми фабриками, використовують алгоритм швидкого пошуку, який звичайно задіє хеш таблицю, так що вони можуть швико вирішити, є або ні об'єкт в колекції.</p></div>
<div class="paragraph"><p>Наприклад, метод фабрики <code>scala.collection.mutable.Set()</code> повертає  <code>scala.collection.mutable.HashSet</code>, що внутрішньо використовує хеш таблицю. Подібно, фабрика <code>scala.collection.mutable.Map()</code> повертає <code>scala.collection.mutable.HashMap</code>.</p></div>
<div class="paragraph"><p>Історія для незмінних множин та мап трохи складніша. Наприклад, клас, що повертається методом фабрики <code>scala.collection.immutable.Set()</code>, залежить від того, як багато елементів ви передасте йому, як показано в Таблиці 17.3. Для множин, меньших за п'ять елементів, існують окремі класи, ексклюзивно призначені для множин кожного окремого розміру, що використовуються для максимальної продуктивності. Однак, коли ви запитуєте множину, що має п'ять або більше елементів, метод фабрики буде повертати реалізацію, що використовує хеш дерева.</p></div>
<div class="paragraph"><p>Подібно до цього, метод фабрики <code>scala.collection.immutable.Map()</code> буде повертати інший клас, в залежності від того, як багато пар ключ-значення ви передасте йому, як показано в Таблиці 17.4. Так само, як з множинами, для незмінних мап з меньше ніж п'ятьма елементами виділяється окремий клас, ексклюзивно призначений для мап окремого розміру, що використовується для максимальної продуктивності. Однак, коли мапа має п'ять або більше пар ключ-значення, буде використаний незмінний <code>HashMap</code>.</p></div>
<div class="paragraph"><p>Реалізація незмінних класів по замовчанню, показаних в Таблиці 17.3 та 17.4, роблять разом для надання вам максимальної продуктивності. Наприклад, якщо ви додасте елемент до <code>EmptySet</code>, він поверне <code>Set1</code>. Якщо ви додасте елемент до <code>Set1</code>, він буде повертати <code>Set2</code>. Якщо ви потім видалите елемент з <code>Set2</code>, ви отримаєте новий <code>Set1</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.3 Реалізації незмінних множин по замовчанню</caption>
<col width="14%" />
<col width="85%" />
<thead>
<tr>
<th align="center" valign="top">Число елементів </th>
<th align="center" valign="top">Реалізація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.EmptySet</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set1</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set2</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set3</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set4</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">&gt;=5</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.HashSet</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.4 Реалізації незмінних мап по замовчанню</caption>
<col width="14%" />
<col width="85%" />
<thead>
<tr>
<th align="center" valign="top">Число елементів </th>
<th align="center" valign="top">Реалізація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.EmptyMap</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map1</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map2</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map3</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map4</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">&gt;=5</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.HashMap</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_____14">Впорядковані множини та мапи</h3>
<div class="paragraph"><p>Часом вам може знадобитись множина або мапа, чий ітератор повертає елементи в певному порядку. Для ціх цілей бібліотека колекцій Scala провадить трейти <code>SortedSet</code> та <code>SortedMap</code>. Ці трейти реалізовані класами <code>TreeSet</code> та <code>TreeMap</code>, що викорисотвують дерева <em>червоне-чорне</em> для зберігання елементів (в випадку <code>TreeSet</code>) або ключів (в випадку <code>TreeMap</code>) впорядкованими. Порядок визначається трейтом <code>Ordered</code>, що або зміксований в тип множини чи тип ключа мапи, або має до нього неявне перетворення. Ці класи мають тільки незмінні варіанти. Ось деякі приклади <code>TreeSet</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ts</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">ts</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="sc">&#39;f&#39;</span><span class="o">,</span> <span class="sc">&#39;u&#39;</span><span class="o">,</span> <span class="sc">&#39;n&#39;</span><span class="o">)</span>
<span class="n">cs</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та ось декілька прикладів <code>TreeMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.immutable.TreeMap</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeMap</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">tm</span> <span class="k">=</span> <span class="nc">TreeMap</span><span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">)</span>
<span class="n">tm</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">tm</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">tm</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_3______">17.3 Вибір між змінними та незмінними колекціями</h2>
<div class="sectionbody">
<div class="paragraph"><p>Для деяких пробелем змінні колекції роблять краще, тоді як для інших незмінні колекції роблять краще. Коли є сумніви, краще почати з незмінної колекції, та потім змінити її, якщо буде потреба, оскількі незмінні колекції легші для розуміння, ніж змінні.</p></div>
<div class="paragraph"><p>Також може бути вартим іноді іти в зворотньому напрямку. Якщо ви знайдете якійсь код, що використовує змінні колекції, та стає складним для розуміння, поміркуйте, чи не допоможе зміна деяких з колекцій на незмінні альтернативи. Зокрема, якщо ви турбуєтесь щодо створення копій змінних колекцій тільки в вірних місцях, або думаєте про те, хто "володіє" або "містить" змінну колекцію, розгляньте перехід деяких колекцій на їх незмінних двійників.</p></div>
<div class="paragraph"><p>Крім того, що про них легше розмірковувати, незмінні колекції можуть зазвичай зберігатись більш компактно, ніж змінні, якщо кількість елементів, що зберігається в колекції, невелика. Наприклад, примірник порожньої змінної мапи в її представленні за замовчанням  <code>HashMap</code>, займає приблизно 80 байт, та на 16 ще додаються для кожного елемента, що додається. Порожня незмінна <code>Map</code> є єдиним об'єктом, що поділяється між всіма посиланнями, так що посилання на неї коштує рівно стільки, скільки саме поле вказівника.</p></div>
<div class="paragraph"><p>Ще більше, бібліотека колекцій Scala наразі зберігає незмінні мапи до чотирьох елементів як єдиний об'єкт, що типово займає від 16 до 40 байтів, в залежності від числа елементів, що зберігаються в колекції.<span class="footnote"><br />["Єдиний об'єкт" є примірник <code>Set1</code> до <code>Set4</code>, або <code>Map1</code> до <code>Map4</code>, як показано в Таблиці 17.3 та 17.4.]<br /></span> Так що для малих мап та множин незмінні версії значно більш компактні, ніж змінні. Беручи до уваги, що багато колекцій є малими, перехід на незмінні варіанти може привнести важливі збереження простору та переваги продуктивності.</p></div>
<div class="paragraph"><p>Щоб спростити перехід від незмінних до змінних колекцій, та навпаки, Scala провадить деякий синтаксичний цукор. Навіть зважаючи, що незмінні множини та мапи не підтримують дійсний метод <code>+=</code>, Scala дає корисну альтернативну інтерпретацію до <code>+=</code>. Кожного разу, коли ви пишете <code>a += b</code>, і <code>a</code> не підтримує метод з ім'ям <code>+=</code>, Scala спробує інтерпретувати це як <code>a = a + b</code>.</p></div>
<div class="paragraph"><p>Наприклад, незмінні множини не підтримують оператор <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Nancy&quot;</span><span class="o">,</span> <span class="s">&quot;Jane&quot;</span><span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Jane</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">+=</span> <span class="s">&quot;Bob&quot;</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">+=</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
              <span class="n">people</span> <span class="o">+=</span> <span class="s">&quot;Bob&quot;</span>
                     <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак, якщо ви декларуєте <code>people</code> як <code>var</code>, замість <code>val</code>, тоді колекція може бути "оновлена" за допомогою оператора <code>+=</code>, навіть якщо вона незмінна. Спочатку буде створена нова колекція, та потім <code>people</code> буде переприсвоєне, щоб посилатись на нову колекцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Nancy&quot;</span><span class="o">,</span> <span class="s">&quot;Jane&quot;</span><span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Jane</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">+=</span> <span class="s">&quot;Bob&quot;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Jane</span><span class="o">,</span> <span class="nc">Bob</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Після цієї серії тверджень, змінна <code>people</code> посилається на нову незмінну множину, що містить доданий рядок, <code>"Bob"</code>. Та сама ідея застосовується до любого метода, що завершується на <code>=</code>, не тільки до метода <code>+=</code>. Ось той самий синтаксис, використаний з оператором <code>-=</code>, що видаляє елемент з множини, та до оператора <code>++=</code>, що додає колекцію елементів до множини:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">-=</span> <span class="s">&quot;Jane&quot;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;Tom&quot;</span><span class="o">,</span> <span class="s">&quot;Harry&quot;</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Bob</span><span class="o">,</span> <span class="nc">Tom</span><span class="o">,</span> <span class="nc">Harry</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб подивитись, як це може бути корисне, знову розглянемо наступний приклад <code>Map</code> з Розділу 1.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код використовує незмінні колекції. Якщо ви бажаєте спробувати використання змінних колекцій замість цього, все що треба, це імпортувати змінну версію <code>Map</code>, таким чином перекриваючи імпорт по замовчанню незмінної <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.Map</span> <span class="c1">// єдина потрібна зміна!</span>
<span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Не всі приклади так само прості для конвертації, але особлива трактовка методів, що закінчується на знак рівності, часто зменшує кількість коду, що потребує змін.</p></div>
<div class="paragraph"><p>До ручі, цей синтаксичний підхід робить з любим типом значення, не тільки для колекцій. Наприклад, ось як він робить, використаний для чисел з плаваючою крапкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">roughlyPi</span> <span class="k">=</span> <span class="mf">3.0</span>
<span class="n">roughlyPi</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">roughlyPi</span> <span class="o">+=</span> <span class="mf">0.1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">roughlyPi</span> <span class="o">+=</span> <span class="mf">0.04</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">roughlyPi</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.14</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект цього розширення подібний до операторів присвоєння Java (<code>+=</code>, <code>-=</code>, <code>*=</code>, тощо), але він більш загальний, бо кожний оператор, що закінчується на <code>=</code>, може бути конвертований.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_17_4__">17.4 Ініціалізація колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви вже бачили до цього, найбільш загальний спосіб створити та ініціалізувати колекцію є передати початкові елементи до метода фабрики на об'єкті компанйоні обраної колекції. Ви просто покладаєте елементи в дужки після імені об'єкта компанйона, та компілятор Scala буде трансформувати його на виклик метода <code>apply</code> на цьому об'єкті компанйоні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="sc">&#39;c&#39;</span><span class="o">)</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;hi&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&quot;there&quot;</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">hi</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">there</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Array</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча більш часто ви можете дозволити компілятору Scala виводити тип елементів колекції від елементів, що ви передаєте до його методу фабрики, іноді ви можете бажати створити колекцію, але вказати інший тип, ніж той, що буде обирати компілятор. Це особливо важливо для змінних колекцій. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stuff</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">stuff</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stuff</span> <span class="o">+=</span> <span class="s">&quot;abracadabra&quot;</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">abracadabra</span><span class="err">&quot;</span><span class="o">)</span>
<span class="kt">required:</span> <span class="kt">Int</span>
            <span class="n">stuff</span> <span class="o">+=</span> <span class="s">&quot;abracadabra&quot;</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут проблема в тому, що <code>stuff</code> отримав тип елементу <code>Int</code>. Якщо ви бажаєте, щоб тип елементу був <code>Any</code>, вам треба сказати це явно, поклавши тип елементу в прямокутні дужки, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stuff</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">Any</span><span class="o">](</span><span class="mi">42</span><span class="o">)</span>
<span class="n">stuff</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша особлива ситуація виникає, коли ви бажаєте ініціалізувати колекцію за допомогою іншої колекції. Наприклад, уявімо, що ви маєте список, але ви бажаєте мати <code>TreeSet</code>, що містить елементи з цього списку. Ось список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">colors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;blue&quot;</span><span class="o">,</span> <span class="s">&quot;yellow&quot;</span><span class="o">,</span> <span class="s">&quot;red&quot;</span><span class="o">,</span> <span class="s">&quot;green&quot;</span><span class="o">)</span>
<span class="n">colors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">yellow</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не можете передати список <code>colors</code> до метода фабрики для <code>TreeSet</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">treeSet</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="n">colors</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">implicit</span> <span class="kt">Ordering</span> <span class="kt">defined</span> <span class="kt">for</span>
<span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">].</span>
       <span class="k">val</span> <span class="n">treeSet</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="n">colors</span><span class="o">)</span>
                            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього вам треба створити порожній <code>TreeSet[String]</code>, та додати до нього елементи списку за допомогою оператора <code>TreeSet</code> <code>++</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">treeSet</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]()</span> <span class="o">++</span> <span class="n">colors</span>
<span class="n">treeSet</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="______9">Конвертація до масиву або списку</h3>
<div class="paragraph"><p>З іншого боку, якщо вам треба ініціалізувати список або масив з іншої колекції, це досить прямолінійно. Як ви бачили до цього, щоб ініціалізувати новий список з іншої колекції, просто виконайте на цій колекції метод <code>toList</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">treeSet</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або, якщо вам треба масив, викличте <code>toArray</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">treeSet</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що хоча оригінальний список <code>colors</code> не був впорядкований, елементи в списку, спродукованому через виклик <code>toList</code> на <code>TreeSet</code>, ідуть в алфавітному порядку. Коли ви викликаєте <code>toList</code> або <code>toArray</code> на колекції, порядок елементів в отриманому списку або масиві буде той самий, що і порядок елементів, спродукований ітератором, отриманим через виклик <code>elements</code> на цій колекції. Оскільки ітератор <code>TreeSet[String]</code> буде продукувати рядкі в алфавітному порядку, ці рядкі будуть з'являтись в алфавітному порядку в списку, отриманому від визову <code>toList</code> на цьому <code>TreeSet</code>.</p></div>
<div class="paragraph"><p>Однак майте на увазі, що перетворення між списками та масивами звичайно потребує копіювання всіх елементів в колекції, і, таким чином, можуть бути повільними для великих колекцій. Хоча іноді вам треба зробити це через існуюче API. Більше того, багато колекцій мають лише декілька елементів, і в цьому випадку існує лише мала втрата швидкості.</p></div>
</div>
<div class="sect2">
<h3 id="________">Перетворення між змінними та незмінними множинами або мапами</h3>
<div class="paragraph"><p>Інша ситуація, що часом постає, є потреба конвертувати змінну множину або мапу до незмінної, або <em>vice versa</em>. Щоб досягти цього, ви можете використати прийом, показаний на попередній сторінці, для ініціалізації <code>TreeSet</code> елементами списку. Створіть колекцію нового типу, використовуючи метод <code>empty</code>, та потім додайте нові елементи, використовуючи або <code>++</code>, або <code>++=</code>, що відповідає до типу цільової колекції. Ось як ви конвертуєте незмінний <code>TreeSet</code> з попереднього прикладу до змінної множини, та назад до незмінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">treeSet</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mutaSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">++=</span> <span class="n">treeSet</span>
<span class="n">mutaSet</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">immutaSet</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">++</span> <span class="n">mutaSet</span>
<span class="n">immutaSet</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете використовувати той самий прийом для конвертації змінних та незмінних мап:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">muta</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;i&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;ii&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">muta</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">ii</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">immu</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span> <span class="o">++</span> <span class="n">muta</span>
<span class="n">immu</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">ii</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_5_">17.5 Тапли</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як описане в Кроці 9 в Главі 3, типл комбінує фіксоване число елементів разом, так що вони можуть бути передані будь-куди як ціле. На відміну від масиву або списка, тапл може зберігати об'єкти різних типів. Ось приклад тапла, що містить ціле, рядок та консоль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="nc">Console</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тапли вберігають вам від нудьги визначати прості класи даних. Навіть зважаючи, що визначення класу вже просте, воно все ще потребує мінімальних зусиль, що іноді на до чого. Тапли вберігають вас від зусиль обирати ім'я файлу, обирати поле видимості, в якому треба визначити клас, та обрати імена для членів класу. Якщо ваш клас просто містить ціле та рядок, не додасться ясності, якщо ви визначите клас на ім'я <code>AnIntegerAndAString</code>.</p></div>
<div class="paragraph"><p>Оскільки тапли можуть комбінувати об'єкти різних типів, тапли не наслідують від <code>Traversable</code>. Якщо ви бажаєте згруаувати рівно одне ціле і один рядок, тоді вам треба тапл, не <code>List</code> або <code>Array</code>.</p></div>
<div class="paragraph"><p>Загальне застосування таплів є повернення декількох значень з метода. Наприклад, ось метод, що знаходить найдовше слово в колекції, що також повертає індекс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">longestWord</span><span class="o">(</span><span class="n">words</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">word</span> <span class="k">=</span> <span class="n">words</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">var</span> <span class="n">idx</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">words</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">word</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">word</span> <span class="k">=</span> <span class="n">words</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="n">idx</span> <span class="k">=</span> <span class="n">i</span>
  <span class="o">}</span>
  <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">idx</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад, що використовує цей метод:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">longest</span> <span class="k">=</span>
         <span class="n">longestWord</span><span class="o">(</span><span class="s">&quot;The quick brown fox&quot;</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span>
<span class="n">longest</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">quick</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>longestWord</code> обчислює два елементи: <code>word</code>, найдовше слово в масиві, та <code>idx</code>, індекс цього слова. Щоб утримувати речі простими, функція вважає, що в списку є хоча б одне слово, і він вирішує спірні питання, обираючи слово, що іде раніше в списку. Коли функція обирає, яке слово та індекс повертати, вона повертає обоє з них разом, використовуючи синтаксис тапла <code>(word, idx)</code>. Щоб отримати доступ до елементів в таплі, ви можете використати метод <code>_1</code> для доступу до першого елементу, <code>_2</code> для доступу до другого, і так далі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">longest</span><span class="o">.</span><span class="n">_1</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">quick</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">longest</span><span class="o">.</span><span class="n">_2</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Додатково, ви можете присвоїти кожний елемент тапла до власної змінної,<span class="footnote"><br />[Насправді, цей синтаксис є особливим випадком порівняння шаблонів, як описано в деталях в Розділі 15.7.]<br /></span> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">idx</span><span class="o">)</span> <span class="k">=</span> <span class="n">longest</span>
<span class="n">word</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">quick</span>
<span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">word</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">quick</span>
</pre></div></div></div>
<div class="paragraph"><p>Доречі, якщо ви відкинете дужки, ви отримаєте інший варіант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">word</span><span class="o">,</span> <span class="n">idx</span> <span class="k">=</span> <span class="n">longest</span>
<span class="n">word</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">quick</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="n">idx</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">quick</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей синтаксис дає <em>множинні визначення</em> того самого виразу. Кожна змінна ініціалізована власним обчисленням виразу в правій стороні. Те, що в даному випадку цей вираз обчислюється до тапла, не має значення. Обоє змінні ініціалізуються таплом, як цілим. Дивіться Главу 18 для деяких прикладів, де множинні визначення є зручними.</p></div>
<div class="paragraph"><p>В якості попередження, тапли загалом дуже прості в використанні. Тапли чудові, коли ви комбінуєте дані, що не мають значення, крім "якесь A та якесь B." Однак, коли комбінація має якесь значення, або ви бажаєте додати якісь методи до комбінації, краще піти далі, та створити клас. Наприклад, не використовуйте 3-місний тапл для комбінації місяця, дня та року. Створіть клас <code>Date</code>. Це зробить ваші наміри явними, що одночасно прояснює код для людей, та дає компілятору та мові можливість допомогти вам відловлювати помилки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_17_6_">17.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала огляд бібліотеки колекцій Scala, та найбільш важливі класи та трейти в ній. З цією основою ви маєте бути в змозі робити ефективно зі Scala колекціями, та знати, куди дивитись в Scaladoc, якщо вам треба більше інформації. Для більш детальної інформації щодо Scala колекцій, дивіться далі, в Главі 24 та Главі 25. До того часу, в наступній главі ми перенесемо нашу увагу від бібліотеки Scala назад на мову, та обговоримо підтримку Scala для змінних об'єктів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__18_2">Глава 18</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____19">Змінні об'єкти</h1>
<div class="paragraph"><p>В попередньому розділі ми звернули увагу на функціональні (незмінні) об'єкти. Ми зробили це, оскільки ідея об'єктів без жодного змінного стану заслуговує бути краще відомою. Однак це також чудово можливо визначати в Scala об'єкти зі змінним станом. Такі змінні об'єкти часто спливають природно, коли ви бажаєте змоделювати об'єкти в реальному світі, що змінюються з часом.</p></div>
<div class="paragraph"><p>Ця глава пояснює, що таке змінні об'єкти, та що провадить Scala в термінах синтаксису для їх вираження. Ми також введемо більше дослідження симуляції дискретних подій, що включатиме змінні об'єкти, так само, як побудову внутрішнього DSL для визначення цифрових схем для симуляції.</p></div>
<div class="sect1">
<h2 id="_18_1_____">18.1 Що робить об'єкт змінним?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете спостерігати принципову різницю між чисто функціональним об'єктом і змінним об'єктом, навіть без погляду на реалізацію об'єкта. Коли ви викликаєте метод або отримуєте поле на деякому функціональному об'єкті, ви будете завжди отримувати один той самий результат.</p></div>
<div class="paragraph"><p>Наприклад, беручи список символів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="sc">&#39;c&#39;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>застовування <code>cs.head</code> буде завжди повертати <code>'a'</code>. Це буде саме так, навіть якщо відбудеться довільне число операцій зі списком <code>cs</code> між місцем, де він визначений, та місцем, де відбувається доступ до <code>cs.head</code>.</p></div>
<div class="paragraph"><p>З іншого боку, для зміноого об'єкту результат виклику метода або доступ до поля може залежати  від того, які операції до цього застосовувались до об'єкту. Гарний приклад змінного об'єкту є банківській рахунок. Лістинг 18.1 показує спрощену реалізацію банківського рахунку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BankAccount</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">bal</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">balance</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">bal</span>

  <span class="k">def</span> <span class="n">deposit</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">bal</span> <span class="o">+=</span> <span class="n">amount</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">withdraw</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">amount</span> <span class="o">&gt;</span> <span class="n">bal</span><span class="o">)</span> <span class="kc">false</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="n">bal</span> <span class="o">-=</span> <span class="n">amount</span>
      <span class="kc">true</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.1 - Змінний клас банківського рахунку.</p></div>
<div class="paragraph"><p>Клас <code>BankAccount</code> визначає приватну змінну, <code>bal</code>, і три публічні методи: <code>balance</code> повертає поточний баланс; <code>deposit</code> додає сумму до <code>bal</code>; та <code>withdraw</code> намагається списати надану сумму з <code>bal</code>, при цьому вважаючи, що залишковий баланс не буде від'ємним. Значення, що повертає <code>withdraw</code>, є <code>Boolean</code>, вказуючи, чи запитані фонди були вдало списані.</p></div>
<div class="paragraph"><p>Навіть якщо ми нічого не знаємо про внутрішню роботу класу <code>BankAccount</code>, ви все ще можете сказати, що <code>BankAccounts</code> є змінними об'єкти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">account</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BankAccount</span>
<span class="n">account</span><span class="k">:</span> <span class="kt">BankAccount</span> <span class="o">=</span> <span class="nc">BankAccount</span><span class="k">@</span><span class="mi">21</span><span class="n">cf775d</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">account</span> <span class="n">deposit</span> <span class="mi">100</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">account</span> <span class="n">withdraw</span> <span class="mi">80</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">account</span> <span class="n">withdraw</span> <span class="mi">80</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що два останні списання в попередній взаємодії повернули різні результати. Перша операція списання повернула <code>true</code>, оскільки банківський рахунок містив достатньо коштів, щоб дозволити списання. Друга операція, хоча така сама, як і перша, повертає <code>false</code>, оскільки баланс на рахунку було зменшено, так що він більше не покриває запитані кошти. Так що, як це зрозуміло, банківські рахунки мають змінній стан, оскільки та сама операція може повертати різні результати в різний час.</p></div>
<div class="paragraph"><p>Ви можете подумати, що змінність <code>BankAccount</code> безпосередньо наочна, оскільки він містить визначення <code>var</code>. Змінність та <code>var</code> звичайно ідуть рука в руку, але речі не завжди так чітко окреслені. Наприклад, клас може бути змінним без визначення або наслідування любих <code>var</code>, оскільки він перенаправляє викликів методів до інших об'єктів, що мають змінний стан. Зворотнє також можливе: клас може містити <code>var</code>, та все одне залишатись чисто функціональним. Прикладом може бути клас, що кешує результат коштовної операції в полі для цілей оптимізації. Щоб зрозуміти приклад, розглянемо наступний неоптимізований клас <code>Keyed</code> з коштовною операцією <code>computeKey</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Keyed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">computeKey</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span> <span class="c1">// це займає деякий час</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>За умови, що <code>computeKey</code> не читає та не записує жодні <code>var</code>, ви можете зробити <code>Keyed</code> більш ефективним через додавання кешу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MemoKeyed</span> <span class="k">extends</span> <span class="nc">Keyed</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">keyCache</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">computeKey</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">keyCache</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="n">keyCache</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">computeKey</span><span class="o">)</span>
    <span class="n">keyCache</span><span class="o">.</span><span class="n">get</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Використання <code>MemoKeyed</code> замість <code>Keyed</code> може прискорити речі, бо коли результат операції <code>computeKey</code> запитується в  другий раз, замість виконання <code>computeKey</code> ще раз може бути повернене значення, збережене в полі <code>keyCache</code>. Але, за винятком цього прискорення, поведінка класу <code>Keyed</code> та <code>MemoKeyed</code> в точності така сама. Відповідно, якщо <code>Keyed</code> є чисто функціональним, так само буде <code>MemoKeyed</code>, навіть якщо він містить переприсвоювану змінну.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_2____">18.2 Переприсвоєння змінних та властивостей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете виконати дві фундаментальні операції на переприсвоюваних змінних: отримати її значення, або встановити її в нове значення. В бібліотеках, таких, як JavaBeans, ці операції часто інкапсульовані в окремі методи геттера та сеттера, що повинні бути визначені явно.</p></div>
<div class="paragraph"><p>В Scala кожна <code>var</code>, що є не-приватним членом деякого об'єкту, одночасно неявно визначає методи геттера та сеттера. Однак ці геттери та сеттери іменуються інакше, ніж за Java домовленістю. Геттер <code>var x</code> називається просто <code>x</code>, тоді як сеттер називається <code>x_=</code>.</p></div>
<div class="paragraph"><p>Наприклад, якщо воно з'являється в класі, визначення <code>var</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">hour</span> <span class="k">=</span> <span class="mi">12</span>
</pre></div></div></div>
<div class="paragraph"><p>генерує геттер <code>hour</code>, та сеттер <code>hour_=</code>, на додаток до переприсвоюваного поля. Поле завжди маркується як <code>private[this]</code>, що означає, що воно може отримувати доступ тільки з об'єкта, що містить його. З іншого боку, геттер та сеттер отримують ту саму оглядовість, що і оригінальна <code>var</code>. Якщо визначення <code>var</code> є публічним, таким будуть його геттер та сеттер. Якщо воно <code>protected</code>, вони також будуть <code>protected</code>, і так далі.</p></div>
<div class="paragraph"><p>Наприклад, розглянемо клас <code>Time</code>, показаний на Лістингу 18.2, що визначає дві публічні змінні, з назвами <code>hour</code> та <code>minute</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">var</span> <span class="n">minute</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.2 - Клас з публічними <code>var</code>.</p></div>
<div class="paragraph"><p>Ця реалізація в точності еквівалентна до визначення класу, показаному в Лістингу 18.3. В визначенні, показаному в Лістингу 18.3, імена локальних полів <code>h</code> та <code>m</code> обрані довільно, так щоб вони не стикались з любими іменами, що вже використовуються.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">h</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.3 - Як публічні <code>var</code> розширюються в методи геттерів та сеттерів.</p></div>
<div class="paragraph"><p>Цікавий аспект щодо цього розширення <code>var</code> в геттери та сеттери в тому, що ви за бажанням також можете визначити геттери та сеттери напряму, замість визначення <code>var</code>. Через визначення ціх методів напряму ви можете інтерпретувати операції доступу до змінної, або присвоєння змінної, як вам завгодно. Наприклад, варіант класу <code>Time</code>, показаний в Лістингу 18.4, містить вимоги, щоб перехоплювати всі присвоєння до годин та хвилин з нелегальними значеннями.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>

  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">12</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">0</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="o">)</span>
    <span class="n">h</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span> <span class="k">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="o">)</span>
    <span class="n">m</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.4 - Визначення методів геттера та сеттера напряму.</p></div>
<div class="paragraph"><p>Деякі мови мають спеціальні синтаксичні конструкції для змінно-подібних кількостей, що не є звичайними змінними, де їх сеттери та геттери можуть бути перевизначені. Наприклад, C# має властивості, що виконують цю роль. Ефективно, довленість Scala завжди інтерпретувати змінну як пару з сеттера та геттера надає вам ті самі можливості, що і властивості C#, без потреби в спеціальному синтаксисі.</p></div>
<div class="paragraph"><p>Властивості можуть служити для багатьох різних призначень. В прикладі, показаному в Лістингу 18.4, сеттери примушують виконання інваріантів, таким чином захищаючи змінну від присвоєння нелегальних значень. Також ви можете використовувати властивість для журналювання всіх доступів до сеттера та геттера змінної. Або ви можете інтегрувати змінні з подіями, наприклад, для нотифікації деяких методів підписчикив, кожного разу, коли змінна модифікується (ви побачите приклади цього в Главі 35).</p></div>
<div class="paragraph"><p>Також можливо, і іноді корисно, визначити геттер та сеттер без асоційованого поля. Наприклад, Лістинг 18.5 показує клас <code>Thermometer</code>, що інкапсулює змінну <code>temperature</code>, що може бути прочитана та оновлена. Температури можуть бути виражені в градусах Цельсія або Фаренгейта. Цей клас дозволяє вам отримати та встановити температуру в будь-яких одиницях.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Thermometer</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="k">_</span>

  <span class="k">def</span> <span class="n">fahrenheit</span> <span class="k">=</span> <span class="n">celsius</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span>

  <span class="k">def</span> <span class="n">fahrenheit_=</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">celsius</span> <span class="k">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">-</span> <span class="mi">32</span><span class="o">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">fahrenheit</span> <span class="o">+</span> <span class="s">&quot;F/&quot;</span> <span class="o">+</span> <span class="n">celsius</span> <span class="o">+</span> <span class="s">&quot;C&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.5 - Визначення геттера та сеттера без асоційованого поля.</p></div>
<div class="paragraph"><p>Перший рядок тіла цього класу визначає <code>var</code>, <code>celsius</code>, що буде містити температуру в градусах Цельсія. Змінна <code>celsius</code> напочатку встановлена в значення по замовчанню, через вказання <code>_</code> як "ініціалізуючого значення" змінної. Більш точно, ініціалізатор <code>= _</code> поля присвоює нульове значення до цього поля. Нульове значення залежить від типу поля. Це <code>0</code> для числових типів, <code>false</code> для логічних, <code>null</code> для типів посилань. Це те саме, якби та сама змінна була визначена в Java без ініціалізатора.</p></div>
<div class="paragraph"><p>Зауважте, що ви не можете просто відкинути ініціалізатор <code>= _</code> в Scala. Якщо ви напишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span>
</pre></div></div></div>
<div class="paragraph"><p>це декларує абстрактну змінну, не неініціалізовану зміну.<span class="footnote"><br />[Абстрактні змінні будуть пояснені в Главі 20.]<br /></span></p></div>
<div class="paragraph"><p>За визначенням змінної <code>celsius</code> іде геттер, <code>fahrenheit</code>, та сеттер, <code>fahrenheit_=</code>, що отримує доступ до такої самої температури, але в градусах Фаренгейту. Немає окремого поля, що містить поточне значення температури в фаренгейтах. Замість цього, методи геттера та сеттера для значень фаренгейта автоматично конвертують з градусів Цельсія, відповідно. Ось приклад взаємодії з об'єктом <code>Thermometer</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Thermometer</span>
<span class="n">t</span><span class="k">:</span> <span class="kt">Thermometer</span> <span class="o">=</span> <span class="mf">32.0F</span><span class="o">/</span><span class="mf">0.0</span><span class="n">C</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">celsius</span> <span class="k">=</span> <span class="mi">100</span>
<span class="n">t</span><span class="o">.</span><span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">100.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Thermometer</span> <span class="o">=</span> <span class="mf">212.0F</span><span class="o">/</span><span class="mf">100.0</span><span class="n">C</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span><span class="o">.</span><span class="n">fahrenheit</span> <span class="k">=</span> <span class="o">-</span><span class="mi">40</span>
<span class="n">t</span><span class="o">.</span><span class="n">fahrenheit</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="o">-</span><span class="mf">40.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Thermometer</span> <span class="o">=</span> <span class="o">-</span><span class="mf">40.0F</span><span class="o">/-</span><span class="mf">40.0</span><span class="n">C</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_3____">18.3 Дослідження: симуляція дескретних подій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Залишок цієї глави, поміж іншим, показує розширений приклад, як змінні об'єкти можуть бути комбіновані зі значеннями першокласних функцій в цікавий спосіб. Ви побачите розробку та реалізацію симулятора для цифрових пристроїв. Це завдання розбите на декілька субпроблем, кожне з яких цікаві самі по собі.</p></div>
<div class="paragraph"><p>Спочатку, ви побачите невелику мову для цифрових пристроїв. Визначення цієї мови буде висвічувати загальний метод для вбудованих домен-специфічних мов (DSL) в основній мові, як Scala. Друге, ми представимо простий, але загальний фреймворк для симуляції дискретних подій. Його головне завдання буде відстеження дій, що виконуються в симульованому часу. Нарешті, ми покажемо, як програми дискретної симуляції можуть бути структуровані та побудовані. Ідея такої симуляції є моделювання фізичних об'єктів через симульовані об'єкти, та використання фреймворка симуляції для моделювання фізичного часу.</p></div>
<div class="paragraph"><p>Приклад взятий з класичного підручника <em>Structure and Interpretation of Computer Programs</em> від Abelson та Sussman [Abe96]. Що тут відрізняється, це те, що мова реалізації є Scala замість Scheme, та що різні аспекти приклада структуровані в шари програмного забезпечення: один для фреймворка симуляції, інший для базового пакунку симуляції схем, третій для бібліотеки визначених користувачем пристроїв, та останній шар для кожного окремого симульованого пристрою. Кожний з рівнів виражений як клас, та більш специфічні шари наслідують від більш загальних.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___35">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>Розуміння симуляції дескретних подій, представленої в цій главі, займе деякий час. Якщо ви відчуваєте, що замість цього бажаєте зайнятись вивченням Scala, безпечно перейти далі, до наступної глави.</p></div>
<div class="paragraph"><p>Малюнок 18.1 - Базові ключі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_4____">18.4 Мова для цифрових пристроїв</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми почнемо з "малої мови" для опису дискретних цифрових пристроїв. Цифровий пристрій побудований з дротів та функціональних блоків. Дроти передають сигнали, що перетворюються функціональними блоками. Сигнали представлені як логічні рівні: <code>true</code> для вімкненого сигналу, <code>false</code> для вимкненого.</p></div>
<div class="paragraph"><p>Малюнок 18.1 показує базові функціональні блоки (або вентилі):</p></div>
<div class="ulist"><ul>
<li>
<p>
<em>Інвертор</em>, що обертає свій сигнал.
</p>
</li>
<li>
<p>
<em>ТА-вентиль</em>, що встановлює свій вихід в кон'юкцію своїх входів.
</p>
</li>
<li>
<p>
<em>АБО-вентиль</em>, що встановлює свій вихід в діз'юкцію своїх входів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ці вентилі достатні для побудови всіх інших функціональних блоків. Ключі мають затримки, так що вихід з вентиля буде змінюватись тільки через деякий час після зміни входу.</p></div>
<div class="paragraph"><p>Ми опишемо елементи цифрової схеми через наступний набір класів та функцій Scala. Перше, існує клас <code>Wire</code> для дротів. Ми можемо конструювати дроти таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
<span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
</pre></div></div></div>
<div class="paragraph"><p>або, еквівалентно, але коротше, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
</pre></div></div></div>
<div class="paragraph"><p>Друге, існують три процедури, що "виготовляють" базові вентилі, що нам знадобляться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span>
<span class="k">def</span> <span class="n">andGate</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span>
<span class="k">def</span> <span class="n">orGate</span><span class="o">(</span><span class="n">o1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">o2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що є незвичним, беручи функціональну схильність Scala, це те, що ці процедури конструюють вентилі як побічний ефект, замість повернення сконструйованих вентилів в якості результата. Наприклад, виклик <code>inverter(a, b)</code> покладає інвертор між дротами <code>a</code> та <code>b</code>. З'ясовується, що таке побічно-ефектне конструювання спрощує конструювання складних пристроїв поступово. Також, хоча методи більш часто мають імена-дієслова, ці називаються як прикметники, що вказує на вентилі, що вони виробляють. Це відображує декларативну природу DSL: це має описувати схему, а не дії по їх створенню.</p></div>
<div class="paragraph"><p>Більш складні функціональні блоки можуть бути побудовані з базових вентилів. Наприклад, метод, показаний в Лістингу 18.6, конструює напів-суматор. Метод <code>halfAdder</code> приймає два входи, <code>a</code> та <code>b</code>, та продукує суму, <code>s</code>, визначене як <code>s = (a + b) % 2</code> та перенос, <code>c</code>, визначене як <code>c = (a + b) / 2</code>. Діаграма напів-суматора показана на Малюнку 18.2.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
  <span class="n">orGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
  <span class="n">andGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
  <span class="n">inverter</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
  <span class="n">andGate</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.6 - Метод <code>halfAdder</code>.</p></div>
<div class="paragraph"><p>Малюнок 18.2 - Схема напів-суматора.</p></div>
<div class="paragraph"><p>Зауважте, що <code>halfAdder</code> є параметризованим функціональним блоком, так само, як три методи, що конструюють примітивні вентилі. Ви можете використовувати метод <code>halfAdder</code> для побудови більш складних схем. Наприклад, Лістинг 18.7 визначає повний однобітний суматор, показаний на Малюнку 18.3, що приймає два входи, <code>a</code> та <code>b</code>, так само, як вхідний перенос, <code>cin</code>, та який продукує на виході <code>sum</code>, визначений як <code>sum = (a + b + cin) % 2</code>, та вихідний перенос, визначений як <code>cout = (a + b + cin) / 2</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cin</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span>
    <span class="n">sum</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cout</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">,</span> <span class="n">c2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
  <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">cin</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">)</span>
  <span class="n">halfAdder</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
  <span class="n">orGate</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">,</span> <span class="n">cout</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.7 - Метод <code>fullAdder</code>.</p></div>
<div class="paragraph"><p>Клас <code>Wire</code> та функції <code>inverter</code>, <code>andGate</code>, та <code>orGate</code> представляють малу мову, за допомогою якої користувачі можуть визначати цифрові пристрої. Це гарний приклад визначення <em>внутрішнього</em> DSL, домен-специфічної мови, визначеної як бібліотека в основній мові, замість бути реалізованій сама по собі.</p></div>
<div class="paragraph"><p>Малюнок 18.3 - Схема повного суматора.</p></div>
<div class="paragraph"><p>Реалізація DSL пристроїв все ще має бути пропрацьована. Оскільки призначення визначення пристрою в DSL є симуляція пристрою. має сенс базувати реалізацію DSL на загальному API для симуляції дескретних подій. Наступні два розділи будуть презентувати спочатку API симуляції, та потім реалізацію DSL пристроїв зверху нього.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_5_api_">18.5 API симуляції</h2>
<div class="sectionbody">
<div class="paragraph"><p>API симуляції показаний в Лістингу 18.8. Він складається з класа <code>Simulation</code> в пакунку <code>org.stairwaybook.simulation</code>. Конкретна бібліотека симуляції наслідує цей клас, та додає до неї домен-специфічну функціональність. Елементи класу <code>Simulation</code> представлені в цьому розділі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Simulation</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">Action</span> <span class="o">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">time</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">action</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">curtime</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">currentTime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">curtime</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">agenda</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">],</span>
      <span class="n">item</span><span class="k">:</span> <span class="kt">WorkItem</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">time</span><span class="o">)</span> <span class="n">item</span> <span class="o">::</span> <span class="n">ag</span>
    <span class="k">else</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">block</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">item</span> <span class="k">=</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">currentTime</span> <span class="o">+</span> <span class="n">delay</span><span class="o">,</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">block</span><span class="o">)</span>
    <span class="n">agenda</span> <span class="k">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">agenda</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">next</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="o">(</span><span class="n">agenda</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">item</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
        <span class="n">agenda</span> <span class="k">=</span> <span class="n">rest</span>
        <span class="n">curtime</span> <span class="k">=</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span>
        <span class="n">item</span><span class="o">.</span><span class="n">action</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">afterDelay</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;*** simulation started, time = &quot;</span> <span class="o">+</span>
        <span class="n">currentTime</span> <span class="o">+</span> <span class="s">&quot; ***&quot;</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">while</span> <span class="o">(!</span><span class="n">agenda</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">next</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.8 - Клас <code>Simulation</code>.</p></div>
<div class="paragraph"><p>Симуляція дискретних подій виконує визначені користувачем дії у вказаний час. Дії, що визначені в субкласі конкретної симуляції, всі поділяють єдиний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Action</span> <span class="o">=</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Це твердження визначає <code>Action</code> як псевдоним для типу процедури, що приймає порожній список параметрів, та повертає <code>Unit</code>. <code>Action</code> є <em>членом типу</em> класу <code>Simulation</code>. Ви можуту думати про це, як про більш читаєме ім'я для типу <code>() =&gt; Unit</code>. Члени типів будуть описані в деталях в Розділі 20.6.</p></div>
<div class="paragraph"><p>Час, в який виконується дія, є симульований час; він не має нічого спільного зі справжнім часом "годинника на стіні". Симульований час представлений просто як ціле. Поточний симульований час утримується як приватна змінніа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">var</span> <span class="n">curtime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна має публічний метод аксессора, що повертає поточний час:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">currentTime</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">curtime</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця комбінація приватної змінної з публічним аксессором використовується для переконання, що поточний час не може бути модифікований за межами класу <code>Simulation</code>. Кінець кінцем, звичайно ви не бажаєте, щоб ваші об'єкти симуляції маніпулювали поточним часом, можливо, за винятком, якщо ваша модель симуляції подорожує в часі.</p></div>
<div class="paragraph"><p>Дія, що має бути виконана у вказаний час, називається робочим елементом. Робочий елемент реалізований як наступний клас:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">time</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">action</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми робимо клас <code>WorkItem</code> кейс класом, оскільки є синтаксичні зручності, що витікають з цього: ви можете використовувати метод фабрики <code>WorkItem</code>, щоб створити примірники класу, та ви задурно отримуєте аксессори для параметрів конструктора <code>time</code> та <code>action</code>. Також зауважте, що клас <code>WorkItem</code> вкладений в клас <code>Simulation</code>. Вкладені класи в Scala розглядаються подібно до Java. Розділ 20.7 надасть більше деталей.</p></div>
<div class="paragraph"><p>Клас <code>Simulation</code> утримує порядок денний з усіх залишених робочих елементів, що ще не були виконані. Робочі елементи впорядковані по симульованому часу, в який вони мають виконуватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">var</span> <span class="n">agenda</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Список <code>agenda</code> буде підтримуватись в потрібному впорядкованому вигляді через метод <code>insert</code>, що оновлює його. Ви можете бачити <code>insert</code>, коли той викликається з <code>afterDelay</code>, що є єдиним шляхом додати робочий елемент до розкладу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">block</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">item</span> <span class="k">=</span> <span class="nc">WorkItem</span><span class="o">(</span><span class="n">currentTime</span> <span class="o">+</span> <span class="n">delay</span><span class="o">,</span> <span class="o">()</span> <span class="k">=&gt;</span> <span class="n">block</span><span class="o">)</span>
  <span class="n">agenda</span> <span class="k">=</span> <span class="n">insert</span><span class="o">(</span><span class="n">agenda</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як натякає ім'я, цей метод вставляє дію (надану як <code>block</code>) в розклад, так що вона планується для виконання з затримкою в одиницях часу, після поточного часу симуляції. Наприклад, наступний виклик буде створювати новий робочий елемент, що буде виконаний в симульований час <code>currentTime + delay</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">afterDelay</span><span class="o">(</span><span class="n">delay</span><span class="o">)</span> <span class="o">{</span> <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Код, що буде виконаний, міститься в другому аргументі метода. Формальний параметр для цього аргумента має тип <code>=&gt; Unit</code> (тобто, це обчислення типу <code>Unit</code>, що передається по імені). Згадайте, що параметри за-ім'ям не обчислюються коли передаються в метод. Так що в виклику вище <code>count</code> буде інкрементовано тільки коли фреймворк симуляції викликає дію, що зберігається в робочому елементі. Зауважте, що <code>afterDelay</code> є карованою функцією. Це гарний приклад принципу, викладеного в Розділі 9.5, що каровані функції можуть використовуватись, щоб зробити виклик метода більш схожим на вбудований синтаксис. Створений робочий елемент все ще потребує бути вставленим в розклад. Це робиться через метод <code>insert</code>, що підтримує інваріант, згідно якого <code>agenda</code> впорядкована за часом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">],</span>
    <span class="n">item</span><span class="k">:</span> <span class="kt">WorkItem</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">WorkItem</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span> <span class="o">&lt;</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">time</span><span class="o">)</span> <span class="n">item</span> <span class="o">::</span> <span class="n">ag</span>
  <span class="k">else</span> <span class="n">ag</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">ag</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Основа класу <code>Simulation</code> визначений методом <code>run</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">run</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">afterDelay</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;*** simulation started, time = &quot;</span> <span class="o">+</span>
      <span class="n">currentTime</span> <span class="o">+</span> <span class="s">&quot; ***&quot;</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">agenda</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">next</span><span class="o">()</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей метод постійно вибирає перший елемент в <code>agenda</code>, видаляє його з розкладу, та виконує його. Він робить це, доки в роскладі більше не залишиться елементів, що не були виконані. Кожний крок виконується через метод <code>next</code>, що визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">next</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="o">(</span><span class="n">agenda</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">item</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="n">agenda</span> <span class="k">=</span> <span class="n">rest</span>
      <span class="n">curtime</span> <span class="k">=</span> <span class="n">item</span><span class="o">.</span><span class="n">time</span>
      <span class="n">item</span><span class="o">.</span><span class="n">action</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>next</code> декомпонує потоний розклад за допомогою порівняння шаблонів на перший елемент, <code>item</code>, та залишок списку робочих елементів, <code>rest</code>. Він видаляє передній елемент з поточного розкладу, встановлює симульований час <code>curtime</code> до часу робочого елементу, та виконує дію робочого елемента.</p></div>
<div class="paragraph"><p>Зауважте, що <code>next</code> може бути викликаний тільки якщо розклад непорожній. Немає <code>case</code> для порожнього списку, так що ви будете отримувати виключення <code>MatchError</code>, якщо ви спробуєте викликати <code>next</code> на порожньому розкладі.</p></div>
<div class="paragraph"><p>Фактично, компілятор Scala буде звичайно попереджати вас, що ви пропустили один з можливих шаблонів для списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Simulator</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">19</span><span class="kt">:</span> <span class="kt">warning:</span> <span class="kt">match</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">exhaustive!</span>
<span class="n">missing</span> <span class="n">combination</span>     <span class="nc">Nil</span>

    <span class="n">agenda</span> <span class="k">match</span> <span class="o">{</span>
    <span class="o">^</span>
<span class="n">one</span> <span class="n">warning</span> <span class="n">found</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку, відсутній <code>case</code> не є проблемою, оскільки ви знаєте, що <code>next</code> викликається на непорожньому розкладі. Таким чином, ви можете побажати відключити попередження. Ви бачили в Розділі 15.5, що це може бути зроблене через додавання анотації <code>@unchecked</code> до виразу селектора в порівнянні шаблонів. Ось чому код <code>Simulation</code> використовує <code>(agenda: @unchecked) match</code>, не <code>agenda match</code>. Це все. Це може виглядати як дивовижно малий код для фреймворка симуляції. Ви можете здивуватись, як цей фреймворк може потенційно підтримувати цікаві симуляції, якщо все, що він робить, це виконує список робочих елементів? Фактично, потужність фреймворку симуляції походить від факту, що дії, що зберігаються в робочих елементах, самі можуть встановлювати подальші робочі елементи в розклад під час виконання. Це робить можливим мати довготриваючі симуляції, розвинені з простого початку.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_18_6__">18.6 Симуляція схеми</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наступний крок є використання фреймворку симуляції для реалізації домен-специфічної мови для пристроїв, показаної в Розділі 18.4. Згадайте, що DSL пристроїв складається з класа для дротів, та методів, що створюють ТА-вентилі, АБО-вентилі та інвертори. Всі вони містяться в класі <code>BasicCircuitSimulation</code>, що розширює фреймворк симуляції. Цей клас показаний в Лістингах 18.9 та 18.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.simulation</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BasicCircuitSimulation</span> <span class="k">extends</span> <span class="nc">Simulation</span> <span class="o">{</span>

  <span class="k">def</span> <span class="nc">InverterDelay</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nc">AndGateDelay</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="nc">OrGateDelay</span><span class="k">:</span> <span class="kt">Int</span>

  <span class="k">class</span> <span class="nc">Wire</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">sigVal</span> <span class="k">=</span> <span class="kc">false</span>
    <span class="k">private</span> <span class="k">var</span> <span class="n">actions</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Action</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

    <span class="k">def</span> <span class="n">getSignal</span> <span class="k">=</span> <span class="n">sigVal</span>

    <span class="k">def</span> <span class="n">setSignal</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">sigVal</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sigVal</span> <span class="k">=</span> <span class="n">s</span>
        <span class="n">actions</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">())</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">addAction</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="n">actions</span> <span class="k">=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">actions</span>
      <span class="n">a</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">invertAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">inputSig</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="n">afterDelay</span><span class="o">(</span><span class="nc">InverterDelay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">output</span> <span class="n">setSignal</span> <span class="o">!</span><span class="n">inputSig</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">input</span> <span class="n">addAction</span> <span class="n">invertAction</span>
  <span class="o">}</span>
<span class="c1">// продовження в Лістингу 18.10...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.9 - Перша половина класу <code>BasicCircuitSimulation</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// ...продовження з Лістингу 18.9</span>
  <span class="k">def</span> <span class="n">andGate</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">andAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">a1Sig</span> <span class="k">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="k">val</span> <span class="n">a2Sig</span> <span class="k">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="n">afterDelay</span><span class="o">(</span><span class="nc">AndGateDelay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">output</span> <span class="n">setSignal</span> <span class="o">(</span><span class="n">a1Sig</span> <span class="o">&amp;</span> <span class="n">a2Sig</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">a1</span> <span class="n">addAction</span> <span class="n">andAction</span>
    <span class="n">a2</span> <span class="n">addAction</span> <span class="n">andAction</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">orGate</span><span class="o">(</span><span class="n">o1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">o2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">orAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">o1Sig</span> <span class="k">=</span> <span class="n">o1</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="k">val</span> <span class="n">o2Sig</span> <span class="k">=</span> <span class="n">o2</span><span class="o">.</span><span class="n">getSignal</span>
      <span class="n">afterDelay</span><span class="o">(</span><span class="nc">OrGateDelay</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">output</span> <span class="n">setSignal</span> <span class="o">(</span><span class="n">o1Sig</span> <span class="o">|</span> <span class="n">o2Sig</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">o1</span> <span class="n">addAction</span> <span class="n">orAction</span>
    <span class="n">o2</span> <span class="n">addAction</span> <span class="n">orAction</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">probe</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wire</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">probeAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">currentTime</span> <span class="o">+</span>
          <span class="s">&quot; new-value = &quot;</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getSignal</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">wire</span> <span class="n">addAction</span> <span class="n">probeAction</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.10 - Друга половина класу <code>BasicCircuitSimulation</code>.</p></div>
<div class="paragraph"><p>Клас <code>BasicCircuitSimulation</code> декларує три абстрактні методи, що представляють затримки базових вентилів: <code>InverterDelay</code>, <code>AndGateDelay</code>, та <code>OrGateDelay</code>. Дійсні затримки невідомі на рівні цього класу, оскікльи вони залежать від технології пристроїв, що будуть симульовані. Ось чому затримки залишені абстрактними в класі <code>BasicCircuitSimulation</code>, так що їх суцільне визначення делеговано до субкласів.<span class="footnote"><br />[Імена ціх методів затримки починаються з великої літери, оскільки вони представляють константи. Вони є методами, так що вони можуть бути перекриті в субкласах. Ви винайдете, як робити ті самі речі з <code>val</code> в Розділі 20.3.]<br /></span> Реалізація інших членів класу <code>BasicCircuitSimulation</code> описана далі.</p></div>
<div class="sect2">
<h3 id="__wire">Клас Wire</h3>
<div class="paragraph"><p>Дріт має підтримувати три базові дії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>getSignal: Boolean</code>: повертає поточний сигнал на дроті.
</p>
</li>
<li>
<p>
<code>setSignal(sig: Boolean)</code>: встановлює сигнал на дроті в <code>sig</code>.
</p>
</li>
<li>
<p>
<code>addAction(p: Action)</code>: приєднує вказану процедуру <code>p</code> до дій на дроті. Ідея полягає в тому, що всі процедури дій, приєднані до деякого дроту, будуть використовуватись кожний раз, коли сигнал на дроті змінюється. Типово акції додаються до дроту через компоненти, приєднані до дроту. Приєднана дія виконується один раз, коли вона додається до дроту, та після цього кожний раз, коли сигнал на дроті змінюється.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ось реалізація класу <code>Wire</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Wire</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">sigVal</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">actions</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Action</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>

  <span class="k">def</span> <span class="n">getSignal</span> <span class="k">=</span> <span class="n">sigVal</span>

  <span class="k">def</span> <span class="n">setSignal</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">!=</span> <span class="n">sigVal</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">sigVal</span> <span class="k">=</span> <span class="n">s</span>
      <span class="n">actions</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="o">())</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">addAction</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Action</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">actions</span> <span class="k">=</span> <span class="n">a</span> <span class="o">::</span> <span class="n">actions</span>
    <span class="n">a</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дві приватні змінні складають стан дроту. Змінна <code>sigVal</code> представляє поточний сигнал, та змінна <code>actions</code> представляє процедури дій, наразі приєднані до дроту. Одна цікава реалізація метода є <code>setSignal</code>: коли сигнал на дроті змінюється, нове значення зберігається в змінній <code>sigVal</code>. Більше того, всі дії, приєднані до дроту, виконуються. Зауважте скорочений синтаксис для виконання цього: <code>actions foreach (_ ())</code> застосовує функцію <code>_ ()</code> до кожного елементу в списку <code>actions</code>. Як описане в Розділі 8.5, функція <code>_ ()</code> є скороченням до <code>f =&gt; f ()</code> — тобто, вона приймає функцію (назвемо її <code>f</code>), та застосовує її до порожнього списку параметрів.</p></div>
</div>
<div class="sect2">
<h3 id="__code_inverter_code">Метод <code>inverter</code></h3>
<div class="paragraph"><p>Єдиний ефект від створення інвертора в тому, що на його вхідному дроті встановлюється дія. Ця дія викликається кожний раз, коли дія інсталюється, та потім кожного разу, коли сигнал на дроті змінюється. Ефект дії в тому, що значення на виході інвертора встановлюється (через <code>setSignal</code>) на протилежність вхідного значення. Оскільки вентилі інверторів мають затримки, ця зміна повинна набувати ефекту тільки після <code>InverterDelay</code> одиниць симульованого часу після того, як вхідне значення було змінене, та дія була виконана. Це підказує наступну реалізацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">inverter</span><span class="o">(</span><span class="n">input</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">invertAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">inputSig</span> <span class="k">=</span> <span class="n">input</span><span class="o">.</span><span class="n">getSignal</span>
    <span class="n">afterDelay</span><span class="o">(</span><span class="nc">InverterDelay</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">output</span> <span class="n">setSignal</span> <span class="o">!</span><span class="n">inputSig</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">input</span> <span class="n">addAction</span> <span class="n">invertAction</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект метода <code>inverter</code> є додавання <code>invertAction</code> до вхідного дроту. Ця дія, коли викликана, бере вхідний сигнал, та встанавлює іншу дію, що інвертує вихідний сигнал в симульованому розкладі. Ця інша дія буде виконана через <code>InverterDelay</code> одиниць симульованого часу. Зауважте, як метод використовує метод <code>afterDelay</code> фреймворка симуляції для створення нового робочого елемента, що буде виконаний в майбутньому.</p></div>
</div>
<div class="sect2">
<h3 id="__code_andgate_code__code_orgate_code">Методи <code>andGate</code> та <code>orGate</code></h3>
<div class="paragraph"><p>Реалізація ТА-вентилів аналогічна реалізації інверторів. Призначення ТА-вентилів є вивід кон'юкції його вхідних сигналів. Це має відбуватись через <code>AndGateDelay</code> одиниць симульованого часу після зміни одного з його вхідних сигналів. З цього випливає наступна реалізація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">andGate</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">output</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">andAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">a1Sig</span> <span class="k">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">getSignal</span>
    <span class="k">val</span> <span class="n">a2Sig</span> <span class="k">=</span> <span class="n">a2</span><span class="o">.</span><span class="n">getSignal</span>
    <span class="n">afterDelay</span><span class="o">(</span><span class="nc">AndGateDelay</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">output</span> <span class="n">setSignal</span> <span class="o">(</span><span class="n">a1Sig</span> <span class="o">&amp;</span> <span class="n">a2Sig</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">a1</span> <span class="n">addAction</span> <span class="n">andAction</span>
  <span class="n">a2</span> <span class="n">addAction</span> <span class="n">andAction</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект метода <code>andGate</code> є додавання <code>andAction</code> до обох його вхідних дротів, <code>a1</code> та <code>a2</code>. Ця дія, коли викликається, отримує обоє вхідні сигнали, та інсталює іншу дію, що встанавлює вихідний сигнал в кон'юкцію обох вхідних сигналів. Ця інша дія буде виконана після <code>AndGateDelay</code> одиниць симульованого часу. Зауважте, що вихід буде перерахований, якщо любий з вхідних дротів зміниться. Ось чому та сама акція <code>andAction</code> інсталюється для обох вхідних дротів, <code>a1</code> та <code>a2</code>. Метод <code>orGate</code> реалізований подібно, за винятком того, що він виконує логічне АБО замість логічного ТА.</p></div>
</div>
<div class="sect2">
<h3 id="___36">Вивід симуляції</h3>
<div class="paragraph"><p>Щоб виконати симулятор, вам треба спосіб інспектувати зміни сигналів на дротах. Щоб досягти цього, ви можете симулювати дію покладання проби на дріт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">probe</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wire</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">probeAction</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">currentTime</span> <span class="o">+</span>
        <span class="s">&quot; new-value = &quot;</span> <span class="o">+</span> <span class="n">wire</span><span class="o">.</span><span class="n">getSignal</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">wire</span> <span class="n">addAction</span> <span class="n">probeAction</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект процедури <code>probe</code> є встановити <code>probeAction</code> на обраний дріт. Як звичайно, встановлена дія виконується кожний раз, коли сигнал на дроті змінюється. В цьому випадку вона просто друкує ім'я дроту (що передається як перший параметр до <code>probe</code>), так само, як і поточний час симуляції, та нове значення на дроті.</p></div>
</div>
<div class="sect2">
<h3 id="___37">Запуск симулятора</h3>
<div class="paragraph"><p>Після всіх ціх підготувань настав час побачити симулятор в дії. Щоб визначити суцільну симуляцію, вам треба наслідувати від класу фреймворка симуляції. Щоб побачити щось цікаве, ми створимо клас абстрактної симуляції, що розширює <code>BasicCircuitSimulation</code>, та містить визначення методів для напів-суматора та повного суматора, як вони були представлені раніше в цій главі в Лістингах 18.6 та 18.7, відповідно. Цей клас, що ми назвемо  <code>CircuitSimulation</code>, показаний на Лістингу 18.11.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.simulation</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">CircuitSimulation</span>
  <span class="k">extends</span> <span class="nc">BasicCircuitSimulation</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
    <span class="n">orGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
    <span class="n">andGate</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
    <span class="n">inverter</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
    <span class="n">andGate</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">fullAdder</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cin</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span>
    <span class="n">sum</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">,</span> <span class="n">cout</span><span class="k">:</span> <span class="kt">Wire</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">,</span> <span class="n">c2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
    <span class="n">halfAdder</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">cin</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">c1</span><span class="o">)</span>
    <span class="n">halfAdder</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">c2</span><span class="o">)</span>
    <span class="n">orGate</span><span class="o">(</span><span class="n">c1</span><span class="o">,</span> <span class="n">c2</span><span class="o">,</span> <span class="n">cout</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 18.11 - Клас <code>CircuitSimulation</code>.</p></div>
<div class="paragraph"><p>Суцільна симуляція пристрою буде об'єктом, що наслідує від класа <code>CircuitSimulation</code>. Об'єкт все ще потребує виправлення затримок вентилів відповідно до технології реалізації пристрою, яка симулюється. Нарешті, вам також треба буде визначити суцільний пристрій, що має бути симульований. Ви можете зробити ці кроки інтерактивно в інтерпретаторі Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">org.stairwaybook.simulation._</span>
<span class="k">import</span> <span class="nn">org.stairwaybook.simulation._</span>
</pre></div></div></div>
<div class="paragraph"><p>Зпершу вирішимо затримки вентилів. Визначимо об'єкт (назвемо її <code>MySimulation</code>), що провадить деякі числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">MySimulation</span> <span class="k">extends</span> <span class="nc">CircuitSimulation</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nc">InverterDelay</span> <span class="k">=</span> <span class="mi">1</span>
        <span class="k">def</span> <span class="nc">AndGateDelay</span> <span class="k">=</span> <span class="mi">3</span>
        <span class="k">def</span> <span class="nc">OrGateDelay</span> <span class="k">=</span> <span class="mi">5</span>
      <span class="o">}</span>
<span class="n">defined</span> <span class="n">module</span> <span class="nc">MySimulation</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ви збираєтесь постійно отримувати доступ до членів об'єкта <code>MySimulation</code>, імпортування об'єкту підтримує подальший код коротшим:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">MySimulation._</span>
<span class="k">import</span> <span class="nn">MySimulation._</span>
</pre></div></div></div>
<div class="paragraph"><p>Далі - пристрій. Визначте чотири дроти, та покладіть проби на два з них:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">input1</span><span class="o">,</span> <span class="n">input2</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">carry</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wire</span>
<span class="n">input1</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">111089</span><span class="n">b</span>
<span class="n">input2</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">14</span><span class="n">c352e</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">37</span><span class="n">a04c</span>

<span class="n">carry</span><span class="k">:</span> <span class="kt">MySimulation.Wire</span> <span class="o">=</span>
<span class="nc">BasicCircuitSimulation$Wire</span><span class="k">@</span><span class="mi">1</span><span class="n">fd10fa</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">probe</span><span class="o">(</span><span class="s">&quot;sum&quot;</span><span class="o">,</span> <span class="n">sum</span><span class="o">)</span>
<span class="n">sum</span> <span class="mi">0</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">probe</span><span class="o">(</span><span class="s">&quot;carry&quot;</span><span class="o">,</span> <span class="n">carry</span><span class="o">)</span>
<span class="n">carry</span> <span class="mi">0</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що проби безпосередньо друкують вивід. Це тому, що кожна дія, встановлена на дроті, перший раз виконується при встановленні дії.</p></div>
<div class="paragraph"><p>Тепер визначимо напів-суматор, під'єднавши дроти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">halfAdder</span><span class="o">(</span><span class="n">input1</span><span class="o">,</span> <span class="n">input2</span><span class="o">,</span> <span class="n">sum</span><span class="o">,</span> <span class="n">carry</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, встановимо сигнали, один за одним, на двох вхідних дротах, та запустимо симуляцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">input1</span> <span class="n">setSignal</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">()</span>
<span class="o">***</span> <span class="n">simulation</span> <span class="n">started</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">0</span> <span class="o">***</span>
<span class="n">sum</span> <span class="mi">8</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">input2</span> <span class="n">setSignal</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">run</span><span class="o">()</span>
<span class="o">***</span> <span class="n">simulation</span> <span class="n">started</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">8</span> <span class="o">***</span>
<span class="n">carry</span> <span class="mi">11</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">sum</span> <span class="mi">15</span> <span class="k">new</span><span class="o">-</span><span class="n">value</span> <span class="k">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_18_7_">18.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава поєднала дві техніки, що спочатку виглядають окремими: змінний стан та функції вищих порядків. Змінний стан був використаний для симуляції фізичних сутностей, чий стан змінюється з часом. Функції вищих порядків були використані в фреймворку симуляції, щоб виконувати дії у вказаних точках симульованого часу. Вони також були використані в симуляціях пристроїв, що асоціюють дії зі змінами стану. По дорозі ви бачили простий шлях для визначення домен-специфічної мови як бібліотеки. Це, можливо, досить для однієї глави!</p></div>
<div class="paragraph"><p>Якщо ви хочете залишитись трохи довше, ви можете за бажанням спробувати більше прикладів симуляцій. Ви можете комбінувати напів-суматори та повні суматори для створення більших пристроїв, або розробити нові прилади з визначених досі базових вентилів, та симулювати їх. В наступній главі ми вивчимо щодо параметризації типів в Scala, і побачимо інший приклад, де комбінація функціонального та імперативного підходів дає гарні рішення.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__19_2">Глава 19</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___38">Параметризація типів</h1>
<div class="paragraph"><p>В цій главі ми пояснимо деталі параметризації типів в Scala. По ходу ми продемонструємо деякі з прийомів приховування інформації, з якою ви ознайомились в Главі 13 через використання суцільного прикладу: розробки класу для повністю функціональних черг. Ми презентуємо параметризацію типів та приховування разом, оскільки приховування інформації може використовуватись для більш загальної параметризації типів з анотаціями варіантності.</p></div>
<div class="paragraph"><p>Типова параметризація дозволяє вам писати загальні класи та трейти. Наприклад, множини є загальними та приймають параметр типу: вони визначені як <code>Set[T]</code>. Як результат, любий окремий примірник множини може бути <code>Set[String]</code>, <code>Set[Int]</code>, тощо, але він має бути множиною чогось. На відміну від Java, що дозволяє сирі типи, Scala вимагає, щоб ви вказували параметри типів. Варіантність визначає відношення наслідування для параметризованих типів, наприклад, такі як: чи є <code>Set[String]</code> субтипом <code>Set[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Глава містить три частини. Перша частина розробляє структуру даних для повністю функціональних черг. Друга частина розробляє техніку для приховування деталей внутрішньої репрезентації цієї структури. Заключна частина пояснює варіантність, та як вона взаємодіє з приховуваннями інформації.</p></div>
<div class="sect1">
<h2 id="_19_1__">19.1 Функціональні черги</h2>
<div class="sectionbody">
<div class="paragraph"><p>Функціональна черга є структурою даних з трьома операціями:</p></div>
<div class="paragraph"><p><code>head</code> повертає перший елемент черги</p></div>
<div class="paragraph"><p><code>tail</code> повертає чергу без першого елемента</p></div>
<div class="paragraph"><p><code>enqueue</code> повертає нову чергу з наданим елементом
          доданим в кінець</p></div>
<div class="paragraph"><p>На відміну від змінної черги, функціональна черга не змінює вміст коли додається елемент. Замість цього повертається нова черга, що містить цей елемент. Ціль цієї глави - створити клас, що буде мати ім'я <code>Queue</code>, що робить таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q1</span> <span class="k">=</span> <span class="n">q</span> <span class="n">enqueue</span> <span class="mi">4</span>
<span class="n">q1</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>Queue</code> мав би змінну реалізацію, операція <code>enqueue</code> в другому рядку мала б впливати на вміст <code>q</code>; фактично, після цієї операції обидві черги, результат <code>q1</code> та оригінальна черга <code>q</code>, мали б містити послідовність <code>1, 2, 3, 4</code>. Але для функціональної черги додане значення можна побачити тільки в результаті <code>q1</code>, та не в черзі <code>q</code>, на якій виконується операція.</p></div>
<div class="paragraph"><p>Чисто функціональні черги також мають деяку подібність до списків. Обоє є так званими повністю стійкими структурами даних, коли старі версії залишаються доступні, навіть після розширення або модифікації. Вони підтримують операції <code>head</code> та <code>tail</code>. Але коли список звичайно розширюється зпереду, використовуючи операцію <code>::</code>, черга розширюється з кінця, використовуючи <code>enqueue</code>.</p></div>
<div class="paragraph"><p>Як це може бути реалізовано ефективно? Ідеально, функціональна (незмінна) черга не повинна мати фундаментально вище навантаження, ніж імперативна (змінна). Тобто, всі три операції, <code>head</code>, <code>tail</code>, <code>enqueue</code>, повинні виконуватись за сталий час. Один простий підхід реалізувати функціональну чергу, що буде використовувати список як тип репрезентації.</p></div>
<div class="paragraph"><p>Тоді <code>head</code> та <code>tail</code> будуть просто транслюватись в такі ж операції на списках, тоді як <code>enqueue</code> має бути конкатенацією.</p></div>
<div class="paragraph"><p>Це буде давати таку реалізацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SlowAppendQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// неефективне</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">elems</span><span class="o">.</span><span class="n">head</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowAppendQueue</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowAppendQueue</span><span class="o">(</span><span class="n">elems</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема з цією реалізацією знаходиться в операції <code>enqueue</code>. Вона займає час, пропорційну до числа елементів, що зберігаються в черзі. Якщо ви бажаєте додавати елементи за сталий час, ви також можете спробувати обернути порядок елементів в представленому списку, так щоб останній елемент, що додається, був би першим в списку. Це може привести до наступної реалізації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SlowHeadQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">smele</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// неефективне</span>
<span class="c1">// smele це обернене elems</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">smele</span><span class="o">.</span><span class="n">last</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowHeadQueue</span><span class="o">(</span><span class="n">smele</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowHeadQueue</span><span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">smele</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>enqueue</code> займає сталий час, але <code>head</code> та <code>tail</code> - ні. Тепер вони витрачають час, пропорційний до кількості елементів, що зберігаються в черзі.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дивлячись на ці два приклади, виглядає непростим запропонувати реалізацію, що має сталий час для всіх трьох операцій. Фактично, виглядає сумнівним, щоб це взагалі було можливим! Однак комбінуючи дві операції ви можете підійти дуже близько. Ідея є представити чергу як два списки, названі <code>leading</code> та <code>trailing</code>. Список <code>leading</code> містить елементи, ближчі до початку, тоді як список <code>trailing</code> містить елементи, ближчі до кінця черги в оберненому порядку. Вміст цілої черги в кожну мить є рівним `leading 
</dt>
<dd>
<p>
trailing.reverse`.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Тепер, щоб додати елемент, ви просто робите йому <code>cons</code> до списку <code>trailing</code>, використовуючи оператор <code>::</code>, так що <code>enqueue</code> має сталий час. Це означає, що спочатку, коли порожня черга конструююється з послідовних операцій <code>enqueue</code>, список <code>trailing</code> буде зростати, тоді як список <code>leading</code> буде залишатись порожньою. Потім, перед першою операцією <code>head</code> або <code>tail</code>, що буде виконана для порожнього списку <code>leading</code>, цілий список <code>trailing</code> копіюється до <code>leading</code> з реверсом порядку елементів. Це робиться операцією, що називається <code>mirror</code>. Лістинг 19.1 показує реалізацію черги, що використовує цей підхід.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="k">this</span>

  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.1 - Базова функціональна черга.</p></div>
<div class="paragraph"><p>Яка складність цієї реалізації черги? Операція <code>mirror</code> може займати час, пропорційну до кількості елементів в списку, але тільки якщо список <code>leading</code> порожній. Він повертається безпосередьньо, якщо <code>leading</code> непорожній. Оскільки <code>head</code> та <code>tail</code> викликають <code>mirror</code>, їх складність також може бути лінійною до розміру черги, також. Однак чим більшою стає черга, тим рідше викликається <code>mirror</code>.</p></div>
<div class="paragraph"><p>Дійсно, припустімо є черга довжиною <code>n</code> з порожнім списком <code>leading</code>. Тоді <code>mirror</code> має реверс-копіювати список довжини <code>n</code>. Однак наступного разу <code>mirror</code> буде мати виконати будь яку роботу, коли список <code>leading</code> буде знову порожній, що буде після <code>n</code> операцій <code>tail</code>. Це означає, що ви можете "заряджати" кожну з ціх <code>n</code> операцій <code>tail</code> один раз на <code>n</code> від складності <code>mirror</code>, що означає сталу кількість роботи. Зважаючи, що операції <code>head</code>, <code>tail</code>, та <code>enqueue</code> з'являються з тою самою частотою, амортизована складність, таким чином, є константою для кожної операції. Так що функціональні черги асимптотично такі ж само ефективні, як і змінні.</p></div>
<div class="paragraph"><p>Тепер, ось декілька застережень, що треба додати до ціх аргументів. Перше, дискусія була тільки про асимптотичну поведінку. Друге, аргументація покладалась на факт, що <code>head</code>, <code>tail</code> та <code>enqueue</code> викликаються з майже такою ж частотою. Якщо <code>head</code> викликана значно частіше, ніж інші дві операції, наш аргумент не діє, бо кожний виклик <code>head</code> може включати коштовну реорганізацію списку в <code>mirror</code>. Друге застереження можна оминути; можливо розробити функціональні черги, так щоб для послідовних операцій <code>head</code> тільки перша могла потребувати реорганізації. Ви з'ясуєте в кінці цієї глави, як це робиться.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_2__">19.2 Приховування інформації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Реалізація <code>Queue</code>, показана в Лістингу 19.1 тепер досить гарна, в відношенні ефективності. Однак ви можете заперечити, що ця ефективність сплачена викриттям непотрібних деталей реалізації. Конструктор, що є глобально доступним, приймає два списки як параметри, один з яких реверсований — навряд чи інтуітивна репрезентація черги. Що потрібно, це шлях приховати цей конструктор від клієнтського коду. В цьому розділі ми покажемо деякі шляхи досягти цього в Scala.</p></div>
<div class="sect2">
<h3 id="______10">Приватні конструктори та методи фабрик</h3>
<div class="paragraph"><p>В Java ви можете приховати конструктор, зробивши його приватним. В Scala первинний конструктор не має явного визначення; він визначений явно через параметри та тіло класу. Тим не менше, все ще можливо приховати первинний конструктор, через додавання модифікатора <code>private</code> перед списком параметрів класу, як показано в Лістингу 19.2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.2 - Приховування первинного конструктора через створення його приватним.</p></div>
<div class="paragraph"><p>Модифікатор <code>private</code> між ім'ям класу та його параметрами вказує, що конструктор <code>Queue</code> є приватним: до нього можна отримати доступ тільки з самого класу, та його об'єкта компанйона. Ім'я класу <code>Queue</code> все ще публічне, так що ви можете використовувати його як тип, але ви не можете викликати конструктор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">constructor</span> <span class="kt">Queue</span> <span class="kt">in</span> <span class="kt">class</span> <span class="kt">Queue</span> <span class="kt">cannot</span>
<span class="n">be</span> <span class="n">accessed</span> <span class="n">in</span> <span class="k">object</span> <span class="nc">$iw</span>
              <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли цей приватний конструктор класу <code>Queue</code> не може бути викликаний з клієнтського коду, виникає потреба в деякому іншому способі створювати нові черги. Одна можливість є добавити додатковий конструктор, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Додатковий конструктор, показаний в попередньому прикладі, будує порожню чергу. Як покращення, додатковий конструктор може приймати список початкових елементів черги:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нагадаємо, що <code>T*</code> є нотацією для повторюваних параметрів, як описано в Розділі 8.8.</p></div>
<div class="paragraph"><p>Інша можливість є додати метод фабрики, що будує чергу з такої послідовності початкових елементів. Милий спосіб зробити це є визначення об'єкта <code>Queue</code>, що має те саме ім'я, що і клас, що визначається, та містить метод <code>apply</code>, як показано в Лістингу 19.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>
<span class="c1">// конструює чергу з початковими елементами xs</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.3 - Метод фабрика <code>apply</code> в об'єкті компанйоні.</p></div>
<div class="paragraph"><p>Через покладання цього об'єкту в той самий джерельний файл, що і клас <code>Queue</code>, ви робите об'єкт об'єктом компанйоном цього класу. Ви бачили в Розділі 13.5, що об'єкт компанйон має ті самі права доступу, що і його клас. Завдяки цьому метод <code>apply</code> в об'єкті <code>Queue</code> може створити новий об'єкт <code>Queue</code>, навіть якщо конструктор класу <code>Queue</code> є приватним.</p></div>
<div class="paragraph"><p>Зауважте, що оскільки метод фабрики названий <code>apply</code>, клієнти можуть створювати черги за допомогою виразів, таких як <code>Queue(1, 2, 3)</code>. Цей вираз розширюється до <code>Queue.apply(1, 2, 3)</code>, оскільки <code>Queue</code> є об'єктом, а не функцією. Як результат, <code>Queue</code> виглядає для клієнтів так, якби це був глобально визначений метод фабрики. В реальності Scala не має глобально видимих методів; кожний метод має бути розміщений в об'єкті або класі. Однак використовуючи методи, названі <code>apply</code>, всередині глобальних об'єктів, ви можете підтримати шаблони використання, що виглядають як виклики глобальних методів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
        <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="k">this</span>

    <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.4 - Абстракції типів для функціональних черг.</p></div>
</div>
<div class="sect2">
<h3 id="____20">Альтернатива: приватні класи</h3>
<div class="paragraph"><p>Приватні конструктори та приватні члени є одним способом приховати ініціалізацію та репрезентацію класу. Інший, більш радикальний шлях є приховати сам клас, та імпортувати тільки трейт, що розкриває публічний інтерфейс класу. Код в Лістингу 19.4 реаліщзує цей дизайн. Це трейт <code>Queue</code>, який декларує методи <code>head</code>, <code>tail</code>, та <code>enqueue</code>. Всі три методи реалізовані як субклас <code>QueueImpl</code>, що по собі є приватним інутрішнім класом об'єкта <code>Queue</code>. Це виставляє клієнтам ту саму інформацію, що і раніше, але використовуючи іншу технологію. Замість приховування індивідуальних конструкторів та методів, ця версія приховує цілий клас реалізації.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_19_3__">19.3 Анотації варіантності</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>Queue</code>, як визначено в Лістингу 19.4, є трейтом, але не типом. <code>Queue</code> не є типом, бо він приймає параметр типу.</p></div>
<div class="paragraph"><p>Як результат, ви не можете створити змінні типу <code>Queue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">doesNotCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Queue</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
        <span class="k">def</span> <span class="n">doesNotCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього, трейт <code>Queue</code> дозволяє вам вказати параметризовані типи, такі як <code>Queue[String]</code>, <code>Queue[Int]</code>, або <code>Queue[AnyRef]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">doesCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">])</span> <span class="k">=</span> <span class="o">{}</span>
<span class="n">doesCompile</span><span class="k">:</span> <span class="o">(</span><span class="kt">q:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">])</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, <code>Queue</code> є трейтом, та <code>Queue[String]</code> є типом. <code>Queue</code> також називають конструктором типу, оскільки ви можете конструювати тип за допомогою нього, вказавши тип параметра. (Це аналогічно до конструювання примірника об'єкта за допомогою старого доброго конструктора, вказавши значення параметра). Конструктор типа <code>Queue</code> "генерує" сімейство типів, що включає <code>Queue[Int]</code>, <code>Queue[String]</code>, та <code>Queue[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Також ви можете сказати, що <code>Queue</code> є <em>дженерік</em> трейтом. (Класи та трейти, що приймають параметри типів, є "дженеріками", але типи, що вони генерують, є "параметризованими", не дженеріками). Термін "дженерік" означає, що ви визначаєте багато специфічних типів за допомогою одного загально написаного класу або трейту. Наприклад, трейт <code>Queue</code> в Лістингу 19.4 визначає дженерік чергу. <code>Queue[Int]</code> та <code>Queue[String]</code>, тощо, будуть специфічними чергами.</p></div>
<div class="paragraph"><p>Комбінація параметрів типів та субтипізація виставляє деякі цікаві питання. Наприклад, чи існують якісь особливі відношення субтипізації між членами сімейства типів, згенерованих <code>Queue[T]</code>? Біль точно, чи має <code>Queue[String]</code> розглядатись як субтип <code>Queue[AnyRef]</code>? Або більш загально, якщо <code>S</code> є субтипом типу <code>T</code>, тоді чи має <code>Queue[S]</code> розглядатись як субтип <code>Queue[T]</code>? Якщо так, ви можете сказати, що трейт <code>Queue</code> є коваріантним (або "гнучким") по його параметру типу <code>T</code>. Або, оскікльи він має тільки один параметр типу, ви можете просто сказати, що <code>Queue</code> є коваріантними. Коваріантність <code>Queue</code> може означати, наприклад, що ви можете передати <code>Queue[String]</code> до метода <code>doesCompile</code>, показаного перед цім, що приймає значення параметра типу <code>Queue[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Інтуітивно, все це виглядає OK, оскільки черга <code>String</code> виглядає як особливий випадок черги <code>AnyRefs</code>. Однак в Scala дженерік типи мають по замовчанню неваріантне (або "жорстку") субтипізацію. Тобто, з <code>Queue</code>, визначеним в Лістингу 19.4, черги з разними типами елементів ніколи не будуть в відношенні субтипізації. <code>Queue[String]</code> не буде корисним як <code>Queue[AnyRef]</code>. Однак, ви можете вимагати коваріантної (гнучкої) субтипізації черг, через зміну першого рядка цього визначення класу <code>Queue</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Вказуючи префікс <code>+</code> перед формальним параметром типу, вказує, що субтипізація коваріантна (гнучка) в цьому параметрі. Через додавання цього одного символа, ви кажете Scala, що ви бажаєте, щоб <code>Queue[String]</code>, наприклад, розглядався як субтип <code>Queue[AnyRef]</code>. Компілятор буде перевіряти, що <code>Queue</code> визначений в спосіб, що така субтипізація має місце.</p></div>
<div class="paragraph"><p>Крім <code>+</code>, також є і префікс <code>-</code>, що вказує контрваріантну субтипізацію. Якщо б <code>Queue</code> було визначено таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>тоді, якщо <code>T</code> є субтипом типу <code>S</code>, це буде означати, що <code>Queue[S]</code> є субтипом <code>Queue[T]</code> (що в випадку черги буде досить несподівано!). Чи є параметр типу коваріантним, контрваріантним або неваріантним, все це називається варіантністю параметра. Символи <code>+</code> та <code>-</code>, що ви можете покладати коло параметрів типу, називаються анотаціями варіантності.</p></div>
<div class="paragraph"><p>В чисто функціональному світі багато типів є природно коваріантними (гнучкими). Однак ситуація змінюється, коли ми вводимо змінні дані. Щоб зрозуміти чому, розглянемо простий тип одно-елементних клітин, що можуть бути прочитані та записані, показаний в Лістингу 19.5.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cell</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">init</span>
  <span class="k">def</span> <span class="n">get</span> <span class="k">=</span> <span class="n">current</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">current</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.5 - Неваріантний (жорсткий) клас <code>Cell</code>.</p></div>
<div class="paragraph"><p>Тип <code>Cell</code> в Лістингу 19.5 деклароване як неваріантне (жорстке). Для цілей доказу, уявімо на момент, що замість цього <code>Cell</code> був декларований коваріантним, тобто, він був деларований як клас <code>Cell[+T]</code> — і в такому вигляді переданий компілятору Scala. (Він не буде, і ми скоро пояснимо чому). Тоді ви можете сконструювати наступну проблематичну послідовність тверджень:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cell</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">c2</span><span class="k">:</span> <span class="kt">Cell</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">c1</span>
<span class="n">c2</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">get</span>
</pre></div></div></div>
<div class="paragraph"><p>Взяті окремо, кожний з ціх чотирьох рядків виглядають OK. Перший рядок створює клітину рядків, та зберігає її в <code>val</code> на ім'я <code>c1</code>. Другий рядок визначає новий <code>val</code>, <code>c2</code>, типу <code>Cell[Any]</code>, що ініціалізований <code>c1</code>. Це OK, оскільки <code>Cells</code> вважається контрваріантним. Третій рядок встановлює значення клітинки <code>c2</code> в <code>1</code>. Це також OK, оскільки присвоєне значення <code>1</code> є примірником типу елемента <code>c2</code>, <code>Any</code>. Нарешті, останній рядок присвоює значення елементу <code>c1</code> в рядок. Тут також нічого дивного, бо обоє сторін однакового типу. Вле взяті разом, ці чотири рядка закінчуються присвоєнням цілого <code>1</code> до рядка <code>s</code>. Це, очевидно, порушення значення типу.</p></div>
<div class="paragraph"><p>Яка операція винна в рантайм збої? Це, напевне, другий, що використовує коваріантну субтипізацію. Ініш твердження дуже прості та фундаментальні. Таким чином, <code>Cell</code> зі <code>String</code> також є <code>Cell</code> з <code>Any</code>, оскільки є такі речі, які ви можете робити з <code>Cell</code> з <code>Any</code>, які ви не можете робити з <code>Cell</code> з <code>String</code>. Наприклад, ви не можете використовувати <code>set</code> з аргументом <code>Int</code> на <code>Cell</code> зі <code>String</code>.</p></div>
<div class="paragraph"><p>Фактично, коли ви передаєте коваріанту версію <code>Cell</code> до компілятора <code>Scala</code>, ви будете отримувати помилку часу компілятора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Cell</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">7</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">x</span>
    <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">current</span> <span class="k">=</span> <span class="n">x</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="____21">Варіантність та масиви</h3>
<div class="paragraph"><p>Цікаво порівняти цю поведінку з масивами в Java. В принципі масиви такі ж, як клітини, за винятком того, що вони можуть мати більше одного елементу. Тим не менш, масиви розглядаються як коваріантні в Java. Ви можете спробувати приклад, аналогічний до взаємодії з клітиною, описаний тут для Java масивів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// це Java</span>
<span class="n">String</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">&quot;abc&quot;</span> <span class="o">};</span>
<span class="n">Object</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">;</span>
<span class="n">a2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">17</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a1</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви спробуєте цей приклад, ви знайдете, що це буде компілюватись. Але виконання програми буде викликати виключення <code>ArrayStore</code>, що буде закинуте, коли <code>a2[0]</code> присвоюється до <code>Integer</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArrayStoreException</span><span class="k">:</span>
<span class="kt">java.lang.Integer</span>
        <span class="n">at</span> <span class="nc">JavaArrays</span><span class="o">.</span><span class="n">main</span><span class="o">(</span><span class="nc">JavaArrays</span><span class="o">.</span><span class="n">java</span><span class="k">:</span><span class="err">8</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це те, що Java зберігає тип елементу під час виконання. Потім, кожний раз, коли елемент масиву оновлюється, значення нового елементу перевіряється на збережений тип. Якщо це не примірник цього типу, буде закинуте виключення <code>ArrayStore</code>.</p></div>
<div class="paragraph"><p>Ви можете запитати, чому Java прийняла цей дизайн, що виглядає одночасно небезпечним та коштовним. Коли йому задавали це питання, James Gosling, головний винахідник мови Java, відповідав, що вони бажали мати прості засоби для загального трактування масивів. Наприклад, вони бажали бути в змозі записати метод для сортування всіх елементів в масиві, використовуючи сигнатуру, подібну до наступної, що приймає массив з <code>Object</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">sort</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Comparator</span> <span class="n">cmp</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коваріантність масивів була необхідною, так щоб масиви довільного типу посилання могли бути передані до метода <code>sort</code>. Звичайно, з появою Java дженериків такий метод <code>sort</code> тепер може бути написаний з параметром типу, так що коваріантність масивів більше не потрібна. Однак з причин сумісності вона дозволена в Java до цього дня.</p></div>
<div class="paragraph"><p>Scala намагається бути чистішою, ніж Java, не розглядаючи масиви як коваріантні. Ось що ми отримаємо, якщо перенесемо перші два рядкі приклада масива в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">a1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
        <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
                             <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це те, що Scala розглядає масиви як неваріантні (жорсткі), так що <code>Array[String]</code> не розглядається як сумісний з <code>Array[Any]</code>. Однак, іноді є необхідним взаємодіяти зі старими методами в Java, що використовують масив <code>Object</code>, як спосіб емуляції дженерік масивів. Наприклад, ви можете побажати викликати метод <code>sort</code>, як описаний до цього, з масивом <code>String</code> в якості аргумента. Щоб зробити це можливим, Scala дозволяє вам привести масив <code>T</code> до масива любого супертипу T:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">a1</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]]</span>
<span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Кастинг завжди легальний під час компіляції, та він буде завжди успішним під час виконання, тому що модель рантайма JVM трактує масиви як коваріантні, так само, як сама мова Java. Але після цього ви можете отримати виключення <code>ArrayStore</code>, знову так само, як це відбувається в Java.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_19_4___">19.4 Перевірка анотацій варіантності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили деякі приклади, де варіантність не має сенсу, ви можете поцікавитись, які визначення класу треба відсторонити, та які можуть бути прийнятними. Досі всі порушення сенсу типізації включали деяке переприсвоюване поле або елемент масиву. Чисто функціональна реалізація черги, з іншого боку, виглядає як гарний варіант на коваріантність. Однак наступний приклад показує, що ви можете "зінженерити" безглузду ситуацію, навіть якщо немає жодних переприсвоюваних полів.</p></div>
<div class="paragraph"><p>Щоб налаштувати приклад, будемо вважати, що черги, визначені в Лістингу 19.4, коваріантними. Потім створимо субклас черги, що спеціалізує тип елементу як <code>Int</code>, та перекриває метод <code>enqueue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StrangeIntQueue</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
    <span class="k">super</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>enqueue</code> з <code>StrangeIntQueue</code> роздруковує квадратний корінь свого (цілого) аргументу, перед виконанням власне додавання.</p></div>
<div class="paragraph"><p>Тепер ми можемо написати контрприклад в два рядки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StrangeIntQueue</span>
<span class="n">x</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший з ціх двох рядків валідний, бо <code>StrangeIntQueue</code> є субкласом <code>Queue[Int]</code>, і, зважаючи на коваріантність черг, <code>Queue[Int]</code> є субтипом <code>Queue[Any]</code>. Другий рядок є валідним, оскільки ви можете додати <code>String</code> до <code>Queue[Any]</code>. Однак, взяті разом, ці два рядка мають ефект застосування квадратного кореня до рядка, що не має сенсу.</p></div>
<div class="paragraph"><p>Зрозуміло, що це не тільки змінні поля, що робить коваріантні типи безглуздими. Проблема більш загальна. З'ясовується, що як тільки дженерік параметр типу з'являється як тип параметру метода, клас або трейт, що містить це, не може бути коваріантним по цьому параметру типу.</p></div>
<div class="paragraph"><p>Для черг метод <code>enqueue</code> порушує цю умову:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Виконуючи модифікований клас черги, як вище, через компілятор Scala, буде давати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">11</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">x</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
             <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Переприсвоювані поля є особливим випадком правила, що не дозволяє параметрам типу,анотованим з допомогою <code>+</code>, бути використаними як паратаметри типів в методах. Як зазначалось в Розділі 18.2, переприсвоюване поле, <code>var x: T</code>, трактується в Scala як метод геттер <code>def x: T</code>, та метод сеттер, <code>def x_=(y: T)</code>. Як ви можете бачити, метод сеттера має параметр типа поля <code>T</code>. Так що цей тип не може бути коваріантним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___39">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>В залишку цього розділу ми опишемо механізм, завдяки якому компілятор Scala перевіряє анотації варіантності. Якщо вам доки досить деталей, ви можете безпечно перейти до Розділу 19.5. Найбільш важлива річ, що треба зрозуміти, це що компілятор Scala буде перевіряти кожну анотацію варіантності, яку ви покладете до параметрів типу. Наприклад, якщо ви спробуєте декларувати параметр типу як коваріантний (через додавання <code>+</code>), але це призведе до потенційних помилок під час виконання, ваша програма не буде компілюватись.</p></div>
<div class="paragraph"><p>Щоб перевірити коректність анотацій варіантності, компілятор Scala класифікує всі позиції в тілі класу або трейта як позитівні, негативні, або нейтральні. "Позиція" є люба локація в тілі класу або трейта (відтепер будемо казати просто "клас"), де може використовуватись параметр типу. Наприклад, кожний параметр значення метода є позицією, оскільки значення параметру метода має тип. Таким чином, параметр типу може опинитись в цій позиції.</p></div>
<div class="paragraph"><p>Компілятор перевіряє кожне використання кожного з параметрів типу класа. Параметри типів, анотовані за допомогою <code>+</code>, можуть використовуватись в позитивних позиціях, тоді як параметри типів, анотовані за допомогою <code>-</code>, можуть бути використані тільки в негативних позиціях. Параметр типу, що не має анотації варіантності, може бути використаний в любій позиції, і, таким чином, є одним різновидом параметрів типу, що може використовуватись в нейтральних позиціях тіла класу.</p></div>
<div class="paragraph"><p>Щоб класифікувати позиції, компілятор починає з декларації параметру типу, та потім рухається всередину, через глибокі вкладені рівні. Позиції на верхньому рівні декларації класу класифікуються як позитивні. По замовчанню, позиції на глибших вкладених рівнях класифікуються так само, що і на оточуючих рівнях, але є декілька виключень, де класифікація змінюється. Параметри значень методів є позиції, де класифікація обертається відносно кваліфікації за межами метода, де позитивна класифікація стає негативно, негативна позитивною, та обертання нейтральної класифікації буде знову нейтральна.</p></div>
<div class="paragraph"><p>Крім позицій параметрів значень методів, поточна класифікація обертається на параметрах типів методу. Класифікація іноді обертається в позиції аргумента типу для типу, як в <code>Arg</code> в <code>C[Arg]</code>, в залежності від варіантності відповідного параметру типу. Якщо параметр типу типу <code>C</code> анотований з <code>+</code>, тоді класифікація залишається та сама. Якщо параметр типу <code>C</code> анотований з  <code>-</code>, тоді поточна класифікація обертається. Якщо параметр типу <code>C</code> не має анотацій варіантності, тоді поточна класифікація змінюється до нейтральної.</p></div>
<div class="paragraph"><p>Як дещо надуманий приклад, розглянемо наступне визначення класу, де декілька позицій анотовані за допомогою своєї класифікації, <code>^+</code> (для позитивної) або <code>^-</code> (для негативної):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Cat</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">meow</span><span class="o">[</span><span class="kt">W^-</span><span class="o">](</span><span class="n">volume</span><span class="k">:</span> <span class="kt">T^-</span><span class="o">,</span> <span class="n">listener</span><span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]^-)</span>
    <span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]</span><span class="kt">^-</span>, <span class="kt">U^+</span><span class="o">]^+</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Позиції параметру типу, <code>W</code>, та двох параметрів значень, <code>volume</code> та <code>listener</code>, є всі негативними. Дивлячись на результат <code>meow</code>, позиція першого аргумента <code>Cat[U, T]</code> є негативною, бо перший параметр типу <code>Cat</code>, <code>T</code>, анотований за допомогою <code>-</code>. Тип <code>U</code> в цьому аргументі знову в позитивній позиції (два обертання), Тоді як тип <code>T</code> в цьому аргументі все ще в негативній позиції. Ви бачите з цієї дискусії, що відстежувати позиції варіантності досить складно.</p></div>
<div class="paragraph"><p>Ось чому буде приємною новина, що компілятор Scala робить це за вас.</p></div>
<div class="paragraph"><p>Коли класифікація обчислена, компілятор перевіряє кожний параметр типу, що він використовується тільки в позиціях, де він відповідно класифікаваний. В цьому випадку <code>T</code> використовується тільки в негативних позиціях, та <code>U</code> тільки в позитивних позиціях. Так що клас <code>Cat</code> є типово коректним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_5__">19.5 Нижня межа</h2>
<div class="sectionbody">
<div class="paragraph"><p>Повертаючись до класу <code>Queue</code>. Ви бачили, що попереднє визначення <code>Queue[T]</code>, показане в Лістингу 19.4, не може бути зроблене коваріантним по <code>T</code>, оскільки <code>T</code> з'являється як параметр типу метода <code>enqueue</code>, і це негативна позиція.</p></div>
<div class="paragraph"><p>На щастя, є шлях роблокувати ситуацію: ви можете узагальнити <code>enqueue</code>, зробивши його поліморфним (тобто, надавши самому методу <code>enqueue</code> параметр типу), та використавши нижню межу для його параметру типу. Лістинг 19.6 показує нове формулювання <code>Queue</code>, що реалізує цю ідею.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">(</span><span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span> <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.6 - Параметр типу з нижньою межею.</p></div>
<div class="paragraph"><p>Нове визначення надає <code>enqueue</code> параметр типу <code>U</code>, та за допомогою синтаксиса <code>U &gt;: T</code> визначає <code>T</code> як нижню межу для <code>U</code>. Як результат, від <code>U</code> вимагається бути субтипом  <code>T</code>.<span class="footnote"><br />[Відношення субтипу та супертипу є рефлексивними, що означає, що тип є одночасно супертипом та субтипом себе. Навіть якщо <code>T</code> є нижньою межею для <code>U</code>, ви все ще можете передати в <code>enqueue</code> <code>T</code>.]<br /></span> Параметр <code>enqueue</code> тепер є типу <code>U</code>, замість <code>T</code>, та повернене значення метода тепер <code>Queue[U]</code>, замість <code>Queue[T]</code>.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що є клас <code>Fruit</code> з двома субкласами, <code>Apple</code> та <code>Orange</code>. З новим визначенням класу <code>Queue</code> можливо додати <code>Orange</code> до <code>Queue[Apple]</code>. Результатом буде <code>Queue[Fruit]</code>.</p></div>
<div class="paragraph"><p>Це модифіковане визначення <code>enqueue</code> типово коректне. Інтуітивно, якщо <code>T</code> є більш специфічним типом, ніж очікується (наприклад, <code>Apple</code> замість <code>Fruit</code>), виклик до <code>enqueue</code> все одно буде робити, оскільки <code>U</code> (<code>Fruit</code>) буде все ще супертипом типу <code>T</code> (<code>Apple</code>).<span class="footnote"><br />[Технічно, те що відбувається, це обернення для нижньої межі. Параметр типу <code>U</code> є в негативній позиції (1 обернення), тоді як нижня межа (<code>&gt;: T</code>) в позитивній позиції (2 обернення).]<br /></span></p></div>
<div class="paragraph"><p>Нове визначення <code>enqueue</code> є, можливо, кращим, ніж старе, оскільки воне більш загальне. На відміну від старої версії, нове визначення дозволяє вам додати довільний супертип <code>U</code> типу елемента черги <code>T</code>. Після цього результатом буде <code>Queue[U]</code>. Разом з коваріантністю черги, це дає правильний різновід гнучкості для моделювання черг з різними типами елементів в природний спосіб.</p></div>
<div class="paragraph"><p>Це показує, що анотації варіантності та ніжні межі гарно грають разом. Вони є гарним прикладом типо-рушійної розробки, де типи інтерфейсів направляють її детальний дизайн та реалізацію. В випадку черг, можливо, ви не будете розмірковувати щодо покращеної реалізації <code>enqueue</code> з нижньою межею. Але ви можете вирішити зробити чергу коваріантною, в якому випадку компілятор буде вказувати на помилку варіантностів в <code>enqueue</code>. Корегування помилки варіантності через додавання нижньої межі робить <code>enqueue</code> більш загальним, та черги загалом більш корисними.</p></div>
<div class="paragraph"><p>Це дослідження також є головною причиною того, що Scala обирає варіантність на стороні декларації, замість варіантності на боці використання, як це відбувається в замінниках Java. З варіантністю на боці використання, ви наодинці при розробці свого класу. Це буде клієнт класу, той, що покладатиме підстановку, і якщо він зробить щось не так, деякі важливі методи примірників будуть більше незастосовні. Варіантність залишається хитрою справою, користувачі часто розміють її невірно, та вони ідуть геть, думаючи, що підстановки та дженеріки дуже ускладнені. З варіантністю на боці визначення ви викладаєте ваші наміри компілятору, та компілятор двічи перевірить, що методи, які ви бажаєте, будуть доступними.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_6_">19.6 Контрваріантність</h2>
<div class="sectionbody">
<div class="paragraph"><p>Докі в цій главі всі приклади, що ви бачили, були або коваріантними, або неваріантними. Але також є випадки, коли є природною контрваріантність. Наприклад, розглянемо трейт вихідного каналу, показаний на Лістингу 19.7:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">OutputChannel</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.7 - Контрваріантний вихідний канал.</p></div>
<div class="paragraph"><p>Тут <code>OutputChannel</code> визначений бути контрваріантним по <code>T</code>. Так що, скажімо, вихідний канал <code>AnyRefs</code> є субтипом вихідного каналу <code>Strings</code>. Хоча це може виглядати неінтуітивним, насправді це має сенс. Щоб побачити чому, розглянемо, що ви можете робити з <code>OutputChannel[String]</code>. Одна підтримувана операція є запис <code>String</code> в канал. Та сама операція може також бути виконана на <code>OutputChannel[AnyRef]</code>. Так що безпечно підставити <code>OutputChannel[AnyRef]</code> замість <code>OutputChannel[String]</code>. Для контрасту, може бути небезпечним підставити <code>OutputChannel[String]</code> там, де потрібен <code>OutputChannel[AnyRef]</code>. Кінець кінцем, ви можете надіслати любий об'єкт до <code>OutputChannel[AnyRef]</code>, в той час, коли <code>OutputChannel[String]</code> потребує щоб всі записані елементи були рядками.</p></div>
<div class="paragraph"><p>Ці міркування вказують на загальний принцип в розробці системи типів: безпечно вважати, що тип <code>T</code> є субтипом типу <code>U</code>, якщо ви можете підставити значення <code>T</code> там, де вимагається значення типу <code>U</code>. Це називається принципом підстановки Ліскова. Принцип стверджує, що тоді <code>T</code> підтримує ті самі операції, що і <code>U</code>, та всі операції <code>T</code> потребують меньше, та провадять більше, ніж відповідні операції <code>U</code>. В цьому випадку з вихідними каналами, <code>OutputChannel[AnyRef]</code> може бути субтипом <code>OutputChannel[String]</code>, оскільки обоє підтримують ту саму операцію <code>write</code>, та ця операція потребує меньше в <code>OutputChannel[AnyRef]</code>, ніж в <code>OutputChannel[String]</code>. "Меньше" означає, що від аргумента вимагається тільки бути <code>AnyRef</code> в першому випадку, тоді як він має бути  <code>String</code> в другому випадку.</p></div>
<div class="paragraph"><p>Іноді коваріантність та контрваріантність змішані в одному типі. Яскравий приклад є функціональні трейти Scala. Наприклад, коли ви пишете функціональний тип <code>A =&gt; B</code>, Scala розширює це до <code>Function1[A, B]</code>. Визначення <code>Function1</code> в стандартній бібліотеці використовує одночасно коваріантність та контрваріантність: трейт <code>Function1</code> є контрваріантним по функціональному типу аргумента <code>S</code>, та коваріантним по типу результату <code>T</code>, як показано в Лістингу 19.8. Це задовільняє принципу підстановки Ліскова, оскільки аргументи є іноді тим, що вимагається, тоді як результат іноді те, що було запроваджено.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-S</span>, <span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.8 - Коваріантність та контрваріантність <code>Function1s</code>.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо застосування, показане в Лістингу 19.9. Тут клас <code>Publication</code> містить одно параметричне поле, <code>title</code>, типу <code>String</code>. Клас <code>Book</code> розширює <code>Publication</code>, та пересилає його параметр <code>title</code> в конструктор свого суперкласу. Об'єкт синглтон <code>Library</code> визначає набір книжок, та метод <code>printBookList</code>, що приймає функцію на ім'я <code>info</code>, типу <code>typeBook =&gt; AnyRef</code>. Іншими словами, тип єдиного параметра <code>printBookList</code> є функцією, що приймає один аргумент <code>Book</code>, та повертає <code>AnyRef</code>. Застосування <code>Customer</code> визначає метод <code>getTitle</code>, що приймає <code>Publication</code> як свій єдиний параметр, та повертає <code>String</code>, заголовок переданого <code>Publication</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Publication</span><span class="o">(</span><span class="k">val</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Publication</span><span class="o">(</span><span class="n">title</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">&quot;Programming in Scala&quot;</span><span class="o">),</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">&quot;Walden&quot;</span><span class="o">)</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="n">printBookList</span><span class="o">(</span><span class="n">info</span><span class="k">:</span> <span class="kt">Book</span> <span class="o">=&gt;</span> <span class="nc">AnyRef</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">book</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">info</span><span class="o">(</span><span class="n">book</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Customer</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">getTitle</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Publication</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">title</span>
  <span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.9 - Демонстрація варіантності параметру типу функції.</p></div>
<div class="paragraph"><p>Тепер поглянемо на останній рядок <code>Customer</code>. Цей рядок викликає метод <code>Library</code>  <code>printBookList</code>, та передає <code>getTitle</code>, оточений в функціональне значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей рядок коду проходить перевірку типів, навіть якщо <code>String</code>, тип результату функції, є субтипом <code>AnyRef</code>, типу результата параметра <code>info</code> метода <code>printBookList</code>. Цей код проходить компілятор, оскільки типи результата функції декларований як коваріантний (<code>+T</code> в Лістингу 19.8). Якщо ви подивитесь в тіло <code>printBookList</code>, ви можете отримати проблиск, чому це має сенс.</p></div>
<div class="paragraph"><p>Метод <code>printBookList</code> ітерує по своєму списку книжок, та викликає передану функцію для кожної книжки. Він передає результат <code>AnyRef</code>, що повертає <code>info</code>, до <code>println</code>, що викликає на ньому <code>toString</code>, та друкує результат. Ця активність буде робити зі <code>String</code> так само, як і інші субкласи <code>AnyRef</code>, що саме і означає коваріантність результату функції.</p></div>
<div class="paragraph"><p>Тепер розглянемо тип параметру функції, коли він передається до метода <code>printBookList</code>. Хоча тип параметра <code>printBookList</code> декларований як <code>Book</code>, <code>getTitle</code>, яку ми передаємо туди, приймає <code>Publication</code>, супертип <code>Book</code>. Причина, чому це робить, полягає в тому, що оскільки тип параметра <code>printBookList</code> є <code>Book</code>, в тілі метода <code>printBookList</code> буде дозволено передати <code>Book</code> в функцію. І оскількі тип параметра <code>getTitle</code> є <code>Publication</code>, тіло цієї функції буде в змозі отримати доступ тільки до свого параметра, <code>p</code>, члени якого декларовані в класі <code>Publication</code>. Оскільки любий метод, декларований в <code>Publication</code> також доступний в субкласі <code>Book</code>, все повинно робити, що є саме те, що означає контрваріантність функціонального параметру. Ви можете бачити все це графічно на Малюнку 19.1.</p></div>
<div class="paragraph"><p>Код в Лістингу 19.9 компілюється, оскільки <code>Publication =&gt; String</code> є субтипом <code>Book =&gt; AnyRef</code>, як показано в центрі Малюнка 19.1. Оскільки тип результата <code>Function1</code> є визначеним як коваріантний, відношення наслідування двох типів результату, показані справа діаграми, є в тому самому напрямку, що той у двох функцій, показаних в центрі. По контрасту, оскільки тип параметра <code>Function1</code> визначений як контрваріантний, відношення наслідування двох типів параметрів, показаних зліва від діаграми, ідуть в зворотньому напрямку, ніж ті для двох функцій.</p></div>
<div class="paragraph"><p>Малюнок 19.1 - Коваріантність і контрваріантність в параметрах типів функції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span><span class="o">()</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">trailing</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">leading</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">leading</span>
        <span class="n">trailing</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">tail</span>
      <span class="o">}</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="n">leading</span><span class="o">.</span><span class="n">head</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.10 - Оптимізована функціональна черга.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_7____">19.7 Приватні дані об'єкта</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас <code>Queue</code>, яку ми бачили до цього, має проблему в тому, що операція <code>mirror</code> буде постійно копіювати список <code>trailing</code> в <code>leading</code>, якщо <code>head</code> буде викликатись декілька разів поспіль для списку, коли <code>leading</code> є порожнім. Марного копіювання можна уникнути, додаючи деякі розсудливі побічні ефекти. Лістинг 19.10 презентує нову реалізацію <code>Queue</code>, що виконує щонайбільше одне коригування <code>trailing</code> до <code>leading</code> для кожної послідовності операцій <code>head</code>.</p></div>
<div class="paragraph"><p>Що тут відмінне з точки зору попередньої версії, є те, що тепер <code>leading</code> та <code>trailing</code> є переприсвоювані змінні, і <code>mirror</code> виконує реверсивну копію від <code>trailing</code> до <code>leading</code> як побічний ефект на поточній черзі, замість повернення нової черги. Цей побічний ефект чисто внутрішній відносно до реалізації операцій <code>Queue</code>; оскільки <code>leading</code> та <code>trailing</code> є приватними змінними, ефект не є видимий для клієнтів <code>Queue</code>. Так що за термінологією, встановленою в Главі 18, нова версія <code>Queue</code> все ще визначає чисто функціональні об'єкти, не зважаючи на факт, що вони тепер містять переприсвоювані поля.</p></div>
<div class="paragraph"><p>Ви можете поцікавитись, чи цей код пройде перевірку типів Scala. Кінець кінцем, тепер черги містять два переприсвоювані поля коваріантного параметру типу <code>T</code>. Чи це не порушення правил варіантності? Це було б так, за винятком тої деталі, що <code>leading</code> та <code>trailing</code> мають модифікатор <code>private[this]</code>, і, таким чином декларовані як приватні до об'єкта.</p></div>
<div class="paragraph"><p>Як зазначалось в Розділі 13.5, приватні до об'єкта члени можуть отримувати доступ тільки з того самого об'єкта, де вони визначені. З'ясовується, що доступ до змінних з того самого об'єкта, в якому вони визначені, не викликають проблем з варіантністю. Інтуітивне пояснення в тому, що щоб сконструювати випадок, коли варіантність призведе до помилки типів, вам треба мати посилання на містячий об'єкт, що має статично слабший тип, ніж тип об'єкта, з яким об'єкт був визначений. Але для доступу до об'єкт приватних значень це неможливо.</p></div>
<div class="paragraph"><p>Перевірка варіантності в Scala містить особливий випадок для об'єкт приватних визначень. Такі визначення оминаються при перевірці, що параметр типу з анотаціями <code>+</code> або <code>-</code> з'являється лише в позиціях, що мають ту саму класифікацію варіантності. Таким чином, код в Лістингу 19.10 компілюється без помилок. З іншого боку, якщо ви приберете кваліфікатор <code>[this]</code> для двох  модифікаторів <code>private</code>, ви побачите дві помилки типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">of</span> <span class="n">parameter</span> <span class="n">of</span>
<span class="n">setter</span> <span class="n">leading_=</span>
<span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span><span class="k">private</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
                                     <span class="o">^</span>
<span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">of</span> <span class="n">parameter</span> <span class="n">of</span>
<span class="n">setter</span> <span class="n">trailing_=</span>
                        <span class="k">private</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
                                    <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_8__">19.8 Верхня межа</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Лістингу 16.1 ми показали функцію сортування злиттям для списків, що приймає функцію порівняння як перший аргумент, і список для сортування в якості другого, каровані аргументи. Інший шлях, як ви можете організувати таку функцію сортування, це змусити тип списку зміксувати трейт <code>Ordered</code>. Як зазначалось в Розділі 12.4, через міксування <code>Ordered</code> в клас, та реалізуючи єдиний абстрактний метод <code>Ordered</code>, <code>compare</code>, ви дозволяєте клієнтам порівнювати примірники цього класу за допомогою <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, та <code>&gt;=</code>. Наприклад, Лістинг 19.11 показує <code>Ordered</code>, що зміксовано в клас <code>Person</code>.</p></div>
<div class="paragraph"><p>Як результат ви можете порівнювати двох людей, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">robert</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Robert&quot;</span><span class="o">,</span> <span class="s">&quot;Jones&quot;</span><span class="o">)</span>
<span class="n">robert</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="nc">Robert</span> <span class="nc">Jones</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sally</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Sally&quot;</span><span class="o">,</span> <span class="s">&quot;Smith&quot;</span><span class="o">)</span>
<span class="n">sally</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="nc">Sally</span> <span class="nc">Smith</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">robert</span> <span class="o">&lt;</span> <span class="n">sally</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">firstName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">lastNameComparison</span> <span class="k">=</span>
      <span class="n">lastName</span><span class="o">.</span><span class="n">compareToIgnoreCase</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">lastName</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lastNameComparison</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">lastNameComparison</span>
    <span class="k">else</span>
      <span class="n">firstName</span><span class="o">.</span><span class="n">compareToIgnoreCase</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">firstName</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">firstName</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">lastName</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.11 - Клас <code>Person</code>, міксує трейт <code>Ordered</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">orderedMergeSort</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">ys</span><span class="o">),</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">zs</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.12 - Функція сортування злиттям з верхньою межею.</p></div>
<div class="paragraph"><p>Щоб змусити тип списку, що передається в нову функцію сортування, міксувати <code>Ordered</code>, вам треба встановити верхню межу. Верхня межа вказується подібно до нижньої межі, за винятком того, що замість символа <code>&gt;:</code>, що використовується для нижньої межі, ви використовуєте символ <code>&lt;:</code>, як показано в Лістингу 19.12.</p></div>
<div class="paragraph"><p>З синтаксисом <code>T &lt;: Ordered[T]</code> ви вказуєте, що параметр типу, <code>T</code>, має верхню межу,<code>Ordered[T]</code>. Це означає, що тип елемента списка, переданого до <code>orderedMergeSort</code>, має бути субтипом від <code>Ordered</code>. Таким чином, ви можете передати <code>List[Person]</code> до <code>orderedMergeSort</code>, оскільки <code>Person</code> зміксований з <code>Ordered</code>.</p></div>
<div class="paragraph"><p>Наприклад, розглянемо цей список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Larry&quot;</span><span class="o">,</span> <span class="s">&quot;Wall&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Anders&quot;</span><span class="o">,</span> <span class="s">&quot;Hejlsberg&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Guido&quot;</span><span class="o">,</span> <span class="s">&quot;van Rossum&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Alan&quot;</span><span class="o">,</span> <span class="s">&quot;Kay&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Yukihiro&quot;</span><span class="o">,</span> <span class="s">&quot;Matsumoto&quot;</span><span class="o">)</span>
       <span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Larry</span> <span class="nc">Wall</span><span class="o">,</span> <span class="nc">Anders</span> <span class="nc">Hejlsberg</span><span class="o">,</span>
  <span class="nc">Guido</span> <span class="n">van</span> <span class="nc">Rossum</span><span class="o">,</span> <span class="nc">Alan</span> <span class="nc">Kay</span><span class="o">,</span> <span class="nc">Yukihiro</span> <span class="nc">Matsumoto</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки тип елемента цього списка, <code>Person</code>, міксується (і таким чином є його субтипом) <code>Ordered[People]</code>, ви можете передати список до <code>orderedMergeSort</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sortedPeople</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">people</span><span class="o">)</span>
<span class="n">sortedPeople</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Anders</span> <span class="nc">Hejlsberg</span><span class="o">,</span> <span class="nc">Alan</span> <span class="nc">Kay</span><span class="o">,</span>
  <span class="nc">Yukihiro</span> <span class="nc">Matsumoto</span><span class="o">,</span> <span class="nc">Guido</span> <span class="n">van</span> <span class="nc">Rossum</span><span class="o">,</span> <span class="nc">Larry</span> <span class="nc">Wall</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, хоча функція сортування, показана в Лістингу 19.12, служить як корисна ілюстрація верхньої межі, насправді це не найбільш загальний шлях в Scala для розробки функції сортування, що набуває вигод від трейту <code>Ordered</code>.</p></div>
<div class="paragraph"><p>Наприклад, ви не можете використовувати функцію <code>orderedMergeSort</code> для сортування списку цілих, оскільки клас <code>Int</code> не є субтипом <code>Ordered[Int]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wontCompile</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">inferred</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">do</span>
   <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="n">method</span> <span class="n">orderedMergeSort</span><span class=" -Symbol">&#39;s</span> <span class="k">type</span>
      <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
        <span class="k">val</span> <span class="n">wontCompile</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
                          <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>В Розділі 21.6 ми побачимо, як використовувати неявні параметри та обмеження контекстів, щоб досягти більш загального рішення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_9_">19.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили декілька прийомів для приховування інформації: приватні конструктори, методи фабрик, абстракції типів та об'єкт приватні члени. Ви також навчились, як задавати варіантність типів, та що це накладає на реалізацію класів. Нарешті, ви бачили два прийоми, що допоможуть в отриманні гнучких анотацій варіантності: нижні межі для параметрів типу методів, та анотації <code>private[this]</code> для локальних полів та методів.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__20">Глава 20</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___40">Абстрактні члени</h1>
<div class="paragraph"><p>Член класа або трейта є абстрактним, якщо член не має повного визначення в класі. Абстрактні члени призначені бути реалізованими в субкласах класа, в якому вони визначені. Ця ідея знаходиться в багатьох об'єктно-рієнтованих мовах. Наприклад, Java дозволяє вам декларувани абстрактні методи. Scala також дозволяє вам декларувати такі методи, як ви бачили в Розділі 10.2. Але Scala іде далі, і реалізує ідею в своїй повній загальності: крім методів, ви можете декларувати абстрактні поля, та навіть абстрактні типи, як члени класів та трейтів.</p></div>
<div class="paragraph"><p>В цій главі ми опишемо всі типи абстрактних членів: <code>val</code>, <code>var</code>, методи та типи. По ходу ми обсудимо наперед-ініціалізовані поля, ліниві <code>val</code>, шлях-залежні типи та енумерації.</p></div>
<div class="sect1">
<h2 id="_20_1_____">20.1 Швидкий тур для абстрактних членів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наступний трейт декларує по одному з кожного типу абстрактних членів: абстрактний тип (<code>T</code>), метод (<code>transform</code>), <code>val</code> (<code>initial</code>), та <code>var</code> (<code>current</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Суцільна реалізація <code>Abstract</code> потребує заповнення визначень для кожного з його абстрактних членів. Ось приклад реалізації, що провадить ці визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Concrete</span> <span class="k">extends</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
  <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">initial</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація надає певне значення типу на ім'я <code>T</code>, через його визначення як псевдониму до типу <code>String</code>. Операція <code>transform</code> конкатенує наданий рядок з собою, та значення <code>initial</code> та <code>current</code> обоє встановлені в <code>"hi"</code>.</p></div>
<div class="paragraph"><p>Цей приклад надає вам грубу першу ідею щодо типів абстрактних членів, що існують в Scala. Залишок глави буде презентувати деталі, та пояснювати, для чого гарні нові форми абстрактних членів, так само, як і типи членів взагалі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_2__">20.2 Члени типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви можете бачити з приклада в попередньому розділі, термін <em>абстрактний тип</em> в Scala означає тип, декларований (за допомогою ключового слова <code>type</code>) як член класу або трейта, без вказання визначення. Класи самі можуть бути абстрактними, та трейти по визначенню абстрактні, але на жодний з них не посилаються як на абстрактні типи в Scala. Абстрактний тип в Scala завжди є членом деякого класу або трейта, як тип <code>T</code> в трейті <code>Abstract</code>.</p></div>
<div class="paragraph"><p>Ви можете думати про не-абстрактні (або <em>суцільні</em>) члени типів, як тип <code>T</code> в класі <code>Concrete</code>, як шлях для визначення нового визначення, або псевдоним, для типу. Наприклад, в класі <code>Concrete</code>, типу <code>String</code> наданий псевдоним <code>T</code>. Як результат, будь-де, де з'являється <code>T</code> в визначенні класа <code>Concrete</code>, це означає <code>String</code>. Це включає параметр і типи результатів для <code>transform</code>, <code>initial</code> та <code>current</code>, які згадують <code>T</code>, коли вони декларовані в супертрейті <code>Abstract</code>. Таким чином, коли клас <code>Concrete</code> реалізує ці методи, ці <code>T</code> інтерпретуються щоб означати <code>String</code>.</p></div>
<div class="paragraph"><p>Одна з причин для використання члена типу є визначення коротких, описових псевдонимів для типів, чиє дійсне ім'я більш балакуче, або менш очевидне за значенням, ніж псевдоним. Такі члени типів можуть допомогти прояснити код класа або трейта. Інше головне використання членів типа є декларація абстрактних типів, що мають бути визначені в субкласах. Це використання, що було продемонстроване в попередньому розділі, буде детально описане в цій главі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_3__val">20.3 Абстрактні val</h2>
<div class="sectionbody">
<div class="paragraph"><p>Абстрактна декларація <code>val</code> має таку форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона надає ім'я та тип для <code>val</code>, але не його значення. Це значення має бути запровадження через суцільне визначення <code>val</code> в субкласі. Наприклад, клас <code>Concrete</code> реалізує <code>val</code> з використанням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви використовуєте абстрактну декларацію <code>val</code> в класі, коли ви не знаєте коректного значення в класі, але ви знаєте, що змінна буде мати незмінне значення для кожного примірника класа.</p></div>
<div class="paragraph"><p>Абстрактна декларація <code>val</code> повторює декларацію абстрактного безпараметричного метода, декларованого таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Клієнтській код може посилатись на обох, <code>val</code> та метод, в точно той самий спосіб (тобто, <code>obj.initial</code>). Однак, якщо <code>initial</code> є абстрактна <code>val</code>, клієнту гарантовано, що <code>obj.initial</code> буде давати те саме значення кожний раз, коли на нього посилаються. Якщо <code>initial</code> буде абстрактний метод, ця гарантія не виконується, оскільки в цьому випадку <code>initial</code> може бути реалізований суцільним методом, що повертає різне значення при кожному виклику.</p></div>
<div class="paragraph"><p>Іншими словами, абстрактний <code>val</code> обмежує свою легальну реалізацію: люба реалізація може бути визначенням <code>val</code>; це не може бути <code>var</code> або <code>def</code>. З іншого боку, абстрактні декларації методів можуть бути реалізовані на вибір, як визначення суцільного метода, або як суцільне визначення <code>val</code>. Беручи абстрактний клас <code>Fruit</code>, показаний в Лістингу 20.1, клас <code>Apple</code> буде легальною реалізацією субкласа, але клас <code>BadApple</code> ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// v означає value</span>
  <span class="k">def</span> <span class="n">m</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// m означає method</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// OK перекривати def за допомогою val</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BadApple</span> <span class="k">extends</span> <span class="nc">Fruit</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// ПОМИЛКА: не можна перекривати val за допомогою def</span>
  <span class="k">def</span> <span class="n">m</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.1 - Перекриття абстрактного <code>val</code> та безпараметрного метода.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_4__var">20.4 Абстрактні var</h2>
<div class="sectionbody">
<div class="paragraph"><p>Подібно до абстрактного <code>val</code>, абстрактний <code>var</code> декларує лише ім'я і тип, але не початкове значення. Наприклад, Лістинг 20.2 показує трейт <code>AbstractTime</code>, що декларує дві абстрактні змінні на ім'я <code>hour</code> та <code>minute</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">AbstractTime</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.2 - Декларація абстрактних <code>var</code>.</p></div>
<div class="paragraph"><p>Яке значення має визначення абстрактних <code>var</code>, як <code>hour</code> та <code>minute</code>?Ви бачили в Розділі 18.2, що <code>var</code>, задекларовані як члени класів ідуть обладнані методвами геттера та сеттера. Це дотримується також і для абстрактних методів. Якщо ви, наприклад, декларуєте абстрактний <code>var</code> на ім'я <code>hour</code>, ви неявно декларуєте абстрактний метод геттера, <code>hour</code>, та абстрактний метод сеттера, <code>hour_=</code>. Немає переприсвоюваного поля, що треба визначати — він надійде в субкласах, що визначають суцільну реалізацію абстрактного <code>var</code>. Наприклад, визначення <code>AbstractTime</code>, показане в Лістингу 20.2, в точності еквівалентна до визначення, показаній в Лістингу 20.3.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">AbstractTime</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// геттер для hour</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// сеттер для hour</span>
  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// геттер для minute</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// сеттер для minute</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.3 - Як абстрактні <code>var</code> розширюються в геттери та сеттери.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_5___val">20.5 Ініціалізація абстрактних val</h2>
<div class="sectionbody">
<div class="paragraph"><p>Абстрактні <code>val</code> іноді грають роль, аналогічну до параметрів суперкласу: вони дозволяють вам провадити деталі в субкласі, що відсутні в суперкласі. Це зокрема важливо для трейтів, оскільки трейти не мають конструктора, до якого ви можете передати параметри. Так що звичайна нотація параметризації трейтів робить через абстрактні <code>val</code>, що реалізовані в субкласах.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо переформулювання класу <code>Rational</code> з Глави 6, як показано на Лістингу 6.5, в вигляді трейта:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас <code>Rational</code> з Глави 6 має два параметри: <code>n</code> для чисельника раціонального числа, та <code>d</code> для займенника. Наданий тут трейт <code>RationalTrait</code> визначає замість цього абстрактні <code>val</code>: <code>numerArg</code> та <code>denomArg</code>. Щоб створити суцільний примірник цього трейту, вам треба реалізувати визначення <code>val</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ключове слово <code>new</code> з'являється перед іменем трейта, <code>RationalTrait</code>, за яким слідує тіло класа в фігурних дужках. Цей вираз дає примірник анонімного класу, що міксує трейт, та визначений в тілі. Цей окремий примірник анонімного класу має ефект, аналогічний створенню примірника <code>new Rational(1, 2)</code>.</p></div>
<div class="paragraph"><p>Однак аналогія недосконала. Існує тонка різниця щодо порядку, в якому ініціалізуються вирази. Коли ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">expr1</span><span class="o">,</span> <span class="n">expr2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>два вирази, <code>expr1</code> та <code>expr2</code>, обчислюються перед тим, як буде ініціалізований клас <code>Rational</code>, так що значення <code>expr1</code> та <code>expr2</code> доступні для ініціалізації класу <code>Rational</code>.</p></div>
<div class="paragraph"><p>Для трейтів ситуація протилежна. Коли ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="n">expr1</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="n">expr2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>вирази <code>expr1</code> та <code>expr2</code> обчислюються як частина ініціалізації анонімного класу, але анонімний клас ініціалізується <em>після</em>  <code>RationalTrait</code>. Так що значення <code>numerArg</code> та <code>denomArg</code> не доступні впродовж ініціалізації <code>RationalTrait</code> (більш точно, вибір любого зі значень буде давати значення по замовчанню для типу <code>Int</code>, <code>0</code>). Для визначення наданого вище <code>RationalTrait</code> це не проблема, оскільки ініціалізація трейта на використовує значення значень <code>numerArg</code> або <code>denomArg</code>. Однак це стає проблемою в варіанті <code>RationalTrait</code>, показаному в Лістингу 20.4, що визначає нормалізовані чисельник та займенник.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.4 - Трейт, що використовує свої абстрактні <code>val</code>.</p></div>
<div class="paragraph"><p>Якщо ви спробуєте створити примірник цього трейту з деякими виразами чисельника та займенника, що не є простими літералами, ви отримаєте виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
          <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
        <span class="o">}</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">IllegalArgumentException</span><span class="k">:</span> <span class="kt">requirement</span> <span class="kt">failed</span>
<span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="nc">Predef</span><span class="n">$</span><span class="o">.</span><span class="n">require</span><span class="o">(</span><span class="nc">Predef</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">207</span><span class="o">)</span>
<span class="n">at</span> <span class="nc">RationalTrait$class</span><span class="o">.</span><span class="nc">$init</span><span class="n">$</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="o">)</span>
<span class="o">...</span> <span class="mi">28</span> <span class="n">elided</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі виключення буде закинено через те, що <code>denomArg</code> все ще має значення по замовчанню, <code>0</code>, коли клас <code>RationalTrait</code> було ініціалізовано, що спричиняє збій при виклику <code>require</code>.</p></div>
<div class="paragraph"><p>Цей приклад демонструє, що порядок ініціалізації не той самий для параметрів класів та абстрактних полів. Аргумент параметру класа обчислюється до того, як воно передається в клнструктор класу (за винятком коли параметр є за-ім'ям). Для контрасту, реалізація визначення <code>val</code> в субкласі обчислюється тільки після того, як суперклас був ініціалізований.</p></div>
<div class="paragraph"><p>Тепер, коли ви розумієте, чому абстрактні <code>val</code> поводяться інакше, ніж параметри, гарно буде знати, що ми можемо з цім робити. Чи можливо визначити <code>RationalTrait</code>, що може бути ініціалізований надійно, без старху помилок через неініціалізовані поля? Фактично, Scala пропонує альтернативні рішення до цієї проблеми, пре-ініціалізовані поля та ліниві <code>val</code>. Вони представлені і залишку цього розділу.</p></div>
<div class="sect2">
<h3 id="____22">Пре-ініціалізовані поля</h3>
<div class="paragraph"><p>Перше рішення, пре-ініціалізовані поля, дозволяє вам ініціалізувати поле субкласа перед тим, як буде викликано субклас. Щоб зробити це, просто покладіть визначення поля в фігурних дужках перед викликом конструктора суперкласа. Як приклад, Лістинг 20.5 показує іншу спробу створити примірник <code>RationalTrait</code>. Як ви бачите з приклада, розділ ініціалізації іде перед зазначенням супертрейта  <code>RationalTrait</code>. Обоє розділені <code>with</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">RationalTrait</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.5 - Пре-ініціалізовані поля в виразі анонімного класу.</p></div>
<div class="paragraph"><p>Пре-ініціалізовані поля не обмежуються до анонімних класів; вони можуть також застосовуватись в об'єктах або іменованих субкласах. Два приклада показані в Лістингах 20.6 та 20.7. Як ви можете бачити з ціх прикладів, розділ пре-ініціалізації кожний раз іде після ключового слова <code>extends</code> визначеного об'єкта або класа. Клас <code>RationalClass</code>, показаний в Лістингу 20.7, надає приклад загальної схеми того, як параметри класів можуть бути зроблені доступними для ініціалізації супертрейта.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">twoThirds</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">3</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.6 - Пре-ініціалізовані поля в визначенні об'єкта.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RationalClass</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="n">d</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">RationalClass</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RationalClass</span><span class="o">(</span>
    <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
    <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.7 - Пре-ініціалізовані поля в визначенні класу.</p></div>
<div class="paragraph"><p>Оскільки пре-ініціалізовані поля є ініціалізовані перед викликом конструктора суперкласа, їх ініціалізатори не можуть посилатись на об'єкт, що наразі конструюється. Відповідно, якщо такий ініалізатор посилається на <code>this</code>, посилання іде на об'єкт, що містить клас або об'єкт, який конструюється, не на самий створюваний об'єкт.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numerArg</span> <span class="o">*</span> <span class="mi">2</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">numerArg</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">object</span>
<span class="nc">$iw</span>
                <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numerArg</span> <span class="o">*</span> <span class="mi">2</span>
                                    <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад не компілюється, оскільки посилання <code>this.numerArg</code> шукає  <code>numerArgfield</code> в об'єкті, що містить <code>new</code> (що в цьому випадку є синтетичним об'єктом на ім'я <code>$iw</code>, в який інтерпретатор покладає поля, що вводить користувач). Ще раз, пре-ініціалізовані поля поводяться в цьому відношенні як аргументи конструктора класа.</p></div>
</div>
<div class="sect2">
<h3 id="__code_val_code">Ліниві <code>val</code></h3>
<div class="paragraph"><p>Ви можете використовувати пре-ініціалізовані поля для точної симуляції поведінки ініціалізації аргументів конструкторів класу. Однак іноді ви можете обрати дозволити системі самій з'ясувати, які речі мають бути ініціалізовані. Це може бути досягнуто через створення ваших визначень <code>val</code> як <code>lazy</code>. Якщо перед <code>val</code> поставити модифікатор <code>lazy</code>, вираз ініціалізації в правій стороні буде обчислений тільки перший раз, коли використовується <code>val</code>.</p></div>
<div class="paragraph"><p>Наприклад, визначимо об'єкт <code>Demo</code> з <code>val</code> наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;initializing x&quot;</span><span class="o">);</span> <span class="s">&quot;done&quot;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">defined</span> <span class="k">object</span> <span class="nc">Demo</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, спочатку посилаємось на <code>Demo</code>, потвм на <code>Demo.x</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span>
<span class="n">initializing</span> <span class="n">x</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Demo.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Demo</span><span class="n">$</span><span class="k">@</span><span class="mi">2129</span><span class="n">a843</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span><span class="o">.</span><span class="n">x</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">done</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, коли ви використовуєте <code>Demo</code>, його поле <code>x</code> стає ініціалізованим. Ініціалізація <code>x</code> формує частину ініціалізації <code>Demo</code>. Ситуація змінюється, якщо ви визначите поле <code>x</code> як <code>lazy</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;initializing x&quot;</span><span class="o">);</span> <span class="s">&quot;done&quot;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">defined</span> <span class="k">object</span> <span class="nc">Demo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Demo.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Demo</span><span class="n">$</span><span class="k">@</span><span class="mi">5</span><span class="n">b1769c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span><span class="o">.</span><span class="n">x</span>
<span class="n">initializing</span> <span class="n">x</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">done</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ініціалізація <code>Demo</code> не включає ініціалізацію <code>x</code>. Ініціалізація <code>x</code> буде відкладена, доки <code>x</code> не буде ініціалізоване перший раз. Це подібно до ситуації, коли <code>x</code> визначена як безпараметричний метод з використанням <code>def</code>. Однак, на відміну від <code>def</code>, <code>lazy val</code> ніколи не визначається більше ніж один раз. Фактично, після першого обчислення <code>lazy val</code> результат обчислення зберігається, щоб бути використаний, якщо та сама <code>val</code> буде використовуватись декілька разів.</p></div>
<div class="paragraph"><p>Дивлячись на цей приклад, здається, що об'єкти як <code>Demo</code> самі поводяться як <code>lazy val</code>, в тому, що вони ініціалізуються на вимогу, коли вони використовуються перший раз. Це коректно. Фактично, визначення об'єкта може розглядатись як скорочення для визначення <code>lazy val</code> з анонімним класом, що описує вміст об'єкту.</p></div>
<div class="paragraph"><p>Використавуя <code>lazy val</code>, ви можете переформулювати <code>RationalTrait</code>, як показано в Лістингу 20.8. В новому визначенні трейта всі суцільні поля визначені як ліниві. Інша зміна з точки зору попереднього визначення <code>RationalTrait</code>, показаного на Лістингу 20.4, в тому, що твердження <code>require</code> було переміщено з тіла трейта до ініціалізатора приватного поля, <code>g</code>, що обчислює найбільший загальний дільник <code>numerArg</code> та <code>denomArg</code>. З ціма змінними нема нічого, що треба зробити при ініціалізації <code>LazyRationalTrait</code>; весь код ініціалізації тепер є частиною правої сторони <code>lazy val</code>. Таким чином, є безпечним ініціалізувати абстрактні поля <code>LazyRationalTrait</code> після того, як клас визначений.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
  <span class="k">private</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.8 - Ініціалізація трейта за допомогою лінивих змінних.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
         <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
         <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
       <span class="o">}</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">LazyRationalTrait</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Попередня ініціалізація непотрібна. Буде повчальним прослідити послідовність ініціалізації, що призведе до того, що рядок <code>1/2</code> буде надрукований кодом вище:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Свіжий примірник <code>LazyRationalTrait</code> буде створений, та код ініціалізації <code>LazyRationalTrait</code> виконується. Цей код ініціалізації порожній; жодне з полів <code>LazyRationalTrait</code> досі не ініціалізований.
</p>
</li>
<li>
<p>
Далі виконується первинний конструктор анонімного субкласу, визначеного виразом <code>new</code>. Це включає ініціалізацію <code>numerArg</code> значенням 2, та <code>denomArg</code> значенням 4.
</p>
</li>
<li>
<p>
Далі викликається метод <code>toString</code> на конструйованому інтерпретатором об'єкті, так що результуюче значення може бути роздруковане.
</p>
</li>
<li>
<p>
Далі в перший раз відбувається доступ до поля <code>numer</code> з метода <code>toString</code> в трейті <code>LazyRationalTrait</code>, так що її ініціалатор обчислюється.
</p>
</li>
<li>
<p>
Ініціалізатор <code>numer</code> отримує доступ до приватного поля <code>g</code>, так що наступним ініціалізується <code>g</code>. Це обчислення отримує доступ до <code>numerArg</code> та <code>denomArg</code>, що були визначені на Кроці 2.
</p>
</li>
<li>
<p>
Далі метод <code>toString</code> отримує доступ до значення <code>denom</code>, що спричинить обчислення <code>denom</code>. Обчислення <code>denom</code> отримує доступ до <code>denomArg</code> та <code>g</code>. Ініціалізатор поля <code>g</code> не переобчислюється, оскільки він вже був обчислений на Кроці 5.
</p>
</li>
<li>
<p>
Нарешті, конструюється та друкується результуючий рядок <code>"1/2"</code>.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Зауважте, що визначення <code>g</code> текстуально іде після визначення <code>numer</code> та <code>denom</code> в класі <code>LazyRationalTrait</code>. Тим не менше, оскільки всі ці значення ліниві, <code>g</code> стає ініціалізованим перед тим, як ініціалізація <code>numer</code> та <code>denom</code> буде завершеною.</p></div>
<div class="paragraph"><p>Це показує важливу властивість лінивих змінних: текстуальний порядок їх визначення не має значення, оскільки значення ініціалізуються на вимогу. Таким чином, ліниві змінні вивільняють вам як програміста від роздумів, як вистроїти визначення <code>val</code>, щоб переконатись, що все визначено, коли це треба.</p></div>
<div class="paragraph"><p>Однак ця перевага дотримується тільки доти, доки ініціалізація лінивих змінних ані не призводить до побічних ефектів, ані не залежить від них. В присутності побічних ефектів порядок ініцалізації починає ставати важливим. І потім може стати досить складним відстежити, в якому порядку виконується код ініціалізації, як демонструє попередній приклад. Так що ліниві змінні є ідеальним доповненням до функціональних об'єктів, де порядок ініціалізації не має значення, доки все стає при нагоді ініціалізованим. Вони менш підходять для коду, що є здебільшого імперативним.</p></div>
</div>
<div class="sect2">
<h3 id="____23">Ліниві функціональні мови</h3>
<div class="paragraph"><p>Scala жодним чином не є першою мовою, що чудово відповідає лінивим визначеням та функціональному коду. Фактично є категорія "лінивих функціональних мов програмування", в яких кожне значення та парамент ініціалізуються ліниво. Найбільш відомий член цього класу мов є Haskell [SPJ02].</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_20_6__">20.6 Абстрактні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>На початку цієї глави ви бачили <code>type T</code>, декларацію абстрактного типу. Залишок цієї глави дискутує, що означають такі декларації абстрактних типів, та для чого вони добрі. Як всі інши абстрактні декларації, декларації абстрактних типів є замінниками для чогось, що буде визначено суцільним в субкласах. В цьому випадку це тип, що буде визначений десь далі в ієрархії типів. Так що тип <code>T</code> вище посилається на тип, що досі невідомий в точці, де він визначений. Різні субкласи можуть провадити різні реалізації для <code>T</code>.</p></div>
<div class="paragraph"><p>Ось гарно відомий приклад, де абстрактні типи виглядають природними. Уявімо, що ми отримали завдання змоделювати істівні звички тварин. Ви можете почати з класу <code>Food</code> та класу <code>Animal</code> за методом <code>eat</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ви можете спробувати спеціалізувати ці два класа, до класу <code>Cows</code>, що їсть <code>Grass</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span> <span class="c1">// Це не компілюєтья</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ви спробуєте компілювати ці нові класи, ви отримаєте наступну помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BuggyAnimals</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">7</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Cow</span> <span class="kt">needs</span> <span class="kt">to</span> <span class="kt">be</span>
<span class="k">abstract</span><span class="o">,</span> <span class="n">since</span> <span class="n">method</span> <span class="n">eat</span> <span class="n">in</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="n">of</span> <span class="k">type</span>
    <span class="o">(</span><span class="kt">Food</span><span class="o">)</span><span class="kt">Unit</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">defined</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
      <span class="o">^</span>
<span class="nc">BuggyAnimals</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">8</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">method</span> <span class="kt">eat</span> <span class="kt">overrides</span> <span class="kt">nothing</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, ще те, що метод <code>eat</code> класу <code>Cow</code> не перекриває метод <code>eat</code> в класі <code>Animal</code>, оскікльи його тип параметру інший: це  <code>Grass</code> в класі <code>Cow</code> vs. <code>Food</code> в класі <code>Animal</code>.</p></div>
<div class="paragraph"><p>Деякі люди заперечують, що така система типів сувора без необхідності в відмові цім класам. Вони кажуть, що повинно бути OK спеціалізувати параметр метода в субкласі. Однак, якщо класам дозволити бути написаними таким чином, дуже швидко ви можете опинитись в небезпечній ситуації. Наприклад, наступний скрипт буде проходити перевірку типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span> <span class="c1">// Це не буде компілюватись,</span>
<span class="o">}</span>                                    <span class="c1">// але якщо б могло,...</span>
<span class="k">class</span> <span class="nc">Fish</span> <span class="k">extends</span> <span class="nc">Food</span>
  <span class="k">val</span> <span class="n">bessy</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cow</span>
  <span class="n">bessy</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Fish</span><span class="o">)</span>               <span class="c1">// ...ви б могли кормити корів рибою.</span>
</pre></div></div></div>
<div class="paragraph"><p>Програма могла б компілюватись, якщо обмеження були б послаблені, оскільки <code>Cows</code> є <code>Animals</code>, та <code>Animals</code> мають метод <code>eat</code>, що приймає любий різновид <code>Food</code>, включаючи <code>Fish</code>. Але напевно корові не буде гарно, якщо вона поїсть риби! Що вам треба замість цього, це застосувати якесь більш точне моделювання. <code>Animals</code> їдять <code>Food</code>, але який різновид <code>Food</code> їсть кожний <code>Animal</code>, залежить від самого <code>Animal</code>. Це може бути гарно виражено за допомогою абстрактного типу, як показано в Лістингу 20.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="k">&lt;:</span> <span class="kt">Food</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">SuitableFood</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.9 - Моделювання підходящої їжи через абстрактний тип.</p></div>
<div class="paragraph"><p>З новим визначенням класу, <code>Animal</code> може їсти тільки іжу, що їй підходить. Яка їжа є підходящою не може бути визначено на рівні класу <code>Animal</code>. Ось чому <code>SuitableFood</code> змодельований як абстрактний клас. Тип має верхню межу, <code>Food</code>, що виражається як вираз <code>&lt;: Food</code>. Це означає, що любий суцільний примірник <code>SuitableFood</code> (в субкласі <code>Animal</code>) має бути субкласом <code>Food</code>. Наприклад, ви не можете створити примірник <code>SuitableFood</code> за допомогою класу <code>IOException</code>.</p></div>
<div class="paragraph"><p>З визначеним <code>Animal</code> ви тепер можете переходити до корів, як показано в Лістингу 20.10. Клас <code>Cow</code> ладнає свій <code>SuitableFood</code> до <code>Grass</code>, а також визначає суцільний метод <code>eat</code> для цього різновиду їжі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.10 - Реалізація абстрактного типу в субкласі.</p></div>
<div class="paragraph"><p>Ці нові визначення класів компілюються без помилок. Якщо ви спробуєте виконати контрприклад "корови-що-їдять-рибу" з новими визначеннями класів, ви будете отримувати наступну помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fish</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">Fish</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bessy</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cow</span>
<span class="n">bessy</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="nc">Cow</span><span class="k">@</span><span class="mi">1515</span><span class="n">d8a6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bessy</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Fish</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
  <span class="n">found</span>   <span class="k">:</span> <span class="kt">Fish</span>
  <span class="n">required</span><span class="k">:</span> <span class="kt">bessy.SuitableFood</span>
              <span class="n">bessy</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Fish</span><span class="o">)</span>
                         <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_7___">20.7 Шляхо-залежні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знову поглянемо на останнє повідомлення про помилку. Що цікавє, це те, який тип потребує метод <code>eat</code>: <code>bessy.SuitableFood</code>. Цей тип містить посилання на об'єкт, <code>bessy</code>, за яким іде поле типу об'єкту, <code>SuitableFood</code>. Це показує, що об'єкти в Scala може мати типи в якості членів. Значення <code>bessy.SuitableFood</code> є "тип <code>SuitableFood</code>, що є членом об'єкту, на який посилаєтья <code>bessy</code>" або, альтернативно, тип їжі, що підходить для <code>bessy</code>.</p></div>
<div class="paragraph"><p>Тип як <code>bessy.SuitableFood</code> називається шляхо-залежним типом. Слово "шлях" тут означає посилання на об'єкт. Це може бути простим іменем, таке як <code>bessy</code>, або довший шлях доступу, такий як <code>farm.barn.bessy</code>, де кожний з <code>farm</code>, <code>barn</code>, та <code>bessy</code> є змінними (або іменами об'єктів синглтонів), що посилаються на об'єкти.</p></div>
<div class="paragraph"><p>Як підказує термін "шляхо-залежний тип", тип залежить від шляху; загалом, різні шляхи дають різні типи. Наприклад, скажімо, ви визначили класи <code>DogFood</code> та <code>Dog</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DogFood</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">DogFood</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">DogFood</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви спробуєте погодувати собаку їжею, що підходить для корови, ваш код не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bessy</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cow</span>
<span class="n">bessy</span><span class="k">:</span> <span class="kt">Cow</span> <span class="o">=</span> <span class="nc">Cow</span><span class="k">@</span><span class="mi">713</span><span class="n">e7e09</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">lassie</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span>
<span class="n">lassie</span><span class="k">:</span> <span class="kt">Dog</span> <span class="o">=</span> <span class="nc">Dog</span><span class="k">@</span><span class="mi">6</span><span class="n">eaf2c57</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">bessy</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Grass</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">DogFood</span>
             <span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">bessy</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>
                         <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема тут в тому, що тип об'єкта <code>SuitableFood</code>, переданого до метода <code>eat</code>, <code>bessy.SuitableFood</code>, несумісний з типом параметра <code>eat</code>, <code>lassie.SuitableFood</code>.</p></div>
<div class="paragraph"><p>Випадок може бути іншим для двох <code>Dog</code>. Оскікльи тип <code>Dog</code> <code>SuitableFood</code> визначений бути псевдонімом для класу <code>DogFood</code>, типи  <code>SuitableFood</code> для двох <code>Dog</code> є фактично ті самі. Як результат, примірник <code>Dog</code> на ім'я <code>lassie</code> насправді може їсти підходящц їжу іншого примірника <code>Dog</code> (який ми назвемо <code>bootsie</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bootsie</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span>
<span class="n">bootsie</span><span class="k">:</span> <span class="kt">Dog</span> <span class="o">=</span> <span class="nc">Dog</span><span class="k">@</span><span class="mi">13</span><span class="n">a7c48c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">bootsie</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Шляхо-залежнийA тип копіює синтаксис для типу внутрішнього класу в Java, але є важлива відмінність: шляхо-залежний тип називає зовнішній клас. Типи внутрішніх класів в стилі Java також можуть бути виражені в Scala, але вони записуються інакше. Розглянемо ці два класи, <code>Outer</code> та <code>Inner</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Inner</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala внутрішній клас адресується з використанням виразу <code>Outer#Inner</code> замість <code>Outer.Inner</code> в Java. Синтаксис <code>.</code> зарезервований для об'єктів. Наприклад, уявімо, що ви створили два об'єкти типу <code>Outer</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">o1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
<span class="k">val</span> <span class="n">o2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>o1.Inner</code> та <code>o2.Inner</code> є два шляхо-залежні типи (і вони різні типи). Обоє з ціх типів відповідають до (є субтипами до) більш загального типу <code>Outer#Inner</code>, що представляє клас <code>Inner</code> з довільним зовнішнім об'єктом типу <code>Outer</code>. Для контрасту, тип <code>o1.Inner</code> посилається на клас <code>Inner</code> зі специфічним зовнішнім об'єктом (на який посилається <code>o1</code>). Подібним чином, тип <code>o2.Inner</code> посилається на клас <code>Inner</code> з іншим, специфічним зовнішнім об'єктом (на який посилається o2).</p></div>
<div class="paragraph"><p>В Scala, як і в Java, примірники внутрішнього класу містять посилання на оточуючий примірник зовнішнього класа. Це дозволяє внутрішньому класу, наприклад, отримувати доступ до членів свого зовнішнього класу. Таки чином, ви не зможете створити внутрішній клас, в деякий спосіб не указавши примірник зовнішнього класу. Один спосіб зробити це є створити внутрішній клас всередині зовнішнього класу. В цьому випадку буде використаний поточний примірник зовнішнього класу (на який вказує <code>this</code>).</p></div>
<div class="paragraph"><p>Інший шлях є використати шляхо-залежний тип. Наприклад, оскікльи тип <code>o1.Inner</code> іменує специфічний зовнішній об'єкт, ви можете створити його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="n">o1</span><span class="o">.</span><span class="nc">Inner</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">o1.Inner</span> <span class="o">=</span> <span class="nc">Outer$Inner</span><span class="k">@</span><span class="mi">1</span><span class="n">ae1e03f</span>
</pre></div></div></div>
<div class="paragraph"><p>Результуючий інутрішній об'єкт буде містити посилання на на свій зовнішній об'єкт, на який посилається o1. Для контрасту, оскільки тип <code>Outer#Inner</code> не іменує жодний специфічний примірник <code>Outer</code>, ви не можете створити його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Outer</span><span class="k">#</span><span class="nc">Inner</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Outer</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">legal</span> <span class="kt">prefix</span> <span class="kt">for</span> <span class="kt">a</span>
<span class="n">constructor</span>
              <span class="k">new</span> <span class="nc">Outer</span><span class="k">#</span><span class="nc">Inner</span>
                        <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_8__">20.8 Уточнені типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли клас наслідує від іншого, кажуть, що перший клас є <em>номінальним</em> субтипом іншого. Це <em>номінальний</em> субтип, бо кожний тип має <em>ім'я</em>, і імена явно декларовані як такі, що вають відношення субтипізації. Scala додатково підтримує <em>структурну</em> субтипізацію, коли ви маєте відношення субтипізації, просто тому що два типи мають сумісні члени. Щоб отримати структурну субтипізацію в Scala, використовуйте уточнення типів Scala.</p></div>
<div class="paragraph"><p>Номінальна типізація звичайно є більш зручною, так що вам слідує зпочатку спробувати номінальні типи в кожній новій розробці. Ім'я є простим коротким ідентифікатором, і, таким чином, більш стислі, ніж явний перелік членів типів. Більше того, структурна субтипізація часто більш гнучка, ніж ви бажаєте. Віджет може <code>draw()</code>, та ковбой заходу також може <code>draw()</code>, але вони насправді не замінюють один одного. Ви будете переважно обирати отримання помилки компіляції, якщо ви спробуєте замінити ковбоя на віджет.</p></div>
<div class="paragraph"><p>Тим не менш, структурна субтипізація має власні переваги. Одна з них в тому, що іноді немає більше ніякого типу, ніж перелік членів. Наприклад, уявімо, що ви бажаєте визначити клас <code>Pasture</code>, що може містити тварин, що їдять траву. Одна з опцій буде визначити трейт <code>AnimalThatEatsGrass</code>, та міксувати його в кожний клас, який це стосується. Однак це може бути балакучим. Клас <code>Cow</code> вже був визначений як тварина, та що їсть траву, і тепер він має додатково бути визначений також як тварина-що-їсть-траву. Замість визначення <code>AnimalThatEatsGrass</code> ви можете використовувати уточнюючий тип. Просто запишіть базовий тип, <code>Animal</code>, за яким слідує послідовність членів в фігурних дужках. Члени в фігурних дужках далі специфікують — або, якщо бажаєте, уточнюють — типи членів від базового класу. Ось як ви записуєте тип "тварина, що їсть траву":</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей тип, тепер ви можете записати клас пасовиська таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Pasture</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">animals</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="kt">=</span> <span class="kt">Grass</span> <span class="o">}]</span> <span class="k">=</span> <span class="nc">Nil</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_9_">20.9 Енумератори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цікаве застосування для шляхо-залежних типів знаходиться в Scala підтримці енумераторів. Деякі інші мови, включаючи Java та C#, мають енумератори як вбудовані конструкції мови, що визначають нові типи. Scala не потребує особливого синтаксису для енумераторів. Замість цього існує клас в стандадртній бібліотеці, <code>scala.Enumeration</code>.</p></div>
<div class="paragraph"><p>Щоб створити нову енумерацію ви визначаєте об'єкт, що розширює цей клас, як в наступному прикладі, що визначає новий енумератор <code>Colors</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span> <span class="k">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">Green</span> <span class="k">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">Blue</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala дозволяє вам скоротити декілька послідовних визначень <code>val</code> або <code>var</code> з тою самою правою стороною. Еквівалентно до попереднього ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей об<em>єкт провадить три значення: <code>Color.Red</code>, <code>Color.Green</code>, та 'Color.Blue</em>. Ви також можете імпортувати все з <code>Color</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Color._</span>
</pre></div></div></div>
<div class="paragraph"><p>та потім тільки використовувати <code>Red</code>, <code>Green</code>, та <code>Blue</code>. Але який буде тип ціх значень? <code>Enumeration</code> визначає внутрішній клас на ім'я <code>Value</code>, та так само названий безпараметричний метод <code>Value</code> повертає свіжий примірник цього класу. Іншими словами, значення, таке як <code>Color.Red</code> має тип <code>Color.Value</code>; <code>Color.Value</code> є типом для всіх значень енумератора, визначених в об'єкті <code>Color</code>. Це шляхо-залежний тип, де <code>Color</code> є шляхом, та <code>Value</code> є залежним типом. Що важливо щодо цього, це те, що це повністю новий тип, відмінний від всіх інших типів.</p></div>
<div class="paragraph"><p>Зокрема, якщо ви визначите іншу енумерацію, як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">North</span><span class="o">,</span> <span class="nc">East</span><span class="o">,</span> <span class="nc">South</span><span class="o">,</span> <span class="nc">West</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>тоді <code>Direction.Value</code> буде відмінне від <code>Color.Value</code>, оскільки два типи відрізняються в частині шляху.</p></div>
<div class="paragraph"><p>В Scala клас <code>Enumeration</code> також пропонує багато інших можливостей, які можна знайти в дизайні енумераторів в інших мовах. Ви можете асоціювати імена зі значеннями енумерації, використовуючи різні перевантажені варіанти метода <code>Value</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">North</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;North&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">East</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;East&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">South</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;South&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">West</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;West&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете ітерувати по значенням енумерації через множину, що повертає метод <code>values</code> енумерації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">d</span> <span class="k">&lt;-</span> <span class="nc">Direction</span><span class="o">.</span><span class="n">values</span><span class="o">)</span> <span class="n">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span>
<span class="nc">North</span> <span class="nc">East</span> <span class="nc">South</span> <span class="nc">West</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення енумерації нумеруються від <code>0</code>, і ви можете знайти номер значення енумерації через його метод <code>id</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Direction</span><span class="o">.</span><span class="nc">East</span><span class="o">.</span><span class="n">id</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Також можливо піти іншим шляхом, від не-від'ємного цілого до значення, що має цей номер в якості <code>id</code> в енумерації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Direction</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Direction.Value</span> <span class="o">=</span> <span class="nc">East</span>
</pre></div></div></div>
<div class="paragraph"><p>Цього має бути достатньо, щоб почати робити з енумераціями. Ви можете знайти додаткову інформацію в коментарях Scaladoc до класу <code>scala.Enumeration</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_10___">20.10 Лабораторна робота: валюта</h2>
<div class="sectionbody">
<div class="paragraph"><p>Залишок цієї глави презентує лабораторну роботу, що пояснює, як абстрактні типи можуть бути використані в Scala. Завданням буде розробити клас <code>Currency</code>. Типовий примірник <code>Currency</code> буде представляти кількість грошей в доларах, євро, ієнах або в якійсь іншій валюті. Повинно бути можливим виконувати деяку арифметику з валютами. Наприклад, ви можете бути в змозі додавати дві суми в тій самій валюті. Або ви повинні бути в змозі помножити суму в валюті на коефіціент, що представляє відсотковий рівень.</p></div>
<div class="paragraph"><p>Ці роздуми призводять до наступного першого дизайну класу валюти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Перший (невдалий) дизайн класу Currency</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Сума <code>amount</code> валюти є часло в одиницях валюти, яку вона представляє. Це поле типу <code>Long</code>, так що можуть бути представлені дуже великі суми, такі як капіталізація ринку Google або Apple. Тут це залишено абстрактним, очікуючи визначення коли субклас казатиме про конкретні об'єми грошей. Поле <code>designation</code> для валюти є рядок, що ідентифікує валюту. Метод <code>toString</code> класу <code>Currency</code> вказує суму та позначення. Він буде видавати результати в такому вигляді:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>79 USD
11000 Yen
99 Euro</code></pre>
</div></div>
<div class="paragraph"><p>Нарешті, є метод <code>+</code> для додавання валюти, та <code>*</code> для множення валюти на число з плаваючою крапкою. Ви можете створити суцільне значення валюти, через надання конкретних значень суми та назви валюти, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="mi">79L</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей дизайн буде OK, якщо все, що ми бажаємо, це єдина валюта, як тільки долар або тільки євро. Але він схибить, якщо нам буде треба мати справу з декількома валютами. Уявімо, що ви модулюєте долари та єаро як два субкласи до класу валюти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Euro</span> <span class="k">extends</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;Euro&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>На перший погляд це виглядає розумним. Але це дасть нам змогу додавати долари до євро. Результат такого додавання має бути типу <code>Currency</code>. Але це буде цікава валюта, що складається з суміші євро та доларів. Що ми бажаємо замість цього, є більш специфікована версія метода <code>+</code>. Коли реалізується клас <code>Dollar</code>, віе має брати аргументи <code>Dollar</code>, та видавати результат <code>Dollar</code>; коли реалізується клас <code>Euro</code>, він повинен брати аргументи <code>Euro</code>, та видавати результат <code>Euro</code>. Так що тип результату метода додавання буде змінюватись, в залежності від того, в якому класі він знаходиться. Тим не менш, ви бажаєте написати метод додавання тільки один раз, та не кожного разу, коли визначаєте нову валюту.</p></div>
<div class="paragraph"><p>В Scala існує простий прийом, що порається з подібними ситуаціями. Якщо дещо невідоме в точці, де визначається клас, зробіть це абстрактним в класі. Це стосується до обох, значень та типів. В випадку валют, точний тип аргументів та результату метода складання невідомий, так що це гарний кандидат на абстрактний тип.</p></div>
<div class="paragraph"><p>Це може привести до наступного скетчу класа <code>AbstractCurrency</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Другий (все ще недосконалий) дизайн класу Currency</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span>
  <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span><span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдина різниця з попередньою ситуацією в тому, що тепер клас називається <code>AbstractCurrency</code>, і що він містить абстрактний тип <code>Currency</code>, що презентує реальну валюту. Кожний суцільний субклас <code>AbstractCurrency</code> буде потребувати полагодження <code>Currencytype</code>, щоб він посилався на сам суцільний субклас, таким чином "затягуючи петлю".</p></div>
<div class="paragraph"><p>Наприклад, ось нова версія класу <code>Dollar</code>, що тепер розширює клас <code>AbstractCurrency</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Dollar</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей дизайн робить, але він все ще не ідеальний. Одна проблема ховається за крапками, що вказують на відсутні визначення методів <code>+</code> та <code>*</code> в класі <code>AbstractCurrency</code>. Зокрема, як має додавання бути реалізоване в цьому класі? Досить просто обчислити коректну суму нової валюти, як <code>this.amount + that.amount</code>, але як ви будете конвертувати суму в валюту правильного типу?</p></div>
<div class="paragraph"><p>Ви можете спробувати щось таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">error</span><span class="k">:</span> <span class="kt">class</span> <span class="k">type</span> <span class="kt">required</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Currency</span> <span class="o">{</span>
                                         <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Одне з обмежень трактування Scala абстрактніх типів в тому, що вона ніколи не буде створювати примірник абстрактного типу, ані матиме абстрактний тип як супертип іншого класу.<span class="footnote"><br />[Є деяке обіцяюче останнє дослідження в віртуальних класах, що може дозволити це, але віртуальні класи наразі не підтримуються в Scala.]<br /></span> Так що компілятор буде відхиляти код в прикладі, що намагається створити примірник <code>Currency</code>.</p></div>
<div class="paragraph"><p>Однак ви можете обійти це обмеження, використовуючи метод фабрики. Замість створення примірника абстрактного класу напряму, декларуйте абстрактний метод, що робить це. Потім, коли абстрактний клас зафіксований як деякий суцільний тип, вам також треба надати суцільну реалізацію матода фабрики. Для класу <code>AbstractCurrency</code> це може виглядати наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span> <span class="c1">// абстрактний тип</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span>  <span class="c1">// метод фабрики</span>
<span class="o">...</span>
<span class="c1">// залишок класу</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дизайн як цей можна зробити робочим, але він виглядає скоріше підозрілим. Чому класти метод фабрики всередину класу <code>AbstractCurrency</code>? Це виглядає сумнівно з двох причин. Перше, якщо ви маєте якусь суму валюти (скажімо, один долар), ви також тримаєте в своїх руках можливість зрбити більше в тій же валюті, використовуючи код як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">myDollar</span><span class="o">.</span><span class="n">make</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span> <span class="c1">// тут ще одна сотня!</span>
</pre></div></div></div>
<div class="paragraph"><p>В епоху кольорового копіювання це може бути привабливим сценарієм, але, сподіваюсь, не тим, який ви б могли робити довго, не бувши спійманим. Друга проблема з цім кодом в тому, що ви можете зробити більше об'єктів <code>Currency</code>, якщо ви вже маєте посилання на об'єкт <code>Currency</code>. Але як ви отримаєте перший об'єкт даної <code>Currency</code>? Вам знадобиться інший метод, що робить ту саму роботу, що і <code>make</code>. Так що ви маєте випадок дублікації коду, що є певним знаком, що ваш код завонявся.</p></div>
<div class="paragraph"><p>Рішення, звичайно, є перемістити абстрактний тип та метод фабрики за межі класу <code>AbstractCurrency</code>. Вам треба створити інший клас, що містить клас <code>AbstractCurrency</code>, тип <code>Currency</code>, та методо фабрики <code>make</code>.</p></div>
<div class="paragraph"><p>Ми будемо називати це <code>CurrencyZone</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span>

  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
    <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span>
    <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">*</span> <span class="n">x</span><span class="o">).</span><span class="n">toLong</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад суцільного <code>CurrencyZone</code> є <code>US</code>, що може бути визначено так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">US</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Dollar</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollar</span> <span class="o">{</span> <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>US</code> є об'єктом, що розширює <code>CurrencyZone</code>. Він визначає клас <code>Dollar</code>, що є субкласом <code>AbstractCurrency</code>. Так що тип грошей в цій зоні є <code>US.Dollar</code>. Об'єкт <code>US</code> також фіксує тип <code>Currency</code> як псевдонім для <code>Dollar</code>, та він надає реалізацію метода фабрики <code>make</code>, що повертає суму в доларах.</p></div>
<div class="paragraph"><p>Це робочий дизайн. Залишилось додати лише декілька покращень. Перше покращення стосується субодиниць. Досі кожна валюта обчислювалась в єдиних одиницях: долари, євро, або ієни. Однак більшість валют мають субодиниці: наприклад, в US це долари та центи. Найбільш прямолінійний шлях моделювати центи є мати поле <code>amount</code> в <code>US.Currency</code>, що представляє центи замість доларів. Для конвертації назад до доларів є корисним ввести поле <code>CurrencyUnit</code> в клас <code>CurrencyZone</code>, що містить суму в одній стандартній одиниці цієї валюти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
<span class="o">...</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span><span class="k">:</span> <span class="kt">Currency</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як показано в Лістингу 20.11, об'єкт <code>US</code> може визначати кількості в <code>Cent</code>, <code>Dollar</code>, та <code>CurrencyUnit</code>. Це визначення є таке саме, як попереднє визначення об'єкта <code>US</code>, за винятком того, що воно додає три нові поля. Поле <code>Cent</code> представляє суму в 1 <code>US.Currency</code>. Це об'єкт, аналогічний до монеті в один цент. Поле <code>Dollar</code> представляє суму в 100 <code>US.Currency</code>. Так що об'єкт <code>US</code> тепер визначає ім'я <code>Dollar</code> в два способи. Тип <code>Dollar</code> (визначаний абстрактним інутрішнім класом на ім'я <code>Dollar</code>) представляє дженерік ім'я <code>Currency</code>, валідної в валютній зоні <code>US</code>. Для контрасту, значення <code>Dollar</code> (на яке посилається поле <code>val</code> на ім'я <code>Dollar</code>) представляє окремий US долар, подібно до однодоларового чеку. Третє визначення поля <code>CurrencyUnit</code> задає факт, що стандартна одиниця валюти в US зоні є <code>Dollar</code> (тобто, значення <code>Dollar</code>, на яке посилається поле, не тип <code>Dollar</code>).</p></div>
<div class="paragraph"><p>Метод <code>toString</code> в класі <code>Currency</code> також потребує бути адаптованим, щоб приймати до уваги субодиниці. Наприклад, сума десяти доларів і двадцяти трьох центів має друкуватись як десятичне число: 10.23 USD.</p></div>
<div class="paragraph"><p>Щоб досягти цього, ви повинні реалізовати метод <code>Currency</code> <code>toString</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
  <span class="o">((</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
  <span class="n">formatted</span> <span class="o">(</span><span class="s">&quot;%.&quot;</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;f&quot;</span><span class="o">)</span>
  <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>formatted</code> є методом, що Scala робить доступним для декількох класів, включачи <code>Double</code>.<span class="footnote"><br />[Scala використовує багаті огортки, описані в Розділі 5.10, щоб зробити форматування можливим.]<br /></span> Метод <code>formatted</code> повертає рядок, що є результатом форматування оригінального рядка, на якому було викликано <code>formatted</code>, відповідно до рядка формату, переданого як правий операнд метода <code>formatted</code>. Синтаксис рядка формату, переданого в <code>formatted</code>, той самий, що і для Java метода <code>String.format</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">US</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Dollar</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">cents</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollar</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">cents</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">Cent</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">Dollar</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span> <span class="k">=</span> <span class="nc">Dollar</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.11 - Валютна зона <code>US</code>.</p></div>
<div class="paragraph"><p>Наприклад, рядок формату <code>%.2f</code> форматує число з двома десятичними цифрами. Рядок формату, використаний в показаному <code>toString</code> складається з виклику метода <code>decimals</code> на <code>CurrencyUnit.amount</code>. Цей метод повертає число десятичних знаків в десятичній ступіні мінус один. Наприклад, <code>decimals(10)</code> є <code>1</code>, <code>decimals(100)</code> є <code>2</code>, і так далі. Метод <code>decimals</code> реалізований через просту рекурсію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.12 показує деякі інші валютні зони. Як інше покращення ви можете додати до моделі можливість конвертації валют. Зпершу, вам треба написати о'бєкт <code>Converter</code>, що містить допустимі курси обміну між валютами, як показано в Лістингу 20.13. Потім ви можете додати метод конвертації, <code>from</code>, до класу <code>Currency</code>, що конвертує з наданої валюти в поточну валюту об'єкту <code>Currency</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">CurrencyZone</span><span class="k">#</span><span class="kt">AbstractCurrency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
  <span class="n">make</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">round</span><span class="o">(</span>
  <span class="n">other</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">*</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">exchangeRate</span>
  <span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">designation</span><span class="o">)(</span><span class="k">this</span><span class="o">.</span><span class="n">designation</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>from</code> приймає довільну валюту як аргумент. Це виражається в типи його формального параметру, <code>CurrencyZone#AbstractCurrency</code>, що вказує, що аргумент, переданий як <code>other</code>, має бути типу <code>AbstractCurrency</code> в якійсь, невідомій <code>CurrencyZone</code>. Він продукує свій результат чеерз множення суми в іншій валюті на курс обміну між іншою та поточною валютою.<span class="footnote"><br />[Доречі, якщо ви думаєте ви отримали погані справи з японською ієною, курси обміну конвертують валюти на основі своїх сум <code>CurrencyZone</code>. Таким чином, 1.211 є курс обміну між US центами та японськіми ієнами.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Europe</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Euro</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;EUR&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Euro</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">cents</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Euro</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">cents</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">Cent</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">Euro</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span> <span class="k">=</span> <span class="nc">Euro</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Japan</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Yen</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;JPY&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Yen</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">yen</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Yen</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">yen</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">Yen</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span> <span class="k">=</span> <span class="nc">Yen</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.12 - Валютні зони для Європи та Японії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">exchangeRate</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
    <span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span>   <span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.7596</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.211</span> <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.223</span><span class="o">),</span>
    <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.316</span> <span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.594</span> <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.623</span><span class="o">),</span>
    <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.8257</span><span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.6272</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span>   <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.018</span><span class="o">),</span>
    <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.8108</span><span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.6160</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.982</span> <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span> <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.13 - Об'єкт конвертора з мапою курсів обміну.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span>

  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
    <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span>

    <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">*</span> <span class="n">x</span><span class="o">).</span><span class="n">toLong</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">make</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">/</span> <span class="n">that</span><span class="o">).</span><span class="n">toLong</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">this</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span>

    <span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">CurrencyZone</span><span class="k">#</span><span class="kt">AbstractCurrency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
        <span class="n">make</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">round</span><span class="o">(</span>
        <span class="n">other</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">*</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">exchangeRate</span>
        <span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">designation</span><span class="o">)(</span><span class="k">this</span><span class="o">.</span><span class="n">designation</span><span class="o">)))</span>

    <span class="k">private</span> <span class="k">def</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
      <span class="o">((</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
       <span class="n">formatted</span> <span class="o">(</span><span class="s">&quot;%.&quot;</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;f&quot;</span><span class="o">)</span>
       <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span><span class="k">:</span> <span class="kt">Currency</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.14 - Повний код класу <code>CurrencyZone</code>.</p></div>
<div class="paragraph"><p>Фінальна версія класу <code>CurrencyZone</code> показана на Лістингу 20.14. Ви можете протестувати клас в командній оболонці Scala. Ми будемо вважати, що клас <code>CurrencyZone</code> та всі суцільні об'єкти <code>CurrencyZone</code> визначені в пакунку <code>org.stairwaybook.currencies</code>. Перший крок є імпортувати  <code>org.stairwaybook.currencies._</code> в командну оболонку. Потім ви можете зробити деякі конвертації валют:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Japan</span><span class="o">.</span><span class="nc">Yen</span> <span class="n">from</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">*</span> <span class="mi">100</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Japan.Currency</span> <span class="o">=</span> <span class="mi">12110</span> <span class="nc">JPY</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Europe</span><span class="o">.</span><span class="nc">Euro</span> <span class="n">from</span> <span class="n">res16</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Europe.Currency</span> <span class="o">=</span> <span class="mf">75.95</span> <span class="nc">EUR</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="n">from</span> <span class="n">res17</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">US.Currency</span> <span class="o">=</span> <span class="mf">99.95</span> <span class="nc">USD</span>
</pre></div></div></div>
<div class="paragraph"><p>Факт, що ви отримали майже ті самі суми після трьох конвертацій каже нам, що це досить гарні обмінні курси! Ви також можете пододавати значення в тій самій валюті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">res18</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">US.Currency</span> <span class="o">=</span> <span class="mf">199.95</span> <span class="nc">USD</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку, ви не можете додавати суми в різних валютах:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">+</span> <span class="nc">Europe</span><span class="o">.</span><span class="nc">Euro</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Europe.Euro</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">US.Currency</span>
    <span class="o">(</span><span class="n">which</span> <span class="n">expands</span> <span class="n">to</span><span class="o">)</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span>
              <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">+</span> <span class="nc">Europe</span><span class="o">.</span><span class="nc">Euro</span>
                                 <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Через запобігання додавань двох значень в різних одиницях (в цьому випадку валют), абстракція типів робить свою роботу. Це утримує нас від виконання безглуздих обчислень. Збої коректної конвертації між різними одиницями може виглядати як тривіальні баги, але вони призводили до багатьох серйозних системних відмов. Як приклад можна навести аварію космічного корабля Mars Climate Orbiter 23 вересня 1999го року, що сталась через те, що одна інженерна команда використовувала метричні одиниці, тоді як інша використовувала англійські одиниці. Якщо одиниці були б закодовані в той же спосіб, що і валюти в цьому розділі, ця помилка була б детектована простим запуском компілятора. Замість цього це спричинило аварію орбітального корабля після майже десятимісячної подорожі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_11_">20.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala пропонує систематичну і дуже загальну підтримку для об'єктно-орієнтовних абстракцій. Вона дозволяє вам абстрагувати не тільки методи, але також значення, змінні і типи. Ця глава показала, як отримати переваги від абстрактних членів. Вони підтримують простий, але ефективний принцип для структурування систем: коли ви розробляєте клас, робіть все, що доки невідоме, як абстрактний член. Потім система типів буде рухати розробку вашої моделі, так само, як ви бачили в лабораторій роботі про валюту. Не має значення, чи невідомим є тип, метод, змінна або значення. В Scala все це може бути визначено абстрактно.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__21">Глава 21</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____15">Неявні перетворення та параметри</h1>
<div class="paragraph"><p>Існує фундаментальна відмінність між вашим кодом, та бібліотеками інших людей: ви можете змінити або розширити ваш власний код, як побажаєте, але якщо ви бажаєте використати чиюсь іншу бібліотеку, ви звичайно маєте сприймати її як є. В мовах з'явилось декілька конструкцій для полегчення цієї проблеми. Ruby має модулі, та Smalltalk дозволяє пакункам додавати до класів один одного. Вони дуже потужні, але також небезпечні, тому що ви можете модифікувати поведінку класу для всього застосування, деяки частини якого ви можете не знати. C# 3.0 має статичні методи розширення, які є більш локальними, але також більш обмежуючі, в тому, що ви можете лише добавляти до класа методи, не поля, та ви не можете змусити клас реалізувати нові інтерфейси.</p></div>
<div class="paragraph"><p>Відповіддю Scala є неявні перетворення та параметри. Вони можуть зробити існуючі бібліотеки значно більше приємними у взаємодії, дозволяючі вам облишити за бортом нудні, очевидні деталі, що приховують цікаві частини вашого коду. Коли використовується зі смаком, це призводить до коду, що сфокусований на цікавих, нетривіальних частинах вашої програми. Ця глава показує вам, як неявні роблять, та вона презентує деякі з найбільш загальних шляхів їх використання.</p></div>
<div class="sect1">
<h2 id="_21_1__">21.1 Неявні перетворення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Перед зануренням в деталі неявних перетворень, поглянемо на типовий приклад їх використання. Неявні перетворення часто корисні для роботи з двома тілами програмного забезпечення, що розроблялись без думки один про одне. Кожна бібліотека має свій власний шлях для кодування концепції, що насправді є однією річчю. Неявні перетворення допомагають через зменьшення числа явних перетворень, що потрібні від одного типу до іншого.</p></div>
<div class="paragraph"><p>Java включає бібліотеку на ім'я Swing для реалізації крос-платформених користувацьких інтерфейсів. Одна з речей, що робить Swing, це обробка подій від операційної системи, конвертація їх до платформ-незалежних об'єктів подій, та передача ціх подій до частин застосування, що називаються слухачами подій.</p></div>
<div class="paragraph"><p>Якщо б Swing був написаний зі Scala на думці, слухачі подій мали б, можливо, бути представлені як функціональний тип. Викликачі можуть потім використовувати синтаксис фінкціональних літералів, як легковажний шлях вказати, що має відбуватись для певного класу подій. Оскільки Java не має функціональних літералів, Swing використовує наступну кращу річ, внутрішній клас, що реалізує одно-методний інтерфейс. В випадку слухачів подій, інтерфейсом є <code>ActionListener</code>.</p></div>
<div class="paragraph"><p>Без використання неявних перетворень, програма Scala, що використовує Swing, має використовувати внутрішній клас, так само як в Java. Ось приклад що створює кнопку, та підвішує на неї слухача подій. Слухач подій викликається кожного разу, коли кнопка натискається, і в цій точці він друкує рядок <code>"pressed!"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
     <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код має багато неінформативного шаблону. Факт, що цей слухач є <code>ActionListener</code>, факт, що це метод зворотнього виклику на ім'я <code>actionPerformed</code>, та факт, що аргументом є <code>ActionEvent</code> - все це мається на увазі для кожного аргументу <code>addActionListener</code>. Єдина нова інформація тут є код, що буде виконаний, а саме виклик <code>println</code>. Ця нова інформація тоне в шаблонному коді. Той, хто читає цей код, повинен мати гострий зір, щоб пробитись крізь шум та знайти інформативну частину.</p></div>
<div class="paragraph"><p>Більш Scala-дружня версія приймає функцію як аргумент, значно зменьшуючи кількість шаблоного коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span> <span class="c1">// Неспівпадіння типів!</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але так, як він написаний, цей код не робить.<span class="footnote"><br />[Як буде пояснено в Розділі 31.5, це робить в Scala 2.12.]<br /></span> Метод <code>addActionListener</code> бажає слухача подій, але отримує функцію. З неявними перетвореннями цей код, однак, може бути зроблений робочим.</p></div>
<div class="paragraph"><p>Перший крок є написання неявного перетворення між двома типами. Ось неявне перетворення від функцій до слухачів подій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">function2ActionListener</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">ActionEvent</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це одно-аргументний метод, що приймає функцію, та повертає слухача подій. Як любий інший одно-аргументний метод, він може бути викликаний напряму, та має свій результат переданий далі в інший вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="n">function2ActionListener</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це вже покращення, в порівняні з версією з внутрішнім класом. Зауважте, як довільні маси шаблонного коду були замінені функціональним літералом та викликом метода. Однак з неявними перетвореннями це стає ще краще. Оскільки <code>function2ActionListener</code> помічена як <code>implicit</code>, вона може бути прибрана, і компілятор буде вставляти її автоматично. Ось результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Тепер це робить</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Шлях, яким цей код робить, полягає в тому, що компілятор спочатку компілює його як є, але він бачить помилку типу. Перед тим як здатись, він шукає неявне перетворення, що може владнати проблему. В цьому випадку він знаходить <code>function2ActionListener</code>. Він випробовує метод перетворення, бачить що він робить, та рухається далі. Компілятор виконує тяжку роботу, так що розробник може ігнорувати ще одну дрібну деталь. Слухач подій? Функція обробки подій? Обоє будуть робити — використовуйте те, що більш зручно.</p></div>
<div class="paragraph"><p>В цьому розділі ми ілюструємо деякі з потужностей неявних перетворень, та як вони дозволяють вам причипурити існуючі бібліотеки. В наступних розділах ви вивчите правила, що визначають, коли неявні перетворення будуть спробувані, та як вони будуть шукатись.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_2____">21.2 Правила для неявних визначень</h2>
<div class="sectionbody">
<div class="paragraph"><p>Визначення <code>implicit</code> є такими, що дозволяються компілятору для вставки в програму, щоб поладнати любі з його помилок типів. Наприклад, якщо <code>x + y</code> не проходить перевірку типів,компілятор може змінити його на <code>convert(x) + y</code>, де <code>convert</code> є деяке доступне <code>implicit</code> перетворення. Якщо <code>convert</code> змінює <code>x</code> на дещо, що має метод <code>+</code>, тоді ця зміна може поладнати програму, так що вона пройде перевірку типів та виконається коректно. Якщо <code>convert</code> насправді тільки проста функція перетворення, тоді прибирання її з джерельного коду може бути очищенням.</p></div>
<div class="paragraph"><p>Неявні перетворення регулюються наступними загальними правилами:</p></div>
<div class="paragraph"><p><strong>Правило маркування: доступні тільки визначення, відмічені як <code>implicit</code>.</strong> Ключове слово <code>implicit</code> використовується як маркер, які декларації може використовувати компілятор для неявних перетворень. Ви можете використовувати його для маркування визначення змінної, функції або об'єкта. Ось приклад визначення неявної функції:<span class="footnote"><br />[Змінні та об'єкти синглтони, відмічені як <code>implicit</code>, можуть бути використані як неявні параметри. Цей спосіб використання буде описаний пізніше в цій главі.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">intToString</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toString</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор буде змінювати <code>x + y</code> до <code>convert(x) + y</code>, тільки якщо <code>convert</code> відмічений як <code>implicit</code>. Таким чином, ви уникаєте плутанини, коли компілятор обиратиме випадкові функції, що трапляються в полі зору, та вставляє їх як "перетворення". Компілятор буде обирати тільки між визначеннями, що ви явно відмітили як <code>implicit</code>.</p></div>
<div class="paragraph"><p><strong>Правило поля зору: вставлене неявне перетворення має бути в полі зору як єдиний ідентифікатор, або бути асоційоване з типом джерела або цілі перетворення.</strong> Компілятор Scala буде розглядати тільки неявні перетворення, що знаходяться в полі зору. Таким чином, щоб зробити неявне перетворення доступним, ви повинні деяким чином занести його в поле зору. Більше того, з один виключенням, неявне перетворення має бути в полі зору як <em>єдиний ідентифікатор</em>. Компілятор не буде вставляти перетворення в формі <code>someVariable.convert</code>. Наприклад, він не буде розширювати <code>x + y</code> до <code>someVariable.convert(x) + y</code>. Якщо ви бажаєте зробити <code>someVariable.convert</code> доступним як <code>implicit</code>, вам треба імпортувати його, що робитиме його доступним як єдиний ідентифікатор. Як тільки той імпортований, компілятор буде вільний застосувати його як <code>convert(x) + y</code>. Фактично, є загальним для бібліотек включати об'єкт <code>Preamble</code>, що включає декілька корисних неявних перетворень. Код, що використовує бібліотеку, потім може зробити один <code>import Preamble._</code> для доступу до неявних перетворень бібліотеки.</p></div>
<div class="paragraph"><p>Існує одне виключення до правила "єдиного ідентифікатора". Компілятор також буде дивитись неявні перетворення в об'єкті компанйоні джерела або очікуваного типів перетворення. Наприклад, якщо ви намагаєтесь передати об'єкт <code>Dollar</code> до метода, що приймає <code>Euro</code>, типом джерела є <code>Dollar</code>, та тип цілі є <code>Euro</code>. Таким чином, ви можете запакувати неявне перетворення від <code>Dollar</code> до <code>Euro</code> в об'єкт компанйон любого класу, <code>Dollar</code> або <code>Euro</code>.</p></div>
<div class="paragraph"><p>Ось приклад, в якому визначення <code>implicit</code> покладене в об'єкт компанйон <code>Dollar</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Dollar</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">dollarToEuro</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Dollar</span><span class="o">)</span><span class="k">:</span> <span class="kt">Euro</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Dollar</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку кажуть, що перетворення <code>dollarToEuro</code> <em>асоційоване</em> з типом <code>Dollar</code>. Компілятор буде шукати такі асоційовані перетворення кожний раз, коли йому треба перетворити з примірника типу <code>Dollar</code>. Немає потреби окремо імпортувати перетворення в вашу програму.</p></div>
<div class="paragraph"><p>Правило поля зору допомогає з модульним сприяттям. Коли ви читаєте код в файлі, єдині речі, що вам треба брати до уваги з інших файлів, це тільки те, що або імпортоване, або явно посилається через повністю кваліфіковане ім'я. Ця перевага щонайменьше така ж важлива для неявних, як і для явно написаного коду. Якщо неявні визначення отримали б ефект в маштабах системи, тоді для розуміння файла вам би знадобилось знати щодо кожного неявного перетворення, визначеного будь-де в програмі!</p></div>
<div class="paragraph"><p><strong>Правило один-за-раз: буде вставлене тільки одне неявне перетворення.</strong> Компілятор ніколи не буде переписувати <code>x + y</code> до <code>convert1(convert2(x)) + y</code>. Якщо робити це, час компіляції драматично збільшиться для помилкового коду, та це збільшить різницю між тим, що пише програміст, та що програма насправді робить. Заради збереження здорового глузду, компілятор не вставляє подальші неявні перетворення, коли він вже на середині спроби іншого неявного перетворення. Однак можливо обійти це обмеження, маючи неявні перетворювачі, що приймають неявні параметри, які будуть описані пізніше в цій главі.</p></div>
<div class="paragraph"><p><strong>Правило явні-перші: якщо код проходить перевірку типів як він є, жодні неявні не будуть спробувані.</strong> Компілятор не буде змінювати код, що вже робить. Наслідок з цього правила є такий, що ви завжди можете замінити неявні ідентифікатори на явні, таким чином роблячи код довшим, але з менш вірогідною двозначністю. Ви можете балансувати між ціма виборами на основі випадку-до-випадка. Кожного разу, коли ви бачите код, що виглядає повторюваним та балакучим, неявні перетворення можуть допомогти зменшити нудьгу. Кожного разу, коли ви бачите, що код виглядає скороченим до точки незрозумілості, ви можете вставити явні перетворення. Кількість неявних перетворень, що ви залишите для вставки компілятором, кінець кінцем є предметом стилю.</p></div>
<div class="sect2">
<h3 id="____24">Іменування неявного перетворення</h3>
<div class="paragraph"><p>Неявні перетворення можуть мати довільні імена. Ім'я неявного перетворення має значення тільки в двох ситуаціях: якщо ви бажаєте написати його явно в застосуванні метода, та для визначення, які перетворення доступні в любій точці програми. Щоб проілюструвати другу точку, скажімо, ви маєте об'єкт з двома неявними перетвореннями:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyConversions</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">stringWrapper</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span>
    <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToString</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В вашому застосуванні ви бажаєте використати перетворення <code>stringWrapper</code>, але ви не бажаєте, щоб цілі автоматично перетворювались на рядки за допомогою <code>intToString</code>. Ви можете досягти цього через імпорт тільки одного перетворення, але не іншого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">MyConversions.stringWrapper</span>
<span class="o">...</span> <span class="c1">// код, що використовує stringWrapper</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі було важливо, щоб неявні перетворення мали імена, оскільки тільки таким чином ви вибірково імпортуєте одні, та не імпортуєте інші.</p></div>
</div>
<div class="sect2">
<h3 id="______11">Де будуть спробувані неявні декларації</h3>
<div class="paragraph"><p>Існує три місця, де в мові використовуються неявні декларації: перетворення до очікуваного типу, перетворення отримувача вибору, та неявні параметри. Неявні перетворення до очікуваного типу дозволяють вам використовувати один тип в контексті, де очікуєтья інший тип. Наприклад, ви можете мати <code>String</code>, та бажати передати його в метод, що потребує <code>IndexedSeq[Char]</code>. Перетворення отримувача дозволяє вам адаптувати отримувач виклику метода (тобто об'єкт, на якому викликається метод), якщо метод не застосований на оригінальному типі. Прикладом є <code>"abc".exists</code>, що конвертований до <code>stringWrapper("abc").exists</code>, оскільки метод <code>exists</code> не доступний на <code>String</code>, але доступний на <code>IndexedSeq</code>. Неявні параметри, з іншого боку, звичайно використовуються для провадження додаткової інформації до викликаної функції, щодо того, що хоче викликач. Неявні параметри особливо корисні з дженерік функціями, коли визивана функція може інакше взагалі нічого не знати щодо типів одного або більше аргументів. Ми будемо досліджувати кожний з ціх трьох різновидів неявних в наступніх розділах.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_21_3_____">21.3 Неявні перетворення до очікуваного типу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявне перетворення до очікуваного типу є перше місце, де компілятор буде використовувати неявні. Це правило просте. Кожного разу, коли компілятор бачить <code>X</code>, але потребує <code>Y</code>, він буде шукати <code>implicit</code> функцію, що конвертує <code>X</code> до <code>Y</code>. Наприклад, звичайно число подвійної точності не може бути використане як ціле, бо воно втратить точність:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
  <span class="n">found</span>   <span class="k">:</span> <span class="kt">Double</span><span class="o">(</span><span class="err">3</span><span class="kt">.</span><span class="err">5</span><span class="o">)</span>
  <span class="kt">required:</span> <span class="kt">Int</span>
        <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>
                     <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак ви можете визначити неявне перетворення, щоб згладити це питання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">doubleToInt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toInt</span>
<span class="n">doubleToInt</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Double</span><span class="o">)</span><span class="kt">Int</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це коли компілятор бачить <code>Double</code>, зокрема <code>3.5</code>, в контексті де має бути <code>Int</code>. Доки компілятор бачить тільки звичайну помилку типу. Однак перед тим як здатись, він шукає неявне перетворення від <code>Double</code> до <code>Int</code>. В цьому випадку він знаходить таке: <code>doubleToInt</code>, оскільки <code>doubleToInt</code> є в полі зору як єдиний ідентифікатор. (За межами інтерпретатора ви можете занести <code>doubleToInt</code> в поле зору через імпорт, або, можливо, через наслідування). Потім компілятор автоматично вставляє виклик до <code>doubleToInt</code>. За лаштунками код стає такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">doubleToInt</span><span class="o">(</span><span class="mf">3.5</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буквально <em>неявне</em> перетворення. Ви явно не просили про перетворення. Замість цього ви відмітили <code>doubleToInt</code> як доступне неявне перетворення, через занесення його в поле зору як єдиний ідентифікатор, та потім компілятор автоматично використовує його коли треба для конвертації від <code>Double</code> до <code>Int</code>.</p></div>
<div class="paragraph"><p>Конвертація <code>Double</code> до <code>Int</code> може декого здивувати, оскільки є сумнівною ідеєю мати дещо, що спричиняє втрату точності, що відбувається невидимо. Так що це насправді не те перетворення, яке ми рекомендуємо. Це має значно більше сенсу, якщо пійти в зворотньому напрямку, від якогось більш обмеженого типу до більш загального. Наприклад, <code>Int</code> може бути конвертований без страти точності на <code>Double</code>, так що неявне перетворення від <code>Int</code> до <code>Double</code> має сенс. Фактично, це саме те, що відбувається. Об'єкт <code>scala.Predef</code>, що неявно імпортований в кожну Scala програму, визначає неявне перетворення, що конвертує "меньші" числові типи на "більші". Наприклад, ви знайдете в <code>Predef</code> наступне перетворення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">int2double</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toDouble</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось чому в Scala значення <code>Int</code> може бути збережене в змінних типу <code>Double</code>. Для цього немає особливого правила в системі типів; це просто неявне перетворення, що застосовується при нагоді.<span class="footnote"><br />[Однак бекенд Scala компілятора буде трактувати перетворення особливим чином, транслюючи його в особливий байткод <code>i2d</code>. Так що скомпільований образ буде такий самий, як в Java.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_4__">21.4 Перетворення отримувача</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні перетворення також застосовуються до отримувача виклику метода, об'єкт, на якому викликається метод. Цей різновид неявного перетворення має два головні застосування. Перше, перетворення отримувача дозволяє гладшу інтеграцію нових класів в існуючу ієрархію класів. Та друге, вони підтримують написання домен-специфічних мов (DSL) всередині мови.</p></div>
<div class="paragraph"><p>Щоб побачити, як це робить, уявімо, що ви пишете <code>obj.doIt</code>, та <code>obj</code> не має члена на ім'я <code>doIt</code>. Компілятор буде намагатись вставити перетворення, перед тим як здатись. В цьому випадку перетворення треба застосувати до отримувача <code>obj</code>. Компілятор буде діяти так, якби очікуваний "тип" <code>obj</code> мав член на ім'я <code>doIt</code>. Цей "має <code>doIt</code>" тип не є звичайним типом Scala, але концептуально він тут, і ось чому компілятор буде вставляти неявне перетворення в цьому випадку.</p></div>
<div class="sect2">
<h3 id="_____16">Взаємодія з новими типами</h3>
<div class="paragraph"><p>Як вже зазначалось перед цім, одне головне застосування конвертації отримувача є дозволити гладшу інтеграцію нових типів з існуючими типами. Зокрема, вони дозволяють вам дозволити програмістам клієнтів використовувати примірники існуючих типів, так, якби вони були би примірниками нових типів. Візьмемо, наприклад, клас <code>Rational</code>, показаний в Лістингу 6.5. Ось фрагмент цього класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
<span class="o">...</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас <code>Rational</code> має два перевантажені варіанта метода <code>+</code>, що приймає <code>Rational</code> та <code>Int</code>,відповідно, в якості аргументів. Так що ви можете або додавати раціональні числа, або раціональне та ціле:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="o">+</span> <span class="n">oneHalf</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо виразів, як <code>1 + oneHalf</code>? Цей вираз хитрий, оскільки отримувач, <code>1</code>, не має підходящого метода <code>+</code>. Так що наступне дасть помилку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">overloaded</span> <span class="kt">method</span> <span class="kt">value</span> <span class="kt">+</span> <span class="kt">with</span>
<span class="n">alternatives</span> <span class="o">(</span><span class="nc">Double</span><span class="o">)</span><span class="nc">Double</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span> <span class="o">...</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span>
<span class="n">to</span> <span class="o">(</span><span class="nc">Rational</span><span class="o">)</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб дозволити цей різновид змішаної арифметики, вам треба визначити неявне перетворення від <code>Int</code> до <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
<span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">intToRational</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">Rational</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли це перетворення на місці, конвертація отримувача робить цей трюк:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається за лаштунками сцени, це те, що компілятор Scala спочатку намагається перевірити тип варазу  <code>1 + oneHalf</code> як він є. Це схибить, оскільки <code>Int</code> має декілька методів <code>+</code>, але жодного, що приймає аргумент <code>Rational</code>. Далі, компілятор шукає неявне перетворення від <code>Int</code> до іншого типу, що має метод <code>+</code>, який може бути застосований до <code>Rational</code>. Він находить ваше перетворення, та застосовує його, що дає таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">intToRational</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">oneHalf</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку компілятор знайшов функцію неявного перетворення, оскільки ви ввели його визначення в інтерпретатор, що занесло його поле зору до кінця сессії інтерпретатора.</p></div>
</div>
<div class="sect2">
<h3 id="____25">Симуляція нового синтаксису</h3>
<div class="paragraph"><p>Інше головне застосування неявних перетворень це симуляція додавання нового синтаксису. Згадайте, що ви можете створити <code>Map</code>, використовуючи такий синтаксис:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;two&quot;</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;three&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Чи ви не здивувались, як підтримується <code>-&gt;</code>? Це не синтаксис! Замість цього <code>-&gt;</code> є методом класу <code>ArrowAssoc</code>, класу, визначеного в стандартній преамбулі Scala (<code>scala.Predef</code>). Преамбула також визначає неявне перетворення з <code>Any</code> до <code>ArrowAssoc</code>. Коли ви пишете <code>1 -&gt; "one"</code>, компілятор вставляє перетворення від <code>1</code> до <code>ArrowAssoc</code> так що метод <code>-&gt;</code> може бути знайдений. Ось відповідні визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala</span>

<span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tuple2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">any2ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrowAssoc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей шаблон "багатих огорток" загальний в бібліотеках, що провадять до мови синтаксо-подібні розширення, так що ви повинні бути готові розпізнати шаблон, коли ви бачите його. Кожного разу, коли ви бачите ,як дехто викликає методи, що не існують в класі отримувачі, вони вірогідно використовують неявні перетворення. Подібно до цього, якщо ви бачите клас, названий <code>RichSomething</code> (тобто, <code>RichInt</code> або <code>RichBoolean</code>), виглядає що цей клас додає синтакс-подібні методи до типу <code>Something</code>.</p></div>
<div class="paragraph"><p>Ви вже бачили цей шаблон багатих огорток для базових типів, описаних в Главі 5. Як ви можете бачити, ці багаті огортки застосовуються більш широко, часто дозволяючи вам отримати внутрішінй DSL, визначений як бібліотека, коли програмісти на інших мовах відчувають потребу в зовнішньому DSL.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___41">Неявні класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні класи були додані в Scala 2.10, щоб спростити написання багатих класів огорток. Неявний клас є клас, перед яким стоїть ключове слово <code>implicit</code>. Для любого такого класу компілятор генерує неявне перетворення від параметру конструктора класу до самого класу. Таке перетворення є саме тим, що вам треба, якщо ви плануєте використовувати клас для шаблону багатих огорток.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що ви маєте клас на ім'я <code>Rectangle</code> для представлення ширини та висоти прямокутника на екрані:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви використовуєте цей клас дуже часто, ви можете побажати використати шаблон багатої огортки, так щоб ви могли конструювати його більш просто. Ось один спосіб зробити це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">class</span> <span class="nc">RectangleMaker</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">x</span><span class="o">(</span><span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначення вище визначає клас <code>RectangleMaker</code> в звичайній манері. На додаток, він спричиняє автоматичну генерацію наступного перетворення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Автоматично згенеровано</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nc">RectangleMaker</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=new</span> <span class="nc">RectangleMaker</span><span class="o">(</span><span class="n">width</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як результат, ви можете створити точки через покладання <code>x</code> між двома цілими:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">myRectangle</span> <span class="k">=</span> <span class="mi">3</span> <span class="n">x</span> <span class="mi">4</span>
<span class="n">myRectangle</span><span class="k">:</span> <span class="kt">Rectangle</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як це робить: оскільки тип <code>Int</code> не має метода на ім'я <code>x</code>, компілятор буде шукати неявне перетворення від <code>Int</code> до чогось, що має. Він знайде згенероване перетворення <code>RectangleMaker</code>, та <code>RectangleMaker</code> має метод на ім'я <code>x</code>. Компілятор вставляє виклик для цього перетворення, після чого виклик <code>x</code> проходить перевірку типів, і робить те, що задумане.</p></div>
<div class="paragraph"><p>Як засторога для відчайдушних, може бути спокусливо думати, що кожний клас може мати поставлений перед собою <code>implicit</code>. Це не так. Неявний клас не може бути кейс класом, та його конструктор повинен мати рівно один параметр. Також неявний клас мусить розміщуватись в деякому іншому об'єкті, класі або трейті. На практиці, доки ви використовуєте неявні класи як багаті огортки для додавання нових методів в існуючі класи, ці обмеження не повинні мати значення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_5__">21.5 Неявні параметри</h2>
<div class="sectionbody">
<div class="paragraph"><p>Останнє місце, де компілятор вставляє неявні, є спискі аргументів. Компілятор буде іноді замінювати <code>someCall(a)</code> на <code>someCall(a)(b)</code>, або <code>new SomeClass(a)</code> на <code>new SomeClass(a)(b)</code>, таким чином додаючи відсутній список параметрів для завершення виклику функції. Те, що додається є цілим останнім карованим списком параметрів, не просто останній параметр. Наприклад, якщо <code>someCall</code> не вистачає останнього списку параметрів, що приймає три параметра, компілятор може замінити <code>someCall(a)</code> на <code>someCall(a)(b, c, d)</code>. Для цього використання не просто вставлені ідентифікатори, такі як <code>b</code>, <code>c</code>, та <code>d</code> в <code>(b, c, d)</code>, бути відмічені як неявні там, де вони визначені, але також останній список параметрів в  визначенні <code>someCall</code> або <code>someClass</code> має бути маркований як <code>implicit</code>.</p></div>
<div class="paragraph"><p>Ось простий приклад. Уявімо, що ви маєте клас <code>PreferredPrompt</code>, що енкапсулює рядок підказки оболонки (такий як, скажімо <code>"$ "</code> або <code>"&gt; "</code>), який обирає користувач:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Також, уявімо, ви маєте об'єкт <code>Greeter</code> з методом <code>greet</code>, що приймає два списка параметрів. Перший список параметрів приймає ім'я користувача як рядок, та другий список параметрів приймає <code>PreferredPrompt</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;. The system is ready.&quot;</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Останній список параметрів відмічений як <code>implicit</code>, що означає, що він може бути наданий неявно. Але ви можете все ще провадити підказку явно, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bobsPrompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;relax&gt; &quot;</span><span class="o">)</span>
<span class="n">bobsPrompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span> <span class="o">=</span> <span class="nc">PreferredPrompt</span><span class="k">@</span><span class="mi">714</span><span class="n">d36d6scala</span><span class="o">&gt;</span>
<span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">)(</span><span class="n">bobsPrompt</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Bob</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="n">relax</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб дозволити компілятору надавати параметр неявно, вам треба зпочатку визначити змінну очікуваного типу, що в цьому випадку є <code>PreferredPrompt</code>. Ви можете зробити це, наприклад, в об'єкті користувацькіх налаштувань:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">JoesPrefs</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;Yes, master&gt; &quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що сама <code>val</code> відмічена як <code>implicit</code>. Якщо ні, компілятор не буде використовувати її для надання відсутнього списку параметрів. Він також не буде використовувати її, якщо вона не в полі зору як єдиний ідентифікатор, як показано в цьому прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span>
<span class="n">parameter</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span>
              <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
                           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак коли ви занесете її в поле зору через імпорт, вона буде використана для надання відсутнього списку параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">JoesPrefs._</span>
<span class="k">import</span> <span class="nn">JoesPrefs._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="nc">Yes</span><span class="o">,</span> <span class="n">master</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважне, що ключове слово <code>implicit</code> стосується до цілього списку параметрів, не до індивідуальних параметрів. Лістинг 21.1 показує приклад, в якому останній список параметрів метода <code>Greeter</code> <code>greet</code>, що знову визначений <code>implicit</code>, має два параметри: <code>prompt</code> (типу <code>PreferredPrompt</code>), та <code>drink</code> (типу <code>PreferredDrink</code>).</p></div>
<div class="paragraph"><p>Об'єкт синглтон <code>JoesPrefs</code> декларує дві неявні <code>val</code>, <code>prompt</code> типу <code>PreferredPrompt</code>, та <code>drink</code> типу <code>PreferredDrink</code>. Однак як і раніше, доки воні не в полі зору як прості ідентифікатори, вони не будуть використані для заповнення відсутнього списку параметрів для <code>greet</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">19</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span>
<span class="n">parameter</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span>
              <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
                           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете занести обі неявні <code>val</code> в поле зору за допомогою <code>import</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">JoesPrefs._</span>
<span class="k">import</span> <span class="nn">JoesPrefs._</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки обоє, <code>prompt</code> та <code>drink</code> тепер в полі зору як єдині ідентифікатори, ви можете використовувати їх для явного надання останнього списку параметрів, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)(</span><span class="n">prompt</span><span class="o">,</span> <span class="n">drink</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="nc">But</span> <span class="k">while</span> <span class="n">you</span> <span class="n">work</span><span class="o">,</span> <span class="n">why</span> <span class="n">not</span> <span class="n">enjoy</span> <span class="n">a</span> <span class="n">cup</span> <span class="n">of</span> <span class="n">tea</span><span class="o">?</span>
<span class="nc">Yes</span><span class="o">,</span> <span class="n">master</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Але оскільки тепер задовільняються всі правила для неявних параметрів, альтернативно ви можете дозволити компілятору Scala надати <code>prompt</code> та <code>drink</code> для вас, відкинувши останній список параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="nc">But</span> <span class="k">while</span> <span class="n">you</span> <span class="n">work</span><span class="o">,</span> <span class="n">why</span> <span class="n">not</span> <span class="n">enjoy</span> <span class="n">a</span> <span class="n">cup</span> <span class="n">of</span> <span class="n">tea</span><span class="o">?</span>
<span class="nc">Yes</span><span class="o">,</span> <span class="n">master</span><span class="o">&gt;</span>

<span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">,</span>
      <span class="n">drink</span><span class="k">:</span> <span class="kt">PreferredDrink</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;. The system is ready.&quot;</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot;But while you work, &quot;</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;why not enjoy a cup of &quot;</span> <span class="o">+</span> <span class="n">drink</span><span class="o">.</span><span class="n">preference</span> <span class="o">+</span> <span class="s">&quot;?&quot;</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">JoesPrefs</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;Yes, master&gt; &quot;</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">drink</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;tea&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.1 - Неявний список параметрів з декількома параметрами.</p></div>
<div class="paragraph"><p>Одна річ, яку треба відмітити щодо попередніх прикладів, є те, що ми не використовуємо <code>String</code> як тип для <code>prompt</code> або <code>drink</code>, навіть якщо кінець кінцем це буде <code>String</code>, що отримають обоє через поля <code>preference</code>. Оскільки компілятор обирає неявні параметри через порівняння типів параметрів з типами змінних в полі зору, неявні параметри звичайно мають досить "рідкі" або "специфічні" типи, щоб зробити випадкове співпадіння маловірогідним. Наприклад, типи <code>PreferredPrompt</code> та <code>PreferredDrink</code> в Лістингу 21.1 були визначені єдино служити як типи неявних параметрів. Як результат, маловірогідно, що неявні змінні ціх типів будуть в полі зору, якщо вони не призначені для використання як неявні параметри для <code>Greeter.greet</code>.</p></div>
<div class="paragraph"><p>Інша річ, що треба знати щодо неявних параметрів, є те, що вони найбільш часто використовуються для провадження інформації щодо типу, вказаного <em>явно</em> в ранішньому списку пармаетрів, подібно до класів типу в Haskell.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо функцію <code>maxListOrdering</code>, показану в Лістингу 21.2, що повертає максимальний елемент переданого списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxListOrdering</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxListOrdering</span><span class="o">(</span><span class="n">rest</span><span class="o">)(</span><span class="n">ordering</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordering</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.2 - Функція з верхньою межею.</p></div>
<div class="paragraph"><p>Сигнатура <code>maxListOrdering</code> подібна до <code>orderedMergeSort</code>, показаного в Лістингу 19.12: він приймає <code>List[T]</code> в якості аргумента, але зараз він приймає додатковий аргумент типу <code>Ordering[T]</code>. Цей додатковий аргумент специфікує, який <code>ordering</code> використовувати при порівнянні елементів типу <code>T</code>. Як така, ця версія може бути використана для типів, що не мають вбудованого спорядкування. Додатково, ця версія може бути використана для типів, що мають вбудоване впорядкування, але для яких ви час від часу бажаєте викорстовувати деякий інший порядок.</p></div>
<div class="paragraph"><p>Ця версія більш загальна, але вона також більш заплутана в використанні. Тепер викликач має вказувати явний порядок, навіть якщо <code>T</code> щось подібне до <code>String</code> або <code>Int</code>, що має явно визначений порядок. Щоб зробити цей новий метод більш зручним, допоможе зробити другий аргумент неявним. Цей підхід показаний в Лістингу 21.3.</p></div>
<div class="paragraph"><p>Параметр <code>ordering</code> в цьому прикладі використаний для описання впорядкування <code>T</code>. В тілі <code>maxListImpParm</code> цей <code>ordering</code> використовується в двох місцях: в рекурсивному виклику до <code>maxListImpParm</code>, та виразі <code>if</code>, що перевіряє, що голова цього списку більша, ніж максимальний елемент в залишку списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxListImpParm</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="k">implicit</span> <span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>

  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="n">rest</span><span class="o">)(</span><span class="n">ordering</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordering</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.3 - Функція з неявним параметром.</p></div>
<div class="paragraph"><p>Функція <code>maxListImpParm</code> є прикладом неявного параметра, використаного для провадження додаткової інформації щодо типу, явно вказаного в попередньому списку параметрів. Більш точно, неявний параметр <code>ordering</code> типу <code>Ordering[T]</code> провадить більше інформації щодо типу T — в цьому випадку як впорядковувати <code>T</code>. Тип <code>T</code>, згаданий в <code>List[T]</code> як параметр типу елементів, з'являється в попередньому списку параметрів. Оскільки елементи мають завжди бути проваджені явно в любому виклику до <code>maxListImpParm</code>, компілятор буде знати <code>T</code> під час компіляції, і, таким чином, може визначити, чи доступне неявне визначення типу <code>Ordering[T]</code>. Якщо це так, він може передати другий список параметрів, <code>ordering</code>, неявно.</p></div>
<div class="paragraph"><p>Цей шаблон такий загальний, що стандартна бібліотека Scala провадить неявні методи <code>ordering</code> для багатьох загальних типів. Таким чином ви можете використовувати цей метод <code>maxListImpParm</code> з різними типами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mf">1.5</span><span class="o">,</span> <span class="mf">5.2</span><span class="o">,</span> <span class="mf">10.7</span><span class="o">,</span> <span class="mf">3.14159</span><span class="o">))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">10.7</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">,</span> <span class="s">&quot;three&quot;</span><span class="o">))</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">two</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому випадку компілятор вставляє <code>ordering</code> для <code>Int</code>; в другому випадку для <code>Double</code>; в третьому випадку для <code>String</code>.</p></div>
<div class="sect2">
<h3 id="______12">Правило стиля для неявних параметрів</h3>
<div class="paragraph"><p>Як правило стилю, є кращим використовувати власні імена типів в типах неявних параметрів. Наприклад, типи <code>prompt</code> та <code>drink</code> в попередньому прикладі не були <code>String</code>, але  <code>PreferredPrompt</code> та <code>PreferredDrink</code>, відповідно. Як контрприклад розглянемо функцію <code>maxListImpParm</code>, що може так само бути написаний з наступною сигнатурою типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxListPoorStyle</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="k">implicit</span> <span class="n">orderer</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак щоб використати цю версію функції, викликач має надати параметр <code>orderer</code> типу <code>(T, T) =&gt; Boolean</code>. Це досить загальний тип, що включає любу функцію з двох <code>T</code> до <code>Boolean</code>. Він зовсім нічого не вказує щодо того, для чого призначений цей тип; він може бути перевіркою на рівність, перевіркою на менше-ніж, перевіркою на більше-ніж, або повністю чимось іншим.</p></div>
<div class="paragraph"><p>Справжній код для <code>maxListImpParm</code>, наданий в Лістингу 21.3, показує кращий стиль. Він використовує параметр <code>ordering</code> типу <code>Ordering[T]</code>. Слово <code>Ordering</code> в цьому типі точно вказує, для чого призначений неявний параметр: він призначений для впорядкування елементів <code>T</code>. Оскільки цей тип <code>ordering</code> більш явний, немає проблем з додаванням неявних провайдерів для цього типу в стандартній бібліотеці. Для контрасту, уявіть хаос, що настав би, якщо б ви додали неявний тип <code>(T, T) =&gt; Boolean</code> в стантартну бібліотеку, і компілятор почав би зрошувати їм людський код. Ви б скінчили з кодом, що компілюється та виконується, але що робить досить довільні тести з парами елементів! Від цього випливає правило стилю: використовуйте щонайменьше одне роль-визначаюче ім'я в типі неявного параметру.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_21_6__">21.6 Межі контексту</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад мав показати можливості використання неявних, але ні. Зауважте, що коли ви застосовуєте неявне як параметр, не тільки компілятор спробує надати цей параметр через неявне значення, але компілятор також буде використовувати цей параметр як доступне неявне в тілі метода!</p></div>
<div class="paragraph"><p>Таким чином, перше використання <code>ordering</code> в тілі метода може бути відкинуте.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="k">implicit</span> <span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>

  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>    <span class="c1">// (ordering) неявне</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordering</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span> <span class="c1">// але це ordering</span>
      <span class="k">else</span> <span class="n">maxRest</span>                   <span class="c1">// все ще явне</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.4 - Функція, що використовує неявний параметр внутрішньо.</p></div>
<div class="paragraph"><p>Коли компілятор перевіряє код в Лістингу 21.4, він буде бачити, що типи не співпадають. Вираз <code>maxList(rest)</code> надає тільки один список параметрів, але <code>maxList</code> потребує два. Оскільки другий список параметрів є неявний, компілятор не здається зразу після перевірки типів. Замість цього він шукає неявний параметр відповідного типу, в цьому випадку <code>Ordering[T]</code>. В цьому випадку він находить такий, та переписує виклик на <code>maxList(rest)(ordering)</code>, після чого код проходить перевірку типів.</p></div>
<div class="paragraph"><p>Є також спосіб уникнути другого використання <code>ordering</code>. Він задіє наступний метод, визначений в стандартній бібліотеки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект виклику <code>implicitly[Foo]</code> в тому, що компілятор буде шукати неявне визначення типу <code>Foo</code>. Потім він буде викликати неявний метод з цім об'єктом, що, в свою чергу, повертає назад об'єкт. Таким чином ви можете записати <code>implicitly[Foo]</code> кожного разу, коли ви бажаєте найти неявний об'єкт типу <code>Foo</code> в поточньому полі зору. Наприклад, Лістинг 21.5 показує використання <code>implicitly[Ordering[T]]</code> для отримання параметра <code>ordering</code> по його типу.</p></div>
<div class="paragraph"><p>Подивіться уважніше на цю останню версію <code>maxList</code>. Тут немає жодного спомину параметру <code>ordering</code> в тексті метода. Другий параметр може так само бути названий <code>comparator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">comparator</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="c1">// те саме тіло...</span>

  <span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
        <span class="o">(</span><span class="k">implicit</span> <span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>

    <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
      <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
        <span class="k">else</span> <span class="n">maxRest</span>
    <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.5 - Функція, що використовує <code>implicitly</code>.</p></div>
<div class="paragraph"><p>З цієї причини ця версія бути робити так само:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
<span class="o">(</span><span class="k">implicit</span> <span class="n">iceCream</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="c1">// тіло те саме...</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки цей шаблон є загальним, Scala дозволяє вам пропустити ім'я цього параметру, та скоротити заголовок метода через використання межі контексту. Використання межі контексту дозволяє вам записати сигнатуру <code>maxList</code> як показано на Лістингу 21.6. Синтаксис <code>[T : Ordering]</code> є межою контексту, і він робить дві речі. Перше, він вводить параметр типу <code>T</code>, як звичайно. Друге, він додає неявний параметр типу <code>Ordering[T]</code>. В попередніх версіях <code>maxList</code>, цей параметр був названий <code>ordering</code>, але коли використовується межа контексту, ви не знаєте, що викликається параметром. Як показано раніше, часто вам не треба знати, що викликається параметром.</p></div>
<div class="paragraph"><p>Інтуітивно ви можете думати про межу контаксту, як сказати дещо про параметр типу. Коли ви пишете <code>[T &lt;: Ordered[T]]</code> ви кажете, що <code>T</code> є <code>Ordered[T]</code>. Для контрасту, коли ви пишете <code>[T : Ordering]</code> ви не кажете багато про те, що є <code>T</code>; скоріше, ви кажете, що існує деяка форма впорядкування, асоційована з <code>T</code>. Таким чином межа контексту досить гнучка. Це дозволяє вам використовувати код, що потребує впорядкування — або любу іншу властивість типу — без потреби змінювати визначення цього типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span> <span class="kt">:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.6 - Функція з межею контекста.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_7____">21.7 Коли застосовуються декілька конверсій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Може трапитись, що в полі зору знаходяться декілька неявних перетворень, і кожне може робити. В великій мірі Scala відмовляється вставляти перетворення в такому випадку. Неявні роблять гарно, коли перетворення, що відкидається, повністю очевидне та чистий шаблон. Якщо застосовуються декілька перетворень, вибір вже не такий і очевидний, кінець кінцем.</p></div>
<div class="paragraph"><p>Ось простий приклад. Існує метод, що приймає послідовність, перетворення, що обертає ціле на диапазон, та перетворення, що обертає ціле на список цифр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">printLength</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">seq</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">printLength</span><span class="k">:</span> <span class="o">(</span><span class="kt">seq:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Unit</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRange</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">i</span>
<span class="n">intToRange</span><span class="k">:</span> <span class="o">(</span><span class="kt">i:</span>
<span class="kt">Int</span><span class="o">)</span><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Range</span><span class="o">.</span><span class="nc">Inclusive</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToDigits</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
<span class="n">i</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toInt</span><span class="o">)</span>
<span class="n">intToDigits</span><span class="k">:</span> <span class="o">(</span><span class="kt">i:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printLength</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span><span class="o">(</span><span class="err">12</span><span class="o">)</span>
<span class="kt">required:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="nc">Note</span> <span class="n">that</span> <span class="k">implicit</span> <span class="n">conversions</span> <span class="n">are</span> <span class="n">not</span> <span class="n">applicable</span> <span class="n">because</span>
<span class="n">they</span> <span class="n">are</span> <span class="n">ambiguous</span><span class="k">:</span>
  <span class="kt">both</span> <span class="kt">method</span> <span class="kt">intToRange</span> <span class="kt">of</span> <span class="k">type</span> <span class="o">(</span><span class="kt">i:</span>
<span class="kt">Int</span><span class="o">)</span><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Range</span><span class="o">.</span><span class="nc">Inclusive</span>
  <span class="n">and</span> <span class="n">method</span> <span class="n">intToDigits</span> <span class="n">of</span> <span class="k">type</span> <span class="o">(</span><span class="kt">i:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="n">are</span> <span class="n">possible</span> <span class="n">conversion</span> <span class="n">functions</span> <span class="n">from</span> <span class="nc">Int</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span> <span class="n">to</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
               <span class="n">printLength</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span>
                           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Неоднозначність тут є реальною. Перетворення цілого на послідовність цифр повністю відрізняється від перетворення його на диапазон. В цьому випадку програміст має вказати, який варіант потрібен, та бути явним. До Scala 2.7 це було кінцем історії. Кожного разу, коли застосовуються декілька неявних перетворень, компілятор відмовляється обирати між ними. Ситуація була така сама, що і з перевантаженням методів. Якщо ви спробуєте викликати <code>foo(null)</code>, і є два різні перевантаження <code>foo</code>, що приймають <code>null</code>, компілятор відмовиться обирати. Він скаже, що ціль виклику метода неоднозначна.</p></div>
<div class="paragraph"><p>Scala 2.8 послаблює це правило. Якщо одне з доступних перетворень явно більш специфічне, ніж інші, тоді компілятор буде обирати більш специфічний варіант. Ідея в тому, що коли є причина повірити програмісту, що маємо завжди обирати один перетворювач ніж інші, не вимагати від програміста записувати це явно. Кінець кінцем, перевантаження методів має те саме послаблення. Продовжуючи попередній приклад, якщо один з доступних методів <code>foo</code> приймає <code>String</code>, тоді як інший приймає <code>Any</code>, тоді буде обрана версія з <code>String</code>. Це вочевидь більш специфічне.</p></div>
<div class="paragraph"><p>Щоб бути більш точним, неявне перетворення є більш специфічним, якщо відбувається одне з наступного:</p></div>
<div class="ulist"><ul>
<li>
<p>
Тип аргументу першого є субтипом другого.
</p>
</li>
<li>
<p>
Обоє перетворення є методами, та оточуючий клас першого розширює оточуючий клас другого.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Мотивацією для перегляду цього питання та ревізії правила було покращення взаємодії між Java колекціями, Scala колекціями, та рядками.</p></div>
<div class="paragraph"><p>Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">cba</span> <span class="k">=</span> <span class="s">&quot;abc&quot;</span><span class="o">.</span><span class="n">reverse</span>
</pre></div></div></div>
<div class="paragraph"><p>Який тип, що буде виведений для <code>cba</code>? Інтуітивно, типом має бути <code>String</code>. Реверс рядка має давати рядок, вірно? Однак в Scala 2.7 відбувається те, що <code>"abc"</code> було перетворене на Scala колекцію. Реверс Scala колекції дає Scala колекцію, так що тип <code>cba</code> має бути колекцією. Також є неявне перетворення назад до рядка, але це не латає жодних проблем. Наприклад, в версії до Scala 2.8 <code>"abc" == "abc".reverse.reverse</code> було <code>false</code>!</p></div>
<div class="paragraph"><p>В Scala 2.8 тип <code>cba</code> є <code>String</code>. Старе неявне перетворення до Scala колекції (тепер названої <code>WrappedString</code>) залишилось. Однак тепер є більш специфічне перетворення, від  <code>String</code> до нового типу, названого <code>StringOps</code>. <code>StringOps</code> має багато методів, таких як <code>reverse</code>, але замість повернення колекцій вони повертають <code>String</code>. Перетворення до <code>StringOps</code> визначено напряму в <code>Predef</code>, тоді як перетворення до Scala колекцій визначено в новому класі, <code>LowPriorityImplicits</code>, що розширений <code>Predef</code>. Коли існує вибір між ціма двома перетвореннями, компілятор обере перетворення до <code>StringOps</code>, оскільки він визначений в субкласі класу, де визначене інше перетворення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_8__">21.8 Зневадження неявних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні є потужною можливістю в Scala, але те, що іноді важко зрозуміти. Цей розділ містить декілька підказок зі зневадження неявних.</p></div>
<div class="paragraph"><p>Іноді ви можете дивуватись, чому компілятор не знайшов неявне перетворення, яке, як ви сподівались, мало б бути застосоване. В такому випадку допоможе записати це перетворення явно. Якщо  це також видає повідомлення про помилку, тоді ви знатимете, чому компілятор не застосував ваше неявне.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що ви помилково взяли <code>wrapString</code> в якості перетворення від <code>Strings</code>  до <code>List</code>, замість <code>IndexedSeqs</code>. Ви можете здивуватись, чому наступний код не робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;xyz&quot;</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">xyz</span><span class="err">&quot;</span><span class="o">)</span>
<span class="kt">required:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
      <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;xyz&quot;</span>
                              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову, допоможе написати перетворення <code>wrapString</code> явно, щоб знайти, що іде не так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">wrapString</span><span class="o">(</span><span class="s">&quot;xyz&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">scala.collection.immutable.WrappedString</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
      <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">wrapString</span><span class="o">(</span><span class="s">&quot;xyz&quot;</span><span class="o">)</span>
                                        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи це, ви знаходите те що спричинило помилку: <code>wrapString</code> має помилковий тип повернення. З іншого боку, також можливо, що явне вставлення перетворення призведе до зникнення помилки. В цьому випадку ви знаєте, що одне з інших правил (таке як Правило поля зору) перешкоджає застосуванню неявного перетворення.</p></div>
<div class="paragraph"><p>Коли ви зневаджуєте програму, іноді може допомогти побачити, яке неявне перетворення вставляє компілятор. Для цього корисна опція компілятора <code>-Xprint:typer</code>. Якщо ви виконуєте <code>scalac</code> з цією опецією, компілятор буде показувати вам, як буде виглядати код після всіх неявних перетворень, що були додані перевіркою типів. Приклад показаний в Лістингу 21.7 та Лістингу 21.8. Якщо ви подивитесь на останній вираз в кожному лістингу, ви побачите, що другий список параметрів <code>enjoy</code>, що випущений в коді Лістинга 21.7, <code>enjoy("reader")</code> був доданий компілятором, як показано в Лістингу 21.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">enjoy</span><span class="o">(</span><span class="s">&quot;reader&quot;</span><span class="o">)(</span><span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">pref</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви хоробрий, спробуйте <code>scala -Xprint:typer</code> щоб отримати інтерактивну оболонку, що роздруковує пост-типізований код, що використовується внутрішньо. Якщо ви зробите це, будьте готові побачити величезну кількість шаблонного обвісу, що оточує м'ясо вашого коду.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Mocha</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="k">class</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">pref</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;mocha&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">enjoy</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">drink</span><span class="k">:</span> <span class="kt">PreferredDrink</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot;. Enjoy a &quot;</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="n">drink</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="n">enjoy</span><span class="o">(</span><span class="s">&quot;reader&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.7 - Код прикладу, що використовує неявний параметр.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="nc">Xprint</span><span class="k">:type</span><span class="kt">r</span> <span class="kt">mocha.scala</span>
<span class="o">[[</span><span class="kt">syntax</span> <span class="kt">trees</span> <span class="kt">at</span> <span class="kt">end</span> <span class="kt">of</span> <span class="k">type</span><span class="kt">r</span><span class="o">]]</span>
<span class="c1">// Scala source: mocha.scala</span>
<span class="k">package</span> <span class="err">&lt;</span><span class="nn">empty</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">object</span> <span class="nc">Mocha</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span> <span class="k">with</span> <span class="nc">Application</span>
    <span class="k">with</span> <span class="nc">ScalaObject</span> <span class="o">{</span>

<span class="c1">// ...</span>

    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">pref</span><span class="k">:</span> <span class="kt">Mocha.PreferredDrink</span> <span class="o">=</span>
     <span class="k">new</span> <span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;mocha&quot;</span><span class="o">);</span>
    <span class="k">implicit</span> <span class="o">&lt;</span><span class="n">stable</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">accessor</span><span class="o">&gt;</span>
      <span class="k">def</span> <span class="n">pref</span><span class="k">:</span> <span class="kt">Mocha.PreferredDrink</span> <span class="o">=</span> <span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">pref</span><span class="o">;</span>
    <span class="k">def</span> <span class="n">enjoy</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
       <span class="o">(</span><span class="k">implicit</span> <span class="n">drink</span><span class="k">:</span> <span class="kt">Mocha.PreferredDrink</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span><span class="o">.+(</span><span class="n">name</span><span class="o">));</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="s">&quot;. Enjoy a &quot;</span><span class="o">);</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="n">drink</span><span class="o">.</span><span class="n">preference</span><span class="o">);</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;!&quot;</span><span class="o">)</span>
    <span class="o">};</span>
    <span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">enjoy</span><span class="o">(</span><span class="s">&quot;reader&quot;</span><span class="o">)(</span><span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">pref</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.8 - Код прикладу після перевірки типів та вставки <code>implicit</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_9_">21.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні є потужною, кодо-стискаючою можливістю Scala. Ця глава показала вам правила Scala щодо неявних, та декілька загальних програмних ситуацій, коли ви можете отримати вигоди від використання неявних. Як слово застереження, неявні можуть зробити код збентежливим, якщо ви використовуєте їх дуже часто. Таким чином, перед додаванням неявного перетворення, спочатку запитайте, чи ви можете досягти подібного ефекту через інші засоби, такі як наслідування, композиція міксінів або перевантаження методів. Однак якщо все це схибить, і ви відчуваєте, що більшість вашого коду досі нудна та зайва, тоді неявні можуть допомогти вам знайти вихід.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__22">Глава 22</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___42">Реалізація списків</h1>
<div class="paragraph"><p>Списки стали повсюдними в цій книзі. Клас <code>List</code>, можливо, є найбільш загально уживаний тип структурованих даних в Scala. Глава 16 показала вам, як використовувати списки. Ця глава "зриває покривадла", та трохи пояснює щодо того, як списки реалізовані в Scala.</p></div>
<div class="paragraph"><p>Знаючи внутрішню роботу класу <code>List</code> корисне з деяких причин. Ви набудете кращу ідею щодо відносної ефективності операцій списків, що допоможе вам писати швидкий та компактний код з використанням списків. Ви також набудете інструментарій з прийомів, що ви можете застосувати в розробці ваших власних бібліотек. Нарешті, клас <code>List</code> є витонченим застосуванням системи типів Scala загалом, та зокрема її узагальнених концепцій. Так що вивчання класу <code>List</code> поглибить ваше знання ціх областях.</p></div>
<div class="sect1">
<h2 id="_22_1__list_">22.1 Клас List, принципово</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>List</code> не є "вбудований" як конструкція мови в Scala; списки визначені як абстрактний клас <code>List</code> в пакунку <code>scala</code>, що іде з двома субкласами, <code>::</code> та <code>Nil</code>. В цій главі ми презентуємо швидкий тур по класу <code>List</code>. Цей розділ представляє дещо спрощене пояснення цього класу, порівняно з його справжньою реалізацією в стандартній бібліотеці Scala, що розкривається в Розділі 22.3.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
</pre></div></div></div>
<div class="paragraph"><p>List є абстрактним класом, так що ви не можете визначити елементи через виклик порожнього конструктора <code>List</code>. Наприклад, вираз <code>new List</code> буде нелегальним. Клас має параметр типу <code>T</code>. Знак <code>+</code> перед цім параметром типу вказує, що списки є коваріантними, як обговорюється в Главі 19.</p></div>
<div class="paragraph"><p>Малюнок 22.1 - Ієрархія класів для списків Scala.</p></div>
<div class="paragraph"><p>Завдяки цій властивості ви можете присвоїти значення типу <code>List[Int]</code> до змінної типу <code>List[Any]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span>
<span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі операції списків можуть бути виражені в термінах трьох базових методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
<span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці три методи всі абстрактні в класі <code>List</code>. Вони визначені в субоб'єкті <code>Nil</code> і субкласі <code>::</code>. Ієрархія для <code>List</code> показана на Малюнку 22.1.</p></div>
<div class="sect2">
<h3 id="___code_nil_code">Об'єкт <code>Nil</code></h3>
<div class="paragraph"><p>Об'єкт <code>Nil</code> визначає порожній список. Його визначення показане в Лістингу 22.1. Об'єкт <code>Nil</code> наслідує від типу <code>List[Nothing]</code>. Завдяки коваріантності це означає, що <code>Nil</code> сумісний з кожним примірником типу <code>List</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;head of empty list&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;tail of empty list&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.1 - Визначення об'єкта синглтона <code>Nil</code>.</p></div>
<div class="paragraph"><p>Три абстрактні метода класу <code>List</code> реалізовані в об'єкті <code>Nil</code> в прямолінійний спосіб: метод <code>isEmpty</code> повертає <code>true</code>, та методи <code>head</code> та <code>tail</code> обоє закидають виключення. Зауважте, що закидання виключення не тільки має сенс, але практично є єдиною можливою річчю, що можна робити для <code>head</code>: оскільки <code>Nil</code> є <code>List</code> з <code>Nothing</code>, тип результату <code>head</code> має бути <code>Nothing</code>. Оскільки немає значення цього типу, це означає, що <code>head</code> не може повернути звичайне значення. Він має повертатись ненормально, через закидання виключення.<span class="footnote"><br />[Щоб бути точним, типи також дозволяють <code>head</code> назавжди пійти в безкінечний цикл, замість закидання виключення, але це очевидно не те, що ми бажаємо.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="__code_code">Клас <code>::</code></h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Клас <code>::</code>, вимовляється <code>"cons"</code> скорочено від <code>"construct"</code>, представляє непорожній список. Він названий в такий спосіб, щоб підтримувати співпадіння шаблонів з інфіксним <code>::</code>. Ви вже бачили в Розділі 16.5, що кожна інфіксна операція в шаблоні трактується як застосування конструктора інфіксного оператора до його аргументів. Так що шаблон `x 
</dt>
<dd>
<p>
xs` трактується як <code>::(x, xs)</code>, де <code>::</code> є кейс класом.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Ось визначення класу <code>::</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація класу <code>::</code> є прямолінійним. Він приймає два параметри, <code>hd</code> та <code>tl</code>, які представляють голову та хвіст списку, що має бути створений. Визначення методів <code>head</code> та <code>tail</code> просто повертають відповідний параметр. Фактично, цей шаблон може бути скорочений, дозволяючи параметрам напряму реалізувати методи <code>head</code> та <code>tail</code> суперкласу <code>List</code>, як в наступному еквівалентному, але коротшому визначенні класу <code>::</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить, бо кожний параметр кейс класу неявно також є полем класу (це як декларація параметру, перед яким стоїть <code>val</code>). Згадайте з Розділу 20.3, що Scala дозволяє вам реалізовати абстрактний безпараметрний метод, як <code>head</code> або <code>tail</code>, за допомогою поля. Так що код вище напряму використовує параметри <code>head</code> та <code>tail</code> як реалізації абстрактних методів <code>head</code> та <code>tail</code>, що були наслідувані від класу <code>List</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____26">Ще декілька методів</h3>
<div class="paragraph"><p>Всі інші методи <code>List</code> можуть бути записані з використанням троьх базових методів. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>або:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">drop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="n">tail</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">)</span> <span class="o">::</span> <span class="n">tail</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__list">Конструювання List</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Методи конструювання списків, <code>::</code> та <code>:::</code>, є особливими. Оскільки вони закінчуються на двокрапку, вони прикріплені до свого правого операнду. Тобто, операція, така як `x 
</dt>
<dd>
<p>
xs` розглядається як виклик метода <code>xs.::(x)</code>, не <code>x.::(xs)</code>. Фактично, <code>x.::(xs)</code> не мало б сенсу, оскільки <code>x</code> має тип елементу списку, що може бути довільним, так що ми не можемо очікувати, що цей тип має метод <code>::</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>З цієї причини метод <code>::</code> має приймати значення елементу та видавати новий список. Який тип має бути в значень елементів? Ви можете спокуситись і сказати, що він має бути такий самий, що і тип елементів списку, але фактично це більш обмежливе, ніж треба.</p></div>
<div class="paragraph"><p>Щоб бачити чого, розглянемо таку ієрархію класів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Fruit</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.2 показує, що трапляється, коли ви конструююте списки фруктів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">apples</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Apple</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">apples</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Apple</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="nd">@e885c6a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fruits</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Orange</span> <span class="o">::</span> <span class="n">apples</span>
<span class="n">fruits</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Fruit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Orange</span><span class="k">@</span><span class="mi">3</span><span class="n">f51b349</span><span class="o">,</span> <span class="nc">Apple</span><span class="nd">@e885c6a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.2 - Підставлення елементу супертипа до списку субтипа.</p></div>
<div class="paragraph"><p>Значення <code>apples</code> трактується як <code>List</code> з <code>Apples</code>, як і очікувалось. Але визначення <code>fruits</code> показує, що все ще можливо додати елемент іншого типу до цього списку. Тип елементу отриманого списку буде <code>Fruit</code>, що є більш точним загальним супертипом елементів оригінального списку (<code>Apple</code>), і типу доданого елементу (<code>Orange</code>). Ця гнучкість отримана через визначення метода <code>::</code> (<code>cons</code>), як показано в Лістингу 22.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.3 - Визначення метода <code>::</code> (<code>cons</code>) в класі <code>List</code>.</p></div>
<div class="paragraph"><p>Зауважте, що метод сам по собі поліморфний — він приймає параметр типу на ім'я U. Більше того, <code>U</code> обмежений в <code>[U &gt;: T]</code>, щоб він був супертипом типу елемента списку <code>T</code>. Елемент, що додається, має бути типу <code>U</code>, і результатом буде <code>List[U]</code>.</p></div>
<div class="paragraph"><p>С формулюванням <code>::</code>, показаним на Лістингу 22.3, ви можете перевірити, як визначення <code>fruits</code>, показана в Лістингу 22.2 робить с точки зору типів: в цьому визначенні параметр типу <code>U</code> в <code>::</code> виступає як примірник <code>Fruit</code>. Обмеження нижньої межі для <code>U</code> задовільняється, оскільки список <code>apples</code> має тип <code>List[Apple]</code>, і <code>Fruit</code> є супертипом для <code>Apple</code>. Аргументом <code>::</code> є <code>new Orange</code>, що відповідає типу <code>Fruit</code>. Таким чином, застосування метода є типо-коректним, з типом результату <code>List[Fruit]</code>. Малюнок 22.2 ілюструє структуру списків, що отримуються від виконання коду, показаного в Лістингу 22.2.</p></div>
<div class="paragraph"><p>Малюнок 22.2 - Структура списків Scala, показаного в Лістингу 22.2.</p></div>
<div class="paragraph"><p>Фактично, поліморфне визначення <code>::</code> з нижньою межею <code>T</code> не тільки зручне, але також потрібне щоб зробить визначення класу <code>List</code> типо-коректним. Це так, тому що <code>List</code> визначений як коваріантний.</p></div>
<div class="paragraph"><p>Уявімо на мить, що ми визначили <code>::</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Розумовий експеримент (що не буде робити)</span>
<span class="k">def</span> <span class="o">::(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачили в Главі 19, що параметри метода рахуються як контрваріантні позиції, так що тип елементів списку <code>T</code> є контрваріантної позицією в визначенні вище. Але тоді <code>List</code> не може бути декларований як коваріантний по <code>T</code>. Таким чином, нижня межа, <code>[U &gt;: T]</code>, убиває двох зайців з одного пострілу: вона прибирає проблему типізації, та призводить до того, що метод <code>::</code> стає більш гнучким в використанні. Метод конкатенації <code>:::</code> визначений в подібний до <code>::</code> спосіб, як показано в Лістингу 22.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">:::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">prefix</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.4 - Визначення метода <code>:::</code> в класі <code>List</code>.</p></div>
<div class="paragraph"><p>Як і <code>cons</code>, конкатенація є поліморфною. Тип результату "поширений" як треба, щоб включати типи всіх елементів списку. Знову зауважте, що порядок аргументів переставлений в інфіксній операції та явному виклику метода. Оскільки обоє, <code>:::</code> та <code>::</code>, завершуються на дві крапки, вони обоє прив'язуються до правої сторони, та обоє право асоціативні. Наприклад, частина <code>else</code> визначення <code>:::</code>, показаний в Лістингу 22.4, містить інфіксні операції обох, <code>::</code> та <code>:::</code>.</p></div>
<div class="paragraph"><p>Ці інфіксні операції можуть бути розширені до еквівалентних методів, що викликаються таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span>
  <span class="n">дорівнює</span> <span class="o">(</span><span class="n">оскільки</span> <span class="o">::</span> <span class="n">та</span> <span class="o">:::</span> <span class="n">право</span> <span class="n">асоциативні</span><span class="o">)</span>

<span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span><span class="o">)</span>
  <span class="n">дорівнює</span> <span class="o">(</span><span class="n">оскільки</span> <span class="o">::</span> <span class="n">прикріплюється</span> <span class="n">зправа</span><span class="o">)</span>

<span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span><span class="o">).::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
  <span class="n">дорівнює</span> <span class="o">(</span><span class="n">оскількі</span> <span class="o">:::</span> <span class="n">прикріплюється</span> <span class="n">зправа</span><span class="o">)</span>

<span class="k">this</span><span class="o">.:::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span><span class="o">).::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_22_2__listbuffer">22.2 Клас ListBuffer</h2>
<div class="sectionbody">
<div class="paragraph"><p>Типовий шаблон доступа до списків є рекурсивний. Наприклад, для інкрементації кожного елемента без використовування мапи, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs1</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Один з недоліків цього програмного шаблону є те, що вона не має хвостової рекурсії. Зауважте, що рекурсивний виклик до <code>incAll</code> вище, відбувається в операції <code>::</code>. Таким чином, кожний рекурсивний виклик потребує новий фрейм стеку.</p></div>
<div class="paragraph"><p>На сьогоднішніх віртуальних машинах це означає, що ви не можете застосувати <code>incAll</code> до списків з більше ніж <code>30000</code> або <code>50000</code> елементів. Це шкода. Як ви пишете версію <code>incAll</code>, що може робити зі списками довільного розміру (доки дозволяє місткість купи)?</p></div>
<div class="paragraph"><p>Один з підходів є використання циклу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="c1">// ??</span>
</pre></div></div></div>
<div class="paragraph"><p>Але що має піти в тілі циклу? Зауважте, що тут <code>incAll</code> конструює список через перед-ставлення елементів до результату рекрсивного виклику, цикл потребує додавати нові елементи до кінця результуючого списку. Дуже неефективна можливість є використання <code>:::</code>, оператора додавання списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span> <span class="c1">// дуже неефективний підхід</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">result</span> <span class="k">=</span> <span class="n">result</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">result</span>
</pre></div></div></div>
<div class="paragraph"><p>Це жахливо неефективне. Оскільки <code>:::</code> займає час, пропорційний до довжини його першого операнда, повна операція займає час, пропорційний до квадрату довжини списку. Зрозуміло, що це неприйнятне.</p></div>
<div class="paragraph"><p>Кращою альтернативою є використання спискового буфера. Списковий буфер дозволяє вам акумулювати елементи в списку. Щоб зробити це, ви використовуєте операцію, таку як <code>buf += elem</code>, що додає елемент <code>elem</code> в кінець спискового буфера <code>buf</code>. Коли ви скінчите додавати елементи, ви можете перетворити буфер на список, використовуючи операцію <code>toList</code>.</p></div>
<div class="paragraph"><p><code>ListBuffer</code> є класом в пакунку <code>scala.collection.mutable</code>. Щоб використовувати тільки просте ім'я, ви можете імпортувати <code>ListBuffer</code> з його пакунку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи списковий буфер, тіло <code>incAll</code> тепер може бути записане таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дуже ефективний спосіб будувати списки. Фактично, реалізація спискового буфера організована таким чином, що обоє операції, додавання (<code>+=</code>) та <code>toList</code> займають (дуже короткий) сталий час.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_22_3__list__">22.3 Клас List на практиці</h2>
<div class="sectionbody">
<div class="paragraph"><p>Реалізація спискових методів, надане в Розділі 22.1, є стислі та зрозумілі, але потерпають від деяких проблем переповнення, як не-хвосто-рекурсивна реалізація <code>incAll</code>. Таким чином, більшість методів в реальних реалізаціях класу <code>List</code> уникають рекурсії, та замість цього використовують цикли з списковими буферами. Наприклад, Лістинг 22.5 показує справжню реалізацію <code>map</code> в класі <code>List</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
  <span class="k">var</span> <span class="n">these</span> <span class="k">=</span> <span class="k">this</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">these</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">these</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
    <span class="n">these</span> <span class="k">=</span> <span class="n">these</span><span class="o">.</span><span class="n">tail</span>
  <span class="o">}</span>
  <span class="n">b</span><span class="o">.</span><span class="n">toList</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.5 - Визначення метода <code>map</code> в класі <code>List</code>.</p></div>
<div class="paragraph"><p>Ця переглянута реалізація проходить по списку за допомогою простого циклу, що є дуже ефективним. Реалізація з хвостовою рекурсією може мати подібну ефективність, але загальна рекурсивна реалізація буде повільніша та менш маштабована. Але що до операції <code>b.toList</code> в кінці? Яка її складність? Фактично, виклик метода <code>toList</code> забирає тільки невелику кількість циклів, що не залежить від довжини списку.</p></div>
<div class="paragraph"><p>Щоб зрозуміти чому, накиньте другий погляд на клас <code>::</code>, що конструює непорожні списки. На практиці цей клас не повністю відповідає до його ідеалізованого визначення, попередньо наданому в Розділі 22.1. Справжнє визначення показане на Лістингу 22.6. Як ви можете бачити, є одна особливість: аргумент <code>tl</code> є <code>var</code>! Це означає, що можливо модифікувати хвіст списку після того, як цей список побудований. Однак, оскільки змінна <code>tl</code> має модифікатор <code>private[scala]</code>, він може бути доступний тільки в пакунку <code>scala</code>. Клієнтський код за межами цього пакунка ніколи не може ані читати, ні писати <code>tl</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">U</span><span class="o">,</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">scala</span><span class="o">]</span> <span class="k">var</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.6 - Визначення субкласа <code>::</code> в <code>List</code>.</p></div>
<div class="paragraph"><p>Оскільки клас <code>ListBuffer</code> міститься в субпакунку пакунка <code>scala</code>, <code>scala.collection.mutable</code>, <code>ListBuffer</code> може отримувати доступ до поля <code>tl</code> клітинки <code>cons</code>. Фактично, елементи спискового буфера представлени як список, та додавання нових елементів включає модифікацію поля <code>tl</code> останньої клітинки <code>::</code> цього списку. Ось початок класу <code>ListBuffer</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection.immutable</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Buffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">start</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">last0</span><span class="k">:</span> <span class="kt">::</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">exported</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите три приватні поля, що характерізують <code>ListBuffer</code>:</p></div>
<div class="paragraph"><p><code>start</code>     вказує на список з усіх елементів, що зберігаються в буфері
<code>last0</code>     вказує на останню клітину <code>::</code> в цьому списку
<code>exported</code>  вказує, чи буфер був перетворений на список за допомогою <code>toList</code></p></div>
<div class="paragraph"><p>Операція <code>toList</code> дуже проста:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">exported</span> <span class="k">=</span> <span class="o">!</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span>
  <span class="n">start</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Він повертає список елементів, на який посилається <code>start</code>, а також встановлює <code>true</code>, якщо цей список непорожній. Так що <code>toList</code> дуже ефективний, оскільки він не копіює список, що зберігається в <code>ListBuffer</code>. Але що відбувається, якщо список продовжує далі розширятись після операції <code>toList</code>? Звичайно, коли список повертається з <code>toList</code>, він має бути незмінним. Однак, додавання елемента <code>last0</code> буде модифікувати список, на який посилається <code>start</code>.</p></div>
<div class="paragraph"><p>Щоб підтримувати коректність операцій спискового буфера, вам треба робити замість цього на новому списку. Це досягається першим рядком в реалізації операції <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">exported</span><span class="o">)</span> <span class="n">copy</span><span class="o">()</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">start</span> <span class="k">=</span> <span class="n">last0</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">last1</span> <span class="k">=</span> <span class="n">last0</span>
    <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">last1</span><span class="o">.</span><span class="n">tl</span> <span class="k">=</span> <span class="n">last0</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що <code>+=</code> копіює список, на який вказує <code>start</code>, якщо <code>exported</code> є <code>true</code>. Так що, кінець кінцем, нічого не дається надурно. Якщо ви бажаєте перейти від списків, що можуть розширятись з кінця, до незмінних списків, тоді це потребуватиме деякого копіювання. Однак реалізація <code>ListBuffer</code> є такою, що копіювання необхідне тільки для спискових буферів, що продовжують розширюватись після того, як вони були перетворені на списки. Цей випадок досить рідкий на практиці. Більшість випадків використання для спискових буферів додають елементи послідовно, і потім роблять одну операцію <code>toList</code> в кінці. В таких випадках копіювання непотрібне.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_22_4__">22.4 Функціональність назовні</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередньому розділі ми показали ключові елементи реалізації Scala класів <code>List</code> та <code>ListBuffer</code>. Ви побачили, що списки повністю функціональні "назовні", але мають імперативну реалізацію з використанням спискових буферів "всередині". Це типова стратегія в Scala програмуванні — спроба комбінувати чистоту з ефективністю, через уважне розмежування впливу нечистих операцій.</p></div>
<div class="paragraph"><p>Але ви можете спитати, чому треба наполягати на чистоті? Чому просто не відкрити визначення списків, зробивши поле <code>tail</code>, а можливо і поле <code>head</code>, змінними? Недолік такого підходу в тому, що таким чином ви зробите програми значно більш крихкими. Зауважте, що конструювання списків за допомогою <code>::</code> повторно використовує <code>tail</code> конструйованого списку.</p></div>
<div class="paragraph"><p>Так що коли ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">xs</span>
<span class="k">val</span> <span class="n">zs</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>хвости списків <code>ys</code> та <code>zs</code> поділяються; вони вказують на ту саму структуру даних. Це основа для ефективності; якщо список <code>xs</code> копіювався б кожного разу, коли ви додаєте новий елемент до нього, це було б значно повільніше. Оскільки спільне використання є поширеним, зміна елементів списку, якщо б це було можливо, було б досить небезпечним. Наприклад, беручи код вище, якщо ви бажали б вкоротити список <code>ys</code> до двох перших елементів, і записали б це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ys</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">tail</span> <span class="k">=</span> <span class="nc">Nil</span> <span class="c1">// цього не можна робити в Scala!</span>
</pre></div></div></div>
<div class="paragraph"><p>ви б також вкоротили списки <code>zs</code> та <code>xs</code> в якості побічного ефекту.</p></div>
<div class="paragraph"><p>Зрозуміло, що було б досить складно відстежити, що було змінено. Ось чому Scala обирає поширене поділення даних, та заборону на зміну списків. Клас <code>ListBuffer</code> все ще дозволяє вам будувати списки імперативно та інкрементально, якщо побажаєте. Але оскільки спискові буфери не є списками, типи, що містять змінні буфери та незмінні списки, тримаються окремо.</p></div>
<div class="paragraph"><p>Дизайн Scala <code>List</code> та <code>ListBuffer</code> досить подібні до того, що зроблене в Java з парою класів, <code>String</code> та <code>StringBuffer</code>. Це не випадковість. В обох ситуаціях розробники бажали підтримувати чисті незмінні структури даних, але також провадити ефективний спосіб сконструювати ці структури інкрементально. Для Java і Scala рядків, <code>StringBuffer</code> (або в Java 5 <code>StringBuilder</code>) провадять шлях конструювання рядка інкрементально. Для списків Scala ви маєте вибір: ви можете або конструювати списки інкрементально, через додавання елементів до початку списку з використанням <code>::</code>, або ви використовуєте списковий буфер для додавання елементів в кінець. Який має перевагу залежить від ситуації. Звичайно, <code>::</code> гарно проявляє себе в рекурсивних алгоритмах, в стилі поділяй-та-володій. Спискові буфери часто використовуються в більш традиційному стилі на основі циклів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_22_5_">22.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили, як в Scala реалізовані списки. <code>List</code> є однією з найбільш тяжко використовуваних структур в Scala, і він має доопрацьовану реалізацію. Два субкласи <code>List</code>, <code>Nil</code> та <code>::</code>, обоє є кейс класами. Однак замість рекурсії по цій структурі, багато основних методів реалізовані з використанням <code>ListBuffer</code>. <code>ListBuffer</code>, в свою чергу, ретельно реалізований, так, щоб він міг ефективно будувати списки без розміщення додаткової пам'яті. Він зовні функціональний, але внутрішньо використовує змінність для прискорення загального випадку, коли буфер відкидаєть після виклику <code>toList</code>. Після вивчення всього цього, тепер ви знаєте класи списків ззовні та зсередини, і також ви вивчили один або два трюки реалізації.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__23">Глава 23</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____code_for_code">Ще раз про вирази <code>for</code></h1>
<div class="paragraph"><p>Глава 16 продемонструвала, що функції вищих порядків, такі як <code>map</code>, <code>flatMap</code>, та <code>filter</code>, провадять потужні конструкції для роботи зі списками. Але іноді рівень абстракції, що потребують ці функції, робить програми трохи складними для розуміння.</p></div>
<div class="paragraph"><p>Ось приклад. Скажімо, ви отримали список людей, кожний визначений як примірник класу  <code>Person</code>. Клас <code>Person</code> має поля, де вказані ім'я, стать, та перелік дітей.</p></div>
<div class="paragraph"><p>Ось визначення класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                         <span class="n">isMale</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
                         <span class="n">children</span><span class="k">:</span> <span class="kt">Person*</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад декількох записів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lara</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Lara&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bob</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
<span class="k">val</span> <span class="n">julie</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Julie&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">)</span>
<span class="k">val</span> <span class="n">persons</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">,</span> <span class="n">julie</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, скажімо, ми бажаємо знайти всі пари імен матерів та їх дітей в цьому списку. Використовуючи <code>map</code>, <code>flatMap</code> та <code>filter</code> ви можете зформулювати наступний запит:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">filter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
            <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трохи оптимізувати цей приклад, використавши виклик <code>withFilter</code> замість <code>filter</code>. Це дозволить уникнути створення проміжної структури даних для жінок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці запити роблять свою роботу, але вони не дуже тривіальні для написання та розуміння. Чи є простіший спосіб? Фактично, так. Згадайте вирази <code>for</code> в Розділі 7.3? Використовуючи вирази <code>for</code>, той самий приклад може бути записаний наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">;</span> <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="n">children</span><span class="o">)</span>
      <span class="k">yield</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Результат цього виразу точно такий самий, що і результат попереднього виразу. Більше того, більшість читачів коду вірогідно знайде, що вирази <code>for</code> значно ясніші, ніж попередні запити, що використовують функції вищих порядків, <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>.</p></div>
<div class="paragraph"><p>Однак, останні два запити не настільки різноманітні, як може виглядати. Фактично, з'ясовується, що компілятор Scala буде транслювати другий запит в перший. Більш загально, всі вирази <code>for</code>, що видають результат, транслюються компілятором в комбінації викликів методів вищого порядку, <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Всі <code>for</code> цикли без <code>yield</code> транслюються в меньший набір функцій вищого порядку: тільки <code>withFilter</code> та <code>foreach</code>.</p></div>
<div class="paragraph"><p>В цій главі ви з'ясуєте для початку щодо точних правил написання виразів. Після цього ви побачите, як вони можуть зробити комбінаторні проблеми простішими для вирішення. Нарешті, ви вивчите, як транслюються <code>for</code> вирази, і як результат, <code>for</code> вирази можуть допомогти вам "виростити" мову Scala в нових доменах застосування.</p></div>
<div class="sect1">
<h2 id="_23_1__code_for_code">23.1 Вирази <code>for</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Загалом, <code>for</code> вираз має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span> <span class="n">seq</span> <span class="o">)</span> <span class="k">yield</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>seq</code> є послідовність генераторів, визначень та фільтрів, розділені крапкою з комою між послідовними елементами. Приклад для <code>for</code> виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">))</span>
<span class="k">yield</span> <span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей <code>for</code> вираз містить один генератор, одне визначення та один фільтр. Як зазначалось в Розділі 7.3, ви також можете оточити послідовність в фігурні дужки замість звичайних. Тоді крапки з комою стають опціональними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">{</span>
  <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span>           <span class="c1">// генератор</span>
  <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>             <span class="c1">// визначення</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">)</span> <span class="c1">// фільтр</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p>Генератор має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>expr</code> типово повертає список, навіть якщо, як ви побачите пізніше, це може бути узагальнено. Шаблон <code>pat</code> співпадає один-до-одного з усіма елементами цього списку. Якщо співпадіння успішне, змінні в шаблоні прив'язуються до відповідних частин елементу, в той самий спосіб, як описане в Главі 15. Але якщо співпадіння схибить, виключення <code>MatchError</code> не виникне. Замість цього елемент просто відкидається з ітерації.</p></div>
<div class="paragraph"><p>В самому загальному випадку шаблон <code>pat</code> є тільки змінна <code>x</code>, як в <code>x &lt;- expr</code>. В цьому випадку змінна <code>x</code> просто ітерує по всіх елементах, що повертає <code>expr</code>.</p></div>
<div class="paragraph"><p>Визначення має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="k">=</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення прив'язує шаблон <code>pat</code> до значення <code>expr</code>, так що це має той самий ефект, що і визначення <code>val</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний випадок знову коли шаблон є простою змінною <code>x</code> (тобто, <code>x = expr</code>). Це визначає <code>x</code> як ім'я для значення <code>expr</code>.</p></div>
<div class="paragraph"><p>Фільтр має таку форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>expr</code> є вираз типу <code>Boolean</code>. Фільтр відкидає з ітерації всі елементи, для яких <code>expr</code> повертає <code>false</code>.</p></div>
<div class="paragraph"><p>Кожний <code>for</code> вираз починається з генератора. Якщо є декілька генераторів в виразі <code>for</code>, пізніші генератори змінюються більш швидко, ніж ранішні. Ви можете просто це перевірити за допомогою наступного простого тесту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
        <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span><span class="n">one</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">two</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">one</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">two</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_2__n_">23.2 Проблема N ферзів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Особливо придатною областю застосування <code>for</code> виразів є комбінаторні головоломки. Прикладом такої головоломки є проблема 8-ми ферзів: маючи стандартну шахову дошку, розмістити вісім ферзів, так, щоб жодний не шахував іншого (ферзь шахує іншу фігуру, якщо стоїть на тому самому рядку, лінії або диагоналі). Щоб знайти рішення цієї проблеми, насправді легше узагальнити її для шахових дошок довільного розміру. Таким чином, проблема є розмістити N ферзів на шахівниці з <code>N x N</code> клітин, де розмір <code>N</code> довільний. Ми почнемо нумерування клітин з одного, так що верхня-ліва клітина на дошці <code>N x N</code> має координати <code>(1, 1)</code>, та нижня-права клітина має координати <code>(N, N)</code>.</p></div>
<div class="paragraph"><p>Щоб вирішити проблему <code>N</code> ферзів, зауважте, що вам треба розмістити ферзя на кожному рядку. Так що ви можете ставити ферзів в послідовних рядках, кожний раз перевіряючи, що новий розміщений ферзь не шахується жодним іншим ферзем, що вже на дошці. По ходу цього пошуку, може статись, що ферзь, який треба поставити на рядок <code>k</code>, шахується у всіх полях цього рядка з ферзями на рядках від <code>1</code> до <code>k-1</code>. В цьому випадку вам треба перервати цю частину пошуку, щоб продовжити з іншою конфігурацією ферзів в стовпчиках від <code>1</code> до <code>k-1</code>.</p></div>
<div class="paragraph"><p>Імперативне рішення цієї проблеми буде ставити ферзів один по одному, рухаючи їх по дошці. Але це виглядає складним запропонувати схему, що насправді спробує всі можливості. Більш функціональний підхід представляє рішення напряму, як значення. Рішення складається зі списку координат, по одній для кожного ферзя на дошці. Однак занотуйте, що повне рішення не може бути знайдене за один крок. Рішення має бути побудоване поступово, через захоплення послідовних рядків ферзями.</p></div>
<div class="paragraph"><p>Це підказує рекурсивний алгоритм. Уявімо, що ви вже згенерували всі рішення, розмістивши  <code>k</code> ферзів на дошці розміром <code>N x N</code>, до <code>k</code> меньше ніж <code>N</code>. Кожне таке рішення може бути презентовано як список довжиною <code>k</code> координат <code>(row, column)</code>, де обидва, <code>row</code> та <code>column</code> є числами в диапазоні від <code>1</code> до <code>N</code>. Зручно розглядати ці часткові списки рішень як стеки, де координати ферзя на рядку <code>k</code> ідуть першими в списку, за яким ідуть координати ферзя в рядку <code>k-1</code>, і так далі. Знизу стека є координати ферзя, розміщеного на першому рядку дошки. Всі рішення разом представлені як список списків, з одним елементом для кожного ферзя.</p></div>
<div class="paragraph"><p>Тепер, щоб поставити наступного ферзя в рядок <code>k+1</code>, згенеруйте всі можливі розширення кожного попереднього рішення ще на одного ферзя. Це дає інший список рішень, на цей раз довжини <code>k+1</code>. Продовжуйте процес доки ви не отримаєте всі рішення розміру шахівниці N.</p></div>
<div class="paragraph"><p>Ця алгоритмична ідея втілена в функціональне <code>placeQueens</code> нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">queens</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
    <span class="k">else</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">queens</span> <span class="k">&lt;-</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
        <span class="n">column</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
        <span class="n">queen</span> <span class="k">=</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
        <span class="k">if</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">queens</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">queen</span> <span class="o">::</span> <span class="n">queens</span>

  <span class="n">placeQueens</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зовнішня функція <code>queens</code> в програмі вище просто викликає <code>placeQueens</code> з розміром дошки <code>n</code> в якості аргумента. Завдання функції <code>placeQueens(k)</code> є генерація всіх часткових рішень довжини <code>k</code> в списку. Кожний елемент списку є одним рішенням, представлений списком довжини <code>k</code>. Так що <code>placeQueens</code> повертає список списків.</p></div>
<div class="paragraph"><p>Якщо параметр <code>k</code> до <code>placeQueens</code> є <code>0</code>, це означає, що треба згенерувати всі рішення, розмістивши нуль ферзів на нулі рядків. Існує тільки одне таке рішення: не розташовувати ферзів взагалі. Це рішення представлене порожнім списком. Так що якщо <code>k</code> є нуль,<code>placeQueens</code> повертає <code>List(List())</code>, список складається з єдиного елемента, що є порожнім списком. Зауважте, що це доволі відрізняється від порожнього списку <code>List()</code>.</p></div>
<div class="paragraph"><p>Якщо <code>placeQueens</code> повертає <code>List()</code>, це означає відсутність рішень, замість єдиного рішення, що складається з відсутності розміщених ферзів.</p></div>
<div class="paragraph"><p>В іншому випадку, коли <code>k</code> не нуль, вся робота <code>placeQueens</code> виконується в <code>for</code> виразі. Перший генератор цього <code>for</code> виразу ітерує по всіх рішеннях, розміщуючи <code>k - 1</code> ферзів на дошці. Другий генератор ітерує по всіх можливих стовпчиках, на яких може бути розміщений  <code>k</code>-тий ферзь. Третя частина <code>for</code> виразу визначає новітньо розглянуту позицію ферзя, що буде парою з рядка <code>k</code> та кожного стовпчика. Четверта частина виразу <code>for</code> є фільтром, що перевіряє за допомогою <code>isSafe</code>, чи новий ферзь є вільний від шаху всіма існуючими ферзями (визначення <code>isSafe</code> буде розглянута трохи пізніше).</p></div>
<div class="paragraph"><p>Якщо новий ферзь не має шахів від жодного з інших ферзів,
він може формувати частину часткового рішення, так що <code>placeQueens</code> генерує нове рішення за допомогою <code>queen :: queens</code>. Якщо новий ферзь не вільний від шаху, фільтр повертає <code>false</code>, так що рішення не генерується.</p></div>
<div class="paragraph"><p>Один фрагмент, що залишився, це метод <code>isSafe</code>, що використовується для перевірки, чи даний ферзь шахується любим іншим елементом в списку ферзів. Ось його визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=</span>
  <span class="n">queens</span> <span class="n">forall</span> <span class="o">(</span><span class="n">q</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">inCheck</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">q</span><span class="o">))</span>

<span class="k">def</span> <span class="n">inCheck</span><span class="o">(</span><span class="n">q1</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">q2</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span> <span class="o">||</span> <span class="c1">// той самий рядок</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span> <span class="o">||</span> <span class="c1">// той самий стовпчик</span>
  <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span><span class="o">).</span><span class="n">abs</span> <span class="o">==</span> <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">abs</span> <span class="c1">// на диагоналі</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>isSafe</code> виражає, що ферзь безпечний у відношенні до інших ферзів, якщо він не шахується іншим ферзем. Метод <code>inCheck</code> виражає, що ферзі <code>q1</code> та <code>q2</code> взаємно шахуються. Він повертає <code>true</code> в одному з трьох випадків:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Якщо два ферзя мають ту саму координату рядка,
</p>
</li>
<li>
<p>
Якщо два ферзя мають ту саму координату стовбчика,
</p>
</li>
<li>
<p>
Якщо два ферзя на тій самій диагоналі (тобто, різниця між рядками і різниця між стовпчиками ті самі).
</p>
</li>
</ol></div>
<div class="paragraph"><p>Перший випадок, коли два ферзя мають ту саму координату, не може трапитись в застосуванні, бо <code>placeQueens</code> вже потурбувався про розіщення кожного ферзя на окремому рядку. Так що ви можете видалити цю перевірку без зміни функціональності програми.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_3____code_for_code_">23.3 Запити за допомогою <code>for</code> виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нотація <code>for</code> в основному еквівалентна до загальних операцій мови запитів бази даних. Наприклад, скажімо, ви отримали базу даних на ім'я <code>books</code>, що представлена як спикок нижок, де кожна книжка <code>Book</code> визначена наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось малий приклад бази даних, представленої як список в пам'яті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Structure and Interpretation of Computer Programs&quot;</span><span class="o">,</span>
      <span class="s">&quot;Abelson, Harold&quot;</span><span class="o">,</span> <span class="s">&quot;Sussman, Gerald J.&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Principles of Compiler Design&quot;</span><span class="o">,</span>
      <span class="s">&quot;Aho, Alfred&quot;</span><span class="o">,</span> <span class="s">&quot;Ullman, Jeffrey&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Programming in Modula-2&quot;</span><span class="o">,</span>
      <span class="s">&quot;Wirth, Niklaus&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Elements of ML Programming&quot;</span><span class="o">,</span>
      <span class="s">&quot;Ullman, Jeffrey&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;The Java Language Specification&quot;</span><span class="o">,</span> <span class="s">&quot;Gosling, James&quot;</span><span class="o">,</span>
      <span class="s">&quot;Joy, Bill&quot;</span><span class="o">,</span> <span class="s">&quot;Steele, Guy&quot;</span><span class="o">,</span> <span class="s">&quot;Bracha, Gilad&quot;</span>
    <span class="o">)</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб знайти назви всіх книжок, в яких останнє ім'я автора починається з <code>"Gosling"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">b</span><span class="o">.</span><span class="n">authors</span>
            <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">&quot;Gosling&quot;</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">The</span> <span class="nc">Java</span> <span class="nc">Language</span> <span class="nc">Specification</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або щоб знайти назви всіх книжок, що мають рядок <code>"Program"</code> в своїй назаві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">title</span> <span class="n">indexOf</span> <span class="s">&quot;Program&quot;</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Structure</span> <span class="n">and</span> <span class="nc">Interpretation</span> <span class="n">of</span>
  <span class="nc">Computer</span> <span class="nc">Programs</span><span class="o">,</span> <span class="nc">Programming</span> <span class="n">in</span> <span class="nc">Modula</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Elements</span> <span class="n">of</span> <span class="nc">ML</span>
    <span class="nc">Programming</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або щоб знайти в базі даних імена всіх авторів, що написали щонайменьше дві книжки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
           <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">a1</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">,</span> <span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Останнє рішення все ще недосконале, оскільки автори будуть з'являтись декілька разів в списку результатів. Вам все ще треба видалити дублікати авторів з отриманих списків. Це можливо досягти з наступною функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">removeDuplicates</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">xs</span>
         <span class="k">else</span>
           <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
             <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="n">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
           <span class="o">)</span>
       <span class="o">}</span>
<span class="n">removeDuplicates</span><span class="k">:</span> <span class="err">[</span><span class="kt">A</span><span class="err">]</span><span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">res6</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Варто відзначити, що останній вираз в методі <code>removeDuplicates</code> може бути виражений еквівалентно з використанням виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span>
<span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_4__code_for_code_">23.4 Трансляція <code>for</code> виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кожний <code>for</code> вираз може бути виражений в термінах трьох функцій вищого порядку: <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Цей розділ описує схему трансляції, що також використовується компілятором Scala.</p></div>
<div class="sect2">
<h3 id="__code_for_code____">Трансляція <code>for</code> виразів з одним генератором</h3>
<div class="paragraph"><p>Перше, уявімо ви маєте простий вираз <code>for</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>де <code>x</code> є змінною. Такий вираз транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_______">Трансляція <code>for</code> виразів, що починаються з генератора та фільтра</h3>
<div class="paragraph"><p>Тепер розглянемо <code>for</code> вираз, що комбінує лідируючий генератор з деякими іншими елементами.</p></div>
<div class="paragraph"><p>Вираз <code>for</code> наступної форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">))</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця трансляція дає наступний вираз <code>for</code>, що на один елемент коротший, ніж оригінал, бо елемент <code>if</code> трансформується в застосування <code>withFilter</code> на першому виразі генератора. Трансформація потім продовжується з цім другим виразом, так що в кінці ми отримаємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Така сама схема трансляції також застосовується, якщо після фільтра ідуть інші елементи. Якщо <code>seq</code> є довільною послідовністю генераторів, визначень та фільтрів, тоді:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="n">withFilter</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім трансляція продовжується з другим виразом, що знову коротший на один елемент, ніж оригінальний.</p></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_____">Трансляція <code>for</code> виразів починаючи з двох генераторів</h3>
<div class="paragraph"><p>Наступний випадок обробляє <code>for</code> вирази, що починаються з двох генераторів, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову, будемо вважати, що <code>seq</code> є довільною послідовністю генераторів, визначень та фільтрів. Фактично, <code>seq</code> може також бути порожнім, і в такому випадку після <code>expr_2</code> крапка з комою непотрібні. Схема трансляції залишається такою самою в кожному випадку. Вираз <code>for</code> вище транслюється до застосування <code>flatMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>На цей раз існує інший вираз <code>for</code> в функціональному значенні, переданого до <code>flatMap</code>. Цей вираз <code>for</code> (що знову на елемент простіший, ніж оригінал) в свою чергу транслюється за тими самими правилами. Три схеми трансляції, надані перед цім, достатні для транслювання всіх виразів, що містять тільки генератори та фільтри, та де генератори прив'язують тільки прості змінні. Візьмемо, наприклад, запит: "Знайти всіх авторів, що опубліковали щонайменьше дві книги", з Розділу 23.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
  <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">a1</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей запит транслюється до наступної комбінації <code>map</code>/<code>flatMap</code>/<code>filter</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">books</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b1</span> <span class="k">=&gt;</span>
  <span class="n">books</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">authors</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">a1</span> <span class="k">=&gt;</span>
      <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span>
        <span class="n">a1</span><span class="o">))))</span>
</pre></div></div></div>
<div class="paragraph"><p>Представлена дотепер схама трансляції ще не обробляє генератори, які прикріплюють цілі шаблони, замість простих змінних. Вона також досі не покриває визначення. Ці два аспекта будуть пояснені в наступних двох підсекціях.</p></div>
</div>
<div class="sect2">
<h3 id="_____17">Трансляція шаблонів в генераторах</h3>
<div class="paragraph"><p>Схема трансляції стає більш складна, якщо ліва сторона генератора є шаблоном <code>pat</code>, іншим, ніж проста змінна. Випадок, коли вираз <code>for</code> зв'язує тапл змінних, є все ще простим для обробки. В цьому випадку діє майже та сама схема, що застосовується для окремих змінних.</p></div>
<div class="paragraph"><p><code>for</code> вираз такої форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">((</span><span class="kc">null</span><span class="o">,</span> <span class="o">...,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="o">...,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">expr_2</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це стає трохи складнішим, якщо ліва сторона генератора є довільним шаблоном <code>pat</code>, замість окремої змінної або тапла.</p></div>
<div class="paragraph"><p>В цьому випадку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span> <span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">expr_2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто згенеровані елементи зпочатку фільтруються, і тільки ті, що співпадають з <code>pat</code>, відзеркалюються. Таким чином гарантовано, що генератор зі співпадінням шаблонів, ніколи не закидатиме <code>MatchError</code>.</p></div>
<div class="paragraph"><p>Тут схема трактує тільки випадок, коли вираз <code>for</code> містить один генератор співпадіння шаблону. Аналогічні правила також застосовуються, якщо вираз <code>for</code> містить інші герератори, фільтри та визначення. Оскільки ці додаткові правила не додають багато нового розуміння, вони виключені тут з дискусії. Якщо ви зацікавлені, ви можете пошукати їх в <em>Scala Language Specification</em> [Ode11].</p></div>
</div>
<div class="sect2">
<h3 id="___43">Трансляція визначень</h3>
<div class="paragraph"><p>Остання відсутня ситуація, це коли <code>for</code> вираз містить вбудовані визначення. Ось типовий випадок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="kc">null</span> <span class="k">=</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову вважатимемо, що <code>seq</code> є (можливо порожньою) послідовністю генераторів, визначень та фільтрів. Цей вираз транслюється до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">((</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">expr_2</span><span class="o">);</span> <span class="n">seq</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите, це <code>expr_2</code> обчислюється кожного разу, коли генерується нове значення <code>x</code>. Це пере-обчислення потрібне, оскільки <code>expr_2</code> може посилатись на <code>x</code>, так що має пере-обчислюватись для зміни значень <code>x</code>. Для вас, як для програміста, висносок в тому, що це, можливо, не є гарною ідеєю мати вбудовані визначення в <code>for</code> виразах, що не посилються на значення, прив'язані деяким попереднім генератором, оскільки пере-обчислення таких виразів буде марним. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>звичайно краще записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_">Транслювання <code>for</code> циклів</h3>
<div class="paragraph"><p>Попередні субсекції показали, як транслюються <code>for</code> вирази, що містять <code>yield</code>. Як щодо циклів, що просто виконують побічні ефекти без повернення будь-чого? Їх трансляція подібна, але простіша ніж для <code>for</code> виразів. В принципі, коли попередня схема трансляції вкористовували <code>map</code> або <code>flatMap</code> в трансляції, схема трансляції для <code>for</code> циклів використовує тільки <code>foreach</code>.</p></div>
<div class="paragraph"><p>Наприклад, вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшим прикладом є вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">;</span> <span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_3</span><span class="o">)</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span>
<span class="n">expr_3</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, наступний вираз підсумовує всі елементи матриці, що представлена як список списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">xs</span> <span class="k">&lt;-</span> <span class="n">xss</span><span class="o">;</span> <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей цикл танслюється в два вкладених застосувань <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">xss</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">xs</span> <span class="k">=&gt;</span>
    <span class="n">xs</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_23_5____">23.5 Заходячи з іншого боку</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній розділ показав, що вирази <code>for</code> можуть бути трансльовані в застосування функцій вищого порядку: <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Фактично, однаково ви можете іти іншим шляхом: кожне застосування <code>map</code>, <code>flatMap</code>, або <code>filter</code> може бути представлене як <code>for</code> вираз.</p></div>
<div class="paragraph"><p>Ось реалізації трьох методів в термінах <code>for</code> виразів. Методи, що містяться в об'єкті <code>Demo</code> для відмінносі їх від стандартних операцій з <code>List</code>. Щоб бути конкретним, всі три функції приймають <code>List</code> як параметр, але схема трансляції робить так само гарно і з іншими типами колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="k">yield</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>

  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="k">if</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Не дивно, що трансляція <code>for</code> виразу, використана в тілі <code>Demo.map</code>, буде продукувати виклик до <code>map</code> в класі <code>List</code>. Подібним чином, <code>Demo.flatMap</code> та <code>Demo.filter</code> транслюються до <code>flatMap</code> та <code>withFilter</code> в класі <code>List</code>. Так що ця мала демонстрація показує, що <code>for</code> вирази еквівалентні по своїй виразності до застосування трьох функцій: <code>map</code>, <code>flatMap</code>, <code>withFilter</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_6__code_for_code">23.6 Узагальнюючи <code>for</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки трансляція <code>for</code> виразів покладається тільки на присутність методів <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>, можливо застосувати <code>for</code> нотацію до широкого класу типів даних.</p></div>
<div class="paragraph"><p>Ви вже бачили <code>for</code> вирази на списках та масивах. Вони підтримуються, тому що списки, так само, як масиви, визначають операції <code>map</code>, <code>flatMap</code> та <code>withFilter</code>. Оскільки вони визначають також метод <code>foreach</code>, також можливі цикли <code>for</code> по ціх типах даних.</p></div>
<div class="paragraph"><p>Окрім списків та масивів, існує багато інших типів в стандартній бібліотеці Scala, які підтримують ті самі чотири методи, і, таким чином, дозволяють <code>for</code> вирази. Прикладами є диапазони, ітератори, потокі, і всі реалізації множин. Також чудово можливо для ваших власних типів даних підтримувати <code>for</code> вирази, через визначення потрібних методів. Для підтримки повного диапазону <code>for</code> виразів та <code>for</code> циклів, вам треба визначити <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, та <code>foreach</code> як методи вашого типу даних. Але також можливо визначити підмножину ціх методів, і таким чином підтримати підмножину всіх можливих <code>for</code> виразів або циклів.</p></div>
<div class="paragraph"><p>Ось точні правила:
* Якщо ваш тип визначає <code>map</code>, він дозволяє <code>for</code> виразам складатись з одного генератора.
* Якщо він визначає <code>flatMap</code> разом з <code>map</code>, це дозволяє <code>for</code> виразам складатись з декількох генераторів.
* Якщо він визначає <code>foreach</code>, він дозволяє цикли <code>for</code> (обоє, з одним та декількома генераторами).
* Якщо він визначає <code>withFilter</code>, він дозволяє вирази фільтрів, що починаються з <code>if</code> в <code>for</code> виразах.</p></div>
<div class="paragraph"><p>Трансляція <code>for</code> виразів відбувається перед перевіркою типів. Це дозволяє максимальну гнучкість, оскільки єдиною вимогою є те, щоб результат розширення <code>for</code> виразу проходив перевірку типів. Scala не визначає правил типів для самих <code>for</code> виразів, та не потребує, щоб методи <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, або <code>foreach</code> мали любу окрему сигнатуру типів.</p></div>
<div class="paragraph"><p>Тим не менше, існує типове налаштування, що захоплює найбільш загальні наміри методів вищого порядку, до яких тринслюється <code>for</code> вираз. Скажімо, ви маєте параметризований клас <code>C</code>, що типово буде стояти за деяким типом колекції. Тоді досить природно обрати наступні сигнатури типу для <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, та <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, функція <code>map</code> приймає функцію від типу елементу колекції <code>A</code> до якось іншого типу <code>B</code>. Він продукує нову колекцію того ж типу, що і <code>C</code>, але з <code>B</code> в якості типу елементів. Метод <code>flatMap</code> приймає функцію <code>f</code> від <code>A</code> до деякої <code>C</code>-колекції з <code>B</code>, та продукує <code>C</code>-колекцію з <code>B</code>. Метод <code>withFilter</code> приймає функцію предикат від типу елементів колекції <code>A</code> до <code>Boolean</code>. Він продукує колекцію того самого типу, на якому він викликаний. Нарешті, метод <code>foreach</code> приймає функцію від <code>A</code> до <code>Unit</code>, та продукує результат <code>Unit</code>:</p></div>
<div class="paragraph"><p>В класі <code>C</code> вище, метод <code>withFilter</code> продукує нову колекцію того самого класу. Це означає, що кожний виклик <code>withFilter</code> створює новий об'єкт <code>C</code>, так само, як має робити фільтр. Тепер, в трансляції <code>for</code> виразів, любі виклики до <code>withFilter</code> завжди закінчаться викликом до одного з трьох інших методів. Таким чином, об'єкт, створений <code>withFilter</code> буде розібраний по частинах одним з інших методів безпосередньо після цього. Якщо об'єкти класу <code>C</code> великі (подумайте про великі послідовності), ви можете побажати уникнути створення такого проміжного об'єкту. Стандартним прийомом є дозволити <code>withFilter</code> повертати на об'єкт <code>C</code>, але тільки об'єкт огортку, що "пам'ятає", що елементи треба відсортувати перед подальшою обробкою.</p></div>
<div class="paragraph"><p>Концентруючись на трьох перших функціях класу <code>C</code> слід зауважити наступні факти. В функціональному програмуванні існує загальна концепція з назвою <em>монада</em>, що може пояснювати велике число типів з обчисленнями, від колекцій до обчислень зі станом та I/O, обчислення зворотнього виводу та транзакції, як для прикладу. Ви можете формулювати функції <code>map</code>, <code>flatMap</code>, та <code>withFilter</code> на монаді, та, якщо ви зробите це, вони в підсумку матимуть точно вказані тут типи.</p></div>
<div class="paragraph"><p>Більше того, ви можете характеризувати кожну монаду через <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>, плюс "юніт" конструктор, що продукує монаду зі значення елемента. В об'єктно-орієнтовній мові цей "юніт" є простим конструктором примірника, або методом фабрики. Таким чином на <code>map</code>, <code>flatMap</code>, та <code>withFilter</code> можна дивитись як на об'єктно-орієнтовну версію функціональної концепції монади. Оскільки <code>for</code> вирази еквівалентні до застосувань ціх трьох методів, вони можуть розглядатись як синтаксис для монад.</p></div>
<div class="paragraph"><p>Все це натякає, що концепція <code>for</code> виразів більш загальна, ніж проста ітерація по колекції, і це дійсно так. Наприклад, <code>for</code> вирази також відіграють важливу роль в асинхронному I/O, або як альтернативна нотація для опціональних значень. Шукайте в бібліотеках Scala де зустрічаються <code>map</code>, <code>flatMap</code>, та <code>withFilter</code> — коли вони присутні, <code>for</code> вирази запропонують себе самі, як стислий спосіб маніпуляції елементами цього типу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_7_">23.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви отримали можливість заглянути з лаштунки виразів <code>for</code> та циклів <code>for</code>. Ви вивчили, що вони транслюються в застосування стандартного набору методів вищого порядку. Як результат, ви побачили, що <code>for</code> вирази насправді значно більш загальні, ніж прості ітерації по колекціях, і що ви можете розробляти ваші власні класи для їх підтримки.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__24">Глава 24</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___44">Колекції: докладно</h1>
<div class="paragraph"><p>Scala включає елегантну та потужну бібліотеку колекцій. Навіть якщо вважати, що API колекцій тонкий на перший погляд, зміни, які він може спровокувати в вашому стилі програмування можуть бути грунтовними. Досить часто це так, якби ви робили на вищому рівні з базовими будівельними блоками програми, що є цілими колекціями, ніж їх елементами. Цей новий стиль програмування потребує деякої адаптації. Нащастя, адаптації допомагють декілька милих властивостей Scala колекцій. Вони прості в використанні, стислі, безпечні, швидкі та універсальні.</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Простота в використанні:</strong> Невеликого словника з двадцяти до сорока методів, досить для вирішення більшості проблем колекцій в парі операцій. Намає потреби огортати вашу голову кругом складних циклічних структур або рекурсій. Стійкі колекції вільні від операцій з побічними ефектами, що означає, що вам не треба хвилюватись про випадкове руйнування існуючих колекцій новими даними. Взаємодію між ітераторами та оновленнями колекцій ліквідовано.
</p>
</li>
<li>
<p>
<strong>Стислість:</strong> Ви можете досягти за допомогою одного слова те, що раніше займало один або декілька циклів. Ви можете виразити функціональні операції за допомогою легковажного синтаксису та без зусиль комбінувати операції так що результат відчувається як власна алгебра.
</p>
</li>
<li>
<p>
<strong>Безпечність:</strong> Щоб зрозуміти це, треба мати досвід. Статична типізація та функціональна природа Scala колекцій означає, що переважна більшість помилок, які ви можете зробити, відловлюються під час компіляції. Причини цього в тому, що (1) операції колекцій самі часто використовуються, і таким чином, гарно протестовані. (2) використання операцій з колекціями робить входи та виходи явними, як параметри функції та результати. (3) Ці явні входи та виходи є предметом перевірки статичних типів. Підсумок всього цього в тому, що велика більшість хибних використань будуть заявляти про себе як помилки типів. Взагалі не є рідкістю мати програми з декількох сотень рядків, що роблять з першої спроби.
</p>
</li>
<li>
<p>
<strong>Швидкість:</strong> Операції з колекціями настроєні і оптимізовані в бібліотеках. Як результат, використання колекцій типово досить ефективне. Ви можете бути в змозі зробити все трохи краще, через уважно налаштовані структури даних та операції, але ви також можете зробити все значно гірше, по ходу справи прийнявши якісь неоптимальні рішення з реалізації. Більше того, колекції були адаптовані до паралельної виконання на декількох ядрах. Паралельні колекції підтримують ті самі операції, що і послідовні так що не треба вивчати нові операції та переписувати код. Ви можете перетворити послідовну колекцію в паралельну, просто викликавши метод <code>par</code>.
</p>
</li>
<li>
<p>
<strong>Універсальність:</strong> Колекції провадять ті самі операції на любому типі, коли це має сенс робити. Так що ви можете багато чого досягти з досить малим словником операцій. Наприклад, рядок концептуально є послідовністю символів. Відповідно, в Scala колекціях рядок підтримує всі операції послідовностей. Те саме дійсне і для масивів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ця глава поглиблено описує API для класів колекцій Scala з перспективи користувача. Ви вже бачили швидкий тур по бібліотеці колекцій в Главі 17. Ця глава запрошує вас в більш детальний тур, показуючи всі класи колекцій, і всі методи, що вони визначають так що вона включає все, що вам треба знати для використання Scala колекцій. Дивлячись наперед, Глава 25 буде сконцентрована на архитектурі та аспектах розширюваності бібліотеки, для людей, що реалізують нови типи колекцій.</p></div>
<div class="sect1">
<h2 id="_24_1____">24.1 Змінні та незмінні колекції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви вже знаєте, Scala колекції систематично відрізняють змінні та незмінні колекції. Змінні колекції можуть бути оновлені або розширені на місці. Це означає, що ви можете змінювати, додавати, або видаляти елементи колекції як побічний ефект. Незмінні колекції, для контрасту, ніколи не змінюються. Ви все ще маєте операції, що симулюють додавання, видалення або оновлення, але ці операції будуть в любому випадку повертати нову колекцію та залишати стару колекцію незмінною.</p></div>
<div class="paragraph"><p>Всі класи колекцій знаходяться в пакунку <code>scala.collection</code>, або одному з його субпакунків: <code>mutable</code>, <code>immutable</code> та <code>generic</code>. Більшість класів колекцій, що потрібні клієнтському коду, існують в трьох варіантах, кожний з яких має різні характеристики з точки зору змінності. Три варіанти розміщені в пакунках <code>scala.collection</code>, <code>scala.collection.immutable</code> та <code>scala.collection.mutable</code>.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection.immutable</code> гарантовано буде незмінною для будь-кого. Така колекція ніколи не буде змінюватись після її створення. Таким чином, ви можете покладатись на факт, що отримуєте доступ до значення тієї самої колекції постійно, і в різних точках часу будете завжди мати колекцію з тими самими елементами.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection.mutable</code> знана що має деякі операції, що змінюють колекцію на місці. Ці операції дозволяють вам писати код для зміни колекції самотужки. Однак ви маєте бути уважним, щоб розуміти та захищатись від любих оновлень, що виконують інші частини кодової бази.</p></div>
<div class="paragraph"><p>Колекція в пакунку <code>scala.collection</code> може бути або змінною, або незмінною. Наприклад,<code>scala.collection.IndexedSeq[T]</code> є супертрейтом обох, <code>scala.collection.immutable.IndexedSeq[T]</code> та її родички, <code>scala.collection.mutable.IndexedSeq[T]</code>. Загалом, кореневі колекції в пакунку <code>scala.collection</code> визначають той самий інтерфейс, що і незмінні колекції. І типово, змінні колекції в пакунку <code>scala.collection.mutable</code> додають деякі модифікації з побічним ефектом до цього незмінного інтерфейсу.</p></div>
<div class="paragraph"><p>Різниця між кореневими колекціями та незмінними колекціями в тому, що клієнти назмінних колекцій мають гарантію, що ніхто не може змінити колекцію, коли як клієнти кореневих колекцій знають тільки, що вони самі не можуть змінити колекцію. Навіть зважаючи, що статичний тип такої колекції не провадить операцій для модифікації колекції, все ще може бути можливим, щоб тип часу виконання був змінною колекцією, що може бути змінена іншими клієнтами.</p></div>
<div class="paragraph"><p>По замовчанню Scala завжди обирає незмінні колекції. Наприклад, якщо ви просто пишете <code>Set</code> без жодного префіксу, або без імпорту будь-чого, ви отримаєте незмінну множину, і якщо ви напишете <code>Iterable</code>, ви отримаєте незмінне ітерабельне, оскільки ці прив'язки по замовчанню імпортуються з пакунка <code>scala</code>. Щоб отримати змінні версії по замовчанню, вам треба написати явно <code>collection.mutable.Set</code>, або <code>collection.mutable.Iterable</code>.</p></div>
<div class="paragraph"><p>Останній пакунок в ієрархії колекцій є <code>collection.generic</code>. Цей пакунок містить будівельні блоки для реалізації колекцій. Типово, класи колекцій відкладають реалізації деяких зі своїх операцій до класів в <code>generic</code>. З іншого боку, щоденні користувачі фреймворку колекцій мають потребу посилатись на класи в <code>generic</code> тільки за виключних обставин.</p></div>
<div class="sect2">
<h3 id="___45">Ієрархія колекцій.</h3>
<div class="listingblock">
<div class="content">
<pre><code>Traversable
    Iterable
        Seq
            IndexedSeq
                Vector
                ResizableArray
                GenericArray
            LinearSeq
                MutableList
                List
                Stream
            Buffer
                ListBuffer
                ArrayBuffer
        Set
            SortedSet
                TreeSet
            HashSet (mutable)
            LinkedHashSet
            HashSet (immutable)
            BitSet
            EmptySet, Set1, Set2, Set3, Set4
        Map
            SortedMap
                TreeMap
            HashMap (mutable)
            LinkedHashMap (mutable)
            HashMap (immutable)
            EmptyMap, Map1, Map2, Map3, Map4</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_2__">24.2 Узгодженість колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Найбільш важливі класи колекцій показані на Малюнку 24.1. Є досить загального, що поділяють ці класи. Наприклад, кожний різновид колекції може бути створений за однаковим уніформним синтаксисом, записуючи ім'я класу колекції, за яким ідуть його елементи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">Iterable</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">,</span> <span class="s">&quot;y&quot;</span><span class="o">,</span> <span class="s">&quot;z&quot;</span><span class="o">)</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">,</span> <span class="s">&quot;z&quot;</span> <span class="o">-&gt;</span> <span class="mi">26</span><span class="o">)</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Green</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>
<span class="nc">SortedSet</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">)</span>
<span class="nc">Buffer</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
<span class="nc">IndexedSeq</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="nc">LinearSeq</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Той самий принцип також стосується специфічних реалізацій колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">HashMap</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">,</span> <span class="s">&quot;z&quot;</span> <span class="o">-&gt;</span> <span class="mi">26</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>toString</code> для всіх колекцій продукує вивід, записаний як вище, з іменем типу, за яким в дужках ідуть елементи колекції. Всі колекції підтримують API, що провадить <code>Traversable</code>, але їх методи всі повертають їх власний клас, скоріше ніж кореневий клас  <code>Traversable</code>. Наприклад, метод <code>map</code> на <code>List</code> має тип повернення <code>List</code>, тоді як метод <code>map</code> на <code>Set</code> має тип повернення <code>Set</code>. Таким чином, статичний тип повернення ціх методів досить точний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Еквівалентність також організована одноманітно для всіх класів колекцій; більше про це в Розділі 24.13.</p></div>
<div class="paragraph"><p>Більшість класів на Малюнку 24.1 існують в трьох варіантах: <code>root</code>, <code>mutable</code> та <code>immutable</code>. Одне виключення є трейт <code>Buffer</code>, що існує тільки як змінна колекція.</p></div>
<div class="paragraph"><p>В залишку цієї глави ми будемо переглядати ці класи один за одним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_3__code_traversable_code">24.3 Трейт <code>Traversable</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>На вершині ієрархії колекцій стоїть трейт <code>Traversable</code> (<em>прохідний</em>). Його єдина операція є <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Класам колекцій, що реалізують <code>Traversable</code>, просто потрібно визначити цей метод; всі інші методи можуть бути наслідувані від <code>Traversable</code>.</p></div>
<div class="paragraph"><p>Метод <code>foreach</code> призначений для обходу всіх елементів колекції та застосування наданої операції <code>f</code> до кожного елементу. Тип операції <code>Elem =&gt; U</code>, де <code>Elem</code> є типом елементів колекції та <code>U</code> є довільним типом результату. Виклик <code>f</code> робиться тільки заради побічного ефекту; фактично, любий результат функції <code>f</code> буде відкинутий <code>foreach</code>.</p></div>
<div class="paragraph"><p><code>Traversable</code> також визначає багато суцільних методів, всі вони перелічені в Таблиці 24.1. Ці методи підпадають в такі категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Додавання</strong> <code>++</code>, що додає два прохідних разом, або додає всі елементи ітератора до прохідного.
</p>
</li>
<li>
<p>
<strong>Операції відображення</strong> <code>map</code>, <code>flatMap</code> та <code>collect</code>, що продукують нову колекцію через застосування деякої функції до елементів колекції.
</p>
</li>
<li>
<p>
<strong>Перетворення</strong> <code>toIndexedSeq</code>, <code>toIterable</code>, <code>toStream</code>, <code>toArray</code>, <code>toList</code>, <code>toSeq</code>, <code>toSet</code> та <code>toMap</code>, що повертають колекцію <code>Traversable</code> в більш специфічну колекцію. Всі ці перетворення повертають об'єкт отримувача, якщо він вже відповідає бажаному типу колекції. Наприклад, застосування <code>toList</code> до списку буде повертати сам список.
</p>
</li>
<li>
<p>
<strong>Операції копіювання</strong> <code>copyToBuffer</code> та <code>copyToArray</code>. Як кажуть їх імена, вони копіюють елементи колекції до буфера або масива, відповідно.
</p>
</li>
<li>
<p>
<strong>Операції розміру</strong> <code>isEmpty</code>, <code>nonEmpty</code>, <code>size</code> та <code>hasDefiniteSize</code>. Колекції, що є прохідними, можуть бути скінченими та нескінченими. Прикладом нескінченої прохідної колекції є потік натуральних чисел <code>Stream.from(0)</code>. Метод <code>hasDefiniteSize</code> вказує, що колекція, можливо, нескінчена. Якщо він повертає <code>false</code>, колекція може бути нескінченою, і в цьому випадку <code>size</code> буде видавати помилку або не повернеться.
</p>
</li>
<li>
<p>
<strong>Операції отримання елемента</strong> <code>head</code>, <code>last</code>, <code>headOption</code>, <code>lastOption</code> та <code>find</code>. Вони обирають перший або останній елемент колекції, або інакше перший елемент, що задовільняє умові. Однак зазначте, що не всі колекції мають гарно визначення значення того, що значить "перший" та "останній". Наприклад, хеш множина може зберігати елементи відповідно до їх хеш ключів, що можуть змінюватись від запуску до запуску. В цьому випадку "перший" елемент хеш набору також може бути різним для разних запусків програм. Колекція є впорядкована, якщо вона завжди видає свої елементи в тому самому порядку. Більшість колекцій впорядковані, але деякі (такі як хеш множини) ні — відкидання впорядкованості дає трохи додаткової ефективності. Порядок часто є основою для отримання повторюваних тестів та допомагає в зневадженні. Ось чому колекції Scala провадять впорядковані альтернативи для всіх типів колекцій. Наприклад, впорядкована альтернатива для <code>HashSet</code> є <code>LinkedHashSet</code>.
</p>
</li>
<li>
<p>
<strong>Операції отримання субколекцій</strong> <code>takeWhile</code>, <code>tail</code>, <code>init</code>, <code>slice</code>, <code>take</code>, <code>drop</code>, <code>filter</code>, <code>dropWhile</code>, <code>filterNot</code>, <code>withFilter</code>. Всі вони повертають деяку субколекцію, що ідентифікується диапазоном індексів або предикатом.
</p>
</li>
<li>
<p>
<strong>Операції підрозділу</strong> <code>splitAt</code>, <code>span</code>, <code>partition</code> та <code>groupBy</code> підрозділяють елементи колекції на декілька субколекцій.
</p>
</li>
<li>
<p>
<strong>Перевірка елементів</strong> <code>exists</code>, <code>forall</code> та <code>count</code> перевіряють елементи колекції за допомогою наданого предикату.
</p>
</li>
<li>
<p>
<strong>Згортки</strong> <code>foldLeft</code>, <code>foldRight</code>, <code>/:</code>, <code>:\</code>, <code>reduceLeft</code>, <code>reduceRight</code> застосовують двомісні операції до послідовних елементів.
</p>
</li>
<li>
<p>
<strong>Особливі згортки</strong> <code>sum</code>, <code>product</code>, <code>min</code>, <code>max</code> роблять з колекціями специфічних типів (числові або порівнювані).
</p>
</li>
<li>
<p>
<strong>Рядкові операції</strong> <code>mkString</code>, <code>addString</code>, <code>stringPrefix</code> провадять альтернативні шляхи перетворення колекції на рядок.
</p>
</li>
<li>
<p>
<strong>Операції переглядів</strong> складаються з двох перевантажених варіантів метода <code>view</code>. Перегляд є колекція, що обчислюється ліниво. Ви пізнаєте більше про перегляди в Розділі 24.14.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Абстрактний метод:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs foreach</p></td>
<td align="left" valign="top"><p class="table">Виконує функцію <code>f</code> для кожного елементу <code>xs</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Додавання:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++ ys</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з елементів обох, <code>xs</code> та <code>ys</code>.  <code>ys</code> є колекцією <code>TraversableOnce</code>, тобто або <code>Traversable</code>, або <code>Iterator</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Мапи:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs map</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування функції <code>f</code> до кожного елемента в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs flatMap</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування функції <code>f</code> від значень-колекції до кожного елементу в <code>xs</code> та конкатенації результатів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs collect</p></td>
<td align="left" valign="top"><p class="table">Колекція, отримана від застосування часткової функції <code>f</code> до кожного елементу в <code>xs</code>, для яких вона визначена та накопичення результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Перетворення:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toArray</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в масив.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toList</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в список.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toIterable</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в Iterable.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toSeq</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toIndexedSeq</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в індексовану послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toStream</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в потік (ліниво обчислювана послідовність).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toSet</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію в множину.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.toMap</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію пар ключ/значення в мапу.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Копіювання:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs copyToBuffer buf</p></td>
<td align="left" valign="top"><p class="table">Копіює всі елементи колекції в буфер <code>buf</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs copyToArray(arr, s, len)</p></td>
<td align="left" valign="top"><p class="table">Копіює щонайбільше <code>len</code> елементів <code>arr</code>, починаючи з індексу <code>s</code>. Два останні аргументи опціональні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Інформація про розмір:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.isEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція порожня.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.nonEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція містить елементи.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.size</p></td>
<td align="left" valign="top"><p class="table">Число елементів в колекції.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.hasDefiniteSize</p></td>
<td align="left" valign="top"><p class="table">True, якщо відомо, що xs має фіксований розмір.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Отримання елементів:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.head</p></td>
<td align="left" valign="top"><p class="table">Перший елемент колекції (або деякий елемент, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.headOption</p></td>
<td align="left" valign="top"><p class="table">Перший елемент <code>xs</code> в опціональному значенні, або <code>None</code>, якщо <code>xs</code> порожнє.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.last</p></td>
<td align="left" valign="top"><p class="table">Останній елемент колекції (або деякий елемент, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.lastOption</p></td>
<td align="left" valign="top"><p class="table">Останній елемент <code>xs</code> в опціональному значенні, або <code>None</code>, якщо <code>xs</code> порожнє.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs find</p></td>
<td align="left" valign="top"><p class="table">Опція, яка містить перший елемент в <code>xs</code>, що задовільняє <code>p</code>, або <code>None</code>, якщо жодний елемент не підійде.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Субколекції:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.tail</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs.head</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.init</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs.last</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs slice (from, to)</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з елементів <code>xs</code> в деякому диапазоні індексів (від <code>from</code> до <code>to</code>, виключно).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs take</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з перших <code>n</code> елементів <code>xs</code> (або деякі довільні <code>n</code> елементів, якщо порядок не визначений).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs drop</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs take n</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs takeWhile</p></td>
<td align="left" valign="top"><p class="table">Найдовший префікс елементів в колекції, що задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs dropWhile</p></td>
<td align="left" valign="top"><p class="table">Колекція без найдовшого префіксу елементів, всі з яких задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs filter</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з тих елементів <code>xs</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs withFilter</p></td>
<td align="left" valign="top"><p class="table">Не-строгий фільтр для цієї колекції. Всі операції на отриманому фільтрі будуть застосовані тільки для тих елементів <code>xs</code>, для яких мова <code>p</code> є <code>true</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs filterNot</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з тих елементів <code>xs</code>, що не задовільняють предикатові <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Суброзподіл:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs splitAt</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> в позициї <code>n</code>, даючи пару колекцій (<code>xs take n</code>, <code>xs drop n</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs span</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> відповідно до предикату, даючи пару колекцій (<code>xs takeWhile p</code>, <code>xs.dropWhile p</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs partition</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> на пару колекцій; одна з елементами, що задовільняють предикату <code>p</code>, інша з елементами, що ні, даючи пару колекцій(<code>xs filter p</code>, <code>xs.filterNot p</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs groupBy</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>xs</code> на мапу колекцій, відповідно до функції дескреминатору <code>f</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Умови до елементів:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs forall</p></td>
<td align="left" valign="top"><p class="table">Логічне, що визначає, чи предикат <code>p</code> дотримується до всіх елементів <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs exists</p></td>
<td align="left" valign="top"><p class="table">Логічне, що вказує, чи предикат <code>p</code> дотримується до деякого елемента в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs count</p></td>
<td align="left" valign="top"><p class="table">Число елементів в <code>xs</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Згортки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(z /: xs)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами <code>xs</code>, ідучи зліва направо, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(xs :\ z)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами <code>xs</code>, ідучи зправа наліво, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.foldLeft(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>(z /: xs)(op)</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.foldRight(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>(xs :\ z)(op)</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reduceLeft op</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами непорожньої колекції <code>xs</code>, ідучи зліва направо.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reduceRight op</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами непорожньої колекції <code>xs</code>, ідучи зправа наліво.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Особливі згортки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.sum</p></td>
<td align="left" valign="top"><p class="table">Сума числових значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.product</p></td>
<td align="left" valign="top"><p class="table">Добуток числових значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.min</p></td>
<td align="left" valign="top"><p class="table">Мінімум впорядкованих значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.max</p></td>
<td align="left" valign="top"><p class="table">Максімум впорядкованих значень елементів колекції <code>xs</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Рядки:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs addString (b, start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Додає рядок до <code>StringBuilder</code> <code>b</code>, що показує всі елементи <code>xs</code>, розділені роздільниками <code>sep</code> та оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs mkString (start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Конвертує колекцію на рядок, що показує всі елементи <code>xs</code> між роздільниками <code>sep</code> та оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.stringPrefix</p></td>
<td align="left" valign="top"><p class="table">The collection name at the beginning of the string returned from xs.toString.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Перегляди:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.view</p></td>
<td align="left" valign="top"><p class="table">Продукує перегляд xs.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs view (from, to)</p></td>
<td align="left" valign="top"><p class="table">Продукує перегляд, що представляє елементи в деякому диапазоні індексів <code>xs</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<h1 id="_24_4__iterable">24.4 Трейт Iterable</h1>
<div class="paragraph"><p>Наступний трейт зверху на Малюнку 24.1 є <code>Iterable</code>. Всі методи в цьому трейті визначені в термінах абстрактного метода <code>iterator</code>, що видає елементи колекції один за одним. Абстрактний метод <code>foreach</code>, наслідуваний від трейту <code>Traversable</code>, реалізований в <code>Iterable</code> в термінах <code>iterator</code>. Ось справжня реалізація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="n">f</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лише кілька субкласів <code>Iterable</code> перекривають цю стандартну реалізацію <code>foreach</code> в <code>Iterable</code>, оскільки вони можуть провадити більш ефективну реалізацію. Пам'ятайте, що <code>foreach</code> є основою для реалізації всіх операцій в <code>Traversable</code> так що продуктивність важлива.</p></div>
<div class="paragraph"><p>Ще два метода існують в <code>Iterable</code>, що повертають ітератори: <code>grouped</code> та <code>sliding</code>. Однак ці ітератори не повертають поодинокі елементи, але цілі субпослідовності елементів оригінальної колекції. Максимальний розмір ціх послідовностей надається як аргумент до ціх методів. Метод <code>grouped</code> розбиває свої елементи на інкрементальні пакунки, тоді як <code>sliding</code> дає ковзаюче вікно по елементах. Різниця між двома стане яснішою при погляді на наступні взаємодії в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">git</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">grouped</span> <span class="mi">3</span>
<span class="n">git</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sit</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">sliding</span> <span class="mi">3</span>
<span class="n">sit</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Трейт <code>Iterable</code> також додає деякі інші методи до <code>Traversable</code>, що можуть бути ефективно реалізовані тільки за наявності ітератора. Вони підсумовані в Таблиці 24.2:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Абстрактний метод:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">iterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожний елемент в <code>xs</code>, в тому самому порядку, як <code>foreach</code> проходить по елементах</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Інші ітератори:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs grouped size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає "частки" колекції фіксованого розміру</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sliding size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає ковзне вікно фіксованого розміру з елементів колекції</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Субколекції:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs takeRight</p></td>
<td align="left" valign="top"><p class="table">Колекція, що складається з останніх <code>n</code> елементів <code>xs</code> (або довільні <code>n</code> елементів, якщо порядок не визначений)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs dropRight</p></td>
<td align="left" valign="top"><p class="table">Залишок колекції, за винятком <code>xs takeRight n</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Поєднувачі:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs zip ys</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар відповідних елементів з <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs zipAll (ys, x, y)</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар відповідних елементів з <code>xs</code> та <code>ys</code>, де коротша послідовність розширюється, щоб співпадати до довшої, через додавання елементів <code>x</code> або <code>y</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.zipWithIndex</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне з пар елементів <code>xs</code> разом з їх індексами</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table"><strong>Порівняння:</strong></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sameElements ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> та <code>ys</code> містять ті самі елементи в тому ж порядку</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="____code_traversable_code__code_iterable_code">Чому мати обоє, <code>Traversable</code> та <code>Iterable</code>?</h3>
<div class="paragraph"><p>Ви можете здивуватись, для чого додатковий трейт <code>Traversable</code> над <code>Iterable</code>. Чи не могли б зробити все з ітератором? То яка ідея мати більш абстрактний трейт, що визначає свої методи в термінах <code>foreach</code> замість <code>iterator</code>? Одна причина мати <code>Traversable</code> в тому, що іноді простіше або більш ефективно провадити реалізацію для <code>foreach</code>, ніж провадити реалізацію ітератора. Ось простий приклад. Скажімо, ви бажаєте ієрархію класів для бінарних дерев, що мають цілі елементи на листках. Ви можете розробиби цю ієрархію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер вважатимемо, ви бажаєте зробити дерева перехідними. Щоб зробити це, треба щоб <code>Tree</code> наслідував від <code>Traversable[Int]</code> та визначав метод <code>foreach</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">;</span> <span class="n">r</span> <span class="n">foreach</span> <span class="n">f</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не дуже складно, і це також дуже ефективно — перехід по збалансованому дереву пропорційно до числа елементів в дереві. Щоб побачити це, уявімо, що збалансоване дерево з <code>N</code> листками буде мати <code>N - 1</code> внутрішніх листків класу <code>Branch</code>. Так що загальна кількість кроків для обходу дерева є <code>N + N - 1</code>.</p></div>
<div class="paragraph"><p>Тепер порівняйте це з робленням дерев ітерабельними. Щоб зробити це, робимо <code>Tree</code> походячим від <code>Iterable[Int]</code> та визначаємо метод <code>iterator</code> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">.</span><span class="n">single</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">iterator</span> <span class="o">++</span> <span class="n">r</span><span class="o">.</span><span class="n">iterator</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>На перший погляд це виглядає не складніше, ніж рішення <code>foreach</code>. Однак є проблема ефективності, що стосується реалізації метода конкатенації ітератора, <code>++</code>. Кожного разу,коли продукується елемент конкатенованим ітератором, як в <code>l.iterator ++ r.iterator</code>, обчислення потребує слідувати одному непрямому переходу, щоб отримати вірний ітератор (<code>l.iterator</code> або <code>r.iterator</code>). Загалом це робить <code>log(N)</code> перенаправлень, щоб отримати листок збалансованого дерева з <code>N</code> leaves. Так що ціна відвідування всіх елементів дерева становить від близько <code>2N</code> для метода обходу <code>foreach</code>, до <code>Nlog(N)</code> для проходу за допомогою ітератору. Якщо дерево має мільйон елементів, це означає близько двох мільйонів кроків для <code>foreach</code>, і біля двадцяти (?) мільйонів кроків для <code>iterator</code>. Так що рішення <code>foreach</code> має явну перевагу.</p></div>
</div>
<div class="sect2">
<h3 id="__iterable">Субкатегорії Iterable</h3>
<div class="paragraph"><p>В ієрархії наслідування нижче <code>Iterable</code> ви знайдете три трейти: <code>Seq</code>, <code>Set</code> та <code>Map</code>. Загальний аспект ціх трьох трейтів в тому, що всі вони реалізують трейт <code>PartialFunction</code>,<span class="footnote"><br />[Часткові функції були описані в Розділі 15.7.]<br /></span> з його методами <code>apply</code> та <code>isDefinedAt</code>. Однак спосіб, в який кожний трейт реалізує <code>PartialFunction</code>, відрізняється.</p></div>
<div class="paragraph"><p>Для послідовностей <code>apply</code> є позиційне індексування, де елементи завжди пронумеровані від <code>0</code>. Тобто, <code>Seq(1, 2, 3)(1) == 2</code>. Для множин <code>apply</code> є перевіркою належності. Наприклад, <code>Set('a', 'b', 'c') ('b') == true</code>, тоді як <code>Set()('a') == false</code>. Нарешті, для мап <code>apply</code> є вибір. Наприклад, <code>Map('a' - &gt; 1, 'b' -&gt; 10, 'c' -&gt; 100)('b') == 10</code>.</p></div>
<div class="paragraph"><p>В наступних трьох розділах ми пояснимо кожний з трьох типів колекцій більш детально.</p></div>
</div>
<div class="sect1">
<h2 id="_24_5___code_seq_code_code_indexedseq_code_code_linearseq_code">24.5 Трейти послідовностей <code>Seq</code>, <code>IndexedSeq</code>, <code>LinearSeq</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Трейт <code>Seq</code> представляє послідовності. Послідовність різновид ітерабельного, що має довжину та чиї елементи мають фіксовані індексовані позиції, починаючи від 0. Операції над послідовностями, підсумовані на Малюнку 24.3, підпадають в наступні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Операції індексування та довжини</strong> <code>apply</code>, <code>isDefinedAt</code>, <code>length</code>, <code>indices</code> та <code>lengthCompare</code>. Для <code>Seq</code> операція <code>apply</code> означає індексування; таким чином послідовність типу <code>Seq[T]</code> є частковою функцією, що приймає аргумент <code>Int</code> (індекс) та видає елемент послідовності типу <code>T</code>. Іншими словами, <code>Seq[T]</code> розширює <code>PartialFunction[Int, T]</code>. Елементи послідовності індексовані від нуля до довжини послідовності мінус один. Метод <code>length</code> на послідовностях є псевдонимом метода <code>size</code> на загальних колекціях. Метод <code>lengthCompare</code> дозволяє вам порівнювати довжину двох послідовностей, навіть якщо одна з послідовностей має безкінечну довжину.
</p>
</li>
<li>
<p>
<strong>Операції пошуку індексу</strong> <code>indexOf</code>, <code>lastIndexOf</code>, <code>indexOfSlice</code>, <code>lastIndexOfSlice</code>,<code>indexWhere</code>, <code>lastIndexWhere</code>, <code>segmentLength</code> та <code>prefixLength</code> повертають індекс елементу, рівному до заданого значення або співпадаючий з деяким предикатом.
</p>
</li>
<li>
<p>
<strong>Операції додавання</strong> <code>+:</code>, <code>:+</code> та <code>padTo</code>, повертають нову послідовність, отриману від додавання елементів зпереду або з кінця послідовності.
</p>
</li>
<li>
<p>
<strong>Операції оновлення</strong> <code>updated</code> та <code>patch</code>, що повертають нову послідовність, отриману від заміни деяких елементів оригінальної послідовності.
</p>
</li>
<li>
<p>
<strong>Операції сортування</strong> <code>sorted</code>, <code>sortWith</code> та <code>sortBy</code> сортують елементи послідовності відповідно до різних критеріїв.
</p>
</li>
<li>
<p>
<strong>Операції обертання</strong> <code>reverse</code>, <code>reverseIterator</code> та <code>reverseMap</code> видають або обробляють елементи послідовності в зворотньому порядку, від останнього до першого.
</p>
</li>
<li>
<p>
<strong>Операції порівняння</strong> <code>startsWith</code>, <code>endsWith</code>, <code>contains</code>, <code>corresponds</code> та <code>containsSlice</code> співвідносить дві послідовності або шукає елемент в послідовності.
</p>
</li>
<li>
<p>
<strong>Множинні операції</strong> <code>intersect</code>, <code>diff</code>, <code>union</code> та <code>distinct</code> виконують множино-подібні операції на елементах двох послідовностей, або видаляють дублікати.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо послідовність змінна, вона пропонує додатковий метод з побічним ефектом <code>update</code>, що дозволяє оновлювати елементи. Згадайте з Глави 3, що синтаксис як <code>seq(idx) = elem</code> є просто скороченням для <code>seq.update(idx, elem)</code>. Зауважте різницю між <code>update</code> та <code>updated</code>. Метод <code>update</code> змінює елемент послідовності на місці та доступний тільки для змінних послідовностей. Метод <code>updated</code> доступний для всіх послідовностей та завжди повертає нову послідовність, замість модифікації оригіналу.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Індексування та довжина:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(i)</p></td>
<td align="left" valign="top"><p class="table">(або, розписано,<code>xs apply i</code>) Елемент <code>xs</code> за індексом <code>i</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs isDefinedAt</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>i</code> міститься в <code>xs.indices</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.length</p></td>
<td align="left" valign="top"><p class="table">Довжина послідовності (те саме, що і <code>size</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.lengthCompare ys</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>-1</code>, якщо <code>xs</code> коротше за <code>ys</code>, <code>+1</code> якщо довше та <code>0</code> якщо вони мають рівну довжину. Робить, навіть якщо послідовності безкінечні.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.indices</p></td>
<td align="left" valign="top"><p class="table">Диапазон індексів <code>xs</code>, що простягається від <code>0</code> до <code>xs.length - 1</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Індексний пошук:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу в <code>xs</code> рівному <code>x</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs lastIndexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс останнього елементу в <code>xs</code> рівному <code>x</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexOfSlice ys</p></td>
<td align="left" valign="top"><p class="table">Перший індекс <code>xs</code> такий, що наступні елементи починаючи з цього індексу формують послідовність <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs lastIndexOfSlice ys</p></td>
<td align="left" valign="top"><p class="table">Останній індекс <code>xs</code> такий, що наступні елементи починаючи з цього індексу формують послідовність <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs indexWhere</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу <code>xs</code>, задовільняє <code>p</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs segmentLength (p, i)</p></td>
<td align="left" valign="top"><p class="table">Довжина найдовшого неперериваного сегменту елементів <code>xs</code>, починаючи з <code>xs(i)</code>, всі з яких задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs prefixLength</p></td>
<td align="left" valign="top"><p class="table">Довжина найдовшого префіксу з елементів <code>xs</code>, всі з яких задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">x +: xs</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, що складається з <code>x</code> перед <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs :+</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, що складається з <code>x</code> після <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs padTo (len, x)</p></td>
<td align="left" valign="top"><p class="table">Послідовність, що утворюється як результат від додавання значення <code>x</code> до <code>xs</code>, доки не буде досяжена довжина <code>len</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs patch (i, ys, r)</p></td>
<td align="left" valign="top"><p class="table">Послідовність як результат від заміни <code>r</code> елементів <code>xs</code>, починаючи з <code>i</code> на латку <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs updated (i, x)</p></td>
<td align="left" valign="top"><p class="table">Копія <code>xs</code>, з елементом з індексом <code>i</code>, заміненим на <code>x</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(i) =</p></td>
<td align="left" valign="top"><p class="table">(або, розписане, <code>xs.update(i, x)</code>, доступне тільки для` mutable.Seq`). Зміна елементу <code>xs</code> по індексу <code>i</code> на <code>y</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Сортування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.sorted</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів  <code>xs</code> з використанням стандартного впорядкування типу елементів <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sortWith lessThan</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів <code>xs</code>, використовуючи <code>lessThan</code> як операції порівняння.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sortBy</p></td>
<td align="left" valign="top"><p class="table">Нова послідовність, отримана від сортування елементів <code>xs</code>. Порівняння між двома елементами обробляється через відображення двох елементів функцією <code>f</code> над обома та порівняння результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Обернення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.reverse</p></td>
<td align="left" valign="top"><p class="table">Послідовність з елементами <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.reverseIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає всі елементи <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs reverseMap</p></td>
<td align="left" valign="top"><p class="table">Послідовність, отримана від відображення <code>f</code> над елементами <code>xs</code> в зворотньому порядку.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Порівняння:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs startsWith ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> починається з послідовності <code>ys</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs endsWith ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> закінчується на <code>ys</code> (існують декілька варіантів).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> має елемент, що дорівнює <code>x</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs containsSlice ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> має послідовність, що дорівнює <code>ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(xs corresponds ys)(p)</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи відповідні елементи <code>xs</code> та <code>ys</code> задовільняють двомісному предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Множинні операції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs intersect ys</p></td>
<td align="left" valign="top"><p class="table">Множинний перетин послідовностей <code>xs</code> та <code>ys</code>, що зберігає порядок елементів в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs diff ys</p></td>
<td align="left" valign="top"><p class="table">Множинна різниця послідовностей <code>xs</code> та <code>ys</code>, що зберігає порядок елементів в <code>xs</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs union ys</p></td>
<td align="left" valign="top"><p class="table">Множинне об'єднання; те саме, що <code>xs ++ ys</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.distinct</p></td>
<td align="left" valign="top"><p class="table">Субпослідовність <code>xs</code>, що не містить дублікатів.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Кожний трейт <code>Seq</code> має два субтрейти, <code>LinearSeq</code> та <code>IndexedSeq</code>. Вони не додають жодних нових операцій, але кожний пропонує різні характеристики продуктивності. Лінійна послідовність має ефективні операції <code>head</code> та <code>tail</code>, тоді як індексована послідовність має ефективні операції <code>apply</code>, <code>length</code> та (якщо <code>mutable</code>) <code>update</code>. <code>List</code> є часто використовувана лінійна послідовність, як і <code>Stream</code>. Дві часто використовувані індексовані послідовності є <code>Array</code> та <code>ArrayBuffer</code>. Клас <code>Vector</code> провадить цікавий компроміс між індексованим та лінійним доступом. Він має однаково ефективний сталий час індексного навантаження та сталий час лінійного доступу. Завдяки цьому вектори є гарною основою для шаблонів змішаного доступу, коли одночасно використовується індексний та лінійний доступи. Більше про вектори в Розділі 24.8.</p></div>
<div class="sect2">
<h3 id="__25">Буфери</h3>
<div class="paragraph"><p>Важлива суб-категорія змінних послідовностей є буфери. Буфери дозволяють не тільки оновлення існуючих елементів, але також вставки елементів, видалення елементів та ефективне додавання нових елементів в кінець буфера. Принципово нові методи, що підтримуються буферами, є <code>+=</code> та <code>++=</code> для додавання елементів в кінець та <code>+=:</code> і <code>++=:</code> для додавання зпереду, <code>insert</code> та <code>insertAll</code> для вставок елементів так само як <code>remove</code> та <code>-=</code> для видалення елементів. Ці These operations are summarized in Table 24.4.</p></div>
<div class="paragraph"><p>Дві реалізації <code>Buffer</code> в загальному ужитку є <code>ListBuffer</code> та <code>ArrayBuffer</code>. Як підказує ім'я, <code>ListBuffer</code> підтримується <code>List</code> та підтримує ефективне перетворення його елементів <code>List</code>, тоді як  <code>ArrayBuffer</code> покладається на масив та може бути швидко перетворений на такий. Ви бачили проблиск реалізації <code>ListBuffer</code> в Розділі 22.2.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf +=</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до буфера <code>buf</code> та повертає самий <code>buf</code> як результат</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf += (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Додає надані елементи до буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf ++= xs</p></td>
<td align="left" valign="top"><p class="table">Додає всі елементи в <code>xs</code> до буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">x +=: buf</p></td>
<td align="left" valign="top"><p class="table">Ставить елемент <code>x</code> в початок буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++=: buf</p></td>
<td align="left" valign="top"><p class="table">Ставить всі елементи <code>xs</code> в початок буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf insert (i, x)</p></td>
<td align="left" valign="top"><p class="table">Вставляє елемент <code>x</code> по індексу <code>i</code> в буфер</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf insertAll (i, xs)</p></td>
<td align="left" valign="top"><p class="table">Вставляє всі елементи в <code>xs</code> по індексу <code>i</code> в буфер</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент <code>x</code> з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє елементпо індексу <code>i</code> з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf remove (i, n)</p></td>
<td align="left" valign="top"><p class="table">Видаляє <code>n</code> елементів, починаючи з індексу <code>i</code>, з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf trimStart</p></td>
<td align="left" valign="top"><p class="table">Видаляє перші <code>n</code> елементів з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf trimEnd</p></td>
<td align="left" valign="top"><p class="table">Видаляє останні <code>n</code> елементів з буфера</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи з буфера</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">buf.clone</p></td>
<td align="left" valign="top"><p class="table">Новий буфер з тими самим елементами, що і <code>buf</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_6_">24.6 Множини</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>Set</code> є <code>Iterable</code>, що не містить дублікатів елементів. Операції з множинами підсумовані в Таблиці 24.5 для <code>general</code> множин, і Таблиці 24.6 <code>mutable</code> множин. Вони підпадають під наступні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Перевірки</strong> <code>contains</code>, <code>apply</code> та <code>subsetOf</code>. Метод <code>contains</code> вказує, чи множина містить наданий елемент. Метод <code>apply</code> для множини те саме, що і <code>contains</code> так що <code>set(elem)</code> відповідає до  <code>set contains elem</code>. Це означає, що множини можуть також використовуватись як функції перевірки, що повертають <code>true</code> для елементів, які вони містять. Наприклад:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span><span class="o">,</span> <span class="s">&quot;peach&quot;</span><span class="o">,</span> <span class="s">&quot;banana&quot;</span><span class="o">)</span>
<span class="n">fruit</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="n">apple</span><span class="o">,</span> <span class="n">orange</span><span class="o">,</span> <span class="n">peach</span><span class="o">,</span> <span class="n">banana</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">(</span><span class="s">&quot;peach&quot;</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">(</span><span class="s">&quot;potato&quot;</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Додавання</strong> <code>+</code> and <code>++</code> додають до множини один або більше елементів, даючи нову множини в якості результату.
</p>
</li>
<li>
<p>
<strong>Видалення</strong> <code>-</code> та <code>--</code> видаляють один або більше з множини, даючи нову множину.
</p>
</li>
<li>
<p>
<strong>Операції множин</strong> для об'єднання, перетину та різниці. Ці операції існують в двох фломах: алгебраїчній та символічній. Алгебраїчні версії є <code>intersect</code>, <code>union</code> та <code>diff</code>, тоді як символічні версії <code>&amp;</code>, <code>|</code> та <code>&amp;~</code>. Метод <code>++</code>, який <code>Set</code> наслідує від <code>Traversable</code>, може розглядатись як ще один псевдоним для <code>union</code> або <code>|</code>, за винятком того, що <code>++</code> приймає аргумент <code>Traversable</code>, коли <code>union</code> та <code>|</code> приймають множини.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перевірки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>x</code> є елементом <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(x)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <code>xs contains x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs subsetOf ys</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>xs</code> є підмножиною <code>ys</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs +</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само як <code>x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs + (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само як надані додаткові елементи</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++ ys</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code> так само, як всі елементи <code>ys</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, за винятком <code>x</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs - (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, за винятком наданих елементів</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs&#8201;&#8212;&#8201;ys</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить всі елементи <code>xs</code>, крім елементів в <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.empty</p></td>
<td align="left" valign="top"><p class="table">Порожня множина такого ж класу, що і <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Бінарні операції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs &amp; ys</p></td>
<td align="left" valign="top"><p class="table">Перетин множин <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs intersect ys</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>xs &amp; ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs | ys</p></td>
<td align="left" valign="top"><p class="table">Поєднання множин <code>xs</code> та <code>ys</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs union ys</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і `xs</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ys`</p></td>
<td align="left" valign="top"><p class="table">xs &amp;~ ys</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Різниця множин <code>xs and ys</code></p></td>
<td align="left" valign="top"><p class="table">xs diff ys</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Змінні множини мають методи, що додають, видаляють або оновлюють елементи, що підсумовані в Таблиці 24.6:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить
2+"Додавання:</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">xs +=</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до множини <code>xs</code> як побічний ефект та повератє сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs += (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Додає надані елементи до множини як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs ++= ys</p></td>
<td align="left" valign="top"><p class="table">Додає всі елементи з <code>ys</code> до множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs add</p></td>
<td align="left" valign="top"><p class="table">Додає елемент <code>x</code> до <code>xs</code> та повертає <code>true</code>, якщо <code>x</code> досі не був членом множини, <code>false</code> якщо він був там</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент <code>x</code> з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs -= (x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Видаляє надані елементи з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs --= ys</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи в <code>ys</code> з множини <code>xs</code> як побічний ефект та повертає сам <code>xs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє <code>x</code> з <code>xs</code> та повертає <code>true</code>, якщо <code>x</code> до цього містився в множині, <code>false</code> якщо ні</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs retain</p></td>
<td align="left" valign="top"><p class="table">Залишає лише ті елементи в <code>xs</code>, що задовільняють предикату <code>p</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи з <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs(x) =</p></td>
<td align="left" valign="top"><p class="table">(або, розписано, <code>xs.update(x, b)</code>) Якщо логічний аргумент <code>b</code> є <code>true</code>, додає <code>x</code> до <code>xs</code>, інакше видаляє <code>x</code> з <code>xs</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs.clone</p></td>
<td align="left" valign="top"><p class="table">Нова змінна множина з тими ж елементами, що і <code>xs</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Так само, як незмінні множини, змінні множини пропонують операції  <code>+</code> та <code>++</code> для додавання елементів та <code>-</code> та <code>--</code> для видалення елементів. Але вони рідше використовуються для змінних множин, оскікльки це включає копіювання множини. Ак більш ефективна альтернатива, змінні множини пропонують методи оновлення <code>+=</code> та <code>- =</code>. Операція <code>s += elem</code> додає <code>elem</code> до множини <code>s</code> в якості побічного ефекту та повертає змінену множину як результат. Подібно до цього, <code>s -= elem</code> видаляє <code>elem</code> з множини та повертає змінену множину як результат. Окрім <code>+=</code> та <code>-=</code> також існують масові операції <code>++=</code> та <code>--=</code>, що додають або видаляють всі елементи перехідного або ітератора.</p></div>
<div class="paragraph"><p>Вибір імен методів, <code>+=</code> та <code>-=</code> означає, що дуже подібний код буде робити однаково, зі змінними та незмінними множинами. Зпочатку розглянемо наступний диалог в інтерпретаторі, що використовує незмінну множину <code>s</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">s</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span><span class="o">;</span> <span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі ми використали <code>+=</code> та <code>-=</code> на <code>var</code> типу <code>immutable.Set</code>. Як було пояснено на Кроці 10 в Главі 3, а твердження як <code>s += 4</code> є скороченням для <code>s = s + 4</code>. Так що це викликає метод додавання <code>+</code> на множині <code>s</code> та потім присвоює результат назад до змінної <code>s</code>. Розглянемо тепер аналогічну взаємодію зі змінним набором:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">+=</span> <span class="mi">4</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">-=</span> <span class="mi">2</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">s.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The end effect is very similar to the previous interaction; we start with a Set(1, 2, 3) and end up with a Set(1, 3, 4). However, even though the statements look the same as before, they do something different. The s += 4 statement now invokes the += method on the mutable set values, changing the set in place. Likewise, the s -= 2 statement now invokes the -= method on the same set.</p></div>
<div class="paragraph"><p>Comparing the two interactions shows an important principle. You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa. This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.</p></div>
<div class="paragraph"><p>Mutable sets also provide add and remove as variants of += and -=. The difference is that add andremove return a boolean result indicating whether the operation had an effect on the set.</p></div>
<div class="paragraph"><p>The current default implementation of a mutable set uses a hash table to store the set&#8217;s elements. The default implementation of an immutable set uses a representation that adapts to the number of elements of the set. An empty set is represented by just a singleton object. Sets of sizes up to four are represented by a single object that stores all elements as fields. Beyond that size, immutable sets are implemented as hash tries.<span class="footnote"><br />[Hash tries are described in Section 24.8.]<br /></span></p></div>
<div class="paragraph"><p>A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient than mutable sets. So if you expect the size of a set to be small, try to make it immutable.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_7_">24.7 Мапи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Maps are Iterables of pairs of keys and values (also named mappings or associations). As explained in Section 21.4, Scala&#8217;s Predef class offers an implicit conversion that lets you writekey &#8594; value as an alternate syntax for the pair (key, value). Therefore, Map("x" &#8594; 24, "y" &#8594; 25, "z" &#8594; 26) means exactly the same as Map"x", but reads better.</p></div>
<div class="paragraph"><p>The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets. Mutable maps additionally support the operations shown in Table 24.8. Map operations fall into the following categories:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Lookups</strong> apply, get, getOrElse, contains, and isDefinedAt. These operations turn maps into partial functions from keys to values. The fundamental lookup method for a map is:
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Value</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>The operation "m get key" tests whether the map contains an association for the given key. If so, it returns the associated value in a Some. If no key is defined in the map, get returns None. Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option. If the key is not defined in the map, an exception is raised.</p></div>
<div class="ulist"><ul>
<li>
<p>
Additions and updates <code>, +</code>, and updated, which let you add new bindings to a map or change existing bindings.
</p>
</li>
<li>
<p>
Removals - and --, which remove bindings from a map.
</p>
</li>
<li>
<p>
Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map&#8217;s keys and values separately in various forms.
</p>
</li>
<li>
<p>
Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Пошук:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms get</p></td>
<td align="left" valign="top"><p class="table">Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>, як опція, або <code>None</code>, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms(k)</p></td>
<td align="left" valign="top"><p class="table">(або, розписане, <code>ms apply k</code>) Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>, або закидає виключення, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms getOrElse (k, d)</p></td>
<td align="left" valign="top"><p class="table">Значення, асоційоване з ключем <code>k</code> в мапі <code>ms</code>,або значення по замовчанню <code>d</code>, якщо не знайдене</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms contains</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи <code>ms</code> містить відображення для ключа <code>k</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms isDefinedAt</p></td>
<td align="left" valign="top"><p class="table">Те саме, що і <code>contains</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання та оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms + (k &#8594; v)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code> так само, як і <code>gk -&gt; v</code> ключа <code>k</code> на значення <code>v</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms + (k &#8594; v, l &#8594; w)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code>, разом з наданими парами ключ/значення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms ++ kvs</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code> так само, як і пари ключ/значення з <code>kvs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms updated (k, v)</p></td>
<td align="left" valign="top"><p class="table">Таке саме, що і <code>ms + (k -&gt; v)</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення з <code>ms</code>, за винятком любих відображень для ключа <code>k</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms - (k, l, m)</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення <code>ms</code>, за винятком всіх відображень з наданими ключамі</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms&#8201;&#8212;&#8201;ks</p></td>
<td align="left" valign="top"><p class="table">Мапа, що містить всі відображення з <code>ms</code>, за винятком любих відображень з ключами в <code>ks</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Субколекції:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keys</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне, що містить любий ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keySet</p></td>
<td align="left" valign="top"><p class="table">Множина, що містить кожний ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.keysIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожний ключ в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.values</p></td>
<td align="left" valign="top"><p class="table">Ітерабельне, що містить кожне значення, асоційоване з ключем в <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.valuesIterator</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що видає кожне значення, асоційоване з ключем в <code>ms</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms filterKeys</p></td>
<td align="left" valign="top"><p class="table">Перегляд мапи, що містить тільки ті відображення, в яких ключ відповідає предикату <code>p</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms mapValues</p></td>
<td align="left" valign="top"><p class="table">Перегляд мапи, отриманий від застосування функції <code>f</code> до кожного значення, асоційованого з ключем в <code>ms</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання та оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms(k) =</p></td>
<td align="left" valign="top"><div class="verse">(або, розписано, <code>ms.update(k, v)</code>) Додає відображення ключа <code>k</code> на значення <code>v</code> до мапи <code>ms</code> як побічний ефект, переписуючи любі попередні відображення <code>k</code></div></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms += (k &#8594; v)</p></td>
<td align="left" valign="top"><p class="table">Додає відображення ключа <code>k</code> на значення <code>v</code> до мапи <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms += (k &#8594; v, l &#8594; w)</p></td>
<td align="left" valign="top"><p class="table">Додає надані відображення до <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms ++= kvs</p></td>
<td align="left" valign="top"><p class="table">Додає всі відображення в <code>kvs</code> до <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms put (k, v)</p></td>
<td align="left" valign="top"><p class="table">Додає відображення ключа <code>k</code> на значення <code>v</code> до <code>ms</code> та повертає любе значення, асоційоване до цього з <code>k</code>, як опцію</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms getOrElseUpdate (k, d)</p></td>
<td align="left" valign="top"><p class="table">Якщо ключ <code>k</code> визначений в мапі <code>ms</code>, повертає його асоційоване значення. Інакше оновлює <code>ms</code> відображенням <code>k -&gt; d</code> та повертає <code>d</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Видалення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -=</p></td>
<td align="left" valign="top"><p class="table">Видаляє відображення ключа <code>k</code> з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms -= (k, l, m)</p></td>
<td align="left" valign="top"><p class="table">Видаляє відображення наданних ключів з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms --= ks</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі ключі в <code>ks</code> з <code>ms</code> як побічний ефект та повертає сам <code>ms</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms remove</p></td>
<td align="left" valign="top"><p class="table">Видаляє любі відображення ключа <code>k</code> з <code>ms</code> та повертає любе значення, до цього асоційоване з <code>k</code>, як опцію</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms retain</p></td>
<td align="left" valign="top"><p class="table">Зберігає тільки ті відображення в <code>ms</code>, ключ яких задовільняє предикату <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.clear()</p></td>
<td align="left" valign="top"><p class="table">Видаляє всі відображення з <code>ms</code></p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення та клонування:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms transform</p></td>
<td align="left" valign="top"><p class="table">Перетворює всі асоційовані значення в мапі <code>ms</code> функцією <code>f</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ms.clone</p></td>
<td align="left" valign="top"><p class="table">Повертає нову змінну мапу з тими самими відображеннями, що і <code>ms</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Операції додавання та видалення для мап повторюють такі самі для множин. Як і для множин, змінні мапи також підтримують неруйнівні операції додавання <code>+</code>, <code>-</code> та <code>updated</code>, але вони використовуються менш часто, оскільки вони включають копіювання змінної мапи. Замість цього, змінна мапа <code>m</code> звичайно оновлюється "на місці", використовуючи два варіанти, <code>m(key) = value</code> або <code>m += (key -&gt; value)</code>. Також є варіант <code>m put (key, value)</code>, що повертає значення <code>Option</code>, що складається зі значення, до того асоційованого з ключем, або <code>None</code>, якщо ключ не існував в мапі до цього.</p></div>
<div class="paragraph"><p>Метод <code>getOrElseUpdate</code> корисний для доступу до мап, що діють як кеші. Скажімо, ви маєте коштовне обчислення, що перемикається викликом функції <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
        <span class="n">println</span><span class="o">(</span><span class="s">&quot;taking my time.&quot;</span><span class="o">);</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
        <span class="n">x</span><span class="o">.</span><span class="n">reverse</span> <span class="o">}</span>
<span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Далі уявімо, що <code>f</code> не має побічних ефектів так що повторний виклик з тими ж аргументами буде завжди давати той самий результат. В такому випадку ви можете зберігти час, зберігаючи попередньо обчислені прив'язки аргументів та результати <code>f</code> в мапі та обчислювати результат <code>f</code>, якщо результат від аргументів ще не знаходиться там. Ви можете сказати, що мапа є кешем для обчислення функції <code>f</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">cache</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви можете створити більш ефективну кешовану версію фукнції <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="n">cachedF</span><span class="k">:</span> <span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cachedF</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">taking</span> <span class="n">my</span> <span class="n">time</span><span class="o">.</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cba</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cachedF</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cba</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що другий аргумент <code>getOrElseUpdate</code> є "за ім'ям" так що обчислення <code>f("abc")</code> вище виконується тільки якщо <code>getOrElseUpdate</code> потрубує значення свого другого аргументу, що саме коли перший аргумент не знайдений в кеш мапі. Ви також можете реалізувати <code>cachedF</code> напряму, використовуючи базові операції з мапами, але щоб зробити це знадобиться більше кода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span> <span class="n">get</span> <span class="n">arg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
    <span class="n">cache</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="k">=</span> <span class="n">result</span>
    <span class="n">result</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_8____">24.8 Суцільні класи незмінних колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить багато класів суцільних незмінних колекцій, з яких ви можете вибрати. Вони відрізняються в трейтах, які вони реалізують (мапи, множини, послідовності), чи можуть вони бути нескінченими та швидкістю різних операцій. Ми почнемо з огляду найбільш загальних типів незмінних колекцій.</p></div>
<div class="sect2">
<h3 id="__26">Списки</h3>
<div class="paragraph"><p>Списки є скінчені незмінні послідовності. Вони провадять доступ за сталий час до свого першого елементу так само, як і до залишку списку та вони мають операцію сталого часу <code>cons</code> для додавання нового елемента напочатку списку. Багато інших операцій займають лінійний час. Дівіться Глави 16 та 22 для розширеної дискусії щодо списків.</p></div>
</div>
<div class="sect2">
<h3 id="__27">Потоки</h3>
<div class="paragraph"><p>Потік подібний до списків, за тим винятком, що його елементи обчислюються ліниво. Через це потік може бути безкінечно довгий. Тільки елементи, що запитані, будуть обчислені. В іншому потоки мають ті самі характеристики продуктивності, що і списки.</p></div>
<div class="paragraph"><p>В той час, як списки будуються за допомогою оператора <code>::</code>, потоки будуються за допомогою подібно виглядаючого <code>#::</code>. Ось простий приклад потоку, що містить цілі <code>1</code>, <code>2</code> та <code>3</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mi">2</span> <span class="o">#::</span> <span class="mi">3</span> <span class="o">#::</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">empty</span>
<span class="n">str</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">?)</span>
</pre></div></div></div>
<div class="paragraph"><p>Голова цього потоку є <code>1</code> та хвіст має <code>2</code> та <code>3</code>. Однак хвіст тут не друкується, оскільки він все ще не обчислений! Потоки мають обчислюватись ліниво та метод <code>toString</code> для потоку досить уважний, щоб не змушувати до додаткового обчислення.</p></div>
<div class="paragraph"><p>Нижче більш складний приклад. Він обчислює потік, що містить послідовність Фібоначчі, починаючи з наданих двох чисел. Послідовність Фібоначчі - це коли кожний елемент є сумою двох попередніх в послідовності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">a</span> <span class="o">#::</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
<span class="n">fibFrom</span><span class="k">:</span> <span class="o">(</span><span class="kt">a:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">b:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція оманливо проста. Перший елемент послідовності, вочевидь, <code>a</code> та залишок послідовності є послідовність Фібоначчі, починаючи з <code>b</code>, за яким іде <code>a + b</code>. Хитра частина є обчислення цієї послідовності без нескінченої рекурсії. Якщо функція використовує <code>::</code> замість <code>#::</code>, тоді кожний виклик до функції буде спричиняти інший виклик таким чином спричиняючи нескінчену рекурсію. Однак оскільки вона використовує <code>#::</code>, права частина не обчислюється, доки вона не стане потрібною.</p></div>
<div class="paragraph"><p>Ось декілька перших елементів послідовності Фібоначчі, починаючи з двох елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fibs</span> <span class="k">=</span> <span class="n">fibFrom</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">fibs</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fibs</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">13</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__28">Вектори</h3>
<div class="paragraph"><p>Списки дуже ефективні, коли алгоритм обробляє їх дбайливо, обробляючи тільки їх голови. Досутп, додавання та видалення тільки до голови списку забирає тільки сталий час, тоді як доступ або модифікація елементів в списку пізніше бере час лінійно відносно глибини списку.</p></div>
<div class="paragraph"><p>Вектори є типом колекцій, що дають ефективний доступ до елементів після голови. Доступ до любого елементу вектора займає тільки "ефективно сталий час", як визначено нижче. Це більша константа, ніж для доступу до голови списка, або для читання елементу масиву, але, тим не менше, це константа. Як результат, алгоритми, що використовують вектори, не мають пильнувати щодо доступу тільки до голови послідовності. Вони можуть отримувати доступ та модифікувати елементи в довільних місцях, і таким чином, вони можуть бути значно зручніші до написання.</p></div>
<div class="paragraph"><p>Вектори будуються та модифікуються так само, як інші послідовності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>
<span class="n">vec</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec2</span> <span class="k">=</span> <span class="n">vec</span> <span class="o">:+</span> <span class="mi">1</span> <span class="o">:+</span> <span class="mi">2</span>
<span class="n">vec2</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec3</span> <span class="k">=</span> <span class="mi">100</span> <span class="o">+:</span> <span class="n">vec2</span>
<span class="n">vec3</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec3</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div></div></div>
<div class="paragraph"><p>Вектори представлені як широкі та мілкі дерева. Кожний вузол дерева містить до 32 елементів вектора, або містить до 32 інших вузлів дерева. Вектори до 32 елементів можуть бути представлені одним вузлом. Вектори до 32 * 32 = 1024 елементів можуть бути представлені з одним перенаправленям. Два стрибка від кореня дерева до фінального вузла елементу достатні для векторів до 2<sup>15</sup> елементів, три стрибка для векторів 2<sup>20</sup>, чотири стрибка для векторів з 2<sup>25</sup> елементами, і п'ять стрибкив для векторів до 2<sup>30</sup> елементів. Так що для всіх векторів пристойного розміру вибір елементів включає до п'яти виборок примітивного масиву. Це те, що ми мали на увазі, коли писали, що доступ до елементу має "ефективно сталий час".</p></div>
<div class="paragraph"><p>Вектори незмінні так що ви не зможете змінити елемент вектора на місці. Однак, з методом <code>updated</code> ви можете створити новий вектор, що відрізняється від наданого вектора тільки одним елементом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">vec</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="n">updated</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як показує останній рядок вище, виклик до <code>updated</code> не має ефекту на оригінальний вектор <code>vec</code>. Як і вибір, оновлення функціонального вектора також має "ефективно сталий час". Оновлення вектора всередині вектора може бути зроблене через копіювання вузла, що містить елемент, і кожного вузла, що вказує на нього, починаючи від кореня дерева. Це означає, що функціональне оновлення створює від одного до п'яти вузлів, кожний містить до 32 елементів або субдерев. Це, звичайно, більш коштовно, ніж оновлення на місці в змінному масиві, але все ще набагато дешевше, ніж копіювання цілого вектора.</p></div>
<div class="paragraph"><p>Оскільки вектори влучають в гарний баланс між швидким довільними функціональними вибірками та швидкими довільними функціональними оновленнями, вони наразі є реалізацією по замовченню для незмінних індексованих послідовностей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">scala.collection.immutable.IndexedSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span><span class="nc">Immutable</span> <span class="n">stacks</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___46">Незмінні стеки</h3>
<div class="paragraph"><p>Якщо вам треба послідовність останній-увійшов-перший-вийшов, ви можете використовувати <code>Stack</code>. Ви заштовхуєте елемент в стек за допомогою <code>push</code>, виштовуєте за допомогою <code>pop</code> та вибираєте зверху без видалення за допомогою <code>top</code>. Всі ці операції займають сталий час.</p></div>
<div class="paragraph"><p>Ось деякі прості операції, що виконуються на стеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">.</span><span class="n">empty</span>
<span class="n">stack</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hasOne</span> <span class="k">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">hasOne</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">top</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">pop</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Незмінні стеки використовуються рідко в Scala програмах, оскільки їх функціональність повторює списки: <code>push</code> на незмінному стеку є те саме, що <code>::</code> на списку та <code>pop</code> на стеку те саме, що <code>tail</code> на списку.</p></div>
</div>
<div class="sect2">
<h3 id="___47">Незмінні черги</h3>
<div class="paragraph"><p>Черга така сама як стек, за виключенням що вона перший-війшов-перший-вийшов, ніж останній-війшов-перший-вийшов. Спрощена реалізація незмінних черг дискутувалась в Главі 19. Ось як ви можете створити порожню незмінну чергу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
<span class="n">empty</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додати елемент до незмінної черги за допомогою <code>enqueue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">has1</span> <span class="k">=</span> <span class="n">empty</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">has1</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб додати декілька елементів до черги, викличте <code>enqueue</code> з колекцією в якості аргумента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">has123</span> <span class="k">=</span> <span class="n">has1</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">has123</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span>
<span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб видалити елемент з голови черги, використовуйте <code>dequeue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">has23</span><span class="o">)</span> <span class="k">=</span> <span class="n">has123</span><span class="o">.</span><span class="n">dequeue</span>
<span class="n">element</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">has23</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>dequeue</code> повертає пару, що складається з видаленого елементу та залишку черги.</p></div>
</div>
<div class="sect2">
<h3 id="__29">Диапазони</h3>
<div class="paragraph"><p>Диапазон є впорядкованою послідовністю цілих, що відстоять нарівно один від одного. Наприклад, <code>1, 2, 3</code> є диапазон, як і <code>5, 8, 11, 14</code>. Щоб створити диапазон в Scala, використовуйте попередньо визначені методи <code>to</code> та <code>by</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range.Inclusive</span>
  <span class="k">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="n">to</span> <span class="mi">14</span> <span class="n">by</span> <span class="mi">3</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">14</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте створити диапазон, який виключає свій верхній ліміт, використовуйте зручний метод <code>until</code> замість <code>to</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Диапазони представлені в просторі констант, оскільки вони можуть бути визначені через всього три числа: початок, кінець та значення кроку. Завдяки цій репрезентації, більшість операцій з диапазонами екстремально швидкі.</p></div>
</div>
<div class="sect2">
<h3 id="___48">Хеш дерева</h3>
<div class="paragraph"><p>Хеш дерева (<em>tries</em>, або <em>тріз</em>),<span class="footnote"><br />["Trie" походить від слова "retrieval" та вимовляються як <em>tree</em> або <em>try</em>.]<br /></span> є стандартним шляхом для ефективної реалізації незмінних масивів та мап. Їх репрезентація подібна до векторів в тому, що вони також дерева, де кожний вузол має 32 елементи або 32 субдерева, але вибірка робиться на основі хеш кода. Наприклад, щоб знайти наданий ключ, ви використовуєте молодші п'ять біт хеш коду від ключа, щоб обрати перше піддерево, наступні п'ять біт для іншого субдерева, і так далі. Вибірка зупиняється, як тільки всі елементи, що містяться в вузлі, мають хеш коди, які відрізняються один від одного в бітах, що вже вибрані. Таким чином, не всі біти хеш коду обов'язково використовуються.</p></div>
<div class="paragraph"><p>Хеш <em>тріз</em> поцілюють добрий баланс між достатньо швидкими пошуками та досить ефективними функціональними вставками (<code>+</code>) та видаленнями (<code>-</code>). Ось чому вони служать основою для реалізації по замовчанню для незмінних мап та множин Scala. Фактично, Scala має подальшу оптимізацію для незмінних множин та мап, що мають меньше ніж п'ять елементів. Множини та мапи від одного до чотирьох елементів зберігаються як один об'єкт, що містить самі елементи (або пари ключ/значення в випадку мап) як поля. Порожня незмінна множина та порожня незмінна мапа є в кожному випадку об'єктом синглтона  — немає потреби дублювати сховище для них, оскільки порожня множина та порожня мапа будуть завжди залишатись порожніми.</p></div>
</div>
<div class="sect2">
<h3 id="____27">Червоне-чорне дерева</h3>
<div class="paragraph"><p>Дерева червоне-чорне є формою збалансованих дерев, коли деякі вузли відмічені як "червоні" та інші "чорні". Як любі збалансовані двійникові дерева, операції на них надійно завершуються за час, логірифмічний до розміру дерева.</p></div>
<div class="paragraph"><p>Scala провадить реалізації множин та мап, що внутрішньо використовують красне-чорне. Ви отримуєте доступ до них під іменами <code>TreeSet</code> та <code>TreeMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">set</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Дерева червоне-чорне є також стандартною реалізацією <code>SortedSet</code> в Scala, оскільки вони провадять ефективний ітератор, що повертає всі елементи множини у впорядкованому вигляді.</p></div>
</div>
<div class="sect2">
<h3 id="____28">Незмінні бітові множини</h3>
<div class="paragraph"><p>Бітова множина представляє колекцію малих цілих, як бітів більшого цілого. Наприклад, бітова множина, що містить 3, 2 та 0, буде представлене як ціле <code>1101</code> в бінарній системі, що є <code>13</code> десятичними.</p></div>
<div class="paragraph"><p>Внутрішньо бітові множини використовують масив з 64-бітних <code>Long</code>. Перший <code>Long</code> в масиві є для цілих від 0 до 63, другий для від 64 до 127, і так далі. Таким чином, бітові множини дуже компактні, доки найдовше ціле в множині меньше ніж декілька сотен, або десь так.</p></div>
<div class="paragraph"><p>Операції на бітових наборах дуже швидкі. Перевірка на включення займає сталий час. Додавання елемента до множини пропорційна до числа <code>Long</code> в масиві бітової множини, що типово мале число. Ось деякі прості приклади використання бітових множин:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">moreBits</span> <span class="k">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span>
<span class="n">moreBits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">moreBits</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">moreBits</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___49">Спискові мапи</h3>
<div class="paragraph"><p>Спискова мапа представляє мапу як пов'язаний список пар ключ-значення. Загалом, операції на спискових мапах мають ітерувати по цілому списку. Таким чином, операції на списковій мапі займають час лінійно до розміру мапи. Фактично, існує невелике застосування списковим мапам в Scala, оскільки стандартні незмінні мапи майже завжди швидші. Одна можлива різниця є, коли якщо мапа з якихось причин сконструйована в такий спосіб, що перші елементи обираються значно більш часто, ніж інші елементи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">ListMap</span><span class="o">(</span>
<span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.immutable.ListMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span>
<span class="o">-&gt;</span> <span class="n">one</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">two</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;two&quot;</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_9____">24.9 Суцільні класи змінних колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили найбільш загально використовувані класи незмінних колекцій, що провадить Scala в своїй стандартній бібліотеці, поглянемо на класи змінних колекцій.</p></div>
<div class="sect2">
<h3 id="___50">Буфери масивів</h3>
<div class="paragraph"><p>Ви вже бачили буфери масивів в Розділі 17.1. Буфер масиву зберігає масив та розмір. Більшість операцій на буфері масивів має ту саму швидкість, що і для масивів, оскільки операції просто отримують доступ та модифікують підлеглий масив. Додатково, буфери масивів можуть ефективно додавати дані в кінець. Додавання елементу до буферу масиву триває амортизовано сталий час. Таким чином, буфери масивів корисні для ефективної побудови великих колекцій, коли нові елементи завжди додаються в кінець. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res38</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___51">Буфери списків</h3>
<div class="paragraph"><p>Ви вже бачили буфери списків в Розділі 17.1. Буфери списків подібні до буферів масивів, за виключенням того, що вони внутрішньо використовують зв'язані списки замість масивів. Якщо ви плануєте конвертувати буфер на список, коли він буде побудований, використовуйте буфер списків замість буферу масивів. Ось приклад:<span class="footnote"><br />[<code>buf.type</code>, що з'являється в відповідях інтерпретатора в цьому та деяких інших прикладах цього розділу є типом синглтона. Як буде пояснено в Розділі 29.6, <code>buf.type</code> означає, що змінна зберіагє в точності об'єкт, на який посилається <code>buf</code>.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___52">Побудовники рядків</h3>
<div class="paragraph"><p>Так само, як буфери масивів корисні для побудови масивів та буфери списків корисні для побудови списків, побудовник рядків корисний для побудови рядків. Побудовники рядків використовуються настільки загально, що вони завжди імпортуються в простір імен по замовчанню. Створюйте їх просто як <code>new StringBuilder</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="sc">&#39;a&#39;</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">++=</span> <span class="s">&quot;bcdef&quot;</span>
<span class="n">res45</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="n">abcdef</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toString</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcdef</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____29">Зв'язані списки</h3>
<div class="paragraph"><p>Зв'язані списки є змінні послідовності, що складаються з вузлів, що пов'язані вказівниками <code>next</code>. В більшості мов <code>null</code> може бути взятий як порожній зв'язаний список. Це не робить для Scala колекцій, оскільки навіть порожні послідовності мають підтримувати всі методи послідовностей. Зокрема, <code>LinkedList.empty.isEmpty</code> повинно повертати <code>true</code> та не закидати <code>NullPointerException</code>. Порожні зв'язані списки замість цього закодовані в особливий спосіб: їх поле <code>next</code> вказує назад до самого вузла.</p></div>
<div class="paragraph"><p>Як їх незмінні колеги, зв'язані списки краще обробляються послідовно. На додаток зв'язані списки спрощують вставку елемента або зв'язаного списку в інший зв'язаний список.</p></div>
</div>
<div class="sect2">
<h3 id="_____18">Подвійно зв'язаний список</h3>
<div class="paragraph"><p><code>DoubleLinkedLists</code> подібні до однозв'язаних списків, описаних в попередньому підрозділі, але крім <code>next</code> вони мають інше змінне поле, <code>prev</code>, що вказує на елемент перед поточним вузлом. Головна перевага цього додаткового посилання в тому, що це робить видалення елементу дуже швидким.</p></div>
</div>
<div class="sect2">
<h3 id="___53">Змінні списки</h3>
<div class="paragraph"><p><code>MutableList</code> складається з одного зв'язаного списку, разом з вказівником, що посилається на термінальний порожній вузол цього списку. Це робить додавання до списку операцією сталого часу, оскільки уникається подорожування по списку в пошуку термінального вузла. <code>MutableList</code> наразі є стандартною реалізацією <code>mutable.LinearSeq</code> в Scala.</p></div>
</div>
<div class="sect2">
<h3 id="__30">Черги</h3>
<div class="paragraph"><p>Scala провадить змінні черги, на додаток до незмінних. Ви використовуєте змінні черги подібно до того, як використовуються незмінні, але замість <code>enqueue</code> ви використовуєте оператори <code>+=</code> та <code>++=</code> для додавання. Також на змінній черзі метод <code>dequeue</code> буде лише видаляти головний елемент з черги та повертати його. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">+=</span> <span class="s">&quot;a&quot;</span>
<span class="n">res47</span><span class="k">:</span> <span class="kt">queue.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">)</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">queue.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queueres49</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">dequeue</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___54">Послідовності масивів</h3>
<div class="paragraph"><p>Послідовності масивів є змінні послідовності фіксованого розміру, що зберігають свої елементи всередині як <code>Array[AnyRef]</code>. Вони реалізовані в Scala як клас <code>ArraySeq</code>. Ви можете типово використовувати <code>ArraySeq</code>, якщо ви бажаєте масив заради його характеристик продуктивності, але ви також бажаєте створити загальні примірники послідовності, коли ви не знаєте тип елементів, і не маєте <code>ClassTag</code>, щоб запровадити під час виконання. Скоро ви дізнаєтесь про ці проблеми в Розділі 24.10.</p></div>
</div>
<div class="sect2">
<h3 id="__31">Стеки</h3>
<div class="paragraph"><p>Ви бачили незмінні стеки раніше. Також є змінна версія. Це робить точно так саме, як і незмінна версія, за винятком того, що зміни відбуваються на місці. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">stack</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">stack.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">stack.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">top</span>
<span class="n">res56</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res57</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stack</span>
<span class="n">res59</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stack</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____30">Стекі з масивів</h3>
<div class="paragraph"><p><code>ArrayStack</code> є альтернативною реалізацією змінного стеку, до базується на <code>Array</code>, що змінює розмір за потреби. Він провадить швидке індексування, і загалом трохи більше ефективний для більшості операцій, ніж звичайний змінний стек.</p></div>
</div>
<div class="sect2">
<h3 id="___55">Хеш таблиці</h3>
<div class="paragraph"><p>Хеш таблиця зберігає свої елементи в підлеглому масиві, покладаючи кожний елемент в позицію в масиві, що визначається хеш кодом цього елемента. Додавання елемента до хеш таблиці займає тільки сталий час, доки немає іншого елемента в масиві, що май той самий хеш код. Таким чином хеш таблиці дуже швидкі, доки об'єкти, що покладаються в них мають гарне розподілення хеш кодів. Як результат, по замовчанню типи змінної мапи та множини в Scala базуються на хеш таблицях.</p></div>
<div class="paragraph"><p>Хеш множини та мапи використовуються так само, як любі інші множини або мапи. Ось деякі прості приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;make a web site&quot;</span><span class="o">)</span>
<span class="n">res60</span><span class="k">:</span> <span class="kt">map.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;profit!&quot;</span><span class="o">)</span>
<span class="n">res61</span><span class="k">:</span> <span class="kt">map.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">profit</span><span class="o">!)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res62</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">make</span> <span class="n">a</span> <span class="n">web</span> <span class="n">site</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">contains</span> <span class="mi">2</span>
<span class="n">res63</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітерація по хеш таблиці не гарантовано виконується в деякому певному порядку. Ітерація просто проходить по підлеглому масиву,в якому б порядку це не траплялось. Щоб отримати гарантований порядок ітерації використовуйте зв'язану мапо або множину, замість звичайної. Зв'язана хеш мапа або множина така сама, як і звичайна мапа або множина, за тим винятком, що він таком влючає зв'язаний список елементів в тому порядку, як вони додавались. Ітерація по такій колекції відбувається завжди в тому порядку, в якому елементи були додані.</p></div>
</div>
<div class="sect2">
<h3 id="____31">Слабкі хеш мапи</h3>
<div class="paragraph"><p>Слабка хеш мапа є особливим різновидом хеш мапи, в якій збирач сміття не слідує посиланням від мапи до ключів, що зберігаються в ній. Це означає, що ключ та його асоційоване значення будуть зникати з мапи, якщо немає іншого посилання на ключ. Слабкі хеш мапи корисні для завдань таких як кешування, де ви бажаєте пере-використати результат коштовної функції, коли функція викликається знову на тому ж ключі. Якщо ключі та результати функції зберігаються в звичайній хеш мапі, мапа буде зростати без обмежень, і жодний ключ ніколи не стане сміттям. Використання слабкої хеш мапи уникає цієї проблеми. Як тільки об'єкт ключа стає недосяжний, його входження видаляється зі слабкої хеш мапи. Слабкі хеш мапи в Scala реалізовані як огортка підлеглої Java реалізації, <code>java.util.WeakHashMap</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___56">Конкурентні мапи</h3>
<div class="paragraph"><p>Конкурентні мапи можуть отримувати доступ з декількох потоків одночасно. На додаток до звичайних операцій з <code>Map</code>, вони провадять наступні атомарні операції:</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">m putIfAbsent(k, v)</p></td>
<td align="left" valign="top"><p class="table">Додає прив'язку ключ/value <code>k -&gt; m</code>, за винятком коли <code>k</code> вже визначений в <code>m</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m remove (k, v)</p></td>
<td align="left" valign="top"><p class="table">Видаляє входження для <code>k</code>, якщо він наразі відображений на <code>v</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m replace (k, old, new)</p></td>
<td align="left" valign="top"><p class="table">Замінює значення, асоційоване з ключем <code>k</code> на <code>new</code>, якщо віе до цього був прив'язаний до <code>old</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m replace (k, v)</p></td>
<td align="left" valign="top"><p class="table">Замінює значення, асоційоване з ключом <code>k</code> до <code>v</code>,якщо він до цього був пов'язаний з деяким значенням</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p><code>ConcurrentMap</code> є трейтом в бібліотеці колекцій Scala. Наразі єдиною реалізацією є Java <code>java.util.concurrent.ConcurrentMap</code>, що може бути конвертований автоматично в мапу Scala, використовуючи стандартні перетворення колекцій Java/Scala, що будуть описані в Розділі 24.17.</p></div>
</div>
<div class="sect2">
<h3 id="____32">Змінні бітові множини</h3>
<div class="paragraph"><p>Змінні бітові множини такі самі, як незмінні, за виключенням того, що вони можуть бути модифіковані на місці. Змінні бітові множини трохи більше ефективні при оновленні, ніж незмінні, оскільки вони не мають копіювати <code>Long</code>, що не були змінені. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.mutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res64</span><span class="k">:</span> <span class="kt">bits.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="n">res65</span><span class="k">:</span> <span class="kt">bits.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span>
<span class="n">res66</span><span class="k">:</span> <span class="kt">scala.collection.mutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_10_">24.10 Масиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Масиви є особливим різновидом колекцій в Scala. З одного боку, масиви Scala відповідають один-до-одного до масивів Java. Тобто Scala масив <code>Array[Int]</code> представлений як Java <code>int[]</code>, <code>Array[Double]</code> представлений як Java <code>double[]</code> та <code>Array[String]</code> представлений як Java <code>String[]</code>. Але в той самий час, Scala масиви пропонують значно більше, ніж Java аналоги. Перше, масиви Scala можуть бути дженеріками. Тобто, ви можете мати <code>Array[T]</code>, де <code>T</code> є параметром типу або абстрактном типом. Друге, масиви Scala сумісні зі Scala послідовностями — ви можете передати <code>Array[T]</code>, де потрібне <code>Seq[T]</code>. Нарешті, масиви Scala також підтримують всі операції послідовностей. Ось приклад цього в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">a1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span> <span class="k">=</span> <span class="n">a1</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a3</span> <span class="k">=</span> <span class="n">a2</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">a3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">a3</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги, що Scala масиви представлені як масиви Java, як ці додаткові можливості підтримуються в Scala?</p></div>
<div class="paragraph"><p>Відповідь полягає в систематичному використанні неявних перетворень. Масив не може претендувати на звання послідовності, оскільки тип даних, що представляє природні масиви, не є субтипом <code>Seq</code>. Замість цього, кожного разу, коли масив використовується як Seq, він неявно огортається в субклас <code>Seq</code>. Ім'я цього субкласу - <code>scala.collection.mutable.WrappedArray</code>. Тут ви бачите його в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">a1</span> <span class="n">eq</span> <span class="n">a4</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця взаємодія демонструє, що масиви сумісні з послідовностями, оскільки є неявне перетворення від <code>Array</code> до <code>WrappedArray</code>. Ідучи іншим шляхом, від <code>WrappedArray</code> до <code>Array</code>, ви можете використовувати метод <code>toArray</code>, визначений в <code>Traversable</code>. Останній рядок інтерпретатора вище показує, що огортання та потім розгортання за допомогою <code>toArray</code> дає вам той самий масив, з якого ви починали.</p></div>
<div class="paragraph"><p>Існує також інше неявне перетворення, що застосовується до масивів. Це перетворення просто "додає" всі методи послідовностей до масивів, але не перетворює самий масив на послідовність. "Додавання" означає, що масив огортається в інший об'єкт <code>ArrayOps</code>, що підтримує всі методи послідовностей. Типово цей об'єкт <code>ArrayOps</code> коротко-тривалий; він зазвичай буде недоступний після виклику метода послідовності та його сховище буде утилізоване. Сучасні VM часто уникають створення цього об'єкту повністю.</p></div>
<div class="paragraph"><p>Різниця між двома неявними перетвореннями масивів демонструється нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">seq</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ops</span><span class="k">:</span> <span class="kt">collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="n">ops</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">I</span><span class="o">(</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">)</span>

<span class="kt">scala&gt;</span> <span class="kt">ops.reverse</span>
<span class="kt">res3:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Array</span><span class="o">(</span><span class="err">3</span>, <span class="err">2</span>, <span class="err">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що виклик <code>reverse</code> на <code>seq</code>, що є <code>WrappedArray</code>, знову буде давати <code>WrappedArray</code>. Це логічно, оскільки огорнуті масиви є <code>Seqs</code>, і виклик <code>reverse</code> на любому <code>Seq</code> буде знову давати <code>Seq</code>. З іншого боку, виклик <code>reverse</code> на <code>ops</code> значенні класу <code>ArrayOps</code> дасть в результаті <code>Array</code>, не <code>Seq</code>. Приклад <code>ArrayOps</code> вище був досить штучний, призначений тільки показати різницю з <code>WrappedArray</code>. Звичайно ви ніколи не визначаєте значення класу <code>ArrayOps</code>. Ви просто викликаєте метод <code>Seq</code> на масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a1</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Об'єкт <code>ArrayOps</code> вставляється автоматично через неявне перетворення. Так що рядок вище еквівалентний до наступного рядка, де <code>intArrayOps</code> було перетворенням, що було неявно вставленим до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">intArrayOps</span><span class="o">(</span><span class="n">a1</span><span class="o">).</span><span class="n">reverse</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це підіймає питання, як компілятор обирає <code>intArrayOps</code> перед іншим неявним перетворенням до <code>WrappedArray</code> в рядку вище. Кінець кінцем, обоє перетворення відображають масив на тип, що підтримує метод <code>reverse</code>, де це те, що вказане на вході. Відповідь на це питання в тому, що ці два неявні перетворення мають преоритети. Перетворення <code>ArrayOps</code> має вищий преоритет, ніж перетворення <code>WrappedArray</code>. Перший визначений в об'єкті <code>Predef</code>, тоді як другий визначений в класі <code>scala.LowPriorityImplicits</code>, що є суперкласом <code>Predef</code>. Неявні в субкласах та субоб'єктах мають перевагу над неявними в базових класах. Так що коли можуть застосовуватись обоє перетворень, буде обрана версія з <code>Predef</code>. Дуже подібна схема, що була описана в Розділі 21.7, робить для рядків.</p></div>
<div class="paragraph"><p>Так що зараз ви знаєте, як масиви можуть бути сумісні з послідовностями та як вони можуть підтримувати всі операції послідовностей. Як щодо дженерікив? В Java ви не можете записати <code>T[]</code>, де <code>T</code> є параметром типу. Тоді як представлені <code>Array[T]</code> в Scala? Фактично, дженерік масив як <code>Array[T]</code> може бути під час виконання любим з вісьми масивів примітирних типів Java: <code>byte[]</code>, <code>short[]</code>, <code>char[]</code>, <code>int[]</code>, <code>long[]</code>, <code>float[]</code>, <code>double[]</code>, <code>boolean[]</code>, або він може бути масивом об'єктів. Єдиний загальний рантайм тип, що обіймає всі ці типи, є <code>AnyRef</code> (або, що еквівалентно, <code>java.lang.Object</code>) так що це той тип, на який компілятор Scala відображує <code>Array[T]</code>. Під час виконання, коли виконується доступ або модифікація елементу масиву типу <code>Array[T]</code>, відбувається послідовність перевірок типу, що визначає справжній тип масиву, за яким слідує коректна операція масиву на Java масиві. Ці перевірки типів дещо уповільнюють операції з масивами. Ви можете очікувати, що доступ до дженерік масивів будуть від трьох до чотирьох разів повільніші, ніж доступ до примітивних або об'єктних масивів. Це означає, що якщо вам треба максимальна продуктивність, вам треба обирати суцільні масиви замість дженерікив.</p></div>
<div class="paragraph"><p>Однак представити дженерік масиви не є достатнім також має бути спосіб створювати дженерік масиви. Існує навіть складніша проблема, що потребує трохи більше допомоги з вашого боку. Щоб пролілюструвати проблему, розглянемо наступну спробу написати дженерік метод, що створює масив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це невірно!</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>evenElems</code> повертає новий масив, що складається з усіх елементів аргументу-вектора <code>xs</code>, що стоять в векторі на парних позиціях. Перший рядок тіла <code>evenElems</code> створює результуючий масив, що має той самий тип елементів, що і аргумент. Так що, в залежності від дійсного параметру типу <code>T</code>, це могло бути <code>Array[Int]</code>, або <code>Array[Boolean]</code>, або масив деякого іншого примітивного типу Java, або масив деякого типу посилання. Але ці типи мають різні репрезентації під час виконання, то як рантайм Scala збирається обрати коректний тип? Фактично, він не може зробити це базуючись на наданій йому інформації, оскільки справжній тип, що відповідає параметру типу <code>T</code>, затирається під час виконання. Ось чому ви отримаєте наступне повідомлення про помилку, якщо ви намагатиметесь скомпілювати код вище:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">error</span><span class="k">:</span> <span class="kt">cannot</span> <span class="kt">find</span> <span class="kt">class</span> <span class="kt">tag</span> <span class="kt">for</span> <span class="kt">element</span> <span class="k">type</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">arr</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут потрібне, це ваша допомога компілятору шляхом провадження підказки рантайму, якій справжній тип параметру <code>evenElems</code>. Ця підказка часу виконання приймає форму класового тегу <code>typescala.reflect.ClassTag</code>. Класовий тег описує затертий тип даного типу, що є всею інформацією, потрібною для конструювання масиву цього типу.</p></div>
<div class="paragraph"><p>В багатьох випадках компілятор може генерувати класовий тег сам по собі. Це випадок для суцільних типів, як <code>Int</code> або <code>String</code>. Це також випадок для певних дженерік типів, як <code>List[T]</code>, де відомо досить інформації, щоб зпрогнозувати затертий тип; в цьому випадку затертий тип буде <code>List</code>.</p></div>
<div class="paragraph"><p>Для повністю дженерік класів звичайна ідиома є передавати класовий тег використовуючи обмеження контексту, як обговорювалось в Розділі 21.6. Ось як визначення вище може бути полагоджене, через використання обмеження контексту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це робить</span>
<span class="k">import</span> <span class="nn">scala.reflect.ClassTag</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому новому визначенні, коли створюється <code>Array[T]</code>, компілятор шукає класовий тег для параметру типу <code>T</code>, тобто, він буде шукати неявне значення типу <code>ClassTag[T]</code>. Якщо таке значення буде знайдене, класовий тег використовується для конструювання правильного типу масиву. Інакше ви побачите повідомлення про помилку, яке ви бачили до цього.</p></div>
<div class="paragraph"><p>Ось інтеракція з інтерпретатором, що використовує метод <code>evenElems</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="s">&quot;this&quot;</span><span class="o">,</span> <span class="s">&quot;is&quot;</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;test&quot;</span><span class="o">,</span> <span class="s">&quot;run&quot;</span><span class="o">))</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">run</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В обох випадках компілятор Scala компілятор автоматично конструює класовий тег для типу елементів (перший - <code>Int</code>, другий - <code>String</code>) та передає його до неявного параметру метода <code>evenElems</code>. Компілятор може зробити це для суцільних типів, але ні, якщо аргумент самий є іншим параметром типу без свого класового тегу. Наприклад, наступне схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">ClassTag</span> <span class="kt">available</span> <span class="kt">for</span> <span class="kt">U</span>
  <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
                                        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що відбувається тут, це те, що <code>evenElems</code> вимагає класовий тег для параметру типа <code>U</code>, але жодний не був знайдений. Рішення в цьому випадку, звичайно, що треба вимагати інший класовий тег для <code>U</code>. Так що наступне робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="n">wrap</span><span class="k">:</span> <span class="err">[</span><span class="kt">U</span><span class="err">]</span><span class="o">(</span><span class="kt">xs:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">evidence$1</span><span class="k">:</span>
<span class="kt">scala.reflect.ClassTag</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="nc">Array</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад також показує, що контекст, зв'язаний в визначенні <code>U</code>, є просто скороченням для неявного параметра, що тут має назву <code>evidence$1</code> типу <code>ClassTag[U]</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_11_">24.11 Рядки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як і масиви, рядки напряму не є послідовностями, але вони можуть бути сконвертовані до них, і вони також підтримують всі операції послідовностей. Ось деякі приклади операцій, що ви можете викликати для радків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">str</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">hello</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">olleh</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toUpper</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">HELLO</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span> <span class="n">drop</span> <span class="mi">3</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">lo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">str</span> <span class="n">slice</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">ell</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">str</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedString</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці операції підтримуються двома неявними перетвореннями, що пояснюються в Розділі 21.7. Перше, низько-преоритетне перетворення відображує <code>String</code> до <code>WrappedString</code>, що є субкласом <code>immutable.IndexedSeq</code>. Це перетворення було застосоване в останньому рядку попереднього приклада, де рядок був перетворений на <code>Seq</code>. Інше, високо-преоритетне перетворення відображує рядок до об'єкту <code>StringOps</code>, що додає всі методи незмінних послідовностей до рядків. Це перетворення було неявно вставлене в виклики методів <code>reverse</code>, <code>map</code>, <code>drop</code> та <code>slice</code> в попередньому прикладі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_12__">24.12 Характеристики продуктивності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як показали попередні пояснення, різні типи колекцій мають різні характеристики продуктивності. Часто це головна причина для обирання однієї колекції, ніж іншої. Ви можете бачити характеристики продуктивності деяких загальних операцій на колекціях, підсумовані в двох таблицях, Таблиці 24.12 та Таблиці 24.12.</p></div>
<div class="sect2">
<h3 id="_____19">Характеристики продуктивності типів послідовностей</h3>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<col width="12%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">head</p></td>
<td align="left" valign="top"><p class="table">tail</p></td>
<td align="left" valign="top"><p class="table">apply</p></td>
<td align="left" valign="top"><p class="table">update</p></td>
<td align="left" valign="top"><p class="table">prepend</p></td>
<td align="left" valign="top"><p class="table">append</p></td>
<td align="left" valign="top"><p class="table">insert</p></td>
</tr>
<tr>
<td colspan="8" align="left" valign="top"><p class="table">immutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">List</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stream</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Vector</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Queue</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Range</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td colspan="8" align="left" valign="top"><p class="table">mutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArrayBuffer</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ListBuffer</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">StringBuilder</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">MutableList</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Queue</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArraySeq</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Stack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ArrayStack</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Array</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
<td align="left" valign="top"><p class="table">-</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="______">Характеристики продуктивності типів множин та мап</h3>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">lookup</p></td>
<td align="left" valign="top"><p class="table">add</p></td>
<td align="left" valign="top"><p class="table">remove</p></td>
<td align="left" valign="top"><p class="table">min</p></td>
</tr>
<tr>
<td colspan="5" align="left" valign="top"><p class="table">immutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">HashSet/HashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">TreeSet/TreeMap</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
<td align="left" valign="top"><p class="table">Log</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BitSet</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">eC.<span class="footnote"><br />[Assuming bits are densely packed.]<br /></span></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ListMap</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td colspan="5" align="left" valign="top"><p class="table">mutable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">HashSet/HashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WeakHashMap</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">eC</p></td>
<td align="left" valign="top"><p class="table">L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BitSet</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">aC</p></td>
<td align="left" valign="top"><p class="table">C</p></td>
<td align="left" valign="top"><p class="table">eC^a</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Входження в ціх двох таблицях пояснюється наступним чином:</p></div>
<div class="paragraph"><p><strong>C</strong> Операція займає сталий час (швидка).</p></div>
<div class="paragraph"><p><strong>eC</strong> Операція ефективно займає сталий час, але це може залежати від деяких припущень таких, як максимальна довжина вектора, або розподілення хеш ключей.</p></div>
<div class="paragraph"><p><strong>aC</strong> Операція займає амортизований сталий час. Деякі виклики операції можуть зайняти довше, але якщо виконується багато операцій,в середньому операція триває сталий час.</p></div>
<div class="paragraph"><p><strong>Log</strong> Операція триває час, пропорційний до логарифму розміру колекції.</p></div>
<div class="paragraph"><p><strong>L</strong> Операція лінійна, триває час пропорційний до розміру колекції.</p></div>
<div class="paragraph"><p><strong>-</strong> Операція не підтримується.</p></div>
<div class="paragraph"><p>Таблиця 24.12 розглядає типи послідовностей, змінні та незмінні, для неступних операцій:</p></div>
<div class="paragraph"><p><strong>head</strong> Вибір першого елемента в послідовності.</p></div>
<div class="paragraph"><p><strong>tail</strong> Створення нової колекції, що складається з усіх елементів, крім першого.</p></div>
<div class="paragraph"><p><strong>apply</strong> Індексування.</p></div>
<div class="paragraph"><p><strong>update</strong> Функціональне оновлення (за допомогою <code>updated</code>) для незмінних послідовностей, оновлення з побічним ефектом (за допомогою <code>update</code>) для змінних послідовностей.</p></div>
<div class="paragraph"><p><strong>prepend</strong> Додавання елементу зпереду послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.</p></div>
<div class="paragraph"><p><strong>append</strong> Додавання елементу в кінець послідовності. Для незмінних послідовностей це продукує нову послідовність. Для змінних послідовностей це модифікує існуючу послідовність.</p></div>
<div class="paragraph"><p><strong>insert</strong> Вставка елементу в довільну позицію послідовності. Напряму це підтримується тільки для змінних послідовностей.</p></div>
<div class="paragraph"><p>Таблиця 24.12 розглядає змінні та незмінні множини та мапи стосовно наступних операцій:</p></div>
<div class="paragraph"><p><strong>lookup</strong> Перевірка, чи елемент знаходиться в множині або обирає значення, асоційоване з ключем.</p></div>
<div class="paragraph"><p><strong>add</strong> Додавання нового елементу до множини або новох мапи ключ/значення до мапи.</p></div>
<div class="paragraph"><p><strong>remove</strong> Видалення елементу з множини або ключа з мапи.</p></div>
<div class="paragraph"><p><strong>min</strong> Найменьший елемент в множині, або меньший ключ в мапі.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_13_">24.13 Еквівалентність</h2>
<div class="sectionbody">
<div class="paragraph"><p>Бібліотеки колекцій мають уніформний підхід до рівності та хешування. Перше, ідея в тому, щоб поділити колекції на множини, мапи та послідовності. Колекції в різних категоріях завжди нерівні. Наприклад, <code>Set(1, 2, 3)</code> нерівне до <code>List(1, 2, 3)</code>, навіть якщо вони містять ті самі елементи. З іншого боку, в тій самій категорії, колекції рівні, тільки, та тільки, якщо вони мають ті самі елементи (для послідовностей: ті ж елементи в тому ж порядку). Наприклад, <code>List(1, 2, 3) == Vector(1, 2, 3)</code>, та <code>HashSet(1, 2) == TreeSet(2, 1)</code>.</p></div>
<div class="paragraph"><p>Не має значення для перевірки рівності, чи колекція змінна, чи незмінна. Для змінної колекції рівність просто залежить від поточних елементів на час, коли виконується перевірка. Це означає, що змінні колекції можуть бути еквівалентні до різних колекцій в різний час, в залежності що було додано або видалене. Це потенційна пастка, коли змінна колекція використовується як ключ в хеш мапі. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="nc">HashMap</span><span class="o">(</span><span class="n">buf</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashMap</span><span class="o">[</span><span class="kt">scala.collection.</span>
<span class="kt">mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span><span class="mi">3</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">key</span> <span class="kt">not</span> <span class="kt">found:</span>
  <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі вибірка в останньому рядку скоріше всього схибить, оскільки хеш код масива <code>xs</code> зміниться в передостанньому рядку. Таким чином, пошук на основі хеш кода буде шукати в іншому місці, ніж той, в якому був збережений <code>xs</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_14_">24.14 Перегляди</h2>
<div class="sectionbody">
<div class="paragraph"><p>Колекції мають декілька методів, що конструюють нові колекції. Деякі приклади є <code>map</code>, <code>filter</code> та <code>++</code>. Ми називаємо такі методи трансформерами, оскільки вони приймають щонайменьше одну колекцію в якості свого об'єкта-отримувача, та продукують іншу колекцію в якості результата.</p></div>
<div class="paragraph"><p>Трансформери можуть бути реалізовані в два принципові способи: строгий та нестрогий (або лінивий). Строгий трансформер конструює нову колекцію з усіма своїми елементами. Нестрогий, або лінивий, трансформер конструює тільки проксі для результуючої колекції, та його елементи конструюються на вимогу.</p></div>
<div class="paragraph"><p>Як приклад нестрогого трансформера, розглянемо наступну реалізацію лінивої операції <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lazyMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">coll</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">map</span> <span class="n">f</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>lazyMap</code> конструює нове <code>Iterable</code> без крокування по всіх елементах наданої колекції <code>coll</code>. Надана функція <code>f</code> замість цього застосовується до елементів ітератора нової колекції, по мірі потреби.</p></div>
<div class="paragraph"><p>Scala колекції по замовчанню строгі в усіх своїх трансформерах, за винятком <code>Stream</code>, що реалізує всі свої методи-трансформери ліниво. Однак існує систематичний спосіб для перетворення кожної колекції в ліниву та навпаки, що базується на переглядах колекції. Перегляд є особливим різновидом колекції, що представляє деяку базову колекцію, але реалізує всі її трансформери ліниво.</p></div>
<div class="paragraph"><p>Щоб перейти від колекції до її перегляду, ви можете використовувати метод <code>view</code> на колекції. Якщо <code>xs</code> є деякою колекцією, тоді <code>xs.view</code> є та сама колекція, але всі трансформери якої реалізовані ліниво. Щоб перейти назад від перегляду до строгої колекції ви можете використати метод <code>force</code>. Як приклад, скажімо, ви маєте вектор з <code>Int</code>, на якому ви бажаєте виконати дві функції одна за другою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В останньому твердженні вираз <code>v map (_ + 1)</code> конструює новий вектор, що потім трансформується і третій вектор, через другий виклик до <code>map (_ * 2)</code>. В багатьох ситуаціях конструювання проміжного результату після першого виклику до <code>map</code> є трохи марнотратним. В псевдо прикладі буде скорішим зробити єдиний <code>map</code> з композицією двох функцій, <code>(_ + 1)</code> та <code>(_ * 2)</code>. Якщо ви маєте дві функції доступними в тому самому місці, ви можете зробити це вручну. Але досить часто послідовні трансформації структур даних виконуються в разних програмних модулях. Зплавлення ціх перетворень потім буде підривати модульність. Більш загальним шляхом уникнути проміжних результатів є перетворення вектора зпочатку на перегляд, застосування до перегляду всіх трансформацій, на нарешті примушення перегляду знову до вектора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">view</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)).</span><span class="n">force</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми зробимо цю послідовність операцій знову одну з одною:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vv</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">view</span>
<span class="n">vv</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">SeqView</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосування <code>v.view</code> дає вам <code>SeqView</code>, тобто ліниво обчислену <code>Seq</code>. Тип <code>SeqView</code> має два параметри типу. Перший, <code>Int</code>, показує тип елементів перегляду. Другий, <code>Vector[Int]</code>, показує вам тип конструктора, що ви отримаєте назад, коли будете примушувати перегляд.</p></div>
<div class="paragraph"><p>Застосування першого <code>map</code> до перегляду дасть таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vv</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Seq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">SeqViewM</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>Результатом <code>map</code> є значення, що друкує <code>SeqViewM(...)</code>. Це в основному огортка, що записує факт, що <code>map</code> з функцією <code>(_ + 1)</code> треба застосувати до вектора <code>v</code>. Він, однак, не застосовує цей <code>map</code>, доки перегляд не буде форсований. "M" після <code>SeqView</code> вказує на те, що перегляд екнкапсулює операцію <code>map</code>. Ініш літери вказують інші відкладені операції. Наприклад, "S" вказує на відкладену операцію <code>slice</code>, та "R" вказує на <code>reverse</code>. Тепер ми застосуємо другий <code>map</code> до останнього результату.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res13</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.collection.SeqView</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Seq</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">SeqViewMM</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви отримали <code>SeqView</code>, що містить дві операції <code>map</code>, так що друкуються дві "M": <code>SeqViewMM(...)</code>. Нарешті, форсування останнього результату дає:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res14</span><span class="o">.</span><span class="n">force</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">22</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Обоє збережені функції застосовуються як частина виконання операції <code>force</code>, та конструюється новий вектор. Таким чином, жодні проміжні структури непотрібні.</p></div>
<div class="paragraph"><p>Одна деталь, яку треба зауважити, це те, що статичний тип фінального результату є <code>Seq</code>, а не <code>Vector</code>. Відстежуючи типи назад, ми бачимо, що як тільки був застосований перший відкладений <code>map</code>, результат має статичний метод <code>SeqViewM[Int, Seq[_]]</code>. Тобто, "знання" що перегляд був застосований до певного тип послідовності <code>Vector</code> було втрачене. Реалізація перегляду для любого окремого класу потребує трохи коду, так що бібліотеки колекцій Scala провадять перегляди в основному тільки для загальних типів колекцій,не для специфічних реалізацій.<span class="footnote"><br />[Виключенням для цього є масиви: застосування відкладених операцій на масивах буде знову давати результат зі статичним типом <code>Array</code>.]<br /></span></p></div>
<div class="paragraph"><p>Існує дві причини, чому ви можете вирішити використовувати перегляди. Перша це продуктивність. Ви бачили, що перемикання з колекції на перегляд можливо уникає створення проміжних колекцій. Ці збереження можуть бути досить важливі. Як інший приклад розглянемо проблему пошуку першого паліндрому в списку слів. Паліндром - це слово, що однаково читається в обох напрямках. Ось необхідні визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">def</span> <span class="n">findPalindrome</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">s</span> <span class="n">find</span> <span class="n">isPalindrome</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер уявімо, щоб ви маєте дуже довгу послідовність слів, та ви бажаєте знайти паліндром в першому мільйоні слів цієї послідовностіі. Чи ви можете повторно використати визначення <code>findPalindrome</code>? Звичайно, ви можете написати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це мило розділяє два аспекти отримання першого мільйона слів з послідовності, та пошук в ньому паліндрому. Але недолік в тому, що це завжди будує проміжну послідовність, що складається з одного мільйона слів, навіть якщо перше слово в цій послідовності поліндром. Так що після цього потенційно 999999 слів копіюються в проміжний результат взагалі без перевірки. Багато програмістів тут здадуться і напишуть свої власні версії пошуку паліндромів в деякому наданому префіксі аргумента-послідовності. Але з переглядами ви не маєте робити це. Просто напишіть:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">view</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це матиме той самий гарний поділ турбот, але замість послідовності з мільйона елементів це буде конструювати лише один легковажний об'єкт перегляда. Таким чином, вам не треба обирати між продуктивністю та модульністю. Другий випадок застосування стосується до переглядів змінних послідовностей. Багато функцій-трансформерів на таких переглядах провадять вікно до оригінальної послідовності, що потім може використовуватись для вибіркового оновлення деяких елементів в цій послідовності. Щоб побачити це на прикладі, уявімо ми маємо масив <code>arr</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">9</span><span class="o">).</span><span class="n">toArray</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити субвікно в цьому масиві, створивши скибку <code>slice</code> перегляду масиву:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">subarr</span> <span class="k">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">subarr</span><span class="k">:</span> <span class="kt">scala.collection.mutable.IndexedSeqView</span><span class="o">[</span>
  <span class="kt">Int</span>,<span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">IndexedSeqViewS</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дає перегляд <code>subarr</code>, що посилається на елементи в позиціях від 3 до 5 в масиві <code>arr</code>. Перегляд не копіює ці елементи, він тільки провадить посилання на них. Тепер уявімо, що ви маєте метод, що модифікує деякі елементи в послідовності. Наприклад, наступний метод <code>negate</code> буде обертати знак всіх наданих елементів послідовності цілих:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span>
        <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="o">-</span><span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="n">negate</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">scala.collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер уявімо, що ви бажаєте змінити знак елементів в позиціях від трьох до п'яти масива <code>arr</code>. Чи можливо використати для цього <code>negate</code>? З використанням перегляду це просто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">negate</span><span class="o">(</span><span class="n">subarr</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це те, що <code>negate</code> змінює всі елементи в <code>subarr</code>, що є скибкою елементів <code>arr</code>. Знову, ви бачите, що перегляди допомагають підтримувати речі модулярними. Код вище гарно розділяє питання, до якого диапазону індексів застосувати метод, та те, який саме метод застосувати.</p></div>
<div class="paragraph"><p>Після того, як ми побачили всі ці дотепні використання переглядів, ви можете здивуватись, для чого взагалі мати строгі послідовності? Одна причина в тому, що порівняння продуктивності не завжди на користь лінивих в колекцій в порівнянні зі строгими. Для меньших розмірів колекцій додаткове навантаження по формуванню замикань в переглядах часто більше, ніж вигода від уникнення проміжних структур даних. Можливо більш важлива причина в тому, що обчислення в переглядах можуть бути дуже збентежливі, якщо операції мають побічні ефекти.</p></div>
<div class="paragraph"><p>Ось приклад, що зачепив декількох користувачів версій Scala до 2.8. В ціх версіях тип <code>theRange</code> був лінивий, так що він ефективно поводився як перегляд. Люди намагались створити декілька акторів,<span class="footnote"><br />[Бібліотека акторів Scala вже застаріла, але цей історичний приклад все ще актуальний.]<br /></span> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="k">yield</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони були здивовані, що після цього жодний з акторів не виконувався, навіть якщо метод <code>actor</code> повинен створювати та запускати актора на основі кода, що оточений в фігурні дужки за ним. Щоб пояснити, чому нічого не відбувається, нагадаємо, що вираз <code>for</code> вище еквівалентний до застосування методу <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки попередній <code>range</code>, спродукований <code>(1 to 10)</code>, поводиться як перегляд, результатом <code>map</code> знову буде перегляд. Тобто, відповідно, жодного елементу не було обчислено, та жодного актора не було створено! Актори були створені через форсування <code>range</code> для всього виразу, але це менше ніж очевидне, що все це треба щоб змусити акторів до своєї роботи.</p></div>
<div class="paragraph"><p>Щоб уникнути ціх сюрпризів, колекції Scala отримали більш регулярні правила в версії 2.8. Всі колекції, за винятком потоків та переглядів, є строгими. Єдиний шлях від строгих до лінивих колекцій - через метод <code>view</code>. Єдиний шлях іти зворотнім шляхом - через метод <code>force</code>. Так що визначення акторів вище будуть робити як очікується в Scala 2.8, в тому розмінні, що будуть створені та запущені десять акторів. Щоб перейти до цікавої попередньої поведінки, ви маєте додати явний виклик метода <code>view</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">actors</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">).</span><span class="n">view</span><span class="o">)</span> <span class="k">yield</span> <span class="n">actor</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В підсумку, перегляди є потужним інструментом для примирення проблем ефективності з проблемами модульності. Але щоб загрузнути в аспектах відкладеного виконання, вам слідує обмежити перегляди до двох сценаріїв. Або ви застосувуєте перегляди в чисто функціональному коді, де трансформації колекцій не мають побічних ефектів. Або ви застосовуєте їх для змінних колекцій, коли всі модифікації виконуються явно. Чого треба уникати, це змішування переглядів і операцій, що створюють нові колекції, при цьому також маючи побічні ефекти.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_24_15_">24.15 Ітератори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ітератор не є колекцією, але скоріше шляхом отримати доступ до елементів колекції один за одним. Існує дві базові операції на ітераторі <code>it</code>, <code>next</code> та <code>hasNext</code>. Виклик до <code>it.next()</code> буде повертати наступний елемент ітератора, та просувати стан ітератора. Наступний виклик <code>next</code> на тому самому ітераторі буде видавати елемент на один далі від повернутого перед цім. Якщо немає більше елементів, що можна повернути, виклик до <code>next</code> буде закидати <code>NoSuchElementException</code>. Ви можете дізнатись, чи є ще елементи, що можна повернути, використовуючи метод <code>Iterator</code>'а <code>hasNext</code>.</p></div>
<div class="paragraph"><p>Найбільш прямолінійний метод "прокрокувати" по всіх елементах, що повертає ітератор, це використання циклу <code>while</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітератори в Scala також провадять аналоги до більшості з методів, що ви можете знайти в трейтах <code>Traversable</code>, <code>Iterable</code> та <code>Seq</code>. Наприклад, вони провадять метод <code>foreach</code>, що виконує надану процедуру на кожному елементі, що повертаються ітератором. Використовуючи <code>foreach</code>, цикл вище може бути скорочений до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">it</span> <span class="n">foreach</span> <span class="n">println</span>
</pre></div></div></div>
<div class="paragraph"><p>Як завжди, вирази <code>for</code> можуть використовуватись як альтернативний синтаксис для виразів, що включають <code>foreach</code>, <code>map</code>, <code>filter</code> та <code>flatMap</code>, так що інший спосіб надрукувати всі елементи, що повертаються ітератором, буде таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">elem</span> <span class="k">&lt;-</span> <span class="n">it</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує важлива різниця між методом <code>foreach</code> на ітераторі, та тим самим методом на перехідних колекціях: коли він викликається на ітераторів, <code>foreach</code> після свого закінчення буде залишати ітератор в кінці. Так що наступний виклик до <code>next</code> знову на томуж ітератору буде хибним <code>NoSuchElementException</code>. На відміну до цього, коли викликається для колекції, <code>foreach</code> залишає число елементів в колекції без змін (якщо передана функція не додає або видаляє елементи, але це не заохочується, оскільки легко може призвести до несподіваних результатів).</p></div>
<div class="paragraph"><p>Інші операції, які <code>Iterator</code> має назагал з <code>Traversable</code>, мають ту саму властивість полишати ітератор в кінці після завершення. Наприклад, ітератори провадять метод <code>map</code>, що повертає новий ітератор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;number&quot;</span><span class="o">,</span> <span class="s">&quot;of&quot;</span><span class="o">,</span> <span class="s">&quot;words&quot;</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res1</span> <span class="n">foreach</span> <span class="n">println</span>
<span class="mi">1</span>
<span class="mi">6</span>
<span class="mi">2</span>
<span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">next</span> <span class="kt">on</span> <span class="kt">empty</span> <span class="kt">iterator</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, після виклику до <code>map</code>, ітератор просунувся в кінець. Інший приклад є метод <code>dropWhile</code>, що може використовуватись для пошуку першого елементу ітератора, що має певну властивість. Наприклад, щоб знайти перше слово в ітераторі, показаному до цього, що має щонайменьше два символи, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;number&quot;</span><span class="o">,</span> <span class="s">&quot;of&quot;</span><span class="o">,</span> <span class="s">&quot;words&quot;</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">java.lang.String</span> <span class="o">=</span> <span class="n">number</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову зауважте, що <code>it</code> був змінений через виклик до <code>dropWhile</code>: тепер <code>it</code> вказує на друге слово "number" в списку. Фактично, <code>it</code> та результат <code>res4</code>, що повертається <code>dropWhile</code>, буде повертати точно такуж ж послідовність елементів.</p></div>
<div class="paragraph"><p>Існує тільки одна стандартна операція, <code>duplicate</code>, що дозволяє вам повторно використовувати той самий ітератор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="o">(</span><span class="n">it1</span><span class="o">,</span> <span class="n">it2</span><span class="o">)</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">duplicate</span>
</pre></div></div></div>
<div class="paragraph"><p>Виклик до <code>duplicate</code> дає вам два ітератори, де кожний повертає точно такі ж елементи, що і ітератор <code>it</code>. Два ітератори роблять незалежно; просування одного не впливає на інший. На відміну від цього, оригінальний оператор, <code>it</code>, просувається до свого кінця під час дублювання, і, таким чином, стає некорисним.</p></div>
<div class="paragraph"><p>В підсумку, ітератори поводяться як колекції, якщо ви ніколи не отримуєте доступ до ітератора знову, після виклику на ньому метода. Бібліотеки колекцій Scala робить це явним, з абстракцією на ім'я <code>TraversableOnce</code>, що є загальним трейтом для <code>Traversable</code> та <code>Iterator</code>. Як відказує ім'я, об'єкти <code>TraversableOnce</code> можуть проходити з використанням <code>foreach</code>, але стан цього об'єкту після проходження не визначений. Якщо об'єкт <code>TraversableOnce</code> фактично є <code>Iterator</code>, він після проходження буде в своєму кінці, але якщо це <code>Traversable</code>, він буде існувати як раніше. Загальний спосіб застосування <code>TraversableOnce</code> - як тип аргумента для методів, що можуть приймати або ітератор, або перехідне в якості аргумента. Прикладом є метод додавання <code>++</code> в трейті <code>Traversable</code>. Він приймає параметр <code>TraversableOnce</code>, так що ви можете додати елементи, що походять або від ітератора, або від перехідної колекції.</p></div>
<div class="paragraph"><p>Всі операції на ітераторах підсумовані в Таблиці 24.12.</p></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Абстрактні методи:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.next()</p></td>
<td align="left" valign="top"><p class="table">Повертає наступний елемент ітератора <code>it</code> та просувається далі.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.hasNext</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>true</code>, якщо <code>it</code> може повернути наступний елемент.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Варіації:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.buffered</p></td>
<td align="left" valign="top"><p class="table">Буферизований ітератор, що повертає всі елементи <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it grouped size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отримує елементи <code>it</code> в "шматках" послідовностей фіксованого розміру.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">xs sliding size</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отримує елементи <code>it</code> в послідовностях плаваючого вікна фіксованого розміру.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Копіювання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it copyToBuffer buf</p></td>
<td align="left" valign="top"><p class="table">Копіює всі повернуті <code>it</code> елементи до буфера <code>buf</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it copyToArray(arr, s, l)</p></td>
<td align="left" valign="top"><p class="table">Копіює щонайбільше <code>l</code> елементів, що повертаються <code>it</code>, до <code>arr</code>, починаючи з індексу <code>s</code>. Останні два аргументи опціональні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Дублікація:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.duplicate</p></td>
<td align="left" valign="top"><p class="table">Пара ітераторів, кожний з яких незалежно повертає всі елементи <code>it</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Додавання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it ++ jt</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи, що повертає ітератор <code>it</code>, за яким слідують елементи, що повертає ітератор <code>jt</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it padTo (len, x)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи <code>it</code>, за якими слідують копії <code>x</code>, доки не буде досягнута загальна довжина з <code>len</code> елементів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Мапи:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it map</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отриманий від застосування функції <code>f</code> до кожного елементу, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it flatMap</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що отриманий від застосування функції зі значенням ітератора <code>f</code> до кожного елементу, та додавання результатів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it collect</p></td>
<td align="left" valign="top"><p class="table">Ітератор, отриманий від застосування часткової функції <code>f</code> до кожного елементу в <code>it</code>, до якого вона визначена, та збирання результатів.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Перетворення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toArray</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в масив.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toList</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в список.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toIterable</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в <code>iterable.it.toSeq</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toIndexedSeq</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в індексовану послідовність.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toStream</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в потік.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toSet</p></td>
<td align="left" valign="top"><p class="table">Збирає елементи, що повертає <code>it</code>, в множину.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.toMap</p></td>
<td align="left" valign="top"><p class="table">Збирає пари ключ/значення, що повертає <code>it</code>, в мапу.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Інформація про розмір:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.isEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи ітератор порожній (протилежність <code>hasNext</code>).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.nonEmpty</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи колекція містить елементи (псевдоним до <code>hasNext</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.size</p></td>
<td align="left" valign="top"><p class="table">Число елементів, що повертає <code>it</code>. Увага: <code>it</code> після цієї операції буде вказувати на кінець!</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.lengt</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <em>it.size</em>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.hasDefiniteSize</p></td>
<td align="left" valign="top"><p class="table">Повертає <code>true</code>, якщо відомо, що <code>it</code> повертає обмежену кількість елементів (по замовчанню те саме, що <code>isEmpty</code>).</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Пошук і отримання елементів:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it find</p></td>
<td align="left" valign="top"><p class="table">Опція, що містить перший елемент, що повертає <code>it</code>, який задовільняє <code>p</code>, або <code>None</code>, якщо жодний елемент не підійде. Увага: ітератор просувається після знайденого елементу, або до кінця, якщо нічого не знайдене.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it indexOf</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елемента, що повертається <code>it</code>, що дорівнює <code>x</code>. Увага: ітератор просувається за позицію цього елемента.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it indexWhere</p></td>
<td align="left" valign="top"><p class="table">Індекс першого елементу, що повертається <code>it</code>, що задовільняє <code>p</code>. Увага: ітератор просувається за позицію цього елемента.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Субітератори:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it take</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає перші <code>n</code> елементів <code>it</code>. Увага: <code>it</code> буде просуватись до позиції за <code>n</code>-ним елементом, або до кінця, якщо <code>it</code> містить меньше ніж <code>n</code> елементів.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it drop</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що починається з <code>(n + 1)</code>-ного елементу <code>it</code>. Увага: <code>it</code> буде просуватись на нову позицію.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it slice (m, n)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає фрагмент з елементів, що повертає <code>it</code>, починаючи з <code>m</code>-того елемента, та завершуючи перед <code>n</code>-ним елементом.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it takeWhile</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає елементи з <code>it</code>, доки умова <code>p</code> є <code>true</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it dropWhile</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що пропускає елементи з <code>it</code>, доки умова <code>p</code> є <code>true</code>, та повертає залишок.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it filter</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи з <code>it</code>, що задовільняє умові <code>p</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it withFilter</p></td>
<td align="left" valign="top"><p class="table">Те саме, що <code>it filter p</code>. Треба для використання ітераторів в виразах <code>for</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it filterNot</p></td>
<td align="left" valign="top"><p class="table">Ітератор, що повертає всі елементи з <code>it</code>, що не задовільняють <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Підрозділення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it partition</p></td>
<td align="left" valign="top"><p class="table">Розділяє <code>it</code> на пару з двох ітераторів; один повертає всі елементи, що задовільняють предикатові <code>p</code>, інший повертає всі елементи з <code>it</code>, що ні.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Умови до елементів:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it forall</p></td>
<td align="left" valign="top"><p class="table">Логічне, вказує, чи предикат <code>p</code> дотримується до всіх елементів, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it exists</p></td>
<td align="left" valign="top"><p class="table">Логічне, вказує, чи предикат <code>p</code> виконується для деякого елементу, що повертає <code>it</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it count</p></td>
<td align="left" valign="top"><p class="table">Число елементів в <code>it</code>, що задовільняють предикату <code>p</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Згортки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(z /: it)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами, що повертає <code>it</code>, ідучи зліва направо, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">(it :\ z)(op)</p></td>
<td align="left" valign="top"><p class="table">Застосовує двомісну операцію <code>op</code> між послідовними елементами, що повертає <code>it</code>, ідучи зправа наліво, починаючи з <code>z</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.foldLeft(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що (z /: it)(op).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.foldRight(z)(op)</p></td>
<td align="left" valign="top"><p class="table">Те саме, що (it :\ z)(op).</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it reduceLeft op</p></td>
<td align="left" valign="top"><p class="table">Застосовує вдомірну операцію <code>op</code> між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it reduceRight op</p></td>
<td align="left" valign="top"><p class="table">Застосовує вдомірну операцію <code>op</code> між послідовними елементами, що повертає непорожній ітератор, ідучи зліва направо.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Специфічні згортки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.sum</p></td>
<td align="left" valign="top"><p class="table">Сума числових елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.product</p></td>
<td align="left" valign="top"><p class="table">Добуток значень числових елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.min</p></td>
<td align="left" valign="top"><p class="table">Мінімум впорядкованих елементів, що повертає ітератор.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.max</p></td>
<td align="left" valign="top"><p class="table">Максимум впорядкованих елементів, що повертає ітератор</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Поєднання:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it zip jt</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар відповідних елементів, що повертаються ітераторами <code>it</code> та <code>jt</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it zipAll (jt, x, y)</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар відповідних елементів, що повертаються ітераторами <code>it</code> та <code>jt</code>, де коротший ітератор розширюється, щоб співпадати з довшим, через додавання елементів <code>x</code> або <code>y</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it.zipWithIndex</p></td>
<td align="left" valign="top"><p class="table">Ітератор пар елементів, що повертаються <code>it</code> разом з індексами.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Оновлення:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it patch (i, jt, r)</p></td>
<td align="left" valign="top"><p class="table">Ітератор, отриманий з <code>it</code> заміною <code>r</code> елементів починаючи з <code>i</code> патч-ітератором <code>jt</code>.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Порівняння:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it sameElements jt</p></td>
<td align="left" valign="top"><p class="table">Перевіряє, чи ітератори <code>it</code> та <code>jt</code> повертають ті самі елементи в тому самому порядку. Увага: після цієї операції щонайменьше один з <code>it</code> та <code>jt</code> опиниться в кінці.</p></td>
</tr>
<tr>
<td colspan="2" align="left" valign="top"><p class="table">Рядки:</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it addString (b, start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Додає рядок до <code>StringBuilder</code> <code>b</code>, що показує всі елементи, повернуті <code>it</code> з роздільниками <code>sep</code>, оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональними.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">it mkString (start, sep, end)</p></td>
<td align="left" valign="top"><p class="table">Конвертує ітератор на рядоко, що показує всі елементи, що обмежені роздільникими <code>sep</code>, оточені рядками <code>start</code> та <code>end</code>. <code>start</code>, <code>sep</code> та <code>end</code> всі є опціональними.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="___57">Буферізовані ітератори</h3>
<div class="paragraph"><p>Іноді ви бажаєте ітератори, що можуть "заглядати наперед", так що ви можете інспектувати наступний елемент, що буде повернутий, без просування за цей елемент. Розглянемо, наприклад, завдання пропуску початкових порожніх рядків з ітератора, що повертає послідовність рядків. Ви можете підпасти в спокусу написати дещо подібне до такого метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це не працюватиме</span>
<span class="k">def</span> <span class="n">skipEmptyWordsNOT</span><span class="o">(</span><span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">().</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але подивіться на цей код ближче, ясно що він невірний: код вочевидь пропустить початкові порожні рядки, але він також просуне <code>it</code> за перший непорожній рядок!</p></div>
<div class="paragraph"><p>Рішення до цієї проблеми є використання буферизованого ітератора, примірника трейту <code>BufferedIterator</code>. <code>BufferedIterator</code> є субтрейтом <code>Iterator</code>, що провадить один додатковий метод, <code>head</code>. Виклик <code>head</code> на буферизованому ітераторі буде повертати його перший елемент, але не буде просувати ітератор. Використовуючи буферизований ітератор пропуск порожніх слів може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">skipEmptyWords</span><span class="o">(</span><span class="n">it</span><span class="k">:</span> <span class="kt">BufferedIterator</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний ітератор може бути конвертований на буферизований ітератор, через виклик його методу <code>buffered</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bit</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">buffered</span>
<span class="n">bit</span><span class="k">:</span> <span class="kt">java.lang.Object</span> <span class="kt">with</span> <span class="kt">scala.collection.</span>
<span class="kt">BufferedIterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bit</span><span class="o">.</span><span class="n">head</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що виклик <code>head</code> на буферизованому ітераторі, <code>bit</code>, не просуває його. Таким чином, наступний виклик <code>bit.next()</code> повертає те саме значення, що і <code>bit.head</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_16____">24.16 Створення колекцій з нуля</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви вже бачили синтаксис, як <code>List(1, 2, 3)</code>, що створює список з трьох цілих, та <code>Map('A' - &gt; 1, 'C' -&gt; 2)</code>, що створює мапу з двома парами прив'язок. Насправді це універсальна можливість Scala колекцій. Ви можете взяти любе ім'я колекції, та поставити після нього список елементів в дужках. Результат буде новою колекцією з наданими елементвами. Ось деякі інші приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Traversable</span><span class="o">()</span> <span class="c1">// Порожній перехідний об&#39;єкт</span>
<span class="nc">List</span><span class="o">()</span> <span class="c1">// Порожній список</span>
<span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span> <span class="c1">// Список з елементами 1.0, 2.0</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span> <span class="c1">// Вектор з елементами 1.0, 2.0</span>
<span class="nc">Iterator</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// Ітератор, що повертає три цілі.</span>
<span class="nc">Set</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">bird</span><span class="o">)</span> <span class="c1">// Множина з трьох тварин</span>
<span class="nc">HashSet</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">bird</span><span class="o">)</span> <span class="c1">// Хеш множина з тими ж тваринами</span>
<span class="nc">Map</span><span class="o">(</span><span class="sc">&#39;a&#39;</span> <span class="o">-&gt;</span> <span class="mi">7</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// Мапа з символів до цілих</span>
</pre></div></div></div>
<div class="paragraph"><p>"Під покровом" кожний з рядків вище викликає метод <code>apply</code> на деякому об'єкті. Наприклад, третій рядок розширюється до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що це виклик до метода <code>apply</code> об'єкта компанйона класу <code>List</code>. Метод приймає довільне число аргументів, та конструює з них список. Кожний клас колекції в бібліотеці Scala має метод <code>apply</code>. Не має значення, чи клас колекції представляє суцільну реалізацію, як <code>List</code>, <code>Stream</code> або <code>Vector</code>, або це трейт, такий як <code>Seq</code>, <code>Set</code> або <code>Traversable</code>. В останньому випадку виклик <code>apply</code> буде продукувати деяку реалізацію трейта по замовчанню. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Крім <code>apply</code> кожний об'єкт компанйон колекції визначає метод <code>empty</code>, що повертає порожню колекцію. Так що замість <code>List()</code> ви можете написати <code>List.empty</code>, замість <code>Map()</code> - <code>Map.empty</code>, і так далі.</p></div>
<div class="paragraph"><p>Нащадки трейтів <code>Seq</code> також провадять інші операції фабрик в своїх об'єктах компанйонах. Вони підсумовані в Таблиці 24.13. Скорочено це виглядає так:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>concat</code> конкатенує довільне число перехідних разом
</p>
</li>
<li>
<p>
<code>fill</code> та <code>tabulate</code>, що генерують одно- або багато-вимісні послідовності, ініціалізовані деякими виразами або функцією табуляції
</p>
</li>
<li>
<p>
<code>range</code>, яка генерує цілі послідовності з деяким заданим кроком
</p>
</li>
<li>
<p>
<code>iterate</code>, що генерує послідовність, як результат від повторного застосування функції до початкового елемента.
</p>
</li>
</ul></div>
<div class="paragraph"><p>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">S.empty</p></td>
<td align="left" valign="top"><p class="table">Порожня послідовність</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S(x, y, z)</p></td>
<td align="left" valign="top"><p class="table">Послідовність з елементів <code>x</code>, <code>y</code> та <code>z</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.concat(xs, ys, zs)</p></td>
<td align="left" valign="top"><p class="table">Послідовність, отримана як конкатенація елементів <code>xs</code>, <code>ys</code> та <code>zs</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.fill(n)(e)</p></td>
<td align="left" valign="top"><p class="table">Послідовність довжини <code>n</code>, де кожний елемент обчисляється як вираз <code>e</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.fill(m, n)(e)</p></td>
<td align="left" valign="top"><p class="table">Послідовність послідовностей розміром <code>m x n</code>, де кожний елемент обчислюється як вираз <code>e</code> (існує також для більших розмірнестей)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.tabulate(n)(f)</p></td>
<td align="left" valign="top"><p class="table">Послідовність довжини <code>n</code>, де елемент для кожного індексу <code>i</code> обчислюється як <code>f(i)</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.tabulate(m, n)(f)</p></td>
<td align="left" valign="top"><p class="table">Послідовність послідовностей розміром <code>m x n</code>, де елемент з індексом <code>(i, j)</code> обчислюється як <code>f(i, j)</code> (існує також для більших розмірностей)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.range(start, end)</p></td>
<td align="left" valign="top"><p class="table">Послідовність цілих <code>start ... end - 1</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.range(start, end, step)</p></td>
<td align="left" valign="top"><p class="table">Послідовність цілих, що починається зі <code>start</code>, та продовжується з кроком <code>step</code> до значення <code>end</code>, виключно</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">S.iterate(x, n)(f)</p></td>
<td align="left" valign="top"><p class="table">Послідовність довжини <code>n</code> з елементами <code>x</code>, <code>f(x)</code>, <code>f(f(x))</code>, &#8230;</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_24_17____java__scala">24.17 Перетворення між колекціями Java і Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як Scala, Java має багату бібліотеку колекцій. Існує багато подібного між ціма двома. Наприклад, обоє знають про ітерації, ітерабельні, множини, мапи та послідовності. Але також існують важливі відмінності. Зокрема, бібліотеки Scala роблять значно більший наголос на незмінні колекції, та провадять значно більше операцій, що трансформують колекції в нові.</p></div>
<div class="paragraph"><p>Іноді вам треба конвертувати колекцію з ощного фреймфорка в інший. Наприклад, ви можете отримати доступ до існуючої Java колекції, так, якби це була Scala. Або ви можете забажати одну зі Scala колекцій до Java методу, що очікує Java варіант. Зробити це досить легко, оскільки Scala пропонує неявні перетворення між всіма головними типами колекцій в об'єкт <code>JavaConversions</code>. Зокрема, ви знайдете двосторонні перетворення між наступними типами:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Iterator</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Iterator</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Iterator</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Enumeration</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Iterable</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.lang.Iterable</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Iterable</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Collection</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Buffer</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.List</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Set</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Set</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Map</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Mapx</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Щоб дозволити ці перетворення, просто імпортуйте їх, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.JavaConversions._</span>
<span class="k">import</span> <span class="nn">collection.JavaConversions._</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви маєте автоматичні перетворення між колекціями Scala, та відповідними колекціями Java.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.mutable._</span>
<span class="k">import</span> <span class="nn">collection.mutable._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">jul</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">java.util.Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">HashMap</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">m</span><span class="k">:</span> <span class="kt">java.util.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span><span class="n">hello</span><span class="k">=</span><span class="mi">2</span><span class="o">,</span> <span class="n">abc</span><span class="k">=</span><span class="mi">1</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Внутрішньо ці перетворення роблять через встановлення об'єкта "огортки", що пересилає всі операції до підлеглого об'єкта колекції. Так що колекції ніколи не копіюються, коли конвертуються між Java та Scala. Цікава властивість в тому, що якщо ви робите кругову конверсію, скажімо, Java типу до відповідного типу Scala, та назад до того самого типу Java, ви скінчите з об'єктом ідентичного типу, до того, з якого починали.</p></div>
<div class="paragraph"><p>Деякі інші загальні Scala колекції також можуть бути конвертовані до Java типів, але для яких немає відповідного перетворення в іншому напрямку:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Seq</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.List</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">mutable.Seq</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.List</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Set</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Set</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Map</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">java.util.Map</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Оскільки Java не розрізняє між змінними та незмінними колекціями в своїх типах, перетворення зі, скажімо, <code>collection.immutable.List</code> буде давати <code>java.util.List</code>, на якому всі операції змін будуть закидати <code>UnsupportedOperationException</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="err">1</span>, <span class="err">2</span>, <span class="err">3</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">jul</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">UnsupportedOperationException</span>
<span class="n">at</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">AbstractList</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="nc">AbstractList</span><span class="o">.</span><span class="n">java</span><span class="k">:</span><span class="err">131</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<h1 id="_24_18_">24.18 Висновок</h1>
<div class="paragraph"><p>Тепер ви побачили, як використовувати Scala колекції дуже детально. Колекції Scala приймають підхід надання вам потужних будівельних блоків, скоріше, ніж декількох споміжних методів на підхваті. Покладаючи поряд два або три такі будівельні блоки, дозволяє вам виразити величезну кількість коричних обчислень. Цей стиль бібліотек особливо ефективний через те, що Scala має легкий синтаксис для функціональних літералів, та через те, що вона провадить багато типів колекцій, що стійкі та незмінні.</p></div>
<div class="paragraph"><p>Ця глава показала колекції з точки зору програміста, що використовує бібліотеку колекцій. Наступна глава покаже вам, як колекції побудовані, та як ви можете додати власні типи колекцій.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="sect1">
<h2 id="__25_2">Глава 25</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___scala_3">Архитектура колекцій Scala</h1>
<div class="paragraph"><p>Ця глава описує архитектуру фреймворка колекцій Scala в деталях. Продовжуючи тему Глави 24, ви знайдете більше щодо внутрішньої роботи фреймворка. Ви також навчитесь, як ця архитектура допомагає вам визначити ваші власні колекції в декількох рядках коду, при цьому використовуючи значну частину функціональності колекцій з фреймворку.</p></div>
<div class="paragraph"><p>Глава 24 перелічує велику кількість операцій з колекціями, що існують одноманітно на великій кількості реалізацій колекцій. Реалізація кожної операції колекцій поновій для кожного типу колекцій може призвести до значного обсягу коду, більшість якого буде копіюваться з інших місць. Така дублікація коду може з часом призвести до неузгодженості, коли операція додається або модифікується в одній частині бібліотеки колекцій, але не інших. Принципова ціль розробки фреймворка нових колекцій було уникнути жодних дублікацій, визначення кожної операції в стількох небагатьох місцях, наскільки це можливо.<span class="footnote"><br />[Ідеально все має бути визначено тільки в одному місці, але є декілька виключень, де речі мають бути перевизначені.]<br /></span> Підхід розробки полягав в визначенні більшость операцій в "шаблонах" колекцій, що можуть бути гнучко наслідувані від окремих базових класів та реалізацій. В цій главі ми дослідимо ці шаблони, та інші класи і трейти, що складають "будівельні блоки" фреймворка, так само, як принципи конструкції, які вони підтримують.</p></div>
<div class="sect1">
<h2 id="_25_1_">25.1 Будівельники</h2>
<div class="sectionbody">
<div class="paragraph"><p>Майже всі операції колекцій реалізовані в термінах проходів та будівельників. Перехідні обробляються методом <code>Traversable</code> <code>foreach</code>, та побудова новий колекцій обробляється примірниками класу <code>Builder</code>. Лістинг 25.1 представляє дещо скорочений конутр цього класу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection.generic</span>
<span class="k">class</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+=(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.type</span>
  <span class="k">def</span> <span class="n">result</span><span class="o">()</span><span class="k">:</span> <span class="kt">To</span>
  <span class="k">def</span> <span class="n">clear</span><span class="o">()</span>
  <span class="k">def</span> <span class="n">mapResult</span><span class="o">[</span><span class="kt">NewTo</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">To</span> <span class="o">=&gt;</span> <span class="nc">NewTo</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">NewTo</span><span class="o">]</span>
  <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.1 - Контур класу <code>Builder</code>.</p></div>
<div class="paragraph"><p>Ви можете додати елемент <code>x</code> до білдера <code>b</code> за допомогою <code>b += x</code>. Також є синтаксис для додавання більше одного елемента за раз: наприклад <code>b += (x, y)</code> та <code>b ++= xs</code> роблять як для буферів. (Фактично, буфери є підсиленими версіями будівельників). Метод  <code>result()</code> повертає колекцію з будівельника. Стан будівельника невизначений після отримання його результату, але він може бути скинутий в новий порожній стан з використанням <code>clear()</code>. Будівельники є дженеріками по обох, типі елементів <code>Elem</code>, та по <code>To</code>, типу колекції, яку він повертає.</p></div>
<div class="paragraph"><p>Часто будівельник може посилатись на деякий інший будівельник для збирання елементів колекції, але потім трансформує результат іншого будівництва, щоб отримати інший тип. Це завдання спрощене методом <code>mapResult</code> в класі <code>Builder</code>. Уявімо, наприклад, що ви маєте буфер масиву <code>buf</code>. Буфери масивів є будівельниками для самих себе, так що отримання  <code>result()</code> буфера масива буде повертати той самий буфер. Якщо ви бажаєте використовувати цей буфер для продукування будівельника, що будує масиви, ви можете використати <code>mapResult</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bldr</span> <span class="k">=</span> <span class="n">buf</span> <span class="n">mapResult</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toArray</span><span class="o">)</span>
<span class="n">bldr</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Builder</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
    <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення результату <code>bldr</code> є будівельник, що використовує буфер масивів <code>buf</code> для збирання елементів. Коли треба результат від <code>bldr</code> обчислюється результат <code>buf</code>, що дає сам буфер масива <code>buf</code>. Цей буфер потім відображується за допомогою <code>_.toArray</code> на масив. Так що кінцевий результат в тому, що <code>bldr</code> є будівельник для масивів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_25_2___">25.2 Виділення загальних операцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Головними цілями дизайну бібліотеки колекцій є мати одночасно природні типи та максимальне поділення коду реалізації. Зокрема, колекції Scala слідують принципу "того самого результату": коли це можливо, метод трансформації для колекції буде видавати колекцію того самого типу. Наприклад, операція <code>filter</code> має видавати на кожному типу колекцій примірник того самого типу. Застосування <code>filter</code> до <code>List</code> повинно давати <code>List</code>; застосування його до <code>Map</code> має давати <code>Map</code>; і так далі. В залишку цього розділу ви побачите, як це досягається.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___58">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>Матеріал в цьому розділу трохи плотніший ніж звичайно, та може потребувати часу для сприйняття. Якщо ви бажаєте рухатись вперед швидко, ви можете пропустити залишок цього розділу, та перейти до Розділу 25.3, де ви навчатиметесь на конкретних прикладах, як інтегрувати ваші власні класи колекцій в фреймворк.</p></div>
<div class="paragraph"><p>Бібліотека колекцій Scala уникає дублікації коду, та досягає принциту "того самого результату" через використання дженерік будівельників та проходах по колекціях в так званих трейтах реалізації. Ці трейти названі з суфіксом <code>Like</code>; наприклад, <code>IndexedSeqLike</code> є трейтом реалізаціх для <code>IndexedSeq</code>, та подібно до цього, <code>TraversableLike</code> є трейтом реалізації для <code>Traversable</code>. Класи колекції, такі як <code>Traversable</code> або <code>IndexedSeq</code>, наслідують всі свої суцільні методи реалізації від ціх трейтів. Трейти реалізації мають два параметри типу, замість одного для нормальних колекцій. Вони параметризують не тільки тип елементів колекції, але також тип репрезентації колекції (тобто тип підлеглої колекції), такий як <code>Seq[I]</code> або <code>List[T]</code>.</p></div>
<div class="paragraph"><p>Наприклад, ось заголовок трейта <code>TraversableLike</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметр типу <code>Elem</code> означає тип елемента перехідного, тоді як параметр типу <code>Repr</code> означає тип репрезентації. Немає обмежень на <code>Repr</code>. Зокрема, <code>Repr</code> може бути втілено в тип, що сам не є субтипом <code>Traversable</code>. Таким чином, класи за межами ієрархії колекцій, такі як <code>String</code> та <code>Array</code>, все ще можуть використовувати всі операції, визначені в трейті реалізації колекції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection</span>
<span class="k">trait</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="c1">// відкладене</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
<span class="c1">// відкладене</span>
            <span class="o">...</span>
  <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">newBuilder</span>
    <span class="n">foreach</span> <span class="o">{</span> <span class="n">elem</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">elem</span> <span class="o">}</span>
    <span class="n">b</span><span class="o">.</span><span class="n">result</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.2 - Реалізація <code>filter</code> в <code>TraversableLike</code>.</p></div>
<div class="paragraph"><p>Беручи <code>filter</code> в якості приклада, ця операція визначається один раз для всіх класів колекцій в трейті <code>TraversableLike</code>. Нарис відповідного коду показаний в Лістингу 25.2. Трейт декларує два абстрактні методи, <code>newBuilder</code> та <code>foreach</code>, що реалізовані в суцільних класах колекцій. Операція <code>filter</code> реалізована в однаковий спосіб для всіх колекцій, використовуючи ці методи. Він зпочатку конструює нового будівельника для типу репрезентації <code>Repr</code>, використовуючи <code>newBuilder</code>. Потім він проходить по всіх елементах поточної колекції з використанням <code>foreach</code>. Якщо елемент <code>x</code> задовільняє наданому предикату <code>p</code> — тобто, <code>p(x)</code> є <code>true</code> — елемент додається через будівельника. Нарешті, елементи, що побудовані в будівельнику, повертаються як примірник типу колекції <code>Repr</code>, через виклик метода будівельника <code>result</code>.</p></div>
<div class="paragraph"><p>Операція <code>map</code> на колекціях трохи більш складна. Наприклад, як <code>f</code> є функція від <code>String</code> до <code>Int</code>, і <code>xs</code> є <code>List[String]</code>, тоді <code>xs map f</code> має видавати <code>List[Int]</code>. Подібним чином, якщо <code>ys</code> є <code>Array[String]</code>, тоді <code>ys map f</code> повинно давате <code>Array[Int]</code>. Але як ви досягнете цього, без дублікації визначення метода <code>map</code> в списках та масивах?</p></div>
<div class="paragraph"><p>Фреймворк <code>newBuilder</code>/<code>foreach</code>, показаний в Лістингу 25.2, недостатній для цього, оскільки він дозволяє створення нових примірників того самого типу колекцій, тоді як <code>map</code> потребує примірник того самого типу конструктора, але можливо з іншим типом елемента. Більше того, навіть конструктор результуючого типу функції як <code>map</code>, може залежати в нетрівіальний спосіб від типів інших аргументів. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.immutable.BitSet</span>
<span class="k">import</span> <span class="nn">collection.immutable.BitSet</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toFloat</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви відобразите бітову множину через функцію подвоєння <code>_ * 2</code>, ви отримєте іншу бітову множину. Однак, якщо ви відобразите ту ж множину через функцію <code>(_.toFloat)</code>, результатом буде загальний <code>Set[Float]</code>. Звичайно, це не може бути бітова множина, бо бітові множини містять <code>Int</code>, не <code>Float</code>.</p></div>
<div class="paragraph"><p>Зауважте, що тип результата <code>map</code> залежить від типу функції, що передається до нього. Якщо тип результата цього функціонального аргумента знову <code>Int</code>, результатом <code>map</code> буде <code>BitSet</code>. Але якщо тип результату функціонального аргументу є щось інше, результатом <code>map</code> є простий <code>Set</code>. Скоро ви з'ясуєте, як досягається ця гнучкість типів в Scala.</p></div>
<div class="paragraph"><p>Проблема з <code>BitSet</code> не є ізольованим випадком. Ось дві інші взаємодії з інтерпретатором, що відображують функцію через <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;b&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;b&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">}</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перша функція обмінює два аргументи пари ключ/значення. Результат відображення цієї функції є знову мапа, але тепер ідемо в іншому напрямку. Фактично, перший вираз дає інверсію оригінальної мапи, зважаючи, що це можливо зробити. Однак друга функція відображує пару ключ/значення на ціле, а саме на частину значення. В цьому випадку ми не можемо сформувати з результату <code>Map</code>, але ми все ще можемо сформувати <code>Iterable</code>, супертрейт <code>Map</code>.</p></div>
<div class="paragraph"><p>Ви можете запитати, чому не обмежити <code>map</code> так, щоб він завжди повертав той самий тип колекції? Наприклад, на бітових множинах <code>map</code> міг би сприймати тільки функції <code>Int</code>-до-<code>Int</code>, та на мапах він міг би сприймати тільки функції пара-до-пари. Це обмеження не тільки небажане з об'єктно-орієнтовної точки зору, воно також нелегальне, бо це порушує принцип підстановки Ліскова: якщо <code>Map</code> є <code>Iterable</code>, кожна операція, що є легальною на <code>Iterable</code>, мусить бути легальною на <code>Map</code>.</p></div>
<div class="paragraph"><p>Замість цього Scala вирішує цю проблему за допомогою перевантаження: не тої простої форми перевантаження, наслідуваної від Java (що не може бути достатньо гнучкою), але більш систематичної форми перевантаження, що провадиться через неявні параметри.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">bf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">bf</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">)</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">result</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.3 - Реалізація <code>map</code> в <code>TraversableLike</code>.</p></div>
<div class="paragraph"><p>Лістинг 25.3 показує трейт <code>TraversableLike</code> в частині реалізації <code>map</code>. Це досить подібно до реалізації <code>filter</code>, показаного в Лістингу 25.2. Принципова різниця в тому, що <code>filter</code> використовує метод <code>newBuilder</code>, що є абстрактним в класі <code>TraversableLike</code>, але <code>map</code> використовує фабрику будівельника, що передається як додатковий неявний параметр типу <code>CanBuildFrom</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection.generic</span>
<span class="k">trait</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
<span class="c1">// Створює нового будівельника</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">From</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.4 - Трейт <code>CanBuildFrom</code>.</p></div>
<div class="paragraph"><p>Лістинг 25.4 показує визначення трейта <code>CanBuildFrom</code>, що представляє фабрики будівельниуів. Він має три параметри типу: <code>Elem</code> вказує тип елемента колекції, що має бути побудована, <code>To</code> вказує на тип колекції, що будується, та <code>From</code> вказує тип, для якого застосовуєть ця фабрика будівельників. Через визначення правильних неявних визначень фабрик будівельника, ви можете викроїти вірну поведінку типів, як треба.</p></div>
<div class="paragraph"><p>Візьмемо клас <code>BitSet</code> в якості приклада. Його об'єкт компанйон містить фабрику будівельника типу <code>CanBuildFrom[BitSet, Int, BitSet]</code>. Це означає, що коли робите з <code>BitSet</code>, ви можете сконструювати інший <code>BitSet</code>, маючи що тип колекції для побудови є <code>Int</code>. Якщо це не так, ви завжди можете відкотитись до різних інших неявних фабрик будівельника, на цей раз реалізованих в об'єкті компанйоні <code>mutable.Set</code>. Тип цієї, більш загальної, фабрики будівельника, де <code>A</code> є дженерік параметр типу, такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це означає, що коли ви оперуєте з довільним <code>Set</code>, вираженим типом з підстановкою <code>Set[_]</code>, ви знову можете побудувати <code>Set</code>, неважливо, який є тип елементу <code>A</code>. Маючи ці два неявні примірника <code>CanBuildFrom</code>, ви можете покладатись на правила Scala щодо розрішення неявних, щоб обрати той варіант, що відповідає ситуації і є найбільш специфічним.</p></div>
<div class="paragraph"><p>Так що неявне розрішення провадить коректні статичні типи для складних операцій з колекціями, як <code>map</code>. Але що до динамічних типів? Зокрема, скажімо, якщо ви маєте значення списку, що має <code>Iterable</code> як свій статичний тип, і ви відображуєте деяку функцію по цьому значенню:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>
<span class="n">ys</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Статичний тип <code>ys</code> вище є <code>Iterable</code>, як і очікувалось. Але його динамічний тип є (і має бути) <code>List</code>! Ця поведінка досягається ще одним перенаправленням. Метод <code>apply</code> в <code>CanBuildFrom</code> отримує колекцію джерела як аргумент. Більшість фабрик будівельника для дженеріків перехідних (фактично всі, за винятком фабрик будівельника для класів листів) пересилають виклик до метода <code>genericBuilder</code> колекції.</p></div>
<div class="paragraph"><p>В свою чергу метод <code>genericBuilder</code> викликає будівельник, що належить до колекції, в якій він визначений. Так що Scala використовує неявне розрішення для визначення обмежень по типах <code>map</code>, та віртуально скеровує для обрання кращого динамічного типу, що відповідає цім обмеженням.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_25_3___">25.3 Інтеграція нових колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Що треба зробити, якщо ви бажаєте інтегрувати новий клас колекції, так щоб ви могли отримати вигоди від всіх попередньо визначених операцій від правильних типів? В цьому розділі ми покажемо вам два приклада як це робиться.</p></div>
<div class="sect2">
<h3 id="___59">Інтеграція послідовностей</h3>
<div class="paragraph"><p>Скажімо, ви бажаєте створити новий тип послідовності для спіралей РНК, що є послідовностями основ: A (аденін), T (тимін), G (гуанін) та U (урацил). Визначення для основ встановлюються просто, як показано на Лістингу 25.5.</p></div>
<div class="paragraph"><p>Кожна база визначена як кейс об'єкт, що наслідує від загального абстрактного класу <code>Base</code>. Клас <code>Base</code> має об'єкт компанйон, що визначає дві функції, які пов'язують основи з цілими від 0 до 3. Ви можете побачити на прикладах два різні шляхи використовувати колекції для реалізації ціх функцій. Функція <code>toInt</code> реалізована як <code>Map</code> від значень  <code>Base</code> на цілі. Зворотня функція, <code>fromInt</code>, реалізована як масив. Це використовує факт, що обоє, мапи та масиви є функціями, оскільки вони наслідують від трейта <code>Function1</code>.</p></div>
<div class="paragraph"><p>Наступне завдання визначити клас для спіралей РНК. Концептуально такий ланцюжок РНК є просто <code>Seq[Base]</code>. Однак ланцюжок РНК може стати досить довгим, так що має сенс докласти деякої роботи для компактної репрезентації. Оскільки основ тільки чотири, основа може бути ідентифікована чотирьма бітами, і ви можете зберігати шістнадцять основ в двобайтному значенні як ціле. Тоді ідея побудувати особливий клас <code>Seq[Base]</code>, що використовує цю запаковану репрезентацію.</p></div>
<div class="paragraph"><p>Лістинг 25.6 представляє першу версію цього класу; пізніше вона буде покращена. Клас RNA1 має конструктор, що приймає масив з <code>Int</code> в якості першого елемента. Цей масив містить запаковані дані RNA з шістнадцятьма основами на один елемент, за винятком останнього елементу масива, що може бути заповнений частково. Другий аргумент, довжина, вказує загальну кількість основ в масиві (та в послідовності). Клас <code>RNA1</code> розширює <code>IndexedSeq[Base]</code>. Трейт <code>IndexedSeq</code>, що надходить з пакунка <code>scala.collection.immutable</code>, визначає два абстрактні методи, <code>length</code> та <code>apply</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">T</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">G</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">U</span> <span class="k">extends</span> <span class="nc">Base</span>

<span class="k">object</span> <span class="nc">Base</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">fromInt</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Base</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">toInt</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">G</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">U</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.5 - Основи РНК.</p></div>
<div class="paragraph"><p>Ці методи мають бути реалізованими в суцільних субкласах. Клас <code>RNA1</code> реалізує <code>length</code> автоматично, через визначення параметрического поля (описане в Розділі 10.6) з саме таким ім'ям. Він реалізує метод індексації <code>apply</code> за допомогою кода, наданому в Лістингу 25.6. По суті <code>apply</code> зпочатку виділяє ціле значення з масиву <code>groups</code>, потім виділяє коректне двобітне число з цього цілого з використанням зсува (&gt;&gt;) та маски (&amp;). Приватні константи <code>S</code>, <code>N</code> та <code>M</code> надходять від об'єкта компанйона <code>RNA1</code>. <code>S</code> вказує розмір кожного пакета (тобто, два); <code>N</code> задає число двобітних пакетів в цілому; нарешті, <code>M</code> є бітова маска, що ізолює молодші <code>S</code> біт в слові.</p></div>
<div class="paragraph"><p>Зауважте, що конструктор класу <code>RNA1</code> є приватним. Це означає, що клієнти не можуть створювати послідовності <code>RNA1</code> через виклик <code>new</code>, що має сенс, оскільки приховує реалізацію послідовностей <code>RNA1</code> в термінах запакованих масивів від користувача. Якщо клієнти не можуть бачити, які деталі репрезентації послідовностей РНК, стає можливим змінити цю репрезентацію в любій точці в майбутньому, не впливаючи на клієнтській код.</p></div>
<div class="paragraph"><p>Іншими словами, цей дизайн досягає гарного розділення інтерфейса РНК послідовностей, та його реалізації. Однак, якщо конструювання РНК послідовності за допомогою <code>new</code> неможливе, має бути якійсь інший шлях створювати нові РНК послідовності, або інакше цілий клас буде скоріше некорисним. Є дві альтернативи для створення РНК послідовності, обоє провадяться об'єктом компанйоном <code>RNA1</code>. Перший шлях є метод <code>fromSeq</code>, що конвертує надану послідовність основ (тобто значення типу <code>Seq[Base]</code>) в послідовність класу <code>RNA1</code>. Метод <code>fromSeq</code> робить це через пакування всіх основ, що містяться в послідовності аргументі в масив, потім викликаючи приватний конструктор RNA1 з цім масивом та довжиною оригінальної послідовності в якості аргументів. Це задіє використання факта, що приватний конструктор видимий до об'єкта компанйона класу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">collection.IndexedSeqLike</span>
<span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">Builder</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">collection.generic.CanBuildFrom</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">RNA1</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span>
    <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA1._</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>
    <span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">groups</span><span class="o">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">RNA1</span> <span class="o">{</span>
<span class="c1">// Число біт для представлення групи</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">S</span> <span class="k">=</span> <span class="mi">2</span>

<span class="c1">// Число груп, що містяться в Int</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="mi">32</span> <span class="o">/</span> <span class="n">S</span>

<span class="c1">// Бітова маска для ізоляції групи</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="k">def</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Base</span><span class="o">])</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">groups</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]((</span><span class="n">buf</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">|=</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span><span class="o">(</span><span class="n">buf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span>
    <span class="k">new</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">bases</span><span class="k">:</span> <span class="kt">Base*</span><span class="o">)</span> <span class="k">=</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">bases</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.6 - Перша версія класу РНК ланцюжків.</p></div>
<div class="paragraph"><p>Другий спосіб створити значення <code>RNA1</code> є провадження метода <code>apply</code> в об'єкті <code>RNA1</code>. Він приймає змінне число аргументів <code>Base</code>, та просто пересилає їх як послідовність до <code>fromSeq</code>.</p></div>
<div class="paragraph"><p>Ось обидві схеми створення в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Product</span> <span class="kt">with</span> <span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">RNA1</span><span class="o">.</span><span class="n">fromSeq</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna1</span> <span class="k">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna1</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____code_rna_code">Адаптація типу результатів методів <code>RNA</code></h3>
<div class="paragraph"><p>Ось ще деякі інтеракції з абстракцією <code>RNA1</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna1</span><span class="o">.</span><span class="n">length</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna1</span><span class="o">.</span><span class="n">last</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="n">T</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna1</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перші два результати виглядають очікуваними, але останній результат отримання трьох елементів від <code>rna1</code>, можливо, ні. Фактично, ви бачите <code>IndexedSeq[Base]</code> як статичний тип результату, та <code>Vector</code> як динамічний тип значення результату. Ви можливо очікували замість цього отримати значення <code>RNA1</code>. Але це неможливо, оскільки все, що ми зробили в Лістингу 25.6, це зробили <code>RNA1</code> розширенням <code>IndexedSeq</code>. Клас <code>IndexedSeq</code>, з іншого боку, має метод <code>take</code>, що повертає <code>IndexedSeq</code>, і це реалізоване в термінах реалізації <code>IndexedSeq</code> по замовчанню, а саме <code>Vector</code>.</p></div>
<div class="paragraph"><p>Тепер, коли ви зрозуміли, чому все відбувається як відбувається, наступне запитання має бути: що треба зробити, щоб змінити це? Один спосіб зробити це може бути перекрити метод <code>take</code> в класі <code>RNA1</code>, можливо так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">take</span><span class="o">(</span><span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">.</span><span class="n">fromSeq</span><span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="n">count</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Це зробить свою роботу для <code>take</code>. Але як щодо <code>drop</code>, або <code>filter</code>, або <code>init</code>? Фактично є більше п'ятидесяти методів на послідовностях, що знову повертають послідовність. Для сумісності всі вони мають бути перекриті. Це менше і менше виглядає як приваблива опція.</p></div>
<div class="paragraph"><p>Нащастя, існує значно простіший спосіб досягти того самого ефекту. Клас <code>RNA</code> має наслідувати не тільки від <code>IndexedSeq</code>, але також від його трейта реалізації <code>IndexedSeqLike</code>. Це показане в Лістингу 25.7. Нова реалізація відрізняється від попередньої тільки в двох аспектах. Перше, клас <code>RNA2</code> тепер також розширяє <code>IndexedSeqLike[Base, RNA2]</code>. Трейт <code>IndexedSeqLike</code> реалізує всі суцільні методи <code>IndexedSeq</code> в розширюваний спосіб.</p></div>
<div class="paragraph"><p>Наприклад, тип повернення методів як <code>take</code>, <code>drop</code>, <code>filter</code> або <code>init</code> є другим параметром типу, переданим до класу <code>IndexedSeqLike</code> (тобто, <code>RNA2</code> в Лістингу 25.7). Щоб зробити це, <code>IndexedSeqLike</code> базує себе на абстракції <code>newBuilder</code>, що створює будівельник правильного різновиду. Субкласи трейту <code>IndexedSeqLike</code> мають перекрити <code>newBuilder</code>, щоб повертати колекції свого власного типу. В класі <code>RNA2</code> метод  <code>newBuilder</code> повертає будівельника типу <code>Builder[Base, RNA2]</code>. Щоб сконструювати цього будівельника він спочатку створює <code>ArrayBuffer</code>, що сам є <code>Builder[Base, ArrayBuffer]</code>. Потім він трансформує будівельник <code>ArrayBuffer</code> через власний метод <code>mapResult</code> до будівельника <code>RNA2</code>. Метод <code>mapResult</code> очікує функцію трансформації від <code>ArrayBuffer</code> до <code>RNA2</code> в якості параметра. Функція є просто <code>RNA2.fromSeq</code>, що конвертує довільну базову послідовність на значення <code>RNA2</code> (згадайте, що буфер масива є різновид послідовності, так що до нього може бути застосований <code>RNA2.fromSeq</code>).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">class</span> <span class="nc">RNA2</span> <span class="k">private</span> <span class="o">(</span>
  <span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">with</span> <span class="nc">IndexedSeqLike</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA2</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA2._</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA2</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="n">mapResult</span> <span class="n">fromSeq</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="c1">// як раніше</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.7 - Клас ланцюжка РНК, друга версія.</p></div>
<div class="paragraph"><p>Якщо ви забудете визначення <code>newBuilder</code>, ви отримаєте повідомлення про помилку, приблизно такого змісту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">RNA2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">5</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">overriding</span> <span class="kt">method</span> <span class="kt">newBuilder</span> <span class="kt">in</span> <span class="kt">trait</span>
<span class="nc">TraversableLike</span> <span class="n">of</span> <span class="k">type</span> <span class="o">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Builder</span><span class="o">[</span><span class="kt">Base</span>,<span class="kt">RNA2</span><span class="o">];</span>
  <span class="n">method</span> <span class="n">newBuilder</span> <span class="n">in</span> <span class="k">trait</span> <span class="nc">GenericTraversableTemplate</span> <span class="n">of</span> <span class="k">type</span>
  <span class="o">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Builder</span><span class="o">[</span><span class="kt">Base</span>,<span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]]</span> <span class="n">has</span>
  <span class="n">incompatible</span> <span class="k">type</span>
<span class="kt">class</span> <span class="kt">RNA2</span> <span class="kt">private</span> <span class="o">(</span><span class="kt">val</span> <span class="kt">groups:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
      <span class="o">^</span>
<span class="n">one</span> <span class="n">error</span> <span class="n">found</span>
</pre></div></div></div>
<div class="paragraph"><p>Повідомлення про помилку досить довге та заскладне, що відзеркалює плутаний шлях, яким бібліотеки колекцій складаються докупи. Краще проігнорувати інформацію щодо того, звідки походять методи, бо це випадок, коли це більше заважає, ніж допомагає. Що залишається, це те, що метод <code>newBuilder</code> з типом результата <code>Builder[Base, RNA2]</code> має бути визначений, але був знайдений лише метод <code>newBuilder</code> з типом результата <code>Builder[Base,IndexedSeq[Base]]</code>. Останній не перекриває попередній.</p></div>
<div class="paragraph"><p>Перший метод, чий тип результата <code>Builder[Base, RNA2]</code>, є абстрактним методом, що був втілений в цьому типі в Лістингу 25.7, через передачу параметра типу до <code>IndexedSeqLike</code>. Другий метод, з типом результата <code>Builder[Base,IndexedSeq[Base]]</code>, є те, що провадиться наслідуваним класом <code>IndexedSeq</code>. Іншими словами, клас <code>RNA2</code> є невалідним без визначення <code>newBuilder</code> з першим типом результата.</p></div>
<div class="paragraph"><p>З покращеною реалізацією класа <code>RNA</code> в Лістингу 25.7, методи як <code>take</code>, <code>drop</code> або <code>filter</code> роблять як очікується:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna2</span> <span class="k">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna2</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="n">take</span> <span class="mi">3</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="n">filter</span> <span class="o">(</span><span class="n">U</span> <span class="o">!=)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_map_code__">Справи з <code>map</code> та друзями</h3>
<div class="paragraph"><p>Існує інший клас методів, з якими ми досі не мали справи. Ці методи не завжди повертають колекцію точно того самого типу. Вони можуть повернути той самий різновид колекції, але з іншим типом елементів. Класичним прикладом є метод <code>map</code>. Якщо є <code>Seq[Int]</code>, та <code>f</code> є функція від <code>Int</code> до <code>String</code>, тоді <code>s.map(f)</code> буде повертати <code>Seq[String]</code>. Так що тип елементу змінюється від отримувача до результата, але різновид колекції залишається такий самий.</p></div>
<div class="paragraph"><p>Існує декілька інших методів, що поводяться як <code>map</code>. Для деяких з них ви можете очікувати цього (як <code>flatMap</code>, <code>collect</code>), але від інших ні. Наприклад, метод додавання, <code>++</code>, також може повертати результат, тип якого відрізняється від його аргументів — додавання списку зі <code>String</code> до списку <code>Int</code> буде давати список з <code>Any</code>. Як ці методи мають бути адаптовані до ланцюжків <code>RNA</code>? В ідеалі ми очікуємо, що відображення від основи до основи на РНК має знову давати ланцюжок РНК:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna</span> <span class="k">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">case</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">}</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібним чином, додавання двох ланцюжків за допомогою <code>++</code> має давати новий ланцюжор РНК:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="o">++</span> <span class="n">rna</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку, відображення основи на якійсь інший тип на РНК ланцюжку не може дати новий ланцюжок, оскільки нові елементи мають не той тип. Замість цього буде видана послідовність. В тому ж дусі, додавання елементів, що не є типу <code>Base</code> до ланцюжка дає загальну послідовність, але ніколи не може дати новий ланцюжок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="n">map</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;missing&quot;</span><span class="o">,</span> <span class="s">&quot;data&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">java.lang.Object</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Vector</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">missing</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те, що ми очікуємо в ідеальному випадку. Але це не те, що провадить клас <code>RNA2</code>, як він є в Лістингу 25.7. Фактично, якщо ви запустите перші два приклади вище з цім класом, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna2</span> <span class="k">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna2</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">case</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">}</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="o">++</span> <span class="n">rna2</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що результат <code>map</code> та <code>++</code> ніколи не буде ланцюжком, навіть якщо тип елементів згенерованої колекції буде <code>Base</code>. Щоб побачити, як зробити краще, має сенс подивитись на сигнатуру метода <code>map</code> (або <code>++</code>, що має подібну сигнатуру). Оригінально метод <code>map</code> визначений в класі <code>scala.collection.TraversableLike</code> з наступною сигнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cbf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>Elem</code> є типом елементів колекції, та <code>Repr</code> є типом самої колекції; тобто, другий параметр типу, що передається до класу реалізації, такий як <code>TraversableLike</code> та <code>IndexedSeqLike</code>. Метод <code>map</code> приймає два інші параметри типу, <code>B</code> та <code>That</code>.</p></div>
<div class="paragraph"><p>Параметр <code>B</code> позначає тип результату функції відображення, що також є типом елементів нової колекції. <code>That</code> з'являється як тип мапи, так що він представляє тип нової колекції,що створюється.</p></div>
<div class="paragraph"><p>Як визначається тип <code>That</code>? Він зв'язується з іншими типами через неявний параметр <code>cbf</code> за типом <code>CanBuildFrom[Repr, B, That]</code>. Ці неявні <code>CanBuildFrom</code> визначені індивідуальними класами колекцій. В основному неявне значення типу <code>CanBuildFrom[From, Elem, To]</code> каже: "Ось спосіб, маючи колекцію типу <code>From</code>, побудувати з елементів типу <code>Elem</code> колекцію типу <code>To</code>".</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">class</span> <span class="nc">RNA</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">with</span> <span class="nc">IndexedSeqLike</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA._</span>

<span class="c1">// Обов&#39;язкова реалізація `newBuilder` в `IndexedSeq`</span>
  <span class="k">override</span> <span class="k">protected</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">RNA</span><span class="o">.</span><span class="n">newBuilder</span>

<span class="c1">// Обов&#39;язкова реалізація `apply` в `IndexedSeq`</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>
    <span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">groups</span><span class="o">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">}</span>

<span class="c1">// Опціональна реалізація `foreach`, щоб зробити</span>
<span class="c1">// його більш ефективним.</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="n">b</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">b</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="k">else</span> <span class="n">b</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">S</span>
      <span class="n">f</span><span class="o">(</span><span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">))</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.8 - Клас ланцюжків РНК, фінальна версія.</p></div>
<div class="paragraph"><p>Тепер поведінка <code>map</code> та <code>++</code> на <code>RNA2</code> послідовностях стає яснішою. Немає <code>CanBuildFrominstance</code>, що створює <code>RNA2</code> послідовності, так що наступний найкращий доступний <code>CanBuildFrom</code> був знайдений в об'єкті компанйоні наслідуваного трейта <code>IndexedSeq</code>. Цей неявний примірник створює <code>IndexedSeqs</code>, і це те, що ви бачили, коли застосували <code>map</code> до <code>rna2</code>. Щоб виправити цей недолік, вам треба визначити неявний примірник <code>CanBuildFrom</code> в об'єкті компанйоні класу <code>RNA</code>. Цей примірник повинен мати тип <code>CanBuildFrom[RNA, Base, RNA]</code>. Таким чином, цей примірник стверджує, що маючи ланцюжок РНК і новий тип елементу <code>Base</code>, ви можете побудувати іншу колекцію, що знову буде ланцюжком. Лістинг 25.8 та Лістинг 25.9 показують деталі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">RNA</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">S</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// число біт в групі</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// бітова маска для ізоляції групи</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="mi">32</span> <span class="o">/</span> <span class="n">S</span> <span class="c1">// кількість груп в Int</span>

  <span class="k">def</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Base</span><span class="o">])</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">groups</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]((</span><span class="n">buf</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
      <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">|=</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span><span class="o">(</span><span class="n">buf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span>
    <span class="k">new</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">bases</span><span class="k">:</span> <span class="kt">Base*</span><span class="o">)</span> <span class="k">=</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">bases</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrayBuffer</span> <span class="n">mapResult</span> <span class="n">fromSeq</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">canBuildFrom</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">RNA</span>, <span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">RNA</span>, <span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="n">newBuilder</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">RNA</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="n">newBuilder</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.9 - Об'єкт компанйон <code>RNA</code>, фінальна версія.</p></div>
<div class="paragraph"><p>Порівняно з класом <code>RNA2</code> є дві важливі відмінності. Перше, реалізація <code>newBuilder</code> була переміщена з класу <code>RNA</code> до його об'єкта компанйона. Метод <code>newBuilder</code> в класі <code>RNA</code> просто пересилає до цього визначення. Друге, тепер в об'єкті <code>RNA</code> є неявне значення <code>CanBuildFrom</code>. Щоб створити такий об'єкт, вам треба визначити два методи <code>apply</code> в трейті <code>CanBuildFrom</code>. Обоє створять нового будівельника для колекції <code>RNA</code>, але в них різний список аргументів. Метод <code>apply()</code> просто створює нового будівельника правильного типу. Для контрасту метод <code>apply(from)</code> приймає оригінал колекції як аргумент. Це може бути корисним для адаптації динамічного типу повернення будівельника, щоб він був той самий, що і динамічний тип отримувача. В випадку з <code>RNA</code> це не має зіграти роль, оскільки  RNA є фінальним класом, так що кожний отримувач статичного типу <code>RNA</code> також матиме <code>RNA</code> в якості динамічного типу. Ось чому <code>apply(from)</code> також просто викликає <code>newBuilder</code>, ігноруючи аргумент.</p></div>
<div class="paragraph"><p>Ось так. Клас <code>RNA</code> в Лістингу 25.8 реалізує всі методи колекцій на їх природний типах. Його реалізація потребує малої частки протоколу. В основному ви маєте знати, де покласти фабрики <code>newBuilder</code> та неявні <code>canBuildFrom</code>. З іншого боку, з відносно невеликим кодом ви отримали велику кількість автоматично визначених методів. Також, якщо ви не маєте намірів робити для ваших колекцій масові операції, як <code>take</code>, <code>drop</code>, <code>map</code> або <code>++</code>, ви можете обрати не робити додаткову <code>length</code>, та зупинитись на реалізації, показаній в Лістингу 25.6.</p></div>
<div class="paragraph"><p>Дискусія досі оберталась коло найменьшої кількості визначень, потрібних для визначення нових послідовностей, з методами, що підкорюються певним типам. Але на практиці ви можете також захотіти додати нову функціональність до ваших послідовностей, або перекрити існуючі методи для кращої ефективності. Прикладом цього є перекритий метод <code>foreach</code> в класі <code>RNA</code>. <code>foreach</code> є важливим методом сам по собі, оскільки він реалізує цикли по колекціях. Більше того, багато інших методів колекцій реалізовані в термінах <code>foreach</code>. Так що має сенс інвестувати деякі зусилля в оптимізацію реалізації цього метода.</p></div>
<div class="paragraph"><p>Стандартна реалізація <code>foreach</code> в <code>IndexedSeq</code> буде просто обирати кожний <code>i</code>-тий елемент колекції, використовуючи <code>apply</code>, де <code>i</code> в диапазоні від 0 до довжини колекції мінус один. Так що стандартна реалізація вибирає елемент та розпаковує з нього основу кожного разу для кожного елемента в <code>RNA</code>. Перекриваюче <code>foreach</code> в класі RNA є розумнішим ніж це. Для кожного обраного елементу масива він безпосередньо застосовує надану функцію до всіх основ, що містяться в елементі. Так що зусилля для виборки з масива та розпаковки біт дуже зменшено.</p></div>
</div>
<div class="sect2">
<h3 id="______13">Інтегрування нових множин та мап</h3>
<div class="paragraph"><p>Другий приклад, який ви вивчете, це як інтегрувати в фреймворк колекцій новий різновид мапи. Ідея полягає в реалізації змінної мапи зі <code>String</code> як типом ключа, через "Patricia дерева".<span class="footnote"><br />[Morrison, "PATRICIA — Practical Algorithm To Retrieve Information Coded in Alphanumeric" [Mor68]]<br /></span> Термін Patricia є скороченням для "Practical Algorithm to Retrieve Information Coded in Alphanumeric". Ідея в зберіганні множини або мапи як дерева,де послідовні символи в ключі пошуку визначають унікальне наступне дерево.</p></div>
<div class="paragraph"><p>Наприклад, дерево Patricia зберігає п'ять рядків, <code>"abc"</code>, <code>"abd"</code>, <code>"al"</code>, <code>"all"</code>, <code>"xy"</code>, та може виглядати як дерево на Малюнку 25.1. Щоб знайти вузол, відповідний рядку <code>"abc"</code> в цьому дереві, просто слідуйте піддереву з міткою <code>"a"</code>, звідти ідіть до піддерева з міткою <code>"b"</code>, щоб нарешті досягти субдерева з міткою <code>"c"</code>. Якщо дерево Patricia використовується як мапа, значення, що асоційоване з ключем, зберігається в вузлах, що можуть бути досяжними по ключу. Якщо це множина, ви просто зберігаєте маркер, який каже що вузол присутній в множині.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">collection._</span>

<span class="k">class</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="nc">extends</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">]</span>
    <span class="k">with</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">MapLike</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">suffixes</span><span class="k">:</span> <span class="kt">immutable.Map</span><span class="o">[</span><span class="kt">Char</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>
    <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">value</span>
      <span class="k">else</span> <span class="n">suffixes</span> <span class="n">get</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">withPrefix</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
      <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">leading</span> <span class="k">=</span> <span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
        <span class="n">suffixes</span> <span class="n">get</span> <span class="n">leading</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
            <span class="n">suffixes</span> <span class="k">=</span> <span class="n">suffixes</span> <span class="o">+</span> <span class="o">(</span><span class="n">leading</span> <span class="o">-&gt;</span> <span class="n">empty</span><span class="o">)</span>
          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
        <span class="o">}</span>
        <span class="n">suffixes</span><span class="o">(</span><span class="n">leading</span><span class="o">)</span> <span class="n">withPrefix</span> <span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">)</span>
      <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">withPrefix</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">value</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="k">val</span> <span class="n">prev</span> <span class="k">=</span> <span class="n">value</span><span class="o">;</span> <span class="n">value</span> <span class="k">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">prev</span> <span class="o">}</span>
    <span class="k">else</span> <span class="n">suffixes</span> <span class="n">get</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)]</span> <span class="k">=</span>
    <span class="o">(</span><span class="k">for</span> <span class="o">(</span><span class="n">v</span> <span class="k">&lt;-</span> <span class="n">value</span><span class="o">.</span><span class="n">iterator</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">++</span>
    <span class="o">(</span><span class="k">for</span> <span class="o">((</span><span class="n">chr</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">suffixes</span><span class="o">.</span><span class="n">iterator</span><span class="o">;</span>
          <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">.</span><span class="n">iterator</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="n">chr</span> <span class="o">+:</span> <span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>

  <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">kv</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">T</span><span class="o">))</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span> <span class="n">update</span><span class="o">(</span><span class="n">kv</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">kv</span><span class="o">.</span><span class="n">_2</span><span class="o">);</span> <span class="k">this</span> <span class="o">}</span>

  <span class="k">def</span> <span class="o">-=</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span> <span class="n">remove</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="k">this</span> <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">empty</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.10 - Реалізація префіксної мапи за допомогою Patricia дерев.</p></div>
<div class="paragraph"><p>Малюнок 25.1 - Приклад дерева Patricia.</p></div>
<div class="paragraph"><p>Patricia дерева підтримують дуже ефективні пошуки та оновлення. Інша гарна можливість в тому, що вони підтримують виборку субколекцій по заданому префіксу. Наприклад, в дереві на Малюнку 25.1 ви можете отримати субколекцію по всім ключам, що починаються на <code>"a"</code>, просто слідуя посиланню <code>"a"</code> від кореня дерева.</p></div>
<div class="paragraph"><p>Базуючись на ціх ідеях ми тепер будемо проходити з вами по реалізації мапи, що реалізована як дерево Patricia. Ми назвали мапу <code>PrefixMap</code>, що означає, що вона підтримує метод <code>withPrefix</code>, що обирає субмапу з усіх ключів, що мають наданий префікс.</p></div>
<div class="paragraph"><p>Спочатку ми визначимо префіксну мапу з ключами, показану на Малюнку 25.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">PrefixMap</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;abd&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;al&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span>
<span class="s">&quot;all&quot;</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="s">&quot;xy&quot;</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">m</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">abc</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">abd</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">al</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">all</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span>
<span class="o">(</span><span class="n">xy</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли викликається <code>withPrefix</code> на <code>m</code>, це даватиме іншу префіксну мапу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span> <span class="n">withPrefix</span> <span class="s">&quot;a&quot;</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">bc</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">bd</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">ll</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.10 показує визначення <code>PrefixMap</code>. Цей клас параметризований типом асоційованого значення <code>T</code>, та розширює <code>mutable.Map[String, T]</code> та <code>mutable.MapLike[String, T, PrefixMap[T]]</code>. Ви вже бачили цей шаблон для послідовностей в прикладі з РНК ланцюжками. Тепер, коли є наслідування класу реалізації, такого як <code>MapLike</code>, це служить для отримання правильного класу результату для таких трансформацій, як <code>filter</code>.</p></div>
<div class="paragraph"><p>Вузол префіксної мапи має два змінних поля: <code>suffixes</code> та <code>value</code>. Поле <code>value</code> містить додаткове значення, що асоційоване з вузлом. Воно ініціалізоване як <code>None</code>. Поле <code>suffixes</code> містить тмапу від префіксів до значень <code>PrefixMap</code>. Воно ініціалізоване як порожня мапа. Ви можете запитати, чому ми обрали незмінну мапу як тип реалізації для <code>suffixes</code>? Чи не була б змінна мапа більш стандартною, оскільки <code>PrefixMap</code> вцілому також змінна? Відповідь в тому, що незмінні мапи, що містять тільки декілька елементів, є дуже ефективними одночасно, по простору і часу виконання.</p></div>
<div class="paragraph"><p>Наприклад, мапи, що містять меньше ніж 5 елементів, представлені як один об'єкт. Для контрасту, як описано в Розділі 17.2, стандартна змінна мапа є <code>HashMap</code>, що типово займає близько 80 байт, навіть якщо вона порожня. Так що якщо мали колекції є типовими, краще обирати незмінні замість змінних. В випадку дерев Patricia ми очікуємо, що більшість вузлів, за винятком тих, що будуть з самого верху дерева, будуть містити лише декільки наступних. Так що зберігання ціх наступних в незмінній мапі, вірогідно, буде більш ефективним.</p></div>
<div class="paragraph"><p>Тепер подивимось на перший метод, що має бути реалізований для мапи: <code>get</code>. Алгоритм наступний: щоб отримати значення, асоційоване з порожнім рядком в префіксній мапі, просто оберіть опціональне значення, що зберігається в корені дерева. Інакше, якщо рядок не порожній, спробуйте вибрати субмапу, що відповідає першому символу в рядку. Якщо це дає мапу, продовжуйте через пошук залишку ключового рядка після його першого символа в цій мапі. Якщо вибірка схибить, ключ не зберігається в мапі, так що повертаємо <code>None</code>. Комбінована вибірка через опціональне значення елегантно виражене через <code>flatMap</code>. Коли застосовується до опціонального значення <code>ov</code> та замикання <code>f</code>, що в свою чергу повертає опціональне значення, <code>ov flatMap f</code> буде успішним, якщо обоє, <code>ov</code> та <code>f</code> повертає визначене значення. Інакше <code>ov flatMap f</code> буде повертати <code>None</code>.</p></div>
<div class="paragraph"><p>Наступні два методи, що треба реалізувати для змінної мапи, є <code>+=</code> та <code>-=</code>. В реалізації на Лістингу 25.10 вони визначені в термінах двох інших методів: <code>update</code> та <code>remove</code>. Метод <code>remove</code> дуже подібний до метода <code>get</code>, за тим винятком, що перед поверненням асоційованого значення, поле, що містить це значення, встановлюється в <code>None</code>. Метод <code>update</code> спочатку викликає <code>withPrefix</code> для навігації до вузла дерева, що потребує оновлення, та потім встановлює поле цього вузла в надане значення. Метод <code>withPrefix</code> навігує по дереву, створюючи субмапи за необхідності, якщо деякий префікс з символів ще не міститься як шлях в дереві.</p></div>
<div class="paragraph"><p>Останній абстрактний метод, що треба реалізувати для змінної мапи є <code>iterator</code>. Цей метод має продукувати ітератор, що отримує всі пари ключ/значення, що зберігаються в мапі. Для кожної префіксної мапи цей ітератор складається з наступних частин: перше, якщо мапа містить визначене значення, <code>Some(x)</code>, в полі <code>value</code> в своєму корені, потім <code>("", x)</code> є першим елементом, що повертається від ітератора. Більше того, ітератор має пройти по всіх ітераторах всіх субмап, що містяться в полі <code>suffixes</code>, але він має додавати символ перед кожним рядком, що повертається ціма ітераторами. Більш точно, якщо <code>m</code> є субмапою, що досяжна з кореня через символ <code>chr</code>, та <code>(s, v)</code> є елементом, що повертає <code>m.iterator</code>, тоді кореневий ітератор буде повертати <code>(chr +: s, v)</code>.</p></div>
<div class="paragraph"><p>Ця логіка реалізована досить стисло, як конкатенація двох виразів в реалізації метода  <code>iterator</code> з Лістингу 25.10. Перший <code>for</code> вираз ітерує по <code>value.iterator</code>. Це використовує факт, що значення <code>Option</code> визначають метод <code>iterator</code>, що або не повертає елементів, якщо опціональне значення <code>None</code>, або рівно один елемент <code>x</code>, якщо значення опціїif є <code>Some(x)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.</span><span class="o">{</span><span class="nc">Builder</span><span class="o">,</span> <span class="nc">MapBuilder</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.collection.generic.CanBuildFrom</span>

<span class="k">object</span> <span class="nc">PrefixMap</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">kvs</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">T</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">empty</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">kv</span> <span class="k">&lt;-</span> <span class="n">kvs</span><span class="o">)</span> <span class="n">m</span> <span class="o">+=</span> <span class="n">kv</span>
    <span class="n">m</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">MapBuilder</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">canBuildFrom</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
        <span class="k">def</span> <span class="n">apply</span><span class="o">()</span> <span class="k">=</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
      <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.11 - Об'єкт компанйон для префіксної мапи.</p></div>
<div class="paragraph"><p>Зауважте, що немає метода <code>newBuilder</code>, визначеного в <code>PrefixMap</code>. В ньому немає потреби, оскільки мапи та множини ідуть з будівельниками по замовчанню, що є примірниками класу  <code>MapBuilder</code>. Для змінної мапи будівельник по замовчанню починає з порожньої мапи, та потім додає послідовні елементи, використовуючи метод мапи <code>+=</code>.</p></div>
<div class="paragraph"><p>Змінні множини поводяться таким же чином. Будівельники по замовчанню для незмінних мап та множин використовують неруйнівний метод додавання елементу <code>+</code>, замість метода <code>+=</code>. Однак у всіх ціх випадках, щоб побудувати правильний різновид множини або мапи вам треба почати з порожньої множини або мапи цього виду. Це провадиться методом <code>empty</code>, що є останнім метедом, визначеним в <code>PrefixMap</code>. В Лістингу 25.10 цей метод просто повертає свіжу <code>PrefixMap</code>.</p></div>
<div class="paragraph"><p>Тепер ми перейдемо до об'єкта компанйона <code>PrefixMap</code>, що показаний на Лістингу 25.11. Фактично, не є винятково необхідним визначати цей об'єкт, бо клас <code>PrefixMap</code> може гарно встояти як він є. Головне призначення об'єкта <code>PrefixMap</code> є визначити деякі зручні методи фабрик. Він також визначає неявне значення <code>CanBuildFrom</code>, щоб покращити роботу типізації.</p></div>
<div class="paragraph"><p>Два зручні методи - це <code>empty</code> та <code>apply</code>. Ті самі методи присутні для всіх інших колекцій в фреймворці колекцій Scala, так що має сенс визначити тут їх, також. З ціма двома методами ви можете записати літерали <code>PrefixMap</code>, як ви робите це для всіх інших колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">PrefixMap</span><span class="o">(</span><span class="s">&quot;hello&quot;</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">&quot;hi&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">hello</span><span class="o">,</span><span class="mi">5</span><span class="o">),</span> <span class="o">(</span><span class="n">hi</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">PrefixMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший член в об'єкті <code>PrefixMap</code> є неявний примірник <code>CanBuildFrom</code>. Він має те саме призначення, що і визначення <code>CanBuildFrom</code> в останньому розділі: щоб дозволити таким методам, як <code>map</code>, повертати найкращий можливий тип. Наприклад, розглянемо функцію одображення для пар ключ/значення <code>PrefixMap</code>. Доки ця функція продукує пари з рядків та якогось іншого типу, результуюча колекція знову буде <code>PrefixMap</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res0</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">,</span> <span class="s">&quot;x&quot;</span> <span class="o">*</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">hello</span><span class="o">!,</span><span class="n">xxxxx</span><span class="o">),</span> <span class="o">(</span><span class="n">hi</span><span class="o">!,</span><span class="n">xx</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Аргумент наданої функції приймає пари ключ/значення префіксної мапи <code>res0</code>, та продукує пари рядків. Результатом <code>map</code> буде <code>PrefixMap</code>, на цей раз з типом значень <code>String</code> замість <code>Int</code>. Без неявного <code>canBuildFrom</code> в <code>PrefixMap</code>, результат буде загальна змінна мапа, не префіксна мапа.</p></div>
</div>
<div class="sect2">
<h3 id="__32">Підсумок</h3>
<div class="paragraph"><p>Якщо ви бажаєте повністю інтегрувати новий клас колекції в фреймворк, вам треба звернути увагу на такі питання:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Вирішити, чи колекція повиння бути змінною чи незмінною.
</p>
</li>
<li>
<p>
Обрати вірний базовий трейт для колекції.
</p>
</li>
<li>
<p>
Наслідувати від правильного трейта реалізації, щоб реалізовати більшість операцій колекцій.
</p>
</li>
<li>
<p>
Якщо ви бажаєте, щоб <code>map</code> та подібні операції повертали примірники вашого класа колекції, запровадьте неявний <code>CanBuildFrom</code> в об'єкті компанйоні вашого класу.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__33">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили, як побудовані колекції Scala, та як ви можете будувати нові різновиди колекцій. Завдяки багатій підтримці абстракцій в Scala, кожний новий тип колекцій може мати велику кількість методів, без потреби кожного разу знову реалізувати їх.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__26_2">Глава 26</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__34">Екстрактори</h1>
<div class="paragraph"><p>Тепер ви, можливо, зростили бажання мати стислий спосіб, яким дані можуть бути декомпоновані і проаналізовані з використанням співпадіння шаблонів. Ця глава показує вам,як надалі узагальнити цю концепцію. До цього часу шаблони конструкторів були пов'язані з кейс класами. Наприклад, <code>Some(x)</code> є валідним шаблоном, оскільки <code>Some</code> є кейс класом. Іноді ви будете бажати створити шаблон як цей,  без створення асоційованого кейс класу. Фактично, ви можете побажати створити власний різновид шаблону. Екстрактори дають вам спосіб зробити це. Ця глава пояснює, що таке екстрактори, і як ви їх можете використовувати для визначення шаблонів, що відділені від репрезентації об'єкта.</p></div>
<div class="sect1">
<h2 id="_26_1_____">26.1 Приклад: отриманння адреси електронної пошти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб проілюструвати проблему, яку використовує екстрактор, уявімо, що вам треба проаналізувати рядкі, що представляють адреси електронної пошти. Беручи рядок, ви бажаєте вирішити, чи є це адреса електронної пошти, або ні, та, якщо це так, ви бажаєте отримати доступ до частин користувача та домена цієї адреси. Традиційний спосіб зробити це задіє три допоміжні функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isEMail</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">domain</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="k">def</span> <span class="n">user</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>З ціма функціями ви можете розібрати наданий рядок таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">isEMail</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="n">println</span><span class="o">(</span><span class="n">user</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot; AT &quot;</span> <span class="o">+</span> <span class="n">domain</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="k">else</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;not an email address&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить, але дещо неоковирно. Що більше, речі ставатимуть складнішими, якщо вам треба зробити декілька такіх перевірок. Наприклад, ви можете побажати знайти дві послідовні рядки в списку, що обоє є адресами електрнної пошти з тим самим користувачем. Ви можете спробувати це самотужки, за допомогою попередньо визначених функцій доступу, щоб побачити, що для цього знадобиться.</p></div>
<div class="paragraph"><p>Ви вже бачили в Главі 15, що порівняння шаблонів є ідеальним для атак на проблеми як ця. Давайте на мить уявімо, що ви можете порівняти рядок з шаблоном:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Шаблон співпадатиме, якщо рядок містить символ <code>at</code> (<code>@</code>). В цьому випадку він може прикріпляти змінну <code>user</code> до частини рядка до <code>@</code>, та змінну <code>domain</code> до частини після нього. Постулюючи шаблон такого вигляду, попередній вираз може бути записаний більш ясно, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">user</span> <span class="o">+</span> <span class="s">&quot; AT &quot;</span> <span class="o">+</span> <span class="n">domain</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;not an email address&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Більш складна проблема пошуку двох послідовних адрес з тим же користувачем буде транслюватись в наступний шаблон:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ss</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">u1</span><span class="o">,</span> <span class="n">d1</span><span class="o">)</span> <span class="o">::</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">u2</span><span class="o">,</span> <span class="n">d2</span><span class="o">)</span> <span class="o">::</span> <span class="k">_</span> <span class="k">if</span> <span class="o">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це значно більш прийнятно, ніж будь-що, що може бути написане за допомогою функцій доступу. Однак проблема в тому, що рядкі не кейс класи; вони не мають репрезентації, що відповідає до <code>EMail(user, domain)</code>. Ось де з'являються екстрактори Scala: вони дозволяють вам визначити нові шаблони для вже визначених типів, де шаблон не має слідувати внутрішній репрезентації типу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_2_">26.2 Екстрактори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Екстрактором в Scala є об'єкт, що має метод з назвою <code>unapply`в якості свого члена. Призначення метода `unapply</code> є порівнювати значення та розбивати його на частини. Часто об'єкт екстрактора також визначає парний метод <code>apply</code> для побудови значень, але це не вимагається. Як приклад, Лістинг 26.1 показує об'єкт екстрактора для адрес електронної пошти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">EMail</span> <span class="o">{</span>
  <span class="c1">// Метод ін&#39;єкції (опціональний)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">user</span> <span class="o">+</span> <span class="s">&quot;@&quot;</span> <span class="o">+</span> <span class="n">domain</span>

<span class="c1">// Метод екстракції (обов&#39;язковий)</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">str</span> <span class="n">split</span> <span class="s">&quot;@&quot;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.1 - Рядковий об'єкт <code>EMail</code> екстрактора.</p></div>
<div class="paragraph"><p>Цей об'єкт визначає одночасно методи <code>apply</code> та <code>unapply</code>. Метод <code>apply</code> має таке значення, як і завжди: він перетворює <code>EMail</code> в об'єкт, що може бути застосований до аргументів в дужках, в той же спосіб, як застосовуються методи. Так що ви можете написати <code>EMail("John", "epfl.ch")</code> для конструювання рядка <code>"John@epfl.ch"</code>. Щоб зробити це більш явним, ви можете також дозволити <code>EMail</code> наслідувати функціональний тип Scala, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">EMail</span> <span class="k">extends</span> <span class="o">((</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Частина <code>(String, String) =&gt; String</code> декларації попереднього об'єкта означає те саме, що і <code>Function2[String, String, String]</code>, що декларує абстрактний метод <code>apply</code>, що реалізує <code>EMail</code>. Як результат цієї декларації ви можете, наприклад, передати <code>EMail</code> до метода, що очікує <code>Function2[String, String, String]</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Метод <code>unapply</code> це те, що перетворює <code>EMail</code> в екстрактор. В деякому сенсі він обератє процес конструктора в <code>apply</code>. Коли <code>apply</code> приймає два рядки, та формує на їх основі рядок адреси, <code>unapply</code> приймає рядок адреси, та потенційно повертає два рядка: <code>user</code> та <code>domain</code> цієї адреси. Але <code>unapply</code> має також обробляти випадок, коли наданий рядок не є електронною адресою. Ось чому <code>unapply</code> повертає тип <code>Option</code> для пари рядків. Його результат є або <code>Some(user, domain)</code>, якщо рядок <code>str</code> є адресою з певними частинами <code>user</code> та <code>domain</code>,<span class="footnote"><br />[Як тут демонструється, де <code>Some</code> застосовується до тапла <code>(user, domain)</code>, ви можете полишити пару дужок, коли передаєте тапл до функції, що приймає один аргумент. Таким чином, <code>Some(user, domain)</code> означає те саме, що і <code>Some((user, domain))</code>.]<br /></span> або <code>None</code>, якщо <code>str</code> не є адресою електронної пошти. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">unapply</span><span class="o">(</span><span class="s">&quot;John@epfl.ch&quot;</span><span class="o">)</span> <span class="n">equals</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="s">&quot;epfl.ch&quot;</span><span class="o">)</span>
<span class="n">unapply</span><span class="o">(</span><span class="s">&quot;John Doe&quot;</span><span class="o">)</span> <span class="n">equals</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли порівняння шаблонів натрапляє на шаблон, що посилається на об'єкт екстрактора, він викликає метод екстрактора <code>unapply</code> на виразі селектора. Наприклад, виконання кода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">selectorString</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде призводити до виклика:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">selectorString</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачили до цього, цей виклик до <code>EMail.unapply</code> буде повертати або <code>None</code> або <code>Some(u, d)</code> для деяких значень, <code>u</code> для частини адреси <code>user</code>, та <code>d</code> для чистини <code>domain</code>. В випадку <code>None</code> шаблоне на співпадає, і система намагається порівняти інший шаблон, або схибить з виключенням <code>MatchError</code>. В випадку <code>Some(u, d)</code> шаблон співпадає, та його змінні прикріплюються до елементів повернутого значення. В попередньому порівнянні <code>user</code> буде зв'язано з <code>u</code>, та <code>domain</code> буде прив'язаний до <code>d</code>.</p></div>
<div class="paragraph"><p>В прикладі з шаблоном порівняння <code>EMail</code> тип <code>String</code> виразу селектора, <code>selectorString</code>, відповідає до типу аргумента <code>unapply</code> (що в прикладі також був <code>String</code>). Це досить загальне, але не обов'язкове. Також можливо використовувати екстрактор <code>EMail</code> для порівняння <code>match</code> виразів для більш загальних типів. Наприклад, щоб знайти, чи довільне значення <code>x</code> є рядком адреси електронної пошти, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код, порівнювач шаблонів зпочатку перевірить, чи надане значення <code>x</code> відповідає до <code>String</code>, тип параметру метода <code>EMail</code> <code>unapply</code>. Якщо він відповідає, значення приводиться до <code>String</code>, та співпадіння шаблонів продовжується як звичайно. Якщо він не відповідає, шаблон безпосередньо зазнає невдачі.</p></div>
<div class="paragraph"><p>В об'єкті <code>EMail</code> метод <code>apply</code> називається ін'єкцією, оскільки він приймає деякі аргументи, та отримує елемент наданої множини (в нашому випадку множину рядків, що є інтернет адресами). Метод <code>unapply</code> називається екстракцією, оскільки він бере елемент з тієї ж множини, та екстрагує деякі з його частин (в нашому випадку субрядки <code>user</code> та <code>domain</code>). Ін'єкції та екстракції часто групіюються разом в одному об'єкті, оскільки ви можете використовувати ім'я об'єкта для обох, конструктора та шаблона, що симулює домовленість про порівняння шаблонів для кейс класів. Однак також можливо визначити екстракцію в об'єкті без відповідної ін'єкції. Сам об'єкт називається екстрактором, безвідносно, чи має чи ні метод <code>apply</code>.</p></div>
<div class="paragraph"><p>Якщо метод ін'єкції включений, він має доповнювати метод екстракції. Наприклад, виклик:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="nc">EMail</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>повинен повертати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>тобто та сама послідовність аргументів, огорнена в <code>Some</code>. Ідучи в іншому напрямку означає спочатку викликати метод <code>unapply</code>, та потім <code>apply</code>, як показано в наступному коді:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">EMail</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В уьому коді, якщо <code>match</code> на <code>obj</code> матиме успіх, ви очікуєте отримати той самий об'єкт від <code>apply</code>. Ці дві умови для дуальності <code>apply</code> та <code>unapply</code> є гарним принципом дизайну. Вони не примушуються Scala, але їх рекомендовано дотримуватись, коли розробляєте ваші екстрактори.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_3______">26.3 Шаблони з нулем або однією змінною</h2>
<div class="sectionbody">
<div class="paragraph"><p>Метод <code>unapply</code> в попередньому прикладі повертає пару значень елемента в разі успіху. Це легко узагальнити до шаблонів з більш ніж двома змінними. Щоб прікрипити <code>N</code> змінних, <code>unapply</code> має повертати тапл з N елементів, огорнутий в <code>Some</code>.</p></div>
<div class="paragraph"><p>Однак випадок, коли шаблон прикріплює лише одну змінну, трактується по-іншому. В Scala немає тапла з одним елементом. Щоб повернути тільки один елемент шаблону метод <code>unapply</code> просто огортає сам елемент в <code>Some</code>. Наприклад, об'єкт екстрактор, показаний на Лістингу 26.2, визначає <code>unapply</code> для рідків, що складається з деяких субрядків, з'являючись два рази поспіль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Twice</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">s</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">val</span> <span class="n">half</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">half</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="n">length</span><span class="o">))</span> <span class="nc">Some</span><span class="o">(</span><span class="n">half</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.2 - Об'єкт екстрактора рядків <code>Twice</code>.</p></div>
<div class="paragraph"><p>Також можливо, щоб шаблон екстрактора взагалі не прикріпляв жодних змінних. В цьому випадку відповідний метод <code>unapply</code> повертає логічне <code>true</code> для успіха, та <code>false</code> для невдачі. Наприклад, об'єкт екстрактора, показаний в Лістингу 26.3, характеризує рядкі, що складаються лише з великих літер:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">UpperCase</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">toUpperCase</span> <span class="o">==</span> <span class="n">s</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.3 - Об'єкт екстрактора рядків <code>UpperCase</code>.</p></div>
<div class="paragraph"><p>На це раз екстрактор тільки визначає <code>unapply</code>, але не <code>apply</code>. Не буде сенсу з визначення <code>apply</code>, бо нічого конструювати. Наступна функція <code>userTwiceUpper</code> застосовує всі попередньо визначені екстрактори разом в своєму коді співпадіння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="nc">Twice</span><span class="o">(</span><span class="n">x</span> <span class="k">@</span> <span class="nc">UpperCase</span><span class="o">()),</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="s">&quot;match: &quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&quot; in domain &quot;</span> <span class="o">+</span> <span class="n">domain</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="s">&quot;no match&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший шаблон цієї функції співпадає з рядками, що є адресами електронної пошти, чия частина <code>user</code> складається з двох входжень того самого рядка великими літерами. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">&quot;DIDI@hotmail.com&quot;</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">match:</span> <span class="kt">DI</span> <span class="kt">in</span> <span class="kt">domain</span> <span class="kt">hotmail.com</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">&quot;DIDO@hotmail.com&quot;</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span> <span class="k">match</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">&quot;didi@hotmail.com&quot;</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span> <span class="k">match</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>UpperCase</code> в функції <code>userTwiceUpper</code> приймає порожній список параметрів. Цього неможливо оминути, бо тоді <code>match</code> буде тестувати на рівність з об'єктом <code>UpperCase</code>! Зауважте також, що хоча <code>UpperCase()</code> сам не прикріплює жодних змінних, все ще можливо асоціювати змінну з цілим шаблоном, що співпав. Щоб зробити це, ви використовуєте стантартну схему прикріплення змінних, пояснену в Розділі 15.2: форма <code>x @ UpperCase()</code> асоціює змінну з <code>x</code> шаблоном, співпавшим з <code>UpperCase()</code>. Наприклад, в першому виклику <code>userTwiceUpper</code> вище, <code>x</code> був прив'язаний до <code>"DI"</code>, оскільки це було значення, з яким порівнювався шаблон <code>UpperCase()</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_4____">26.4 Екстрактори зі змінними аргументами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередні методи екстракторів для електронної пошти всі повертали фіксоване число значень елеменів. Іноді це недостатньо гнучко. Наприклад, ви можете бажати порівняти на рядку, що містить ім'я домені, так щоб кожна частина домену зберігалась в іншому субшаблоні. Це дозволить вам виразити такі шаблони:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">dom</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;org&quot;</span><span class="o">,</span> <span class="s">&quot;acm&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;acm.org&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;com&quot;</span><span class="o">,</span> <span class="s">&quot;sun&quot;</span><span class="o">,</span> <span class="s">&quot;java&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;java.sun.com&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;net&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;a .net domain&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі речі аранжовані так, щоб домени витрачались в зворотньому порядку — від вищого рівня до субдоменів. Це зроблене так, щоб отримати більше вигод від шаблонів послідовностей. Ви бачили в Розділі 15.2, що шаблон підстановки послідовностей, <code>_*</code>, в кінці списку аргументів співпадає з любим залишком елементів в послідовності. Ця можливість більш корисна, якщо домени вищого рівня ідуть першими, оскільки тоді ви можете використовувати підстановки послідовностей для співпадіння субдоменів на довільну глибину.</p></div>
<div class="paragraph"><p>Залишається питання, як екстрактор може підтримувати співпадіння <code>vararg</code>, як показано в попередньому прикладі, де шаблони можуть мати змінне число субшаблонів. Методи <code>unapply</code>, що ми зустрічали до цього, недостатні, оскільки кожний з них повертає фіксоване число субелементів в випадку успіху. Щоб обробити цей випадок, Scala дозволяє визначити інший метод екстрактора спеціально для vararg співпадіння. Цей метод має назву <code>unapplySeq</code>. Щоб побачити, як це записується, подивіться на екстрактор <code>Domain</code>, показаний в Лістингу 26.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Domain</span> <span class="o">{</span>
  <span class="c1">// Метод ін&#39;єкції (опціональний)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">parts</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="n">parts</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)</span>

  <span class="c1">// Метод екстракції (обов&#39;язковий)</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">whole</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">whole</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\.&quot;</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.4 - Об'єкт екстрактора рядків <code>Domain</code>.</p></div>
<div class="paragraph"><p>Об'єкт <code>Domain</code> визначає метод <code>unapplySeq</code>, що зпочатку розбиває рядок на частини, розділені крапками. Це робиться за допомогою Java метода <code>split</code> на рядках, що приймає регулярний вираз в якості аргумента. Цей результат <code>split</code> є масивом субрядків. Результат <code>unapplySeq</code> є цей масив з усіма елементами, також огорнутий в <code>Some</code>.</p></div>
<div class="paragraph"><p>Тип результату <code>unapplySeq</code> має відповідати до <code>Option[Seq[T]]</code>, де тип елемента <code>T</code> є довільним. Як ви бачили в Розділі 17.1, <code>Seq</code> є важливим класом в ієрархії колекцій Scala. Це загальний суперклас декількох класів, що описують різні типи послідовностей: <code>List</code>,<code>Array</code>, <code>WrappedString</code> та декілька інших.</p></div>
<div class="paragraph"><p>Для симетрії <code>Domain</code> також має метод <code>apply</code>, що будує рядок домену зі списку параметрів частин домена, що починається з домену вищого рівня. Як завжди, метод <code>apply</code> є опціональним.</p></div>
<div class="paragraph"><p>Ви можете використовувати естрактор <code>Domain</code> для отримання більш детальної інформації від адрес електронної пошти. Наприклад, щоб знайти всі адреси з ім'ям <code>"tom"</code> в деякому домені <code>".com"</code>, ви можете написати наступну функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="s">&quot;tom&quot;</span><span class="o">,</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;com&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">*))</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дає очікувані результати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="s">&quot;tom@sun.com&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="s">&quot;peter@sun.com&quot;</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="s">&quot;tom@acm.org&quot;</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Також можливо повернути деякі фіксовані елементи від <code>unapplySeq</code> разом зі змінною частиною. Це виражається через повернення всіх елементів в таплі, де змінна частина іде, як звичайно, останньою. Як приклад, Лістинг 26.5 показує новий екстрактор для адрес, де частина домена вже розширена в послідовність:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">ExpandedEMail</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">email</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
      <span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">email</span> <span class="n">split</span> <span class="s">&quot;@&quot;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\.&quot;</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.5 - Об'єкт екстрактора <code>ExpandedEMail</code>.</p></div>
<div class="paragraph"><p>Метод <code>unapplySeq</code> в <code>ExpandedEMail</code> повертає опціональне значення пари (<code>Tuple2</code>). Перший елемент в парі є частина <code>user</code>. Другий елемент є послідовність імен, що представляють домен. Ви можете зробити співпадіння на них, як звичайно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;tom@support.epfl.ch&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">tom</span><span class="nd">@support</span><span class="o">.</span><span class="n">epfl</span><span class="o">.</span><span class="n">ch</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">ExpandedEMail</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">topdom</span><span class="o">,</span> <span class="n">subdoms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=</span> <span class="n">s</span>
<span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">tom</span>
<span class="n">topdom</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">ch</span>
<span class="n">subdoms</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="n">epfl</span><span class="o">,</span> <span class="n">support</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_5____">26.5 Екстрактори та шаблони послідовностей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви бачили в Розділі 15.2, що ви можете отримати доступ до елементів списку або масива, використовуючи шаблони послідовностей, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span>
<span class="nc">Array</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, ці шаблони послідовностей всі реалізовані з використанням екстракторів в стандартній бібліотеці Scala. Наприклад, шаблони в формі <code>List(...)</code> стали можливі, оскільки об'єкт компанйон <code>scala.List</code> є екстрактором, що визначає метод <code>unapplySeq</code>. Лістинг 26.6 показує маючі відношення визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala</span>
<span class="k">object</span> <span class="nc">List</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="n">elems</span><span class="o">.</span><span class="n">toList</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.6 - Екстрактор, що визначає метод <code>unapplySeq</code>.</p></div>
<div class="paragraph"><p>Об'єкт <code>List</code> містить метод <code>apply</code>, що приймає змінне число аргументів. Це те, що дозволяє вам писати вирази як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Він також містить метод <code>unapplySeq</code>, що повертає всі елементи зі списка як послідовність. Ось що підтримує шаблони <code>List(...)</code>. Дуже подібні визначення існують в об'єкті <code>scala.Array</code>. Вони підтримують ін'єкції та екстрактори для масивів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_6____">26.6 Екстрактори проти кейс класів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Навіть якщо вони і дуже корисні, кейс класи мають одне обмеження: вони демонструють дійсну репрезентацію даних. Це означає, що імя класу в шаблоні конструктора відповідає конкретній репрезентації типу об'єкта селектора. Якщо співпадіння з:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">C</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>успішне, ви знаєте, що вираз селектора є примірником класу <code>C</code>.</p></div>
<div class="paragraph"><p>Екстрактори руйнують цей зв'язок між репрезентацією даних та шаблонами. Ви бачили в прикладах в цьому розділі, що вони дозволяють шаблони, що не мають нічого загального з типом даних об'єкта, що вибирається. Ця властивість називається незалежністю від репрезентації. В відкритих системах великого розміру незалежність від репрезентації дуже важлива, оскільки вона дозволяє вам змінити тип реалізації, що використовується в множині компонент, без впливу на клієнтів ціх компонент.</p></div>
<div class="paragraph"><p>Якщо ваш компонент був визначений та експортований як набір кейс класів, ви будете прив'язані до них, оскільки клієнтській код завжди може містити порівняння шаблонів на ці кейс класи. Переіменування деяких кейс класів або змінення ієрархії класів буде впливати на клієнтський код. Екстрактори не поділяють цю проблему, оскільки вони представляють прошарок перенаправлення між репрезентацією даних та способом, як їх бачать клієнти. Ви все ще можете змінити конкретну репрезентацію типу, доки ви оновлюєте всі ваші екстрактори разом з цім.</p></div>
<div class="paragraph"><p>Незалежність від репрезентації є важливою перевагою екстракторів над кейс класами. З іншого боку кейс класи також мають деякі переваги над екстракторами. Перше, вони значно простіші для встановлення та визначення, та вони потребують меньше коду. Друге, вони звичайно призводять до більш ефективного порівняння шаблонів, ніж екстрактори, оскільки компілятор Scala може оптимізувати шаблони по кейс класам значно краще, ніж по екстракторам. Це так тому, що механізми кейс класів фіксовані, тоді як методи <code>unapply</code> або <code>unapplySeq</code> в екстракторі можуть робити майже все. Третє, якщо ваші кейс класи наслідують від закоркованого базового класа, компілятор Scala буде перевіряти ваше співпадіння шаблонів на вичерпність, та буде скаржитись, якщо деяка комбінація можливих значень не покрита шаблоном. Для екстракторів така перевірка на вичерпність не доступна.</p></div>
<div class="paragraph"><p>То який з двох методів ви маєте обрати для ваших порівнянь шаблонів? Це залежить від декількох факторів. Якщо ви пишете код для закритого застосування, кейс класи звичайно мають перевагу, завдяки їх стислості, швидкості та статичній перевірці. Якщо ви потім вирішите змінити вашу ієрархію класів, застосування буде вимагати рефакторингу, але це звичайно не проблема. З іншого боку, якщо вам треба показати клас невідомим клієнтам, екстрактори можуть переважити, оскільки вони підтримують незалежність від репрезентації.</p></div>
<div class="paragraph"><p>Нащастя, вам не треба вирішувати прямо зараз. Ви можете в любому випадку почати з кейс класів, і потім, коли постане потреба, змінити їх на екстрактори. Оскільки шаблони по екстракторам та шаблони по кейс класах виглядають так само в Scala, порівняння шаблонів в ваших клієнтах буде продовжувати робити.</p></div>
<div class="paragraph"><p>Звичайно, також існують ситуації, коли ясно з самого початку, що структура ваших шаблонів не співпадає з репрезентацією типу ваших даних. Обговорена адреса електронної пошти в цій главі є одним з таких прикладів. В такому випадку екстрактори є єдиним можливим вибором.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_7__">26.7 Регулярні вирази</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна виключено корисна оболасть застосування екстракторів є регулярні вирази. Як і Java, Scala провадить регулярні вирази через бібліотеку, але екстрактори роблять більш приємною взаємодію з ними.</p></div>
<div class="sect2">
<h3 id="____33">Формування регулярних виразів</h3>
<div class="paragraph"><p>Scala наслідує синтаксис своїх регулярних виразів від Java, що, в свою чергу, наслідує більшість з можливостей від Perl. Ми вважатимемо, що ви вже знаєте синтаксис; якщо ні, існує багато доступних інструкцій, починаючи з документації Javadoc для класа <code>java.util.regex.Pattern</code>. Ось тільки деякі приклади, що повинні бути достатні для нагадування:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">ab?</p></td>
<td align="left" valign="top"><p class="table"><code>'a'</code>, за яким можливо іде <code>'b'</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">[1em] \d+</p></td>
<td align="left" valign="top"><p class="table">Число, що складається з одної або більше цифр, представлених <code>\d</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">[a-dA-D]\w*</p></td>
<td align="left" valign="top"><p class="table">Слово, що починається з літери між <code>a</code> та <code>d</code> в верхньому або нижньому реєстрі, за яким іде послідовність з нуля або більше "слівних  символів", позначених <code>\w</code>. (Слівні символи це літери, цифри та підкреслення.)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">[1em](-)?(\d+)(\.\d*)?</p></td>
<td align="left" valign="top"><p class="table">Число, що складається з опціонального знаку мінуса, за яким слідує одна або більше цифр, за якими опціонально слідує крапка, та нуль або більше цифр. Число складається з трьох груп, тобто знаку мінусу, частини до десятичної крапки, та дрібної частини. Групи оточені дужками.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Клас регулярних виразів Scala знаходиться в пакунку <code>scala.util.matching</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.util.matching.Regex</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення нового регулярного виразу створено через передачу рядка до конструктора <code>Regex</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="s">&quot;(-)?(\\d+)(\\.\\d*)?&quot;</span><span class="o">)</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що порівняно з регулярним виразом для десятичних чисел, наданого перед цім, кожна зворотня коса надаєтся двічі в рядку вище. Це через те, що в Java та Scala поодинока зворотня коса є символом виключення в рядковому літералі, а не звичайним символом, що показується в рядку. Так що замість <code>'\'</code> вам треба писати <code>'\\'</code> щоб отримати поодиноку зворотню косу в рядку.</p></div>
<div class="paragraph"><p>Якщо регулярний вираз містить багато зворотніх косих, це може бути болісним для написання та читання. Сирі рядки Scala провадять альтернативу. Як ви бачили в Розділі 5.2, сирий рядок є послідовність символів між потроєними лапками. Різниця між сиром та звичайним рядком в тому, що всі символи в сирому рядку з'являються саме так, як вони надрукувані. Це включає зворотні косі, що не трактуються як символи виключення. Так що ви можете і дещо більш зрозуміле:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">)</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите з виводу інтерпретатора, згенерований значення результату для <code>Decimal</code> точно таке, як і раніше. Інший, навіть коротший шлях написати регулярний вираз в Scala, є такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>
</pre></div></div></div>
<div class="paragraph"><p>Іншими словами, просто додайте <code>.r</code> до рядка для отримання регулярного виразу. Це можливо, оскільки існує метод на ім'я <code>r</code> в класі <code>StringOps</code>, що конвертує рядок на регулярний вираз. Метод визначений як показано в Лістингу 26.7:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.runtime</span>
<span class="k">import</span> <span class="nn">scala.util.matching.Regex</span>

<span class="k">class</span> <span class="nc">StringOps</span><span class="o">(</span><span class="n">self</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">...</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.7 - Як метод <code>r</code> визначений в <code>StringOps</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____34">Пошук регулярних виразів</h3>
<div class="paragraph"><p>Ви можете пошукати появи регулярного виразу в рядку, використовуючи різні оператори:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>regex findFirstIn str</code></pre>
</div></div>
<div class="paragraph"><p>Знаходить першу появу регулярного виразу <code>regex</code> в рядку <code>str</code>, повертаючи результат в типі <code>Option</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>regex findAllIn str</code></pre>
</div></div>
<div class="paragraph"><p>Знаходить всі появи регулярного виразу <code>regex</code> в рядку <code>str</code>, повертаючи результат як <code>Iterator</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>regex findPrefixOf str</code></pre>
</div></div>
<div class="paragraph"><p>Знаходить появу регулярного виразу <code>regex</code> на початку рядка <code>str</code>, повертаючи результат в типі <code>Option</code>. Наприклад, ви можете визначити вхідну послідовність нижче, та пошукати в ній десятичні числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">input</span> <span class="k">=</span> <span class="s">&quot;for -1.0 to 99 by 3&quot;</span>
<span class="n">input</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">for</span> <span class="o">-</span><span class="mf">1.0</span> <span class="n">to</span> <span class="mi">99</span> <span class="n">by</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">s</span> <span class="k">&lt;-</span> <span class="nc">Decimal</span> <span class="n">findAllIn</span> <span class="n">input</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">-</span><span class="mf">1.0</span>
<span class="mi">99</span>
<span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Decimal</span> <span class="n">findFirstIn</span> <span class="n">input</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(-</span><span class="mf">1.0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Decimal</span> <span class="n">findPrefixOf</span> <span class="n">input</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="______14">Екстракція за допомогою регулярних виразів</h3>
<div class="paragraph"><p>Більше того, кожний регулярний вираз в Scala визначає екстрактор. Екстрактор використовується для ідентифкації субрядків, що співпадають з групами регулярного виразу. Наприклад, ви можете декомпонувати рядок числа таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;-1.23&quot;</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">-</span>
<span class="n">integerpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">decimalpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">.</span><span class="mi">23</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі шаблон <code>Decimal(...)</code> використовується в визначенні <code>val</code>, як описано в Розділі 15.7. Що тут відбувається, це значення регулярного виразу <code>Decimal</code> визначає метод <code>unapplySeq</code>. Цей метод співпадає з кожним рядком, що відповідає до синтаксису регулярного виразу для десятичних чисел. Якщо рядок співпадає, частини відповідно до трьох груп в регулярному виразі <code>(-)?(\d+) (\.\d*)?</code> повертаються як елементи шаблону, та потім співпадають з трома змінними шаблону: <code>sign</code>, <code>integerpart</code> та <code>decimalpart</code>. Якщо група відсутня, значення встановлюється в <code>null</code>, як можна бачити в наступному прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;1.0&quot;</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
<span class="n">integerpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">decimalpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">.</span><span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Також можливо міксувати екстрактори з пошуком регулярних виразів в  <code>for</code> виразах. Наприклад, наступний вираз декомпонує всі десятичні числа, що він знайде у вхідному рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="nc">Decimal</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">Decimal</span> <span class="n">findAllIn</span> <span class="n">input</span><span class="o">)</span>
          <span class="n">println</span><span class="o">(</span><span class="s">&quot;sign: &quot;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;, integer: &quot;</span> <span class="o">+</span>
              <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;, decimal: &quot;</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">-</span><span class="o">,</span> <span class="n">integer</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">.</span><span class="err">0</span>
<span class="kt">sign:</span> <span class="kt">null</span><span class="o">,</span> <span class="n">integer</span><span class="k">:</span> <span class="err">99</span><span class="o">,</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">null</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">null</span><span class="o">,</span> <span class="n">integer</span><span class="k">:</span> <span class="err">3</span><span class="o">,</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">null</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__35">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили, як узагальнити співпадіння шаблонів за допомогою екстракторів. Екстрактори дозволяють вам визначити ваші власні типи шаблонів, що не мають відповідати типу виразів, по яких ви робите вибірку. Це дає вам більше гнучкості в типах шаблонів, що ви можете використовувати для співпадіння. Ефективно це як мати різні можливі погляди на ті самі дані. Це також дає вам прошарок між репрезентацією типа, та тим, як клієнт бачить його. Це дозволяє вам робити порівняння шаблонів, при цьому підтримуючи незалежність репрезентації, властивість, що дуже корисна в великих програмних системах.</p></div>
<div class="paragraph"><p>Екстрактори - це ще один елемент серед ваших інструментів, що дозволяє вам визначити гнучкі абстракції бібліотеки. Вони потужно використовуються в бібліотеках Scala, наприклад, для зручного порівняння регулярних виразів.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__27_2">Глава 27</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__36">Анотації</h1>
<div class="sect1">
<h2 id="_27_1____">27.1 Для чого потрібні анотації?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Є багато речей, які ви можете робити з програмою, крім компіляції та виконання. Ось деякі приклади:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Автоматична генерація документації з Scaladoc.
</p>
</li>
<li>
<p>
Форматування коду, так щоб він співпадав з вашим стилем.
</p>
</li>
<li>
<p>
Перевірка коду на загальні помилки, як відкриття файлу, та за деяких шляхів виконання відсутність його закриття.
</p>
</li>
<li>
<p>
Експериментальна перевірка типів, наприклад, щоб керувати побічними ефектами або для гарантії властивостей власності.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Такі інструменти називаються інструментами мета-програмування, оскількі вони є програмами, що приймають інші програми на вході. Анотації підтримують ці інструменти, дозволяючи програмісту  включати директиви для таких інструментів через джерельний код. Такі директиви дозволяють інструментам бути більш ефективними, порівняно з тим, якщо вони не мали б користувацького вводу. Наприклад, анотації можуть покращити попередньо перелічені інструменти наступним чином:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Генератор документації може бути проінструктований, що певний метод треба документувати як застарілий.
</p>
</li>
<li>
<p>
Форматувальник може бути проінструктований перестрибнути через частини програми, що були дбайливо відформатовані вручну.
</p>
</li>
<li>
<p>
Перевіряч незачинених файлів може бути поінструктований ігнорувати певний файл, що перевіряється на зачиненість вручну.
</p>
</li>
<li>
<p>
Перевіряч побічних ефектів може бути поінструктований перевірити, що вказаний метод не має побічних ефектів.
</p>
</li>
</ol></div>
<div class="paragraph"><p>У всіх ціх випадках теоретично має бути можливим для програмної мови провадити способи вставити додаткову інформацію. Фактично, більшість з цього напряму підтримується в тій чи іншій мові. Однак для кожної мови існує дуже багато таких інструментів, щоб напряму підтримувати їх всі. Більше того, вся ця інформація повністю ігнорується компілятором, який кінець кінцем лише бажає зробити код робочим.</p></div>
<div class="paragraph"><p>Філософія Scala в випадках як цей є включати мінімальну, ортогональну підтримку в основній мові, так що потім може бути написаний широкий загал інструмнтів мета програмування. В цьому випадку ця мінімальна підтримка є система анотацій. Компілятор розуміє тільки одну можливість, анотації, але він не додає жодного значення до окремих анотацій. Кожний інструмент мета програмування може визначати та використовувати свої особливі анотації.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_27_2__">27.2 Синтаксис анотацій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Типове визначення анотації виглядає ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@deprecated</span> <span class="k">def</span> <span class="n">bigMistake</span><span class="o">()</span> <span class="k">=</span> <span class="c1">//...</span>
</pre></div></div></div>
<div class="paragraph"><p>Анотацією є частина <code>@deprecated</code>, і вона стосується повністю до метода <code>bigMistake</code> (не показаний — він дуже жахливий). В цьому випадку метод помічений як дещо, що автор <code>bigMistake</code> бажав би, щоб ви не використовували. Можливо <code>bigMistake</code> буде повністю видалений з наступної версії коду.</p></div>
<div class="paragraph"><p>В попередньому прикладі метод анотований як <code>@deprecated</code>. Анотації дозволяються також в інших місцях. Анотації дозволяються на любому різновиді анотації або визначення, включаючи <code>val</code>, <code>var</code>, <code>def</code>, <code>class</code>, <code>object</code>, <code>trait</code> та <code>type</code>. Анотація стосується повністю до декларації або визначення, що слідує за ним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@deprecated</span> <span class="k">class</span> <span class="nc">QuickAndDirty</span> <span class="o">{</span>
<span class="c1">//...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анотації також можуть бути застосовані до виразу, як з анотацією <code>@unchecked</code> для порівняння шаблонів (див. Главу 15). Щоб зробити це, поставьте дві крапки (<code>:</code>) після виразу, та потім напишіть анотацію. Синтаксично це виглядає так, якби анотація була використаною як тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
<span class="c1">// non-exhaustive cases...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, анотації можуть бути розташовані на типах. Анотовані типи описані далі в цій главі.</p></div>
<div class="paragraph"><p>Досі показані анотації були просто символом <code>@</code>, за яким слідує склас анотації. Така проста анотація загальна та корисна, але анотації мають багатшу загальну форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@annot</span><span class="o">(</span><span class="n">exp_</span><span class="o">{</span><span class="mi">1</span><span class="o">},</span> <span class="n">exp_</span><span class="o">{</span><span class="mi">2</span><span class="o">},</span> <span class="o">...)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>annot</code> вказує клас анотації. Всі анотації мають включати цю частину. Частини <code>exp</code> є аргументами анотації. Для анотацій як <code>@deprecated</code>, що не потребує жодних елементів, ви звичайно можете полишити дужки, але ви можете записати <code>@deprecated()</code>, якщо бажаєте. Для анотацій, що мають аргументи, покладайте аргументи в дужки, наприклад, <code>@serial(1234)</code>.</p></div>
<div class="paragraph"><p>Точна форма аргументів, які ви можете надати до анотації, залежить від окремого класу анотації. Більшість процесорів дозволяють вам надавати безпосередні константи, як <code>123</code> або <code>"hello"</code>. Сам компілятор, однак, підтримує довільні вирази, доки вони проходять перевірку типів. Деякі анотації класів можуть це використовувати, наприклад, щоб дозволити вам посилатись на інші змінні, крім таких з поля зору:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@cool</span> <span class="k">val</span> <span class="n">normal</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="nd">@coolerThan</span><span class="o">(</span><span class="n">normal</span><span class="o">)</span> <span class="k">val</span> <span class="n">fonzy</span> <span class="k">=</span> <span class="s">&quot;Heeyyy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Внутрішньо Scala представляє анотації як просто виклик конструктора на класі анотатора — замініть <code>@</code> на <code>new</code>, і ви матимете валідний вираз створення примірника. Це означає, що іменовані та аргументи по замовчанню  підтримуються природно, оскільки Scala вже має іменовані та аргументи по замовчанню для викликів методів та конструкторів. Одне з доволі заплутаних питань щодо анотацій, що концептуально приймають інші анотації як аргументи, чого потребують деякі фреймворки. Ви не можете писати анотації напряму як аргументи до анотацій, оскільки анотації не є валідними виразами. В таких випадках ви маєте використовувати <code>new</code> замість <code>@</code>, як проілюстровано тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">annotation._</span>
<span class="k">import</span> <span class="nn">annotation._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">strategy</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Annotation</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Annotation</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">strategy</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">delayed</span> <span class="k">extends</span> <span class="nc">Annotation</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">delayed</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nd">@strategy</span><span class="o">(</span><span class="nd">@delayed</span><span class="o">)</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">1</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">illegal</span> <span class="kt">start</span> <span class="kt">of</span> <span class="kt">simple</span> <span class="kt">expression</span>
      <span class="nd">@strategy</span><span class="o">(</span><span class="nd">@delayed</span><span class="o">)</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
                <span class="o">^</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nd">@strategy</span><span class="o">(</span><span class="k">new</span> <span class="n">delayed</span><span class="o">)</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
<span class="n">f</span><span class="k">:</span> <span class="o">()</span><span class="kt">Unit</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_27_3__">27.3 Стандартні анотації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala включає декілька стандартних анотацій. Вони призначені для можливостей, що використовуються досі загально, щоб заслужити розташування в специфікації мови, але не досить фундаментальні, щоб отримати свій власний синтаксис. З часом буде тонка струмка нових анотацій, що будуть додані до стандарту в такий самий спосіб.</p></div>
<div class="sect2">
<h3 id="__37">Застаріння</h3>
<div class="paragraph"><p>Іноді ви пишете клас або метод, про який потім бажаєте, щоб його не було. Однак коли він вже доступний, код, написаний іншими людьми може викликати цей метод. Таким чином ви не можете просто видалити цей метод, оскільки після цього код інших людей перестане компілюватись.</p></div>
<div class="paragraph"><p>Застаріння дозволяє вам елегантно видалити метод або клас, що виявився помилкою. Ви помічаєте метод або клас як застарілий, та потім будь хто при виклику цього методу або класу буде отримувати попередження про застарілість. Їм краще дослухатись до цього попередження та оновити їхній код! Ідея в тому, що після спливання віповідного проміжку часу ви відчуватимете безпечним в припущенні, що всі помірковані клієнти припинять доступатись до застарілого класу або методу, і, таким чином, що ви можете безпечно видалити його.</p></div>
<div class="paragraph"><p>Ви відмічаєте метод як застарілий просто написавши перед ним <code>@deprecated</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@deprecated</span> <span class="k">def</span> <span class="n">bigMistake</span><span class="o">()</span> <span class="k">=</span>
<span class="c1">//...</span>
</pre></div></div></div>
<div class="paragraph"><p>Така анотація призведе до того, що Scala компілятор додасть повідомлення про застарілість кожного разу, коли код Scala отримує доступ до метода.</p></div>
<div class="paragraph"><p>Якщо ви надасте рядок як аргумент до <code>@deprecated</code>, цей рядок буде виданий разом з повідомленням про помилку. Використовуйте це повідомлення для пояснення розробникам, що вони повинні використовувати замість застарілого метода.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@deprecated</span><span class="o">(</span><span class="s">&quot;use newShinyMethod() instead&quot;</span><span class="o">)</span>
<span class="k">def</span> <span class="n">bigMistake</span><span class="o">()</span> <span class="k">=</span> <span class="c1">//...</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер викликачі будуть отримувати таке повідомлення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="n">deprecation</span> <span class="nc">Deprecation2</span><span class="o">.</span><span class="n">scala</span>
<span class="nc">Deprecation2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">33</span><span class="kt">:</span> <span class="kt">warning:</span> <span class="kt">method</span> <span class="kt">bigMistake</span> <span class="kt">in</span> <span class="kt">objectDeprecation2</span> <span class="kt">is</span> <span class="kt">deprecated:</span> <span class="kt">use</span> <span class="kt">newShinyMethod</span><span class="o">()</span> <span class="kt">instead</span>
    <span class="n">bigMistake</span><span class="o">()</span>
    <span class="o">^</span>
<span class="n">one</span> <span class="n">warning</span> <span class="n">found</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___60">Мінливі поля</h3>
<div class="paragraph"><p>Конкурентно програмування негарно міксується з загальним змінним станом. З цієї причини фокус підтримки конкурентності Scala є передача повідомлень, та мінімум загального змінного стану. Дивіться Главу 32 щодо деталей.</p></div>
<div class="paragraph"><p>Тим не менш, іноді програмісти бажають використати змінний стан в їх конкурентних програмах. Анотація <code>@volatile</code> допомагає в таких випадках. Вона інформує компілятор, що розглядувана змінна буде використана в декількох потоках. Такі змінні реалізовані так, що читання та запис до них повільнішій, але доступ з декількох потоків поводиться більш передбачувано.</p></div>
<div class="paragraph"><p>Ключове слово <code>@volatile</code> дає різні гарантії на різних платформах. Однак на Java платформі ви отримаєте ту саму поведінку, якби ви написали поле в Java коді, і помітили його за допомогою модифікатора Java <code>volatile</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___61">Бінарна сериалізація</h3>
<div class="paragraph"><p>Багато мов включають фреймворк для бінарної сериалізації. Фреймворк сериалізації допомагає вам конвертувати об'єкти в потоки байтів і навпаки. Це корисно, якщо ви бажаєте зберігти об'єкти на диску, або надіслати їх по мережі. XML може допомогти для тих же цілей (дивіться Главу 28), але він має інші недоліки відносно швидкості, використання простору, гнучкості та портабельності.</p></div>
<div class="paragraph"><p>Scala не має власного фреймворку сериалізації. Замість цього вам слідує використовувати фреймворк для вашої підлеглої платформи. Що робить Scala, це провадить три анотації, що корисні для різних фреймворків. Також компілятор Scala для платформи Java інтерпретує ці анотації в Java спосіб (дивіться Главу 31).</p></div>
<div class="paragraph"><p>Перша анотація вказує, чи клас взагалі серіалізується. Більшість класів сериалізуються, але не всі. Вказівник на сокет або GUI вікно, наприклад, не можуть бути серіалізовані. По замовчанню клас не розглядається як серіалізуємий. Вам слідує додати анотацію @<code>serializable</code> до любого класу, що буде серіалізуватись.</p></div>
<div class="paragraph"><p>Друга анотація допомагає мати справу зі змінами серіалізованих класів з плином часу. Ви можете додати серійний номер до поточної версії класу, через додавання анотації, як <code>@SerialVersionUID(1234)</code>, де <code>1234</code> має бути замінено на ваш серійний номер. Фреймворк повинен зберігати це число в згенерованому байтовому потоці. Коли потім ви перезавантажите байтовий потік, та спробуєте конвертувати його на об'єкт, фреймворк може перевірити, що поточна версія класу має той самий номер версії, що і версія в байтовому потоці. Якщо ви бажаєте зробити сериалізація-несумісні зміни до вашого класу, тоді ви можете змінити номер версії. Тоді фреймворк буде автоматично відхиляти завантаження старих примірників класу.</p></div>
<div class="paragraph"><p>Нарешті, Scala провадить анотацію <code>@transient</code> для полів, що взагалі не мають бути серіалізовані. Якщо ви помітите поле як <code>@transient</code>, тоді фреймворк не повинен зберігати поле, навіть коли оточуючий об'єкт серіалізується. Коли об'єкт завантажується, поле буде відновлене в значення по замовчанню для типу поля, анотованого як <code>@transient</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_get_code__code_set_code">Автоматичні методи <code>get</code> та <code>set</code></h3>
<div class="paragraph"><p>Scala код звичайно не потребує явних методів <code>get</code> та <code>set</code> для полів, оскілько Scala змішує синтаксис для доступу до полів та виклик методів. Однак, деякі платформ-специфічні фреймворки очікують методи <code>get</code> та <code>set</code>. Для ціх цілей Scala провадить анотацію <code>@scala.reflect.BeanProperty</code>. Якщо ви додаєте цю анотацію до поля, компілятор буде автоматично генерувати <code>get</code> та <code>set</code> для вас. Якщо ви анотуєте поле на ім'я <code>crazy</code>, <code>get</code> метод буде названий <code>getCrazy</code>, та <code>set</code> метод буде названий <code>setCrazy</code>.</p></div>
<div class="paragraph"><p>Згенеровані методи <code>get</code> та <code>set</code> доступні тільки після того, як прохід компілятора буде завершено. Таким чином ви не можете викликати ці методи <code>get</code> та <code>set</code> з кода, що ви компілюєте, разом з анотованим полем. Це не має бути проблемою на практиці, оскільки в Scala коді ви можете отримувати доступ до полів напряму. Ця можливість призначеня для підтримкм фреймворків, що очікують звичайних методів <code>get</code> та <code>set</code>, та типово ви не компілюєте фреймворк, та код, що його використовує, одночасно.</p></div>
</div>
<div class="sect2">
<h3 id="_tailrec">Tailrec</h3>
<div class="paragraph"><p>Ви будете типово додавати анотацію <code>@tailrec</code> до метода, що має хвостову рекурсію, наприклад тому, що ви очікуєте, що інакше рекурсія буде занадто глибокою. Щоб переконатись, що компілятор Scala виконує хвостову рекурсію метода з оптимізацією, описаною в Розділі 8.9, ви можете додати <code>@tailrec</code> перед визначенням метода. Якщо оптимізація не може бути виконана, ви будете отримувати попередження, разом з поясненням причини.</p></div>
</div>
<div class="sect2">
<h3 id="_unchecked">Unchecked</h3>
<div class="paragraph"><p>Анотація <code>@unchecked</code> інтерпретується компілятором під час порівняння шаблонів. Вона каже компілятору не турбуватись, якщо вираз <code>match</code> здається не враховує деякі випадки. Дивіться Розділ 15.5 для деталей.</p></div>
</div>
<div class="sect2">
<h3 id="___62">Природні методи</h3>
<div class="paragraph"><p>Анотація <code>@native</code> інформує компілятор, що реалізація метода надається скоріше середовищем виконання, ніж кодом Scala. Компілятор буде перемикати відповідний флаг на виході, і покладається на розробника надати реалізацію, використовуючі механізми, такі як Java Native Interface (JNI).</p></div>
<div class="paragraph"><p>При використанні анотації <code>@native</code> тіло метода має бути надане, але воно не потрапить на вихід. Наприклад, ось як декларується метод <code>beginCountdown</code>, що буде наданий під час виконання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nd">@native</span>
<span class="k">def</span> <span class="n">beginCountdown</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_27_4_">27.4 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава описує платформ-незалежні аспекти анотацій, про які вам скоріше всього треба знати. Перед усім вона розповідає про синтаксис анотацій, оскіль використання анотацій є значно більш загальним, ніж використання нових. Друге, вона показує, як використовувати декілька анотацій, що підтримуються стандартним компілятором Scala, включаючи <code>@deprecated</code>, <code>@volatile</code>, <code>@serializable</code>, <code>@BeanProperty</code>, <code>@tailrec</code> та <code>@unchecked</code>.</p></div>
<div class="paragraph"><p>Глава 31 дає додаткову, Java-специфічну інформацію по анотаціях. Це покриває анотації, доступні тільки при цілі на Java, додаткове значення стандартних анотацій при цілі на Java, як взаємодіяти з Java-базованими анотаціями, і як використовувати Java-базовані механізми для визначення та обробки анотацій вScala.</p></div>
<div class="paragraph"><p>Анотації є структурованою інформацією, доданою до програмного джерельного коду. Як коментарі, вони можуть бути розпорошені по програмі та приєднані до кожної змінної, методу, виразу або іншому елементу програми. На відміну від коментарів, вони мають структуру,  таким чином спрощуючи машинну обробку.</p></div>
<div class="paragraph"><p>Ця глава показує, як використовувати анотації в Scala. Вона також показує їх загальний синтаксис, та як використовувати декілька стандартних анотацій.</p></div>
<div class="paragraph"><p>Ця глава не показує, як писати нові інструменти обробки анотацій, оскільки це за межами цієї книги. Глава 31 показує один прийом, але він не поодинокий. Замість цього, ця глава фокусується на тому, як використовувати анотації, оскільки більш загально використовувати анотації, ніж визначати нові процесори анотацій.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__28_2">Глава 28</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___xml">Робота з XML</h1>
<div class="paragraph"><p>Ця глава вводить в підтримку XML в Scala. Після дискутування напів-структурованих даних взагалі, вона показує основну функціональність в Scala для маніпулювання XML: як створити вузли з допомогою XML літералів, як зберігти та завантажити XML з файлів, та як розбити XML вузли з використанням методів запитів та порівняння шаблонів. Ця глава є тільки коротким введенням в те, що можливо з допомогою XML, але вона показує вам досить для початку.</p></div>
<div class="sect1">
<h2 id="_28_1___">28.1 Напів-структуровані дані</h2>
<div class="sectionbody">
<div class="paragraph"><p>XML є формою _напів-структурованих_ даних. Він є більш структурованим ніж прості рядки, оскільки він організує вміст даних в вигляді дерев. Однак простий XML менш структурований, ніж об'єкти в мові програмування, оскільки він дозволяє довільний текст між тегами, та йому бракує системи типів.<span class="footnote"><br />[Існують системи типів для XML, такі як XML Schemas, але вони за полем зору цієї книги.]<br /></span></p></div>
<div class="paragraph"><p>Напів-структуровані дані дуже корисні кожного разу, коли вам треба серіалізувати дані програми для збереження в файлі або доставки через мережу. Замість конвертування структурованих даних кожного разу до байтів, ви конвертуєте їх до-та-з напів-структурованих даних. Потім ви використовуєте існуючу бібліотечні процедури для конвертації напів-структурованих даних в бінарні дані, зберігаючи ваш час для більш важливих проблем.</p></div>
<div class="paragraph"><p>Існує багато форм напів-структурованих даних, але XML є найбільш широко використовуваною формою в інтернеті. Існують XML інструменти для більшості операційних систем, та більшість мов програмування мають доступні XML бібліотеки. Його популярність само-підсилююча. Чим більше інструментів та бібліотек розробляється у відповідь на популірність XML, тим вірогідніше інженери програмного забезпечення оберуть XML як частину своїх форматів. Якщо ви пишете програмне забезпечення, що комунікує через інтернет, тоді скоріше або пізніше вам буде треба взаємодіяти з якимось сервісом, що розмовляє мовою XML.</p></div>
<div class="paragraph"><p>З усіх ціх причин Scala включає спеціальну підтримку для обробки XML. Ця глава показує вам підтримку Scala для конструювання XML, його обробку звичайними методами, та обробку за допомогою порівняння шаблонів Scala. На додаток до ціх основ, глава по ходу показує декілька загальних ідіом по використанню XML в Scala.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_2__xml">28.2 Огляд XML</h2>
<div class="sectionbody">
<div class="paragraph"><p>XML побудований з двох базових елементів, тексту та тегів.<span class="footnote"><br />[Повна історія трохи складніша, але цього достатньо щоб бути ефективним з XML.]<br /></span> Текст є, як звичайно, любою послідовністю символів. Теги, записані як <code>&lt;pod&gt;</code>, складаються зі знака меньше, літерної мітки, та знака більше. Тегі можуть бути відкриваючими та закриваючими. Закриваючий тег виглядає як відкриваючий, за винятком того, що він має косу прямо перед міткою тега, як тут: &lt;/pod&gt;.</p></div>
<div class="paragraph"><p>Відкриваючий та закриваючий тег мають відповідати один до одного, так само як дужки. Кожний відкриваючий тег повинен раніше чи пізніше мати закриваючий тег з такою ж міткою. Так що наступне нелегальне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>// Illegal XML
One <span class="nt">&lt;pod&gt;</span>, two <span class="nt">&lt;pod&gt;</span>, three <span class="nt">&lt;pod&gt;</span> zoo
</pre></div></div></div>
<div class="paragraph"><p>Більше того, вміст любих двух парних тегів сам має бути валідним XML. Ви не можете мати дві пари тегів, які перекривають один одного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>// Also illegal
<span class="nt">&lt;pod&gt;</span>Three <span class="nt">&lt;peas&gt;</span> in the <span class="nt">&lt;/pod&gt;&lt;/peas&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете, однак, написати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nt">&lt;pod&gt;</span>Three <span class="nt">&lt;peas&gt;&lt;/peas&gt;</span> in the <span class="nt">&lt;/pod&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки теги мають співпадати один з одним в такий спосіб, XML структурований як вкладені елементи. Кожна пара відповідних відкриваючих та закриваючих тегів формують елемент, та елементи можуть бути вкладені один в другий. В прикладі вище цілий <code>&lt;pod&gt;Three &lt;peas&gt;&lt;/peas&gt; in the &lt;/pod&gt;</code> є елементом, <code>&lt;peas&gt;&lt;/peas&gt;</code> є елементом, вкладеним в перший.</p></div>
<div class="paragraph"><p>Такі основи. Дві інші речі, які вам треба знати: перше, існує скорочена нотація для відкриваючого тега, за яким зразу іде закриваючий тег. Просто запишіть один тег з косою після мітки тегу. Такий тег складається з порожнього елементу. Використовуючи порожній елемент, попередній приклад може бути просто записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">pod</span><span class="o">&gt;</span><span class="nc">Three</span> <span class="o">&lt;</span><span class="n">peas</span><span class="o">/&gt;</span> <span class="n">in</span> <span class="n">the</span> <span class="o">&lt;/</span><span class="n">pod</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Друге, початковий тег може мати приєднані до нього атрибути. Атрибут є пара ім'я-значення, написана зі знаком рівності між ними. Ім'я атрибуту є простим, неструктурованим текстом, та значення оточене або подвійними (<code>""</code>) або поодинокими (<code>''</code>) лапками. Атрибути виглядають так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nt">&lt;pod</span> <span class="na">peas=</span><span class="s">&quot;3&quot;</span> <span class="na">strings=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_3_xml_">28.3 XML літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala дозволяє вам вбивати XML як літерал будь-де, де є валідним вираз. Просто набираєте початковий тег та потім продовжуєте писати XML вміст. Компілятор перейде в режим вводу XML та буде читати вміст XML доки не побачить закриваючий тег, що співпадає з тим, з якого ви почали:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
          <span class="nc">This</span> <span class="n">is</span> <span class="n">some</span> <span class="nc">XML</span><span class="o">.</span>
          <span class="nc">Here</span> <span class="n">is</span> <span class="n">a</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">&lt;atag/&gt;</span>
       <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
  <span class="nc">This</span> <span class="n">is</span> <span class="n">some</span> <span class="nc">XML</span><span class="o">.</span>
  <span class="nc">Here</span> <span class="n">is</span> <span class="n">a</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">&lt;atag/&gt;</span>
<span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Результатом цього виразу є тип <code>Elem</code>, що означає елемент XML з міткою <code>a</code> та вмістом <code>"This is some XML...,"</code>. Деякі інші важливі XML класи:</p></div>
<div class="ulist"><ul>
<li>
<p>
Клас <code>Node</code> є абстрактним суперкласом всіх класів вузлів XML.
</p>
</li>
<li>
<p>
Клас <code>Text</code> є вузол, що містить лише текст. Наприклад, <code>"stuff"</code> що є частиною <code>&lt;a&gt;stuff&lt;/a&gt;</code> має клас <code>Text</code>.
</p>
</li>
<li>
<p>
Клас <code>NodeSeq</code> містить послідовність вузлів. Багато методів в XML бібліотеці обробляють <code>NodeSeqs</code> в місцях, де ви б могли очікувати, що вони обробляють окремі <code>Node</code>. Ви все ще можете використовувати такі методи з окремими вузлами, однак, оскільки <code>Node</code> є розширенням <code>NodeSeq</code>. Це може виглядати збочено, але це гарно робить для XML. Ви можете думати про окремі <code>Node</code>, як про одно-елементні <code>NodeSeq</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ви не обмежені виписувати точний XML який бажаєте, символ в символ. Ви можете обислити Scala код всередині XML дітерала, через використання фігурних дужок <code>{}</code> як виключення. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="s">&quot;hello&quot;</span> <span class="o">+</span> <span class="s">&quot;, world&quot;</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Виключення фігурними дужками включає довільний Scala вміст, включаючи подальші XML літерали. Таким чином, по мірі зростання рівня вкладеності, ваш код може перемикатись між XML та звичайним Scala кодом.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">1955</span>
<span class="n">yearMade</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1955</span>

<span class="n">scala</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span> <span class="k">if</span> <span class="o">(</span><span class="n">yearMade</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="o">)</span> <span class="o">&lt;</span><span class="n">old</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">old</span><span class="o">&gt;</span>
              <span class="k">else</span> <span class="n">xml</span><span class="o">.</span><span class="nc">NodeSeq</span><span class="o">.</span><span class="nc">Empty</span> <span class="o">}</span>
        <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">old</span><span class="o">&gt;</span><span class="mi">1955</span><span class="o">&lt;/</span><span class="n">old</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо код в фігурних дужках обчислюється або до XML вузла, або до послідовності XML вузлів, ці вузли вставляються прямо як є. В прикладі вище, якщо <code>yearMade</code> меньше ніж <code>2000</code>, він огортається в теги <code>&lt;old&gt;</code>, та додається до елемента <code>&lt;a&gt;</code>. Інакше нічого не додається. Зауважте щодо прикладу вище, що "нічого" як XML вузол позначається <code>xml.NodeSeq.Empty</code>. Вираз виключення в фігурних дужках не має обчислюватись до вузла XML. Він може обчислюватись до любого значення Scala. В такому випадку результат буде перетворено на рядок, та вставлено як текстовий вузол:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="mi">7</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Любі символи <code>&lt;</code>, <code>&gt;</code> та <code>&amp;</code> в тексті будуть виключені, якщо ви роздрукуєте вузол:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="s">&quot;&lt;/a&gt;potential security hole&lt;a&gt;&quot;</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span><span class="n">potential</span> <span class="n">security</span>
<span class="n">hole</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Для контрасту, якщо ви створюєте XML з низькорівневими операціями з рядками, ви попадете в пастку, як наступна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">&quot;&lt;a&gt;&quot;</span> <span class="o">+</span> <span class="s">&quot;&lt;/a&gt;potential security hole&lt;a&gt;&quot;</span> <span class="o">+</span> <span class="s">&quot;&lt;/a&gt;&quot;</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span><span class="n">potential</span> <span class="n">security</span> <span class="n">hole</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це що наданий користувачем рядок включає XML теги самі по собі, в цьому випадку <code>&lt;/a&gt;</code> та <code>&lt;a&gt;</code>. Ця поведінка може дозволити деякі капосні сюрпризи для початкового програміста, оскільки дозволяє користувачеві впливати на результуюче дерево XML за межами простору, наданому для користувача в елементі <code>&lt;a&gt;</code>. Ви можете запобігти всьому цьому класу проблем, завжди конструюючи XML з використанням XML літералів, а не додавання рядків.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_4_">28.4 Сериалізація</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили досить щодо Scala підтримки XML, щоб написати першу частину серіалізатора: перетворення від внутрішніх структур даних до XML. Все що вам треба для цього, це XML літерали та їх виключення в фігурних дужках.</p></div>
<div class="paragraph"><p>Як приклад, уявімо, що ви реалізуєте базу даних, яка відстежує вашу екстенсивну колекцію вінтажних термометрів Coca-Cola. Ви можете зробити наступний внутрішній клас, що утримуватиме елементи каталогу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CCTherm</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">yearMade</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">dateObtained</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">bookPrice</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// in US cents</span>
  <span class="k">val</span> <span class="n">purchasePrice</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// in US cents</span>
  <span class="k">val</span> <span class="n">condition</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// 1 to 10</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">description</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це прямолінійний, набитий даними клас, що містить різні частини інформації, такі, як де термометр було зроблено, коли ви його отримали, та скільки заплатили за нього. Щоб конвертувати примірники цього класу до XML, просто додайте метод <code>toXML</code>, що використовує XML літерали та виключення в фігурних дужках, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CCTherm</span> <span class="o">{</span>
<span class="o">...</span>
<span class="k">def</span> <span class="n">toXML</span> <span class="k">=</span>
  <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;{</span><span class="n">description</span><span class="o">}&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;{</span><span class="n">dateObtained</span><span class="o">}&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;{</span><span class="n">bookPrice</span><span class="o">}&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;{</span><span class="n">purchasePrice</span><span class="o">}&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;{</span><span class="n">condition</span><span class="o">}&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось цей метод в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">therm</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CCTherm</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">description</span> <span class="k">=</span> <span class="s">&quot;hot dog #5&quot;</span>
        <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">1952</span>
        <span class="k">val</span> <span class="n">dateObtained</span> <span class="k">=</span> <span class="s">&quot;March 14, 2006&quot;</span>
        <span class="k">val</span> <span class="n">bookPrice</span> <span class="k">=</span> <span class="mi">2199</span>
        <span class="k">val</span> <span class="n">purchasePrice</span> <span class="k">=</span> <span class="mi">500</span>
        <span class="k">val</span> <span class="n">condition</span> <span class="k">=</span> <span class="mi">9</span>
      <span class="o">}</span>
<span class="n">therm</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span> <span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">therm</span><span class="o">.</span><span class="n">toXML</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>

<span class="nc">NOTE</span><span class="k">:</span> <span class="kt">Вираз</span> <span class="kt">`new CCTherm`</span> <span class="kt">в</span> <span class="kt">попередньому</span> <span class="kt">прикладі</span> <span class="kt">робить</span><span class="o">,</span> <span class="n">навіть</span> <span class="n">якщо</span> <span class="n">`CCTherm`</span> <span class="n">є</span> <span class="n">абстрактним</span> <span class="n">класом</span><span class="o">,</span> <span class="n">оскільки</span> <span class="n">цей</span> <span class="n">синтаксис</span> <span class="n">насправді</span> <span class="n">створює</span> <span class="n">примірник</span> <span class="n">анонімного</span> <span class="n">субкласу</span> <span class="n">`CCTherm`</span><span class="o">.</span> <span class="n">Анонімні</span> <span class="n">класи</span> <span class="n">описані</span> <span class="n">в</span> <span class="n">Розділі</span> <span class="mf">20.5</span><span class="o">.</span>

<span class="n">Доречі</span><span class="o">,</span> <span class="n">якщо</span> <span class="n">ви</span> <span class="n">бажаєте</span> <span class="n">включити</span> <span class="n">фігурні</span> <span class="n">дужки</span> <span class="n">`{`</span> <span class="n">або</span> <span class="n">`}`</span> <span class="n">як</span> <span class="nc">XML</span> <span class="n">текст</span><span class="o">,</span> <span class="n">але</span> <span class="n">не</span> <span class="n">використовувати</span> <span class="n">їх</span> <span class="n">для</span> <span class="n">виключення</span> <span class="nc">Scala</span> <span class="n">коду</span><span class="o">,</span> <span class="n">просто</span> <span class="n">запишіть</span> <span class="n">їх</span> <span class="n">два</span> <span class="n">рази</span> <span class="n">поспіль</span><span class="k">:</span> <span class="err">[</span><span class="kt">source</span><span class="o">,</span><span class="n">scala</span><span class="err">]</span>
</pre></div></div></div>
<div class="paragraph"><p>scala&gt; &lt;a&gt; {{{{brace yourself!}}}} &lt;/a&gt;
res7: scala.xml.Elem = &lt;a&gt; {{brace yourself!}} &lt;/a&gt;</p></div>
<div class="listingblock">
<div class="content">
<pre><code>28.5 Розбиття XML на частини</code></pre>
</div></div>
<div class="paragraph"><p>Серед багатьох методів, доступних для XML класів, існує щонайменьше три, про які вам слідує знати. Вони дозволяють вам розбити XML на частини, багато не думаючи щодо того, як саме в точності XML представлений в Scala. Ці методи базуються на мові XPath для обробки XML. Як взагалі в Scala, ви можете писати їх напряму в коді Scala, замість викликати зовнішній інструмент.</p></div>
<div class="paragraph"><p><strong>Екстрагування тексту.</strong> Через виклик метода <code>text</code> на любому вузлі XML ви отримуєте весь текст в вузлі, мінус тегі елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="nc">Sounds</span> <span class="o">&lt;</span><span class="n">tag</span><span class="o">/&gt;</span> <span class="n">good</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">text</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Sounds</span> <span class="n">good</span>
</pre></div></div></div>
<div class="paragraph"><p>Любі закодовані символи розкодуються автоматично:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">---&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">output</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">text</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot; input ---&gt; output &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Екстрагування суб-елементів.</strong> Якщо ви бажаєте знайти суб-елементи за іменем тегу, просто викличте <code>\</code> з ім'ям тегу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span><span class="s">&quot;b&quot;</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">(&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете зробити "глибокий пошук", щоб шукати в суб-елементах, і так далі, використовуючи оператор <code>\\</code> замість <code>\</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span><span class="s">&quot;c&quot;</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\\</span><span class="s">&quot;c&quot;</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">(&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span><span class="s">&quot;a&quot;</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\\</span><span class="s">&quot;a&quot;</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span>
<span class="nc">NodeSeq</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Scala використовує <code>\</code> та <code>\\</code> замість <code>/</code> та <code>//</code> в XPath. Причина в тому, що <code>//</code> починає коментар в Scala! Таким чином мав використовуватись якійсь інший символ, і інші косі роблять добре.</td>
</tr></table>
</div>
<div class="paragraph"><p><strong>Екстракція атрибутів.</strong> Ви можете екстрагувати атрибути тегу, використовуючі ті самі методи <code>\</code> та <code>\\</code>. Просто покладіть знак <code>at</code>
(<code>@</code>) перед ім'ям атрибуту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">joe</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">employee</span>
          <span class="n">name</span><span class="o">=</span><span class="s">&quot;Joe&quot;</span>
          <span class="n">rank</span><span class="o">=</span><span class="s">&quot;code monkey&quot;</span>
          <span class="n">serial</span><span class="o">=</span><span class="s">&quot;123&quot;</span><span class="o">/&gt;</span>
<span class="n">joe</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">employee</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Joe&quot;</span> <span class="n">rank</span><span class="o">=</span><span class="s">&quot;code monkey&quot;</span>
 <span class="n">serial</span><span class="o">=</span><span class="s">&quot;123&quot;</span><span class="o">/&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">joe</span> <span class="o">\</span><span class="s">&quot;@name&quot;</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">Joe</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">joe</span> <span class="o">\</span><span class="s">&quot;@serial&quot;</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="mi">123</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_6_">28.6 Десеаріалізація</h2>
<div class="sectionbody">
<div class="paragraph"><p>Використовуючи попередні методи для розбиття XML на частини, тепер ви можете написати пару до серіалізатора, парсер з XML знову назад до ваших внутрішніх структур даних. Наприклад, ви можете знови розбити примірник <code>CCTherm</code>, через використання наступного коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">CCTherm</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">description</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span>
    <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;yearMade&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">dateObtained</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;dateObtained&quot;</span><span class="o">).</span><span class="n">text</span>
    <span class="k">val</span> <span class="n">bookPrice</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;bookPrice&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">purchasePrice</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;purchasePrice&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">condition</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;condition&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код шукає по вхідному вузлу XML на ім'я <code>node</code>, щоб знайти кожну з шести частин даних, потрібних щоб зібрати <code>CCTherm</code>. Дані, що є текстом, отримуються через <code>.text</code> та залишаються як є. Ось цей метод в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="n">therm</span><span class="o">.</span><span class="n">toXML</span>
<span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span> <span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_7___">28.7 Загрузка та збереження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Є одна остання частина, потрібна для серіалізатора даних: перетворення між XML anта потоками даних. Ця остання частина є найпростішою, оскільки є бібліотечні процедури, що будуть робити все це за вас. Ви просто маєте викликати правильну процедуру на правильних даних.</p></div>
<div class="paragraph"><p>Щоб конвертувати XML в рядок все що вам треба, це <code>toString</code>. Присутність робочого <code>toString</code> це те, чому ви можете експериментувати з XML в оболонці Scala. Однак краще використавувати бібліотетчні процедури, та конвертувати все підряд до байтів. Таки чином, результуючий XML може включати директиву, що вказує, яке кодування символів було використане. Якщо ви закодуєте рядок до байтів самі, тоді відповідальність за відстеження кодування символів лягає на вас.</p></div>
<div class="paragraph"><p>Щоб конвертувати з XML до файлу з байтів, ви можете використовувати команду <code>XML.save</code>. Ви маєте задати ім'я файлу і вузол, що треба зберегти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">.</span><span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="s">&quot;therm1.xml&quot;</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Після виконання команди вище, отриманий файл <code>therm1.xml</code> виглядає наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span>
<span class="nt">&lt;cctherm&gt;</span>
  <span class="nt">&lt;description&gt;</span>hot dog #5<span class="nt">&lt;/description&gt;</span>
  <span class="nt">&lt;yearMade&gt;</span>1952<span class="nt">&lt;/yearMade&gt;</span>
  <span class="nt">&lt;dateObtained&gt;</span>March 14, 2006<span class="nt">&lt;/dateObtained&gt;</span>
  <span class="nt">&lt;bookPrice&gt;</span>2199<span class="nt">&lt;/bookPrice&gt;</span>
  <span class="nt">&lt;purchasePrice&gt;</span>500<span class="nt">&lt;/purchasePrice&gt;</span>
  <span class="nt">&lt;condition&gt;</span>9<span class="nt">&lt;/condition&gt;</span>
<span class="nt">&lt;/cctherm&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Завантаження простіше ніж збереження, оскільки файл містить все, що повинно знати завантажувачу. Просто викличте <code>XML.loadFile</code> з ім'ям файлу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">loadnode</span> <span class="k">=</span> <span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">loadFile</span><span class="o">(</span><span class="s">&quot;therm1.xml&quot;</span><span class="o">)</span>
<span class="n">loadnode</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">loadnode</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span> <span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p>Those are the basic methods you need. There are many variations on these loading and saving methods, including methods for reading and writing to various kinds of readers, writers, input and output streams.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_8____xml">28.8 Порівняння шаблонів на XML</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поки що ми бачили, як розділяти XML використовуючи <code>text</code> та методи, подібні до XPath <code>\</code> та <code>\\</code>. Вони гарні, коли ви знаєте точно, який тип структури XML ви розбиваєте на частки. Однак іноді існує декілька можливих структур, які може мати XML. Можливо багато різновидів записів з даними, наприклад, оскільки ви розширили вашу колекцію термометрів, щоб включити годинники та тарілки для сендвічів. Можливо ви просто бажаєте пропустити всі проміжки між тегами. З будь якої причини ви можете використовувати порівняння шаблонів для перемикання між можливостями.</p></div>
<div class="paragraph"><p>Шаблон XML виглядає просто як XML літерал. Головна різниця в тому, що якщо ви вставляєте виключення <code>{}</code>, тоді код в <code>{}</code> не є виразом, але шаблоном. Шаблон, вставлений в <code>{}</code> може використовувати повну мову шаблонів Scala, включаючи прив'язку нових змінних, виконання перевірки типів, та ігнорування контенту з використанням шаблонів <code>_</code> та <code>_*</code>. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span><span class="o">}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s an a: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span><span class="o">}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s a b: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s something else.&quot;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція має перевірку шаблонів з трьома випадками. Перший випадок шукає елемент <code>&lt;a&gt;</code>, чий вміст складається з одного підвузла. Він прикліплює цей вміст до змінної на ім'я <code>contents</code>, та потім обчислює код зправа від асоційованої стрілки вправо (<code>=&gt;</code>). Другий випадок робить те саме для <code>&lt;b&gt;</code> замість <code>&lt;a&gt;</code>, та третій випадок співпадає з будь-чим, що не співпало з іншими випадками. Ось ця функція в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">an</span> <span class="n">a</span><span class="k">:</span> <span class="kt">apple</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">banana</span><span class="o">&lt;/</span><span class="n">b</span><span class="o">&gt;)</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">a</span> <span class="n">b</span><span class="k">:</span> <span class="kt">banana</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">cherry</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;)</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>Скоріше всього, ця функція не саме те, що вам треба, тому що вона шукає точно такий вміст, що складається з одного субвузла в <code>&lt;a&gt;</code> або <code>&lt;b&gt;</code>. Таким чином вона буде хибити в випадках як наступний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">red</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">/&gt;)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте функцію, що співпадає з випадками, як цей, ви можете порівняти з послідовністю вузлів замість одного. Шаблон для "любої послідовності" XML вузлів записується <code>_*</code>. Візуально ця послідовність виглядає як підстановочний шаблон (<code>_</code>), за яким слідує regex-стильна зірочка Kleene (<code>*</code>). Ось оновлена функція, що порівнює послідовності субелементів, замість одного субелемента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s an a: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s a b: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s something else.&quot;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що результат <code>_*</code> прикріплений до вмісту змінної через використання шаблону <code>@</code>, описаного в Розділі 15.2. Тут нова версія в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">red</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">an</span> <span class="n">a</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">(</span><span class="kt">a</span> <span class="o">,</span> <span class="kt">&lt;em&gt;red&lt;/em&gt;</span><span class="o">,</span> <span class="n">apple</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">/&gt;)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">an</span> <span class="n">a</span><span class="k">:</span> <span class="kt">WrappedArray</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Як фінальна підказка, майте на увазі, що шаблони XML роблять дуже гарно з виразами <code>for</code>, як шлях ітерувати по деяких частинах дерева XML, при цьому ігноруючі інші частини. Наприклад, уявімо, що ви бажаєте пропустити деякі проміжки між записами в наступній XML структурі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">catalog</span> <span class="k">=</span>
  <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="nc">Sprite</span> <span class="nc">Boy</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1964</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">April</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">2003</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">1695</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">595</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Візуально це виглядає як два елементи в елементі <code>&lt;catalog&gt;</code>. Однак насправді їх п'ять. Існує проміжок перед, після та між двома елементами! Якщо ви не приймете до уваги ці проміжки, ви можете некоретно обробити записи термометрів, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">catalog</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;{</span><span class="n">therms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">therm</span> <span class="k">&lt;-</span> <span class="n">therms</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;processing: &quot;</span> <span class="o">+</span>
              <span class="o">(</span><span class="n">therm</span> <span class="o">~</span><span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">processing</span><span class="k">:</span>
<span class="kt">processing:</span> <span class="kt">hot</span> <span class="kt">dog</span> <span class="k">#</span><span class="err">5</span>
<span class="kt">processing:</span>
<span class="n">processing</span><span class="k">:</span> <span class="kt">Sprite</span> <span class="kt">Boy</span>
<span class="n">processing</span><span class="k">:</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте рядки, де іде спроба обробити всі проміжки так, якби це були б дійсними записами термометрів. Що б ви дійсно бажали зробити, це ігнорувати ці проміжки, та обробляти тільки ті субвузли, що є всередині елементу <code>&lt;cctherm&gt;</code>. Ви можете описати цю підмножину, використовуючи шаблон <code>&lt;cctherm&gt;{_*}&lt;/cctherm&gt;</code>, та ви можете обмежити вираз <code>for</code> до ітерації по елементах, що співпадають з шаблоном:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">catalog</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;{</span><span class="n">therms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">therm</span> <span class="k">@</span> <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;{</span><span class="k">_</span><span class="o">*}&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span> <span class="k">&lt;-</span> <span class="n">therms</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;processing: &quot;</span> <span class="o">+</span>
              <span class="o">(</span><span class="n">therm</span> <span class="o">/</span><span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">processing</span><span class="k">:</span> <span class="kt">hot</span> <span class="kt">dog</span> <span class="k">#</span><span class="err">5</span>
<span class="kt">processing:</span> <span class="kt">Sprite</span> <span class="kt">Boy</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_9_">28.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава тільки подерла поверхню того, що можна робити за допомогою XML. Існує багато інших розширень, бібліотек та інструментів, про які ви можете знати, деякі з яких прилаштовані для Scala, деякі зроблені для Java, але корисні в Scala, та деякі мово-нейтральні. Що ми можемо винести з цієї глави, це як використовувати напів-структуровані дані для обміну, та як отримувати доступ до напів-структурованих даних через підтримку XML в Scala.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__29_2">Глава 29</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_______2">Модулярне програмування з використанням об'єктів</h1>
<div class="paragraph"><p>В Главі 1 ми стверджували, що один зі способів, в який Scala є маштабованою мовою, це те, що ви можете використовувати ті самі прийоми для конструювання малих, так само як і великих програм. Досі в цій книзі ми в основному фокусувались на програмуванні в малому: розробленні та реалізації маліших програмних частин, з яких ви можете конструювати більші програми.
<span class="footnote"><br />[Ця термінологія була введена в творі DeRemer, et. al., "Programming - in - the - large versus programming - in - the - small." [DeR75]]<br /></span> Інша сторона історії є програмування в великому: організація та збирання менших частин в більші програми, застосування або системи. Ми торкались цього предмета, коли ми обговорювали пакунки та модифікатори доступу в Главі 13. Коротко кажучи, пакунки та модифікатори доступу дозволяють вам організувати великі програми, використовуючи пакунки як модулі, де модуль є "меньшою програмною частиною" з гарно визначеним інтерфейсом та прихованою реалізацією.</p></div>
<div class="paragraph"><p>В той час, коли поділення програм на пакунки завжди досить корисне, воно обмежене, оскільки воно не провадить методів для абстракції. Ви не можете переналаштувати пакунок в два способи в тій самій програмі, і ви не можете наслідувати між пакунками. Пакунок завжди включає один конкретний список компонент, і цей список фіксований, доки ви не зміните код.</p></div>
<div class="paragraph"><p>В цій главі ми обсудимо, як ви можете задіяти об'єктно орієнтовні можливості Scala, щоб зробити програму більш модулярною. Спочатку ми покажемо, як простий об'єкт синглтон може бути використаний як модуль. Потім ми покажемо, як ви можете використовувати трейти та класи для абстракцій в модулях. Ці абстракції можуть бути переконфігуровані в декілька модулів, навіть декілька разів в тій самій програмі. Нарешті, ми покажемо прагматичну техніку для використання трейтів для розподілу модуля по декільком файлам.</p></div>
<div class="sect1">
<h2 id="_29_1_">29.1 Проблема</h2>
<div class="sectionbody">
<div class="paragraph"><p>По мірі того, як програма зростає в розмірі, стає все більше важливим організувати її в модулярний спосіб. По перше, можливість окремо компілювати різні модулі, що складають систему, допомагає різним командам робити незалежно. На додаток, корисно мати змогу відмикати одну реалізацію модуля, та підмикати іншу, оскільки це дозволяє використовувати різні конфігурації системи в різних контекстах, таких, як юніт тестування на десктопі розробника, інтеграційні тести, тестова експлуатація та розгортання.</p></div>
<div class="paragraph"><p>Наприклад, ви можете мати застосування, що використовує базу даних та сервіс повідомлень. По мірі як ви пишете код, ви можете бажати виконувати юніт тести на вашому десктопі, що використовують фіктивні мок версії обох, бази даних та сервіса повідомлень, що симулює ці сервіси достатньо для тестування, без потреби розмовляти по мережі до загального ресурса. Протягом інтеграційного тестування ви можете побажати використовувати мок сервіс повідомлень, але живу базу даних. Під час тестової експлуатації, та напевне при розгортанні, ваша організація скоріше всього буде використовувати живі версії обох, бази даних та сервіс повідомлень.</p></div>
<div class="paragraph"><p>Люба техніка, що націлена на спрощення цього різновиду модульності потребує провадити декілька основних речей. Перше, має бути конструкція модуля, що провадить гарне розділення інтерфейса та реалізації. Друге, потрібен бути шлях заміняти один модуль на інший, що має той самий інтерфейс, без зміни або перекомпіляції модулів, що залежать від заміненого. Нарешті, повинен бути спосіб поєднувати модулі разом. Ця задача поєднання може розглядатись як конфігурація системи.</p></div>
<div class="paragraph"><p>Один підхід до вирішення цієї проблеми є ін'єкція залежностей, прийом, що підтримується на Java платформі фреймворками, як Spring та Guice, що популярні в корпоративній Java спільноті.<span class="footnote"><br />[Fowler, "Inversion of control containers and the dependency injection pattern." [Fow04]]<br /></span> Наприклад Spring в основному дозволяє вам презентувати інтерфейс модуля як Java інтерфейс, та реалізації модуля як Java класи. Ви можете задати залежності між модулями та "приєднати" застосування разом через зовнішній файл конфігурації XML. Хоча ви можете використовувати Spring зі Scala, і через це використовувати підхід Spring для досягнення модульності рівня системи ваших Scala програм, зі Scala ви маєте деякі альтернативи, доступні через саму мову. В залишку цієї глави ви покажемо, як використовувати об'єкти як модулі для бажаної модульності "в великому", без використання зовнішнього фреймворку.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_29_2__">29.2 Застосування рецепту</h2>
<div class="sectionbody">
<div class="paragraph"><p>Уявіть, що ви будуєте корпоративне веб застосування, що дозволить користувачам керувати рецептами. Ви бажаєте розбити програму на шари, включаючи прикладний шар та шар застосування. В прикладному шарі ви визначите прикладні об'єкти, що захоплять бізнес концепції та правила, так само як енкапсулюють стан, що буде збережений в зовнішній базі даних. В рівні застосування ви будете провадити API, організоване в термінах сервісів, які застосування пропонує клієнтам (включаючи рівень користувацького інтерфейсу). Рівень застосування буде реалізувати ці серсіси через координацію завдань та делегацію роботи до об'єктів прикладного домена.<span class="footnote"><br />[Іменування ціх шарів слідує таким в Evans, Domain-Driven Design. [Eva03]]<br /></span></p></div>
<div class="paragraph"><p>Ви бажаєте бути в змозі під'єднати реальну або мок версію на кожному з ціх рівнів, так що ви можете більш просто писати юніт тести для вашого застосування. Щоб досягти цієї цілі ви можете розглядати об'єкти, що ви бажаєте зробити мок, як модулі. В Scala немає потреби для об'єктів бути "малими" речами, немає потреби використовувати деякий інший різновид конструктора для "великих" речей, як модулі. Один зі шляхів, в який Scala є маштабованою мовою, є те, що ті самі конструкції використовуються для структур, однаково, малих та великих.</p></div>
<div class="paragraph"><p>Наприклад, оскільки одне з "речей", що ви бажаєте зробити мок на прикладному рівні, є об'єкт, що представляє реляційну базу даних, ви зробите його одним з модулей. На рівні застосування ви будете трактувати об'єкт "переглядач бази даних" як модуль. База даних буде містити всі рецепти, що людина буде збирати. Переглядач буде допомагати шукати та переглядати базу даних, наприклад, щоб знайти кожний рецепт, що включає інгредієнти, що у вас є в наявності.</p></div>
<div class="paragraph"><p>Перша річ, що треба зробити, є моделювання їжі та рецептів. Щоб утримувати речі простими, їжа буде мати лише назву, як показано в Лістингу 29.1. Рецепт буде мати ім'я, список інгредієнтів і деякі інструкції, як показано на Лістингу 29.2.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.recipe</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Food</span><span class="o">(</span><span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">name</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.1 - Простий клас сутності <code>Food</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.recipe</span>

<span class="k">class</span> <span class="nc">Recipe</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">ingredients</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Food</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">instructions</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">name</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.2 - Простий клас сутності <code>Recipe</code>.</p></div>
<div class="paragraph"><p>Класи <code>Food</code> та <code>Recipe</code>, показані в Лістингу 29.1 та 29.2, представляють сутності, що будуть представлені в базі даних.<span class="footnote"><br />[Ці класи сутностей спрощені, щоб не захаращувати приклад багатьма деталями реального світу. Але трансформація ціх класів в сутності, що можуть бути збережені за допомогою Hibernate або, наприклад, Java Persistence Architecture, буде потребувати тільки декількох модифікацій, таких як додавання поля <code>private Long id</code> та конструктора без аргументів, покладання анотацій <code>scala.reflect.BeanProperty</code> на поля, вказання відповідних відображень через анотації або окремий XML файл, і так далі.]<br /></span> Лістинг 29.3 показує деякі примірники синглтонів ціх класів, що можуть бути використані для написання тестів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.recipe</span>

<span class="k">object</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Food</span><span class="o">(</span><span class="s">&quot;Apple&quot;</span><span class="o">)</span>
<span class="k">object</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Food</span><span class="o">(</span><span class="s">&quot;Orange&quot;</span><span class="o">)</span>
<span class="k">object</span> <span class="nc">Cream</span> <span class="k">extends</span> <span class="nc">Food</span><span class="o">(</span><span class="s">&quot;Cream&quot;</span><span class="o">)</span>
<span class="k">object</span> <span class="nc">Sugar</span> <span class="k">extends</span> <span class="nc">Food</span><span class="o">(</span><span class="s">&quot;Sugar&quot;</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">FruitSalad</span> <span class="k">extends</span> <span class="nc">Recipe</span><span class="o">(</span>
  <span class="s">&quot;fruit salad&quot;</span><span class="o">,</span>
  <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Cream</span><span class="o">,</span> <span class="nc">Sugar</span><span class="o">),</span>
  <span class="s">&quot;Stir it all together.&quot;</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.3 - Приклади <code>Food</code> та <code>Recipe</code> для використання в тестах.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.recipe</span>

<span class="k">object</span> <span class="nc">SimpleDatabase</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">allFoods</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Cream</span><span class="o">,</span> <span class="nc">Sugar</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">foodNamed</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">allFoods</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">allRecipes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FruitSalad</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">SimpleBrowser</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">recipesUsing</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">allRecipes</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">recipe</span> <span class="k">=&gt;</span>
      <span class="n">recipe</span><span class="o">.</span><span class="n">ingredients</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">food</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.4 - Фіктивна база даних та модулі перегляду.</p></div>
<div class="paragraph"><p>Scala використовує об'єкти для модулів, так що ви можете почати модулізацію вашої програми зі створення двох синглтонів, що служитимуть як фіктивні мок реалізації бази даних та переглядача під час тестування. Оскільки це мок, модуль бази даних підтримується простим списком в пам'яті. Реалізації ціх об'єктів показані в Лістингу 29.4. Ви можете використовувати цю базу даних та переглядач наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">apple</span> <span class="k">=</span> <span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">foodNamed</span><span class="o">(</span><span class="s">&quot;Apple&quot;</span><span class="o">).</span><span class="n">get</span>
<span class="n">apple</span><span class="k">:</span> <span class="kt">Food</span> <span class="o">=</span> <span class="nc">Apple</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">SimpleBrowser</span><span class="o">.</span><span class="n">recipesUsing</span><span class="o">(</span><span class="n">apple</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">fruit</span> <span class="n">salad</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб зробити речі трохи цікавішими, уявімо, що база даних сортує їжу по категоріях. Щоб реалізувати це, ви можете додати клас <code>FoodCategory</code>, та перерахувати всі категорії в базі даних, як показано в Лістингу 29.5. Зауважте в цьому прикладі ключове слово <code>private</code>, що корисне для реалізації класів, і також корисне для реалізації модулів. Елементи, що відмічені як приватні, є частиною реалізації модуля, і, таким чином, відносно прості для зміни без впливу на інші модулі.</p></div>
<div class="paragraph"><p>В цій точці можуть бути додані значно більше можливостей, але ви отримали ідею. Програми можуть бути поділені на об'єкти синглтони, про які ви можете думати як про модулі. Це не велика новина, але це стає дуже корисним, коли ви розглядатимете абстракції (про що ми скоро розповімо).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.recipe</span>

<span class="k">object</span> <span class="nc">SimpleDatabase</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">allFoods</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Cream</span><span class="o">,</span> <span class="nc">Sugar</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">foodNamed</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">allFoods</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">allRecipes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FruitSalad</span><span class="o">)</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">FoodCategory</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">foods</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Food</span><span class="o">])</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">categories</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
    <span class="nc">FoodCategory</span><span class="o">(</span><span class="s">&quot;fruits&quot;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">)),</span>
    <span class="nc">FoodCategory</span><span class="o">(</span><span class="s">&quot;misc&quot;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Cream</span><span class="o">,</span> <span class="nc">Sugar</span><span class="o">)))</span>

  <span class="k">def</span> <span class="n">allCategories</span> <span class="k">=</span> <span class="n">categories</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">SimpleBrowser</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">recipesUsing</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">allRecipes</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">recipe</span> <span class="k">=&gt;</span>
      <span class="n">recipe</span><span class="o">.</span><span class="n">ingredients</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">food</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="k">:</span> <span class="kt">SimpleDatabase.FoodCategory</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.5 - Модулі бази даних та переглядача з доданими категоріями.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_29_3_">29.3 Абстракції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча приклади, показані дотепер, керували розбиттям вашого застосування на окремі модулі бази даних та переглядача, досі дизай не дуже "модулярний". Проблема в тому, що існує "жорсткий зв'язок" від модуля переглядача до модуля бази даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">allRecipes</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">recipe</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки модуль <code>SimpleBrowser</code> споминає модуль <code>SimpleDatabase</code> за ім'ям, ви не будете в змозі під'єднати іншу реалізацію модуля бази даних, без модифікації та перекомпіляції модуля переглядача. На додаток, хоча немає жорсткого посилання від модуля <code>SimpleDatabase</code> до модуля <code>SimpleBrowser</code>,<span class="footnote"><br />[Це гарно, бо кожний з ціх архитектурних шарів повинен залежати тільки від шарів під ним.]<br /></span> немає ясного спосібу дозволити шару користувацького інтерфейсу, наприклад, бути сконфігурованим для використання інших реалізацій модуля переглядача.</p></div>
<div class="paragraph"><p>Однак, коли робити ці модулі більш підключуваними, важливо уникати дублікації кода, оскільки більшість коду з вірогідністю може бути поширений між різними реалізаціями того самого модуля. Наприклад уявімо, що ви бажаєте, щоб та сама кодова база підтримувала декілька баз даних рецептів. Ви скоріше всього захочете використати код переглядача для кожного з примірників, оскільки тільки одна річ, що буде відрізняться в переглядачах, це база даних, на яку вони посилаються. За винятком реалізації бази даних, решта коду може бути використана повторно, символ до символа. Як аранжувати програму, щоб зменшити повторення коду? Як код можна зробити конфігурованим, так що ви б могли конфігурувати його з використанням любої реалізації бази даних?</p></div>
<div class="paragraph"><p>Відповідь знайома: якщо модуль є об'єктом, тоді шаблоном для модуля є клас. Точно так, як клас описує загальні частини всіх своїх примірників, клас може описувати частину модуля, що є загальною для всіх можливих конфігурацій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Browser</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">database</span><span class="k">:</span> <span class="kt">Database</span>

  <span class="k">def</span> <span class="n">recipesUsing</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">database</span><span class="o">.</span><span class="n">allRecipes</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">recipe</span> <span class="k">=&gt;</span>
      <span class="n">recipe</span><span class="o">.</span><span class="n">ingredients</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">food</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="k">:</span> <span class="kt">database.FoodCategory</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг29.6 - Клас <code>Browser</code> з абстрактною <code>val</code> бази даних.</p></div>
<div class="paragraph"><p>Визначення переглядача таким чином перетворюєтья на клас, замість об'єкта, та база даних для користування задається як абстрактний член класу, як показано в Лістингу 29.6. База даних також стає класом, що включає стільки, як це можливо, загального для всіх баз даних,та декларує відсутні частини, які має визначити база даних. В цьому випадку всі модулі бази даних мають визначати методи для <code>allFoods</code>, <code>allRecipes</code> та <code>allCategories</code>, оле оскільки вони можуть використовувати довільне визначення, методи мають бути залишені абстрактними в класі <code>Database</code>. Для контрасту, метод <code>foodNamed`може бути визначений в абстрактному класі `Database</code>, як показано в Лістингу 29.7.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Database</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">allFoods</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">allRecipes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">foodNamed</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">allFoods</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="n">f</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="o">)</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">FoodCategory</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">foods</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Food</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">allCategories</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">FoodCategory</span><span class="o">]}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.7 - Клас <code>Database</code> з абстрактними методами.</p></div>
<div class="paragraph"><p>Об'єкт <code>SimpleDatabase</code> має бути оновлений для наслідування від абстрактного класу <code>Database</code>, як показано в Лістингу 29.8.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">SimpleDatabase</span> <span class="k">extends</span> <span class="nc">Database</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">allFoods</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Cream</span><span class="o">,</span> <span class="nc">Sugar</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">allRecipes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FruitSalad</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">var</span> <span class="n">categories</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
    <span class="nc">FoodCategory</span><span class="o">(</span><span class="s">&quot;fruits&quot;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">)),</span>
    <span class="nc">FoodCategory</span><span class="o">(</span><span class="s">&quot;misc&quot;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Cream</span><span class="o">,</span> <span class="nc">Sugar</span><span class="o">)))</span>

  <span class="k">def</span> <span class="n">allCategories</span> <span class="k">=</span> <span class="n">categories</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.8 - Об'єкт <code>SimpleDatabase</code> як субклас <code>Database</code>.</p></div>
<div class="paragraph"><p>Тепер окремий модуль переглядача, отриманий як примірник класу <code>Browser</code>, вказує, яку базу даних використовувати, як показано в Лістингу 29.9.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">SimpleBrowser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">database</span> <span class="k">=</span> <span class="nc">SimpleDatabase</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.9 - Об'єкт <code>SimpleBrowser</code> як субклас <code>Browser</code>.</p></div>
<div class="paragraph"><p>Ви можете використовувати ці більш підключувані модулі так само, як раніше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">apple</span> <span class="k">=</span> <span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">foodNamed</span><span class="o">(</span><span class="s">&quot;Apple&quot;</span><span class="o">).</span><span class="n">get</span>
<span class="n">apple</span><span class="k">:</span> <span class="kt">Food</span> <span class="o">=</span> <span class="nc">Apple</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">SimpleBrowser</span><span class="o">.</span><span class="n">recipesUsing</span><span class="o">(</span><span class="n">apple</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">fruit</span> <span class="n">salad</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак тепер ви можете створити другу мок базу даних, та використовувати з нею той самий клас переглядача, як показано в Лістингу 29.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">StudentDatabase</span> <span class="k">extends</span> <span class="nc">Database</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">FrozenFood</span> <span class="k">extends</span> <span class="nc">Food</span><span class="o">(</span><span class="s">&quot;FrozenFood&quot;</span><span class="o">)</span>

  <span class="k">object</span> <span class="nc">HeatItUp</span> <span class="k">extends</span> <span class="nc">Recipe</span><span class="o">(</span>
    <span class="s">&quot;heat it up&quot;</span><span class="o">,</span>
    <span class="nc">List</span><span class="o">(</span><span class="nc">FrozenFood</span><span class="o">),</span>
    <span class="s">&quot;Microwave the &#39;food&#39; for 10 minutes.&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">allFoods</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FrozenFood</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">allRecipes</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">HeatItUp</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">allCategories</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
    <span class="nc">FoodCategory</span><span class="o">(</span><span class="s">&quot;edible&quot;</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FrozenFood</span><span class="o">)))</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">StudentBrowser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">database</span> <span class="k">=</span> <span class="nc">StudentDatabase</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.10 - Студентська база даних та переглядач.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_29_4____">29.4 Поділ модулей на трейти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Часто модуль дуже великий, щоб комфортабельно міститись в одному файлі. Коли це трапляється, ви можете використовувати трейти для поділу модуля на окремі файли. Наприклад, уявімо, що ви бажаєте перенести код категоризації з головного файлу <code>Database</code> до свого власного. Ви можете створити трейт для кода, як показано в Лістингу 29.11.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">FoodCategories</span> <span class="o">{</span>
  <span class="k">case</span> <span class="k">class</span> <span class="nc">FoodCategory</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">foods</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Food</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">allCategories</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">FoodCategory</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.11 - Трейт для категорій їжі.</p></div>
<div class="paragraph"><p>Тепер клас <code>Database</code> може міксувати трейт <code>FoodCategories</code> замість визначення <code>FoodCategory</code> та <code>allCategories</code> самому, як показано в Лістингу 29.12:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Database</span> <span class="k">extends</span> <span class="nc">FoodCategories</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">allFoods</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Food</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">allRecipes</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Recipe</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">foodNamed</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">allFoods</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="n">f</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">name</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.12 - Клас <code>Database</code>, що міксує трейт <code>FoodCategories</code>.</p></div>
<div class="paragraph"><p>Ви можете спробувати, та поділити <code>SimpleDatabase</code> на два трейти, один для їжі, та один для рецептів. Це дозволить вам визначити <code>SimpleDatabase</code>, як показано в Лістингу 29.13:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">SimpleDatabase</span> <span class="k">extends</span> <span class="nc">Database</span>
  <span class="k">with</span> <span class="nc">SimpleFoods</span> <span class="k">with</span> <span class="nc">SimpleRecipes</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.13 - Об'єкт <code>SimpleDatabase</code>, повністю складений з міксінів.</p></div>
<div class="paragraph"><p>Трейт <code>SimpleFoods</code> може виглядати як показано в Лістингу 29.14:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">SimpleFoods</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">Pear</span> <span class="k">extends</span> <span class="nc">Food</span><span class="o">(</span><span class="s">&quot;Pear&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">allFoods</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Pear</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">allCategories</span> <span class="k">=</span> <span class="nc">Nil</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.14 - Трейт <code>SimpleFoods</code>.</p></div>
<div class="paragraph"><p>Доки все добре, але нажаль постає проблема, якщо ви спробуєте визначити трейт <code>SimpleRecipes</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">SimpleRecipes</span> <span class="o">{</span> <span class="c1">// Не компілюється</span>
  <span class="k">object</span> <span class="nc">FruitSalad</span> <span class="k">extends</span> <span class="nc">Recipe</span><span class="o">(</span>
    <span class="s">&quot;fruit salad&quot;</span><span class="o">,</span>
    <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Pear</span><span class="o">),</span> <span class="c1">// Uh oh</span>
    <span class="s">&quot;Mix it all together.&quot;</span>
  <span class="o">)</span>

  <span class="k">def</span> <span class="n">allRecipes</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FruitSalad</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема в тому, що <code>Pear</code> розміщений в іншому трейті, відносно того, який його використовує, так що він за полем зору. Компілятор не має уяви, що <code>SimpleRecipes</code> ще колись буде зміксований з <code>SimpleFoods</code>.</p></div>
<div class="paragraph"><p>Однак є спосіб, як ви можете сказати це компілятору. Scala провадить тип <code>self</code> саме для цієї ситуації. Технічно тип <code>self</code> є очікуваний тип для <code>this</code>, кожного разу коли <code>this</code> споминається в класі. Прагматично тип <code>self</code> вказує вимоги на кожному конкретному класі, до якого міксується цей трейт. Якщо ви маєте трейт, який використовується тільки тоді, коли міксується з іншим трейтом або трейтами, тоді ви маєте вказати, що ці інші трейти повинно мати на увазі. В цьому випадку досить задати тип <code>self</code> для <code>SimpleFoods</code>, як показано в Лістингу 29.15:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">SimpleRecipes</span> <span class="o">{</span>
  <span class="k">this:</span> <span class="kt">SimpleFoods</span> <span class="o">=&gt;</span>

  <span class="k">object</span> <span class="nc">FruitSalad</span> <span class="k">extends</span> <span class="nc">Recipe</span><span class="o">(</span>
    <span class="s">&quot;fruit salad&quot;</span><span class="o">,</span>
    <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Pear</span><span class="o">),</span> <span class="c1">// Now Pear is in scope</span>
    <span class="s">&quot;Mix it all together.&quot;</span>
  <span class="o">)</span>
  <span class="k">def</span> <span class="n">allRecipes</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FruitSalad</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.15 - Трейт <code>SimpleRecipes</code> з типом <code>self</code>.</p></div>
<div class="paragraph"><p>Маючи цей новий тип <code>self</code>, <code>Pear</code> тепер доступний. Неявно посилання до <code>Pear</code> іде як <code>this.Pear</code>. Це безпечно, бо любий суцільний клас, що міксує <code>SimpleRecipes</code>, також має бути субтипом <code>SimpleFoods</code>, що означає, що <code>Pear</code> буде членом. Абстрактні субкласи та трейти не мають слідувати цьому обмеженню, але оскільки вони не можуть утворити примірники за допомогою <code>new</code>, немає ризику, що посилання <code>this.Pear</code> схибить.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_29_5____">29.5 Зв'язування часу виконання</h2>
<div class="sectionbody">
<div class="paragraph"><p>Модулі Scala можуть бути зв'язані разом під час виконання, та ви можете обрати, які модулі будуть зв'язуваться з якими, в залежності від обчислень часу виконання. Наприклад, Лістинг 29.16 показує малу програму, що обирає базу даних під час виконання, і потім роздруковує всі яблучні рецепти в ній:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">GotApples</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">db</span><span class="k">:</span> <span class="kt">Database</span> <span class="o">=</span>
      <span class="k">if</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;student&quot;</span><span class="o">)</span>
        <span class="nc">StudentDatabase</span>
      <span class="k">else</span>
        <span class="nc">SimpleDatabase</span>

  <span class="k">object</span> <span class="nc">browser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">database</span> <span class="k">=</span> <span class="n">db</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">apple</span> <span class="k">=</span> <span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">foodNamed</span><span class="o">(</span><span class="s">&quot;Apple&quot;</span><span class="o">).</span><span class="n">get</span>

  <span class="k">for</span><span class="o">(</span><span class="n">recipe</span> <span class="k">&lt;-</span> <span class="n">browser</span><span class="o">.</span><span class="n">recipesUsing</span><span class="o">(</span><span class="n">apple</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">recipe</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.16 - Застосування, що динамічно обирає реалізацію модуля.</p></div>
<div class="paragraph"><p>Тепер, якщо ви використовуєте базу даних <code>simple</code>, ви знайдете рецепт для фруктового салату. Якщо ви використовуєте базу даних <code>student</code>, ви взагалі не знайдете рецептів з використанням яблук:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">GotApples</span> <span class="n">simple</span>
<span class="n">fruit</span> <span class="n">salad</span>
<span class="n">$</span> <span class="n">scala</span> <span class="nc">GotApples</span> <span class="n">student</span>
<span class="n">$</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="____scala__2">Конфігураця за допомогою Scala кода</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете здивуватись, чи ви не зповзли до проблеми жорстких посилань оригінальних прикладів в цій главі, оскільки об'єкт <code>GotApples</code>, показаний в Лістингу 29.16, містить жорсткі посилання на обох, <code>StudentDatabase</code> та <code>SimpleDatabase</code>. Тут різниця в тому, що жорсткі посилання локалізовані в одному файлі, що може бути замінений.</p></div>
<div class="paragraph"><p>Кожне модулярне застосування потребує деякий спосіб вказати дійсну реалізацію модуля, що треба використовувати в певній ситуації. Ця дія "конфігурації" застосування буде по визначенню включати іменування конкретинх реалізацій модуля. Наприклад, в застосуванні Spring ви конфігуруєте через назву реалізацій в зовнішньому файлі XML. В Scala ви можете сконфігурувати через сам код Scala. Перевага використання джерела Scala над XML для конфігурації в тому, що процес виконання вашого файла конфігурації через компілятор Scala викриє любі помилки набору перед його дійсним застосуванням.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_29_6___">29.6 Відстеження примірників модуля</h2>
<div class="sectionbody">
<div class="paragraph"><p>Крім використання того самого кода, різні модулі переглядача та бази даних, створені в попередньому розділі, насправді розділяють модулі. Це означає, що кожний модуль має свій власний вміст, включаючи любі вкладені класи. <code>FoodCategory</code> в <code>SimpleDatabase</code>, наприклад, інший клас від <code>FoodCategory</code> в <code>StudentDatabase</code>!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">category</span> <span class="k">=</span> <span class="nc">StudentDatabase</span><span class="o">.</span><span class="n">allCategories</span><span class="o">.</span><span class="n">head</span>
<span class="n">category</span><span class="k">:</span> <span class="kt">StudentDatabase.FoodCategory</span> <span class="o">=</span>
<span class="nc">FoodCategory</span><span class="o">(</span><span class="n">edible</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">FrozenFood</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">SimpleBrowser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">StudentDatabase.FoodCategory</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">SimpleBrowser.database.FoodCategory</span>
          <span class="nc">SimpleBrowser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
                                        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо замість цього ви бажаєте, щоб всі <code>FoodCategorys</code> були тими самими, ви можете досягти цього через перемііщення визначення <code>FoodCategory</code> за межі класу або трейта. Вибір за вами, але так як воно написане, кожна <code>Database</code> отримує свій власний, унікальний клас <code>FoodCategory</code>.</p></div>
<div class="paragraph"><p>Оскільки два класи <code>FoodCategory</code>, показані в цьому прикладі, насправді різні, компілятов був правий, коли скаржився. Однак іноді ви можете натрапити на випадок, коли два типа такі ж самі, але компілятор не може верифікувати їх. Ви будете бачити, що компілятор скаржиться, що два типи не однакові, однак ви, як програміст, знаеєте що це так.</p></div>
<div class="paragraph"><p>В таких випадках ви можете часто полагодити проблему з використанням типів синглтонів. Наприклад, в програмі <code>GotApples</code> перевірка типів не знає, що <code>db</code> та <code>browser.database</code> такі ж самі. Це спричинить помилку типу, якщо ви спробуєте передати категорії між двома об'єктами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">GotApples</span> <span class="o">{</span>
  <span class="c1">// таке саме визначення...</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">category</span> <span class="k">&lt;-</span> <span class="n">db</span><span class="o">.</span><span class="n">allCategories</span><span class="o">)</span>
    <span class="n">browser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
<span class="c1">// ...</span>
<span class="o">}</span>
<span class="nc">GotApples2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">14</span><span class="kt">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">db.FoodCategory</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">browser.database.FoodCategory</span>
      <span class="n">browser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
                              <span class="o">^</span>
<span class="n">one</span> <span class="n">error</span> <span class="n">found</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб уникнути цієї помилки вам треба поінформувати перевірку типів, що вони є тим самим об'єктом. Ви можете зробити це, змінивши визначення <code>browser.database</code>, як показано в Лістингу 29.17:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">browser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">database</span><span class="k">:</span> <span class="kt">db.</span><span class="k">type</span> <span class="o">=</span> <span class="n">db</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 29.17 - Використання типу синглтону.</p></div>
<div class="paragraph"><p>Це визначення таке саме, як раніше, за винятком що <code>database</code> має дивно виглядаючий тип <code>db.type</code>. <code>.type</code> в кінці означає, що це тип синглтон. Тип синглтон екстремально специфічний, та має лише один об'єкт; в цьому випадку будь-який об'єкт, на який посилаєтся <code>db</code>. Звичайно такі типи дуже специфічні, щоб бути корисними, ось чому компілятор неохоче вставляє їх автоматично. Однак в цьому випадку тип синглтон дозволяє компілятору знати, що <code>db</code> та <code>browser.database</code> той самий об'єкт — досить інформації, щоб прибрати помилку типу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_29_7_">29.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава показала, як використовувати об'єкти Scala як модулі. На додаток до простих статичних модулів, цей підхід надає вам різні шляхі для створення абстрактних, переналаштовуваних модулів. Існує навіть більше прийомів абстрагування, ніж показано, оскільки будь-що, що робить для класа, також робить для класа, задіяного для реалізації модуля. Як завжди, скільки з цієї потужності ви задієте має бути справою смаку.</p></div>
<div class="paragraph"><p>Модулі є частиною програмування в великому, і, таким чином, з ними важко експериментувати. Вам треба велика програма, доки різниця дійсно стане помітною. Тим не менше, після читання цієї глави ви знаєте, про які можливості Scala слід згадати, коли ви бажаєте програмувати в модульному стилі. Думайте про ці прийоми, коли ви пишете ваші власні великі програми, та розпізнавайте ці шаблони прогрумавання, коли ви бачите їх в коді інших людей.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__30_2">Глава 30</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____35">Еквівалентність об'єктів</h1>
<div class="paragraph"><p>Порівняння двох об'єктів на еквівалентність є наріжним в програмуванні. Воно більш заплутане, ніж здається на перший погляд. Ця глава дає погляд на еквівалентність в деталях, та дає деякі рекомендації для розгляду, коли ви розробляєте ваші власні тести еквівалентності.</p></div>
<div class="sect1">
<h2 id="_30_1___scala">30.1 Еквівалентність в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Розділі 11.2, визначення еквівалентності є різне в Scala та Java. Java має два порівняння на еквівалентність: оператор <code>==</code>, що є природною рівністю для типів значення та ідентичності об'єктів для типів посилань, та метод <code>equals</code>, що є  (визначена користувачем) канонічна еквівалентність для типів посилань. Ця домовленість є проблематичною, оскільки більш природний символ <code>==</code> не завжди відповідає до природної нотації еквівалентності. При програмуванні на Java загальна пастка для початківців є порівняння об'єктів за допомогою <code>==</code>, коли вони мають порівнюватись за допомогою <code>equals</code>. Наприклад, порівняння двох рядків <code>x</code> та <code>y</code> з використанням <code>x == y</code> може дати <code>false</code> в Java, навіть якщо <code>x</code> та <code>y</code> мають ті самі символи в тому ж порядку.</p></div>
<div class="paragraph"><p>Scala також має метод еквівалентності, що означає ідентичність об'єктів, але він використовується не часто. Цей різновид еквівалентності, що записується <code>x eq y</code>, є <code>true</code>, якщо <code>x</code> та <code>y</code> посилаються на той самий об'єкт. Еквівалентність <code>==</code> зарезервована в Scala для "природної" еквівалентності кожного типу. Для типів значень <code>==</code> є порівняння значень, так само, як в Java. Для типів посилань <code>==</code> є те саме, що <code>equals</code> в Java. Ви можете перевизначити поведінку <code>==</code> для нових типів через перевизначення метода <code>equals</code>, що завжди наслідується від класу <code>Any</code>. Наслідуване <code>equals</code>, що набуває сили якщо не перекрите, є ідентичність об'єкта, як це відбувається в Java. Так що <code>equals</code> (та разом і <code>==</code>) по замовчанню те саме, що і <code>eq</code>, але ви можете змінити його поведінку через перекриття метода <code>equals</code> в класі, що ви визначаєте. Неможливо перекрити <code>==</code> напряму, бо це визначене як фінальний метод в класі <code>Any</code>. Тобто Scala трактує <code>==</code> якби воно було визначене наступним чином в класі <code>Any</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">def</span> <span class="o">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="n">eq</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span><span class="kc">null</span> <span class="n">eq</span> <span class="n">that</span><span class="o">}</span> <span class="k">else</span> <span class="o">{</span><span class="k">this</span> <span class="n">equals</span> <span class="n">that</span><span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_30_2___">30.2 Написання метода еквівалентності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як має бути визначений метод <code>equals</code>? З'ясовується, що написання коректного метода еквівалентності є несподівано складним в об'єктно орієнтованих мовах. Фактично, після вивчення великого обсягу Java коду, автори документу 2007 прийшли до висновку, що майже всі реалізації метода <code>equals</code> невдалі.<span class="footnote"><br />[Vaziri, et. al., "Declarative Object Identity Using Relation Types" [Vaz07]]<br /></span> Це проблематично, бо еквівалентність є базисом багатьої інших речей. Для початку, хибний метод еквівалентності для типу <code>C</code> може означати, що ви не можете надійно покласти об'єкт типу <code>C</code> до колекції.</p></div>
<div class="paragraph"><p>Наприклад, ви можете мати два елементи, <code>elem1</code> та <code>elem2</code>, типу <code>C</code>, що еквівалентні (тобто, <code>elem1 equals elem2</code> дає <code>true</code>). Тим не менше, з загально зустріваною хибною реалізацією метода <code>equals</code> ви можете все ще бачити поведінку, подібну до такої:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">hashSet</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">HashSet</span>
<span class="n">hashSet</span> <span class="o">+=</span> <span class="n">elem1</span>
<span class="n">hashSet</span> <span class="n">contains</span> <span class="n">elem2</span> <span class="c1">// повертає false!</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось чотири загальні пастки,<span class="footnote"><br />[Всі крім третьої описані і контексті Java в книзі Effective Java Second Edition, by Joshua Bloch. [Blo08]]<br /></span> що можуть спричинити неузгоджену поведінку при перекритті <code>equals</code>:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Визначення <code>equals</code> з помилковою сигнатурою.
</p>
</li>
<li>
<p>
Зміна <code>equals</code> без одночасної зміни <code>hashCode</code>.
</p>
</li>
<li>
<p>
Визначення <code>equals</code> в термінах змінних полів.
</p>
</li>
<li>
<p>
Схиблене визнечення <code>equals</code> як відношення еквівалентності.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Ці чотири пастки дискутуються в залишку цього розділу.</p></div>
<div class="sect2">
<h3 id="__1__code_equals_code___">Пастка #1: Визначення <code>equals</code> з помилковою сигнатурою</h3>
<div class="paragraph"><p>Розглянемо додавання метода еквівалентності до наступного класу простих точок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Майже очевидний, але невірний шлях буде визначити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Повністю невірне визначення `equals`</span>
<span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Що не так з цім методом? На перший погляд здається, що все робить OK:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p1</span><span class="o">,</span> <span class="n">p2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p1</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">37</span><span class="n">d7d90f</span>
<span class="n">p2</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">3</span><span class="n">beb846d</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">q</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="nd">@e0cf182</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="n">equals</span> <span class="n">p2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="n">equals</span> <span class="n">q</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак проблеми починаються, як тільки ви починаєте покладати точки до колекції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="n">p1</span><span class="o">)</span>
<span class="n">coll</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Point</span><span class="k">@</span><span class="mi">37</span><span class="n">d7d90f</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p2</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Як пояснити, що <code>coll</code> не містить <code>p2</code>, навіть якщо <code>p1</code> був доданий до неї, та <code>p1</code> та <code>p2</code> еквівалентні об'єкти? Причина явно полягає в наступній ітерації, де точний тип однієї з порівнюваних точок замаскований. Визначте <code>p2a</code> як псевдоним <code>p2</code>, але з типом <code>Any</code> замість <code>Point</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p2a</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">p2</span>
<span class="n">p2a</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">3</span><span class="n">beb846d</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли ви повторите перше порівняння, але з псевдонимом <code>p2a</code> замість <code>p2</code>, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="n">equals</span> <span class="n">p2a</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Що не так? Версія <code>equals</code>, надана до цього, не перекриває стандартний метод <code>equals</code>, оскільки її тип інший. Ось тип метода <code>equals</code>, як він визначений в кореневому класі <code>Any</code>:<span class="footnote"><br />[Якщо ви багато пишете на Java, ви можете очікувати, що аргумент цього метода буде типу <code>Object</code>, замість типу <code>Any</code>. Не турбуйтесь про це; це той самий метод <code>equals</code>. Компілятор просто робить що воно виглядає як тип <code>Any</code>.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки метод <code>equals</code> в <code>Point</code> приймає <code>Point</code> замість <code>Any</code> як аргумент, він не перекриває <code>equals</code> в <code>Any</code>. Замість цього він просто є перевантаженою альтернативою. Тепер, перевантаження в Scala та в Java розрішене статичним типом аргумента, не типом часу виконання. Так що доки статичний тип аргумента є <code>Point</code>, буде викликатись метод <code>equals</code> в <code>Point</code>. Однак як тільки статичний аргумент стає типу <code>Any</code>, замість цього починає викликатись метод <code>equals</code> в Any. Цей метод не був перекритий, так що він досі реалізований через порівняння ідентичності об'єктів.</p></div>
<div class="paragraph"><p>Ось чому порівняння  <code>p1 equals p2a</code> дає <code>false</code>, навіть якщо точки <code>p1</code> та <code>p2a</code> мають ті самі значення <code>x</code> та <code>y</code>. Ось чому метод <code>contains</code> в <code>HashSet</code> повертає <code>false</code>. Оскільки цей метод оперує на дженерік множинах, він викликає дженерік метод <code>equals</code> в <code>Object</code>, замість перевантаженого варіанта в <code>Point</code>. Ось кращий метод <code>equals</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Краще визначення, але все ще не ідеальне</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>equals</code> має коректний тип. Він приймає значення типу <code>Any</code> як параметр, та дає результат <code>Boolean</code>. Реалізація цього метода використовує порівняння шаблонів. Спочатку він перевіряє, чи об'єкт також є типу <code>Point</code>. Якщо це так, він порівнює координати двох точок, та повертає результат. Інакше результат <code>false</code>.</p></div>
<div class="paragraph"><p>Пов'язана пастка є визначити <code>==</code> з невірноє сигнатурою. Нормально, якщо ви намагаєтесь перевизначити <code>==</code> з коректною сигнатурою, що приймає аргумент типу <code>Any</code>, компілятор буде давати вам помилку, оскільки ви намагаєтесь переписати фінальний метод типу <code>Any</code>.</p></div>
<div class="paragraph"><p>Новачки в Scala іноді роблять дві помилки разом: вони намагаються перекрити <code>==</code>, і вони дають невірну сигнатуру. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">==(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="c1">// Не робіть цього!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку визначений користувачем метод <code>==</code> трактується як перевантажений варіант так само названого метода з класа <code>Any</code>, і програма компілюється. Однак поведінка програми буде такою ж сумнівною, якби ви визначили <code>equals</code> з невірною сигнатурою.</p></div>
<div class="paragraph"><p>Пастка #2: Зміна <code>equals</code> без одночасної зміни <code>hashCode</code></p></div>
<div class="listingblock">
<div class="content">
<pre><code>Ми будемо продовжувати використовувати приклад з пастки #1. Якщо ви продовжите порівняння `p1` та `p2a` з останнім визначенням `Point`, ви отримаєте `true`, як очікувалось. Однак якщо ми повторимо перевірку `HashSet.contains`, ви будете вірогідно все ще отримувати `false`:
[source,scala]
----
scala> val p1, p2 = new Point(1, 2)
p1: Point = Point@122c1533
p2: Point = Point@c23d097

scala> collection.mutable.HashSet(p1) contains p2
res4: Boolean = false
----
Але цей результат не на 100% певний. Ви можете також отримати `true` в простому експерименті. Якщо ви зробите це, ви можете спробувати деякі інші точки з координатами 1 та 2. З часом ви отримаєте таку, що не містилась в множині. Що тут не так, це те, що `Point` перевизначає `equals`, при цьому також не перевизначаючи `hashCode`.

Зауважте, що колекція в прикладі є `HashSet`. Це означає, що елементи колекції покладаються в "хеш ьакети", що визначаються їх хеш кодом. Перевірка `contains` спершу визначає хеш бакет, де дивитись, та потім порівнює надані елементи з усіма елементами в бакеті. Тепер, остання версія класу `Point` перевизначила `equals`, але вона в той же час не перевизначила `hashCode`. Так що `hashCode` все ще той, що був в версії для класа `AnyRef`: деяка трансформація адреси розміщеного об'єкта.

Хеш коди `p1` та `p2` майже напевне різні, навіть якщо поля обох точок однакові. Різні хеш коди означають, з великою вірогідністю, різні хеш бакети в множині. Перевірка `contains` буде шукати співпадаючий елемент в бакеті, що відповідає до хеш коду `p2`. В більшості випадків точка `p1` буде в іншому бакеті, так що вона ніколи не буде знайдена. `p1` та `p2` можуть також з вірогідністю попасти в той самий хеш бакет. В цьому випадку перевірка поверне `true`. Проблема в тому, що остання реалізація `Point` порушує контракт на `hashCode`, як визначено для класа `Any`:footnote:[Текст контракту `Any` `hashCode` надихнено документацією Javadoc класу `java.lang.Object`.]

  Якщо два класи еквівалентні відповідно до метода `equals`, тоді виклик `hashCode` на кожному з двох об'єктів має продукувати той самий цілий результат.

Фактично, це добре відомо в Java, що `hashCode` та `equals` повинні завжди бути перевизначені разом. Більше того, `hashCode` можу залежати тільки від полів, на які покладається `equals`. Для класа `Point` наступне може бути підходящим визначенням `hashCode`:
[source,scala]
----
class Point(val x: Int, val y: Int) {
  override def hashCode = (x, y).##
  override def equals(other: Any) = other match {
    case that: Point => this.x == that.x && this.y == that.y
    case _ => false
  }
}
----
Це тільки одне з багатьох можливих реалізацій `hashCode`. Нагадаємо, що метод `##`є скороченням для обчислення хеш кодів, що роблять з примітивними значеннями, типами посилань та `null`. Коли викликається на колекції або таплі, він обчислює змішаний хеш, що чутливий до хеш кодів всіх елементів в колекції. Ми запровадимо більше настанов по написанню  `hashCode` пізніше в цій главі.

Додавання `hashCode` лагодить проблему еквівалентності, коли визначаються класи як `Point`; однак є інші проблемні місця, до яких треба придивитись.

Пастка #3: Визначення `equals` в термінах змінних полів</code></pre>
</div></div>
<div class="paragraph"><p>Розглянемо наступну невелику варіацію класу <code>Point</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Проблематично</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдина відмінність в тому, що поля <code>x</code> та <code>y</code> тепер <code>var</code> замість <code>val</code>. Методи <code>equals</code> та <code>hashCode</code> тепер визначені в термінах ціх змінних полів, так що їх результати змінюються, коли змінюються поля. Це може мати дивний ефект, коли ваші точки потраплять до колекції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
<span class="n">coll</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ви зміните поле в <code>p</code>, чи буде колекція все ще містити точку? Ми спробуємо це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Це виглядає дивно. Куди зникла <code>p</code>? Більше дивини буде, якщо ви перевірите, чи ітератор по множині містить <code>p</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що тут множина, що не містить <code>p</code>, але <code>p</code> є серед елементів множини! Що трапилось, це те, що після зміни поля <code>x</code>, точка <code>p</code> залишилась з невірним хеш бакетом в множині <code>coll</code>. Тобто, її оригінальний хеш бакет більше не відповідає до нового значення її хеш коду. Кажучи розмовною мовою, точка <code>p</code> "випала з поля зору" в множині <code>coll</code>, навіть якщо вона все ще належить до її елементів.</p></div>
<div class="paragraph"><p>Урок, що треба винести з цього прикладу, в тому, що коли <code>equals</code> та <code>hashCode</code> залежать від змінного стану, це призводить до проблем для потенційних користувачів. Якщо ви покладете такі об'єкти до колекцій, ви маєте бути уважними, щоб ніколи не модифікувати цей стан, і це складно. Якщо вам треба порівняння, що приймає до уваги поточний стан об'єкта, вам слідує назвати це якось інакше, не <code>equals</code>.</p></div>
<div class="paragraph"><p>Розглядаючи останнє визначення <code>Point</code>, можливо буде мати вигоду оминути перевизначення <code>hashCode</code>, та назвати метод порівняння <code>equalContents</code> або деяким ішим ім'ям, відмінним від <code>equals</code>. Після цього <code>Point</code> буде наслідувати реалізацію по замовчанню <code>equals</code> та <code>hashCode</code>; <code>p</code> буде шукатись в <code>coll</code> навіть після модифікацій до його поля <code>x</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__4___code_equals_code___">Пастка #4: Схиблене визнечення <code>equals</code> як відношення еквівалентності</h3>
<div class="paragraph"><p>Контракт метода <code>equals</code> в <code>scala.Any</code> вказує, що <code>equals</code> має реалізувати відношення еквівалентності на не-<code>null</code> об'єктах:<span class="footnote"><br />[Як з <code>hashCode</code>, контракт <code>Any</code> для метода <code>equals</code> базується на контракті метода equals в <code>java.lang.Object</code>.]<br /></span></p></div>
<div class="ulist"><ul>
<li>
<p>
Він рефлексивний: Для любого не-<code>null</code> значення <code>x</code> вираз <code>x.equals(x)</code> повинен повертати <code>true</code>.
</p>
</li>
<li>
<p>
Він симетричний: для любих не-<code>null</code> значень <code>x</code> та <code>y</code>, <code>x.equals(y)</code> повинно повертати <code>true</code> тоді і тільки тоді, якщо <code>y.equals(x)</code> повертає <code>true</code>.
</p>
</li>
<li>
<p>
Він транзитивний: для любих не-<code>null</code> значень <code>x</code>, <code>y</code>, та <code>z</code>, якщо <code>x.equals(y)</code> повертає <code>true</code>, та <code>y.equals(z)</code> повертає <code>true</code>, тоді <code>x.equals(z)</code> повинно повертати <code>true</code>.
</p>
</li>
<li>
<p>
Він узгоджений: для любих не-<code>null</code> значень <code>x</code> та <code>y</code>, декілька викликів <code>x.equals(y)</code> повинно узгоджено повертати <code>true</code>, або узгоджено повертати <code>false</code>, вважаючи, що інформація, яка використовувалась для порівнянь не змінювалась.
</p>
</li>
<li>
<p>
Для кожного не-<code>null</code> значення <code>x</code>, <code>x.equals(null)</code> повинно повертати <code>false</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Визначення <code>equals</code>, розроблене для класа <code>Point</code> дотепер, задовільняє контракту для <code>equals</code>. Однак речі стають складнішими, коли прийняти до уваги субкласи. Скажімо, існує субклас <code>ColoredPoint</code> від <code>Point</code>, що додає поле <code>color</code> типу <code>Color</code>. Нехай <code>Color</code> визначений як перелік, як представлено в Розділі 20.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Yellow</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span><span class="o">,</span> <span class="nc">Indigo</span><span class="o">,</span> <span class="nc">Violet</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>ColoredPoint</code> перекриває <code>equals</code>, щоб прийняти до уваги нове поле <code>color</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Пробелма: equals не симетричне</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те, що більшість програмістів скоріше всього напишуть. Зауважте, що в цьому випадку клас <code>ColoredPoint</code> не повинен перекрити <code>hashCode</code>. Оскільки нове визначення <code>equals</code> на <code>ColoredPoint</code> суворіше, ніж перекрите визначення в <code>Point</code> (що означає, що воно прирівняє меньшу кількість об'єктів), контракт для <code>hashCode</code> залишається валідним. Якщо дві кольорові точки еквівалентні, вони повинні мати ті самі координати, так що їх хеш коди також гарантовано рівні.</p></div>
<div class="paragraph"><p>Беручи сам клас <code>ColoredPoint</code>, його визначення <code>equals</code> виглядає OK. Однак контракт для <code>equals</code> ламається, як тільки точки і кольорові точки змішуються. Розглянемо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>
<span class="n">cp</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span> <span class="n">equals</span> <span class="n">cp</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cp</span> <span class="n">equals</span> <span class="n">p</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння <code>p equals cp</code> викликає метод <code>p.equals</code>, що визначений в класі <code>Point</code>. Цей метод приймає до уваги тільки координати двох точок. Як слідоцтво, порівняння дає <code>true</code>. З іншого боку, порівняння <code>cp equals p</code> викликає метод <code>cp.equals</code>, що визначений в класі <code>ColoredPoint</code>. Цей метод повертає <code>false</code>, оскільки <code>p</code> не є <code>ColoredPoint</code>. Так що відношення, визначене <code>equals</code>, не є симетричним.</p></div>
<div class="paragraph"><p>Втрата симетрії може мати неочікувані наслідки для колекцій. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">](</span><span class="n">p</span><span class="o">)</span> <span class="n">contains</span> <span class="n">cp</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">](</span><span class="n">cp</span><span class="o">)</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть якщо <code>p</code> та <code>cp</code> рівні, одна перевірка <code>contains</code> буде успішна, та інша невдала:</p></div>
<div class="paragraph"><p>Як ви можете змінити визначення <code>equals</code>, так щоб він став симетричний? В основному є два шляхи. Ви можете або зробити відношення більш загальним, або більш суворим. Створення його більш загальним означає, що пара з двох об'єктів, <code>x</code> та <code>y</code>, має вважатись рівними, якщо любе з порівнянь <code>x</code> до <code>y</code>, або <code>y</code> до <code>x</code>, дасть <code>true</code>. Ось код що робить це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Проблема: equals не транзитивне</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="n">that</span> <span class="n">equals</span> <span class="k">this</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нове визначення <code>ColoredPoint</code> має один додатковий <code>case</code>, ніж старе: якщо об'єкт <code>other</code> є <code>Point</code>, але не <code>ColoredPoint</code>, метод відсилає до метода <code>equals</code> в <code>Point</code>. Це має бажаний ефект, що робить <code>equals</code> симетричним. Тепер обоє, <code>cp equals p</code> та <code>p equals cp</code> дають <code>true</code>. Однак контракт для <code>equals</code> все ще поломаний. Проблема в тому, що нове відношення більше не транзитивне!</p></div>
<div class="paragraph"><p>Ось послідовність тверджень, що демонструють це. Визначте точку і дві кольорові точки різного кольору, всі з однаковими координатами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">redp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>
<span class="n">redp</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bluep</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>
<span class="n">bluep</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>
</pre></div></div></div>
<div class="paragraph"><p>Взяті окремо, <code>redp</code> рівне до <code>p</code>, та <code>p</code> рівне до <code>bluep</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">redp</span> <span class="o">==</span> <span class="n">p</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">==</span> <span class="n">bluep</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак порівняння <code>redp</code> та <code>bluep</code> дає <code>false</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">redp</span> <span class="o">==</span> <span class="n">bluep</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, твердження транзитивності контракту <code>equals</code> порушене.</p></div>
<div class="paragraph"><p>Створення відношення <code>equals</code> більш загальним, здається, призводить до глухого кута. Ми спробуємо зробити його замість цього суворішим. Один спосіб зробити <code>equals</code> суворішим - це завжди вприймати об'єкти різних типів як різні. Цього можна досягти, можифікуючи методи <code>equals</code> в класах <code>Point</code> та <code>ColoredPoint</code>. В класі <code>Point</code> ви можете додати додаткове порівняння, що перевіряє, чи клас часу виконання іншої <code>Point</code> точно такий самий, як і в класа цієї <code>Point</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Технічно валідний, але незадовільний метод equals</span>
<span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span>
          <span class="k">this</span><span class="o">.</span><span class="n">getClass</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">getClass</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви можете відкатити реалізацію класа <code>ColoredPoint</code> назад до версії, що перед цім порушувала вимогу симетричності:<span class="footnote"><br />[Маючи нову реалізацію <code>equals</code> в <code>Point</code>, ця версія <code>ColoredPoint</code> більше не порушує вимогу симетрії.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут примірник класу <code>Point</code> визнається рівним до деякого іншого примірника того самого класу, тільки якщо об'єкти мають ті самі координати, та вони мають той клас часу виконання, що означає, що <code>getClass</code> на кожному об'єкті поверне те саме значення. Нові визначення задовільняють симетрії та транзитивності, оскільки тепер кожне порівняння між об'єктами різних класів дає <code>false</code>. Так що кольорова точка ніколи не буде рівна точці. Ця домовленість виглядає логічною, але ви можете сказати, що нове обмеження дуже суворе.</p></div>
<div class="paragraph"><p>Розглянеом наступний обхідний шлях визначити точку з координатами <code>(1, 2)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pAnon</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">}</span>
<span class="n">pAnon</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>
</pre></div></div></div>
<div class="paragraph"><p>Чи <code>pAnon</code> рівне до <code>p</code>? Відповідь є ні, оскільки об'єкти <code>java.lang.Class</code>, асоційовані з <code>p</code> та <code>pAnon</code> є різні. Для <code>p</code> це <code>Point</code>, тоді як для <code>pAnon</code> це анонімний субклас <code>Point</code>. Але ясно, що <code>pAnon</code> є тільки нова точка з координатами <code>(1, 2)</code>. Не виглядає логічним розглядати її як іншу, ніж <code>p</code>.</p></div>
<div class="paragraph"><p>Виглядає що ми буксуємо. Чи існує розумний спосіб перевизначити еквівалентність на декількох рівнях ієрархії класів, при цьому дотримуючись контракту? Фактично, існує такий метод, але він потребує одночасного перевизначення ще одного метода разом з <code>equals</code> та <code>hashCode</code>. Ідея в тому, що як тільки клас перевизначає <code>equals</code> (та <code>hashCode</code>), він також має явно встановити, що об'єкти цього класу ніколи не рівні до об'єктів деякого суперкласу, що реалізує інший метод еквівалентності. Це досягається додаванням методу <code>canEqual</code> до кожного класу, що перевизначає <code>equals</code>. Ось сигнатура метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод повинен повертати <code>true</code>, якщо інший об'єкт є примірником класу, в якому <code>canEqual</code> є (пере)визначеним, інакше <code>false</code>. Він викликається з <code>equals</code>, щоб переконатись, що об'єкти можна порівняти в обох напрямках. Лістинг 30.1 показує нову (та фінальну) реалізацію класу <code>Point</code>, разом з ціма рядками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
          <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.1 - Метод суперкласа <code>equals</code>, що викликає <code>canEqual</code>.</p></div>
<div class="paragraph"><p>Метод <code>equals</code> в цій версії класу <code>Point</code> містить додаткову вимогу, щоб об'єкт <code>other</code> міг бути еквівалентним до <code>this</code>, як визначено в методі <code>canEqual</code>. Реалізація <code>canEqual</code> в <code>Point</code> стверджує, що всі примірники <code>Point</code> можуть бути рівними.</p></div>
<div class="paragraph"><p>Лістинг 30.2 показує відповідну реалізацію <code>ColoredPoint</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">hashCode</span><span class="o">,</span> <span class="n">color</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
          <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">ColoredPoint</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.2 - Метод субкласу <code>equals</code>, що викликає <code>canEqual</code>.</p></div>
<div class="paragraph"><p>Може бути показане, що нове визначення <code>Point</code> та <code>ColoredPoint</code> дотрумуються контракту для <code>equals</code>. Еквівалентність є симетричною та транзитивною. Порівняння <code>Point</code> з <code>ColoredPoint</code> завжди дає <code>false</code>. Зрозуміло, що для кожної точки <code>p</code> та кольорової точки <code>cp</code>, <code>p equals cp</code> буде повертати <code>false</code>, оскільки <code>cp canEqual p</code> буде повертати <code>false</code>. Зворотнє порівняння <code>cp equals p</code> буде також повертати <code>false</code>, оскільки <code>p</code> не є <code>ColoredPoint</code>, так що перше співпадіння шаблонів в тілі <code>equals</code> в <code>ColoredPoint</code> схибить.</p></div>
<div class="paragraph"><p>З іншого боку, примірники різних субкласів <code>Point</code> можуть бути рівні, доти, докі ніякий з субкласів не перевизначає метод рівності. Наприклад, з повим визначенням класу, порівняння <code>p</code> та <code>pAnon</code> даватиме <code>true</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Indigo</span><span class="o">)</span>
<span class="n">cp</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="nd">@e6230d8f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pAnon</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">}</span>
<span class="n">pAnon</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
<span class="n">coll</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">cp</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">pAnon</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці приклади демонструють, що якщо реалізація <code>equals</code> суперкласа визначає та викликає <code>canEqual</code>, тоді програмісти, що реалізують субкласи можуть вирішувати, зможе чи ні примірник їхнього субкласу бути рівний примірникам суперкласу. Наприклад, оскільки <code>ColoredPoint</code> перекриває <code>canEqual</code>, кольорова точка ніколи не може бути рівною до простої старої точки. Але оскільки анонімний субклас, на який посилається <code>pAnon</code> не перекриває <code>canEqual</code>, його примірник може бути рівним до примірника <code>Point</code>.</p></div>
<div class="paragraph"><p>Одне з потенційних зауважень підходу <code>canEqual</code> в тому, що він порушує Принцип Підстановки Ліскова (LSP). Наприклад, техніка реалізації <code>equals</code> через порівняння типів часу виконання, що призводить до неможливості визначити субклас, чиї примірники можуть бути рівні примірникам суперкласу, була описана як порушення LSP.<span class="footnote"><br />[Bloch, Effective Java Second Edition, p. 39 [Blo08]]<br /></span> LSP стверджує, що повинна бути можливість використовувати (підставляти) примірники субкласів, там, де потрібні примірники суперкласа.</p></div>
<div class="paragraph"><p>Однак в попередньому прикладі <code>coll contains cp</code> повертає <code>false</code>, навіть якщо в <code>cp</code> значення <code>x</code> та <code>y</code> співпадають з такими для точки в колекції. Таким чином, це може виглядати як порушення LSP, оскільки ви не можете використовувати <code>ColoredPoint</code> там, де очікувався <code>Point</code>. Ми віримо, що це помилкова інтерпретація, оскільки LSP не вимагає, щоб субклас поводився ідентично до своїх суперкласів, а тільки щоб він поводився так, щоб задовільняти контракту свого суперкласу.</p></div>
<div class="paragraph"><p>Проблема з написанням метода <code>equals</code>, що порівнює класи часу виконання не в тому, що він порушує LSP, але в тому, що він не дає вам спосіб створити субклас, чиї примірники можуть бути еквівалентні примірникам суперкласу. Наприклад, як ми використовували техніку рантайм класів в попередньому прикладі, <code>coll contains pAnon</code> мало б повертати <code>false</code>, але не те, чого ми б хотіли. Для контрасту, ми реально хочемо, щоб <code>coll contains cp повертав `false</code>, оскільки через перекриття <code>equals</code> в <code>ColoredPoint</code> ми в основному кажемо, що точка кольору індіго з координатами <code>(1, 2)</code> не те саме, що некольорова точка <code>(1, 2)</code>. Таким чином, в попередньому прикладі ми були в змозі передати два різні примірники субкласа <code>Point</code> до метода <code>contains</code>, та ми отримали назад дві різні відповіді, обоє коректні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_30_3_____">30.3 Визначення параметрів для параметризованих типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В методі <code>equals</code> в попередніх прикладах все починалось з шаблона порівняння, що перевіряв, чи тип операнда відповідав типу класу, що містить метод <code>equals</code>. Коли класи параметризовані, ця схема потребує невеликої адаптації.</p></div>
<div class="paragraph"><p>Як приклад розглянемо бінарні дерева. Ієрархія класів, показана на Лістингу 30.3 визначає абстрактний клса <code>Tree</code> для бінарного дерева, з двома альтернативними реалізаціями: об'єкт <code>EmptyTree</code>, та клас <code>Branch</code>, що представляє непорожні дерева. Непорожне дерево складається з деякого елемента <code>elem</code>, та лівого та правого дочірніх дерев. Тип цього елементу береться з параметру типу <code>T</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">EmptyTree</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;EmptyTree.elem&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;EmptyTree.left&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;EmptyTree.right&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">+T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span><span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.3 - Ієрархія для бінарних дерев.</p></div>
<div class="paragraph"><p>Тепер ми додамо методи <code>equals</code> та <code>hashCode</code> до ціх класів. Для самого класу <code>Tree</code> нічого робити, оскільки ми вважаємо, що ці методи реалізовані окремо для кожної реалізації абстрактного класу. Для об'єкту <code>EmptyTree</code> все ще нічого робити, оскільки реалізація по замовчанню для <code>equals</code> та <code>hashCode</code>, які <code>EmptyTree</code> наслідує від <code>AnyRef</code>, роблять чудово. Кінець кінцем, <code>EmptyTree</code> единий буде рівний сам собі, так що еквівалентність буде посилатись на ідентичність, що наслідується від <code>AnyRef</code>.</p></div>
<div class="paragraph"><p>Але додавання <code>equals</code> та <code>hashCode</code> до <code>Branch</code> потребує деякої роботи. Значення <code>Branch</code> має бути рівне тільки іншим значенням <code>Branch</code>, та тільки в тому випадку, якщо два значення мають рівні поля <code>elem</code>, <code>left</code> та <code>right</code>. Буде природним застосувати схему для <code>equals</code>, що була розроблена в попередніх розділах цієї глави. Це дасть вам:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак компіляція цього прикладу дає позначку, що виникло попередження "unchecked". Нова компіляція з опцією -unchecked викриває наступну проблему:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">fsc</span> <span class="o">-</span><span class="n">unchecked</span> <span class="nc">Tree</span><span class="o">.</span><span class="n">scala</span>
<span class="nc">Tree</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">14</span><span class="kt">:</span> <span class="kt">warning:</span> <span class="kt">non</span> <span class="kt">variable</span> <span class="k">type</span><span class="kt">-argument</span> <span class="kt">T</span> <span class="kt">in</span> <span class="k">type</span>
<span class="kt">pattern</span> <span class="kt">is</span> <span class="kt">unchecked</span> <span class="kt">since</span> <span class="kt">it</span> <span class="kt">is</span> <span class="kt">eliminated</span> <span class="kt">by</span> <span class="kt">erasure</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Як каже попередження, існує порівняння шаблонів щодо типу <code>Branch[T]</code>, але вивтема може тільки перевірити, що інше посилання є (деяким різновидом) <code>Branch</code>; вона не може перевірити, що тип елементу дерева є <code>T</code>. В Главі 19 ви зустрічали причину цього: типи елементів параметризованих типів видаляються на фазі затирання компілятора; вони недоступні для інспекції під час виконання.</p></div>
<div class="paragraph"><p>Так що ми можемо зробити? Нащастя, з'ясовується, що вам не обов'язково перевіряти, що два <code>Branch</code> мають той самий тип елементів при їх порівнянні. Досить можливо, що два <code>Branch</code> з різними типами елементів рівні, доки їх поля такі самі. Простий приклад цього може бути <code>Branch</code>, що складається з одного елементу <code>Nil</code> та двох порожніх субдерев. Прийнятно вважати любі два таких  <code>Branch</code> як рівні, не важливо, які статичні типи вони мають:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">b1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span>
           <span class="nc">EmptyTree</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">)</span>
<span class="n">b1</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Branch</span><span class="k">@</span><span class="mi">9</span><span class="n">d5fa4f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">b2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span>
           <span class="nc">EmptyTree</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">)</span>
<span class="n">b2</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Branch</span><span class="k">@</span><span class="mi">56</span><span class="n">cdfc29</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Позитивний результат порівняння вище було отримане від реалізації <code>equals</code> на <code>Branch</code>, показаної до цього. Це демонструє, що тип елементу <code>Branch</code> не був перевірений — якщо б він був перевірений, результатом мало б бути <code>false</code>.</p></div>
<div class="paragraph"><p>Ми можемо не погоджуватись, який з двох результатів буде більш натуральний. Кінець цінцем, це залежить від ментальної моделі того, як класи представлені. В моделі, де параметри типу присутні лише під час компіляції, природно вважати, що два <code>Branch</code>, <code>b1</code> та <code>b2</code>, рівні. В альтернатівній моделі, де параметри типу формують частину значення об'єкту, так само природно розглядати їх як різні. Оскільки Scala приймає модель затирання типів, параметри типів неприсутні під час виконання, так що <code>b1</code> та <code>b2</code> природно розглядаються як рівні.</p></div>
<div class="paragraph"><p>Існує тільки маленька зміна, потрібна для формулювання методу <code>equals</code>, що не продукує неперевіреного попередження. Замість елементу типу <code>T</code> використовуйте літеру малого реєсту, таку як <code>t</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
                        <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
                        <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
</pre></div></div></div>
<div class="paragraph"><p>Згадайте з Розділу 15.2, що параметр типу в шаблоні, що починається з малої літери, представляє невідомий тип. Тепер шаблон співпаде:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>буде успішним для значень <code>Branch</code> любого типу. Параметр типу <code>t</code> представляє невідомий елемент типу для <code>Branch</code>. Він також може бути замінений на підкреслення, що те саме, що і попередній варіант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна річ, що залишилось визначити для класу <code>Branch</code> є два інші методи, <code>hashCode</code> та <code>canEqual</code>, що ідуть з <code>equals</code>. Ось можлива реалізація <code>hashCode</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Це тільки одна з багатьох можливих реалізацій. Як показано раніше, принцип є взяти <code>hashCode</code> з усіх полів, та скомбінувати їх. Ось реалізація методу <code>canEqual</code> в класі <code>Branch</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація метода <code>canEqual</code> використовує типізоване порівняння шаблонів. Також можливо свормулювати його за допомогою <code>isInstanceOf</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви почуваєтесь як nit-picking — і ми заохочуємо, щоб ви так і почувались! — ви можете здивуватись, що значить поява підкреслення в типі вище. Кінець кінцем, <code>Branch[_]</code> є технічно параметром типу для метода, не типом шаблону. То як це можливо залишити деякі його частини невизначеними?</p></div>
<div class="paragraph"><p>Відповідь на це запитання обговорюється в наступній главі. <code>Branch[_]</code> є скороченням для так званого підстановочного типу, що є, грубо кажучи, типом з деякими невідомими частинами. Так що навіть якщо технічно підкреслення означає дві різні речі в порівнянні шаблонів та параметрі типу в виклику метода, в основному значення те саме: воно дозволяє вам помітити дещо, що є невідомим. Фінальна версія <code>Branch</code> показана в Лістингу 30.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">).#</span><span class="k">#</span>
<span class="o">}</span>

<span class="n">Лістинг</span> <span class="mf">30.4</span> <span class="o">-</span> <span class="n">Параметризований</span> <span class="n">тип</span> <span class="n">з</span> <span class="n">`equals`</span> <span class="n">та</span> <span class="n">`hashCode`</span><span class="o">.</span>

<span class="mf">30.4</span> <span class="n">Рецепти</span> <span class="n">щодо</span> <span class="n">`equals`</span> <span class="n">та</span> <span class="n">`hashCode`</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому розділі ми надамо крок-за-кроком рецепти для створення методів <code>equals</code> та <code>hashCode</code>, що повинні підходити для більшості ситуацій. Як ілюстрація, ми будемо використовувати методи класу <code>Rational</code>, показаного в Лістингу 30.5.</p></div>
<div class="paragraph"><p>Щоб створити цей клас ми видалили методи математичних операцій з версії класу <code>Rational</code>, показаного в Лістингу 6.5. Ми також зробили мінорні покращення до <code>toString</code>, та модифікували ініціалізатори <code>numer</code> та <code>denom</code>, щоб нормалізувати всі дробі, що мають додатний дільник (тобто, трансформувати <code>1/-2</code> до <code>-1/2</code>).</p></div>
<div class="sect2">
<h3 id="___code_equals_code">Рецепт для <code>equals</code></h3>
<div class="paragraph"><p>Ось рецепт для перекриття <code>equals</code>:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Щоб перекрити <code>equals</code> в нефінальному класі, створіть метод <code>canEqual</code>. Якщо наслідуване визначення <code>equals</code> походить від <code>AnyRef</code> (тобто <code>equals</code> не був перевизначений вище в ієрархії класів), визначення <code>canEqual</code> повинне бути нове; інакше воно буде перекривати повереднє визначення метода з таким же ім'ям. Одне виключення до цієї вимоги є для фінальних класів, що перевизначають метод <code>equals</code>, наслідуваний від <code>AnyRef</code>. Для них аномалії субкласів, описані в Розділі 30.2 не можуть виникти; відповідно вони не мають визначати <code>canEqual</code>. Тип об'єкту, переданий до <code>canEqual</code> повинен бути <code>Any</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Метод <code>canEqual</code> повинен давати <code>true</code>, якщо об'єкт аргумента є примірником поточного класу (iтобто класу, в якому визначений <code>canEqual</code>), та <code>false</code> інакше:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
В методі <code>equals</code> переконайтесь, що ви задекларували тип об'єкта, переданого як <code>Any</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Напишіть тіло метода <code>equals</code> як єдиний вираз <code>match</code>. Селектор  <code>match</code> повинен бути об'єктом, переданим до <code>equals</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Вираз <code>match</code> повинен мати два випадки. Перший повинен декларувати шаблон типу для класу, в якому ви визначаєте метод <code>equals</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=&gt;</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
В тілі цього <code>case</code> запишіть вираз, що логчно пов'язує разом окремі вирази, що мають бути <code>true</code> для рівних об'єктів. Якщо метод <code>equals</code>, що ви перекриваєте, не походить від <code>AnyRef</code>, ви будете найбільш вірогідно включати виклик метода <code>equals</code> суперкласа:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви визначаєте <code>equals</code> для класа, що перший визначає <code>canEqual</code>,ви повинні викликати <code>canEqual</code> на аргументі до метода рівності, передавши його як аргумент:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</pre></div></div></div>
<div class="paragraph"><p>Перекриття перевизначень <code>equals</code> також повенне включати виклик <code>canEqual</code>, якщо вони не включають виклик до <code>super.equals</code>. В останньому випадку перевірка <code>canEqual</code> буде вже зроблена викликом суперкласа. Нарешті, для кожного поля, що має відношення до рівності, перевірте, що поле для об'єкту <code>this</code> рівне до відповідного поля переданого об'єкта:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">numer</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">&amp;&amp;</span>
<span class="n">denom</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Для другого випадку використовуйте підстановочний шаблон, що дає <code>false</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви дотримуватиметесь цього рецепту для <code>equals</code>, рівність гарантовано буде відношенням еквівалентності, як вимагається контрактом <code>equals</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="o">(</span><span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-</span><span class="n">n</span> <span class="k">else</span> <span class="n">n</span><span class="o">)</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=&gt;</span>
        <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">numer</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">&amp;&amp;</span>
        <span class="n">denom</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">).#</span><span class="k">#</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">numer</span><span class="o">.</span><span class="n">toString</span> <span class="k">else</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.5 - Клас <code>Rational</code> з <code>equals</code> та <code>hashCode</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_hashcode_code">Рецепт для <code>hashCode</code></h3>
<div class="paragraph"><p>Для <code>hashCode</code> ви звичайно можете досягти задовільних результатів, якщо будете використовувати наступний рецепт, що подібний до рецепту, рекомендуємого для Java класів в Effective Java.<span class="footnote"><br />[Bloch, Effective Java Second Edition. [Blo08]]<br /></span> Включіть в обчислення кожне поле в вашому об'єкту, що використовується для визначення рівності в методі <code>equals</code> ("відповідні" поля). Зробіть тапл, що містить значення з усіх ціх полів. Потім викличте <code>##</code> на отриманому таплі.</p></div>
<div class="paragraph"><p>Наприклад, щоб реалізувати хеш код для об'єкта, що має п'ять відповідних полів з іменами <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо метод <code>equals</code> викликає <code>super.equals(that)</code> як частину своїх обчислень, ви маєет почати ваше обчислення <code>hashCode</code> з виклика` super.hashCode`. Наприклад, якщо метод <code>Rational</code> <code>equals</code> мав викликати <code>super.equals(that)</code>, його <code>hashCode</code> був би такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">hashCode</span><span class="o">,</span> <span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна річ, що треба пам'ятати коли пишете методи <code>hashCode</code> за допомогою цього підходу, це те, ваш хеш код буде гарний тільки настільки, наскільки гарні хеш коди, на яких він побудований, а саме хеш коди, що ви отримали викликаючи <code>hashCode</code> на відповідних полях вашого об'єкта. Іноді вам буде треба дещо крім простого виклику  <code>hashCode</code> на полі, щоб отримати корисний хеш код для цього поля. Наприклад, якщо одне з ваших полів є колекція, ви вірогідно бажаєте хеш код для цього поля, що базується на всіх елементах, що містяться в цій колекції. Якщо поле є <code>Vector</code>, <code>List</code>, <code>Set</code>, <code>Map</code>, або тапл, ви можете просто включити його в список елементів, по яких ви хешуєте, оскільки <code>equals</code> та <code>hashCode</code> перекриті в ціх класах, щоб прийняти до уваги елементи, які вони містять. Але це не так для  <code>Array</code>, що не приймає до уваги елементи при обчисленні хеш коду. таким чином для масивів ви маєте трактувати кожний елемент масиву як окреме поле вашого об'єкту, викликаюч <code>##</code> на кожному елементі явно, або передаючи масив до одного з методів <code>hashCode</code> в синглтон об'єкті <code>java.util.Arrays</code>.</p></div>
<div class="paragraph"><p>Нарешті, якщо ви знайдете, що окреме обчислення хеш коду шкодить продуктивності вашої програми, розгляньте кешування хеш коду. Якщо об'єкт незмінний, ви можете обчислити хеш код, коли об'єкт створюється, та зберігти його в полі. Ви можете зробити це, просто перекривши <code>hashCode</code> за допомогою <code>val</code> замість <code>def</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">val</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей підхід є компроміс між пам'ятю та часом виконання, оскільки кожний примірник незмінного класу буде мати на одне поле більше, що зберігатиме кешоване значення хеш коду.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_30_5_">30.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В ретроспктиві визначення коректної реалізації <code>equals</code> було несподівано тонким. Ви маєте бути уважним щодо сигнатури типу; ви маєте перекрити <code>hashCode</code>; ви повинні уникати залежностей від змінного стану; та ви маєте реалізувати та використовувати метод <code>canEqual</code>, якщо ваш клас не є фінальним.</p></div>
<div class="paragraph"><p>Беручи до уваги, як складно реалізувати коректний метод рівності, ви можете схилитись до визначення ваших класів для об'єктів що порівнюються як кейс класів. Таким чином компілятор Scala буде додавати методи <code>equals</code> та <code>hashCode</code> з правильними властивостями автоматично.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__31_2">Глава 31</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__scala__java">Комбінування Scala та Java</h1>
<div class="paragraph"><p>Scala код часто використовується в тандемі з великими Java програмами та фреймворками. Оскільки Scala високо сумісна з Java, більшість часу ви можете комбінувати мови без великих турбот. Наприклад, стандартні фреймворки, такі як <code>Swing</code>, <code>Servlets</code> та <code>JUnit</code> відомо роблять досить гарно зі Scala. Тим не менше, час від часу ви будете натрапляти на якісь проблеми, комбінуючи Java та Scala.</p></div>
<div class="paragraph"><p>Ця глава описує два аспекти комбінування Java та Scala. Перше, вона описує, як Scala транслюється до Java, що особливо важливо, якщо ви викликаєте Scala код з Java. Друге, вона дискутує використання Java анотацій в Scala, важлива можливість, якщо ви бажаєте використовувати Scala з існуючим Java фреймворком.</p></div>
<div class="sect1">
<h2 id="_31_1__scala__java">31.1 Використання Scala з Java</h2>
<div class="sectionbody">
<div class="paragraph"><p>Більшість часу ви можете думати про Scala на рівні джерельного коду. Однак ви будете мати багатше розуміння того, як робить система, якщо ви будете дещо знати про її трансляцію. Більше того, якщо ви викликаєте Scala код з Java, вам буде треба знати, як Scala код виглядає з точки зору Java.</p></div>
<div class="sect2">
<h3 id="___63">Загальні правила</h3>
<div class="paragraph"><p>Scala реалізована як трансляція до стандартного байткоду Java. Наскільки це можливо, можливості Scala відображуються напряму на еквівалентні Java можливості. Наприклад, Scala класи, методи, рядки та виключення всі компілюються до таких самих в Java байткоді, як і колеги з Java.</p></div>
<div class="paragraph"><p>Щоб зробити це можливим, знадобився подекуди непростий вибір дизайну Scala. Наприклад, це могло б бути гарним, щоб розрішувати перевантажені методи під час виконання, використовуючи типи часу виконання, скоріше ніж під час компіляції. Однак такий дизайн буде стикатись з аналогічним в Java, що зробить значно складнішим змішувати Java та Scala. В цьому випадку Scala залишається з розрішенням перевантаження від Java, і, таким чином, Scala методи та виклики методів можуть напряму відображатись на Java методи та виклики методів.</p></div>
<div class="paragraph"><p>Scala має власний дизайн для інших можливостей. Наприклад, трейти не мають еквівалента в Java. Подібно до цього, хоча обоє, Scala та Java мають дженерік типи, деталі обох систем конфліктують. Для можливостей мови, як ці, код Scala не може напряму відобразитись на Java конструкції, так що вони мають бути закодовані з використанням якоїсь комбінації структур, що має Java.</p></div>
<div class="paragraph"><p>Для ціх можливостей, що відображаються непрямо, кодування не фіксоване. Є постійне зусилля зробити трансляцію такою простою, як це можливо, так що на час, коли ви це читаєте, деякі деталі можуть бути різні, відносно часу написання. Ви можете знайти, яку трансляцію використовує ваш поточний компілятор Scala, продивившись <code>.class</code> файли за допомогою інструментів, як <code>javap</code>.</p></div>
<div class="paragraph"><p>Такі головні правила. Тепер розглянемо деякі особливі випадки.</p></div>
</div>
<div class="sect2">
<h3 id="___64">Типи значень</h3>
<div class="paragraph"><p>Тип значення, як <code>Int</code>, може бути трансльований до Java в два різні способи. Коли можливо, компілятор транслює <code>Scala</code> <code>Int</code> до <code>Java</code> <code>int</code>, щоб отримати кращу продуктивність. Однак іноді це не можливо, оскільки компілято не впевнений, чи він транслює <code>Int</code>, або деякий інший тип даних. Наприклад, зокрема <code>List[Any]</code> може містити тільки <code>Int</code>, але компілятор не має способу бути впевненим.</p></div>
<div class="paragraph"><p>В таких випадках, коли компілятор невпевнений, чи об'єкт є значенням або ні, компілятор використовує об'єкти та покладається на класи огортки. Наприклад, класи огорток, такі як <code>java.lang.Integer</code> дозволяють типам значень бути огорнутими в Java об'єкт, і так оброблятись кодом, що потребує об'єктів.<span class="footnote"><br />[Реалізація типів значень була обговорена в деталях в Розділі 11.2.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="____36">Синглтон об'єкти</h3>
<div class="paragraph"><p>Java не має точного еквіваленту до синглтон об'єктів, але вона має статичні методи. Трансляція Scala синглтон об'єктів використовує комбінацію статичних методів та методів примірника. Для кожного об'єкта синглтона Scala, компілятор буде створювати Java клас для об'єкта з доданим до нього в кінці знака долара. Для об'єкта синглтона на ім'я <code>App</code> компілятор продукує Java клас на ім'я <code>App$</code>. Цей клас має всі методи та поля об'єкта синглтона Scala. Клас Java також має єдине статичне поле та ім'я <code>MODULE$</code>, що зберігає один примірник класу, що створений під час виконання.</p></div>
<div class="paragraph"><p>Як повний приклад, уявімо, що ви компілюєте наступний синглтон об'єкт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala буде генерувати Java клас <code>App$</code> з наступними полями та методами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javap</span> <span class="nc">App</span><span class="n">$</span>
<span class="n">public</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">App$</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span>
<span class="n">implements</span> <span class="n">scala</span><span class="o">.</span><span class="nc">ScalaObject</span><span class="o">{</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="nc">App</span><span class="n">$</span> <span class="nc">MODULE</span><span class="n">$</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">static</span> <span class="o">{};</span>
  <span class="n">public</span> <span class="nc">App</span><span class="n">$</span><span class="o">();</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">[]);</span>
  <span class="n">public</span> <span class="n">int</span> <span class="nc">$tag</span><span class="o">();</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це трансляція для загального використання. Важливий особливий випадок коли ви маєте "самостійний" синглтон об'єкт, що не іде з класом з таким самим ім'ям. Наприклад, ви можете мати об'єкт синглтон на ім'я <code>App</code>, але не мати жодного класу на ім'я <code>App</code>. В цьому випадку компілятор буде створювати Java клас на ім'я <code>App</code>, що має статичний метод перенаправлювач для кожного метода об'єкта синглтоона Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javap</span> <span class="nc">App</span>
<span class="nc">Compiled</span> <span class="n">from</span> <span class="s">&quot;App.scala&quot;</span>
<span class="n">public</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">App</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span><span class="o">{</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">int</span> <span class="nc">$tag</span><span class="o">();</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">[]);</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Для контрасту, якщо ви мали клас на ім'я <code>App</code>, Scala буде ствоорювати відповідний Java клас <code>App</code> для зберігання всіх членів класу <code>App</code>, що ви визначили. В цьому випадку він не буде додавати жодних методів перенаправлення для так-само-названого об'єкта синглтона, та Java код буде мати доступ до синглтона через поле <code>MODULE$</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____37">Трейти як інтерфейси</h2>
<div class="sectionbody">
<div class="paragraph"><p>Компіляція любого трейта створює Java інтерфейс з тим самим ім'ям. Цей інтерфейс корисний як Java тип, та він дозволяє вам викликати методи на об'єктах Scala через змінні цього типу.</p></div>
<div class="paragraph"><p>Реалізація трейта в Java є інша історія. В загальному випадку це не принципово; однак один особливий випадок важливий. Якщо ви робите Scala трейт, що включає тільки абстрактні методи, тоді цей трейт буде трансльований напряму в Java інтерфейс, без іншого коду, про який треба турбуватись. В основному це означає, що ви можете написати Java інтерфейс в Scala синтаксисі, якщо побажаєте.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_31_2_">31.2 Анотації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Система загальних анотацій Scala обговорювалась в Главі 27. Цей розділ обговорює Java-специфічні аспекти анотацій.</p></div>
<div class="sect2">
<h3 id="______15">Додаткові ефекти від стандартних анотацій</h3>
<div class="paragraph"><p>Декілька анотацій призводять до того, що компілятор видає додаткову інформацію, коли націлений на Java платформу. Коли компілятор бачить таку анотацію, він спочатку обробляє її відповідно до загальним правилам Scala, і потім він робить дещо додаткове для Java.</p></div>
<div class="paragraph"><p><strong>Застаріння</strong> Для любого метода або класа, відміченого як <code>@deprecated</code>, компілятор буде додавати власну анотацію Java до видаваємого коду. Завдяки цьому Java компілятори можуть видивати попередження, коли Java код отримує застарілі Scala методи.</p></div>
<div class="paragraph"><p><strong>Мінливі поля</strong> Подібним чином, любе поле, відмічене як <code>@volatile</code> в Scala отримує Java модифікатор <code>volatile</code> в виданому коді. Таким чином, мінливі поля в Scala поводяться точно у відповідності до Java сементики, та доступ до мінливих полів відбувається в послідовності точно відповідно до правил, заданих для мінливих полів в Java моделі пам'яті.</p></div>
</div>
<div class="sect2">
<h3 id="__38">Сериалізація</h3>
<div class="paragraph"><p>Три стандартні анотації сериалізації Scala всі транслюються до Java еквівалентів.</p></div>
<div class="paragraph"><p>Клас <code>@serializable</code> має доданий до нього Java інтерфейс <code>Serializable</code>.</p></div>
<div class="paragraph"><p>Анотація <code>@SerialVersionUID(1234L)</code> конвертується на наступне визначення поля Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Маркер версії серіалізації Java</span>
<span class="k">private</span> <span class="k">final</span> <span class="n">static</span> <span class="n">long</span> <span class="nc">SerialVersionUID</span> <span class="k">=</span> <span class="mi">1234L</span>
</pre></div></div></div>
<div class="paragraph"><p>Люба змінна, відмічена <code>@transient</code> отримує Java модифікатор <code>transient</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___65">Закидання виключень</h3>
<div class="paragraph"><p>Scala не перевіряє, що закинуті виключення перехоплюються. Таким чином Scala не має еквіваленту до Java декларації <code>throws</code> на методах. Всі Scala методи транслюються до Java методів, що не декларують закидання виключень.<span class="footnote"><br />[Причина, з якох все це робить, в тому, що перевіряч байткоду Java взагалі не перевіряє декларацій! Компілятор Java перевіряє, але не перевіряч.]<br /></span></p></div>
<div class="paragraph"><p>Причина, чому ця можливість видалена зі Scala в тому, що досвід Java з цім був не дуже позитивний. Оскільки анотовані методи зі <code>throws</code> спричиняли жорсткий безлад, дуже багато розробників писали код, що ковтає і відкидає виключення, тільки щоб зробити компіляцію коду без додавання ціх всіх тверджень <code>throws</code>. Можливо вони мали намір покращити обробку виключень пізніше, але досвід показує, що всі надто часто придушені строками програмісти ніколи не будуть повертатись та додавати потрібну обробку виключень. Перекручений результат в тому, що ця можливість з кращих намірів часто завершувалась створенням меньш надійного коду. Велика кількість промислового Java коду ковтає та приховує рантайм виключення, і причиною робити це є задоволення компілятора.</p></div>
<div class="paragraph"><p>Однак іноді, коли робиться інтерфейс до Java, вам може знадобитись написати Scala код, який має дружні до Java анотації, що описують, які виключення ваш метод буде закидати. Наприклад, кожний метод в віддаленому інтерфейсі RMI потребує зазначити <code>java.io.RemoteException</code> в твердженні <code>throws</code>. Таким чином, якщо ви бажаєте написати віддалений інтерфейс RMI як Scala трейт з абстрактними методами, вам знадобиться перелічити <code>RemoteException</code> в твердженні <code>throws</code> для ціх методів. Щоб досягти цього, все що вам треба зробити це відмітити ваші методи анотацією <code>@throws</code>. Наприклад, Scala клас, показаний в Лістингу 31.1 має метод, позначений що закидає <code>IOException</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io._</span>
<span class="k">class</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">fname</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">in</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fname</span><span class="o">))</span>
  <span class="nd">@throws</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">IOException</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">read</span><span class="o">()</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">read</span><span class="o">()</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 31.1 - Метод Scala, що декларує Java твердження <code>throws</code>.</p></div>
<div class="paragraph"><p>Ось як це виглядає з боку Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javap</span> <span class="nc">Reader</span>
<span class="nc">Compiled</span> <span class="n">from</span> <span class="s">&quot;Reader.scala&quot;</span>
  <span class="n">public</span> <span class="k">class</span> <span class="nc">Reader</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span> <span class="n">implements</span>
<span class="n">scala</span><span class="o">.</span><span class="nc">ScalaObject</span><span class="o">{</span>
  <span class="n">public</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">);</span>
  <span class="n">public</span> <span class="n">int</span> <span class="n">read</span><span class="o">()</span> <span class="n">throws</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">IOException</span><span class="o">;</span>
<span class="n">public</span> <span class="n">int</span> <span class="nc">$tag</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">$</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що метод <code>read</code> вказує за допомогою твердження <code>Java</code> <code>throws</code>, що він може закидати <code>IOException</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_java_">Java анотації</h3>
<div class="paragraph"><p>Існуючі анотації з Java фреймворків можуть напряму використовуватись в Scala коді. Любий Java фреймворк буде бачити анотації, що ви пишете, так само, якби ви писали це в Java.</p></div>
<div class="paragraph"><p>Широка різноманіть Java пакунків використовує анотації. Як приклад, розглянемо JUnit 4. JUnit це фреймворк для написання та виконання автоматизованих тестів. Остання версія, JUnit 4, використовує анотації для вказання, які частини вашого коду є тестами. Ідея в тому, що ви пишете багато тестів для вашого коду, та потім ви використовуєте ці тести коли змінюєте свій код. Таким чином, якщо ваші зміни додають нову ваду, один з ціх тестів буде хибити, і ви безпосередньо це з'ясуєте.</p></div>
<div class="paragraph"><p>Написання тестів просте. Ви просто пишете метод в класі верхнього рівня, що виконує ваш код, та ви використовуєте анотацію для відмітки вашого метода як тесту. Це виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.junit.Test</span>
<span class="k">import</span> <span class="nn">org.junit.Assert.assertEquals</span>

<span class="k">class</span> <span class="nc">SetTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="k">def</span> <span class="n">testMultiAdd</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">set</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>testMultiAdd</code> є тестом. Цей тест дадає декілька елементів до множини, та переконується, що кожний доданий тільки один раз. Метод <code>assertEquals</code>, що іде як частина JUnit API, перевіряє, що два його аргументи рівні. Якщо вони різні тест схибить. В цьому випадку тест перевіряє, що повторюване додавання тих самих чисел не збільшує розмір множини.</p></div>
<div class="paragraph"><p>Тест відмічений з використанням анотації <code>org.junit.Test</code>. Зауважте, що ця анотація була імпортована, так що на неї посилається як просто <code>@Test</code>, замість більш заплутаного <code>@org.junit.Test</code>.</p></div>
<div class="paragraph"><p>Ось і все тут про це. Тест може бути виконаний з використанням любого виконувача JUnit. Ось як він виконується за допомогою виконувача з командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="o">-</span><span class="n">cp</span> <span class="n">junit</span><span class="o">-</span><span class="mf">4.3</span><span class="o">.</span><span class="mf">1.</span><span class="n">jar</span><span class="k">:</span><span class="kt">.</span> <span class="kt">org.junit.runner.JUnitCore</span> <span class="kt">SetTest</span>
<span class="nc">JUnit</span> <span class="n">version</span> <span class="mf">4.3</span><span class="o">.</span><span class="mi">1</span>
<span class="o">.</span>
<span class="nc">Time</span><span class="k">:</span> <span class="err">0</span><span class="kt">.</span><span class="err">023</span>
<span class="kt">OK</span> <span class="o">(</span><span class="err">1</span> <span class="kt">test</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____20">Написання ваших власних анотацій</h3>
<div class="paragraph"><p>Щоб зробити анотацію, що видима для Java рефлексії, ви маєте використовувати Java нотацію та компілювати за допомогою <code>javac</code>. Для цього випадку написання анотацій в Scala не виглядає корисним, так що стандартний компілятор не підтримує його. Причина в тому, що підтримка Scala без сумніву швидко схибить на всіх можливостях анотацій Java, та більше, Scala буде мати одного дня власну рефлексію, в якому випадку ви будете бажати мати доступ до Scala анотацій через Scala рефлексію.</p></div>
<div class="paragraph"><p>Ось приклад анотації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span> <span class="c1">// Це Java</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Ignore</span> <span class="o">{</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Після компіляції цього за допомогою javac ви можете використовувати анотацію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Tests</span> <span class="o">{</span>
  <span class="nd">@Ignore</span>
  <span class="k">def</span> <span class="n">testData</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">test1</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">testData</span> <span class="o">==</span> <span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">testData</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">test2</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">head</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі <code>test1</code> та <code>test2</code> вважаються тестовими методами, але <code>testData</code> повинен бути проігнорований, навіть незважаючи що його ім'я починається на <code>"test"</code>. Щоб бачити, коли ці анотації присутні, ви можете використовувати Java API рефлексії. Ось код приклада, що показує, як це робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">{</span>
  <span class="n">method</span> <span class="k">&lt;-</span> <span class="nc">Tests</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getMethods</span>
  <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">getAnnotation</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Ignore</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span>
<span class="o">}</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;found a test method: &quot;</span> <span class="o">+</span> <span class="n">method</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут рефлективні методи <code>getClass</code> та <code>getMethods</code> використовуються для інспекції всіх полів класу входящого об'єкту. Це звичайні методи рефлексії. Специфічна до анотацій частина в використанні метода <code>getAnnotation</code>. Багато об'єктів рефлексії мають метод <code>getAnnotation</code> для пошуку анотацій специфічного типу. В цьому випадку код шукає анотацію нашого нового типу <code>Ignore</code>. Оскільки це Java API, успіх вказує або що результат є <code>null</code>, або дійсний об'єкт анотації.</p></div>
<div class="paragraph"><p>Ось цей код в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javac</span> <span class="nc">Ignore</span><span class="o">.</span><span class="n">java</span>
<span class="n">$</span> <span class="n">scalac</span> <span class="nc">Tests</span><span class="o">.</span><span class="n">scala</span>
<span class="n">$</span> <span class="n">scalac</span> <span class="nc">FindTests</span><span class="o">.</span><span class="n">scala</span>
<span class="n">$</span> <span class="n">scala</span> <span class="nc">FindTests</span>
<span class="n">found</span> <span class="n">a</span> <span class="n">test</span> <span class="n">method</span><span class="k">:</span> <span class="kt">public</span> <span class="kt">void</span> <span class="kt">Tests$.test2</span><span class="o">()</span>
<span class="kt">found</span> <span class="kt">a</span> <span class="kt">test</span> <span class="kt">method:</span> <span class="kt">public</span> <span class="kt">void</span> <span class="kt">Tests$.test1</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Побічно зауважте, що методи в класі <code>Tests$</code>, замість класу <code>Tests</code>, якщо дивитись через Java рефлексію. Як описане на початку глави, реалізація сенглтон об'єктів Scala, покладається в Java клас з доданим знаком долару в кінці імені. В цьому випадку реалізація Tests є в Java класі <code>Tests$</code>.</p></div>
<div class="paragraph"><p>Будьте уважні, коли ви використовуєте Java анотації, ви маєте робити з їх обмеженнями. Наприклад, ви можте використовувати тільки константи, не вирази, в аргументах анотацій. Ви можте підтримувати <code>@serial(1234)</code>, але не <code>@serial(x * 2)</code>, оскільки <code>x * 2</code> не є константою.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_31_3__">31.3 Підстановочні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі Java типи мають Scala еквівалент. Це потрібно, так щоб цей Scala код міг отримувати доступ до любих легальних Java класів. Більшість часу трансляція прямолінійна. <code>Pattern</code> в Java є <code>Pattern</code> в Scala, та <code>Iterator&lt;Component&gt;</code> в Java є <code>Iterator[Component]</code> в Scala. Однак для деяких випадків типів Scala, що ви бачили до цього, недостатньо. Що ви будете робити з підстановочними типами Java, як <code>Iterator&lt;?&gt;</code> або <code>Iterator&lt;? extends Component&gt;</code>? Що ми можемо робити щодо сирих типів, як <code>Iterator</code>, де параметр типу пропущений? Для підстановочних типів Java та сирих типів Scala використовує додатковий різновид типу, що також називається підстановочним типом.</p></div>
<div class="paragraph"><p>Підстановочні типи записуються з використання синтаксису замінника, так само як скорочені функціональні літерали, описані в Розділі 8.5. В скороченнях для функціональних літералів ви можете використовувати підкреслення (<code>_</code>) замість виразу; наприклад, <code>(_ + 1)</code> є те саме, що <code>(x =&gt; x + 1)</code>. Підстановочні типи використовують ту саму ідею, тільки для типів замість виразів. Якщо ви пишете <code>Iterator[_]</code>, тоді підкреслення заміняє тип. Такий тип представляє <code>Iterator</code>, де тип елементу невідомий.</p></div>
<div class="paragraph"><p>Ви також можете вставити верню та нижню межі, коли використовуєте цей синтаксис замінника. Просто додайте межу після підкреслення, використовуючи той самий <code>&lt;:</code> синтаксис, що використовується для параметрів типу (Розділ 19.8 та Розділ 19.5). Наприклад, тип <code>Iterator[_ &lt;: Component]</code> є ітератором, де елемент типу невідомий, але який би тип це не був, він має бути субтипом <code>Component</code>.</p></div>
<div class="paragraph"><p>Ось як ви пишете підстановочний тип, але як його використовувати? В простих випадках ви можете ігнорувати підстановку, та викликати методи на базовому типі. Наприклад, уявімо, що ви маєте наступний Java клас:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java клас з підстановками класів</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wild</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">contents</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stuff</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;see&quot;</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">stuff</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви отримаєте доступ до цього в Scala коді, ви побачите, що він має підстановочний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Wild</span><span class="o">).</span><span class="n">contents</span>
<span class="n">contents</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">a</span>, <span class="kt">b</span>, <span class="kt">see</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте з'ясувати, скільки елементів в цій колекції, ви можете просто ігнорувати підстановочну частину, та просто викликати метод <code>size</code> як звичайно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">contents</span><span class="o">.</span><span class="n">size</span><span class="o">()</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>В більш складних випадках підстановочні типи можуть бути більш незграбними. Оскільки підстановочний тип не має імені, немає способу використати його в двох різних місцях. Наприклад, уявімо, що ви бажаєте створити змінну множину Scala, та ініціалізувати її елементами <code>contents</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">iter</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Wild</span><span class="o">).</span><span class="n">contents</span><span class="o">.</span><span class="n">iterator</span>
<span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">???</span><span class="o">]</span> <span class="c1">// який тут тип?</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="n">hasMore</span><span class="o">)</span>
  <span class="n">set</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема виникає в третьому рядку. Немає способу назвати тип елементів в Java колекції, так що ви не можете написати задовільний тип для множини. Щоб обробити цей різновид проблем, ось два трюки, які ви можете розглянути:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Коли передаєте підстановочний тип в метод, дайте параметр до методу для замінника. Тепер ви маєте ім'я для типу, так що можете використовувати його багато разів, як вам треба.
</p>
</li>
<li>
<p>
Замість повертання підстановочного типу з методу, поверніть об'єкт, що має абстрактні члени для кожного з типів замінників. (Дивіться Главу 20 для інформації по абстрактних членах.)
</p>
</li>
</ol></div>
<div class="paragraph"><p>Використовуючи обоє ці трюки разом, попередній код може бути записаний наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">java.util.Collection</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">SetAndType</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span>
  <span class="k">val</span> <span class="n">set</span><span class="k">:</span> <span class="kt">mutable.Set</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">javaSet2ScalaSet</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">jset</span><span class="k">:</span> <span class="kt">Collection</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">SetAndType</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">sset</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="c1">// тепер T може бути названий!</span>
  <span class="k">val</span> <span class="n">iter</span> <span class="k">=</span> <span class="n">jset</span><span class="o">.</span><span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
    <span class="n">sset</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nc">SetAndType</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="n">T</span>
    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">sset</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете бачити, чому Scala код звичайно не використовує підстановочні типи. Щоб зробити щось виключне з ними, ви скоріше перетворюєте їх на використання абстрактних членів. Так що так само гарно ви можете починати з абстрактних членів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_31_4__scala__java_">31.4 Компіляція Scala та Java разом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Звичайно, коли ви компілюєте Scala код, що залежить від Java коду, спочатку ви будуєте Java код до <code>class</code> файлів. Потім ви будуєте Scala код, покладаючи Java class файли на <code>classpath</code>. Однак цей підхід не працює, якщо Java код має посилання назад на Scala код. В такому випадку не має значення, в якому порядку ви компілюєте ваш код, одна сторона або інша буде мати незадовільнені зовнішні посилання. Ці ситуації не є рідкістю; це відбувається частіше всього в Java проекті, де ви заміняєте один джерельний Java файл на джерельний файл Scala.</p></div>
<div class="paragraph"><p>Щоб підтримувати такі побудови, Scala дозволяє компіляцію джерельного коду Java, так само, як Java <code>class</code> файлів. Все що вам треба зробити, це покласти Java файли на командний рядок, так само, як вони б були Scala файлами. Scala компілятор не буде компілювати ці Java файли, але він буде сканувати їх, щоб побачити, що вони містять. Щоб використати цю можливість, ви спочатку компілюєте Scala код з використанням джерельних файлів Java, та потім компілюєте Java код з використанням class файлів Scala.</p></div>
<div class="paragraph"><p>Ось типова послідовність команд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="n">d</span> <span class="n">bin</span> <span class="nc">InventoryAnalysis</span><span class="o">.</span><span class="n">scala</span> <span class="nc">InventoryItem</span><span class="o">.</span><span class="n">java</span> <span class="o">\</span>
<span class="nc">Inventory</span><span class="o">.</span><span class="n">java</span>

<span class="n">$</span> <span class="n">javac</span> <span class="o">-</span><span class="n">cp</span> <span class="n">bin</span> <span class="o">-</span><span class="n">d</span> <span class="n">bin</span> <span class="nc">Inventory</span><span class="o">.</span><span class="n">java</span> <span class="nc">InventoryItem</span><span class="o">.</span><span class="n">java</span> <span class="o">\</span>
<span class="nc">InventoryManagement</span><span class="o">.</span><span class="n">java</span>

<span class="n">$</span> <span class="n">scala</span> <span class="o">-</span><span class="n">cp</span> <span class="n">bin</span> <span class="nc">InventoryManagement</span>
<span class="nc">Most</span> <span class="n">expensive</span> <span class="n">item</span> <span class="k">=</span> <span class="n">sprocket</span><span class="o">(</span><span class="n">$4</span><span class="o">.</span><span class="mi">99</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_31_5__java_8__scala_2_12">31.5 Інтеграція Java 8 в Scala 2.12</h2>
<div class="sectionbody">
<div class="paragraph"><p>Java 8 додає декілька покращень до мови Java та байткодів, з чого Scala отримує переваги в своєму релізі 2.12.<span class="footnote"><br />[Scala 2.12 потребує Java 8, так щоб вона могла отримувати переваги від можливостей Java 8.]<br /></span> Використовуючи нові можливості Java 8, компілятор Scala 2.12 може генерувати маньші класи та <code>jar</code> файли, та покращити бінарну сумісність трейтів.</p></div>
<div class="sect2">
<h3 id="____sam_">Лямбда вирази та "SAM" типи</h3>
<div class="paragraph"><p>З перспективи Scala програміста, найбільш помітне розширення в Scala 2.12, пов'язане з Java 8 є те, що функціональні літерали Scala можуть бути використані як лямбда вирази Java 8, як більш стисла форма для виразів примірників анонімних класів. Щоб передати поведінку до метода, до появи Java 8 Java програмісти часто визначали примірникі анонімних внутрішніх класів, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">JButton</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span><span class="o">();</span> <span class="c1">// Це Java</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">ActionListener</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="nc">ActionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі анонімний примірник <code>ActionListener</code> створюється та передається до <code>addActionListener</code> в Swing <code>JButton</code>. Коли користувач клацає на кнопці, Swing буде викликати метод <code>actionPerformed</code> на цьому примірнику, що буде друкувати "pressed!".</p></div>
<div class="paragraph"><p>В Java 8 лямбда вираз може використовуватись будь-де, де потрібен примірник класу або інтерфейсу, що містить тільки один абстрактний метод (SAM). <code>ActionListener</code> є такий інтерфейс, оскільки він містить один абстрактний метод, <code>actionPerformed</code>. Таким чином може бути лямбда для реєстрації слухача дій на кнопці Swing. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">JButton</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span><span class="o">();</span> <span class="c1">// Це Java 8</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="n">event</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala ви можете також використовувати анонімний внутрішній клас в тій же ситуації, але ви можете краще використати функціональний літерал, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви вже бачили в Розділі 21.1, ви можете підтримувати такий стиль кодування, через визначення неявної конверсії від функціонального типу <code>ActionEvent =&gt; Unit</code> до <code>ActionListener</code>.</p></div>
<div class="paragraph"><p>Scala 2.12 дозволяє використання функціональних літералів в цьому випадку, навіть за відсутності такого неявного перетворення. Як з Java 8, Scala 2.12 буде дозволяти функціональні типи для використання там, де потрібен примірник класу або трейту, що декларує один абстрактний метод (SAM). Це робить з любим SAM в Scala 2.12. Наприклад, ви можете визначити трейт <code>Increaser</code> з одним абстрактним методом, <code>increase</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Increaser</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">increase</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
<span class="n">defined</span> <span class="k">trait</span> <span class="nc">Increaser</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ви можете визначити метод, що приймає <code>Increaser</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">increaseOne</span><span class="o">(</span><span class="n">increaser</span><span class="k">:</span> <span class="kt">Increaser</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
<span class="n">increaser</span><span class="o">.</span><span class="n">increase</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">increaseOne</span><span class="k">:</span> <span class="o">(</span><span class="kt">increaser:</span> <span class="kt">Increaser</span><span class="o">)</span><span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб викликати ваш новий метод, ви можете передати анонімний примірник до трейту <code>Increaser</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increaseOne</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">Increaser</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">increase</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span>
  <span class="o">}</span>
<span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак в Scala 2.12 ви можете альтернативно просто використати функціональний літерал, оскільки <code>Increaser</code> є SAM типом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increaseOne</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="o">)</span> <span class="c1">// Scala 2.12</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__java_8_stream__scala_2_12">Використання Java 8 Stream зі Scala 2.12</h3>
<div class="paragraph"><p>Java Stream є функціональною структурою даних, що пропонує метод, що сприймає <code>java.util.function.IntUnaryOperator</code>. Зі Scala ви можете викликати <code>Stream.map</code> для інкременту кожного елемента в <code>Array</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.util.function.IntUnaryOperator</span>
<span class="k">import</span> <span class="nn">java.util.function.IntUnaryOperator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.util.Arrays</span>
<span class="k">import</span> <span class="nn">java.util.Arrays</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">IntUnaryOperator</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">applyAsInt</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="o">}</span>
<span class="o">).</span><span class="n">toArray</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак завдяки тому, що <code>IntUnaryOperator</code> є SAM типом, ви можете в Scala 2.12 викликати його більш стисло за допомогою функціонального літерала:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">toArray</span> <span class="c1">// Scala 2.12</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що тільки функціональні літерали будуть адаптовані до SAM типів, не довільні вирази, що мають функціональний тип. Наприклад, розглянемо наступну <code>val</code>, <code>f</code>, що має тип <code>Int =&gt; Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча <code>f</code> має той самий тип, що і функціональний літерал, переданий до <code>stream.map</code> до цього, ви не можете використовувати <code>f</code> там, де потрібний <code>IntUnaryOperator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">toArray</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">java.util.function.IntUnaryOperator</span>
      <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">toArray</span>
                 <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб використати <code>f</code>, ви можете явно викликати її як функціональний літерал, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="o">)).</span><span class="n">toArray</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ви можете анотувати <code>f</code> з <code>IntUnaryOperator</code>, типом, що очікує <code>Stream.map</code>, коли ви визначаєте <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">IntUnaryOperator</span> <span class="o">=</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">java.util.function.IntUnaryOperator</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">toArray</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зі Scala 2.12 та Java 8 ви також можете викликати методи, скомпільовані за допомогою Scala з Java, передаючи функціональні типи Scala з використанням лямбда виразів Java. Хоча функціональні типи Scala визначені як трейти, що включають суцільні методи, Scala 2.12 компілює трейти до Java інтерфейсів з методами по замовчанню, нова можливість Java 8. Як результат, функціональні типи Scala з'являються в Java як SAM.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_31_6_">31.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Більшість часу ви можете ігнорувати, як реалізована Scala, і просто писати та виконувати ваш код. Але іноді гарно "подивитись за лаштунки", так що ця глава зайшла в три аспекти реалізації Scala на Java платформі: як виглядає трансляція, як анотації Scala та Java роблять разом, та як підстановочні типи Scala дозволяють вам отримати доступ до підстановочних типів Java. Також розглянуті використання примітивів конкурентності зі Scala, та компіляцію комбіновиних проектів Scala та Java. Ці теми важливі, чи ви використовуєте Scala та Java разом, чи ні.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__32_2">Глава 32</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____21">Ф'ючерси та конкурентність</h1>
<div class="paragraph"><p>Один з наслідків розповсюдження багатоядерних процесорів був збільшена зацікавленість до конкуренції. Java провадить підтримку конкуренції, побудовану коло розділеної пам'яті та блокування. Хоча ця підтримка є достатньою, цей підхід виявився досить складним, щоб зрозуміти його на практиці. Стандартна бібліотека Scala пропонує альтернативу, що уникає ціх складностей, через фокусування на асинхронних трансофрмаціях незмінного стану: <code>Future</code>.</p></div>
<div class="paragraph"><p>Хоча Java також пропонує <code>Future</code>, воно дуже різне від Scala. Обоє представляють результат асинхронного обчислення, але Java <code>Future</code> потребує, щоб ви отримували доступ до результату через блокуючий метод <code>get</code>. Хоча ви можете викликати <code>isDone</code> для визначення, чи Java <code>Future</code> завершилось, перед викликом <code>get</code>, і так уникнути блокування, ви маєте чекати, доки Java <code>Future</code> буде завершене, перед продовженням любих обчислень, що використовують цей результат.</p></div>
<div class="paragraph"><p>Для конрасту, ви можете вказати трансформації на Scala <code>Future</code>, чи воно завершилось, чи ні. Кожна трансформація має результатом новий <code>Future</code>, що представляє асинхронний результат оригінального <code>Future</code>, трансформованого функцією. Потік, що виконує обчислення, визначається неявно запровадженим контекстом виконання. Це дозволяє вам описати асинхронні обчислення як серії трансформацій незмінних значень, без потреби розмірковувати про розділену пам'ять та блокування.</p></div>
<div class="sect1">
<h2 id="_32_1___">32.1 Проблеми в раю</h2>
<div class="sectionbody">
<div class="paragraph"><p>На Java платформі кожний об'єкт асоційований з логічним монітором, що може бути використаний для контролю багато поточного доступу до даних. Щоб використовувати цю модель, ви вирішуєте, які дані будуть розділені між декількома потоками, та відмічаєте як <code>synchronized</code> розділи коду, що мають доступ, або контролюють доступ до розділених даних. Рантайм Java задіє механізм для переконання, що тільки один потік в момент часу заходить в синхронізовані розділи, захищені тим самим блокуванням, і таким чином дозволяючи вам оркеструвати багато поточним доступом до розділених даних.</p></div>
<div class="paragraph"><p>З причин сумісності Scala провадить доступ до примітивів конкурентності Java. Методи <code>wait</code>, <code>notify</code> та <code>notifyAll</code> можуть бути викликані в Scala, і вони мають те саме значення, що і в Java. Scala технічно не має ключового слова <code>synchronized</code>, але вона включає передвизначений метод <code>synchronized</code>, що може бути викликаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">synchronized</span> <span class="o">{</span>
  <span class="c1">// один потік в кожний момент часу</span>
  <span class="n">counter</span> <span class="k">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нажаль, програмісти визнали дуже складним побудувати надійні багато-поточні застосування з використанням розділених даних та моделі блокування, особливо як застовування зростають в розмірі та складності. Проблема в тому, що в кожній точці в програмі ви маєте продумувати щодо того, які дані змінені або мають доступ, що можуть бути модифіковані або мати доступ з інших потоків, та які блокування утримуються. На кожному виклику метода, ви маєте продумувати щодо того, які блокування була спроба захопити, та переконувати себе, що не виникає глухого блокування під час отримати їх. Ускладнюючи проблему, блокування, про які ви розмірковуєте, не зафіксовані під час компіляції, оскільки програма вільна створювати нові блокування під час виконання, по мірі просування.</p></div>
<div class="paragraph"><p>Що робить речі гуршими, тестування ненадійне з багато-поточним кодом. Оскільки потоки недетерміновані, ви можете успішно тестувати програму тисячу раз, та програма може все ще бути помилковою перший раз, коли вона використовується на машині клієнта. З розділеними даними та блокуваннями ви маєте зробити програму коректною через самі міркування.</p></div>
<div class="paragraph"><p>Більше того, ви не можете рішити проблему через пере-синхронізацію, також. Це буде так само проблематично синхронізувати геть усе, як взагалі не синхронізувати нічого. Хоча нові операції блокуваня можуть видалити можливості стану гонок, вони одночасно додають можливості глихого блокування. Коректна програма, що використовує блокування, повинна не мати одночасно ні станів гонки, ані глухих блокувань, так що ви не можете грати безпечно через надміру в жодному напрямку.</p></div>
<div class="paragraph"><p>Бібліотека <code>java.util.concurrent</code> провадить вищий рівень абстракції для конкурентного програмування. Використовуючи конкуренті утілити можна зробити багато-поточне програмування значно менш схильним до помилок, ніж розвертаючи ваші власні абстракції з низькорівневими примітивами синхронізації Java. Тим не менш, конкурентні утіліти також базовані на розділених даних та моделі блокувань, та як результат не вирішують фундаментальні складності використання цієї моделі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_32_2____try">32.2 Асинхронне використання та Try</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча це і не срібна куля, Scala <code>Future</code> пропонує один спосіб мати справу з конкурентністю, що може зменьшити, а часто і видалити потребу думати про розділені дані та блокування. Коли це включає Scala метод, він виконує обчислення "доки ви очікуєте", та повертає результат. Якщо результат є <code>Future</code>, цей <code>Future</code> представляє інше обчислення, що має бути виконане асинхронно, часто в зовсім іншому потоці. Як результат, багато операцій на <code>Future</code> потребують неявного контексту виконання, що провадить стратегію для виконання функцій асинхронно. Наприклад, якщо ви спробуєте створити ф'ючерс через метод фабрики <code>Future.apply</code> без надання неявного контексту виконання, примірника <code>scala.concurrent.ExecutionContext</code>, ви отримаєте помилку компілятора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.Future</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">find</span> <span class="kt">an</span> <span class="kt">implicit</span> <span class="kt">ExecutionContext.</span>
    <span class="kt">You</span> <span class="kt">might</span> <span class="kt">pass</span> <span class="kt">an</span> <span class="o">(</span><span class="kt">implicit</span> <span class="kt">ec:</span> <span class="kt">ExecutionContext</span><span class="o">)</span>
    <span class="kt">parameter</span> <span class="kt">to</span> <span class="kt">your</span> <span class="kt">method</span> <span class="kt">or</span> <span class="kt">import</span>
    <span class="n">scala</span><span class="o">.</span><span class="n">concurrent</span><span class="o">.</span><span class="nc">ExecutionContext</span><span class="o">.</span><span class="nc">Implicits</span><span class="o">.</span><span class="n">global</span><span class="o">.</span>
        <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
                         <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Повідомлення про помилку дає вам один шлях вирішити цю проблему: імпортування глобального контексту виконання, що провадить сама Scala. На JVM глобальний контекст використовує пул потоків.<span class="footnote"><br />[На Scala.js глобальний контекст виконання покладає завдання на чергу подій JavaScript.]<br /></span> Коли ви занесли неявний контекст виконання в поле зору, ви можете створири ф'ючерс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>
<span class="k">import</span> <span class="nn">scala.concurrent.ExecutionContext.Implicits.global</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Ф'ючерс, створений в попередньому прикладі, асинхронно виконує блок коду, використовуючи глобальний контекст виконання, що завершується зі значенням 42. Як тільки він розпочинає виконання, цей потік буде спати протягом десяти секунд. Таким чином, ф'ючерс буде забирати щонайменьше десять секунд на завершення.</p></div>
<div class="paragraph"><p>Два методи на <code>Future</code> дозволяють вам опитання: <code>isCompleted</code> та <code>value</code>. Коли виконується на ф'ючерсі, що ще не завершений, <code>isCompleted</code> буде повертати <code>false</code>, та <code>value</code> буде повертати <code>None</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">isCompleted</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ф'ючерс завершиться (в цьому випадку коли пройде щонайменш десять секунд), <code>isCompleted</code> буде повертати <code>true</code>, та значення буде повертати <code>Some</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">isCompleted</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Опція, що повертається <code>value</code>, містить <code>Try</code>. Як показано на Малюнку 32.1, <code>Try</code> є або <code>Success</code>, що містить значення типу <code>T</code>, або <code>Failure</code>, що містить виключення ( примірник <code>java.lang.Throwable</code>). Призначення <code>Try</code> є провадити асинхронні обчислення, що вираз <code>try</code> провадить для синхронних обчислень: він дозволяє вам мати справу з можливістю, що обчислення буде закінчено неспродівано з виключенням, скоріше ніж поверне результат.footnotes:[Зауважте, що Java <code>Future</code> також має спосіб мати справу з потенційними виключеннями, що були закинуті асинхронними виключеннями: його метод <code>get</code> буде закидати це виключення, огорнуте в <code>ExecutionException</code>.]</p></div>
<div class="paragraph"><p>Малюнок 32.1 - Ієрархія класів для <code>Try</code>.</p></div>
<div class="paragraph"><p>Для синхронних обчислень ви можете використати <code>try</code>/<code>catch</code> для переконання, що потік, який викликає метод, перехоплює та обробляє виключення, закинуті методом. Однак для асинхронних обчислень потік, що ініціює обчислення, часто переходить до інших завдань. Пізніше, якшо це асинхронно обчислення схибить з виключенням,оригінальний потік буде більше не в змозі обробити виключення в твердженні <code>catch</code>. Таким чином, коли робите з <code>Future</code> що представляє асинхронну активність, ви використовуєте <code>Try</code> щоб мати справу з можливістю, що активність схибить видати значення, та замість цього завершиться несподівано як виключення. Ось приклад, що показує, що відбувається, коли асинхронна активність схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Поітм, через десять секунд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_32_3____">32.3 Робота з ф'ючерсами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala <code>Future</code> дозволяє вам вказати трансформації на результаті <code>Future</code>, та отримати новий ф'ючерс, що представляє композицію двох асинхронних обчислень: оригінального та трансформації.</p></div>
<div class="sect2">
<h3 id="__code_futures_code___code_map_code">Трансформація <code>Futures</code> за допомогою <code>map</code></h3>
<div class="paragraph"><p>Сама фундаментальна така операція є <code>map</code>. Замість блокування, та потім продовження з іншим обчисленням, ви можете просто відобразити наступне обчислення на ф'ючерс. Результатом буде новий ф'ючерс, що представляє оригінальний, асинхронно обчислений результат, асинхронно трансформований функцією, переданою до <code>map</code>.</p></div>
<div class="paragraph"><p>Наприклад, наступний ф'ючерс буде завершений через десять секунд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Відображення цього ф'ючерса функцією, що збільшує на одиницю, буде давати інший ф'ючерс. Цей новий ф'ючерс буде представляти обчислення, що складається з оригінального додавання, за яким слідує наступне збільшення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">fut</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">result</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Як тільки оригінальний ф'ючерс завершується, та функція буде застосована до його результату, ф'ючерс, що повертається з <code>map</code>, буде завершено:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">result</span><span class="o">.</span><span class="n">value</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">43</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що операція, виконана в цьому прикладі, створення ф'ючерса, обчислення суми <code>21 + 21</code>, та інкремент <code>42 + 1</code>, може бути виконана в трьох різних потоках.</p></div>
</div>
<div class="sect2">
<h3 id="__code_future_code____code_for_code">Трансформування <code>Future</code> за допомогою виразів <code>for</code></h3>
<div class="paragraph"><p>Оскільки ф'ючерс Scala також декларує метод <code>flatMap</code>, ви можете трансформувати ф'ючерси з використанням виразу <code>for</code>. Наприклад, розглянемо наступні два ф'ючерса, що будуть через десять секунд виробляти <code>42</code> та <code>46</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut1</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut1</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut2</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">23</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">}</span>
<span class="n">fut2</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці два ф'ючерси, ви можете отримати новий ф'ючерс, що представляє асинхронну суму їх результатів, як це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">{</span>
          <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">fut1</span>
          <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">fut2</span>
       <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Як тільки оригінальні ф'ючерси будуть завершені, та завершиться наступна сума, ви будете в змозі побачити результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res7</span><span class="o">.</span><span class="n">value</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>for</code> вирази серіалізують їх перетворення,footnotes:[Вираз <code>for</code>, показаний в цьому прикладі, буде переписаний як виклик до <code>fut1.flatMap</code>, переданий до функції, що викликає <code>fut2.map</code>: <code>fut1.flatMap(x =&gt; fut2.map(y =&gt; x + y))</code>.] якщо ви не створите ф'ючерси пере виразом, вони не будуть робити паралельно. Наприклад, хоча попередній <code>for</code> вираз потребує близько десяти секунд для завершення, наступний вираз <code>for</code> потребує щонайменьше двадцять секунд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">{</span>
        <span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
        <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">23</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">}</span>
       <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span><span class="o">.</span><span class="n">value</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="c1">// буде потребувати щонайменьше 20 секунд для завершення</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span><span class="o">.</span><span class="n">value</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_future_code_code_future_failed_code_future_successful_code_future_fromtry_code__promise">Створення <code>Future</code>: <code>Future.failed</code>,` Future.successful`, <code>Future.fromTry</code>, та Promise</h3>
<div class="paragraph"><p>Окрім метода <code>apply</code>, використаного в попередніх прикладах для створення ф'ючерсів, об'єкт компанйон <code>Future</code> також включає три метода фабрики для створення вже завершених ф'ючерсів: <code>successful</code>, <code>failed</code> та <code>fromTry</code>. Ці методи фабрики не потребують <code>ExecutionContext</code>.</p></div>
<div class="paragraph"><p>Метод фабрика <code>successful</code> створює ф'ючерс, що вже успішний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">successful</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>failed</code> створює ф'ючерс, що вже схибив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">failed</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;bummer!&quot;</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>fromTry</code> створює вже завершений ф'ючерс на основі <code>Try</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span><span class="nc">Failure</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">Success</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">})</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">.</span><span class="n">fromTry</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;bummer!&quot;</span><span class="o">)))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний спосіб створити ф'ючерс це використати <code>Promise</code>. Маючи проміс ви можете отримати ф'ючерс, що контрольований цім промісом. Ф'ючерс буде завершено, коли ви завершите проміс. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pro</span> <span class="k">=</span> <span class="nc">Promise</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">pro</span><span class="k">:</span> <span class="kt">scala.concurrent.Promise</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="n">pro</span><span class="o">.</span><span class="n">future</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете завершити проміс за допомогою методів на ім'я <code>success</code>, <code>failure</code> та <code>complete</code>. Ці методи на <code>Promise</code> подібні до таких, описаних до цього для конструювання вже завершеного ф'ючерса. Наприклад, метод <code>success</code> буде завершувати ф'ючерс успішно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">pro</span><span class="o">.</span><span class="n">success</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">pro.</span><span class="k">type</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>failure</code> приймає виключення, що змусить ф'ючерс схибити з цім виключенням. Метод <code>complete</code> приймає <code>Try</code>. Метод <code>completeWith</code>, що приймає ф'ючерс, також існує; ф'ючерс промісу буде таким чином відображувати статус ф'ючерса, що ви передали до <code>completeWith</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__code_filter_code__code_collect_code">Фільтрування: <code>filter</code> та <code>collect</code></h3>
<div class="paragraph"><p>Ф'ючерси Scala пропонують два методи, <code>filter</code> та <code>collect</code>, що дозволяють вам переконатись, що властивість дотримується <code>true</code> щодо значень ф'ючерса. Метод <code>filter</code> валідує результат ф'ючерса, залишаючи його тим самим, якщо він валідний. Ось приклад, що переконується, що <code>Int</code> є додатним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">valid</span> <span class="k">=</span> <span class="n">fut</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">valid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо значення ф'ючерса невалідне, ф'ючерс буде хибити з <code>NoSuchElementException</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">invalid</span> <span class="k">=</span> <span class="n">fut</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">invalid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">invalid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
  <span class="kt">Future.filter</span> <span class="kt">predicate</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">satisfied</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>Future</code> також пропонує метод <code>withFilter</code>, ви можете виконати таку саму операцію з фільтрами <code>for</code> виразів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">valid</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">fut</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">yield</span> <span class="n">res</span>
<span class="n">valid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">invalid</span> <span class="k">=</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">fut</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">yield</span> <span class="n">res</span>
<span class="n">invalid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">invalid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
  <span class="kt">Future.filter</span> <span class="kt">predicate</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">satisfied</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>Future</code> дозволяє вам валідувати ф'ючерс, та трансформувати це в одну операцію. Якщо часткова функція, передана до <code>collect</code>, визначена на результаті ф'ючерса, ф'ючерс, що повертає <code>collect</code>, буде успішним зі значенням, що трансформований функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">valid</span> <span class="k">=</span>
         <span class="n">fut</span> <span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">46</span> <span class="o">}</span>
<span class="n">valid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Інакше ф'ючерс буде хибити з <code>NoSuchElementException</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">invalid</span> <span class="k">=</span><span class="n">fut</span> <span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="n">res</span> <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">+</span> <span class="mi">46</span> <span class="o">}</span>
<span class="n">invalid</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">invalid</span><span class="o">.</span><span class="n">value</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
<span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
<span class="kt">Future.collect</span> <span class="kt">partial</span> <span class="kt">function</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">defined</span> <span class="kt">at:</span> <span class="err">42</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_failed_code_code_fallbackto_code_code_recover_code__code_recoverwith_code">Робота з збоями: <code>failed</code>, <code>fallBackTo</code>, <code>recover</code> та <code>recoverWith</code></h3>
<div class="paragraph"><p>Ф'ючерси Scala провадять спосіб робити з ф'ючерсами, що схибили, включаючи <code>failed</code>, <code>fallBackTo</code>, <code>recover</code>,та <code>recoverWith</code>. Метод <code>failed</code> буде трансформувати невдалий ф'ючерс любого типу в <code>successfulFuture[Throwable]</code>, що містить вираз, що спричинив сбій. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">failure</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">}</span>
<span class="n">failure</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">failure</span><span class="o">.</span><span class="n">value</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">expectedFailure</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">failed</span>
<span class="n">expectedFailure</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">expectedFailure</span><span class="o">.</span><span class="n">value</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ф'ючерс, на якому викликаний метод <code>failed</code>, кінець кінцем буде успішним, ф'ючерс, повернутий <code>failed</code> сам буде хибити з <code>NoSuchElementException</code>. Метод <code>failed</code>, таким чином, доречний тільки коли ви очікуєте, що ф'ючерс схибить. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">success</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">/</span> <span class="mi">1</span> <span class="o">}</span>
<span class="n">success</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">success</span><span class="o">.</span><span class="n">value</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">unexpectedSuccess</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">failed</span>
<span class="n">unexpectedSuccess</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">unexpectedSuccess</span><span class="o">.</span><span class="n">value</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Throwable</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span>
<span class="kt">Future.failed</span> <span class="kt">not</span> <span class="kt">completed</span> <span class="kt">with</span> <span class="kt">a</span> <span class="kt">throwable.</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>fallbackTo</code> дозволяє вам провадити альтернативний ф'ючерс, для використання в випадку, коли ф'ючерс, на якому ви викликаєте <code>fallbackTo</code>, схибить. Ось приклад, в якому збійний ф'ючерс відкочується до вдалого ф'ючерса:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fallback</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">fallbackTo</span><span class="o">(</span><span class="n">success</span><span class="o">)</span>
<span class="n">fallback</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fallback</span><span class="o">.</span><span class="n">value</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо оригінальний ф'ючерс, на якому викликається <code>fallbackTo</code>, схибить, збій ф'ючерса, переданого до <code>fallbackTo</code>, просто ігнорується. Ф'ючерс, повернутий <code>fallbackTo</code>, буде хибити з початковим виключенням. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">failedFallback</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">fallbackTo</span><span class="o">(</span>
        <span class="nc">Future</span> <span class="o">{</span> <span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="mi">42</span><span class="o">;</span> <span class="n">require</span><span class="o">(</span><span class="n">res</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">);</span> <span class="n">res</span> <span class="o">}</span>
       <span class="o">)</span>
<span class="n">failedFallback</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">failedFallback</span><span class="o">.</span><span class="n">value</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
<span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>recover</code> дозволяє вам трансформувати вам невдалий ф'ючерс в успішний, дозволяючи результату вдалого ф'ючерса проходити без змін. Наприклад, на ф'ючерсі, що схибив з <code>ArithmeticException</code>, ви можете використати метод <code>recover</code>, щоб трансформувати збій в успіх, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">recovered</span> <span class="k">=</span> <span class="n">failedFallback</span> <span class="n">recover</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ArithmeticException</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">}</span>
<span class="n">recovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">recovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(-</span><span class="mi">1</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо оригінальний ф'ючерс не схибить, ф'ючерс, що повертається з <code>recover</code>, буде завершений з тим самим значенням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">unrecovered</span> <span class="k">=</span> <span class="n">fallback</span> <span class="n">recover</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ArithmeticException</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">}</span>
<span class="n">unrecovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">unrecovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібним чином, якщо часткова функція, передана до <code>recover</code>, не визначена на виключенні, з яким оригінальний ф'ючерс кінець кінцем схибив, цей оригінальний збій буде передано без змін:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">alsoUnrecovered</span> <span class="k">=</span> <span class="n">failedFallback</span> <span class="n">recover</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">IllegalArgumentException</span> <span class="o">=&gt;</span> <span class="o">-</span><span class="mi">2</span>
        <span class="o">}</span>
<span class="n">alsoUnrecovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">alsoUnrecovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>recoverWith</code> подібний до <code>recover</code>, за винятком того, що замість відновлення до значення, як в <code>recover</code>, метод <code>recoverWith</code> дозволяє вам відновити до значення ф'ючерса. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">alsoRecovered</span> <span class="k">=</span> <span class="n">failedFallback</span> <span class="n">recoverWith</span> <span class="o">{</span>
          <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">ArithmeticException</span> <span class="o">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">+</span> <span class="mi">46</span> <span class="o">}</span>
        <span class="o">}</span>
<span class="n">alsoRecovered</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">alsoRecovered</span><span class="o">.</span><span class="n">value</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і з <code>recover</code>, якщо оригінальний ф'ючерс не схибив, або часткова функція, передана до <code>recoverWith</code> не визначена на виключенні, з яким схибив оригінальний ф'ючерс, оригінальний успіх (або збій) будуть передані наскрізь до ф'ючерса, що повертається <code>recoverWith</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____code_transform_code">Відображення обох можливостей: <code>transform</code></h3>
<div class="paragraph"><p>Метод <code>Future</code> <code>transform</code> приймає дві функції, якими він трансформує ф'ючерс: одну для використання в разі вдачі, та іншу для випадку невдачі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">first</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span>
          <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span>
          <span class="n">ex</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
        <span class="o">)</span>
<span class="n">first</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ф'ючерс успішний використовується перша функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">first</span><span class="o">.</span><span class="n">value</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(-</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ф'ючерс зазнає невдачі використовується друга функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">transform</span><span class="o">(</span>
          <span class="n">res</span> <span class="k">=&gt;</span> <span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span>
          <span class="n">ex</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">)</span>
        <span class="o">)</span>
<span class="n">second</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">value</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">see</span> <span class="kt">cause</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що за допомогою метода <code>transform</code>, показаного в попередніх прикладах, ви не можете змінити успішний ф'ючерс на невдалий, так само як неможете перетворити невдалий на успішний. Щоб зробити цей різновид трансформації простішим, Scala 2.12 вводить альтернативну перевантажену форму <code>transform</code>, що приймає функцію з <code>Try</code> до <code>Try</code>. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">firstCase</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">))</span>
        <span class="o">}</span>
<span class="n">first</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">firstCase</span><span class="o">.</span><span class="n">value</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(-</span><span class="mi">42</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">secondCase</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">Failure</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;see cause&quot;</span><span class="o">,</span> <span class="n">ex</span><span class="o">))</span>
        <span class="o">}</span>
<span class="n">secondCase</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">secondCase</span><span class="o">.</span><span class="n">value</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">see</span> <span class="kt">cause</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад використання нового метода <code>transform</code> для трансформації невдачі до успіху:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nonNegative</span> <span class="k">=</span> <span class="n">failure</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">abs</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
        <span class="o">}</span>
<span class="n">nonNegative</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">nonNegative</span><span class="o">.</span><span class="n">value</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_zip_code_code_future_fold_code_code_future_reduce_code_code_future_sequence_code__code_future_traverse_code">Комбінування ф'ючерсів: <code>zip</code>, <code>Future.fold</code>, <code>Future.reduce</code>, <code>Future.sequence</code> та <code>Future.traverse</code></h3>
<div class="paragraph"><p><code>Future</code> та його об'єкт компанйон пропонує методи, що дозволяють вам комбінувати декілька ф'ючерсів. Метод <code>zip</code> буде трансформувати два успішні ф'ючерса в тапл ф'ючерсів з обох значень. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zippedSuccess</span> <span class="k">=</span> <span class="n">success</span> <span class="n">zip</span> <span class="n">recovered</span>
<span class="n">zippedSuccess</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">zippedSuccess</span><span class="o">.</span><span class="n">value</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">((</span><span class="mi">42</span><span class="o">,-</span><span class="mi">1</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо любий з ф'ючерсів схибить, ф'ючерс, що повертається з <code>zip</code> також бути хибним з тим самим виключенням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zippedFailure</span> <span class="k">=</span> <span class="n">success</span> <span class="n">zip</span> <span class="n">failure</span>
<span class="n">zippedFailure</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">zippedFailure</span><span class="o">.</span><span class="n">value</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо обоє з ф'ючерсів невдалі, невдалий ф'ючерс буде містити виключення, що зберігається в початковому ф'ючерсі, тому, на якому був викликаний <code>zip</code>.</p></div>
<div class="paragraph"><p>Об'єкт компанйон пропонує метод <code>fold</code>, що  дозволяє вам акумулювати результати по <code>TraversableOnce</code> колекції ф'ючерсів, отримуючи результуючий ф'ючерс. Якщо всі ф'ючерси в колекції успішні, результуючий ф'ючерс буде успішний з акумульованим результатом. Якщо любий ф'ючерс в колекції схибить, результуючий ф'ючерс буде невдалим. Якщо схиблять декілька ф'ючерсів, результат буде мати невдачу з тим самим виключенням, з яким схибив перший ф'ючерс (більш ранішній в колекції <code>TraversableOnce</code>). Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortyTwo</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fortyTwo</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortySix</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">23</span> <span class="o">+</span> <span class="mi">23</span> <span class="o">}</span>
<span class="n">fortySix</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futureNums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">fortyTwo</span><span class="o">,</span> <span class="n">fortySix</span><span class="o">)</span>
<span class="n">futureNums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">folded</span> <span class="k">=</span>
      <span class="nc">Future</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">futureNums</span><span class="o">)(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">acc</span> <span class="o">+</span> <span class="n">num</span>
      <span class="o">}</span>
<span class="n">folded</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">folded</span><span class="o">.</span><span class="n">value</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>Future.reduce</code> виконує <code>fold</code> без нуля, використовуючи початковий результат ф'ючерса як стартове значення. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">reduced</span> <span class="k">=</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">futureNums</span><span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="n">acc</span> <span class="o">+</span> <span class="n">num</span>
        <span class="o">}</span>
<span class="n">reduced</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">reduced</span><span class="o">.</span><span class="n">value</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">88</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви передасте порожню колекцію до <code>reduce</code>, отриманий ф'ючерс буде хибити з <code>NoSuchElementException</code>.</p></div>
<div class="paragraph"><p>Метод <code>Future.sequence</code> трансформує колекцію <code>TraversableOnce</code> ф'ючерсів в ф'ючерс <code>TraversableOnce</code> зі значень. Наприклад, в неступному прикладі послідовність використовується до трансформації <code>List[Future[Int]]</code> до <code>Future[List[Int]]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futureList</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">.</span><span class="n">sequence</span><span class="o">(</span><span class="n">futureNums</span><span class="o">)</span>
<span class="n">futureList</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">futureList</span><span class="o">.</span><span class="n">value</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">46</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>Future.traverse</code> буде змінювати <code>TraversableOnce</code> з любим типом елементів до <code>TraversableOnce</code> ф'ючерсів, та "послідовність" в ф'ючерс <code>TraversableOnce</code> зі значень. Наприклад, ось <code>List[Int]</code>, що трансформований до <code>Future[List[Int]]</code> через <code>Future.traverse</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">traversed</span> <span class="k">=</span>
        <span class="nc">Future</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span> <span class="o">{</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">Future</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">}</span>
<span class="n">traversed</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">traversed</span><span class="o">.</span><span class="n">value</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_foreach_code_code_oncomplete_code__code_andthen_code">Виконання побічних ефектів: <code>foreach</code>, <code>onComplete</code> та <code>andThen</code></h3>
<div class="paragraph"><p>Іноді вам буває потрібно виконати побічних ефект після закунчення ф'ючерса. <code>Future</code> провадить декілька методів для ціх цілей. Найбільш базовий метод є <code>foreach</code>, що буде виконувати побічний ефект, якщо ф'ючерс закінчився успішно. Наприклад, в наступному прикладі <code>println</code> не виконується в випадку невдалого ф'ючерса, тільки в випадку вдалого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">failure</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">ex</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">success</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">res</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">))</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>for</code> без <code>yield</code> буде переписане до виклика <code>foreach</code>, ви також можете досягти того самого ефекту з використанням <code>for</code> виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">failure</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">res</span> <span class="k">&lt;-</span> <span class="n">success</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Future</code> також пропонує два методи для реєстрації функцій "зворотнього виклику". Метод <code>onComplete</code> буде виконаний кожного разу, коли ф'ючерс нарешті завершується, вдало або невдало. Функції буде переданий <code>Try</code> — <code>Success</code>, що буде містити результат, якщо ф'ючерс успішний, інакше <code>Failure</code>, що міститиме виключення, що призвело до збою ф'ючерса. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.util.</span><span class="o">{</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">success</span> <span class="n">onComplete</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
      <span class="o">}</span>
<span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">failure</span> <span class="n">onComplete</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
        <span class="o">}</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Future</code> не гарантує жодний порядок виконання для функцій зворотнього виклику, зареєстрованих за допомогою <code>onComplete</code>. Якщо ви бажаєте примусити порядок для функцій зворотнього виклику, замість цього ви маєте використовувати <code>andThen</code>. Метод <code>andThen</code> повертає новий ф'ючерс, що відображує (успіхом або невдачею в той же спосіб) оригінальний ф'ючерс на те що ви викликаєте <code>andThen</code>, але він не завершується, доки функція зворотнього виклику не буде повністю виконаний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">newFuture</span> <span class="k">=</span> <span class="n">success</span> <span class="n">andThen</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">res</span><span class="o">)</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>
        <span class="o">}</span>
<span class="mi">42</span>
<span class="n">newFuture</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">newFuture</span><span class="o">.</span><span class="n">value</span>
<span class="n">res76</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо функція зворотнього виклику, передана до <code>andThen</code>, при виконанні закидає виключення, це виключення не буде просуватись до наступних зворотніх викликів, або повідомлятись через отриманий ф'ючерс.</p></div>
</div>
<div class="sect2">
<h3 id="_____2_12_code_flatten_code_code_zipwith_code__code_transformwith_code">Інші методи, додані в 2.12: <code>flatten</code>, <code>zipWith</code> та <code>transformWith</code></h3>
<div class="paragraph"><p>Метод <code>flatten</code>, доданий в 2.12, трансформує <code>Future</code>, вкладене до іншого <code>Future</code> на <code>Future</code> вкладеного типу. Наприклад, <code>flatten</code> може трансформувати <code>Future[Future[Int]]</code> на <code>Future[Int]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nestedFuture</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">42</span> <span class="o">}</span> <span class="o">}</span>
<span class="n">nestedFuture</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">flattened</span> <span class="k">=</span> <span class="n">nestedFuture</span><span class="o">.</span><span class="n">flatten</span> <span class="c1">// Scala 2.12</span>
<span class="n">flattened</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Future</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>zipWith</code>, доданий в 2.12, в основному поєднує два <code>Future</code> разом, потім виконує <code>map</code> на результуючому таплі. Ось приклад двокрокового процесу, <code>zip</code>, за яким іде <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futNum</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">futNum</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">futStr</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="s">&quot;ans&quot;</span> <span class="o">+</span> <span class="s">&quot;wer&quot;</span> <span class="o">}</span>
<span class="n">futStr</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zipped</span> <span class="k">=</span> <span class="n">futNum</span> <span class="n">zip</span> <span class="n">futStr</span>
<span class="n">zipped</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mapped</span> <span class="k">=</span> <span class="n">zipped</span> <span class="n">map</span> <span class="o">{</span>
          <span class="k">case</span> <span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&quot;</span><span class="si">$num</span><span class="s"> is the </span><span class="si">$str</span><span class="s">&quot;</span>
        <span class="o">}</span>
<span class="n">mapped</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mapped</span><span class="o">.</span><span class="n">value</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span> <span class="n">is</span> <span class="n">the</span> <span class="n">answer</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>zipWith</code> дозволяє вам виконати ту ж операцію в один крок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="n">futNum</span><span class="o">.</span><span class="n">zipWith</span><span class="o">(</span><span class="n">futStr</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">str</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">s&quot;</span><span class="si">$num</span><span class="s"> is the </span><span class="si">$str</span><span class="s">&quot;</span>
        <span class="o">}</span>
<span class="n">zipWithed</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">value</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Success</span><span class="o">(</span><span class="mi">42</span> <span class="n">is</span> <span class="n">the</span> <span class="n">answer</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Future</code> також отримав метод <code>transformWith</code> в Scala 2.12, що дозволяє вам трансформувати ф'ючерс, використовуючи функцію від <code>Try</code> до <code>Future</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">flipped</span> <span class="k">=</span> <span class="n">success</span><span class="o">.</span><span class="n">transformWith</span> <span class="o">{</span> <span class="c1">// Scala 2.12</span>
          <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">res</span><span class="o">)</span> <span class="k">=&gt;</span>
            <span class="nc">Future</span> <span class="o">{</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="n">res</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span> <span class="o">}</span>
          <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Future</span> <span class="o">{</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
        <span class="o">}</span>
<span class="n">flipped</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">flipped</span><span class="o">.</span><span class="n">value</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">scala.util.Try</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">Some</span><span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="err">42</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>transformWith</code> подібний до нового, перевантаженого метода <code>transform</code>, доданого в Scala 2.12, за винятком, що замість видачі <code>Try</code> в вашу передану функцію як в <code>transform</code>, <code>transformWith</code> дозволяє вам видати функцію.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_32_4___">32.4 Тестування ф'ючерсів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна перевага ф'ючерсів Scala в тому, що вони допомагають уникати блокування. На більшості JVM реалізацій після створення тільки декількох тисяч потоків, вартість перемикання між потоками буде деградувати продкутивність до неприйнятного рівня. Через уникнення блокування ви можете підтримувати скінчене число потоків, які ви вважаєте необхідними для напруженої роботи. Тим не менш Scala дозволяє вам блокувати на результаті ф'ючерса, якщо вам потрібно. Об'єкт Scala <code>Await</code> спрощує блокування для очікування результату ф'ючерса. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Await</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
<span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">fut</span><span class="o">,</span> <span class="mf">15.</span><span class="n">seconds</span><span class="o">)</span> <span class="c1">// blocks</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Await.result</code> приймає <code>Future</code> та <code>Duration</code>. <code>Duration</code> вказує, як довго <code>Await.result</code> має чекати завершення <code>Future</code> перед таймаутом. В цьому прикладі для <code>Duration</code> було вказано 15 секунд. Таким чином, метод <code>Await.result</code> не повинен вийти в таймаут перед завершенням функції, що обчислює значення <code>42</code>.</p></div>
<div class="paragraph"><p>Одне місце, де блокування загалом прийнятне, це в тестах асинхронного коду. Коли цей <code>Await.result</code> повертається, ви можете виконувати обчислення з використанням результату, як твердження в тесті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">org.scalatest.Matchers._</span>
<span class="k">import</span> <span class="nn">org.scalatest.Matchers._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">org.scalatest.Assertion</span> <span class="o">=</span> <span class="nc">Succeeded</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно, ви можете використовувати блокуючі конструкції, що провадить ScalaTest трейт <code>ScalaFutures</code>. Наприклад, метод <code>futureValue</code>, неявно доданий до <code>Future</code> через <code>ScalaFutures</code>, буде блокувати, доки ф'ючерс не завершиться. Якщо ф'ючерс схибить, <code>futureValue</code> буде закидати <code>TestFailedException</code>, що описує проблему. Якщо ф'ючерс успішний, <code>futureValue</code> буде повертати успішний результат ф'ючерса, так що ви можете виконати твердження для значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">org.scalatest.concurrent.ScalaFutures._</span>
<span class="k">import</span> <span class="nn">org.scalatest.concurrent.ScalaFutures._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fut</span> <span class="k">=</span> <span class="nc">Future</span> <span class="o">{</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">10000</span><span class="o">);</span> <span class="mi">21</span> <span class="o">+</span> <span class="mi">21</span> <span class="o">}</span>
<span class="n">fut</span><span class="k">:</span> <span class="kt">scala.concurrent.Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fut</span><span class="o">.</span><span class="n">futureValue</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="c1">// futureValue блокується</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">org.scalatest.Assertion</span> <span class="o">=</span> <span class="nc">Succeeded</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча блокування в тестах часто гарне, ScalaTest 3.0 додає "асинхронні" стилі тестування, що дозволяють вам тестувати ф'ючерсси без блокування. Маючи ф'ючерс, замість блокування і виконання тверджень на результаті, ви можете відображити твердження напряму на цей ф'ючерс, та повернути результуючий <code>Future[Assertion]</code> до ScalaTest.</p></div>
<div class="paragraph"><p>Приклад показаний на Лістингу 32.1. Коли твердження ф'ючерса завершиться, ScalaTest запустить події (тест успішний, тест схибив, тощо) то доповідача тестів асинхронно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.scalatest.AsyncFunSpec</span>
<span class="k">import</span> <span class="nn">scala.concurrent.Future</span>

<span class="k">class</span> <span class="nc">AddSpec</span> <span class="k">extends</span> <span class="nc">AsyncFunSpec</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">addSoon</span><span class="o">(</span><span class="n">addends</span><span class="k">:</span> <span class="kt">Int*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Future</span> <span class="o">{</span> <span class="n">addends</span><span class="o">.</span><span class="n">sum</span> <span class="o">}</span>

  <span class="n">describe</span><span class="o">(</span><span class="s">&quot;addSoon&quot;</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">it</span><span class="o">(</span><span class="s">&quot;will eventually compute a sum of passed Ints&quot;</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">futureSum</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">addSoon</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
      <span class="c1">// Ви можете відобразити твердежння на Future, потім</span>
      <span class="c1">// повернути отриманий Future[Assertion] до ScalaTest:</span>
      <span class="n">futureSum</span> <span class="n">map</span> <span class="o">{</span> <span class="n">sum</span> <span class="k">=&gt;</span> <span class="n">assert</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 32.1 - Повернення ф'ючерного твердження до <code>ScalaTest</code>.</p></div>
<div class="paragraph"><p>Випадок використання асинхронного тестування ілюструє загальний принцип для роботи з ф'ючерсами: опинившись у "ф'ючерному космосі", намагайтесь залишатись у ф'ючерному космосі. Не блокуйте на ф'ючерсі, та потім не продовжуйте обчислення з результатом. Залишайтесь асинхронним через виконання серій трансформацій, кожна з яких повертає новий ф'ючерс до <code>transform</code>. Щоб отримати результати з ф'ючерного космосу, реєструйте побічні ефекти, що будуть виконуватись асинхронно, коли ф'ючерс завершиться. Цей підхід допоможе вам максимально задіяти ваші потоки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_32_5_">32.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Конкуренте програмування надає вам велику силу. Воно дозволяє вам отримати перевагу від декількох процесорів. На невдачу, що найбільш широко застосовувані конкурентні примітиви, потоки, блокування та монітори, є таким мінним полем з глухих блокувань та станів гонок. Ф'ючерси провадять спосіб виходу з цього мінного поля, дозволяючи вам писати конкурентні програми без великого ризику глухих блокувань та станів гонок. Ця глава ввела декіклька фундаментальних конструкцій для роботи зі ф'ючерсами в Scala, включаючи як створити ф'ючерси, як трансормувати їх, та як їх протестувати, крім інших дрібниць. Вона також показала вам, як використовувати ці конструкції, як частину загального стилю ф'ючерсів.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__33_2">Глава 33</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___66">Парсинг комбінатора</h1>
<div class="paragraph"><p>Часом вам треба обробити малу мову особливого призначення. Наприклад, вам може бути треба прочитати файли конфігурації для вашої програми, і ви бажаєте зробити їх простішими до ручної модифікації, ніж XML. Альтернативно, можливо ви бажаєте підтримати вхідну мову в вашій програмі, таку як пошук термінів з логічними операторами (комп<em>ютер, знайди мені кіно "з &#8216;космічні кораблі</em> та без `любовні історії"&#8217;). Якою б не була причина, вам буде треба парсер. Вам треба спосіб конвертувати вхідну мову в деякі структури даних, які ваша програма може обробити.</p></div>
<div class="paragraph"><p>В основному у вас лише декілька варіантів. Один варіант є розгорнути ваш власний парсер (та лексічний аналізатор). Якщо ви не експерт, це буде складно. Якщо ви експерт, це все одно витратить час.</p></div>
<div class="paragraph"><p>Альтернативний вибір є використання генератора парсерів. Існує декілька таких генераторів. Деякі з краще відомих є Yacc та Bison для персерів, написаних на C, ANTLR для персерів, написаних на Java. Вам також, можливо, знадобиться генератор сканерів, такий, як Lex, Flex або JFlex, щоб йшли з ними. Це може бути кращим рішенням, за винятком пари незручностей. Вам треба вивчити нові інструменти, включаючи їх, іноді таємні, повідомлення про помилки. Вам також треба зрозуміти, як під'єднати вивід ціх інструментів до вашої програми. Це може обмежити вибір вашої мови програмування, та ускладнити ваш ланцюжок інструментів.</p></div>
<div class="paragraph"><p>Ця глава представляє третю альтернативу. Замість використання окремої специфічної мови генератора парсерів, ви будете використовувати використовувати внутрішню домен специфічну мову, або скорочено інутрішню DSL. Внутрішній DSL буде складатись з бібліотеки комбінаторів парсера — функцій та операторів, визначених в Scala, що будуть служити як будівельні блоки для парсерів. Ці будівельні блоки будуть відповідати один до одного з конструкціями контекст-вільної граматики, щоб зробити їх простішими для розуміння.</p></div>
<div class="paragraph"><p>Ця глава вводить тільки одну мовну можливість, що не було пояснена до цього: псевдоними <code>this</code> з Розділа 33.6. Однак, ця глава важко використовує деякі інші можливості, що були пояснені в попередніх главах. Крім інших: параметризовані типи, абстрактні типи, функції та об'єкти, перевантаження операторів, параметри за-ім'ям та неявні перетворення - всі відіграють важливі ролі. Ця глава показує, як ці мовні елементи можуть бути скомбіновані в розробці дуже високорівневої бібліотеки.</p></div>
<div class="paragraph"><p>Пояснені в цій главі концепції мають схильність бути більш просунутими, ніж в попередніх главах. Якщо ви маєте гарне підгрунтя в комп'юторній конструкції, ви отримаєте вигоду від цієї глави, оскільки вона допоможе розуміти речі краще в перспективі. Однак єдиною передумовою для розуміння цієї глави є лише ваше знання про регулярні вирази та контекст-вільні граматики. Якщо ви не знаєте, що це, матеріал цієї глави також може бути безпечно пропущений.</p></div>
<div class="sect1">
<h2 id="_33_1___">33.1 Приклад: арифметичні вирази</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми почнемо з приклада. Скажімо, ви бажаєте сконструювати парсер для арифметичних виразів, що складаються з чисел з плаваючою крапкою, дужок та двійникових операторів <code>+</code>, <code>-</code>, <code>*</code>, та <code>/</code>. Перший крок завжди є виписати граматику для мови, яку ми будемо розбирати. Ось граматика для арифметичних виразів:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  expr ::= term {"+" term | "-" term}.
  term ::= factor {"*" factor | "/" factor}.
  factor ::= floatingPointNumber | "(" expr ")".</code></pre>
</div></div>
<div class="paragraph"><p>Тут, <code>|</code> позначає альтернативні продукції, та <code>\{ ... \}</code> означає повторення (нуль або більше раз). Та хоча в даному прикладі це не використовується, <code>[ ... ]</code> означатиме опціональну присутність.</p></div>
<div class="paragraph"><p>Ця контекст-вільна граматика формально визначає мову арифметичних виразів. Кожний вираз (представлений <em>expr</em>) є <code>term</code>, за яким може іти послідовність операторів <code>+</code> або <code>-</code>, та подальші терми. Терм <em>term</em> є <em>factor</em>, за яким можливо іде послідовність операторів <code>*</code> або <code>/</code> та подальші фактори. Фактор є числовий літерал або вираз в дужках. Зауважте, що граматика завжди кодує відносні преоритети операторів. Наприклад, <code>*</code> прикріплюється сильніше, ніж <code>+</code>, оскільки операція <code>*</code> дає <code>term</code>, тоді як операція <code>+</code> дає <code>expr</code>, та <code>expr</code> можуть містити <code>term</code>, але <code>term</code> може містити <code>expr</code>, тільки якщо останній оточений в дужки.</p></div>
<div class="paragraph"><p>Тепер, коли ми маємо визначену граматику - що далі? Якщо ви використовуєте комбінаторний парсер Scala, ви вже в основному закінчили! Вам тільки потрібно виконати деякі систематичні текстові заміни, та огорнути парсер в клас, як показано в Лістингу 33.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>
<span class="k">class</span> <span class="nc">Arith</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">term</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">~</span><span class="n">term</span> <span class="o">|</span> <span class="s">&quot;-&quot;</span><span class="o">~</span><span class="n">term</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">factor</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">~</span><span class="n">factor</span> <span class="o">|</span> <span class="s">&quot;/&quot;</span><span class="o">~</span><span class="n">factor</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">floatingPointNumber</span> <span class="o">|</span> <span class="s">&quot;(&quot;</span><span class="o">~</span><span class="n">expr</span><span class="o">~</span><span class="s">&quot;)&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.1 - Парсер арифметичних виразів.</p></div>
<div class="paragraph"><p>Парсери для арифметичних виразів містяться в класі, що наслідує від трейту <code>JavaTokenParsers</code>. Цей трейт провадить базову механіку для написання парсера, і також провадить деякі примітивні парсери, що розпізнають деякі класи слів: ідентифікатори, рядокві літерали та числа. В прикладі на Лістингу 33.1 вам треба тільки парсер примітивів <code>floatingPointNumber</code>, що наслідується з цього трейту.</p></div>
<div class="paragraph"><p>Три визначення в класі <code>Arith</code> представляє продукування для арифметичних виразів. Як ви можете бачити, вони слідують дуже тісно контекст-вільній граматиці. Фактично, ви можете генерувати цю частину автоматично з контекстно-вільної граматики, через виконання декількох простих текстових замін:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Кожна продукція стає методом, так що вам треба поставити перед ними префікс <code>def</code>.
</p>
</li>
<li>
<p>
Тип результату кожного метода є <code>Parser[Any]</code>, так що вам треба змінити символ <code>::=</code> на <code>: Parser[Any] =</code>. Ви з'ясуєте пізніше в цій главі, що позначає <code>Parser[Any]</code>, а також як зробити його більш точним.
</p>
</li>
<li>
<p>
В цій граматиці послідовна композиція була неявною, але в програмі вона виражена явним оператором: <code>~</code>. Так що вам треба вставити <code>~</code> між кожними двома послідовними символами продукції. В прикладі на Лістингу 33.1 ми обрали не писати жодних проміжків коло оператора <code>~</code>. Таким чином, код парсера близько притримується до візуального вигляду граматики — він тільки замінює проміжки на символи <code>~</code>.
</p>
</li>
<li>
<p>
Повторення виражене як <code>rep( ... )</code> замість <code>{ ... }</code>. Аналогічно (хоча це не показано в прикладі), опції виражені як <code>opt( ... )</code> замість <code>[ ... ]</code>.
</p>
</li>
<li>
<p>
Крапка (<code>.</code>) в кінці кожної продукції випущена - однак ви можете ставити крапки з комою (<code>;</code>), якщо бажаєте.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Ось і все щодо цього. Результуючий клас <code>Arith</code> визначає три парсери, <code>expr</code>, <code>term</code> та <code>factor</code>, що можуть використовуватись для розбору арифметичних виразів та їх частин.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_2___">33.2 Виконання вашого парсера</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете спробувати ваш парсер за допомогою такої невеликої програми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">ParseExpr</span> <span class="k">extends</span> <span class="nc">Arith</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;input : &quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">parseAll</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Об'єкт <code>ParseExpr</code> визначає головний метод, що розбирає перший аргумент командного рядка, переданий до нього. Він друкує оригінальний вхідний аргумент, та потім друкує його розібрану версію. Парсинг виконується виразом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">parseAll</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">input</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз застосовує персер <code>expr</code> до отриманого вводу. Він очікує, що весь вхід співпадає, тобто немає символів, що ідуть за розбиваним виразом. Також існує метод <code>parse</code>, що дозволяє розбирати префікс вводу, залишаючи деякий залишок непрочитаним.</p></div>
<div class="paragraph"><p>Ви можете запустити арифметичний парсер за допомогою наступної команди:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">ParseExpr</span> <span class="s">&quot;2 * (3 + 7)&quot;</span>
<span class="n">input</span><span class="k">:</span> <span class="err">2</span> <span class="kt">*</span> <span class="o">(</span><span class="err">3</span> <span class="kt">+</span> <span class="err">7</span><span class="o">)</span>
<span class="err">[1</span><span class="kt">.</span><span class="err">12]</span> <span class="kt">parsed:</span> <span class="o">((</span><span class="err">2</span><span class="kt">~List</span><span class="o">((</span><span class="kt">*~</span><span class="o">(((</span><span class="kt">~</span><span class="o">((</span><span class="err">3</span><span class="kt">~List</span><span class="o">())</span><span class="kt">~List</span><span class="o">((</span><span class="kt">+</span>
<span class="kt">~</span><span class="o">(</span><span class="err">7</span><span class="kt">~List</span><span class="o">())))))</span><span class="kt">~</span><span class="o">)))))</span><span class="kt">~List</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Вивід каже вам, що парсер успішно проаналізував вхідний рядок до позиції <code>[1.12]</code>. Це означає, що перший рядок та дванадцята колонка - іншими словами весь наш вхідний рядок — був прочитаний. Доки не зважайте на результат після <code>parsed:</code>. Він не дуже корисний, і пізніше ви зрозумієте, як отримати більш специфічні результати парсера.</p></div>
<div class="paragraph"><p>Ви також можете спробувати ввести деякі вхідні рядки, що не є легальними виразами. Наприклад, ви можете написати вираз з однією зайвою дужкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">ParseExpr</span> <span class="s">&quot;2 * (3 + 7))&quot;</span>
<span class="n">input</span><span class="k">:</span> <span class="err">2</span> <span class="kt">*</span> <span class="o">(</span><span class="err">3</span> <span class="kt">+</span> <span class="err">7</span><span class="o">))</span>
<span class="o">[</span><span class="err">1</span><span class="kt">.</span><span class="err">12</span><span class="o">]</span> <span class="n">failure</span><span class="k">:</span> <span class="kt">`-&#39; expected but `</span><span class="o">)</span><span class="err">&#39;</span> <span class="n">found</span>

<span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">7</span><span class="o">))</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут парсер <code>expr</code> розбирає все до фінальних замикаючих дужок, що не формує частину арифметичного виразу. Метод <code>parseAll</code> при цьому видає повідомлення про помилку, що каже, що очікувався оператор <code>-</code> в тій точки, де стоїть замикаюча дужка. Пізніше в цій главі ви зрозумієте, чому продукується саме таке повідомлення про помилку, та як покращити його.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_3____">33.3 Базовий парсер регулярних виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Парсер для арифметичних виразів використовує інший парсер на ім'я <code>floatingPointNumber</code>. Цей парсер, що був наслідуваний від супертрейта <code>Arith</code>, <code>JavaTokenParsers</code>, розпізнає числа з плаваючою крапкою в форматі Java. Але що ви робите, якщо вам треба розібрати числа в форматі, що трохі інші від Java? В цій ситуації ви можете використати парсер регулярних виразів.</p></div>
<div class="paragraph"><p>Ідея в тому, що ви можете використовувати любий регулярний вираз як парсер. Регулярний вираз розбирає всі рядки, що можуть співпасти. Його результат є розібраний рядок. Наприклад, регулярний вираз, показаний в Лістингу 33.2, описує Java ідентифікатори:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyParsers</span> <span class="k">extends</span> <span class="nc">RegexParsers</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">ident</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;[a-zA-Z_]\w*&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.2 - Парсер регулярних виразів для Java ідентифікаторів.</p></div>
<div class="paragraph"><p>Об'єкт <code>MyParsers</code> з Лістинга 33.2 наслідує від трейта <code>RegexParsers</code>, тоді як <code>Arith</code> наслідується від <code>JavaTokenParsers</code>. Комбінатори парсінгу Scala вибудовані в ієрархію трейтів, які всі містяться в пакунку <code>scala.util.parsing.combinator</code>. Трейт вищого рівня є <code>Parsers</code>, що визначає дуже загальний фреймворк парсингу для всіх сортів вводу. На рівень нижче трейт <code>RegexParsers</code>, що потребує, щов ввод був послідовністю символів, та провадить парсинг по регулярним виразам. Навіть більш спеціалізований є трейт <code>JavaTokenParsers</code>, що реалізує парсери для базових класів слів (або токенів), як вини визначені в Java.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_4___json">33.4 Інший приклад: JSON</h2>
<div class="sectionbody">
<div class="paragraph"><p>JSON, JavaScript Object Notation, є популярним форматом обміну даними. В цьому розділі ми покажемо, як написати парсер для нього. Ось граматика, що описує синтаксис JSON:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>value ::= obj | arr | stringLiteral |
          floatingPointNumber |
          "null" | "true" | "false".
obj ::= "{" [members] "}".
arr ::= "[" [values] "]".
members ::= member {"," member}.
member ::= stringLiteral ":" value.
values ::= value {"," value}.</code></pre>
</div></div>
<div class="paragraph"><p>Значення JSON є об'єкт, масив, рядок, число або одне з трьох зарезервованих слів: <code>null</code>, <code>true</code>, <code>false</code>. Об'єкт JSON є (можливо порожньою) послідовністю членів, розділених комами, та оточених дужками. Кожний член є парою ключ/значення, де початковий рядок та значення розділені двома крапками. Нарешті, масив JSON є послідовністю значень, розділених комами, та оточених прямокутними дужками. Як приклад, Лістинг 33.3 містить адресну книгу, відформатовану як об'єкт JSON.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;address book&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;John Smith&quot;</span><span class="p">,</span>
    <span class="nt">&quot;address&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;street&quot;</span><span class="p">:</span> <span class="s2">&quot;10 Market Street&quot;</span><span class="p">,</span>
      <span class="nt">&quot;city&quot;</span> <span class="p">:</span> <span class="s2">&quot;San Francisco, CA&quot;</span><span class="p">,</span>
      <span class="nt">&quot;zip&quot;</span> <span class="p">:</span> <span class="mi">94111</span>
    <span class="p">},</span>
    <span class="nt">&quot;phone numbers&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;408 338-4238&quot;</span><span class="p">,</span>
      <span class="s2">&quot;408 111-6892&quot;</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.3 - Дані в форматі JSON.</p></div>
<div class="paragraph"><p>Парсинг таких даних є промолінійним, коли використовується комбінатори парсерів Scala. Повний парсер показаний на Лістингу 33.4. Цей парсер слідує тій самій структурі, що і парсер арифметичних виразів. Він знову є прямолінійним відображенням продукцій граматики JSON. Продукції використовують одне скорочення, що спрощує граматику: комбінатор <code>repsep</code> розбирає (можливо порожню) послідовність термів, що розділені наданим рядком роздільника. Наприклад, в прикладі в Лістингу 33.4, <code>repsep(member, ",")</code> розбирає розділену комами послідовність термів-членів. Крім цього продукції в парсері точно співпадають продукціям в граматиці, як було в випадку парсера арифметичних виразів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>

<span class="k">class</span> <span class="nc">JSON</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">value</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="o">|</span> <span class="n">arr</span> <span class="o">|</span>
    <span class="n">stringLiteral</span> <span class="o">|</span>
    <span class="n">floatingPointNumber</span> <span class="o">|</span>
    <span class="s">&quot;null&quot;</span> <span class="o">|</span> <span class="s">&quot;true&quot;</span> <span class="o">|</span> <span class="s">&quot;false&quot;</span>
  <span class="k">def</span> <span class="n">obj</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;{&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;}&quot;</span>
  <span class="k">def</span> <span class="n">arr</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;[&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;]&quot;</span>
  <span class="k">def</span> <span class="n">member</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">stringLiteral</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.4 - Простий парсер JSON.</p></div>
<div class="paragraph"><p>Щоб спробувати JSON парсери ми трохі змінимо фреймворк, так щоб парсер оперував файлом, замість командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>

<span class="k">object</span> <span class="nc">ParseJSON</span> <span class="k">extends</span> <span class="nc">JSON</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">reader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">parseAll</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">reader</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>main</code> в цій програмі спочатку створює об'єкт <code>FileReader</code>. Потім він розбирає символи, що повертаються рідером, відповідно до продукції значень граматики JSON. Зауважте, що <code>parseAll</code> та <code>parse</code> існують в перевантажених варіантах: обоє можуть приймати послідовність символів, або альтернативно вхідний ридер як другий аргумент.</p></div>
<div class="paragraph"><p>Якщо <code>ParseJSON</code> впорається, ви повинні отримати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ scala ParseJSON address-book.json
<span class="o">[</span><span class="m">13</span>.4<span class="o">]</span> parsed: <span class="o">(({</span>~List<span class="o">(((</span><span class="s2">&quot;address book&quot;</span>~:<span class="o">)</span>~<span class="o">(({</span>~List<span class="o">(((</span>
<span class="s2">&quot;name&quot;</span>~:<span class="o">)</span>~<span class="s2">&quot;John Smith&quot;</span><span class="o">)</span>, <span class="o">((</span><span class="s2">&quot;address&quot;</span>~:<span class="o">)</span>~<span class="o">(({</span>~List<span class="o">(((</span>
<span class="s2">&quot;street&quot;</span>~:<span class="o">)</span>~<span class="s2">&quot;10 Market Street&quot;</span><span class="o">)</span>, <span class="o">((</span><span class="s2">&quot;city&quot;</span>~:<span class="o">)</span>~<span class="s2">&quot;San Francisco</span>
<span class="s2">,CA&quot;</span><span class="o">)</span>, <span class="o">((</span><span class="s2">&quot;zip&quot;</span>~:<span class="o">)</span>~94111<span class="o">)))</span>~<span class="o">}))</span>, <span class="o">((</span><span class="s2">&quot;phone numbers&quot;</span>~:<span class="o">)</span>~<span class="o">(([</span>~
List<span class="o">(</span><span class="s2">&quot;408 338-4238&quot;</span>, <span class="s2">&quot;408 111-6892&quot;</span><span class="o">))</span>~<span class="o">]))))</span>~<span class="o">}))))</span>~<span class="o">})</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_5__">33.5 Вивід парсера</h2>
<div class="sectionbody">
<div class="paragraph"><p>Програма <code>ParseJSON</code> успішно розібрала адресну книгу JSON. Однак вивід парсера виглядає странно. Це виглядає як послідовність, що складена зі шматків вводу, склеєні разом списками та комбінаціями <code>~</code>. Цей вивід не дуже корисний. Він менш читабельний для людей, ніж вхід, але він також дуже дезорганізований, щоб бути просто проаналізований комп'ютером. Прийшов час щось робити з цім.</p></div>
<div class="paragraph"><p>Щоб зрозуміти, що маємо робити, вам спочатку треба знати, що окремі парсери в фреймворці комбінатора повертають як результат (звичайно, якщо вони змогли розібрати вхідні дані). Ось правила:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Кожний парсер, написаний як рядок (як в <code>"{"</code> або <code>":"</code> або <code>"null"</code>) повертає сам розібраний рядок.
</p>
</li>
<li>
<p>
Парсери регулярних виразів, як <code>"""[a-zA-Z_]\w*""".r</code> також повертають самий розібраний рядок. Те саме дотримується для парсерів регулярних виразів, таких як <code>stringLiteral</code> або <code>floatingPointNumber</code>, що наслідуються від <code>JavaTokenParsers</code>.
</p>
</li>
<li>
<p>
Послідовна композиція <code>P~Q</code> повертає результат від обох, <code>P</code> та <code>Q</code>. Ці результати повертаються в вигляді примірника кейс класа , що також записується <code>~</code>. Так що якщо <code>P</code> повертає <code>"true"</code> та <code>Q</code> повертає <code>"?"</code>, тоді послідовна композиція <code>P~Q</code> повертає <code>~("true", "?")</code>, що друкується як <code>(true~?)</code>.
</p>
</li>
<li>
<p>
Альтернативна композиція <code>P | Q</code> повертає результат або <code>P</code> або <code>Q</code>, який буде успішний.
</p>
</li>
<li>
<p>
Повторення <code>rep(P)</code> або <code>repsep(P, separator)</code> повертає список з результатів всіх викликів <code>P</code>.
</p>
</li>
<li>
<p>
Опція <code>opt(P)</code> повертає примірник типу Scala <code>Option</code>. Віе повертає <code>Some(R)</code>, якщо <code>P</code> успішний з результатом <code>R</code>, та <code>None</code>, якщо <code>P</code> схибить.
</p>
</li>
</ol></div>
<div class="paragraph"><p>З ціма правилами ви тепер можете вивести, чому вивід парсера виглядає як виглядає в попередніх прикладах. Однак вивід все ще не дуже зручний. Може бути значно кращим відобразити JSON об'єкт на внутрішню репрезентацію Scala, що представлятиме значення  JSON об'єкту. Більш природна репрезентація може бути наступною:</p></div>
<div class="ulist"><ul>
<li>
<p>
JSON об'єкт представлений як мапа Scala типу <code>Map[String, Any]</code>. Кожний член представлений як прікріплення ключ/значення в мапі.
</p>
</li>
<li>
<p>
JSON масив представлений як Scala список типу <code>List[Any]</code>.
</p>
</li>
<li>
<p>
JSON рядок представлений як Scala <code>String</code>.
</p>
</li>
<li>
<p>
Числовий літерал JSON представлений як Scala <code>Double</code>.
</p>
</li>
<li>
<p>
Значення <code>true</code>, <code>false</code>, та <code>null</code> представлені як Scala значення з тими самими іменами.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Щоб спродукувати цю репрезентацію, вам треба задіяти ще один комбінатор для парсерів: <code>^^</code>. Оператор <code>^^</code> трансформує результат парсера. Вирази, що використовують цей оператор, мають форму <code>P ^^ f</code>, де <code>P</code> є парсер, а <code>f</code> є функція. <code>P ^^ f</code> парсить ті самі фрази, що і просто <code>P</code>. Коли <code>P</code> повертає той самий результат <code>R</code>, результатом <code>P ^^ f</code> буде <code>f(R)</code>. Як приклад, ось парсер, що розбирає число з плаваючою крапкою, та перетворює його в Scala значення типу <code>Double</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">floatingPointNumber</span> <span class="o">^^</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та ось парсер, що розбирає рядок <code>"true"</code>, та повертає логічне значенн Scala <code>true</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;true&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер побачимо більш просунуті трансформації. Ось нова версія парсера для JSON об'єктів, що повертає Scala <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="c1">// Може бути покращене</span>
<span class="s">&quot;{&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;}&quot;</span> <span class="o">^^</span>
<span class="o">{</span> <span class="k">case</span> <span class="s">&quot;{&quot;</span><span class="o">~</span><span class="n">ms</span><span class="o">~</span><span class="s">&quot;}&quot;</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="n">ms</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Пам'ятайте, що оператор <code>~</code> продукує як результат примірник кейс класу з тим самим ім'ям: <code>~</code>. Ось визначення цього класу — це внутрішній клас трейту <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">~</span><span class="o">[</span><span class="kt">+A</span>, <span class="kt">+B</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&quot;~&quot;</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ім'я класу навмисно таке саме, що і ім'я метода комбінатора послідовності, <code>~</code>. Таким чином, ви можете порівнювати результати парсера з шаблонами, що слідують тій самій структурі , що і самі парсери. Наприклад, шаблон <code>"{"~ms~"}"</code> співпадає з рядком результату <code>"{"</code>, що яким слідує змінна результату <code>ms</code>, за яким в свою чергу іде рядок результата <code>"}"</code>. Цей шаблон відповідає в точності до того, що повертає парсер зліва від  <code>'^^'</code>. В своїй знецукреній версії, де оператор <code>~</code> іде першим, той самий шаблон читається як <code>~(~("{", ms), "}")</code>, але це значно менш приємно.</p></div>
<div class="paragraph"><p>Призначення шаблона <code>"{"~ms~"}"</code> є очистити дужки, так щоб ми могли отримати список членів, отриманих від парсера <code>repsep(member, ",")</code>. В випадках, як це, також є альтернатива, що цникає створення непотрібного результату парсера, що зразу відкидається порівнянням шаблонів. Альтернативи використовує комбінатори <code>~&gt;</code> та <code>&lt;~</code>. Обоє виражають послідовні композиції, як <code>~</code>, але <code>~&gt;</code> зберігає тільки результат правого операнду, тоді як <code>&lt;~</code> зберігає тільки результат свого лівого операнду. Використовуючи ці комбінатори парсер об'єктів JSON може бути використаний більш послідовно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
  <span class="s">&quot;{&quot;</span><span class="o">~&gt;</span> <span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)</span> <span class="o">&lt;~</span><span class="s">&quot;}&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.5 показує повний парсер JSON, що повертає осмислений результат. Якщо ви виконаєте цей парсер на файлі <code>address-book.json</code>, ви отримаєте наступний результат (після додавання деяких нових рядків та відступів):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">JSON1Test</span> <span class="n">address</span><span class="o">-</span><span class="n">book</span><span class="o">.</span><span class="n">json</span>
<span class="o">[</span><span class="err">14</span><span class="kt">.</span><span class="err">1</span><span class="o">]</span> <span class="n">parsed</span><span class="k">:</span> <span class="kt">Map</span><span class="o">(</span>
<span class="kt">address</span> <span class="kt">book</span> <span class="kt">-&gt;</span> <span class="kt">Map</span><span class="o">(</span>
<span class="kt">name</span> <span class="kt">-&gt;</span> <span class="kt">John</span> <span class="kt">Smith</span><span class="o">,</span>
<span class="kt">address</span> <span class="kt">-&gt;</span> <span class="kt">Map</span><span class="o">(</span>
<span class="kt">street</span> <span class="kt">-&gt;</span> <span class="err">10</span> <span class="kt">Market</span> <span class="kt">Street</span><span class="o">,</span>
<span class="kt">city</span> <span class="kt">-&gt;</span> <span class="kt">San</span> <span class="kt">Francisco</span><span class="o">,</span> <span class="kt">CA</span><span class="o">,</span>
<span class="n">zip</span> <span class="o">-&gt;</span> <span class="mi">94111</span><span class="o">),</span>
<span class="n">phone</span> <span class="n">numbers</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">408</span> <span class="mi">338</span><span class="o">-</span><span class="mi">4238</span><span class="o">,</span> <span class="mi">408</span> <span class="mi">111</span><span class="o">-</span><span class="mi">6892</span><span class="o">)</span>
<span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те що вам повинно знати для початку написання ваших власних парсерів. Як допомога в запам'ятовуванні, Таблиця 33.1 перелічує комбінатори парсерів, які ми нещодавно обговорювали.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>

<span class="k">class</span> <span class="nc">JSON1</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
    <span class="s">&quot;{&quot;</span><span class="o">~&gt;</span> <span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)</span> <span class="o">&lt;~</span><span class="s">&quot;}&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">arr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
    <span class="s">&quot;[&quot;</span><span class="o">~&gt;</span> <span class="n">repsep</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)</span> <span class="o">&lt;~</span><span class="s">&quot;]&quot;</span>

  <span class="k">def</span> <span class="n">member</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">stringLiteral</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">value</span> <span class="o">^^</span>
      <span class="o">{</span> <span class="k">case</span> <span class="n">name</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">value</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
    <span class="n">obj</span>
  <span class="o">|</span> <span class="n">arr</span>
  <span class="o">|</span> <span class="n">stringLiteral</span>
  <span class="o">|</span> <span class="n">floatingPointNumber</span> <span class="o">^^</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
  <span class="o">|</span> <span class="s">&quot;null&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">null</span><span class="o">)</span>
  <span class="o">|</span> <span class="s">&quot;true&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
  <span class="o">|</span> <span class="s">&quot;false&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.5 - Повний парсер JSON, що повертає осмислені результати.</p></div>
<div class="paragraph"><p>Таблиця 33.1 - Підсумок по парсерним комбінаторам</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">"&#8230;"</p></td>
<td align="left" valign="top"><p class="table">літерал</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">"&#8230;".r</p></td>
<td align="left" valign="top"><p class="table">регулярний вираз</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P~Q</p></td>
<td align="left" valign="top"><p class="table">послідовна композиція</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P &lt;<sub> Q, P </sub>&gt; Q</p></td>
<td align="left" valign="top"><p class="table">послідовна композиція, тільки вліво/вправо</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P | Q</p></td>
<td align="left" valign="top"><p class="table">альтернатива</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">opt(P)</p></td>
<td align="left" valign="top"><p class="table">опція</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">rep(P)</p></td>
<td align="left" valign="top"><p class="table">повторення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">repsep(P, Q)</p></td>
<td align="left" valign="top"><p class="table">переміжене повторення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P ^^</p></td>
<td align="left" valign="top"><p class="table">перетворення результату</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="______16">Вимкнення виводу крапки з комою</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зауважте, що тіло парсера значень в Лістингу 33.5 оточений в дужки. Це невеликий трюк, щоб дозволити вивід крапки з комою в виразах парсера. Ви бачили в Розділі 4.2, що Scala вважає присутність крапки з комою між любими двома рядками, що синтаксично можуть бути окремими твердженнями, за винятком коли перший рядок завершується на інфіксний оператор, або два рядка оточені в звичайні або прямокутні дужки. Тепер ви можете писати оператор <code>|</code> в кінці кожної альтернативи, замість початку наступного рядка, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">obj</span> <span class="o">|</span>
  <span class="n">arr</span> <span class="o">|</span>
  <span class="n">stringLiteral</span> <span class="o">|</span>
<span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку немає жодних дужок навколо тіла парсера значень, що могли бути потрібні. Однак деякі люди бажають бачити оператор <code>|</code> на початку другої альтернативи, ніж в кінці першої. Звичайно це призведе до небажаної крапки з комою між двома рядками, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="o">;</span>  <span class="c1">// крапка з комою вставлені явно</span>
<span class="o">|</span> <span class="n">arr</span>
</pre></div></div></div>
<div class="paragraph"><p>Крапка з комою змінили структуру коду, що призвело до збою компіляції. Покладаючи цілий вираз в дужки уникає крапок з комою, та робить компіляцію коду коректною.</p></div>
<div class="sect2">
<h3 id="______17">Символічні імена проти літено-цифрових</h3>
<div class="paragraph"><p>Багато з парсерних комбінатороів в Таблиці 33.1 використовують символічні імена. Це має одночасно переваги та недоліки. Один з мінусів є те, що символічні імена потребують час для вивчення. Користувачі, що незнайомі з бібліотекою парсерних комбінаторів Scala, можливо будуть містифіковані значенням <code>~</code>, <code>~&gt;</code> або <code>^^</code>. На боці плюсів - символічні імена короткі, та можуть бути обрані, щоб мати "правильні" преоритети та асоціативність. Наприклад, парсерні комбінатори <code>~</code>, <code>^^</code> та <code>|</code> обрані навмисне в зростаючому порядку преоритетів. Типова граматична продукція скомпонована з альтернатив, що мають частину парсингу, та частину трансформації. Частина парсингу типово містить декілька послідовних елементів, розділених операторами <code>~</code>. З обраними преоритетами для <code>~</code>, <code>^^</code> та <code>|</code> ви можете написати таку граматичну продукцію без потреби в дужках.</p></div>
<div class="paragraph"><p>Більше того, символічні оператори займають меньше візуальної нерухомості, ніж літерні. Це важливо для парсерів, оскільки це дозволяє вам концентруватись на граматиці, замість самих комбінаторів. Щоб побачити різницю, уявімо на момент, що послідовна композиція (<code>~</code>) мала б назву <code>andThen</code>, та альтернатива (<code>|</code>) мала б назву <code>orElse</code>. Парсери арифметичних виразів в Лістингу 33.1 виглядали б наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArithHypothetical</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>  <span class="k">=</span>
    <span class="n">term</span> <span class="n">andThen</span> <span class="n">rep</span><span class="o">((</span><span class="s">&quot;+&quot;</span> <span class="n">andThen</span> <span class="n">term</span><span class="o">)</span> <span class="n">orElse</span>
                     <span class="o">(</span><span class="s">&quot;-&quot;</span> <span class="n">andThen</span> <span class="n">term</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">factor</span> <span class="n">andThen</span> <span class="n">rep</span><span class="o">((</span><span class="s">&quot;*&quot;</span> <span class="n">andThen</span> <span class="n">factor</span><span class="o">)</span> <span class="n">orElse</span>
                       <span class="o">(</span><span class="s">&quot;/&quot;</span> <span class="n">andThen</span> <span class="n">factor</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">floatingPointNumber</span> <span class="n">orElse</span>
      <span class="o">(</span><span class="s">&quot;(&quot;</span> <span class="n">andThen</span> <span class="n">expr</span> <span class="n">andThen</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви помітили, що цей код став значно більш довшим, і що стало складно "побачити" граматику між всіма ціма операторами та дужками. З іншого боку, дехто новий до комбінаторного парсингу можливо зможе краще зрозуміти, яке призначення має цей код.</p></div>
</div>
<div class="sect2">
<h3 id="_______">Вибір між символічними та літерно-цифровими іменами</h3>
<div class="paragraph"><p>Як настанова для вибору між символічними та літерними іменами ми рекомендуємо наступне:</p></div>
<div class="ulist"><ul>
<li>
<p>
Використовуйте символічні імена в випадках, коли воні вже мають універсально встановлене значення. Наприклад, ніхто не буде рекомендувати писати <code>add</code> замість <code>+</code> для числового додавання.
</p>
</li>
<li>
<p>
В іншому випадку надайте перевагу літерним іменам, якщо ви бажаєте зробити ваш код розумілим для випадкових читачів.
</p>
</li>
<li>
<p>
Ви все ще можете обрати символічні імена для домен-специфічних бібліотек, якщо це дає ясні переваги в розумінні, та ви в жодному разі не очікуєте випадкових читачів без надійного підгрунтя в предметі, щоб вони безпосередньо розуміли код.
</p>
</li>
</ul></div>
<div class="paragraph"><p>В випадку парсерних комбінаторів ми дивимось на дуже високо-домен-специфічну мову, що випадкові читачі можуть мати проблеми з розумінням, навіть для літерних імен. Більше того, символічні імена дають ясну перевагу в виразності для експерта. Так що ми віримо, що їх застосування обгрунтоване в цьому застосуванні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_33_6___">33.6 Реалізація парсерів комбінаторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередні розділи показали, що комбінаторні парсери Scala провадять зручні способи для конструювання ваших власних парсерів. Оскільки вони ніщо інше, ніж Scala бібліотека, вони без проблем пасують до ваших Scala програм. Так що це дуже просто скомбінувати парсер з деяким кодом, що обробляє отримані результати, або зачепити парсер так, щоб він отримував свій вхід з певного джерела (скажімо, файла, рядка або масива символів).</p></div>
<div class="paragraph"><p>Як це досягається? В решті цієї глави ви поглянете "за лаштунки" бібліотеки комбінаторного парсера. Ви побачите що таке є парсер, та як примітивні парсери та як реалізовані парсерні комбінатори, перелічені в попередніх розділах. Ви можете безпечно пропустити ці частини, якщо все, що ви хочете, це написати деякі прості комбінаторні парсери. З іншого боку, читання решти цієї глави може дати вам глибше розуміння комбінаторних парсерів зокрема, та принципів розробки комбінаторної домен-специфічної мови загалом.</p></div>
<div class="paragraph"><p>Ядро фреймворку комбінаторних парсерів міститься в трейті <code>scala.util.parsing.combinator.Parsers</code>. Цей трейт визначає тип <code>Parser</code>, так само, як всі фундаментальні комбінатори. Окрім випадків, коли явно вказано інше, визначення, пояснені в настурних двох розділах, містяться в цьому трейті. Тобто  очікується, що вони містяться в визначенні трейта, що починається таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.util.parsing.combinator</span>

<span class="k">trait</span> <span class="nc">Parsers</span> <span class="o">{</span>
<span class="o">...</span> <span class="c1">// код іде тут, якщо не вказане інше</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Parser</code> в основі є лише функцією від якогось типу до результату розбору. Як перше наближення тип може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="___67">Вхід парсера</h3>
<div class="paragraph"><p>Іноді парсер читає потік токенів замість сирої послідовності символів. Потім використовується окремий лексичний аналізатор для перетворення потоку символів на потік токенів. Тип парсерних входів визначається таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Input</span> <span class="o">=</span> <span class="nc">Reader</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас <code>Reader</code> походить з пакунка <code>scala.util.parsing.input</code>. Це подібно до <code>Stream</code>, але також відстежує позицію всіх елементів, що читає. Тип <code>Elem</code> представляє індивідуальні вхідні елементи. Це абстрактний член <code>type</code> трейта <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Elem</span>
</pre></div></div></div>
<div class="paragraph"><p>Це означає, що субкласи та субтрейти <code>Parsers</code> мають створити примірник класу <code>Elem</code> як тип вхідних елементів, що будуть розбиратись. Наприклад, <code>RegexParsers</code> та <code>JavaTokenParsers</code> фіксують <code>Elem</code> еквівалентним до <code>Char</code>. Але також можливо встановити <code>Elem</code> в якійсь інший тип, такий як тип токена, що повертається з окремого лексера.</p></div>
</div>
<div class="sect2">
<h3 id="___68">Результати парсера</h3>
<div class="paragraph"><p>Парсер може або завершитись успішно, або схибити для деякого даного вхідного потоку. Відповідно клас <code>ParseResult</code> має два субкласа для представлення успіху та неуспіху:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">result</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Випадок <code>Success</code> несе результат, повернутий з парсера в своєму параметрі <code>result</code>. Тип результату парсера довільний; ось чому <code>ParseResult</code>, <code>Success</code> та <code>Parser</code> всі параметризовані параметром типу <code>T</code>. Параметр типу представляє різновид результатів, що повертається даним парсером. <code>Success</code> також приймає другий параметр, <code>in</code>, що посилається на вхід безпосередньо за частиною, що була спожита парсером. Це поле потрібне для зціплених парсерів, так що один парсер може оперувати після іншого. Зауважте, що це чисто функціональний підхід до парсингу. Вхід не читається як побічний ефект, але зберігається як потік. Парсер аналізує деяку частину вхідного потоку, та потім повертає залишкову частину в своєму результаті.</p></div>
<div class="paragraph"><p>Інший субклас <code>ParseResult</code> є <code>Failure</code>. Цей клас приймає як параметр повідомлення, що описує, чому парсер схибив. Як і <code>Success</code>, <code>Failure</code> також приймає залишок вхідного потоку як другий параметр. Це потрібно не для зціплення (парсер не може продовжуватись після збою), але для вказання повідомленню про помилку коректне місце у вхідному потоці.</p></div>
<div class="paragraph"><p>Зауважте, що результати парсера визначені коваріантними по параметру типа <code>T</code>. Тобто, скажімо, парсер, що повертає <code>String</code> як результат, сумісний з парсером, що повертає <code>AnyRef</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__code_parser_code">Клас <code>Parser</code></h3>
<div class="paragraph"><p>Попередня характеристика парсерів як функцій від вхідного потоку до результатів розбору була надспрощена. Попередні приклади показали, що парсери також реалізують методи, такі як <code>~</code>, для послідовної композиції двох парсерів, та <code>|</code> для їх альтернативної композиції. Та що в реальності <code>Parseris</code> є клас, що наслідує від функціонального типу <code>Input =&gt; ParseResult[T]</code>, та додатково  визначає ці методи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
<span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
  <span class="c1">// Невказаний метод, що визначає поведінку парсера.</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="o">~</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">|</span> <span class="o">...</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки парсери є (тобто наслідують від) функціями, вони мають визначати метод <code>apply</code>. Ви бачите абстрактний метод <code>apply</code> в класі <code>Parser</code>, але це тільки для документації, бо  такий самий метод в кожному випадку наслідується від батьківського типу <code>Input =&gt; ParseResult[T]</code> (згадайте, що цей тип є скороченням для <code>scala.Function1[Input, ParseResult[T]]</code>). Метод <code>apply</code> все ще має бути реалізований в індивідуальних парсерах, що наслідують від абстрактного класу <code>Parser</code>. Ці парсери будуть обговорюватись після наступного розділу, де розглядатимуться псевдоніми <code>this</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_this_code">Псевдоним для <code>this</code></h3>
<div class="paragraph"><p>Тіло класу <code>Parser</code> починається з цікавого виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">...</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Таке твердження як <code>id =&gt;</code> безпосередньо після відкриваючої дужки шаблону класа  визначає ідентифікатор <code>id</code> як псевдонім для <code>this</code> в класі. Це те саме, якщо б ви написали:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>в тілі класу, за тим винятком, що компілятор Scala знає, що <code>id</code> є псевдонім для <code>this</code>. Наприклад, ви можете отримати доступ до об'єкт-приватного члена <code>m</code> класу з використанням або <code>id.m</code> або <code>this.m</code>; ці два вирази повністю еквівалентні. Перший вираз не буде компілюватись, якщо <code>id</code> був просто визначений як <code>val</code> з <code>this</code> в якості правої сторони, оскільки в уьому випадку компілятор Scala буде трактувати <code>id</code> як звичайний ідентифікатор.</p></div>
<div class="paragraph"><p>Ви бачили синтаксис, як цей, в Розділі 29.4, де він використовувся для отримання типу <code>self</code> для трейту. Псевдоніми можуть бути також гарним скороченням, коли вам треба отримати доступ до <code>this</code> зовнішнього класу. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span> <span class="n">outer</span> <span class="k">=&gt;</span>
  <span class="k">class</span> <span class="nc">Inner</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="nc">Outer</span><span class="o">.</span><span class="k">this</span> <span class="n">eq</span> <span class="n">outer</span><span class="o">)</span> <span class="c1">// друкує: true</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад визначає два вкладені класи, <code>Outer</code> та <code>Inner</code>. Всередині <code>Inner</code> на значення <code>this</code> класу <code>Outer</code> посилаються два рази, використовуючи різні вирази. Перший вираз показує Java спосіб робити речі: ви можете поставити префікс перез зарезервованим словом  <code>this</code> з ім'ям зовнішнього класу через крапку; такий вираз потім посилається на <code>this</code> зовнішнього класу. Другий вираз показує альтернативу, яку вам дає Scala. Через введення псевдоніма на ім'я <code>outer</code> для <code>this</code> в класі <code>Outer</code>, ви можете посилатись на псевдоним <code>this</code> напряму, також і у внутрішньому класі. Спосіб Scala більш стислий, та також може покращити ясність, якщо ви оберете гарне ім'я для псевдоніма. Ви побачите приклади цього там і тут.</p></div>
</div>
<div class="sect2">
<h3 id="____38">Одно-токенові парсери</h3>
<div class="paragraph"><p>Трейт <code>Parsers</code> визначає загальний <code>elem</code> парсера, що може бути використаний для розбору любого окремого токену:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">kind</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">first</span><span class="o">))</span> <span class="nc">Success</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">first</span><span class="o">,</span> <span class="n">in</span><span class="o">.</span><span class="n">rest</span><span class="o">)</span>
      <span class="k">else</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">kind</span> <span class="o">+</span> <span class="s">&quot; expected&quot;</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей парсер приймає два елементи: рядок <code>kind</code>, що описує різновид токена, що має бути розібраний, та предикат <code>p</code> на <code>Elem</code>, що вказує, чи елемент пасує до класу токенів, що розбираються.</p></div>
<div class="paragraph"><p>Коли застосовується парсер <code>elem(kind, p)</code> до деякого входу <code>in</code>, перший елемент вхідного потоку перевіряється предикатом <code>p</code>. Якщо він <code>true</code>, парсер успішний. Його результат є сам елемент, та його залишковий вхід є вхідний потік, що починається зразу за елементом, що був розібраний. З іншого боку, якщо <code>p</code> повертає <code>false</code>, парсер схибить з повідомленням про помилку, що буде вказувати, на який тип токена він очікував.</p></div>
</div>
<div class="sect2">
<h3 id="___69">Послідовна композиція</h3>
<div class="paragraph"><p>Парсер <code>elem</code> споживає тільки один елемент. Щоб розібрати більш цікаві фрази, ви можете сціпити парсери разом з допомогою оператора послідовної композиції, <code>~</code>. Як ви бачили до цього, <code>P~Q</code> є парсер, що спочатку застосовує парсера <code>P</code> до даного вхідного рядка. Потім, якщо <code>P</code> успішний, застосовується парсер <code>Q</code> до входу, що залишився коли парсер <code>P</code> зробив свою роботу.</p></div>
<div class="paragraph"><p>Комбінатор <code>~</code> реалізований як метод класу <code>Parser</code>. Його визначення показано на Лістингу 33.6. Метод є членом класу <code>Parser</code>. Всередині цього класу <code>p</code> вказане через <code>p =&gt;</code> як псевдонім до <code>this</code>, так що <code>p</code> позначає лівий операнд (або отримувач) <code>~</code>. Його правий операнд представлений як параметр <code>q</code>. Тепер, якщо виконати <code>p~q</code> на деякому вході <code>in</code>, перший <code>p</code> виконається на <code>in</code>, і результат буде проаналізований в порівнянні шаблоінв. Якщо <code>p</code> успішний, <code>q</code> виконується на залишку входу <code>in1</code>. Якщо <code>q</code> також успішний, парсер повністю успішний. Його результатом є об'єкт <code>~</code>, що містить обоє результата, результат <code>p</code> (тобто, <code>x</code>), та результат <code>q</code> (тобто, <code>y</code>). З іншого боку, якщо або <code>p</code> або <code>q</code> схибить, результатом <code>p~q</code> буде об'єкт <code>Failure</code>, що пертає <code>p</code> або <code>q</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="err">...</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="o">~</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T~U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">q</span><span class="o">(</span><span class="n">in1</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">in2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="k">new</span> <span class="o">~(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">in2</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.6 - Метод комбінатор <code>~</code>.</p></div>
<div class="paragraph"><p>Результуючий тип <code>~</code> є парсер, що повертає примірник клейс класу <code>~</code> з елементами типів <code>T</code> та <code>U</code>. Тип виразу <code>T~U</code> є просто більш виразне скорочення для параметризованого типу <code>~[T, U]</code>. Загалом, Scala завжди інтерпретує двомісні операції типів, <code>A op B</code>, як параметризований тип <code>op[A, B]</code>. Це аналогічно до ситуації для шаблонів, коли двомісний шаблон <code>P op Q</code> також інтерпретується як застосування, тобто <code>op(P, Q)</code>.</p></div>
<div class="paragraph"><p>Інші два оператора послідовної композиції, <code>&lt;~</code> та <code>~&gt;</code>, можуть бути визначені як <code>~</code>, тільки з невеликим уточненням того, як обчислюється результат. Більш елегантний прийом, однак, є визначити їх в термінах <code>~</code>, наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">&lt;~</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">p</span><span class="o">~</span><span class="n">q</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span><span class="o">~</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span>

<span class="k">def</span> <span class="o">~&gt;</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">p</span><span class="o">~</span><span class="n">q</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span><span class="o">~</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___70">Композиція альтернативи</h3>
<div class="paragraph"><p>Альернативна композиція <code>P | Q</code> стосується або <code>P</code> або <code>Q</code> для наданого входу. Першим перевіряється <code>P</code>. Якщо <code>P</code> успішний, весь парсер успішний з результатом <code>P</code>. Інакше, якщо <code>P</code> схибив, тоді спробується <code>Q</code> на тому самому вході, що і <code>P</code>. Результат <code>Q</code> буде результатом всього парсера. Ось визначення <code>|</code> як методу класа <code>Parser</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">|</span> <span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s1</span> <span class="k">@</span> <span class="nc">Success</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s1</span>
    <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">q</span><span class="o">(</span><span class="n">in</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо <code>P</code> та <code>Q</code> обоє невдалі, тоді повідомлення про невдачу визначається <code>Q</code>. Цей тонкий вибір обговорюється пізніше, в Розділі 33.9.</p></div>
</div>
<div class="sect2">
<h3 id="____39">Справи з рекурсією</h3>
<div class="paragraph"><p>Зауважте, що параметр <code>q</code> в методах <code>~</code> та <code>|</code> ідуть за ім'ям — перед їх типом стоїть <code>=&gt;</code>. Це означає, що справжній аргумент парсера буде обчислено тільки поли <code>q</code> буде потрібний, що буде лише в випадку після виконання <code>p</code>. Це робить можливим написання рекурсивних парсерів, як наступний, що розбирає число, оточене довільною кількістю дужок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">parens</span> <span class="k">=</span> <span class="n">floatingPointNumber</span> <span class="o">|</span> <span class="s">&quot;(&quot;</span><span class="o">~</span><span class="n">parens</span><span class="o">~</span><span class="s">&quot;)&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо б <code>|</code> та <code>~</code> сприймали параметри за значенням, це визначення безпосередньо би спричинило переповнення стеку без читання будь-чого, оскільки значення <code>parens</code> з'являється посередині правої сторони.</p></div>
</div>
<div class="sect2">
<h3 id="___71">Перетворення результату</h3>
<div class="paragraph"><p>Останній метод класу <code>Parser</code> конвертує результат парсера. Парсер <code>P ^^ f</code> успішний саме тоді, коли успішний P. В цьому випадку він повертає результат <code>P</code>, конвертований з використанням функції <code>f</code>. Ось реалізація цього метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">^^</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">in1</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">}</span> <span class="c1">// кінець ParserParsers, що не читає жодного входу</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є два парсери, що не споживають вхідний потік: <code>success</code> та <code>failure</code>. Парсер <code>success(result)</code> завжди успішний з наданим результатом. Парсер <code>failure(msg)</code> завжди невдалий з повідомленням про помилку <code>msg</code>. Обоє реалізовані як методи трейта <code>Parsers</code>, зовнішнього трейта, що також містить клас <code>Parser</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Success</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____40">Опція та повтор</h3>
<div class="paragraph"><p>Так само визначені в трейті <code>Parsers</code> є комбінатори опції та повтору: <code>opt</code>, <code>rep</code> та <code>repsep</code>. Вони всі реалізовані в термінах послідовної композиції, альтернативи та перетворення результату:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">opt</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">(</span>
  <span class="n">p</span> <span class="o">^^</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>
  <span class="o">|</span> <span class="n">success</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">def</span> <span class="n">rep</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">(</span>
  <span class="n">p</span><span class="o">~</span><span class="n">rep</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span><span class="o">~</span><span class="n">xs</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">}</span>
  <span class="o">|</span> <span class="n">success</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="o">)</span>

<span class="k">def</span> <span class="n">repsep</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">(</span>
  <span class="n">p</span><span class="o">~</span><span class="n">rep</span><span class="o">(</span><span class="n">q</span><span class="o">~&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">r</span><span class="o">~</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">::</span> <span class="n">rs</span> <span class="o">}</span>
  <span class="o">|</span> <span class="n">success</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="o">)</span>

<span class="o">}</span> <span class="c1">// кінець Parsers</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_33_7_____">33.7 Рядкові літерали та регулярні вирази</h2>
<div class="sectionbody">
<div class="paragraph"><p>Парсери, що ви бачили до цього, використовують рядкові літерали та регулярні вирази щоб розбирати окремі слова. Підтримка для цього надходить від <code>RegexParsers</code>, субтрейта <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">RegexParsers</span> <span class="k">extends</span> <span class="nc">Parsers</span> <span class="o">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей трейт більш спеціалізований, ніж трейт <code>Parsers</code> в тому, що він робить тільки з входом, що є послідовністю символів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="nc">Char</span>
</pre></div></div></div>
<div class="paragraph"><p>Він визначає два методи, <code>literal</code> та <code>regex</code>, з наступними сигнатурами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">literal</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">regex</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Regex</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що обоє методи мають модифікатор <code>implicit</code>, так що вони автоматично застосовуються кожного разу, коли надається <code>String</code> або <code>Regex</code>, але очікується <code>Parser</code>. Ось чому ви можете писати рядкові літерали та регулярні вирази прямо в граматиці, без потреби огортати їх в один з ціх методів. Наприклад, парсер <code>"("~expr~")"</code> буде автоматично розширений до літерала <code>literal("(")~expr~literal(")")</code>.</p></div>
<div class="paragraph"><p>Трейт <code>RegexParsers</code> також приймає обробку проміжків між символами. Щоб зробити це, він викликає метод на ім'я <code>handleWhiteSpace</code> перед виконанням парсера <code>literal</code> або <code>regex</code>. Метод <code>handleWhiteSpace</code>  про пропускає найбільшу вхідну послідовність, що відповідає до регулярному виразу <code>whiteSpace</code>, що визначений по замовчанню таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">protected</span> <span class="k">val</span> <span class="n">whiteSpace</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;\s+&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="o">}</span> <span class="c1">// кінець RegexParsers</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте іншу трактовку проміжків, ви можете перевизначити <code>val whiteSpace</code>. Наприклад, якщо ви бажаєте, щоб проміжки взагалі не пропускались, ви можете перекрити <code>whiteSpace</code> порожнім регулярним виразом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyParsers</span> <span class="k">extends</span> <span class="nc">RegexParsers</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">whiteSpace</span> <span class="k">=</span> <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_8___">33.8 Лексінг та парсинг</h2>
<div class="sectionbody">
<div class="paragraph"><p>Завдання синтаксичного аналізу часто розділяється на дві фази. Фаза лексера розпізнає окремі слова на вході, та класифікує їх в деякі класи токенів. Ця фаза також називається лексичним аналізом. За цім слідує фаза синтаксичного аналізу, що аналізує послідовності токенів. Синтаксичний аналіз також індоі називають парсингом, навіть хоча це не дуже точно, оскільки лексичний аналіз також можна віднести до проблеми розбору.</p></div>
<div class="paragraph"><p>Трейт <code>Parsers</code>, описаний в попередньому розділі, може бути задіяний на любій фазі, оскільки його вхідні елементи мають абстрактний тип <code>Elem</code>. Для лексичних аналізаторів <code>Elem</code> може бути втілений як <code>Char</code>, що означає, що будуть розібрані окремі символи, що складають слово. Синтаксичний аналізатор, в свою чергу, втілює <code>Elem</code> як тип токена, що повертає лексер.</p></div>
<div class="paragraph"><p>Парсерні комбінатори Scala провадять декілька допоміжних класів для лексичного та синтаксичного аналізу. Вони містяться в двох субпакунках, по одному для кожного різновиду аналізу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">parsing</span><span class="o">.</span><span class="n">combinator</span><span class="o">.</span><span class="n">lexical</span>
<span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">parsing</span><span class="o">.</span><span class="n">combinator</span><span class="o">.</span><span class="n">syntactical</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте розділити ваш парсер на окремі лексер та синтаксичний аналізатор, ви повинні подивитись Scaladoc документацію щодо ціх пакунків. Але для простих парсерів підхід на основі регулярних виразів, показаний перед цім в цій главі, зазвичай є достатнім.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_9___">33.9 Повідомлення про помилки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Існує одна фінальна тема, що досі не розкрита: як парсер видає повідомлення про помилки? Повідомлення помилок для парсерів є дещо темним мистецтвом. Одна проблема в тому, що коли парсер відхиляє деякий вхід, він загалом має налічувати декільки багато різних помилок. Кожний альтернативний <code>parse</code> має схибити, і все це рекурсивно в кожній точці вибору. Який, зі звичайно численних збоїв, повинен бути виданий як повідомлення помилки користувачеві?</p></div>
<div class="paragraph"><p>Бібліотека парсингу Scala реалізує просту евристику: серед всіх невдач обирається та, що трапилась в останній позиції вводу. Іншими словами, парсер обирає найдовший префікс, що все ще валідний, та видає повідомлення помилки, що описує, чому розбір префіксу не може бути продовжений далі. Якщо декілька точок відмови вказують на ту саму позицію, обирається та, що була оброблена останньою. Наприклад, розглянемо виконання JSON парсера на помилковій адресній книзі, що починається з рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="err">John</span><span class="p">,</span>
</pre></div></div></div>
<div class="paragraph"><p>Найдовший легальний префікс для цієї фрази є <code>{ "name": `. Так що JSON буде відмічати слово `John</code> як помилку. Парсер JSON очікує значення в цій точці, але <code>John</code> є ідентифікатором, що не вважається за значення (скоріше всього автор документу забув оточити ім'я в лапки). Повідомлення про помилку, що видає парсер для цього документу буде:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">1.13</span><span class="p">]</span> <span class="err">failure:</span> <span class="s2">&quot;false&quot;</span> <span class="err">expected</span> <span class="err">but</span> <span class="err">identifier</span> <span class="err">John</span> <span class="err">found</span>
<span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="err">John</span><span class="p">,</span>
          <span class="err">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Частина про те, що очіаувалось <code>false</code> походить від факту, що <code>false</code> є останньою альтернативою продукції для значення в JSON граматиці. Так що це була остання невдача в цій точці. Користувачі, що знають JSON граматику в деталях, можуть реконструювати повідомлення помилки, але для неекспертів ця помилка, можливо, дивна, і також може бути оманливою. Краще повідомлення про помилку може бути сконструйоване через додавання точки збою "на всі випадки", як останньої альтернативи продукції значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">obj</span> <span class="o">|</span> <span class="n">arr</span> <span class="o">|</span> <span class="n">stringLit</span> <span class="o">|</span> <span class="n">floatingPointNumber</span> <span class="o">|</span> <span class="s">&quot;null&quot;</span> <span class="o">|</span>
  <span class="s">&quot;true&quot;</span> <span class="o">|</span> <span class="s">&quot;false&quot;</span> <span class="o">|</span> <span class="n">failure</span><span class="o">(</span><span class="s">&quot;illegal start of value&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це додавання не змінює набір входів, що приймаються як валідні документи. Що це робить, це покращує повідомлення про помилку, оскільки тепер явно доданий збій, що іде як остання альтернатива, і таким чином буде повідомлення від нього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">1.13</span><span class="p">]</span> <span class="err">failure:</span> <span class="err">illegal</span> <span class="err">start</span> <span class="err">of</span> <span class="err">value</span>
<span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="err">John</span><span class="p">,</span>
          <span class="err">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація схеми "останньої можливої" помилки використовує поле на ім'я <code>lastFailure</code> в трейті <code>Parsers</code>, щоб відмічати збій, що трапився в останній позиції входу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">lastFailure</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Failure</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Поле ініціалізоване як <code>None</code>. Воно оновлюється в конструкторі класу <code>Failure</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">lastFailure</span><span class="o">.</span><span class="n">isDefined</span> <span class="o">&amp;&amp;</span>
        <span class="n">lastFailure</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">in</span><span class="o">.</span><span class="n">pos</span><span class="o">)</span>
    <span class="n">lastFailure</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Поле читається методом <code>phrase</code>, що видає фінальну помилку, якщо парсер схибить. Ось реалізація <code>phrase</code> в трейті <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">phrase</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">lastFailure</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">Success</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">in1</span><span class="o">.</span><span class="n">atEnd</span><span class="o">)</span> <span class="n">s</span>
      <span class="k">else</span> <span class="nc">Failure</span><span class="o">(</span><span class="s">&quot;end of input expected&quot;</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">f</span> <span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span>
      <span class="n">lastFailure</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>phrase</code> виконує свій аргумент, парсер <code>p</code>. Якщо <code>p</code> успішний з повністю спожитим вводом, повертається успішний результат <code>p</code>. Якщо <code>p</code> успішний, але вхід не прочитаний повністю, повертається збій з повідомленням "end of input expected". Якщо <code>p</code> схибить, повертається збій або помилка, що зберігається в <code>lastFailure</code>. Зауважте, що трактування <code>lastFailure</code> нефункціональне; воно оновлюється як побічний ефект конструктором <code>Failure</code> та самим методом <code>phrase</code>. Функціональна версія в тій самій схемі можлива, але це потребуватиме трактування значення <code>lastFailure</code> через кожний результат парсера, неважливо, був це <code>Success</code> або <code>Failure</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_10___ll_1">33.10 Бектрекінг проти LL(1)</h2>
<div class="sectionbody">
<div class="paragraph"><p>Парсерні комбінатори задіють бектрекінг для вибору між різними парсерами в альтернативі. В виразі <code>P | Q</code>, якщо <code>P</code> схибить, буде виконуватись <code>Q</code> на тому ж вводі, що і <code>P</code>. Це трапляється навіть якщо <code>P</code> розібрав деякі токени перед тим як схибити. В цьому випадку деякі токени були розібрані знову <code>Q</code>. Бектрекінг накладає тільки декілька обмежень на те, як фурмулювати граматику, так що це може бути розібрано. В основному вам просто треба уникати ліво-рекурсивних продукцій. Продукція, така як:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expr ::= expr "+" term | term.</code></pre>
</div></div>
<div class="paragraph"><p>буде завжди хибити, оскільки <code>expr</code> безпосередньо викликає себе, і таким чином ніколи не просувається далі.<span class="footnote"><br />[Існують способи уникнути переповнення стеку, навіть за наявності лівої рекурсії, але це потребує більш чистого фреймворку парсерних комбінаторів, який наразі не був реалізований.]<br /></span> З іншого боку, бектрекінг потенційно коштовний, оскільки той самий ввод може бути розібраний декілька раз. Розглянемо примірник продукції:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expr ::= term "+" expr | term.</code></pre>
</div></div>
<div class="paragraph"><p>Що трапится, якщо парсер <code>expr</code> застосується до вводу, такому як <code>(1 + 2) * 3</code>, що складає легальний <code>term</code>? Буде спробувана перша альтернатива, та схибить, коли порівняється зі знаком <code>+</code>. Потім буде спробувана друга альтернатива з тим самим термом, і вона буде успішною. В результаті терм буде розібраний двічі.</p></div>
<div class="paragraph"><p>Часто можливо так модифікувати граматику, так щоб уникнути бектрекінгу. Наприклад, в випадку арифметичних виразів, люба з наступних продукцій має працювати:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expr ::= term ["+" expr].
expr ::= term \{"+" term\}.</code></pre>
</div></div>
<div class="paragraph"><p>Багто мов приймають так звані <code>LL(1)</code> граматики.<span class="footnote"><br />[Aho, et. al., Compilers: Principles, Techniques, and Tools. [Aho86]]<br /></span> Коли комбінаторний парсер сформований з такої граматики, він ніколи не буде виконувати бектрекінг, тобто позиція ніколи не буде скидатись в попереднє значення. Наприклад, граматики для арифметичних виразів та JSON термінів раніше в цій главі обоє є <code>LL(1)</code>, так що здібності бектрекінга фреймворка комбінаторних парсерів ніколи не задіються для входів з ціх мов.</p></div>
<div class="paragraph"><p>Комбінаторний парсерний фреймворк дозволяє вам виражати очікування, що граматика є <code>LL(1)</code> явно, використовуючи новий оператор <code>~!</code>. Цей оператор подібний до послідовної композиції <code>~</code>, але він ніколи не буде робити бектрекінг для "від-читування" вхідних елементів, що вже були розібрані. Використовуючи цей оператор, продукція в парсері арифметичних виразів може альтернативно бути записана таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">expr</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">term</span> <span class="o">~!</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;+&quot;</span> <span class="o">~!</span> <span class="n">term</span> <span class="o">|</span> <span class="s">&quot;-&quot;</span> <span class="o">~!</span> <span class="n">term</span><span class="o">)</span>

<span class="k">def</span> <span class="n">term</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">factor</span> <span class="o">~!</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;*&quot;</span> <span class="o">~!</span> <span class="n">factor</span> <span class="o">|</span> <span class="s">&quot;/&quot;</span> <span class="o">~!</span> <span class="n">factor</span><span class="o">)</span>

<span class="k">def</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="s">&quot;(&quot;</span> <span class="o">~!</span> <span class="n">expr</span> <span class="o">~!</span> <span class="s">&quot;)&quot;</span> <span class="o">|</span> <span class="n">floatingPointNumber</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з переваг <code>LL(1)</code> парсера є те, що він використовує простішую техніку ввода. Ввод може бути прочитаний послідовно, та вхідні елементи можуть бути описані як тільки вони прочитані. Це інша причина, чому <code>LL(1)</code> парсери зазвичай більш ефективні, ніж бектрекінг парсери.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_11_">33.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили всі головні елементи фреймворку комбінаторного парсінгу Scala. Це напрочуд малий код для чогось, що напрочуд корисне. З цім фреймворком ви можете сконструювати парсери для широкого класу контекст-вільних граматик. Фреймворк дозволяє вам розпочати дуже швидко, але він також дуже налаштовуваний на нові типи граматик та метоідв вводу. Будучи бібліотекою Scala, він легко інтегрується з залишком мови. Так що просто інтегрувати комбінаторний парсер в більшу Scala програму.</p></div>
<div class="paragraph"><p>Один з недоліків комбінаторних парсерів в тому, що вони не дуже ефективні, щонайменьше коли порівнювати з парсерами, згенерованими від інструментів спеціального призначенням,  таких як Yacc або Bison. Для цього є дві причини. Перше, метод бектрекінга, використаний для комбінаторного парсингу, сам по собі не дуже ефективний. В залежності від граматики та входу парсингу, він може видати експоненціальне уповільнення через повторюваний бектракінг. Це може бути полагоджене через роблення граматики <code>LL(1)</code>, та використання підтвердженної послідовної композиції, оператора <code>~!</code>.</p></div>
<div class="paragraph"><p>Друга проблема, що впливає на продуктивність комбінаторних парсерів є те, що вони міксують парсерні конструкції та аналіз входу в тій самій множині операцій. Фактично, парсер гененується поновому для кожного входа, що розбирається.</p></div>
<div class="paragraph"><p>This problem can be overcome, but it requires a different implementation of the parser combinator framework. In an optimizing framework, a parser would no longer be represented as a function from inputs to parse results. Instead, it would be represented as a tree, where every construction step was represented as a case class. For instance, sequential composition could be represented by a case class Seq, alternative by Alt, and so on. The "outermost" parser method, phrase, could then take this symbolic representation of a parser and convert it to highly efficient parsing tables, using standard parser generator algorithms.</p></div>
<div class="paragraph"><p>What&#8217;s nice about all this is that from a user perspective nothing changes compared to plain combinator parsers. Users still write parsers in terms of ident, floatingPointNumber, ~, |, and so on. They need not be aware that these methods generate a symbolic representation of a parser instead of a parser function. Since the phrase combinator converts these representations into real parsers, everything works as before.</p></div>
<div class="paragraph"><p>The advantage of this scheme with respect to performance is two-fold. First, you can now factor out parser construction from input analysis. If you were to write:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">jsonParser</span> <span class="k">=</span> <span class="n">phrase</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>and then apply jsonParser to several different inputs, the jsonParser would be constructed only once, not every time an input is read.</p></div>
<div class="paragraph"><p>Second, the parser generation can use efficient parsing algorithms such as LALR(1).<span class="footnote"><br />[Aho, et. al., Compilers: Principles, Techniques, and Tools. [Aho86]]<br /></span> These algorithms usually lead to much faster parsers than parsers that operate with backtracking.</p></div>
<div class="paragraph"><p>At present, such an optimizing parser generator has not yet been written for Scala. But it would be perfectly possible to do so. If someone contributes such a generator, it will be easy to integrate into the standard Scala library. Even postulating that such a generator will exist at some point in the future, however, there are reasons for keeping the current parser combinator framework around. It is much easier to understand and to adapt than a parser generator, and the difference in speed would often not matter in practice, unless you want to parse very large inputs.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__34_2">Глава 34</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____41">Програмування користувацького інтерфейсу</h1>
<div class="paragraph"><p>In this chapter you&#8217;ll learn how to develop in Scala applications that use a graphical user interface
(GUI). The applications we&#8217;ll develop are based on a Scala library that provides access to Java&#8217;s Swing
framework of GUI classes. Conceptually, the Scala library resembles the underlying Swing classes, but
hides much of their complexity. You&#8217;ll find out that developing GUI applications using the framework
is actually quite easy.
Even with Scala&#8217;s simplifications, a framework like Swing is quite rich, with many different classes and
many methods in each class. To find your way in such a rich library, it helps to use an IDE such as
Scala&#8217;s Eclipse plugin. The advantage is that the IDE can show you interactively with its command
completion which classes are available in a package and which methods are available for objects you
reference. This speeds up your learning considerably when you first explore an unknown library space.
Figure 34.1 - A simple Swing application: initial (left) and resized (right).
34.1 A FIRST SWING APPLICATION
As a first Swing application, we&#8217;ll start with a window containing a single button. To program with
Swing, you need to import various classes from Scala&#8217;s Swing API package:
import scala.swing._
Listing 34.1 shows the code of your first Swing application in Scala. If you compile and run that file,
you should see a window as shown on the left of Figure 34.1. The window can be resized to a larger
size as shown on the right of Figure 34.1.
import scala.swing._
object FirstSwingApp extends SimpleSwingApplication {
def top = new MainFrame {
title = "First Swing App"
contents = new Button {
text = "Click me"
}
}
}
Listing 34.1 - A simple Swing application in Scala.
If you analyze the code in Listing 34.1 line by line, you&#8217;ll notice the following elements:object FirstSwingApp extends SimpleSwingApplication {
In the first line after the import, the FirstSwingApp object inherits
fromscala.swing.SimpleSwingApplication. This application differs from traditional command-line
applications, which may inherit from scala.App. The SimpleSwingApplication class already defines
a main method that contains some setup code for Java&#8217;s Swing framework. The main method then
proceeds to call the top method, which you supply:
def top = new MainFrame {
The next line implements the top method. This method contains the code that defines your top-level
GUI component. This is usually some kind of Frame—i.e., a window that can contain arbitrary data.
In Listing 34.1, we chose a MainFrame as the top-level component. A MainFrame is like a normal
Swing Frame except that closing it will also close the whole GUI application.
title = "First Swing App"
Frames have a number of attributes. Two of the most important are the frame&#8217;s title, which will be
written in the title bar, and its contents, which will be displayed in the window itself. In Scala&#8217;s Swing
API, such attributes are modeled as properties. You know from Section 18.2that properties are encoded
in Scala as pairs of getter and setter methods. For instance, thetitle property of a Frame object is
modeled as a getter method:
def title: String
and a setter method:
def title_=(s: String)
It is this setter method that gets invoked by the above assignment to title. The effect of the assignment
is that the chosen title is shown in the header of the window. If you leave it out, the window will have
an empty title.
contents = new Button {
The top frame is the root component of the Swing application. It is a Container, which means that
further components can be defined in it. Every Swing container has a contents property, which allows
you to get and set the components it contains. The getter contents of this property has
type Seq[Component], indicating that a component can in general have several objects as its contents.
Frames, however, always have just a single component as theircontents. This component is set and
potentially changed using the setter contents_=. For example, in Listing 34.1 a single Button constitutes
the contents of the top frame.
text = "Click me"
The button also gets a title, in this case "Click me."34.2 PANELS AND LAYOUTS
As next step, we&#8217;ll add some text as a second content element to the top frame of the application. The
left part of Figure 34.2 shows what the application should look like.
Figure 34.2 - A reactive Swing application: initial (left) after clicks (right).
import scala.swing._
object SecondSwingApp extends SimpleSwingApplication {
def top = new MainFrame {
title = "Second Swing App"
val button = new Button {
text = "Click me"
}
val label = new Label {
text = "No button clicks registered"
}
contents = new BoxPanel(Orientation.Vertical) {
contents += button
contents += label
border = Swing.EmptyBorder(30, 30, 10, 30)
}
}
}
Listing 34.2 - Component assembly on a panel.
You saw in the last section that a frame contains exactly one child component. Hence, to make a frame
with both a button and a label, you need to create a different container component that holds both.
That&#8217;s what panels are used for. A Panel is a container that displays all the components it contains
according to some fixed layout rules. There are a number of different possible layouts that are
implemented by various subclasses of classPanel, ranging from simple to quite intricate. In fact, one of
the hardest parts of a complex GUI application can be getting the layouts right—it&#8217;s not easy to come
up with something that displays reasonably well on all sorts of devices and for all window sizes.
Listing 34.2 shows a complete implementation. In this class, the two sub-components of thetop frame
are named button and label. The button is defined as before. The label is a displayed text field that can&#8217;t
be edited:
val label = new Label {
text = "No button clicks registered"
}
The code in Listing 34.2 picks a simple vertical layout where components are stacked on top of each
other in a BoxPanel:contents = new BoxPanel(Orientation.Vertical) {
The contents property of the BoxPanel is an (initially empty) buffer, to which
the button and labelelements are added with the += operator:
contents += button
contents += label
We also add a border around the two objects by assigning to the border property of the panel:
border = Swing.EmptyBorder(30, 30, 10, 30)
As is the case with other GUI components, borders are represented as objects. EmptyBorder is a factory
method in object Swing that takes four parameters indicating the width of the borders on the top, right,
bottom, and left sides of the objects to be drawn.
Simple as it is, the example has already shown the basic way to structure a GUI application. It is built
from components, which are instances of scala.swing classes such as Frame, Panel, Labelor Button.
Components have properties, which can be customized by the application. Panelcomponents can
contain several other components in their contents property, so that in the end a GUI application
consists of a tree of components.
34.3 HANDLING EVENTS
On the other hand, the application still misses an essential property. If you run the code inListing
34.2 and click on the displayed button, nothing happens. In fact, the application is completely static; it
does not react in any way to user events except for the close button of thetop frame, which terminates
the application. So as a next step, we&#8217;ll refine the application so that it displays together with the button
a label that indicates how often the button was clicked. The right part of Figure 34.2 contains a
snapshot of what the application should look like after a few button clicks.
To achieve this behavior, you need to connect a user-input event (the button was clicked) with an action
(the displayed label is updated). Java and Scala have fundamentally the same "publish/subscribe"
approach to event handling: Components may be publishers and/or subscribers. A publisher publishes
events. A subscriber subscribes with a publisher to be notified of any published events. Publishers are
also called "event sources," and subscribers are also called "event listeners". For instance a Button is an
event source, which publishes an event, ButtonClicked, indicating that the button was clicked.
In Scala, subscribing to an event source source is done by the call listenTo(source). There&#8217;s also a way
to unsubscribe from an event source using deafTo(source). In the current example application, the first
thing to do is to get the top frame to listen to its button, so that it gets notified of any events that the
button issues. To do that you need to add the following call to the body of the top frame:
listenTo(button)
Being notified of events is only half the story; the other half is handling them. It is here that the Scala
Swing framework is most different from (and radically simpler than) the Java Swing API&#8217;s. In Java,signaling an event means calling a "notify" method in an object that has to implement
some Listener interfaces. Usually, this involves a fair amount of indirection and boiler-plate code,
which makes event-handling applications hard to write and read. By contrast, in Scala, an event is a
real object that gets sent to subscribing components much like messages are sent to actors. For instance,
pressing a button will create an event which is an instance of the following case class:
case class ButtonClicked(source: Button)
The parameter of the case class refers to the button that was clicked. As with all other Scala Swing
events, this event class is contained in a package named scala.swing.event.
To have your component react to incoming events you need to add a handler to a property
called reactions. Here&#8217;s the code that does this:
var nClicks = 0
reactions += {
case ButtonClicked(b) &#8658;
nClicks += 1
label.text = "Number of button clicks: " + nClicks
}
The first line above defines a variable, nClicks, which holds the number of times a button was clicked.
The remaining lines add the code between braces as a handler to the reactionsproperty of the top frame.
Handlers are functions defined by pattern matching on events, much like Akka actor receive methods
are defined by pattern matching on messages. The handler above matches events of the
form ButtonClicked(b), i.e., any event which is an instance of class ButtonClicked. The pattern
variable b refers to the actual button that was clicked. The action that corresponds to this event in the
code above increments nClicks and updates the text of the label.
Generally, a handler is a PartialFunction that matches on events and performs some actions. It is also
possible to match on more than one kind of event in a single handler by using multiple cases.
import scala.swing._
import scala.swing.event._
object ReactiveSwingApp extends SimpleSwingApplication {
def top = new MainFrame {
title = "Reactive Swing App"
val button = new Button {
text = "Click me"
}
val label = new Label {
text = "No button clicks registered"
}
contents = new BoxPanel(Orientation.Vertical) {
contents += button
contents += label
border = Swing.EmptyBorder(30, 30, 10, 30)
}
listenTo(button)
var nClicks = 0
reactions += {}
}
case ButtonClicked(b) &#8658;
nClicks += 1
label.text = "Number of button clicks: " + nClicks
}
Listing 34.3 - Implementing a reactive Swing application.
The reactions property implements a collection, just like the contents property does. Some components
come with predefined reactions. For instance, a Frame has a predefined reaction that it will close if the
user presses the close button on the upper right. If you install your own reactions by adding them
with += to the reactions property, the reactions you define will be considered in addition to the standard
ones. Conceptually, the handlers installed in reactionsform a stack. In the current example, if
the top frame receives an event, the first handler tried will be the one that matches on ButtonClicked,
because it was the last handler installed for the frame. If the received event is of type ButtonClicked,
the code associated with the pattern will be invoked. After that code has completed, the system will
search for further handlers in the event stack that might also be applicable. If the received event is not
of type ButtonClicked, the event is immediately propagated to the rest of the installed handler stack. It&#8217;s
also possible to remove handlers from the reaction property, using the -= operator.
Listing 34.3 shows the completed application, including reactions. The code illustrates the essential
elements of a GUI application in Scala&#8217;s Swing framework: The application consists of a tree of
components, starting with the top frame. The components shown in the code
areFrame, BoxPanel, Button, and Label, but there are many other kinds of components defined in the
Swing libraries. Each component is customized by setting attributes. Two important attributes
are contents, which fixes the children of a component in the tree, and reactions, which determines how
the component reacts to events.
Figure 34.3 - A converter between degrees Celsius and Fahrenheit.
import swing._
import event._
object TempConverter extends SimpleSwingApplication {
def top = new MainFrame {
title = "Celsius/Fahrenheit Converter"
object celsius extends TextField { columns = 5 }
object fahrenheit extends TextField { columns = 5 }
contents = new FlowPanel {
contents += celsius
contents += new Label(" Celsius = ")
contents += fahrenheit
contents += new Label(" Fahrenheit")
border = Swing.EmptyBorder(15, 10, 10, 10)}
listenTo(celsius, fahrenheit)
reactions += {
case EditDone(<code>fahrenheit</code>) &#8658;
val f = fahrenheit.text.toInt
val c = (f - 32) * 5 / 9
celsius.text = c.toString
case EditDone(<code>celsius</code>) &#8658;
val c = celsius.text.toInt
val f = c * 9 / 5 + 32
fahrenheit.text = f.toString
}
}
}
Listing 34.4 - An implementation of the temperature converter.
34.4 EXAMPLE: CELSIUS/FAHRENHEIT CONVERTER
As another example, we&#8217;ll write a GUI program that converts between temperature degrees in Celsius
and Fahrenheit. The user interface of the program is shown in Figure 34.3. It consists of two text fields
(shown in white) with a label following each. One text field shows temperatures in degrees Celsius, the
other in degrees Fahrenheit. Each of the two fields can be edited by the user of the application. Once
the user has changed the temperature in either field, the temperature in the other field should
automatically update.
Listing 34.4 shows the complete code that implements this application. The imports at the top of the
code use a short-hand:
import swing._
import event._
This is in fact equivalent to the imports used before:
import scala.swing._
import scala.swing.event._
The reason you can use the shorthand is that packages nest in Scala. Because packagescala.swing is
contained in package scala, and everything in that package imported automatically, you can write
just swing to refer to the package. Likewise, packagescala.swing.event, is contained as
subpackage event in package scala.swing. Because you have imported everything in scala.swing in the
first import, you can refer to the event package with just event thereafter.
The two components celsius and fahrenheit in TempConverter are objects of class TextField.
ATextField in Swing is a component that lets you edit a single line of text. It has a default width, which
is given in the columns property measured in characters (set to 5 for both fields).
The contents of TempConverter are assembled into a panel, which includes the two text fields and two
labels that explain what the fields are. The panel is of class FlowPanel, which means it displays all its
elements one after another, in one or more rows, depending on the width of the frame.The reactions of TempConverter are defined by a handler that contains two cases. Each case matches
an EditDone event for one of the two text fields. Such an event gets issued when a text field has been
edited by the user. Note the form of the patterns, which include back ticks around the element names:
case EditDone(<code>celsius</code>)
As was explained in Section 15.2, the back ticks around celsius ensure that the pattern matches only if
the source of the event was the celsius object. If you had omitted the back ticks and just
written case EditDone(celsius), the pattern would have matched every event of class EditDone. The
changed field would then be stored in the pattern variable celsius. Obviously, this is not what you want.
Alternatively, you could have defined the two TextFieldobjects starting with upper case
characters, i.e., Celsius and Fahrenheit. In that case you could have matched them directly without back
ticks, as in case EditDone(Celsius).
The two actions of the EditDone events convert one quantity to another. Each starts by reading out the
contents of the modified field and converting it to an Int. It then applies the formula for converting one
temperature degree to the other, and stores the result back as a string in the other text field.
34.5 CONCLUSION
This chapter has given you a first taste of GUI programming, using Scala&#8217;s wrappers for the Swing
framework. It has shown how to assemble GUI components, how to customize their properties, and
how to handle events. For space reasons, we could discuss only a small number of simple components.
There are many more kinds of components. You can find out about them by consulting the Scala
documentation of the package scala.swing. The next section will develop an example of a more
complicated Swing application.
There are also many tutorials on the original Java Swing framework, on which the Scala wrapper is
based.<span class="footnote"><br />[See, for instance, The Java Tutorials. [Jav]]<br /></span> The Scala wrappers resemble the underlying Swing classes, but try to simplify concepts
where possible and make them more uniform. The simplification makes extensive use of the properties
of the Scala language. For instance, Scala&#8217;s emulation of properties and its operator overloading allow
convenient property definitions using assignments and += operations. Its "everything is an object"
philosophy makes it possible to inherit the main method of a GUI application. The method can thus be
hidden from user applications, including the boilerplate code for setting things up that comes with it.
Finally, and most importantly, Scala&#8217;s first-class functions and pattern matching make it possible to
formulate event handling as the reactions component property, which greatly simplifies life for the
application developer.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="sect1">
<h2 id="__35_2">Глава 35</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___scells">Електронна таблиця SCells</h1>
<div class="paragraph"><p>In the previous chapters you saw many different constructs of the Scala programming language. In this
chapter you&#8217;ll see how these constructs play together in the implementation of a sizable application.
The task is to write a spreadsheet application, which will be namedSCells.
There are several reasons why this task is interesting. First, everybody knows spreadsheets, so it is easy
to understand what the application should do. Second, spreadsheets are programs that exercise a large
range of different computing tasks. There&#8217;s the visual aspect, where a spreadsheet is seen as a rich GUI
application. There&#8217;s the symbolic aspect, having to do with formulas and how to parse and interpret
them. There&#8217;s the calculational aspect, dealing with how to update possibly large tables incrementally.
There&#8217;s the reactive aspect, where spreadsheets are seen as programs that react in intricate ways to
events. Finally, there&#8217;s the component aspect where the application is constructed as a set of reusable
components. All these aspects will be treated in depth in this chapter.Figure 35.1 - A simple spreadsheet table.
35.1 THE VISUAL FRAMEWORK
We&#8217;ll start by writing the basic visual framework of the application. Figure 35.1 shows the first iteration
of the user interface. You can see that a spreadsheet is a scrollable table. It has rows going
from 0 to 99 and columns going from A to Z. You express this in Swing by defining a spreadsheet as
a ScrollPane containing a Table. Listing 35.1 shows the code.
package org.stairwaybook.scells
import swing._
class Spreadsheet(val height: Int, val width: Int)
extends ScrollPane {
val table = new Table(height, width) {
rowHeight = 25
autoResizeMode = Table.AutoResizeMode.Off
showGrid = true
gridColor = new java.awt.Color(150, 150, 150)
}
val rowHeader =
new ListView0 until height) map (<em>.toString {
fixedCellWidth = 30
fixedCellHeight = table.rowHeight
}
viewportView = table
rowHeaderView = rowHeader
}
Listing 35.1 - Code for spreadsheet in Figure 35.1.
The spreadsheet component shown in Listing 35.1 is defined in packageorg.stairwaybook.scells, which
will contain all classes, traits, and objects needed for the application. It imports from
package scala.swing essential elements of Scala&#8217;s Swing wrapper.Spreadsheet itself is a class that
takes height and width (in numbers of cells) as parameters. The class extends ScrollPane, which gives it
the scroll-bars at the bottom and right in Figure 35.1. It contains two sub-components
named table and rowHeader.
The table component is an instance of an anonymous subclass of class scala.swing.Table. The four lines
in its body set some of its attributes: rowHeight for the height of a table row in
points,autoResizeMode to turn auto-sizing the table off, showGrid to show a grid of lines between
cells, and gridColor to set the color of the grid to a dark gray.
The rowHeader component, which contains the row-number headers at the left of the spreadsheet
in Figure 35.1, is a ListView that displays in its elements the strings 0 through 99.The two lines in its
body fix the width of a cell to be 30 points and the height to be the same as the table&#8217;s rowHeight.
The whole spreadsheet is assembled by setting two fields in ScrollPane. The field viewportView is set
to the table, and the field rowHeaderView is set to the rowHeader list. The difference between the twoviews is that a view port of a scroll pane is the area that scrolls with the two bars, whereas the row
header on the left stays fixed when you move the horizontal scroll bar. By some quirk, Swing already
supplies by default a column header at the top of the table, so there&#8217;s no need to define one explicitly.
package org.stairwaybook.scells
import swing.</em>
object Main extends SimpleSwingApplication {
def top = new MainFrame {
title = "ScalaSheet"
contents = new Spreadsheet(100, 26)
}
}
Listing 35.2 - The main program for the spreadsheet application.
To try out the rudimentary spreadsheet shown in Listing 35.1, you just need to define a main program
that creates the Spreadsheet component. Such a program is shown in Listing 35.2.
Program Main inherits from SimpleSwingApplication, which takes care of all the low-level details that
need to be set up before a Swing application can be run. You only need to define the top-level window
of the application in the top method. In our example, top is a MainFrame that has two elements defined:
its title, set to "ScalaSheet," and its contents, set to an instance of classSpreadsheet with 100 rows
and 26 columns. That&#8217;s all. If you launch this application withscala org.stairwaybook.scells.Main, you
should see the spreadsheet in Figure 35.1.
35.2 DISCONNECTING DATA ENTRY AND DISPLAY
If you play a bit with the spreadsheet written so far, you&#8217;ll quickly notice that the output that&#8217;s displayed
in a cell is always exactly what you entered in the cell. A real spreadsheet does not behave like that. In
a real spreadsheet, you would enter a formula and you&#8217;d see its value. So what is entered into a cell is
different from what is displayed.
package org.stairwaybook.scells
import swing._
class Spreadsheet(val height: Int, val width: Int)
extends ScrollPane {
val cellModel = new Model(height, width)
import cellModel._
val table = new Table(height, width) {

override def rendererComponent(isSelected: Boolean,
hasFocus: Boolean, row: Int, column: Int): Component =
if (hasFocus) new TextField(userData(row, column))
else
new Label(cells(row)(column).toString) {
xAlignment = Alignment.Right}
def userData(row: Int, column: Int): String = {
val v = this(row, column)
if (v == null) "" else v.toString
}
}

}
Listing 35.3 - A spreadsheet with a rendererComponent method.
As a first step to a real spreadsheet application, you should concentrate on disentangling data entry and
display. The basic mechanism for display is contained in the rendererComponentmethod of
class Table. By default, rendererComponent always displays what&#8217;s entered. If you want to change that,
you need to override rendererComponent to do something different. Listing 35.3shows a new version
of Spreadsheet with a rendererComponent method.
The rendererComponent method overrides a default method in class Table. It takes four parameters.
The isSelected and hasFocus parameters are Booleans that indicate whether the cell has been selected
and whether it has focus, meaning that keyboard events will go into the cell. The remaining two
parameters, row and column, give the cell&#8217;s coordinates.
The new rendererComponent method checks whether the cell has input focus. If hasFocus is true, the
cell is used for editing. In this case you want to display an editable TextField that contains the data the
user has entered so far. This data is returned by the helper method userData, which displays the
contents of the table at a given row and column. The contents are retrieved by the
call this(row, column).<span class="footnote"><br />[Although "this(row, column)" may look similar to a constructor invocation, it is in this case an invocation of the apply method on the current Table instance.]<br /></span> The userData method also takes care to display a null element as the empty
string instead of "null."
So far so good. But what should be displayed if the cell does not have focus? In a real spreadsheet this
would be the value of a cell. Thus, there are really two tables at work. The first table,
named table contains what the user entered. A second "shadow" table contains the internal
representation of cells and what should be displayed. In the spreadsheet example, this table is a two-
dimensional array called cells. If a cell at a given row and column does not have editing focus,
the rendererComponent method will display the element cells(row)(column). The element cannot be
edited, so it should be displayed in a Label instead of in an editableTextField.
It remains to define the internal array of cells. You could do this directly in the Spreadsheetclass, but it&#8217;s
generally preferable to separate the view of a GUI component from its internal model. That&#8217;s why in the
example above the cells array is defined in a separate class namedModel. The model is integrated into
the Spreadsheet by defining a value cellModel of type Model. The import clause that follows
this val definition makes the members of cellModel available inside Spreadsheet without having to
prefix them. Listing 35.4 shows a first simplified version of a Model class. The class defines an inner
class, Cell, and a two-dimensional array, cells, ofCell elements. Each element is initialized to be a
fresh Cell.package org.stairwaybook.scells
class Model(val height: Int, val width: Int) {
case class Cell(row: Int, column: Int)
val cells = Array.ofDim[Cell](height, width)
for (i &#8592; 0 until height; j &#8592; 0 until width)
cells(i)(j) = new Cell(i, j)
}
Listing 35.4 - First version of the Model class.
Figure 35.2 - Cells displaying themselves.
That&#8217;s it. If you compile the modified Spreadsheet class with the Model class and run
the Mainapplication you should see a window as in Figure 35.2.
The objective of this section was to arrive at a design where the displayed value of a cell is different
from the string that was entered into it. This objective has clearly been met, albeit in a very crude way.
In the new spreadsheet you can enter anything you want into a cell, but it will always display just its
coordinates once it loses focus. Clearly, we are not done yet.35.3 FORMULAS
In reality, a spreadsheet cell holds two things: An actual value and a formula to compute this value.
There are three types of formulas in a spreadsheet:
1. Numeric values such as 1.22, -3, or 0.
2. Textual labels such as Annual sales, Deprecation, or total.
3. Formulas that compute a new value from the contents of cells, such as "=add(A1,B2)", or
"=sum(mul(2, A2), C1:D16)"
A formula that computes a value always starts with an equals sign and is followed by an arithmetic
expression. The SCells spreadsheet has a particularly simple and uniform convention for arithmetic
expressions: every expression is an application of some function to a list of arguments. The function
name is an identifier such as add for binary addition, or sumfor summation of an arbitrary number of
operands. A function argument can be a number, a reference to a cell, a reference to a range of cells
such as C1:D16, or another function application. You&#8217;ll see later that SCells has an open architecture
that makes it easy to install your own functions via mixin composition.
The first step to handling formulas is writing down the types that represent them. As you might expect,
the different kinds of formulas are represented by case classes. Listing 35.5shows the contents of a file
named Formulas.scala, where these case classes are defined:
package org.stairwaybook.scells
trait Formula
case class Coord(row: Int, column: Int) extends Formula {
override def toString = (<em>A</em> + column).toChar.toString + row
}
case class Range(c1: Coord, c2: Coord) extends Formula {
override def toString = c1.toString + ":" + c2.toString
}
case class Number(value: Double) extends Formula {
override def toString = value.toString
}
case class Textual(value: String) extends Formula {
override def toString = value
}
case class Application(function: String,
arguments: List[Formula]) extends Formula {
override def toString =
function + arguments.mkString("(", ",", ")")
}
object Empty extends Textual("")
Listing 35.5 - Classes representing formulas.
Trait Formula, shown in Listing 35.5, has five case classes as children:
Coord
Range
for cell coordinates such as A3,
for cell ranges such as A3:B17,Number
for floating-point numbers such as 3.1415,
Textual
for textual labels such as Deprecation,
Application for function applications such as sum(A1,A2).
Each case class overrides the toString method so that it displays its kind of formula in the standard way
shown above. For convenience there&#8217;s also an Empty object that represents the contents of an empty
cell. The Empty object is an instance of the Textual class with an empty string argument.
35.4 PARSING FORMULAS
In the previous section you saw the different kinds of formulas and how they display as strings. In this
section you&#8217;ll see how to reverse the process: to transform a user input string into a Formula tree. The
rest of this section explains one by one the different elements of a classFormulaParsers, which contains
the parsers that do the transformation. The class builds on the combinator framework given in Chapter
33. Specifically, formula parsers are an instance of the RegexParsers class explained in that chapter:
package org.stairwaybook.scells
import scala.util.parsing.combinator._
object FormulaParsers extends RegexParsers {
The first two elements of object FormulaParsers are auxiliary parsers for identifiers and decimal
numbers:
def ident: Parser[String] = """[a-zA-Z_]\w*""".r
def decimal: Parser[String] = """-?\d+(\.\d*)?""".r
As you can see from the first regular expression above, an identifier starts with a letter or
underscore. This is followed by an arbitrary number of "word" characters represented by the regular
expression code \w, which recognizes letters, digits or underscores. The second regular expression
describes decimal numbers, which consist of an optional minus sign, one or more digits that are
represented by regular expression code \d, and an optional decimal part consisting of a period followed
by zero or more digits.
The next element of object FormulaParsers is the cell parser, which recognizes the coordinates of a cell,
such as C11 or B2. It first calls a regular expression parser that determines the form of a coordinate: a
single letter followed by one or more digits. The string returned from that parser is then converted to a
cell coordinate by separating the letter from the numerical part and converting the two parts to indices
for the cell&#8217;s column and row:
def cell: Parser[Coord] =
"""[A-Za-z]\d+""".r <sup>^ { s &#8658;
val column = s.charAt(0).toUpper - <em>A</em>
val row = s.substring(1).toInt
Coord(row, column)
}
Note that the cell parser is a bit restrictive in that it allows only column coordinates consisting of a
single letter. Hence the number of spreadsheet columns is in effect restricted to be at most 26, becausefurther columns cannot be parsed. It&#8217;s a good idea to generalize the parser so that it accepts cells with
several leading letters. This is left as an exercise to you.
The range parser recognizes a range of cells. Such a range is composed of two cell coordinates with a
colon between them:
def range: Parser[Range] =
cell<sub>":"</sub>cell </sup>^ {
case c1<sub>":"</sub>c2 &#8658; Range(c1, c2)
}
The number parser recognizes a decimal number, which is converted to a Double and wrapped in an
instance of the Number class:
def number: Parser[Number] =
decimal <sup>^ (d &#8658; Number(d.toDouble))
The application parser recognizes a function application. Such an application is composed of an
identifier followed by a list of argument expressions in parentheses:
def application: Parser[Application] =
ident<sub>"("</sub>repsep(expr, ",")<sub>")" </sup>^ {
case f</sub>"("<sub>ps</sub>")" &#8658; Application(f, ps)
}
The expr parser recognizes a formula expression—either a top-level formula following an &#8216;=', or an
argument to a function. Such a formula expression is defined to be a cell, a range of cells, a number, or
an application:
def expr: Parser[Formula] =
range | cell | number | application
This definition of the expr parser contains a slight oversimplification because ranges of cells should
only appear as function arguments; they should not be allowed as top-level formulas. You could change
the formula grammar so that the two uses of expressions are separated, and ranges are excluded
syntactically from top-level formulas. In the spreadsheet presented here such an error is instead
detected once an expression is evaluated.
The textual parser recognizes an arbitrary input string, as long as it does not start with an equals sign
(recall that strings that start with `=' are considered to be formulas):
def textual: Parser[Textual] =
"""[^=].*""".r ^^ Textual
The formula parser recognizes all kinds of legal inputs into a cell. A formula is either a number, or
a textual entry, or a formula starting with an equals sign:
def formula: Parser[Formula] =
number | textual | "="~&gt;exprThis concludes the grammar for spreadsheet cells. The final method parse uses this grammar in a
method that converts an input string into a Formula tree:
def parse(input: String): Formula =
parseAll(formula, input) match {
case Success(e, _) =&gt; e
case f: NoSuccess =&gt; Textual("[" + f.msg + "]")
}
} //end FormulaParsers
The parse method parses all of the input with the formula parser. If that succeeds, the resulting formula
is returned. If it fails, a Textual object with an error message is returned instead.
package org.stairwaybook.scells
import swing._
import event._
class Spreadsheet(val height: Int, val width: Int) ... {
val table = new Table(height, width) {
...
reactions += {
case TableUpdated(table, rows, column) =&gt;
for (row &lt;- rows)
cells(row)(column).formula =
FormulaParsers.parse(userData(row, column))
}
}
}
Listing 35.6 - A spreadsheet that parses formulas.
That's everything there is to parsing formulas. The only thing that remains is to integrate the parser into
the spreadsheet. To do this, you can enrich the Cell class in class Model by a formulafield:
case class Cell(row: Int, column: Int) {
var formula: Formula = Empty
override def toString = formula.toString
}
In the new version of the Cell class, the toString method is defined to display the cell's formula. That
way you can check whether formulas have been correctly parsed.
The last step in this section is to integrate the parser into the spreadsheet. Parsing a formula happens as
a reaction to the user's input into a cell. A completed cell input is modeled in the Swing library by
a TableUpdated event. The TableUpdated class is contained in packagescala.swing.event. The event is
of the form:
TableUpdated(table, rows, column)
It contains the table that was changed, as well as a set of coordinates of affected cells given
byrows and column. The rows parameter is a range value of type Range[Int].footnote:[Range[Int] is also the type of a Scala expression such as "1 to N".[3] This assumes that there are no cyclic dependencies between cells. We discuss dropping this assumption at the end of this chapter.] The column parameter
is an integer. So in general a TableUpdated event can refer to several affected cells, but they would be
on a consecutive range of rows and share the same column.Figure 35.3 - Cells displaying their formulas.
Once a table is changed, the affected cells need to be re-parsed. To react to a TableUpdatedevent, you
add a case to the reactions value of the table component, as is shown in Listing 35.6. Now, whenever
the table is edited the formulas of all affected cells will be updated by parsing the corresponding user
data. When compiling the classes discussed so far and launching the scells.Main application you should
see a spreadsheet application like the one shown in Figure 35.3. You can edit cells by typing into them.
After editing is done, a cell displays the formula it contains. You can also try to type some illegal input
such as the one reading =add(1, X) in the field that has the editing focus in Figure 35.3. Illegal input
will show up as an error message. For instance, once you'd leave the edited field in Figure 35.3 you
should see the error message [`(&#8217; expected] in the cell (to see all of the error message you might need to
widen the column by dragging the separation between the column headers to the right).
35.5 EVALUATION
Of course, in the end a spreadsheet should evaluate formulas, not just display them. In this section,
we&#8217;ll add the necessary components to achieve this.
What&#8217;s needed is a method, evaluate, which takes a formula and returns the value of that formula in the
current spreadsheet, represented as a Double. We&#8217;ll place this method in a new trait, Evaluator. The
method needs to access the cells field in class Model to find out about the current values of cells that
are referenced in a formula. On the other hand, the Model class needs to call evaluate. Hence, there&#8217;s amutual dependency between the Model and the Evaluator. A good way to express such mutual
dependencies between classes was shown in Chapter 29: you use inheritance in one direction and self
types in the other.
In the spreadsheet example, class Model inherits from Evaluator and thus gains access to
itsevaluation method. To go the other way, class Evaluator defines its self type to be Model, like this:
package org.stairwaybook.scells
trait Evaluator { this: Model &#8658; &#8230;
That way, the this value inside class Evaluator is assumed to be Model and the cells array is accessible
by writing either cells or this.cells.
Now that the wiring is done, we&#8217;ll concentrate on defining the contents of class Evaluator.Listing
35.7 shows the implementation of the evaluate method. As you might expect, the method contains a
pattern match over the different types of formulas. For a coordinateCoord(row, column), it returns the
value of the cells array at that coordinate. For a numberNumber(v), it returns the value v. For a textual
label Textual(s), it returns zero. Finally, for an application Application(function, arguments), it
computes the values of all arguments, retrieves a function object corresponding to the function name
from an operations table and applies that function to all argument values.
def evaluate(e: Formula): Double = try {
e match {
case Coord(row, column) &#8658;
cells(row)(column).value
case Number(v) &#8658;
v
case Textual(<em>) &#8658;
0
case Application(function, arguments) &#8658;
val argvals = arguments flatMap evalList
operations(function)(argvals)
}
} catch {
case ex: Exception &#8658; Double.NaN
}
Listing 35.7 - The evaluate method of trait Evaluator.
The operations table maps function names to function objects. It is defined as follows:
type Op = List[Double] &#8658; Double
val operations = new collection.mutable.HashMap[String, Op]
As you can see from this definition, operations are modeled as functions from lists of values to values.
The Op type introduces a convenient alias for the type of an operation.
The computation in evaluate is wrapped in a try-catch to guard against input errors. There are actually
quite a few things that can go wrong when evaluating a cell formula: coordinates might be out of range;
function names might be undefined; functions might have the wrong number of arguments; arithmetic
operations might be illegal or overflow. The reaction to any of these errors is the same: a "not-a-number" value is returned. The returned value,Double.NaN, is the IEEE representation for a
computation that does not have a representable floating-point value. This might happen because of an
overflow or a division by zero, for example. The evaluate method of Listing 35.7 chooses to return the
same value also for all other kinds of errors. The advantage of this scheme is that it&#8217;s simple to
understand and doesn&#8217;t require much code to implement. Its disadvantage is that all kinds of errors are
lumped together, so a spreadsheet user does not get any detailed feedback on what went wrong. If you
wish you can experiment with more refined ways of representing errors in theSCells application.
The evaluation of arguments is different from the evaluation of top-level formulas. Arguments may be
lists whereas top-level functions may not. For instance, the argument
expression A1:A3 in sum(A1:A3) returns the values of cells A1, A2, A3 in a list. This list is then
passed to the sum operation. It&#8217;s also possible to mix lists and single values in argument expressions,
for instance the operation sum(A1:A3, 1.0, C7), which would sum up five values. To handle arguments
that might evaluate to lists, there&#8217;s another evaluation function, calledevalList, which takes a formula
and returns a list of values:
private def evalList(e: Formula): List[Double] = e match {
case Range(</em>, <em>) &#8658; references(e) map (</em>.value)
case _ &#8658; List(evaluate(e))
}
If the formula argument passed to evalList is a Range, the returned value is a list consisting of the
values of all cells referenced by the range. For every other formula the result is a list consisting of the
single result value of that formula. The cells referenced by a formula are computed by a third
function, references. Here is its definition:
def references(e: Formula): List[Cell] = e match {
case Coord(row, column) &#8658;
List(cells(row)(column))
case Range(Coord(r1, c1), Coord(r2, c2)) &#8658;
for (row &#8592; (r1 to r2).toList; column &#8592; c1 to c2)
yield cells(row)(column)
case Application(function, arguments) &#8658;
arguments flatMap references
case _ &#8658;
List()
}
} // end Evaluator
The references method is actually more general than needed right now in that it computes the list of
cells referenced by any sort of formula, not just a Range formula. It will turn out later that the added
functionality is needed to compute the sets of cells that need updating. The body of the method is a
straightforward pattern match on kinds of formulas. For a coordinateCoord(row, column), it returns a
single-element list containing the cell at that coordinate. For a range expression Range(coord1, coord2),
it returns all cells between the two coordinates, computed by a for expression. For a function
application Application(function, arguments), it returns the cells referenced by each argument
expression, concatenated via flatMap into a single list. For the other two types of
formulas, Textual and Number, it returns an empty list.35.6 OPERATION LIBRARIES
The class Evaluator itself defines no operations that can be performed on cells: its operationstable is
initially empty. The idea is to define such operations in other traits, which are then mixed into
the Model class. Listing 35.8 shows an example trait that implements common arithmetic operations:
package org.stairwaybook.scells
trait Arithmetic { this: Evaluator &#8658;
operations += (
"add" &#8594; { case List(x, y) &#8658; x + y
"sub" &#8594; { case List(x, y) &#8658; x - y
"div" &#8594; { case List(x, y) &#8658; x / y
"mul" &#8594; { case List(x, y) &#8658; x * y
"mod" &#8594; { case List(x, y) &#8658; x % y
"sum" &#8594; { xs &#8658; (0.0 /: xs)(_ + <em>)
"prod" &#8594; { xs &#8658; (1.0 /: xs)(</em> * <em>)
)
}
},
},
},
},
},
},
}
Listing 35.8 - A library for arithmetic operations.
Interestingly, this trait has no exported members. The only thing it does is populate theoperations table
during its initialization. It gets access to that table by using a self typeEvaluator, i.e., by the same
technique the Arithmetic class uses to get access to the model.
Of the seven operations that are defined by the Arithmetic trait, five are binary operations and two take
an arbitrary number of arguments. The binary operations all follow the same schema. For instance, the
addition operation add is defined by the expression:
{ case List(x, y) &#8658; x + y }
That is, it expects an argument list consisting of two elements x and y and returns the sum of xand y. If
the argument list contains a number of elements different from two, a MatchError is thrown. This
corresponds to the general "let it crash" philosophy of SCell&#8217;s evaluation model, where incorrect input
is expected to lead to a runtime exception that then gets caught by the try-catch inside
the evaluation method.
The last two operations, sum and prod, take a list of arguments of arbitrary length and insert a binary
operation between successive elements. So they are instances of the "fold left" schema that&#8217;s expressed
in class List by the /: operation. For instance, to sum a list of numbersList(x, y, z), the operation
computes 0 + x + y + z. The first operand, 0, is the result if the list is empty.
You can integrate this operation library into the spreadsheet application by mixing theArithmetic trait
into the Model class, like this:
package org.stairwaybook.scells
class Model(val height: Int, val width: Int)
extends Evaluator with Arithmetic {
case class Cell(row: Int, column: Int) {
var formula: Formula = Emptydef value = evaluate(formula)
override def toString = formula match {
case Textual(s) &#8658; s
case _ &#8658; value.toString
}
}
}
&#8230; // rest as before
Another change in the Model class concerns the way cells display themselves. In the new version, the
displayed value of a cell depends on its formula. If the formula is a Textual field, the contents of the
field are displayed literally. In all other cases, the formula is evaluated and the result value of that
evaluation is displayed.
Figure 35.4 - Cells that evaluate.
If you compile the changed traits and classes and relaunch the Main program you get something that
starts to resemble a real spreadsheet. Figure 35.4 shows an example. You can enter formulas into cells
and get them to evaluate themselves. For instance, once you close the editing focus on cell C5 in Figure
35.4, you should see 86.0, the result of evaluating the formula sum(C1:C4).
However, there&#8217;s a crucial element still missing. If you change the value of cell C1 in Figure 35.4 from
20 to 100, the sum in cell C5 will not be automatically updated to 166. You&#8217;ll have to clickon C5 manually to see a change in its value. What&#8217;s still missing is a way to have cells recompute their
values automatically after a change.
35.7 CHANGE PROPAGATION
If a cell&#8217;s value has changed, all cells that depend on that value should have their results recomputed
and redisplayed. The simplest way to achieve this would be to recompute the value of every cell in the
spreadsheet after each change. However such an approach does not scale well as the spreadsheet grows
in size.
A better approach is to recompute the values of only those cells that refer to a changed cell in their
formula. The idea is to use an event-based publish/subscribe framework for change propagation: once a
cell gets assigned a formula, it will subscribe to be notified of all value changes in cells to which the
formula refers. A value change in one of these cells will trigger a re-evaluation of the subscriber cell. If
such a re-evaluation causes a change in the value of the cell, it will in turn notify all cells that depend
on it. The process continues until all cell values have stabilized, i.e., there are no more changes in the
values of any cell.[3]
The publish/subscribe framework is implemented in class Model using the standard event mechanism
of Scala&#8217;s Swing framework. Here&#8217;s a new (and final) version of this class:
package org.stairwaybook.scells
import swing.</em>
class Model(val height: Int, val width: Int)
extends Evaluator with Arithmetic {
Compared to the previous version of Model, this version adds a new import of swing.<em>, which makes
Swing&#8217;s event abstractions directly available.
The main modifications of class Model concern the nested class Cell. Class Cell now inherits
from Publisher, so that it can publish events. The event-handling logic is completely contained in the
setters of two properties: value and formula. Here is Cell&#8217;s new version:
case class Cell(row: Int, column: Int) extends Publisher {
override def toString = formula match {
case Textual(s) &#8658; s
case _ &#8658; value.toString
}
To the outside, it looks like value and formula are two variables in class Cell. Their actual
implementation is in terms of two private fields that are equipped with public
getters, valueand formula, and setters, value</em>= and formula_=. Here are the definitions implementing
the valueproperty:
private var v: Double = 0
def value: Double = v
def value_=(w: Double) = {
if (!(v == w || v.isNaN &amp;&amp; w.isNaN)) {
v = w}
publish(ValueChanged(this))
}
The value_= setter assigns a new value w to the private field v. If the new value is different from the
old one, it also publishes a ValueChanged event with the cell itself as argument. Note that the test
whether the value has changed is a bit tricky because it involves the value NaN. The Java spec says
that NaN is different from every other value, including itself! Therefore, a test whether two values are
the same has to treat NaN specially: two values v, w are the same if they are equal with respect to ==,
or they are both the value NaN, i.e., v.isNaN and w.isNaN both yieldtrue.
Whereas the value_= setter does the publishing in the publish/subscribe framework,
theformula_= setter does the subscribing:
private var f: Formula = Empty
def formula: Formula = f
def formula_=(f: Formula) = {
for (c &#8592; references(formula)) deafTo(c)
this.f = f
for (c &#8592; references(formula)) listenTo(c)
value = evaluate(f)
}
If a cell is assigned a new formula, it first unsubscribes with deafTo from all cells referenced by the
previous formula value. It then stores the new formula in the private variable f and subscribes
with listenTo to all cells referenced by it. Finally, it recomputes its value using the new formula.
The last piece of code in the revised class Cell specifies how to react to a ValueChanged event:
reactions += {
case ValueChanged(<em>) &#8658; value = evaluate(formula)
}
} // end class Cell
The ValueChanged class is also contained in class Model:
case class ValueChanged(cell: Cell) extends event.Event
The rest of class Model is as before:
val cells = Array.ofDim[Cell](height, width)
for (i &#8592; 0 until height; j &#8592; 0 until width)
cells(i)(j) = new Cell(i, j)
} // end class Model
package org.stairwaybook.scells
import swing.</em>, event._
class Spreadsheet(val height: Int, val width: Int)
extends ScrollPane {
val cellModel = new Model(height, width)
import cellModel.<em>val table = new Table(height, width) {
&#8230; // settings as in Listing ???
override def rendererComponent(
isSelected: Boolean, hasFocus: Boolean,
row: Int, column: Int) =
&#8230; // as in Listing ???
def userData(row: Int, column: Int): String =
&#8230; // as in Listing ???
reactions += {
case TableUpdated(table, rows, column) &#8658;
for (row &#8592; rows)
cells(row)(column).formula =
FormulaParsers.parse(userData(row, column))
case ValueChanged(cell) &#8658;
updateCell(cell.row, cell.column)
}
for (row &#8592; cells; cell &#8592; row) listenTo(cell)
}
val rowHeader = new ListView(0 until height) {
fixedCellWidth = 30
fixedCellHeight = table.rowHeight
}
}
viewportView = table
rowHeaderView = rowHeader
Listing 35.9 - The finished spreadsheet component.
The spreadsheet code is now almost complete. The final piece missing is the re-display of modified
cells. So far, all value propagation concerned the internal Cell values only; the visible table was not
affected. One way to change this would be to add a redraw command to the value</em>= setter. However,
this would undermine the strict separation between model and view that you have seen so far. A more
modular solution is to notify the table of allValueChanged events and let it do the redrawing
itself. Listing 35.9 shows the final spreadsheet component, which implements this scheme.
Class Spreadsheet of Listing 35.9 has only two new revisions. First, the table component now
subscribes with listenTo to all cells in the model. Second, there&#8217;s a new case in the table&#8217;s reactions: if it
is notified of a ValueChanged(cell) event, it demands a redraw of the corresponding cell with a call
of updateCell(cell.row, cell.column).
35.8 CONCLUSION
The spreadsheet developed in this chapter is fully functional, even though at some points it adopts the
simplest solution to implement rather than the most convenient one for the user. That way, it could be
written in just under 200 lines of code. Nevertheless, the architecture of the spreadsheet makesmodifications and extensions easy. In case you would like to experiment with the code a bit further,
here are some suggestions of what you could change or add:
1. You could make the spreadsheet resizable, so that the number of rows and columns can be
changed interactively.
2. You could add new kinds of formulas, for instance binary operations, or other functions.
3. You might think about what to do when cells refer recursively to themselves. For instance, if
cell A1 holds the formula add(B1, 1) and cell B1 holds the formula mul(A1, 2), a re-evaluation
of either cell will trigger a stack-overflow. Clearly, that&#8217;s not a very good solution. As
alternatives, you could either disallow such a situation, or just compute one iteration each time
one of the cells is touched.
4. You could enhance error handling, giving more detailed messages describing what went wrong.
5. You could add a formula entry field at the top of the spreadsheet, so that long formulas could be
entered more conveniently.
At the beginning of this book we stressed the scalability aspect of Scala. We claimed that the
combination of Scala&#8217;s object-oriented and functional constructs makes it suitable for programs ranging
from small scripts to very large systems. The spreadsheet presented here is clearly still a small system,
even though it would probably take up much more than 200 lines in most other languages.
Nevertheless, you can see many of the details that make Scala scalable at play in this application.
The spreadsheet uses Scala&#8217;s classes and traits with their mixin composition to combine its components
in flexible ways. Recursive dependencies between components are expressed using self types. The need
for static state is completely eliminated—the only top-level components that are not classes are formula
trees and formula parsers, and both of these are purely functional. The application also uses higher-
order functions and pattern matching extensively, both for accessing formulas and for event handling.
So it is a good showcase of how functional and object-oriented programming can be combined
smoothly.
One important reason why the spreadsheet application is so concise is that it can base itself on powerful
libraries. The parser combinator library provides in effect an internal domain-specific language for
writing parsers. Without it, parsing formulas would have been much more difficult. The event handling
in Scala&#8217;s Swing libraries is a good example of the power of control abstractions. If you know Java&#8217;s
Swing libraries, you probably appreciate the conciseness of Scala&#8217;s reactions concept, particularly when
compared to the tedium of writing notify methods and implementing listener interfaces in the classical
publish/subscribe design pattern. So the spreadsheet demonstrates the benefits of extensibility, where
high-level libraries can be made to look just like language extensions.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="sect1">
<h2 id="__a">Додаток A</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__scala__unix__windows">Скрипти Scala на Unix та Windows</h1>
<div class="paragraph"><p>Якщо ви на деякому різновиді Unix, ви можете виконувати скрипти Scala як скрипт оболонки, поставивши нагорі файла директиву "ша банг". Наприклад, наберіть таке в файлі на ім'я <code>helloarg</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="nb">exec</span> scala <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
!#
// Скажи hello першому аргументу
println<span class="o">(</span><span class="s2">&quot;Hello, &quot;</span> + args<span class="o">(</span><span class="m">0</span><span class="o">)</span> + <span class="s2">&quot;!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше <code>#!/bin/sh</code> має бути на самому першому рядку в файлі. Коли ви встановите дозвіл на виконання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ chmod +x helloarg
</pre></div></div></div>
<div class="paragraph"><p>Ви можете виконувати Scala скрипт як скрипт оболонки просто сказавши:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./helloarg globe
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви на Windows, ви можете досягти того самого ефекту, назвавши файл <code>helloarg.bat</code>, та поклавши це нагорі вашого скрипта:
::#!
@echo off
call scala %0 %*
goto :eof
::!#</p></div>
<h1 id="__39">Глосарій</h1>
<div class="paragraph"><p><em><strong>алгебраїчний тип даних</strong></em> Тип, визначений через провадження декількох альтетрнатив, кожна з яких іде зі своїм власним конструктором. Віз зазвичай іде зі способом декомпозиції типу через співпадіння шаблонів. Концепція знайдена в мовах специфікації та функціональних мовах програмування. Алгебраїчні типи даних можуть бути емульовані в Scala через кейс класи.</p></div>
<div class="paragraph"><p><em><strong>альтернатива</strong></em> Гілка виразу <code>match</code>. Вона має форму <code>case pattern =&gt; expression</code>. Інше ім'я для альтернативи є <em>випадок</em>.</p></div>
<div class="paragraph"><p><em><strong>анотація</strong></em> Анотація з'являється в джерельному коді, та прив'язана до деякої частини синтаксису. Анотації обробляються комп'ютером, так що ви можете використовувати їх для ефективного додавання розширень до Scala.</p></div>
<div class="paragraph"><p><em><strong>анонімний клас</strong></em> Анонімний клас є синтетичний субклас, згенерований компілятором Scala з виразу <code>new</code>, в якому за ім'ям класу або трейту ідуть фігурні дужки. Фігурні дужки містять тіло анонімного класу, що може бути порожнім. Однак якщо ім'я, на яке посилається <code>new</code>, посилається на трейт або клас, що містить абстрактні члени, це має бути зроблене суцільним в фігурних дужках, що визначають тіло анонімного субкласу.</p></div>
<div class="paragraph"><p><em><strong>анонімна функція</strong></em> Інша назва для функціонального літералу.</p></div>
<div class="paragraph"><p><em><strong>аргумент</strong></em> Коли викликається функція, аргумент передається для кожного параметра функції. Параметр є змінна, що посилається на аргумент. Аргумент є об'єктом, переданим під час виклику. На додаток, застосування можуть приймати аргументи (командного рядка), що виглядають як <code>Array[String]</code>, переданий до метода <code>main</code> об'єкта синглтона.</p></div>
<div class="paragraph"><p><em><strong>без посилань</strong></em> Дивіться <em>недосяжний</em>.</p></div>
<div class="paragraph"><p><em><strong>безпараметерна функція</strong></em> Функція, що не приймає параметрів, та визначена без жодних порожніх дужок. Виклики безпараметерних функцій не може надавати дужки. Це підтримує принцип уніформного доступу, що дозволяє замінити <code>def</code> на <code>val</code>, без вимог до зміни клієнтського коду.</p></div>
<div class="paragraph"><p><em><strong>блок</strong></em> Один або більше виразів та декларацій, оточених фігурними дужками. Коли блок обчислюється, всі його вирази та декларації обробляються по порядку, та потім блок повертає значення останнього виразу або своє власне значення. Блоки загально використовуються як тіла функцій, для виразів, циклів <code>while</code>, та в усіх інишх місцях, де ви бажаєте згрупіювати декілька твердженя разом. Більш формально, блок це конструкція інкапсуляції, для якої ви можете бачити тільки побічні ефекти або значення результату. Фігурні дужки, в яких ви визначаєте клас або об'єкт, таким чином, не формують блок, оскільки поля та методи (що визначені в ціх фігурних дужках) видимі ззовні. Такі фігурні дужки формують <em>шаблон</em>.</p></div>
<div class="paragraph"><p><em><strong>варіантність</strong></em> Параметр типу класу або трейту може бути відмічений анотацією варіантності, як коваріантний (+) або контрваріантний (-). Так анотації варіантності вказують, як субтипізація робить для класів або трейтів. Наприклад, дженерік клас <code>List</code> є коваріантним по своєму парметру типа, так що <code>List[String]</code> є субтипом <code>List[Any]</code>. По замовчанню, тобто при відсутності анотацій + або -, тип параметрів є <em>неваріантним</em>.</p></div>
<div class="paragraph"><p><em><strong>вільна змінна</strong></em> <em>Вільна змінна</em> в виразі є змінна, що використовується в виразі, але не визначається в виразі. Наприклад, в виразі функціонального літерала <code>(x: Int) =&gt; (x, y)</code> використовуються обидві змінні, <code>x</code> та <code>y</code>, але тільки <code>y</code> є вільною змінною, оскільки вона не визначена всередині виразу.</p></div>
<div class="paragraph"><p><em><strong>видача</strong></em> Вираз може <em>видавати</em> результат. Ключове слово <code>yield</code> позначає результат для виразу <code>for</code>.</p></div>
<div class="paragraph"><p><em><strong>визначення</strong></em> <em>Визначити</em> дещо в програмі Scala означає надати ім'я та реалізацію. Ви можете визначити класи, трейти, об'єкти синглтони, поля, методи, локальні функції, локальні змінні, тощо. Оскільки визначення завжди включає деякий різновид реалізації, абстрактні члени <em>декларовані</em>, але не визначені.</p></div>
<div class="paragraph"><p><em><strong>виклик</strong></em> Ви можете викликати метод, функцію або замикання на аргументах, означаючи, що її тіло буде виконане з заданими аргументами.</p></div>
<div class="paragraph"><p><em><strong>вираз</strong></em> Любий фрагмент Scala коду, що дає результат. Ви також можете сказати, що вираз обчислюється до результату, або має результуюче <em>значення</em>.</p></div>
<div class="paragraph"><p><em><strong>вираз генератора</strong></em> <em>Вираз генератора</em> генерує послідовність значень в виразі <code>for</code>. Наприклад, в <code>for(i &lt;- 1 to 10)</code>, вираз генератора є <code>1 to 10</code>.</p></div>
<div class="paragraph"><p><em><strong>генератор</strong></em> <em>Генератор</em> визначає іменовану <code>val</code>, та присвоює їй набір значень в виразі <code>for</code>. Наприклад, в <code>for(i &lt;- 1 to 10)</code>, генератор є <code>i &lt;- 1 to 10</code>. Значення зправа від <code>&lt;-</code> є вираз генератора.</p></div>
<div class="paragraph"><p><em><strong>декларація</strong></em> Ви можете <em>декларувати</em> абстрактне поле, метод або тип, що надає сутності ім'я, але не реалізацію. Ключова різниця між декларацією та визначенням в тому, що визначення встановлює реалізацію для іменованої сутності, тоді як декларація - ні.</p></div>
<div class="paragraph"><p><em><strong>дженерік клас</strong></em> Клас, що приймає параметри типу. Наприклад, оскільки <code>scala.List</code> приймає параметр типу, <code>scala.List</code> є дженерік класом.</p></div>
<div class="paragraph"><p><em><strong>дженерік трейт</strong></em> Трейт, що приймає параметри типу. Наприклад, оскільки трейт <code>scala.collection.Set</code> приймає параметр типу, він є дженерік трейтом.</p></div>
<div class="paragraph"><p><em><strong>додатковий конструктор</strong></em> Додаткові конструктори визначаються в фігурних дужках визначення класа, що виглядає як визначення методів з ім'ям <code>this</code>, але без типу повернення.</p></div>
<div class="paragraph"><p><em><strong>допоміжна функція</strong></em> Функція, чиє призначення є провадити сервіс до одної або декількох функцій. Допоміжні функції часто реалізовані як локальні функції.</p></div>
<div class="paragraph"><p><em><strong>допоміжний метод</strong></em> Допоміжна функція, що є членом класу. Допоміжні методи часто є приватними.</p></div>
<div class="paragraph"><p><em><strong>еквівалентність</strong></em> Коли використовується без кваліфікації, еквівалентність є відношення, виражене <code>==</code>. Дивіться також <em>еквівалентність посилань</em>.</p></div>
<div class="paragraph"><p><em><strong>еквівалентність посилань</strong></em> Еквівалентність посилань означає, що два посилання ідентифікують той самий  Java об'єкт. Еквівалентність посилань може бути визначена тільки для типів посилань, через виклик <code>eq</code> на <code>AnyRef</code>. (В програмах Java еквівалентність посилань може бути визначена з використанням <code>==</code> на типах посилань Java.)</p></div>
<div class="paragraph"><p><em><strong>замикання</strong></em> Функціональний об'єкт, що захоплює вільні змінні, та, як кажуть, "замкнений" на змінних, видимих під час свого створення.</p></div>
<div class="paragraph"><p><em><strong>застосування</strong></em> Ви можете застосувати метод, функцію або замикання до аргументів, що означає, що ви викликаєте їх на ціх аргументах.</p></div>
<div class="paragraph"><p><em><strong>затінення</strong></em> Нова декларація локальної змінної затінює таку з тим же ім'ям в оточуючому полі зору.</p></div>
<div class="paragraph"><p><em><strong>захисник шаблону</strong></em> В виразі <code>match</code> це альтернатива, захисник шаблону може слідувати за шаблоном. Наприклад, в <code>case x if x % 2 == 0 =&gt; x + 1</code>, захисник шаблону є <code>if x % 2 == 0</code>. Випадок з захисником шаблону буде обраною тільки якщо співпадає шаблон, та захисник шаблону видає <code>true</code>.</p></div>
<div class="paragraph"><p><em><strong>змінна</strong></em> Іменована сутність, що посилається на об'єкт. Змінна є або <code>val</code>, або <code>var</code>. Обоє, <code>val</code> та <code>var</code> мають бути ініціалізовані при визначенні, але тільки <code>var</code> потім можуть бути переприсвоєні, щоб посилатись на інший об'єкт.</p></div>
<div class="paragraph"><p><em><strong>значення</strong></em> Результат любого обчислення або виразу в Scala є значення, та в Scala кожне значення є об'єктом. Термін "значення" в основному означає образ об'єкта в пам'яті (в купі JVM або в стеку).</p></div>
<div class="paragraph"><p><em><strong>імперативний стиль</strong></em> Імперативний стиль програмування підкреслює уважне ставлення до послідовності операцій, так, щоб їх ефект відбувався в вірному порядку. Стиль характеризується ітераціями в циклі, змінами даних на місці, та методами з побічними ефектами. Це домінуюча парадигма таких мов, як C, C++, C# та Java, та контрастує з <em>функціональним стилем</em>.</p></div>
<div class="paragraph"><p><em><strong>інваріант</strong></em> Інваріант використовується в два способи. Це може означати властивість, що завжди має бути <code>true</code>, коли структура даних гарно-сформована. Наприклад, це інваріант для впорядкованого бінарного дерева, що кожний вузол впорядкований перед своїм правим підвузлом, якщо той існує. Інваріант також іноді використовується як синонім до неваріантності: "клас <code>Array</code> є інваріантним по своєму параметру типу".</p></div>
<div class="paragraph"><p><em><strong>ініціалізація</strong></em> Коли змінна визначається в джерельному коді Scala, ви маєте ініціалізувати її значенням об'єкту.</p></div>
<div class="paragraph"><p><em><strong>карування</strong></em> Спосіб записати функцію з декількома списками параметрів. Наприклад, <code>def f(x: Int)(y: Int)</code> є карована функція з двома списками параметрів. Карована функція застосовується передачею декількох списків аргументів, як <code>f(3)(4)</code>. Однак, також можливо написати часткове застосування карованої функції, як <code>f(3)</code>.</p></div>
<div class="paragraph"><p><em><strong>клас</strong></em> Визначається ключовим словом <code>class</code>, клас може бути або абстрактним, або суцільним, та може бути параметризований типами та значеннями при створенні примірника. В виразі <code>new Array[String](2)</code> клас, примірник якого створюється, є <code>Array</code>, і тип значення, що утворюється, є <code>Array[String]</code>. Клас, що приймає параметри типів називається <em>конструктором типів</em>. Також можна сказати, що тип має свій клас: наприклад, клас типу <code>Array[String]</code> є <code>Array</code>.</p></div>
<div class="paragraph"><p><em><strong>клас компанйон</strong></em> Клас, що поділяє те саме ім'я з об'єктом синглтоном, визначеним в тому ж джерельному файлі. Клас є класом компанйоном синглтон об'єкта.</p></div>
<div class="paragraph"><p><em><strong>коваріантність</strong></em> <em>Коваріантна</em> анотація може бути застосована до параметру типу класа або трейта, через покладання знаку плюс (+) перед параметром типу. Клас або трейт потім утворює субтипи коваріантно — в тому самому напрямку — до анотованого параметром типу. Наприклад, <code>List</code> є коваріантним в своєму параметрі типу, так що <code>List[String]</code> є субтипом <code>List[Any]</code>.</p></div>
<div class="paragraph"><p><em><strong>конструктор типу</strong></em> Клас або трейт, що приймає параметри типу.</p></div>
<div class="paragraph"><p><em><strong>контрваріантність</strong></em> <em>Контрваріантна</em> анотація може бути застосована до параметру типу класу або трейту, через покладання знаку мінус (-) перед параметром типу. Клас або трейт потім утворює субтипи контрваріантно — в протилежному напрямку — до анотованого типом параметру. Наприклад, <code>Function1</code> є контрваріантною в своєму першому параметрі, так що <code>Function1[Any, Any]</code> є субтипом <code>Function1[String, Any]</code>.</p></div>
<div class="paragraph"><p><em><strong>літерал</strong></em> <code>1</code>, <code>"One"</code>, та <code>(x: Int) =&gt; x + 1</code> є прикладами літералів. Літерал є скороченням для опису об'єкта, коли скоровення в точності відображує структуру створюваного об'єкту.</p></div>
<div class="paragraph"><p><em><strong>локальна змінна</strong></em> Локальна змінна є <code>val</code> або <code>var</code> визначена в блоці. Хоча подібні до локальних змінних, параметри функцій не посилаються як на локальні змінні, але просто як на параметри або "змінні", без "локальні".</p></div>
<div class="paragraph"><p><em><strong>локальна функція</strong></em> Локальна функція є <code>def</code>, визначений в блоці. Для контрасту, <code>def</code>, визначена як слен класу, трейту або об'єкту синглтону називається методом.</p></div>
<div class="paragraph"><p><em><strong>мета-програмування</strong></em> Мета-програмування програмного забезпечення є програми, які на вході також мають програми. Компіляттори є мета-програмами, як і інструменти, як scaladoc. Програми мета-програмування потрібні для робити будь що за допомогою анотацій.</p></div>
<div class="paragraph"><p><em><strong>метод</strong></em> Метод є функція, що є членом днякого класу, трейту або об'єкта синглтона.</p></div>
<div class="paragraph"><p><em><strong>метод без параметрів</strong></em> Метод <em>без параметрів</em> є функція без параметрів, що є членом класу, трейта або об'єкта синглтона.</p></div>
<div class="paragraph"><p><em><strong>міксін</strong></em> Міксін є назвою трейта, коли він застосований в міксін композиції. Іншими словами, в <code>trait Hat</code>, <code>Hat</code> є просто трейтом, але в <code>new Cat extends AnyRef with Hat</code>, <code>Hat</code> може бути названий міксіном. Коли використовується як дієслово, "mix in" є двома словами. Наприклад, ви можете міксувати трейти в класи або інші трейти.</p></div>
<div class="paragraph"><p><em><strong>міксін композиція</strong></em> Процес міксування трейтів в класи або інші трейти. Міксін композиція відрізняється від традиційного множинного наслідування, в тому, що тип посилання <code>super</code> невідомий в точці визначення трейта, але скоріше визначається поновій кожного разу, коли трейт міксується в клас або інший трейт.</p></div>
<div class="paragraph"><p><em><strong>множинне визначення</strong></em> Той самий вираз може бути присвоєний в декількох визначеннях, якщо ви використовуєте синтаксис <code>val v1, v2, v3 = exp</code>.</p></div>
<div class="paragraph"><p><em><strong>модифікатор</strong></em> Ключове слово, що кваліфікує визначення класу, трейта, поля або метода, в деякий спосіб. Наприклад, модифікатор <code>private</code> вказує що клас, трейт, поле або метод буде визначений, як приватний.</p></div>
<div class="paragraph"><p><em><strong>напів-структуровані дані</strong></em> Дані XML є напів структурованими. Вони більш структуровані, ніж суцільно бінарний файл, або текстовий файл, але вони не мають повної структури, як структури даних в мовах програмування.</p></div>
<div class="paragraph"><p><em><strong>неваріантність</strong></em> Параметр типу класу або трейта по замовчанню є неваріантним. При цьому клас або трейт не утворює субтип при зміні параметрів. Наприклад, оскільки клас <code>Array</code> є неваріантним по своєму параметру типа, <code>Array[String]</code> не є ні субтипом, ані супертипом <code>Array[Any]</code>.</p></div>
<div class="paragraph"><p><em><strong>недосяжні значення</strong></em> На рівні Scala об'єкти можуть стати недосяжні, та в цій точці пам'ять, що вони займають, повертається в рантайм. Недосяжність не обов'язково означає <em>без посилань</em>. Типи посилань (примірники <code>AnyRef</code>) реалізовані як об'єкти, що розташовуються в купі JVM. Коли примірник типу посилання стає недосяжний, він дійсно стає без посилань, і стає предметом збирача сміття. Типи значень (примірники <code>AnyVal</code>) реалізовані одночасно як примітивні типи значень, або примірники типів огорток Java (таких як <code>java.lang.Integer</code>), що розташовуються в купі. Примірники типів значень можуть бути боксовані (перетворені з примітивних значень до об'єкту огортки) та розбоксовані (перетворені з об'єкта огортки на примітивне значення) на протязі життєвого циклу змінних, що посилаються на значення. Якщо примірник типу значення наразі представлено як об'єкт огортки в купі JVM, і він стає недосяжним, він також стає без посилань, та доступний для збору сміття. Але якщо тип значення наразі представлений як примітивне значення, та стає недосяжним, тоді він не втрачає посилань, оскільки він не існує як об'єкт в купі JVM, щонайменьше в цій точці часу. Рантайм може повернути пам'ять, зайняту недосяжними об'єктами, але якщо, наприклад, <code>Int</code>, реалізований під час виконання як примітив  Java <code>int</code>, що займає деяку пам'ять у фреймі стеку, тоді пам'ять для цього об'єкту "відновлюється", коли фрейм стеку виштовхується при завершенні метода. Пам'ять для типів посилань, такі як String, може бути відновлена збирачем сміття JVM, після того, як вони стали недосяжними.</p></div>
<div class="paragraph"><p><em><strong>незмінний</strong></em> Об'єкт є <em>незмінним</em>, якщо його значення не може бути зміненим після його створення в жодний спосіб, видимий для клієнтів. Об'єкти можуть бути або не бути змінними.</p></div>
<div class="paragraph"><p><em><strong>об'єкт компанйон</strong></em> Об'єкт синглтон, що поділяє те саме ім'я з класом, визначеним в тому самому джерельному файлі. Компанйон об'єкти та класи мають доступ до приватних членів один одного. На додаток, любі неявні перетворення, визначені в компанйон об'єкті, будуть в полі зору будь-де, де використовується клас.</p></div>
<div class="paragraph"><p><em><strong>об'єкт синглтон</strong></em> Об'єкт, визначений за допомогою ключового слова <code>object</code>. Кожний об'єкт синглтон має один, і тільки один примірник. Об'єкт синглтон, що поділяє ім'я з класом, та визначений в тому самому джерельному файлі, що і клас, є об'єктом компанйоном цього класу. Клас є його класом компанйоном. Об'єкт синглтон, що не має класа компанйона, є <em>окремим об'єктом</em>.</p></div>
<div class="paragraph"><p><em><strong>обмеження типу</strong></em> Деякі анотації є обмеженнями типу, що означає, що вони додають межі, або обмеження на значення, які включає тип. Наприклад, <code>@positive</code> може бути обмеженням типу на типі <code>Int</code>, обмежуючи тип  32-бітних цілих до додатніх значень. Обмеження тиаів не перевіряються стандартним компілятором Scala, та замість цього мають бути перевірені зовнішінім інструментом, або плагіном компілятора.</p></div>
<div class="paragraph"><p><em><strong>окремий об'єкт</strong></em> Об'єкт синглтон, що не має класа компанйона.</p></div>
<div class="paragraph"><p><em><strong>операція</strong></em> В Scala, кожна <em>операція</em> є викликом метода. Методи можуть бути викликані в операторній нотації, як <code>b + 2</code>, та в цій нотації <code>+</code> є оператором.</p></div>
<div class="paragraph"><p><em><strong>охоплення <code>for</code></strong></em> Інша назва для _виразу <code>for_</code>.</p></div>
<div class="paragraph"><p><em><strong>параметр</strong></em> Функції можуть мати нуль або більше параметрів. Кожний параметр має ім'я та тип. Різниця між параметрами та аргументами в тому, що аргументи посилаються на дійсні передані об'єкти, коли функція викликається. Параметри є змінними, що посилаються на ці передані аргументи.</p></div>
<div class="paragraph"><p><em><strong>параметр за-значенням</strong></em> Параметр, що <em>не</em> позначений <code>=&gt;</code> перед типом параметру, як в <code>(x: Int)</code>. Аргумент, що відповідає параметру за-значенням, обчислюється перед викликом метода. Параметри за-значенням відрізняються від параметрів <em>за-ім'ям</em>.</p></div>
<div class="paragraph"><p><em><strong>параметр за-ім'ям</strong></em> Парметр, що позначений <code>=&gt;</code> перед типом параметра, як в <code>(x: =&gt; Int)</code>. Аргумент, що відповідає параметру за ім'ям, обчислюється не перед викликом метода, але кожного разу, коли на параметр є посилання <em>за ім'ям</em> в методі. Якщо параметр не є параметром за-ім'ям, він є <em>за-значенням</em>.</p></div>
<div class="paragraph"><p><em><strong>параметр типу</strong></em> Параметр дженерік класу або дженерік методу, що має бути заповнений типом. Наприклад, клас <code>List</code> визначений як <code>class List[T] { ...</code>, та метод <code>identity</code>, член об'єкта <code>Predef</code>, визначений як <code>def identity[T](x:T) = x</code>. T в обох випадках є параметром типу.</p></div>
<div class="paragraph"><p><em><strong>параметричне поле</strong></em> Поле, визначене як параметр класу.</p></div>
<div class="paragraph"><p><em><strong>переприсвоєння</strong></em> Змінна може бути, або не бути переприсвоюваною. <code>var</code> повторно присвоюється, тоді як <code>val</code> - ні.</p></div>
<div class="paragraph"><p><em><strong>первинний конструктор</strong></em> Головний конструктор класу, що викликає конструктор суперкласу, якщо це потрібно, ініціалізує поля переданими значеннями, та виконує високорівневий код, визначений між фігурними дужками класу. Поля ініціалізовані тільки для значень параметрів, не переданих до конструктора суперкласів, за винятком таких, що не використовуються в тілі класу, і, таким чином, можуть бути "оптимізовані" геть.</p></div>
<div class="paragraph"><p><em><strong>першокласна функція</strong></em> Scala підтримує <em>першокласні функції</em>, що означає, що ви можете виразити функції в синтаксисі <em>функціональних літералів</em>, тобто, <code>(x: Int) =&gt; x + 1</code>, і ці функції можуть представлені об'єктами, що називаються <em>функціональними значеннями</em>.</p></div>
<div class="paragraph"><p><em><strong>підстановочний тип</strong></em> Підстановочний тип включає посилання на змінні типів, що наразі невідомі. Наприклад, <code>Array[_]</code> є підстановочним типом. Це масив, де елемент типу повністю невідомий.</p></div>
<div class="paragraph"><p><em><strong>повернення</strong></em> Функція в програмі Scala повертає значення. Ви можете назвати це значення результатом функції. Ви також можете сказати, що результатом функції є значення. Результат кожної функції в Scala є об'єкт.</p></div>
<div class="paragraph"><p><em><strong>повідомлення</strong></em> Актори комунікують один з одним через надсилання один одному повідомлень. Надсилання повідомлення не перериває те, що робить отримувач. Отримувач може зачекати, доки він скінчить свою поточну активність, та їх інваріанти будуть дотримуватись.</p></div>
<div class="paragraph"><p><em><strong>посилається</strong></em> Змінна в роблячій програмі Scala завжди посилається на деякий об'єкт. Навіть якщо змінній присвоєне <code>null</code>, вона концептуально посилається на об'єкт <code>Null</code>. Під час виконання об'єкт може бути реалізований як Java об'єкт або значення примітивного типу, але Scala дозволяє програмістам думати на вищому рівні абстракції щодо їх кода, як вони уявляють виконання. Також дивіться <em>посилання</em>.</p></div>
<div class="paragraph"><p><em><strong>посилання</strong></em> Посилання в абстракціях Java є вказівник, що унікально ідентифікує об'єкт, що знаходиться на купі JVM. Тип посилання змінних містить посилання на об'єкти, оскільки типи посилання (примірники <code>AnyRef</code>) реалізовані як Java об'єкти, що зберігаються на купі JVM. Для контрасту, змінні типу значення можуть іноді містити посилання (на боксований тип огортки), та іноді ні (коли об'єкт представлений як примітивне значення). Кажучи загалом, змінна Scala посилається на об'єкт. Термін "посилається" більш абстрактний, ніж "містить посилання". Якщо змінна є типу <code>scala.Int</code> наразі представлена як примітивне значення Java <code>int</code>, тоді змінна все ще посилається на об'єкт <code>Int</code>, але посилання не задіяне.</p></div>
<div class="paragraph"><p><em><strong>предикат</strong></em> Предикат є функцією з типом результату <code>Boolean</code>.</p></div>
<div class="paragraph"><p><em><strong>прив'язана змінна</strong></em> Прив'язана змінна в виразі є змінна, що є одночасно визначена та використана в виразі. Наприклад, в виразі функціонального літерала <code>(x: Int) =&gt; (x, y)</code>, використовуються обоє змінні, <code>x</code> та <code>y</code>, але тільки <code>x</code> прив'язана, оскільки вона визначається в виразі як <code>Int</code>, і є єдиним аргументом функції, визначеній цім виразом.</p></div>
<div class="paragraph"><p><em><strong>примірник</strong></em> Примірник, або примірник класу, є об'єктом, концепцією, що існує тільки під час виконання.</p></div>
<div class="paragraph"><p><em><strong>принцип уніформного доступу</strong></em> Принцип уніформного доступу стверджує, що змінні та функції без параметрів повинні отримувати доступ за однаковим синтаксисом. Scala підтримує цей принцип, не дозволяючи ставити дужки в місці виклику функцій без параметрів. Як результат, визначення функції без параметрів може бути змінена на <code>val</code>, або навпаки, без впливу на код клієнта.</p></div>
<div class="paragraph"><p><em><strong>присвоєння</strong></em> Ви можете присвоїти об'єкт до змінної. Після цього змінна буде посилатись на об'єкт.</p></div>
<div class="paragraph"><p><em><strong>прозорість посилання</strong></em> Властивість функцій, що незалежні від тимчасового контексту, та не мають побічних ефектів. Для певного вводу виклик прозорої до посилання функції може бути замінене не її результат, без зміни семантики програми.</p></div>
<div class="paragraph"><p><em><strong>процедура</strong></em>  <em>Процедура</em> є функція, результат якої <code>Unit</code>, і яка, таким чином, виконується виключно для її побічних ефектів.</p></div>
<div class="paragraph"><p><em><strong>прямий субклас</strong></em> Клас є <em>прямим субкласом</em> свого прямого суперкласу.</p></div>
<div class="paragraph"><p><em><strong>прямий суперклас</strong></em> Клас, від якого клас або трейт напрму походить, найближчий клас вище в його ієрархії наслідування. Якщо клас <code>Parent</code> споминається в опціональному твердженні <code>extends</code> класу <code>Child</code>, тоді <code>Parent</code> є прямим суперкласом <code>Child</code>. Якщо трейт вказується в твердженні <code>extends</code> <code>Child</code>, прямий суперклас трейту є прямим суперкласом <code>Child</code>. Якщо <code>Child</code> не має твердження <code>extends</code>, тоді <code>AnyRef</code> є прямим суперкласом <code>Child</code>. Якщо прямий суперклас класу приймає параметри типу, наприклад, <code>class Child extends Parent[String]</code>, прямий суперклас <code>Child</code>  все ще <code>Parent</code>, не <code>Parent[String]</code>. З іншого боку, <code>Parent[String]</code> буде прямим супертипом <code>Child</code>. Дивіться <em>супертип</em> щодо більшої дискусії про різницю між класами і типами.</p></div>
<div class="paragraph"><p><em><strong>рантайм</strong></em>  Середовище виконання Java Virtual Machine, або JVM, що виконує Scala програму. Рантайм охоплює обоє, віртуальну машину, як визначено в Java Virtual Machine Specification, та бібліотеки рантайму Java API і стандартного Scala API. Фраза <em>run time</em> (з проміжком між <code>run</code> та <code>time</code>) означає саме час, коли виконується програма, та контрастує з часом компіляції.</p></div>
<div class="paragraph"><p><em><strong>рантайм тип</strong></em> Тип об'єкта під час виконання. Для контрасту, <em>статичний тип</em> є типом виразу під час компіляції. Більшість типів рантайму просто звичайні типи, без параметрів типу. Наприклад, рантайм типу <code>"Hi"</code> є <code>String</code>, та рантайм тип <code>(x: Int) =&gt; x + 1</code> є <code>Function1</code>. Рантайм типи можуть бути перевірені за допомогою <code>isInstanceOf</code>.</p></div>
<div class="paragraph"><p><em><strong>результат</strong></em> Вираз в програмі Scala дає результат. Результат кожного виразу в Scala є об'єктом.</p></div>
<div class="paragraph"><p><em><strong>рекурсивність</strong></em> Функція є рекурсивною, якщо вона викликає сама себе.</p></div>
<div class="paragraph"><p><em><strong>селектор</strong></em> Значення, що буде порівнюватись в виразі <code>match</code>. Наприклад, в <code>s match { case _ =&gt; }</code>, селектор є <code>s</code>.</p></div>
<div class="paragraph"><p><em><strong>серіалізація</strong></em> Ви можете серіалізувати об'єкт в потік байтів, що потім може бути збережений або переданий по мережі. Ви можете пізніше де-серіалізувати потік байтів, навіть на іншому комп'ютері, та отримати об'єкт, що той самий, що і оригінальний серіалізований об'єкт.</p></div>
<div class="paragraph"><p><em><strong>сигнатура</strong></em> Сигнатура є скороченням від <em>сигнатури типів</em>.</p></div>
<div class="paragraph"><p><em><strong>сигнатура типу</strong></em> Сигнатура типу метода складається з імені, числа, порядку, та типів його параметрів, якщо такі є, та його результуючого типу. Тип сигнатури класу, трейта, або об'єкта синглтона складається з його імені, типу сигнатур всіх його членів та конструкторів, та його задекларованих відношень наслідування та міксінів.</p></div>
<div class="paragraph"><p><em><strong>синтетичний клас</strong></em> Синтетичний клас є згенерований автоматично компілятором, скоріше, ніж бути написаним руками програміста.</p></div>
<div class="paragraph"><p><em><strong>скрипт</strong></em> Файл, що містить високорівневі визначення та твердження, що може бути виконаний напряму за допомогою <code>scala</code>, без явної компіляції. Скрип має завершувати виразом, не визначенням.</p></div>
<div class="paragraph"><p><em><strong>статичний тип</strong></em> Дивіться <em>тип</em>.</p></div>
<div class="paragraph"><p><em><strong>створення примірнику</strong></em> Створити примірник класу означає створити новий об'єкт з класу, дія, що відбувається тільки під час виконання.</p></div>
<div class="paragraph"><p><em><strong>субклас</strong></em> Клас є субкласом для всіх своїх суперкласів та супертрейтів.</p></div>
<div class="paragraph"><p><em><strong>субтип</strong></em> Компілятор буде дозволяти любий з субтипів типу використовуваться як замінник, коли вимагається використання типу. Для класів та трейтів, що не приймають параметрів типу, відношення субтипів відзеркалює відношення субкласів. Наприклад, якщо клас <code>Cat</code> є субкласом абстрактного класу <code>Animal</code>, та жодний не приймає параметрів типу, тип <code>Cat</code> є субтипом <code>Animal</code>. Подібно до цього, якщо трейт <code>Apple</code> є субтрейтом трейту <code>Fruit</code>, та жодний не приймає параметрів, тип <code>Apple</code> є субтипом типу <code>Fruit</code>. Однак для класів та трейтів, що приймають параметри типу, в гру вступає варіантність. Наприклад, оскільки абстрактний клас <code>List</code> декларований коваріантним по своєму єдиному параметру типа (тобто, <code>List</code> декларований як <code>List[+A]</code>), <code>List[Cat]</code> є субтипом <code>List[Animal]</code>, та <code>List[Apple]</code> є субтипом <code>List[Fruit]</code>. Ці відношення субтипів існують навіть не зважаючи на те, що клас кожного з ціх типів є <code>List</code>. Для контрасту, оскільки <code>Set</code> не декларований як коваріантний по своєму параметру типа (тобто, <code>Set</code> декларований як <code>Set[A]</code> без знака плюс), <code>Set[Cat]</code> не є субтипом <code>Set[Animal]</code>. Субтип повинен коректно реалізувати контракти супертипів, так що тут застосовуюється Принцип Заміни Ліскова, але компілятор тільки перевіряє цю властивість на рівні перевірки типів.</p></div>
<div class="paragraph"><p><em><strong>субтрейт</strong></em> Трейт є субтрейтом для всіх своїх супертрейтів.</p></div>
<div class="paragraph"><p><em><strong>суперклас</strong></em> Суперкласу класу включають всі прямі суперкласи, прямі суперкласи ціх суперкласів, і так далі, аж до <code>Any</code>.</p></div>
<div class="paragraph"><p><em><strong>супертип</strong></em> Тип є супертипом всіх своїх субтипів.</p></div>
<div class="paragraph"><p><em><strong>супертрейт</strong></em> Супертрейти класу або трейтів, якщо такі є, включають всі трейти, напряму зміксовані в клас або трейт любого зі своїх суперкласів, плюс любі супертрейти ціх трейтів.</p></div>
<div class="paragraph"><p><em><strong>твердження</strong></em> Вираз, визначення або імпорт, тобто речі, що можуть іти в шаблоні або блоці в джерельному коді Scala.</p></div>
<div class="paragraph"><p><em><strong>тип</strong></em> Кожна змінна та вираз в програмі Scala має тип, що відомий під час компіляції. Тип обмежує можливі значення, на які може посилатись змінна, або яке може продукувати вираз під час виконання. Змінна або тип виразу також може посилатись на статичний тип, якщо треба відрізняти його від типу об'єкту під час виконання. Іншими словами, "тип" сам по собі означає статичний тип. Тип відрізняється від класу, бо клас, що приймає параметри типу, може конструювати багато типів. Наприклад, <code>List</code> є класом, але не типом. <code>List[T]</code> є типом з вільним параметром типу. <code>List[Int]</code> та <code>List[String]</code> також є типами (так звані заземлені типи, бо не мають вільних параметрів типів). Тип може мати "клас" або "трейт." Наприклад, клас типу <code>List[Int]</code> є <code>List</code>. Трейт типу <code>Set[String]</code> є <code>Set</code>.</p></div>
<div class="paragraph"><p><em><strong>тип значення</strong></em> Тип значення є любим субкласом <code>AnyVal</code>, такий як <code>Int</code>, <code>Double</code>, або <code>Unit</code>. Цей термін має значення на рівні джерельного коду Scala. Під час виконання примірники значень типів, що відповідають до примітивних типів Java, можуть бути реалізовані в термінах значень примітивних типів або примірників класів огорток, таких як <code>java.lang.Integer</code>. Під час життєвого циклу примірника рантайм може трансформувати тип між примітивним типом та огорткою (тобто, боксувати та розбоксувати змінну).</p></div>
<div class="paragraph"><p><em><strong>тип посилання</strong></em> Тип посилання є субкласом <code>AnyRef</code>. Примірники типу посилання під час виконання знаходяться в купі JVM.</p></div>
<div class="paragraph"><p><em><strong>тип результату</strong></em> Тип результату метода є тип значення, що є результатом виклику метода. (В Java, ця концепція називається <em>типом повернення</em>.)</p></div>
<div class="paragraph"><p><em><strong>тип <code>self</code></strong></em>  _Тип <code>self`_ трейта є удаваний тип `this</code>, отримувача, що буде використовуватись в цьому трейті. Любий суцільний клас, що міксує трейт, має переконатись, що цей тип відповідає до типу трейта <code>self</code>. Найбільш загальне використання типів <code>self</code> є для поділення великих класів на декілька трейтів, як описано в Главі 29.</p></div>
<div class="paragraph"><p><em><strong>трейт</strong></em> Трейт, що визначений за допомогою ключового слова <code>trait</code>, подібний до абстрактного класу, що не може приймати жодних значень параметрів, та може бути "заміксований" в класи або інші трейти через процес, відомий як міксін композиція. Коли клас міксується в клас або трейт, він називається міксіном. Трейт може бути параметризований одним або більше типами. Коли трейт параметризований типами, він створює тип. Наприклад, <code>Set</code> ґ трейтом, що приймає один параметр типу, тоді як <code>Set[Int]</code> є типом. Також кажуть, що <code>Set</code> є "трейтом типу" <code>Set[Int]</code>.</p></div>
<div class="paragraph"><p><em><strong>удосконалення типу</strong></em> Тип, сформований через надання базовому типу декількох членів в фігурних дужках. Члени в фігурних дужках удосконалюють типи, що присутні в базовому типі. Наприклад, тип "animal that eats grass" є <code>Animal { type SuitableFood = Grass }</code>.</p></div>
<div class="paragraph"><p><em><strong>фільтр, або вираз фільтру</strong></em> <code>if</code>, за яким слідує логічний виразв виразі <code>for</code>. В <code>for(i &lt;- 1 to 10; if i % 2 == 0)</code> фільтр є <code>if i % 2 == 0</code>. Значення зправа від <code>if</code> є виразом фільтра.</p></div>
<div class="paragraph"><p><em><strong>фільтруючий вираз</strong></em> Фільтруючий вираз, або вираз фільтру, є логічний вираз, що слідує за <code>if</code> в виразі <code>for</code>. В <code>for(i &lt;- 1 to 10; if i % 2 == 0)</code> вираз фільтру є "i % 2 == 0".</p></div>
<div class="paragraph"><p><em><strong>функціональне значення</strong></em> Об'єкт функції, що може бути викликаний так само, як люба інша функція. Клас функціонального значення розширює один з трейтів <code>FunctionN</code> (тобто, <code>Function0</code>, <code>Function1</code>) з пакунку <code>scala</code>, та and isusually expressed in source code via function literal syntax. A function value is "invoked" when its apply method is called. A function value that captures free variables is a <em>closure</em>.</p></div>
<div class="paragraph"><p><em><strong>функціональний літерал</strong></em> Функція без імені в джерельному коді Scala, задана за допомогою синтаксису функціонального літералу. Наприклад, <code>(x: Int, y: Int) =&gt; x + y</code>.</p></div>
<div class="paragraph"><p><em><strong>функція</strong></em> <em>Функція</em> може бути <em>викликана</em> зі списком аргументів, щоб спродукувати результат. Функція має список параметрів, тіло, та тип результата. Функції, що є членами класу, трейта або об'єкта синглтона, називаються <em>методами</em>. Функції, визначені в інших функціях, називаються <em>локальними функціями</em>. Функції, тип результата яких є <code>Unit</code> називаються <em>процедурами</em>. Анонімні функції в джерельному коді називаються <em>функціональними літералами</em>. Під час виконання функціональні літерали стають примірниками об'єктів, що називаються <em>функціональними значеннями</em>.</p></div>
<div class="paragraph"><p><em><strong>функціональний стиль</strong></em> <em>Функціональний стиль</em> програмування наголошує на функціях та обчисленні результатів, та не робить наголос на порядку, в якому трапляються оператори. Стиль характеризується передачею функціональних значень в циклічні методи, незмінними даними, методами без побічних ефектів. Це домінантна парадигма таких мов, як Haskell та Erlang, та контастує з <em>імперативним стилем</em>.</p></div>
<div class="paragraph"><p><em><strong>хвостова рекурсія</strong></em> Функція має хвостову рекурсію, якщо єдине місце, де вона викликає сама себе - це остання операція функції.</p></div>
<div class="paragraph"><p><em><strong>цільова типізація</strong></em> Цільова типізація є формою виводу типів, що приймає до уваги очікуваний тип. Наприклад, в <code>nums.filter((x) =&gt; x &gt; 0)</code>, компілятор Scala виводить тип <code>x</code> як тип елементів <code>nums</code>, оскільки метод <code>filter</code> викликає функцію на кожному елементі <code>nums</code>.</p></div>
<div class="paragraph"><p><em><strong>частково застосована функція</strong></em> Функція, що використовується в виразі, та в якій відсутні деякі з його аргументів. Наприклад, якщо функція <code>f</code> має тип <code>Int =&gt; Int =&gt; Int</code>, тоді <code>f</code> та <code>f(1)</code> є частково застосовані функції.</p></div>
<div class="paragraph"><p><em><strong>член</strong></em> Член це любий іменований елемент шаблона класу, трейта або об'єкта синглтона. Член може бути доступний через ім'я власника, крапку, та просте ім'я члену. Наприклад, високорівневі поля та методи, визначені в класі, є членами цього класу. Трейт, визначений в класі, є членом оточуючого класу. Тип, визначений за допомогою ключового слова <code>type</code> в класі, є членом цього класу. Клас є членом пакунку, в якому він визначений. Для контрасту, локальна змінна або локальна функція не є членом свого оточуючого блока.</p></div>
<div class="paragraph"><p><em><strong>шаблон класа</strong></em> Шаблон є тілом визначення класу, трейта, або об'єкта синглтона. Він визначає тип сигнатури, поведінки та початковий стан класу, трейта або об'єкта.</p></div>
<div class="paragraph"><p><em><strong>шаблон порівняння</strong></em> В виразі <code>match</code> альтернативі, шаблон слідує за кожним ключовим словом <code>case</code> та стоїть перед або захисником шаблона, або перед символом <code>=&gt;</code>.</p></div>
<div class="paragraph"><p><em><strong>шляхо-залежний тип</strong></em> Тип, як <code>swiss.cow.Food</code>. Частина <code>swiss.cow</code> є шляхом, що формує посилання на об'єкт. Значення типу чутлива до шляху, що ви використовуєте для доступа до нього. Наприклад, типи <code>swiss.cow.Food</code> та <code>fish.Food</code> є різними типами.</p></div>
<div class="paragraph"><p><em><strong>JVM</strong></em> JVM є Java Virtual Machine, або рантайм, середовище виконання, що містить програму, що виконується Scala програма.</p></div>
<div class="sect1">
<h2 id="__40">Бібліографія</h2>
<div class="sectionbody">
<div class="paragraph"><p>[Ray99] Raymond, Eric. The Cathedral &amp; the Bazaar: Musings on Linux and Open Source by an Accidental Revolutionary. O&#8217;Reilly, 1999.</p></div>
<div class="paragraph"><p>[Blo08] Bloch, Joshua. Effective Java Second Edition. Addison-Wesley, 2008.</p></div>
<div class="paragraph"><p>[Bay72] Bayer, Rudolf. Symmetric binary B-Trees: Data structure and maintenance algorithms. Acta Informatica, 1(4):290-306, 1972.</p></div>
<div class="paragraph"><p>[SPJ02] Simon Peyton Jones, et.al. Haskell 98 Language and Libraries, Revised Report. Technical report, <a href="http://www.haskell.org/onlinereport">http://www.haskell.org/onlinereport</a>, 2002.</p></div>
<div class="paragraph"><p>[Vaz07] Vaziri, Mandana, Frank Tip, Stephen Fink, and Julian Dolby. Declarative Object Identity Using Relation Types. In Proc. ECOOP 2007, pages 54-78. 2007.</p></div>
<div class="paragraph"><p>[Mey91] Meyers, Scott. Effective C++. Addison-Wesley, 1991.</p></div>
<div class="paragraph"><p>[Rum04] Rumbaugh, James, Ivar Jacobson, and Grady Booch. The Unified Modeling Language Reference Manual (2nd Edition). Addison-Wesley, 2004.</p></div>
<div class="paragraph"><p>[Goe06] Goetz, Brian, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Homes, and Doug Lea. Java Concurrency in Practice. Addison Wesley, 2006.</p></div>
<div class="paragraph"><p>[Mey00] Meyer, Bertrand. Object-Oriented Software Construction. Prentice Hall, 2000.</p></div>
<div class="paragraph"><p>[Eck98] Eckel, Bruce. Thinking in Java. Prentice Hall, 1998.</p></div>
<div class="paragraph"><p>[Eva03] Evans, Eric. Domain-Driven Design: Tackling Complexity in the Heart of Software. Addison- Wesley Professional, 2003.</p></div>
<div class="paragraph"><p>[Aho86] Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. Compilers: Principles, Techniques, and Tools. Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA, 1986. ISBN 0- 201-10088-6.</p></div>
<div class="paragraph"><p>[Abe96] Abelson, Harold and Gerald Jay Sussman. Structure and Interpretation of Computer Programs. The MIT Press, second edition, 1996.</p></div>
<div class="paragraph"><p>[Ode03] Odersky, Martin, Vincent Cremet, Christine Röckl, and Matthias Zenger. A Nominal Theory of Objects with Dependent Types. In Proc. ECOOP&#8217;03, Springer LNCS, pages 201-225. July 2003.</p></div>
<div class="paragraph"><p>[Ode11] Odersky, Martin. The Scala Language Specification, Version 2.9. EPFL, May 2011. Available on the web at <a href="http://www.scala-lang.org/docu/manuals.html">http://www.scala-lang.org/docu/manuals.html</a> (accessed April 20, 2014).</p></div>
<div class="paragraph"><p>[Ode05] Odersky, Martin and Matthias Zenger. Scalable Component Abstractions. In Proceedings of OOPSLA, pages 41-58. October 2005.</p></div>
<div class="paragraph"><p>[Emi07] Emir, Burak, Martin Odersky, and John Williams. Matching Objects With Patterns. In Proc. ECOOP, Springer LNCS, pages 273-295. July 2007.</p></div>
<div class="paragraph"><p>[Ste99] Steele, Jr., Guy L. Growing a Language. Higher-Order and Symbolic Computation, 12:221- 223, 1999. Transcript of a talk given at OOPSLA 1998.</p></div>
<div class="paragraph"><p>[Jav] The Java Tutorials: Creating a GUI with JFC/Swing. Available on the web at <a href="http://java.sun.com/docs/books/tutorial/uiswing">http://java.sun.com/docs/books/tutorial/uiswing</a>. [Lan66] Landin, Peter J. The Next 700 Programming Languages.Communications of the ACM, 9(3):157-166, 1966.</p></div>
<div class="paragraph"><p>[Fow04] Fowler, Martin. Inversion of Control Containers and the Dependency Injection pattern. January 2004. Available on the web at <a href="http://martinfowler.com/articles/injection.html">http://martinfowler.com/articles/injection.html</a> (accesssed August 6, 2008).</p></div>
<div class="paragraph"><p>[Gam95] Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides.Design Patterns : Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995.</p></div>
<div class="paragraph"><p>[Kay03] Kay, Alan C. An email to Stefan Ram on the meaning of the term “object-oriented programming”, July 2003. The email is published on the web at <a href="http://www.purl.org/stefan_ram/pub/doc_kay_oop_en">http://www.purl.org/stefan_ram/pub/doc_kay_oop_en</a> (accesssed June 6, 2008).</p></div>
<div class="paragraph"><p>[Dij70] Dijkstra, Edsger W. Notes on Structured Programming., April 1970. Circulated privately. Available at <a href="http://www.cs.utexas.edu">http://www.cs.utexas.edu</a> /users/EWD/ewd02xx/EWD249.PDF as EWD249 (accessed June 6, 2008).
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___72">Про авторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Martin Odersky є створювачем мови Scala. Він є професором EPFL в Лозані, Швейцарія, та засновником Typesafe, Inc. Він робить з програмними мовами та системами, більш точно над темами, як скомбінувати об'єктно-орієнтовне та функціональне програмування. З 2001го року він зконцентрований на розробці, реалізації та покращенні Scala. До цього він зазнав впливу розробки Java в якості спів-розробника дженериків Java, та як оригінальний автор поточного референсного компілятора javac. Він є товаришем ACM.</p></div>
<div class="paragraph"><p>Lex Spoon є софтверний інженер в Semmle, Ltd. Він робив над Scala протягом двох років в якості пост-докторської практики в EPFL. Він отримав доктоорську ступінь в  Georgia Tech, де він робив над статистичним аналізом динамічних мов. На додаток до Scala він допомагав розробляти широку ріноманітність програмних мов, включаючи динамічну мову Smalltalk, наукову мову X10, та логічну мову, що живить Semmle. Він та його жінка живуть в Атланті з двома котами та чихуахуа.</p></div>
<div class="paragraph"><p>Bill Venners є президентом Artima, Inc., видавник веб сайту Artima Developer (www.artima.com), та співзасновник Escalate Software, LLC. Він автор книги Inside the Java Virtual Machine, програміст-орієнтовного дослідження архитектури Java платформи та її нутрощів. Його популярні колонки в журналі JavaWorld торкаються нутрощів Java, об'єктно-орієнтовної розробки та Jini. Будучи активний в спільноті Jini Community з її створення, Bill лідирує в проекті Jini Community ServiceUI, чиє ServiceUI API стало де-факто стандартним способом асоціювати користувацькій інтерфейс з Jini сервісами. Bill також ведучий розробник та дизайнер ScalaTest, відкритого інструменту тестування для Scala та Java розробників.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 3.0<br />
Last updated
 2019-04-25 05:29:35 EEST
</div>
</div>
</body>
</html>
