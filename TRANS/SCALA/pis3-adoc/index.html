<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Програмування на Scala, 3тє видання</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Програмування на Scala, 3тє видання</h1>
<span id="author">Martin Odersky, Lex Spoon, Bill Venners</span><br />
<span id="revnumber">version 3.0,</span>
<span id="revdate">2016-12</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_______scala">Подяки за ранішні редакції Програмування на Scala</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="content">Програмування на Scala є, можливо, одною з кращих книжок з програмування, що я будь-коли читав. Мені подобається стиль написання, краткість та глибина викладення. Книжка, здається, відповідає на кожне запитання, як тілько воно спадає мені на думку - вона завжди на крок попереду мене. Автори не тільки надають деякий код та викладають речі як належне. Вони дають вам саму суть, так що ви дійсно розумієте що відбувається. Мені це дійсно подобається.</div>
<div class="attribution">
<em>Chief Software Architect</em><br />
&#8212; Ken Egervari
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala написано ясно, глибоко, та їй легко слідувати. Вона має чудові приклади та сповнена чудовими підказками. Вона дозволила нашій організації опанувати мову Scala швидко та ефективно. Ця книжка чудова для кожного програміста, хто намагається налаштувати свою голову на гнучкість та елегантність мови Scala.</div>
<div class="attribution">
<em>власник Morroni Technologies Inc.</em><br />
&#8212; Larry Morroni
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala служить як чудовий туторіал по мові Scala. Просування по книзі іде гладко, де кожна глава будується на концепціях та прикладах, описаних в попередніх главах. Книга турбується про глибоке пояснення конструкцій мови, часто провадячи приклади того, як мова відрізняється від Java. Так само, як і головна мова, також є деяке покриття бібліотек, як контейнери та актори. Я знайшов книгу простою до проробки, і це, можливо, одна з кращих написаних технічних книжок, що я читав останні часом. Я справді можу рекомендувати цю книжку любому програмісту, що бажає знайти більше щодо мови Scala.</div>
<div class="attribution">
&#8212; Matthew Todd
</div></div>
<div class="quoteblock">
<div class="content">Я здивований зусиллями, здісненими авторами Програмування на Scala. Ця книга є неоціненним керівництвом до того, що я називаю платформою Scala: рушій до кращого кодування, постійне натхнення до розробки та реалізації маштабованого програмного забезпечення. Якби я тільки мав Scala в її сучасному зрілому стані, та цю книжку в далекому 2003му році, коли я спів-розробляв та реалізував частини інфраструктури порталу Олімпійськіх Ігор 2004 в Афінах! Всім читачам: не важливо, який ваш програмістській бекграунд, я відчуваю ви знайдете програмування на Scala вивільняючим, та ця книга буде вірним другом в цій подорожі.</div>
<div class="attribution">
<em>Software Consultant & Researcher</em><br />
&#8212; Christos KK Loverdos
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala є довершеним глибинним вступом до Scala,та це також чудове посилання. Я хочу сказати, що вона займає видатне місце на моїй книжній полиці, і крім цього я все ще ношу її з собою майже будь-де, куди я іду.</div>
<div class="attribution">
<em>президент ArdenTex</em><br />
&#8212; Brian Clapper
</div></div>
<div class="quoteblock">
<div class="content">Чудова книга, гарно написана з осмисленими прикладами. Я можу рекомендувати її як для досвідчених програмістів, так і для початківців.</div>
<div class="attribution">
&#8212; Howard Lovatt
</div></div>
<div class="quoteblock">
<div class="content">Книга Програмування на Scala не тільки про те, як, але, більш важливо, чому слід розробляти програми на цій новій мові програмування. Прагматичний підхід в введені до потужності комбінування об'єктно-орієнтовного та функціонального програмування, залишає читача без жодних сумнівів, чим насправді є Scala.</div>
<div class="attribution">
<em>CEO/засновник EXPRO I.T. & консультант</em><br />
&#8212; Dr. Ervin Varga
</div></div>
<div class="quoteblock">
<div class="content">Це чудове введення до функціонального програмування для ОО програмістів. Навчання щодо ФП було моєю головною ціллю, але я також познайомився з деякими милими сюрпризами Scala, як кейс класи та порівняння шаблонів. Scala є інтригуючою мовою, та ця книжка гарно розмовідає про це. Завжди є гарна лінія, вздовж якої треба іти в книжці вступу до мови, між надання дуже багато, та нестачею достатньої інформації. Я знайшов, що Програмування на Scala досягла ідеального балансу.</div>
<div class="attribution">
<em>Programmer Analyst</em><br />
&#8212; Jeff Heon
</div></div>
<div class="quoteblock">
<div class="content">Я придбав ранішню електронну версію книжки Програмування на Scala від Odersky, Spoon та Venners, та безпосередньо став фанатом. На додаток до факту, що вона містить найбільш всеосяжну інформацію щодо мови, існує декілька ключових особливостей електронного формату, що вразили мене. Я ніколи не бачив посилань в PDF, що служать не тільки для закладок, але також провадять активні посилання з таблиці змісту та індексів. Я не знаю, чому більше авторів не використовують цю можливість, оскільки це дійсно радість для читача. Інша можливість, якою я був вражений, були посилання на форуми ("Discuss"), та спосіб надсилати коментарі ("Suggest") до авторів по електронній пошті. Можливість коментувати сама по собі не є незвичною, але проста вставка номера сторінки, що генерується для надсилання авторам, є важливою для обох, авторів та читачів. Я доклав більше коментарів, ніж я мав би, якби процес був би більш важкий. Читайте Програмування на Scala заради вмісту, але якщо ви читаєте електронну версію, обов'язково отримайте переваги від цифрових можливостей, які автори подбали вбудувати в книжку!</div>
<div class="attribution">
<em>засновник/консультант SRT Solutions</em><br />
&#8212; Dianne Marsh
</div></div>
<div class="quoteblock">
<div class="content">Ясність та технічна повнота є відзнакою любої гарно написаної книжки, та я вітаю Martin
Odersky, Lex Spoon та Bill Venners з тим, що вони зробили цю роботу дуже гарно! Книжка Programming in Scala починається з встановлення гарного фундаменту з базовими концепціями,та просуває користувача на середній рівень, та далі. Ця книга беззаперечно обов'язкова для придбання для кожного, що прагне вивчити Scala.</div>
<div class="attribution">
<em>Enterprise Architecture & GMAC Financial Services</em><br />
&#8212; Jagan Nambi
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala приємно читається. Це одна з тих гарно написаних технічних книжок, що провадять глибоке та повне покриття предмету в екстремально стислій та елегантній манері. Книга організована в дуже природний та логічний спосіб. Вона однаково гарно пристосована для зацікавлених технологістів, які просто бажають залишатись на піці поточних трендів, та професіоналів, що шукають глибокого розуміння основних можливостей  мови, та обгрунтувань її дизайну. Я дуже рекомендую її всім зацікавленим в фіункціональному програмуванні взагалі. Для розробників Scala ця книга безумовно є обов'язковою для читання.</div>
<div class="attribution">
<em>Software Architect/Lead Programmer @ Greystone Inc.</em><br />
&#8212; Igor Khlystov
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala прямо точиться кількістю важкої роботи, що пішла до неї. Я ніколи до цього не читав книжку в стилі туторіала, що виконує роль вступу, і при цьому є повною: в їх (помилковій) спробі бути доступними, та не "засмучувати" читача, більшість туторіалів замовчують аспекти предмета, що дуже просунутий для поточного обговорення. Це залишає дуже поганий присмак, бо ніхто не може бути впевнений, якого розуміння ви вже досягли. Завжди існує деяка залишкова "магія", що не була пояснена, та  взагалі не може бути зрозумілою читачеві. Ця книжка нуколи не робить цього, вона нічого не приймає на віру: кожна деталь або достатньо пояснена, або надається посилання на подальше пояснення. Дійсно, текст екстенсивно посилається на себе та індексований, так що формує повну картину складної теми відносно просто.</div>
<div class="attribution">
<em>Enterprise Java Architect</em><br />
&#8212; Gerald Loeffler
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala від Martin Odersky, Lex Spoon та Bill Venners: в часи, коли гарні книжкі є рідкістю, це чудове введення для програмістів середнього рівня дійсно є винятнковим. Ви знайдете тут все, щоб вивчити цю мову програмування.</div>
<div class="attribution">
&#8212; Christian Neukirchen
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>Programmmin in Scala, Third Edition
Martin Odersky, Lex Spoon, Bill Venners
Artima Press
Walnut Creek, California
   Martin Odersky є створювачем мови Scala та професором EPFL in Lausanne, Switzerland.
   Lex Spoon робив над Scala протягом двох років разом з Martin Odersky.
   Bill Venners є президентом Artima, Inc.</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_">Передмова</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви обрали чудовий час взяти до рук цю книгу! Сприйняття Scala продовжує пришвидшуватись, наша спільнота вирує, та навкола пропозиції роботи. Чи ви програмуєте для розваги чи для прибутку (або обоє), обіцяна Scala радість та продуктивність робить супротив складним. Щодо мене, дійсна радість програмування походить від протистояння цікавим викликам, за допомогою простих, витончених рішень. Місія Scala не тільки в тому, щоб зробити це можливим, але приємним, і ця книга покаже вам як.</p></div>
<div class="paragraph"><p>Зпочатку я експериментував з Scala 2.5, та миттєво був втугнутий в її синтаксичну та концептуальну впорядкованість. Коли я натрапив на нерегулярність, що параметри типів самі не можуть мати параметри типів, я (боязко) підійшов до Martin Odersky на конференції в 2006, та запронував стажування, щоб позбутись цього обмеження. Моя контриб'юція була сприйнята, що привнесло підтримку поліморфізм конструкторів типів в Scala 2.7 та вище. З тих пір я робив над більшістю інших частин компілятора. В 2012 я пішов з пост-докторської практики в лабораторії Martin на керівника команди Scala в Typesafe, по мірі того, як Scala, з версією 2.10, подорослішала від своїх прагматичних академічних коренів до надійної мови рівня корпорації.</p></div>
<div class="paragraph"><p>Scala 2.10 була поворотною точкою від швидко розвинених, багатих можливостями релізів, базованих на академічних дослідах, в напрямку фокусування на спрощенні та збільшенні прийняття адаптації підприємствами. Ми змістили нашу увагу на проблеми, які неможливо описати в дисертаціях, такі, як бінарна сумісність між головними релізами. Щоб збалансувати стабільність з нашим бажанням продовжувати розробку та покращення платформи Scala, ми робимо в напрямку меньшої головної бібліотеки, яку ми збираємось стабілізувати, при цьому розвиваючи платформу як ціле. Щоб зробити це можливим, мій перший проект в якості технічного керівника Scala був початок модулярізації стандартної бібліотеки Scala в 2.11.</p></div>
<div class="paragraph"><p>Щоб зменшити частоту змін, Typesafe також вирішила поперемінно змінювати бібліоттеку та компілятор. Ця редакція Програмування на Scala відноситься до Scala 2.12, що буде релізом компілятора, який матиме новий бек-енд та оптимізатор, щоб отримати більше від нових можливостей Java 8. Для взаємодії з Java, та насолодження тими ж перевагами від оптимізації JVM, Scala компілює функції в той самий байткод, що і компілятор Java 8. Подібно, трейти Scala тепер компілюються в інтерфейси Java з методами по замовчанню. Обоє схеми компіляції зменшують магію, яку мали виконувати старіші компілятори Scala, більш тісно наближаючи нас до платформи Java, при цьому покращуючи обоє, час компіляції та продуктивність часу виконання, з гладшою бінарною сумісністю!</p></div>
<div class="paragraph"><p>Це покращення до платформи Java 8 дуже захоалююче для Scala, та це дуже приємно бачити, що Java рівняється на тренд, який Scala встановлювала протягом дисятиріччя! Без жодного сумніву, що Scala провадить значно більш функціональний досвід програмування, з незмінністю по замовчанню, уніформним трактуванням виразів (навряд чи в цій книзі можливо побачити твердження return), співпадіння шаблонів, варіативність в місці визначення (варіативність в місці використання Java робить створення субтипів функції незграбним), і так далі! Кажучи прямо, існує дещо в функціональному програмуванні, ніж милий синтаксис для лямбди.</p></div>
<div class="paragraph"><p>В якості розпорядників мови, наша ціль є розробляти основу мови, так само, як зрощувати екосистему. Scala є успішною, оскільки вона має багато чудових бібліотек, видатні IDE та інструменти, та дружніх і завжди готових допомогти членів нашої спільноти. Я глибоко насолоджуюсь своєю першою декадою зі Scala — як реалізатор мови, це є великим збудженням і натхненням бачити стільки програмістів, що насолоджуються Scala в безлічі напрямків.</p></div>
<div class="paragraph"><p>Я люблю програмувати на Scala, і маю надію ви полюбите також. Від імені спільноти Scala вітаю вас!</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Adriaan Moors
San Francisco, CA
January 14, 2016</code></pre>
</div></div>
<div class="sect1">
<h2 id="__2">Подяки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато людей доклали до цієї книги, та до матеріалів, які вона розкриває. Ми вдячні всім їм.</p></div>
<div class="paragraph"><p>Scala сама по собі була колективним зусиллям багатьох людей. Розробці та реалізації версії 1.0 допомагали Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman та Matthias Zenger. Phil Bagwell, Antonio Cunei, Iulian Dragos, Gilles Dubochet, Miguel Garcia, Philipp Haller, Sean McDirmid, Ingo Maier, Donna Malayeri, Adriaan Moors, Hubert Plociniczak, Paul Phillips, Aleksandar Prokopec, Tiark Rompf, Lukas Rytz та Geoffrey Washburn приєднали зусилля для розробки другої та поточної версії мови та інструментів.</p></div>
<div class="paragraph"><p>Gilad Bracha, Nathan Bronson, Caoyuan, Aemon Cannon, Craig Chambers, Chris Conrad, Erik Ernst, Matthias Felleisen, Mark Harrah, Shriram Krishnamurti, Gary Leavens, David MacIver, Sebastian Maneth, Rickard Nilsson, Erik Meijer, Lalit Pant, David Pollak, Jon Pretty, Klaus Ostermann, Jorge Ortiz, Didier Rémy, Miles Sabin, Vijay Saraswat, Daniel Spiewak, James Strachan, Don Syme, Erik Torreborre, Mads Torgersen, Philip Wadler, Jamie Webb, John Williams, Kevin Wright та Jason Zaugg окреслили дизайн мови, щедро подоілившись своїми ідеями з нами в живих та надихаючих дискусіях, через контриб'юцію важливих частин коду до зусиль відкритого коду, так само, як і через коментарі до попередніх версій цього документу. Дописувачі в список розсилки Scala також надали дуже корисний зворотній зв'язок, що допоміг нам покращити мову та інструменти.</p></div>
<div class="paragraph"><p>George Berger працював наполегливо, щоб зробити процес побудови та веб присутність книги роблячими гладко. Як результат, цей проект був чудово вільний від технічних непередбачуваностей.</p></div>
<div class="paragraph"><p>Багато людей надали нам цінний зворотній зв'язок щодо ранішніх версій цього тексту. Подяки надходять до Eric Armstrong, George Berger, Alex Blewitt, Gilad Bracha, William Cook, Bruce Eckel, Stéphane Micheloud, Todd Millstein, David Pollak, Frank Sommers, Philip Wadler, and Matthias Zenger. Також дякуємо до групи Silicon Valley Patterns, за їх дуже корисний огляд: Dave Astels, Tracy Bialik, John Brewer, Andrew Chase, Bradford Cross, Raoul Duke, John P. Eurich, Steven Ganz, Phil Goodwin, Ralph Jocham, Yan-Fa Li, Tao Ma, Jeffery Miller, Suresh Pai, Russ Rufer, Dave W. Smith, Scott Turnquest, Walter Vannini, Darlene Wallach та Jonathan Andrew Wolter. Та нам приємно подякувати Dewayne
Johnson та Kim Leedy за їх допомогу з оформленням обкладинки, та Frank Sommers за його роботу з індексом.</p></div>
<div class="paragraph"><p>Нам також приємно поширити особливі подяки всім нашим читачам, що надали коментарі. Ваші коментарі дуже корисні для нас в окресленні цієї, навіть кращої книжки. Ми не можемо надрукувати імена всіх, хто надіслав коментарі. але ось імена тих читачів, які надіслали щонайменьше п'ять коментарів на протязі стадії eBook PrePrint®, через клацання на посиланні Suggest, впорядковані від найбільшого загального числа надісланих коментарів, та потім за алфавітом. Подякі до: David Biesack, Donn Stephan, Mats Henricson, Rob Dickens, Blair Zajac, Tony Sloane, Nigel Harrison, Javier Diaz Soto, William Heelan, Justin Forder, Gregor Purdy, Colin Perkins, Bjarte S. Karlsen, Ervin Varga, Eric
Willigers, Mark Hayes, Martin Elwin, Calum MacLean, Jonathan Wolter, Les Pruszynski, Seth Tisue, Andrei Formiga, Dmitry Grigoriev, George Berger, Howard Lovatt, John P. Eurich, Marius Scurtescu,Jeff Ervin, Jamie Webb, Kurt Zoglmann, Dean Wampler, Nikolaj Lindberg, Peter McLain, Arkadiusz Stryjski, Shanky Surana, Craig Bordelon, Alexandre Patry, Filip Moens, Fred Janon, Jeff Heon, Boris Lorbeer, Jim Menard, Tim Azzopardi, Thomas Jung, Walter Chang, Jeroen Dijkmeijer, Casey Bowman, Martin Smith, Richard Dallaway, Antony Stubbs, Lars Westergren, Maarten Hazewinkel, Matt Russell, Remigiusz Michalowski, Andrew Tolopko, Curtis Stanford, Joshua Cough, Zemian Deng, Christopher Rodrigues Macias, Juan Miguel Garcia Lopez, Michel Schinz, Peter Moore, Randolph Kahle, Vladimir Kelman, Daniel Gronau, Dirk Detering, Hiroaki Nakamura, Ole Hougaard, Bhaskar Maddala, David Bernard, Derek Mahar, George Kollias, Kristian Nordal, Normen Mueller, Rafael Ferreira, Binil
Thomas, John Nilsson, Jorge Ortiz, Marcus Schulte, Vadim Gerassimov, Cameron Taggart, Jon-Anders Teigen, Silvestre Zabala, Will McQueen та Sam Owen.</p></div>
<div class="paragraph"><p>Ми також бажаемо подякувати тим, хто надіслав коментарі та помилки після друку перших двох видань, включаючи Felix Siegrist, Lothar Meyer-Lerbs, Diethard Michaelis, Roshan Dawrani, Donn Stephan, William Uther, Francisco Reverbel, Jim Balter, and Freek de Bruijn, Ambrose Laing, Sekhar Prabhala, Levon Saldamli, Andrew Bursavich, Hjalmar Peters, Thomas Fehr, Alain O&#8217;Dea, Rob Dickens, Tim Taylor, Christian Sternagel, Michel Parisien, Joel Neely, Brian McKeon, Thomas Fehr, Joseph Elliott, Gabriel da Silva Ribeiro, Thomas Fehr, Pablo Ripolles, Douglas Gaylor, Kevin Squire, Harry-Anton Talvik, Christopher Simpkins, Martin Witmann-Funk, Jim Balter, Peter Foster, Craig Bordelon, Heinz-Peter Gumm, Peter Chapin, Kevin Wright, Ananthan Srinivasan, Omar Kilani, Donn Stephan, Guenther Waffler.
Lex would like to thank Aaron Abrams, Jason Adams, Henry and Emily Crutcher, Joey Gibson, Gunnar Hillert, Matthew Link, Toby Reyelts, Jason Snape, John та Melinda Weathers, та всім членам Atlanta Scala Enthusiasts за багато корисних дискусій щодо розробки мови, її матеатичних засадах, та як презентувати Scala працюючим інженерам.</p></div>
<div class="paragraph"><p>Спеціальна подяка для Dave Briccetti та Adriaan Moors за огляд третього видання, та до Marconi Lanna за не тільки огляд, але за надання мотивації для третього видання, надаючи розмову, озаглавлену "Що нового з часів Програмування на Scala."</p></div>
<div class="paragraph"><p>Bill має подякувати Gary Cornell, Greg Doench, Andy Hunt, Mike Leonard, Tyler Ortman, Bill
Pollock, Dave Thomas та Adam Wright за провадження розуміння та поради по друку книжки. Bill також дякує Dick Wall за взаємодію над курсом Escalate Stairway to Scala, що значною частиною базується на цій книжці. Наші багато років досвіду викладання Stairway to Scala допомогло зробити цю книжку краще. Нарешті, Bill має подякувати Darlene Gruendl та Samantha Woolf за їх допомогу в тому, щоб третє видання було закінчене.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__3">Вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця книжка є туторіалом по мові програмування Scala, написану людьми, напряму причетними до розробки Scala. Наша ціль полягає в тому, щоб читаючи цю книжку ви могли навчитись всьому, що треба, щоб бути продуктивним Scala програмістом. Всі приклади в цій книжці компілюються за допомогою Scala версії 2.11.7, за винятком тих, що відмічені 2.12, що компілюються за допомогою 2.12.0-M3.</p></div>
<div class="sect2">
<h3 id="_____">Кому слідує читати цю книжку</h3>
<div class="paragraph"><p>Головна цільова аудієнція для цієї книжки є програмісти, які бажають навчитись програмуванню на Scala. Якщо ви бажаєте робити ваш наступний проект на Scala, тоді ця книжка для вас. На додаток, книжка має бути цікавою для програмістів, що бажають розширити свої горизонти через навчання нових концепцій. Наприклад, якщо ви Java програміст, читання цієї книжки відкриє вас до багатьох концепцій з функціонального програмування, так само, як просунутих об'єктно-орієнтовних ідей. Ми віримо, що навчання  Scala, та стоячих за нею ідей, може допомогти стати кращим програмістом, загалом.</p></div>
<div class="paragraph"><p>Передбачається загальне знання програмування. Хоча Scala є гарною першою мовою програмування, це не книжка для навчання програмуванню.</p></div>
<div class="paragraph"><p>З іншого боку, ніякого спеціального знання мов програмування не потрібне. Навіть якщо більшість людей використовують Scala на платформі Java, ця книга не очікує, що ви знаєте щось про Java. Однак ми очікуємо, що багато читачів будуть знайомі з Java, так що часом порівнюємо Scala з Java, щоб допомогти таким читачам розуміти відмінності.</p></div>
</div>
<div class="sect2">
<h3 id="____">Як використовувати цю книгу</h3>
<div class="paragraph"><p>Оскільки головне призначення цієї книжки служити туторіалом, рекомендований спосіб читати цю книгу в порядку глав, зпочатку до кінця. Ми дуже намагались викладати одну тему за раз, та пояснюємо нові теми тільки в термінах тем, що ми вже розглянули. Таким чином, якщо ви пересунетесь в кінець, що скоріше підхопити щось, ви можете винайти, що це пояснено в термінах концепцій, що ви не зовсім розумієте. Доки ви читаєте глави по порядку, ми вважаємо, що ви знайдете досить прямолінійним отримати знання в Scala, по одному кроку за раз.</p></div>
<div class="paragraph"><p>Якщо ви бачите невідомий вам термін, будьте певні, що перевірили глосарій та індекс. Багато читачів будуть швидко переглядати частини книжки, і це непогано. Глосарій та індекс можуть допомогти вам надолужити, якщо ви проскочили щось дуже швидко.</p></div>
<div class="paragraph"><p>Після того, як ви прочитали книжку один раз, вона може також служити посиланням мови. Існує формальна специфікація мови Scala, але специфікація мови намагається бути точною, ціною читабельності. Хоча ця книга не покриває кожної деталі Scala, вона досить повна, та може служити як доступне посилання до мови, по мірі як ви ставатимете більш адаптованим в програмуванні Scala.</p></div>
</div>
<div class="sect2">
<h3 id="___scala">Як навчатись Scala</h3>
<div class="paragraph"><p>Ви можете багато чому навчитись про Scala, просто читаючи цю книжку від корки до корки. Однак, ви можете навчитись Scala швидше та більш глибоко, якщо зробите декілька додаткових речей.</p></div>
<div class="paragraph"><p>Зпершу, ви можете отримати вигоду від багатьох прикладів програм, включених в цю книжку. Набираючи їх самотужки є шляхом змісити ваші думки проходити через кожний рядок коду. Пробуючи варіації є шляхом зробити це більш веселим, та переконатись, що ви дійсно розумієте, як вони працюють.</p></div>
<div class="paragraph"><p>Друге, пристаньте до багатьох онлайн форумів. Таким чином ви та інші інтузіасти Scala можете допомагати один одному. Є багато списків розсилки, дискусійних форумів, чат кімнат, wiki, та декілька Scala-специфічних фідів статей. Витратьте деякий час для пошуку такого, що задовільняє вашим інформаційним потребам. Ви будете витрачати значно меньше часу за вирішенням простих проблем, так що ви зможете витрачати час на глибші, більш важливі питання.</p></div>
<div class="paragraph"><p>Нарешті, коли ви прочитаєте досить, оберіть собі власний програмний проект. Робіть над малою програмою від початку, або розробляйте додаток до більшої програми. Ви можете зайти тільки так далеко, читаючи.</p></div>
</div>
<div class="sect2">
<h3 id="__ebook">Можливості eBook</h3>
<div class="paragraph"><p>Ця книжка доступна в обох, паперовій формі та PDF eBook. eBook не просто електронна копія паперової версії книжки. Хоча вміст той самий, що і в паперовій версії, eBook була прискіпливо розроблена та оптимізована для читання на комп'ютерному екрані.</p></div>
<div class="paragraph"><p>Перша річ, що треба зауважити, це що більшість посилань в eBook і гіперпосиланнями. Якщо ви виберете главу, малюнок, або елемент глосарію, ваш PDF переглядач  повинене перенести вас прямо до обраного елементу, так що вам не знадобиться гортати, щоб знайти його.</p></div>
<div class="paragraph"><p>Додатково, знизу кожної сторінки в eBook є декілька навігаційних посилань. Посилання Обкладинка, Огляд та Вміст перенесуть вас на вступні сторінки книжки. Глосарій та Індекс посилаються на частини посилань книжки. Нарешті, посилання Обговорення перенесе вас до онлайн форуму, де ви обговорюєте питання з другими читачами, авторами та ширшою спільнотою Scala. Якщо ви знайдете помилку друку, або щось, що ви вважаєте має пояснюватись краще, будь ласка клацніть на посилання Зауваження, що перенесе вас до онлайн веб застосування, де ви можете надати зворотній зв'язок авторам.</p></div>
<div class="paragraph"><p>Хоча та сама сторінка з'являється в eBook як і в друкованій книжці, порожні сторінки видалені, та залишені сторінки перенумеровані. Сторінки пронумеровані по-різному, так що вам простіше визначати номери сторінок PDF при друці тільки частини eBook. Таким чином, сторінки в eBook є нумеровані саме так, як їх нумероватиме PDF переглядач.</p></div>
</div>
<div class="sect2">
<h3 id="__">Типографічні домовленості</h3>
<div class="paragraph"><p>Перший раз, коли визначається <em>термін</em>, він виділяється прописом. Малий приклад коду як  <code>x + 1</code>, записується інлайн моноширинним шрифтом. Більші приклади коду покладаються в моноширинні блоки запозичень, як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">hello</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли показується інтерактивна оболонка, відповіді від оболонки показуються легшим шрифтом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>scala&gt; <span class="m">3</span> + <span class="m">4</span>
res0: <span class="nv">Int</span> <span class="o">=</span> <span class="m">7</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Огляд вмісту</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Глава 1 "Маштабована мова", надає вам огляд дизайну Scala, разом з міркуваннями, історією, що стоять за нею.
</p>
</li>
<li>
<p>
Глава 2 "Перші кроки в Scala", показує вам, як робити декілька базових завдань програмування в Scala, не вдаючись в великі деталі щодо того, як воно робить. Ціль цієї глави є змусити ваші пальці почати друкувати та виконувати код Scala.
</p>
</li>
<li>
<p>
Глава 3 "Наступні кроки в Scala", показує вам декілька більш базових програмних завдань,  що будуть допомагати вам швидко набрати темп в Scala. Після завершення цієї глави, ви повинні бути в змозі почати використовувати Scala для простих скриптових задач.
</p>
</li>
<li>
<p>
Глава 4 "Класи та об'єкти", розпочинає глибинне покриття Scala з визначення його базових об'єктно-орієнтованих будівельних блоків та інструкцій щодо того, як компілювати та виконувати застосування Scala.
</p>
</li>
<li>
<p>
Глава 5 "Базові типи та операції", розкриває базові типи Scala, їх літерали, операції, що ви можете виконувати з ними, як роблять преоритети та асоційованість, та що таке збагачені обертки.
</p>
</li>
<li>
<p>
Глава 6 "Функціональні обертки", занурюється більш глибоко в об'єктно-орієнтовні можливості Scala, використовуючи функціональні (тобто незмінні) раціональні числа в якості приклада.
</p>
</li>
<li>
<p>
Глава 7 "Вбудовані керівні структури", показує вам, як використовувати вбудовані структури керування Scala: if, while, for, try, та match.
</p>
</li>
<li>
<p>
Глава 8 "Функції та замикання", провадить глибинне пояснення функцій, базових будівельних блоків функціональних мов.
</p>
</li>
<li>
<p>
Глава 9 "Керівні абстракції", показує, як розширювати базові керуючі структури Scala через визначення ваших власних керівних абстракцій.
</p>
</li>
<li>
<p>
Глава 10 "Композиція та наслідування", обговорює більше з підтримки Scala об'єктно-орієнтовного програмування. Теми не такі фундаментальні, як ті що в Главі 4, але вони часто постають на практиці.
</p>
</li>
<li>
<p>
Глава 11 "Ієрархія Scala", пояснює ієрархію наслідування Scala, та обговорює її універсальні методи та нижні типи.
</p>
</li>
<li>
<p>
Глава 12 "Трейти", розказує про механізм Scala для міксін композиції. Глава показує, як роблять трейти, описує загальні використання, та пояснює, як трейти покращують традиційне множинне наслідування.
</p>
</li>
<li>
<p>
Глава 13 "Пакунки та імпорти", обговорює проблеми програмування в широкому сенсі, включаючи пакунки вищого рівня, твердження імпорту, та модифікатори контроля доступа, як <code>protected</code> та <code>private</code>.
</p>
</li>
<li>
<p>
Глава 14 "Твердження та тести", показує механізм тверджень Scala, та надає тур по декількох інструментах для написання тестів в Scala, зокрема фокусуючись на ScalaTest.
</p>
</li>
<li>
<p>
Глава 15 "Кейс класи та співпадіння шаблонів", вводять конструкції-близьнюки, що підтримують вас при написанні регулярних, неінкапсульованих структур даних. Кейс класи та співпадіння шаблонів зокрема корисні для дерево-подібних рекурсивних даних.
</p>
</li>
<li>
<p>
Глава 16 "Робота зі списками", пояснює в деталях списки, що, можливо, найбільш загально уживані структури даних в програмах Scala.
</p>
</li>
<li>
<p>
Глава 17 "Робота з іншими колекціями", показує вам, як використовувати базові колекції Scala, такі як списки, масиси, кортежі, множини та мапи.
</p>
</li>
<li>
<p>
Глава 18 "Змінні об'єкти", пояснює змінні об'єкти, та синтаксис, що провадить Scala для їх вираження. Глава завершується практичним заняттям на симуляцію дискретних подій, що показує деякі змінні об'єкти в дії.
</p>
</li>
<li>
<p>
Глава 19 "Типова параметризація", пояснює деякі з прийомів для приховування інформації, введеної в Главі 13 з допомогою конкретного прикладу: розробкою класу для чисто функціональних черг. Глава будується до визначення варіантності типових параметрів, та як це взаємодіє з приховуванням інформації.
</p>
</li>
<li>
<p>
Глава 20 "Абстрактні члени", описує всі типи абстрактних членів, як підтримує Scala; не тільки методи, але також поля та типи, можуть бути декларовані як абстрактні.
</p>
</li>
<li>
<p>
Глава 21 "Неявні переткорення та параметри", розкриває дві конструкції, що можуть допомогти вам оминути нудних деталей джерельного коду, та дозволяючи компілятору надати їх замість цього.
</p>
</li>
<li>
<p>
Глава 22 "Реалізація списків", описує реалізацію класу List. Важливо розуміти, як списки роблять в Scala, і більше того, реалізація демонструє використання деяких можливостей Scala.
</p>
</li>
<li>
<p>
Глава 23 "Переосмислені вирази for", показує як вирази for транслюються на виклики map, flatMap, filter та foreach.
</p>
</li>
<li>
<p>
Глава 24 "Колекції поглиблено", Надає детальний тур по бібліотеці колекцій.
</p>
</li>
<li>
<p>
Глава 25 "Архитектура колекцій Scala", показує як побудована бібліотека колекцій, та як ви можете реалізувати свої власні колекції.
</p>
</li>
<li>
<p>
Глава 26 "Екстрактори", показує, як робити співпадіння шаблонів з довільними класами, не тільки з кейс класами.
</p>
</li>
<li>
<p>
Глава 27 "Анотації", показує, як робити з розширенням мови через анотації. Глава описує декілька стандартних анотацій, та показує, як робити ваші власні.
</p>
</li>
<li>
<p>
Глава 28 "Робота з XML", пояснює, як обробляти XML в Scala. Глава показує вам ідіоми генерації XML, його розбір, та обробку, коли він вже розібраний.
</p>
</li>
<li>
<p>
Глава 29 "Модулярне програмування з використанням об'єктів", показує, як ви можете використовувати об'єкти Scala як модульну систему.
</p>
</li>
<li>
<p>
Глава 30 "Еквівалентність об'єктів", вказує на деякі проблеми, які треба розглядати, коли пишете метод <code>equals</code>. Є декільки ловушок, що треба уникнути.
</p>
</li>
<li>
<p>
Глава 31 "Комбінація Scala та Java", обговорює проблеми, що постають, коли комбінуєте Scala та Java разом в одному проекті, та рекомендовані методи щодо їх подолання.
</p>
</li>
<li>
<p>
Глава 32 "Ф'ючерси та конкурентність", показує вам, як використовувати Scala Future. Хоча ви можете використовувати примітиви конкуренції платформи Java для Scala програм, ф'ючерси можуть допомогти вам уникнути мертвого блокування та стану гонок, що зачумлюють традиційний підхід "потоки та блокування" до конкуренції.
</p>
</li>
<li>
<p>
Глава 33 "Комбінаторний розібр", показує, як побудувати парсери з використанням бібліотеки Scala парсерних комбінаторів.
</p>
</li>
<li>
<p>
Глава 34 "Програмування користувацького інтерфейсу", надає швидкий тур бібліотеки Scala, що спрощує програмування GUI за допомогою Swing.
</p>
</li>
<li>
<p>
Глава 35 "Електронна таблиця SCells", зв'язує все разом, показуючи повне застосування електронної таблиці, написане на Scala.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="__4">Ресурси</h3>
<div class="paragraph"><p>На <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>, головному веб ресурсі для Scala, ви знайдете останній реліз Scala та посилання на документацію та ресурси спільноти. Для більш стиснутої сторінки з посиланнями навідайтесь на сайт книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>. Щоб поспілкуватись з іншими читачами цієї книжки, перевірте форум Programming in Scala Forum,
за адресою: <a href="http://www.artima.com/forums/forum.jsp?forum=282">http://www.artima.com/forums/forum.jsp?forum=282</a>.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Джерельний код</h3>
<div class="paragraph"><p>Ви можете завантажити ZIP файл, що містить джерельний код цієї книги, що випущений пді відкритою ліцензією Apache 2.0, с зайта книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>.</p></div>
</div>
<div class="sect2">
<h3 id="__5">Помилки</h3>
<div class="paragraph"><p>Хоча ця книжки була щільно переглянута та перевірена, помилки всеж-таки неодмінно будуть прослизати. Для (надіємось, короткого) списку помилок друку для цієї книжки навідайтесь на <a href="http://booksites.artima.com/programming_in_scala_3ed/errata">http://booksites.artima.com/programming_in_scala_3ed/errata</a>. Якщо ви знайшли помилку, будь ласка повідомьте про неї за носиланням нижче URL, так що ми виправимо її при наступному друці або виданні цієї книжки.
:ascii-ids:
:doctype: book
:source-highlighter: pygments</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__1">Глава 1</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___4">Маштабована мова</h1>
<div class="paragraph"><p>Ім'я Scala означає "scalable language", тобто маштабована мова. Мова названа так, оскільки вона була розроблена зростати разом з потребами своїх користувачів. Ви можете застосувати Scala до широкого диапазону програмних завдань, від написання невеликіх скриптів, до побудови великих систем.<span class="footnote"><br />[Scala вимовляється skah-lah.]<br /></span></p></div>
<div class="paragraph"><p>До Scala легко дістатись. Вона працює на стандартній Java платформі, та без проблем взаємодіє з усіма бібліотеками Java. Це досить гарна мова для напсання скриптів, що стягають разом Java компоненти. Але вона може застосувати свою потужність навіть більше для побудови великих систем та фреймворків реюзабельних компонент.</p></div>
<div class="paragraph"><p>Технічно Scala є сумішшю об'єктно-орієнтованих та функціональних програмних концепцій в статично типізованій мові. Зплав об'єктно-орієнтовного та функціонального програмування виявляється в багатьох різних аспектах Scala; воно, можливо, більш проникаюче, ніж в любій іншій широко уживаній мові. Два стилі програмування мають доповнюючі сильні сторони, коли доходить до маштабованості. Функціональні програмні конструкції Scala роблять простим будувати цікаві речі швидко, з простих частин. Її об'єктно-орієнтовні конструкції спрощують структурувати більші системи, та адаптувати їх до нових вимог. Комбінація двох стилів в Scala робить можливим виражати нові типи програмних шаблонів та компонентних абстракцій. Це також призводить до виразного та стислого стилю програмування. Та оскільки вона така піддатлива, програмування на Scala може бути дуже втішним.</p></div>
<div class="paragraph"><p>Ця початкова глава відповідає на запитання "чому Scala?". Вона дає високорівневий погляд на дизайн Scala та міркування позаду неї. Після читання глави ви повинні мати базове відчуття того, що таке є Scala, та які типи задач вона може допомогти виконати. Хоча ця книжка є туторіалом в Scala, ця глава насправді не є частиною туторіала. Якщо вам нетерпляче хочеться почати писати деякий Scala код, вам слідує перестрибнути далі до Глави 2.</p></div>
<div class="sect1">
<h2 id="_1_1______">1.1 Мова, що зростає разом з вами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Програми різного розміру схильні потребувати різних програмних конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця програма встановлює мапу з країн та їх столиць, модифікує мапу, додаючи нову прив'язку ("Japan" &#8594; "Tokyo"), та друкує столицю, що асоційована з країною France.<span class="footnote"><br />[Будь ласка, слідуйте за нами, якщо ви не розумієте всі деталі цієї програми. Вони будуть пояснені в наступних двох главах.]<br /></span> Нотація в цьому прикладі високорівнева, до діла, та не захаращена зайвими крапками з комою або анотаціями типів. Дійсно, відчувається що це сучасна "скриптова" мова, Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що має відношення до приклада вище, в тому, що всі вони підтримують конструкцію "асоціативної мапи" в синтаксисі мови.</p></div>
<div class="paragraph"><p>Асоциативні мапи дуже корисні, оскільки вони дозволяють утримувати програми чіткими та лаконічними, але іноді ви можете не погодитись з їх філософією "один розмір підходить всім", оскільки вам треба контролювати властивості мап, які ви використовуваєте в вашій програмі, в більше гарно-контрольований спосіб. Scala надає вам цей гарний контроль, якщо ви потребуєте його, оскільки мапи в Scala не є синтаксисом мови. Вони є бібліотечними абстракціями, які ви можете розширити та адаптувати.</p></div>
<div class="paragraph"><p>В програмі вище ви отримали реалізацію Map по замовчанню, але ви можете легко змінити це. Ви можете, наприклад, вказати окрему реалізацію, таку як HashMap або TreeMap, або визвати метод <code>par</code> що отримати <code>ParMap</code>, що виконує операції паралельно. Ви можете вказати значення по замовчанню для мапи, або ви можете переписати любий інший метод мапи, яку ви створюєте. В кожному випадку, ви можете використовувати той самий простий синтаксис доступу для мап, що і в прикладі вище.</p></div>
<div class="paragraph"><p>Цей приклад показує, що Scala дати вам обоє, зручність та гнучкість. Scala має набір зручних конструкцій, що допомагають вам стартовати швидко, та дозволяють вам програмувати в приємно стислому стилі. В той же час, ви маєте впевненість, що ви не переростете мову. Ви завжди можете підкроїти програму до ваших потреб, оскільки все базується на бібліотечних модулях, які ви можете обрати та адаптувати, якщо треба.</p></div>
<div class="sect2">
<h3 id="___">Вирощування нових типів</h3>
<div class="paragraph"><p>Eric Raymond ввів собор та базар як дві метафори софтверної розробки.<span class="footnote"><br />[Raymond, The Cathedral and the Bazaar. [Ray99]]<br /></span> Собор майже досконала будівля, що займає довгий час доки збудується. Коли вже побудований, він стоїть незмінний довгий час. На відміну від цього базар адаптується та розширюється кожного дня, людьми, що роблять на ньому. В роботі Raymond базар є метафорою розробки програм з відкритим кодом. Guy Steele зауважив в розмові про "зростаючу мову", що ту саму різницю можна застосувати до дизайна мови.<span class="footnote"><br />[Steele, Growing a language. [Ste99]]<br /></span> Scala є значно більше базаром, ніж собором, в сміслі, що вона розроблена бути розширеною та адаптованою людьми, що програмують на ній. Заміть провадити всі конструкції, що можуть будь-коли вам знадобитись в "досконало повній мові", Scala покладає в ваші руки інструменти для побудови таких конструкцій.</p></div>
<div class="paragraph"><p>Ось приклад. Багато застосувань потребують тип цілих, що може стати довільно великим без переповнення або "циклічного переносу" арифметичних операцій. Scala визначає такий тип в бібліотечному класі scala.BigInt. Ось визначення метода, що використовує цей тип, що обчислює факторіал переданого цілого значення:<span class="footnote"><br />[factorial(x), або в математичній нотації x!, є результатом обчислення 1 * 2 * &#8230; * x, де 0! визначене як 1.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ми викличемо <code>factorial(30)</code>, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">265252859812191058636308480000000</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt виглядає як вбудований тип, оскільки ви можете використовувати цілі літерали та оператори, як * та - зі значеннями цього типу. Але це все ще клас, що визначений в стандартній бібліотеці.<span class="footnote"><br />[Scala іде зі стандартною бібліотекою, дещо з якої буде показане в цій книжці. Для додаткової інформації ви можете звернутись до документації Scaladoc по бібліотеці, що доступна в дистрибутиві та онлайн <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>.]<br /></span> Якщо клас був би відсутній, було б прямолінійним для кожного програміста Scala написати реалізацію, наприклад, через огортання Java класу java.math.BigInteger (фактично, саме так реалізований клас Scala).</p></div>
<div class="paragraph"><p>Звичайно, ви можете використовувати клас Java напряму. Але результат і близько не такий приємний, бо хоча Java дозволяє вам створювати нові типи, ці типи не дуже виглядають як природна підтримка мови:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.math.BigInteger</span>
<span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInteger</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInteger</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ZERO</span><span class="o">)</span>
    <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span>
  <span class="k">else</span>
    <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">subtract</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt є представником багатьох інших число-подібних типів - великих десятичних, комплексних чисел, раціональних чисел, довірчих інтервалів, поліноміалів - список продовжується. Деякі мови програмування реалізують деяки з ціх типів природно. Наприклад, Lisp, Haskell та Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але кожна мова, що намагається реалізувати всі з ціх абструкцій одночасно, просто стане дуже великою, щоб бути керованою. Що ще більше, навіть якщо б така мова могла б існувати, деякі застосування напевно могли б отримати переваги від інших число-подібних типів, що не були включені. Так що спроба запровадити все в одній мові маштабується не дуже добре. Замість цього Scala дозволяє користувачам вирощувати та адаптувати мову в напрямках, які ї потрібні, визначаючи прості-в-використанні бібліотеки, що виглядають як природна підтримка мови.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Вирощування нових керуючих структур</h3>
<div class="paragraph"><p>Попередній приклад демонструє, що Scala дозвляє вам додавати нові типи, що можуть бути такі ж зручні в використанні, що і вбудовані типи. Той же принцип розширення також стосується до керуючих структур. Цей різновид розширюваності ілюстрований Akka, Scala API до "актор-базованого" конкурентного програмування.</p></div>
<div class="paragraph"><p>По мірі того, як багатоядерні процесори будуть продовжувати розмножуватись в наступні роки, досягнення прийнятної продуктивності може підвищувати потребу, щоб ви використовували більше парлелизма в ваших програмах. Часто це буде означати переписування вашого коду, так, щоб розподілити обчислення між декількома конкурентними потоками. Нажаль, створення надійних багатопоточних застосувань доведено складна задача на практиці. Модель поточності Java побудована навколо загальної пам'яті та блокування, модель, яку часто складно промислити, особливо коли система зростає в розмірі та складності. Складно бути впевненим, що ви не маєте стану гонок або мертвого блокування, що десь причаїлись — дещо, що не проявилось під час тестування, але може проявитись під час використатння. Як можливо безпечніша альтернатива є архитектура передачі повідомлень, така, як підхід "акторів", використаний в мові програмування Erlang.</p></div>
<div class="paragraph"><p>Java іде з багатою, основаною на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, так само, як любе інше Java API. Однак існує Akka, що є додатковою бібліотекою Scala, яка реалізує модель акторів, подібних то таких в Erlang.</p></div>
<div class="paragraph"><p>Актори є абстракцією конкурентності, що може бути реалізвана поверху потоків. Вони комунікують через надсилання повідомлень один одному. Актор може виконувати дві базові операції, надсилання та отримання повідомлення. Операція <code>send</code>, позначена знаком наголосу(!), надсилає повідомлення актору. Ось приклад, в якому актор називається <code>recipient</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>recipient ! msg</code></pre>
</div></div>
<div class="paragraph"><p>Надсилання асинхронне; тобто, надсилаючий актор може продовжувати безпосередньо, без очікування щоб повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, в якому накопичуються повідомлення. Актор обробляє повідомлення, що надійшли в поштову скриньку через блок <code>receive</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Msg1</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg1</span>
  <span class="k">case</span> <span class="nc">Msg2</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg2</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Блок <code>receive</code> складається з декількох <code>case</code>, кожний з яких опитує поштову скриньку за шаблоном повідомлення. Перше повідомлення в скриньці, що співпаде з любим <code>case</code>, буде обране, та для нього виконується відповідна дія. Як тільки скринька більше не містить повідомлень, актор призупиняється, та очікує подальших входящих повідомлень.</p></div>
<div class="paragraph"><p>Як приклад, ось простий актор Akka, що реалізує сервіс калькулятора контрольних сум:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Data</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">byte</span>
    <span class="k">case</span> <span class="nc">GetChecksum</span><span class="o">(</span><span class="n">requester</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">checksum</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">requester</span> <span class="o">!</span> <span class="n">checksum</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зпочатку цей актор визначає локальну змінну на ім'я <code>sum</code> з початковим значенням нуль. Далі він визначає блок <code>receive</code>, що буде обробляти повідомлення. Якщо він отримає повідомлення Data, він додає збережений байт до змінної <code>sum</code>. Якщо отримано повідомлення GetChecksum, актор обчислює контрольну суму для поточного значення <code>sum</code>, та надсилає результат назад до запитувача, використовуючи надсилання повідомлення <code>requester ! sum</code>. Поле <code>requester</code> вбудоване в повідомлення GetChecksum; воно звичайно посилається актора, що зробив запит.</p></div>
<div class="paragraph"><p>Ми не очікуємо, що ви повністю розумієте приклад з актором на цей момент. Скоріше, що важливе щодо цього прикладу в плані маштабованості, це те, що ані блок <code>receive</code>, ані повідомлення <code>send</code> (!) не є вбудовані операції в Scala. Навіть вважаючи, що блок <code>receive</code> може виглядати та діяти дуже подібними до вбудованих керівних конструкцій, фактично це метод, визначений в бібліотеці акторів Akka. Подібно до цього, навіть вважаючи, що <em>!</em> виглядає як вбудований оператор, він також є тільки методом, визначеним в бібліотеці акторів Akka. Обоє з ціх конструкцій повністю незалежні від мови програмування Scala.</p></div>
<div class="paragraph"><p>Синтаксис блоку <code>receive</code> та <code>send</code> (!) вигладає в Scala здебільшого як вони виглядають в Erlang, але в Erlang ці конструкції вбудовані в мову. Akka також реалізує більшість з інших конкурентних програмних конструкцій Erlang, таких, як моніторинг схибивших акторів та тайм-аути. Кінець кінцем, модель акторів виявилась дуже приємним засобом для вираження конкурентних та розподілених обчислень. Навіть якщо вони визначені в біблиотеці, актори можуть відчуватись як інтегральна частина мови Scala.</p></div>
<div class="paragraph"><p>Цей приклад ілюструє, як ви можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Звичайно, вам знадобляться гарні архітектори та програмісти, щоб зробити це. Але вирішальна річ в тому, що це можливо — ви можете розробляти та реалізувати абстракції в Scala, що адресують радикально нові галузі застосування, та все ще відчувати це як природну підтримку мови при використанні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_2___scala_">1.2 Що робить Scala маштабованою?</h2>
<div class="sectionbody">
<div class="paragraph"><p>На маштабованість впливає багато факторів, в диапазоні від синтаксичних деталей до абстрактних конструкцій компонент. Однак якщо б нам доводилось назвати тільки один аспект Scala, що допомагає маштабованості, ми б обрали комбінацію об'єктно-орієнтованого та функціонально програмування (гаразд, ми змахлювали, насправді це два аспекти, але вони пов'язані).</p></div>
<div class="paragraph"><p>Scala іде далі, ніж всі інші гарно-відомі мови в справі зплавлення об'єкто-орієнтовного та функціонального програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції як дві окремі концепції, в Scala значення функції є об'єктом. Функціональні типи є класами, що можуть наслідуватись субкласами. Це може виглядати нічим іншим, ніж академічними тонкощами, але це має глибокі наслідки для маштабованості. Фактично, показана раніше концепція актора не могла б бути реалізованою без цієї уніфікації функцій та об'єктів. Цей розділ дає огляд шляху Scala по змішуванню об'єктно-орієнтовної та функціональної концепцій.</p></div>
<div class="sect2">
<h3 id="_scala____">Scala є об'єктно-орієнтовна</h3>
<div class="paragraph"><p>Об'єктно-орієнтоване програмування було назвичайно успішним. Починаючи з Simula в середині 60х та Smalltalk в 70х, воно зараз доступне в більшій кількості мов, ніж навпаки. В деяких галузях об'єкти повністю перебрали все на себе. Хоча немає точного визначення того, що означає об'єкт-орієнтовне, але ясно, що це щось щодо об'єктів, що апелює до програмістів.</p></div>
<div class="paragraph"><p>В принципі, мотивація для об'єктно-орієнтовного програмування дуже проста: всі, крім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, це покласти дані та операції в деяку форму контейнерів. Чудова ідея об'єктно-орієнтовного програмування це зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як і дані, та що вони самі по собі є значеннями, що можуть зберігатись в інших контейнерах, або передані як параметри до операцій. Такі контейнери називаються об'єктами. Alan Kay, винахідник Smalltalk, зауважував, що в такий спосіб найпростіший об'єкт має ті самі принципи конструкції, що і цілий компьп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом.<span class="footnote"><br />[Kay, "The Early History of Smalltalk." [Kay96]]<br /></span> Так що об'єкти мають багато чого докласти до маштабованості мови: та сама технологія застосовується до конструкції малих, так само як і до великих програм.</p></div>
<div class="paragraph"><p>Навіть якщо об'єктно-орієнтоване програмування було мейнстримом протягом довгого часу, є відносно мало мов, що послідували за Smalltalk в протисканні цього конструктивного принипу до його логічного висновку. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні значення в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтовного програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнюівати речі, та обмежувати маштабованість.</p></div>
<div class="paragraph"><p>Для контрасту Scala є об'єктно-орієнтовною мовою в чистій формі: кожне значення є об'єктом, та кожна операція є викликом метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви насправді викликаєте метод на ім'я + , визначений в класі Int. Ви можете визначити методи з оператор-подібними назвами, які потім клієнти вашого API використовують для використання в операторній нотації. Ось як розробник Akka API акторів дозволив вам використовувати вирази, такі як <code>requester ! sum</code>, показані в попередньому прикладі: ! є методом класу Actor.</p></div>
<div class="paragraph"><p>Scala є більш досвідченою, ніж багато інших мови, коли йдеться про композицію об'єктів. Прикладом є трейти Scala. Трейти подібні до інтерфейсів в Java, але вони також можуть мати реалізації методів, та навіть поля.<span class="footnote"><br />[Починаючи з Java 8, інтерфейси можуть мати реалізації методів по замовчанню, але вони не надають всі можливості трейтів Scala.]<br /></span> Об'єкти конструюються через композицію міксінів, що бере методи класу, та додає до них члени декількох трейтів. В цей спосіб різні аспекти класів можуть бути інкапсульовані в різні трейти. Це виглядає трохи схожим на множинне наслідування, але відрізняється, коли річ доходить до деталей. Це робить трейти більш "плагабельними", ніж класи. Зокрема, вони уникають класичних проблем "діамантового наслідування" множинних інтерфейсів, що виникає, коли деякий клас наслідується через декілька різних шляхів.</p></div>
</div>
<div class="sect2">
<h3 id="_scala__">Scala є функціональною</h3>
<div class="paragraph"><p>На додаток до того, що вона є чистою об'єктно-орієнтовною мовою, Scala також є повно-функціональною функціональною мовою. Ці ідеі функціонального програмування старіші ніж (електронні) комп'ютері. Їх основи були покладені в лямбда обчисленні Alonzo Church, що було розроблене в 1930х. Першою функціональною мовою був Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. Протягом довгого часу функціональне програмування було дещо на узбіччі — популярне в академічних колах, але не так широко використане в індустрії. Однак в останні роки намітилась зростаюча зацікавленість в функціональному програмуванні та технологіях.</p></div>
<div class="paragraph"><p>Функціональне програмування направляється двома головними ідеями. Перша ідея в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з тим самим статусом, що і, скажімо, ціле або рядок. Ви можете передати функції як аргументи в інші функції, повернути їх як результат з функції, або зберігати їх в змінних. Ви також можете визначити функцію всередині іншої функції, так само, як ви можете визначити ціле значення всередині функції. Та ви можете визначити функції без надання їм імен, скрапляючи ваш код функціональними літералами так просто, як ви можете записати цілий літерал, як 42.</p></div>
<div class="paragraph"><p>Функції, що є першокласними значеннями, провадять зручні засоби для абстрагування над операціями, та створення нових керівних структур. Це узагальнення функцій провадить чудову виразність, що часто призводить до дуже виразних та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, бібліотека тестування ScalaTest пропонує конструкцію <code>eventually</code>, що приймає функцію як аргумент. Це використовується приблизно так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">iterator</span>
<span class="n">eventually</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="n">shouldBe</span> <span class="mi">3</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Код всередині <code>eventually</code> — твердження, <code>it.next() shouldBe 3</code> — огорнуте в функцію, що передається без виконання до метода <code>eventually</code>. Для сконфігурованого проміжку часу, <code>eventually</code> буде виконувати функцію, доки буде виконуватись твердження.</p></div>
<div class="paragraph"><p>В більшості традиційних мов, для контрасту, функції не є значеннями. Мови, що є значення функцій, часто відсувають їх на другій план. Наприклад, указателі на функції в C та C++ не мають того самого статусу, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись тільки на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення в своєму оточенні. Також вони не дозволяють визначати неіменовані функціональні літерали.</p></div>
<div class="paragraph"><p>Друга головна ідея функціонального програмування в тому, що операції програми мають відзеркалювати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці.  Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масив символів. Символи в рядку можуть бути змінені індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку на кому, всередині того самого об'єкта рядка. В Java та Scala, з іншого боку, рядок є послідовність символі в математичному сенсі. Заміна символа в рядку, використовуючи вираз як s.replace(";","."), повертає новий об'єкт рядка, що є іншим від s. Інший шлях виразити те саме, це сказати, що рядкі незмінні в Java, тоді як вони змінні в Ruby. Так що з погляду тільки на рядки, Java є функціональною мовою, тоді як Ruby ні. Незмінні структури даних є один з наріжних каменів функціонального програмування. Бібліотеки Scala визначають значно більше незмінних типів даних, крім тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, тапли, мапи та множини.</p></div>
<div class="paragraph"><p>Інший шлях затвердити цю другу ідею функціонального програмування є те, що методам не слідує мати любі побічні ефекти. Вони мають комунікувати зі своїм оточенням тільки через прийняття аргументів, та повернення результатів. Наприклад, метод <code>replace</code> в класі Java String підходить під цей опис. Він приймає рядок та два символи, та видає новий рядок, де всі появлення одного символа замінюється на інший. Немає іншого ефекту виклику <code>replace</code>. Методи як <code>replace</code> називаються референційно прозорими, що означає, що для кожного взятого вводу виклик методу може бути замінений на свій результат, без впливу на семантику програми.</p></div>
<div class="paragraph"><p>Функціональні мови заохочують незмінні структури даних та референсно прозорі методи. Деякі функціональні мови навіть вимагають їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є назвою для програмування зі змінними даними та побічними ефектами. Але Scala загалом робить простим уникати імперативних конструкцій, коли ви бажаєте цього, бо існують гарні функціональні альтернативи.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_3__scala">1.3 Чому Scala?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Чи Scala для вас? Вам доведеться зрозуміти та прийняти рішення самостійно. Ми винайшли, що насправді багато причин, крім маштабованості, щоб програмувати на Scala. В цьому розділі будуть розглянуті чотири з найбільш важливих аспектів: сумісність, краткість, високорівневі абстракції та розвинена статична типізація.</p></div>
<div class="sect2">
<h3 id="_scala___2">Scala є сумісною</h3>
<div class="paragraph"><p>Scala не потребує, щоб ви зістрибували назад з платформи Java, щоб зробити крок вперед від мови Java. Вона дозволяє вам додати вартість до існуючого коду — щоб будувати на тому, що вже маєте, оскільки вона була розроблена для безшовної взаємодії з Java.<span class="footnote"><br />[Зпочатку була реалізація Scala, що робила на платформі .NET, але вона більше не активна. Останнім часом все більше популярною стає реалізація Scala, що робить на JavaScript, Scala.js.]<br /></span> Програми Scala компілюються на байткоди JVM. Її продуктивність часу виконання звичано співпадає з Java програмами. Код Scala може викликати методи Java, отримувати доступ до полів Java, наслідувати від Java класів, та реалізувати Java інтерфейси. Ніщо з цього не потребує спеціального синтаксису, явного визначення інтерфейсів, або зклеючого коду. Фактично, весь код Scala дуже тяжко використовує Java бібліотеки, часто без того, щоб програміст переймався цім фактом.</p></div>
<div class="paragraph"><p>Інший аспект повної взаємодії є те, що Scala потужно пере-використовує типи Java. Scala <code>Int</code> представлений як примітивне ціле Java типу <code>int</code>, <code>Float</code> представлені як <code>float</code>, <code>Boolean</code> як <code>boolean</code>, і так далі. Масиви Scala відображуються на масиві Java. Scala також пере-використовує багато зі стандартних бібліотечних типів Java. Наприклад, тип рядкового літерала "abc" в Scala є <code>java.lang.String</code>, та підійняті виключення мають бути субкласом <code>java.lang.Throwable</code>.</p></div>
<div class="paragraph"><p>Scala не тільки пере-використовує Java типи, але також "принаряджує" їх, щоб зробити їх кращими. Наприклад, методи підтримки рядків в Scala, як <code>toInt</code> або <code>toFloat</code>, що конвертують рядок на ціле або на число з плаваючою крапкою. Так що ви можете писати <code>str.toInt</code> замість <code>Integer.parseInt(str)</code>. Як це може бути досягнуте без руйнування сумісності? Клас Java String напевне не має метода <code>toInt</code>! Фактично, Scala має дуже загальне рішення для вирішення цього тертя між розширеним дизайном бібліотек, та взаємодією. Scala дозволяє вам вирішити неявні перетворення, що завжди застосовуються, коли типи не будуть звичайно співпадати, або коли обираються неіснуючі члени. В випадку вище, коли шукається метод <code>toInt</code> для рядка, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String на примірник класу Scala StringOps, що визначає такий член. Це перетворення буде потім неявно застосоване перед виконанням операції <code>toInt</code>. Код Scala також може викликатись з кода Java. Іноді це більш тонка матерія, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш розвинених можливостей Scala мають бути закодовані, перед тим, як іх можна буде відобразити на Java. Глава 31 пояснює деталі.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___3">Scala є стислою</h3>
<div class="paragraph"><p>Програми Scala мають схильність бути короткими. Програмісти на Scala повідомляють зменшення числа рядків до десяти раз, порівняно з Java. Це може бути екстремальним випадком. Більш консервативне очікування може бути таким: типова Scala програма має бути приблизно в половину довжини за числом рядків, до такої самої програми, написаної на Java. Меньше рядків коду означає не тільки менше друку, але також менше зусиль по читанню та розумінню програм, та менші можливості для дефектів. Існують різні фактори, що докладаються до цього зменшення рядків коду.</p></div>
<div class="paragraph"><p>Перше, синтаксис Scala уникає деяких шаблонів, що обтяжують Java програми. Наприклад, крапка з комою є опціональною в Scala, та звичано відкидається. Також є декілька інших площин, де синтаксис Scala менш шумлячий. Як приклад, порівняйте, як ви пишете класи та конструктори в Java та Scala. В Java клас з конструктором часто виглядає подібно до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// це Java</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala ви скоріше всього замість цього напишете таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код компілятор Scala спродукує клас, що має дві приватні змінні примірника, <code>Int</code> на ім'я <code>index</code> та <code>String</code> на ім'я <code>name</code>, та конструктор, що приймає первинні значення для ціх змінних в якості параметрів. Код цього конструктора буде ініціалізувати дві змінні примірника значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча Java версія.<span class="footnote"><br />[Єдина реальна різниця в тому, що змінні примірника, вироблені в випадку Scala, будуть фінальні. Ви навчитесь, як робити їх не-фінальними в Розділі 10.6.]<br /></span> Клас Scala швидше писати, протіше читати, та більш важливо - менше схильний до помилок, ніж Java клас.</p></div>
<div class="paragraph"><p>Вивід типів Scala є іншим фактором, що докладається до її стислості. Повторювана інформація інйормація про типи може бути відкинута, так що програми стають менш захащені та більш читабельні.</p></div>
<div class="paragraph"><p>Але, можливо, найбільш важливим ключем до компактного коду є код, що ви не маєте писати, бо він вже зроблений в бібліотеці за вас. Scala надає вам інструменти для визначення потужних бібліотек, що дають вам захопити та виділити загальну поведінку. Наприклад, різні аспекти класів бібліотеки можуть бути виділені в трейти, що можуть потім бути зміксовані разом в гнучкий спосіб. Або методи бібліотеки можуть бути параметризовані за допомогою операцій, що дозволяє вам визначати конструкції, які ефективно є вашими власними керівними структурами. Разом ці конструкції дозволяють визначення бібліотек, що одночасно високорівневі та гнучки в використанні.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___4">Scala є високорівневою</h3>
<div class="paragraph"><p>Програмісти постійно борються зі складністю. Щоб програмувати продуктивно, ви маєте розуміти код, з яким ви робите. Надскладний код був причиною падіння багатьох софтверних проектів. Нажаль, важливі програми звичано мають складні вимоги. Такої складності неможливо уникнути; замість цього єю треба керувати.</p></div>
<div class="paragraph"><p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракції в інтерфейсах, що ви розробляєте і якими користуєтесь. Як приклад, уявіть, що ви маєте змінну <code>String name</code>, та ви бажаєте визначити, чи містить цей рядок символи в великому реєстрі. До Java 8 ви могли написати такий цикл:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// this is Java</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
         <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
         <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як в Scala ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">nameHasUpperCase</span> <span class="k">=</span> <span class="n">name</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Код Java сприймає рядки як низьковірневі сутнсті, по яких можна крокувати символ за символом в циклі. Код Scala сприймає той самий рядок як високорівневу послідовність символів, до якої можливо робити запити за допомогою предикатів. Зрозуміло, що код Scala значно коротший, та — для тренованого ока — простіший для розуміння, ніж Java код. Так що код Scala менше заважує до загального бюджету складності. Він також дає вам менше можливостей робити помилки.</p></div>
<div class="paragraph"><p>Предикат _.isUpper є прикладом функціонального літералу в Scala.<span class="footnote"><br />[Функціональні літерали можуть бути названі предикатами, якщо тип їх результату Boolean.]<br /></span> Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи це символ верхнього реєстра.<span class="footnote"><br />[Це використання підкреслення як заповнювача для аргументів описане в Розділі 8.5.]<br /></span></p></div>
<div class="paragraph"><p>Java 8 вводить підтримку для лямбда та потоків, що дозволяє вам виконувати подібну операцію в Java. Ось як це може виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span>
<span class="c1">// це Java 8</span>
<span class="n">name</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">anyMatch</span><span class="o">(</span>
    <span class="o">(</span><span class="kt">int</span> <span class="n">ch</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">ch</span><span class="o">)</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це велике покращення над ранішніми версіями Java, код Java 8 все ще більше балакучий, ніж еквівалентний код Scala. Ця додаткова "важкість" Java коду, так само, як довгі традиції циклів Java, можуть заохотити багатьох Java програмістів за браком нових методів, як <code>exists</code>, просто писати цикли, та жити з підвищеною складністю їх кода.</p></div>
<div class="paragraph"><p>З іншого боку, функціональні літерали в Scala насправді легковажні, так що вони використовуютсья часто. Коли ви знатимете Scala краще, ви будете знаходити більше і більше можливостей для визначення та використання ваших власних керівних абстракцій. Ви побачите, що це допомагає уникати дублікації коду, і, таким чином, утримують ваш код коротним та чистішим.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування Scala також пропонує високорівневі принципи розмірковувати про програмування. Ключова ідея в тому, що ці функції є референтно прозорими — застосування функції характеризується тільки її результатом. Таким чином ви можете вільно замінити застосування функції на праву сторону функції (тобто тіло, що слідує за знаком рівняння), не турбуючись щодо жодних побічних ефектів. Цей принцип надає багато корисних законів, які ви можете задіяти для кращого розуміння або для рефакторинга вашого коду. Як приклад, ще раз візьмемо метод <code>exists</code>, описаний вище. Цей метод має задовільняти наступному правилу: для кожної послідовності <code>s</code>, та для кожної пари предикатів <code>p</code> та <code>q</code> має виконуватись таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">q</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">||</span> <span class="n">q</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, опитуючи ту саму послідовність двома предикатами p та q, та роблячи АБО з результатами є те саме, що перевірити один предикат, що одночасно перевіряє на p або q. Правило, подібне до цього, вочевідь корисне для написання та рефакторингу програм. Однак, якщо <code>exists</code> має побічні ефекти, загалом не буде коректно припускати існування такого закону, оскільки ліва частина виконує <code>exists</code> двічі для кожного елемента послідовності, тоді як права частина виконується тільки один раз для кожного елементу. Так що це є прикладом, коли чисто функціональний код призводить до додаткових правил, і корисний для розуміння та рефакторингу вашого коду.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування також прибирає проблеми накладання, що трапляються в імперативному програмуванні. Накладання трапляється, коли декілька змінних посилаються на той самий об'єкт. Це підіймає деякі тернисті запитання та ускладнення. Наприклад, чи зміна поля <code>r.x</code> також впливатиме на <code>s.x</code>? Це відбуватиметься, якщо <code>r</code> та <code>s</code> посилаються на той самий об'єкт. На практиці дуже складно відслідити такі накладання. З іншого боку, незмінні правила можуть вільно поділятись, оскільки копія не відрізняється від загального посилання. Ця перевага є практично ключовою, коли ви пишете конкурентний код. (Ось чому Java має незмінні рядки).</p></div>
</div>
<div class="sect2">
<h3 id="_scala___5">Scala статично типізована</h3>
<div class="paragraph"><p>Статичні системи типів класифікують змінні та вирази відповідно до властивостей значень, що вони зберігають на обчислюють. Scala виділяється як мова з дуже розширеною статичною системою типів. Починаючи від системи типів вкладених класів, подібних до Java, вона дозволяє вам параметризувати типи за допомогою дженериків, комбінувати типи з використанням перетинів, та приховувати деталі типів з використанням абстрактних типів.<span class="footnote"><br />[Дженеріки обговорюються в Главі 19; перетини (тобто, A with B with C) в Главі 12; та абстрактні типи в Главі 20.]<br /></span> Це дає міцний фундамент для будівництва та компонування ваших власних типів, так що ви можете розробити інтерфейси, що одночасно безпечні, та гнучкі в використанні.</p></div>
<div class="paragraph"><p>Якщо вам подобаються динамічні мови, такі як Perl, Python, Ruby, або Groovy, ви можете винайти трохи дивним, що статична система типів Scala попала в перелік як одна з сильних сторін. Кінець кінцем, відсутність статичної системи типів наводиться як одна з головних переваг динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми над балакучими, заважають програмістам виражати себе так, як вони бажають, та роблять неможливим деякі шаблони динамічних модифікацій софтверних систем. Однак часто ці аргументи не ідуть проти самої ідеі статичних типів взагалі, але проти окремих систем типів, що сприймаються як дуже балакучі або негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись замітив: "Я не проти типів, але я не знаю жодної системи типів, що не є суцільною біллю, так що я все ще люблю динамічні типи".<span class="footnote"><br />[Kay, поштою щодо значення об'єктно-орієнтовного програмування. [Kay03]]<br /></span></p></div>
<div class="paragraph"><p>Ми надіємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільною біллю". Фактично, вона адресує дві звичайні турботи щодо статичної типізації: балакучість іникається через вивід типів, та гнучкість досягається через співпадіння шаблонів та декльіка нових шляхів писати та компонувати типи. Коли ці перешкоди прибрані з нашого шляху, класичні переваги статичних типів можуть бути краще помічені. Серед найбільш важливих з ціх переваг є перевіряємі властивості програмних абстракцій, безпечний рефакторинг, та краща документація.</p></div>
<div class="paragraph"><p><strong>Перевіряємі властивості.</strong> Статичні системи типів можуть забезпечити відсутність певних помилок часу виконання. Наприклад, вони можуть доказати такі властивості: <code>Boolean</code> не буде доданий до цілого; приватні змінні не отримують доступ поза меж класу; функції застосовуються до відповідного числа аргументів; тільки рядки будь-коли будуть додаватись до множини рядків.</p></div>
<div class="paragraph"><p>Інші відомі помилки не виявляються сьогоднішніми статичними системами типів. Наприклад, вони зазвичай не будуть не-терміновані функції, порушення меж масивів, або ділення на ноль. Вони також не детектують, що ваша програма не відповідає її специфікації (вважаємо що така специфікація є, саме так!). Статичні системи типів, мають бути звільнені, як не дуже корисні. Аргумент, що надається, що оскільки такі системи можуть виявляти тільки прості помилки, тоді як юніт тести провадять більш екстенсивне покриття, чому треба борсатись зі статичними типами взагалі? Ми впевнені, що ці аргументи позбавлені змісту. Хоча статичні системи типів напевне не можуть замінити юніт тести, вони можуть зменшити число потрібних юніт тестів, пілчкуючись про деякі властивості, для яких інакше знадобились би тести. Подібним чином, юніт тести не можуть замінити статичну типізацію. Кінець кінцем, як казав Edsger Dijkstra, тестування може тільки довести наявність присутності помилок, та ніколи їх відсутність.<span class="footnote"><br />[Dijkstra, "Notes on Structured Programming." [Dij70]]<br /></span> Так що гарантії, що надає статична типізація, може бути слабкою, але це реальні гарантії в формі, яку не може забезпечити ніяка кількість тестів.</p></div>
<div class="paragraph"><p><strong>Безпечний рефакторинг.</strong> Статичні системи типів провадять страховку, що дозволяє вам робити зміни в базі коду з високою мірою довіри. Розглянемо примірник рефакторингу, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто підігнати всі рядки, що видають помилку типу. Коли ви скінчите з цім, ви впевнені, що найшли всі місця, що треба змінити. Те саме вірно для багатьох інших випадків простого рефакторингу, як зміни імені методу, або переміщення методів з одного класу до іншого. В усіх ціх випадках перевірка статичного типу буде провадити досить акуратності, щоб нова система робила так само, як стара.</p></div>
<div class="paragraph"><p><strong>Документація.</strong> Статичні типи є документацією програми, що перевіряється компілятором на коректність. На відміну від звичайних коментарів, анотації типів ніколи не можуть застаріти (щонайменьше якощ файл коду, що містить їх, недавно проходив через компілятор). Більше того, компілятори і інтегровані середовища розробки (IDE) можуть використовувати анотації типів для провадження кращої контекстної підказки. Наприклад, IDE може відображувати всі члени, доступні для вибору, через визначення статичного типу виразу, на якому робиться вибір, та перегляд членів цього типу.</p></div>
<div class="paragraph"><p>Навіть хоча статичні типи загалом корисні для документації програми, вони можуть інколи бути надокучливі, коли вони захаращують програму. Типово, корисна документація - це те, що читачі програми не можуть просто вивести самі по собі. В визначенні метода як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>корисно знати, що аргумент має бути <code>String</code>. Або, з іншого боку, щонайменьше одна з двох анотацій в наступному прикладі є подразником:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
</pre></div></div></div>
<div class="paragraph"><p>Зрозуміло, що має бути достатньо сказати тільки один раз, що <code>x</code> є <code>HashMap</code> з <code>Int</code> в якості ключа, та <code>Strings</code> як значення; немає потреби повторювати ту саму фразу двічі. Scala має дуже складну систему виводу типів, що дозволяє вам оминати майже всю інформацію типів, що звичайно сприймається як надокучлива. В попередньому прикладі наступні дві менш дратливі альтернативи також будуть робити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>ВИвід типів в Scala може зайти досить далеко. Фактично, не є рідкістю для користувацького кода, взагалі не мати явних типів. Таким чином, програми Scala часто виглядають трохи як програми, написані на динамічно типізованій скриптоівій мові. Це вірно зокрема для кода клієнтськіх застосувань, що зліплюють разом попередньо написані бібліотечні компоненти. Це менш вірно для самих компонент бібліотек, оскільки вони часто вживають дуже складні типи, щоб забезпечити гнучкі шаблони застосування. Це просто природно. Кінець кінцем, сигнатури типів членів, що складають інтерфейс реюзабельного компонента, повинен бути наданий явно, оскільки вони складають основну частину контракту між компонентом та його клієнтами.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_4__scala">1.4 Корені Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Дизайн Scala бів під впливом багатьох мов програмування, та ідей в дослідженні програмних мов. Фактично, тільки декілька можливостей Scala чисто нові; більшість вже мали застосування в деякій формі в інших мовах. Інновація Scala в основному походить від того, як вона покладає ці конструкції разом. В цьому розділі ми перелічимо головні впливи на розробку Scala. Список не може бути вичерпним — існує дуже багато розумних ідей коло розробки мови програмування, щоб перелічити тут їх всі.</p></div>
<div class="paragraph"><p>На поверхневому рівні Scala адоптує значну частину синтаксиса Java та C#, що, в свою чергу, позичає більшість зі своїх синтаксичних домовленостей від C та C++. Вирази, твердження та блокі здебільшо як в Java, так само, як синтаксис класів, пакунків та імпортів.<span class="footnote"><br />[Головне відхидення від Java в плані синтаксису для анотацій типу, це "змінна: типу" замість "тип змінної" в Java. Постфіксний синтаксис типу в Scala копіює Pascal, Modula-2, або Eiffel. Головна причина для цього відхилення має відношення до виводу типів, що часто дозволяє вам оминути тип змінної або тип повернення метода. Використання синтаксису "змінна: типу" просте - тільки опустіть крапку з комою та тип. Але в C-style синтаксисі "тип змінної" ви не можете просто відкинути тип; більше намає маркера що почалась декларація. Вам знадобиться деяке альтернативне ключове слово, щоб бути заповнювачем для відсутнього типу (C# 3.0, що робить деякий вивід типів, використовує <code>var</code> для ціх цілей). Таке альтернативне ключове слово виглядає більш притягнутим, та менш регулярним, ніж підхід Scala.]<br /></span> Крім синтаксиса Scala адоптує багато інших елементів Java, такі як базові типи, її бібліотеки типів, та її модель виконання.</p></div>
<div class="paragraph"><p>Scala також заборгувала багатьом іншим мовам. Її уніформна об'єктна модель започаткована  Smalltalk, і згодом прийнята Ruby. Її ідея про універсальне вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, більш пізніше, в Beta та gbeta. Її принцип уніформного доступу для виклику методів та виборів полів надходить від Eiffel. Її підхід до функціонального програмування є дуже подібним до духу сім'ї мов ML, таких як SML, OCaml та F#, в якості видатних членів. Багато високорівневих функцій в стандартній бібліотеці Scala також присутні в ML або Haskell. Неявні параметри були мотивовані класами типів Haskell; вони досягли аналогічних результатів в більше класичной об'єктно-орієнтовному оточенні. Головна актор-базована бібліотека конкурентності, Akka, дуже надихалась Erlang.</p></div>
<div class="paragraph"><p>Scala не є першою мовою, що наголошує на маштабованості та розширюваності. Історичні корені розширюваної мови, що може перетинати різні області застосування, знаходяться в статті Peter Landin 1966го року,"The Next 700 Programming Languages."<span class="footnote"><br />[Landin, "The Next 700 Programming Languages." [Lan66]]<br /></span> (Мова, описана в цьому документі, Iswim, стоїть поряд з Lisp як один з першопроходців функціональних мов). Специфічна ідея трактувати інфіксний оператор як функцію можна прослідкувати до Iswim та Smalltalk. Інша важлива ідея є дозволити функціональні літерали (або блоки) в якості параметрів, що дозвоялє бібліотекам визначати керівні структури. Знову, це тягнеться назад до Iswim та Smalltalk. Smalltalk та Lisp обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх, домен-специфічних мов. C++ є іншою маштабованою мовою, що може бути адаптований та розширений через перевантаження операторів, та його систему шаблонів; порівняно зі Scala він побудований на ніжньому рівні, більш системно-орієнтовному ядрі. Scala також не є першою мовою, що інтегрує функціональне та об'єкт-орієнтовне програмування, хоча вона, можливо, зашла найбільш далеко в цьому напрямку. Інші мови, що інтегрували деякі елементи функціонального програмування в об'єкто-орієнтовне програмування (OOP) включають Ruby, Smalltalk та Python. На Java платформі, Pizza, Nice, Multi-Java — та сама Java 8  — мають розширене Java-подібне ядро з функціональними ідеями. Також існують здебільше функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F#, та PLT-Scheme.</p></div>
<div class="paragraph"><p>Scala також привнесла деякі інновації до поля мов програмування. Наприклад, її абстрактні типи провадять більше об'єктно-орієнтовної альтернативи до дженерік типів, її трейти дозволяють гнучкі збірки компонент, та її екстрактори провадять незалежний від представлення спосіб співпадіння шаблонів. Ці інновації були представлені в документах на конференціях з мов програмування в останні роки.<span class="footnote"><br />[Для додаткової інформації дивіться [Ode03], [Ode05], та [Emi07] в бібліографії.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_1_5_">1.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми дали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Напевне, Scala не є срібною кулею, що магічно зробить вас більш продуктивним. Щоб просуватись, вам знадобиться містецьки застосувати Scala, та це буде потребувати деякого навчання та практики. Якщо ви прийшли до Scala від Java, найбільш викличний аспект у вивченні Scala може включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книжки м'яко провести вас кривою навчання Scala, по кроку за раз. Ми вважаємо, що ви знайдете це корисним інтелектуальним досвідом, що розширить ваші горизонти, та змусить вас думати інакше щодо розробки програм. Надіємось, що ви також отримаєте задоволення та натхнення від програмуванн на Scala.</p></div>
<div class="paragraph"><p>В наступній главі ми почнемо з вами писати деякий Scala код.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2_2">Глава 2</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala">Перші кроки в Scala</h1>
<div class="paragraph"><p>Прийшов час написати деякий код на Scala. Перед тим, як ми почнемо заглиблений туторіал Scala, ми покладемо дві глави, що дасть нам більшу картину Scala, та більш важливо, дасть вам написати код. Ми закликаємо вас справді спробувати всі приклади коду, представлені в цій главі, та наступному, куди ми теж дійдемо. Простий шлях почати вивчати Scala, це програмувати на ній.</p></div>
<div class="paragraph"><p>Щоб виконати приклади в цій главі, вам слідує мати стандартну інсталяцію Scala. Щоб отримати її, перейдіть до <a href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a> та слідуйте інструкціям для своєї платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans. Для кроків в цій главі ми вважатимемо, що ви використовуєте дистрибутив Scala з scala-lang.org.<span class="footnote"><br />[Ми тестували приклади в цій книзі на Scala версії 2.11.7.]<br /></span></p></div>
<div class="paragraph"><p>Якщов ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, що дозволить вам почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий матеріал може видатись вам трохи містичним. Але не хвилюйтесь. Щоб ви жваво набрали швидкість ми полишили деякі деталі. Все буде пояснене в трохи "пожарному" стилі в наступних главах. На додаток ми вставили декілька зносок в ціх наступних двох главах, що вказують вам на пізніші розділи книги, де ви знайдете більш докладні пояснення.</p></div>
<div class="sect1">
<h2 id="__1____scala">Крок 1. Навчаємось викорстовувати інтерпретатор Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Простіший спосіб розпочати зі Scala є використання інтерпретатора Scala, інтерактивної  "оболонки" для написання Scala виразів та програм. Інтерпретатор, що називається scala, буде обчислювати вирази, які ви набираєте, та друкувати отримане значення. Ви використовуєте його, набравши scala в командній підказці:<span class="footnote"><br />[Якщо ви використовуєте Windows, вам буде треба друкувати команду scala у вікно "Command Prompt" DOS.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala
Welcome to Scala version 2.11.7
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Після того, як ви наберете вираз, такий як 1 + 2, та нажмете enter:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; 1 + 2</code></pre>
</div></div>
<div class="paragraph"><p>Інтерпретатор надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>res0: Int = 3</code></pre>
</div></div>
<div class="paragraph"><p>Цей рядок включає:</p></div>
<div class="ulist"><ul>
<li>
<p>
автоматично згенероване або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає результат 0),
</p>
</li>
<li>
<p>
дві крапки (:), за якими іде тип виразу (Int),
</p>
</li>
<li>
<p>
знак рівнсоті (=),
</p>
</li>
<li>
<p>
значення, отримане від обчислення виразу (3).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Тип <code>Int</code> є назвою класа <code>Int</code> в пакунку <code>scala</code>. Пакунки в Scala подібні до пакунків в Java: вони поділяють глобальний простір імен, та провадять механізм для приховування інформації.<span class="footnote"><br />[Якщо ви не знайомі з пакунками Java, ви можете думати про них, як про впроваджене повне ім'я класу. Оскільки Int є членом пакунку scala, "Int" є простим ім'ям класу, та "scala.Int" є його повним ім'ям. Деталі щодо пакунків пояснюються в Главі 13.]<br /></span> Значення класу <code>Int</code> відповідають значенням <code>Java</code> <code>int</code>. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку <code>scala</code>. Наприклад, <code>scala.Boolean</code> відповідає до Java <code>boolean</code>. <code>scala.Float</code> відповідає до Java <code>float</code>. Та коли ви компілюєте ваш Scala код в байткод Java, компілятор Scala коли можливо буде використовувати примітивні типи Java, щоб надати вам переваги продуктивності примітивних типів.</p></div>
<div class="paragraph"><p>Ідентифікатор <code>resX</code> може бути використаний в подальших рядках. Наприклад, оскільки res0 був встановлений в 3 до цього, res0 * 3 буде давати 9:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; res0 * 3
res1: Int = 9</code></pre>
</div></div>
<div class="paragraph"><p>Щоб надрукувати необхідне, але недостатнє привітання Hello, world!, наберіть:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println("Hello, world!")
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Функція <code>println</code> друкує переданий рядок на стандартний вивід, подібно до <code>System.out.println</code> в Java.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2___">Крок 2. Визначаємо декілька змінних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має два типи змінних, <code>vals</code> та <code>vars</code>. <code>val</code> подібні до <code>final</code> змінних в Java. Коли ініціалізована, <code>val</code> ніколи не може бути перепризначеною. На відміну від цього, <code>var</code>, подібно до не-фінальної змінної в Java. <code>var</code> може бути переприсвоєна на протязі свого життя. Ось визначення <code>val</code> definition:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg = "Hello, world!"
msg: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Це твордження вводить <code>msg</code> як ім'я для рядка "Hello, world!". Тип <code>msg</code> є <code>java.lang.String</code>, оскільки рядки в <code>Scala</code> реалізовані через клас Java <code>String</code>.</p></div>
<div class="paragraph"><p>Якщо ви визначали змінні в Java, ви зауважили тут одну вбивчу різницю: ані <code>java.lang.String</code>, ані <code>String</code> не з'являються ніде в визначенні <code>val</code>. Цей приклад ілюструє вивід типу, здатність Scala здогадуватись про типи, які ви оминули. В цьому випадку, оскільки ініціалізували <code>msg</code> рядковим літералом, Scala виводить тип <code>msg</code> як <code>String</code>. Коли інтерпретатор Scala (або компілятор) може вивести це, часто є кращим дозволити йому зробити це, ніж заповнювати код непотрібними, явними анотаціями типів. Однак ви можете вказати тип явно, якщо бажаєте, та іноді ви, вірогідно, повинні. Явна анотація типу може одночасно переконатись, що компілятор Scala виводить типи як задумано, і так само прислужитись в якості корисної документації для майбутніх читачів коду. На відміну від Java, коли ви вказуєте тип змінної перед її ім'ям, в Scala ви вказуєте тип змінної після її ім'ям, відокремлений двома крапками. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg2: java.lang.String = "Hello again, world!"
msg2: String = Hello again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Або, оскільки типи <code>java.lang</code> видимі в частині простих імен для програм Scala, просто:<span class="footnote"><br />[Просте ім'я java.lang.String є String.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Переходя до оригінального <code>msg</code>, тепер, коли вона визначена, ви можете використовувати її як очікується, наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println(msg)
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Що ви не можете робити з <code>msg</code>, зважаючи що вона <code>val</code>, не <code>var</code>, це переприсвоїти її.<span class="footnote"><br />[Однак в інтерпретаторі ви можете визначити нове val з іменем, що вже використовувалось до цього. Цей механізм пояснено в Розділі 7.7.]<br /></span> Наприклад, дивіться, як інтерпретатор скаржиться, коли ви намагаєтесь зробити наступне:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; msg = "Goodbye cruel world!"
&lt;console&gt;:8: error: reassignment to val
msg = "Goodbye cruel world!"
^</code></pre>
</div></div>
<div class="paragraph"><p>Якщо переприсвоєння саме те, чого ви бажаєте, вам треба вкористовувати <code>var</code>, як тут:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; var greeting = "Hello, world!"
greeting: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Оскільки <code>greeting</code> є <code>var</code> а не <code>val</code>, ви можете переприсвоїти її пізніше. Якщо ви пізнаше будете почуватись буркотливим, ви можете, наприклад, змінити ваше привітання на таке:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; greeting = "Leave me alone, world!"
greeting: String = Leave me alone, world!</code></pre>
</div></div>
<div class="paragraph"><p>Щоб ввести щось в інтерпретатор, що займатиме декілька рядків, просто продовжуйте друкувати доки не скінчите, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val multiLine =
|
"This is the next line."
multiLine: String = This is the next line.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви зрозуміли, що набрали щось невірно, але інтерпретатор ще чекає для додаткового вводу, ви можете вийти, натиснувши enter двічі:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val oops =
|
|
You typed two blank lines.
Starting a new command.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>В залишку книги ми полишимо вертикальні стовпчики, щоб зробити код простішим для читання (та простіше копіювати та вставляти з PDF eBook в інтерпретатор).</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3___">Крок 3. Визначаємо деякі функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
}
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Визначення функцій починається з <code>def</code>. Ім'я функції, в нашому випадку <code>max</code>, за яким слідує розділений комами список параметрі в дужках. Анотація типу має слідувати за кожним параметром функції черед дві крапки, оскільки компілятор Scala (і інтерпретатор, вле відтепер ми будемо казати тільки компілятор) не виводить типи параметрів функцій. В цьому прикладі функція на ім'я <code>max</code> приймає два параметри, <code>x</code> та <code>y</code>, обоє типу <code>Int</code>. Після того, як ви закрили дужки списку параметрів <code>max</code>, ви знайдете інішу анотацію типу <code>: Int</code>. Це визначає тип результату самої функції <code>max</code>.<span class="footnote"><br />[В Java тип значення, що повертається з метода, є його типом повернення. В Scala та сама концепція називається типом результата.]<br /></span> За типом результату іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить один вираз <code>if</code>, що обирає або <code>x</code> або <code>y</code>, що більше, як результат функції <code>max</code>. Як продемонстровано тут, в Scala <code>if</code> вираз може видавати значення, подібно то тримісного оператора в Java. Наприклад, вираз Scala  <code>if (x &gt; y) x else y</code> поводить себе подібно до <code>(x &gt; y) ? x : y</code> в Java. Знак рівності, що стоїть перед тілом функції, дає підказку, що з точки зору функціонального світу, функція визначає вираз, що видає значення. Базова структура функції ілюстрована на Малюнку 2.1.</p></div>
<div class="paragraph"><p>Малюнок 2.1 - базова форма визначення функції в Scala.</p></div>
<div class="paragraph"><p>Іноді компілятор Scala буде потребувати, щоб ви вказували тип результату функції. Якщо функція рекурсивна,<span class="footnote"><br />[Функція називається рекурсивною, якщо вона викликає сама себе.]<br /></span> наприклад, ви маєте явно вказати тип результату функції. Однак в випадку <code>max</code> ви можете випустити тип результату, і компілятор буде виводити його.<span class="footnote"><br />[Тим не менш, часто є гарною ідеєю вказати тип результата функції явно, навіть коли компілятор не потребує цього. Така анотація типу може зробити код простішим до читання, оскільки читач на повинен вивчати тіло функції, щоб з'ясувати виведений тип результата.]<br /></span> Також, якщо функція складається тільки з одного твердження, ви можете опціонально випустити і фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int) = if (x &gt; y) x else y
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Коли ви визначили функцію, ви можете викликати її:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; max(3, 5)
res4: Int = 5</code></pre>
</div></div>
<div class="paragraph"><p>Ось визначення функції, що не приймає параметрів, та не повертає цікавих результатів:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</code></pre>
</div></div>
<div class="paragraph"><p>Коли ви визначаєте функцію <code>greet()</code>, інтерпретатор буде відповідати <code>greet: ()Unit</code>.  "greet" є, звичайно, іменем функції. Порожні дужки вказують, що функція не сприймає параметрів. Та <code>Unit</code> є тип повернення <code>greet</code>. Тип результата <code>Unit</code> вказує, що функція не повертає цікавих значень. Тип Scala <code>Unit</code> подібний на тип Java <code>void</code>; фактично, кожинй метод, що повертає в Java <code>void</code>, відзеркалюється на метод Scala, що повертає <code>Unit</code>. Методи з типом результата <code>Unit</code>, таким чином, виконуються тільки для заради їх побічних ефектів. В випадку greet(), побічний ефект є дружнє привітання, роздруковане на стандартний вихід.</p></div>
<div class="paragraph"><p>На наступному кроці ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, ввівші :quit або :q.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; :quit
$</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="__4___scala_">Крок 4. Пишемо деякі Scala скрипти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча Scala розроблена допомогти в побудові дуже велико-маштабованих систем, вона також гарно маштабується донизу до скриптинга. Скрипт це тільки послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть це в файл з назвою <code>hello.scala</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>println("Hello, world, from a script!")</code></pre>
</div></div>
<div class="paragraph"><p>потім виконайте:<span class="footnote"><br />[Ви можете виконати скрипт без набирання "scala" під Unix та Windows, використовуючи синтаксис "pound-bang", що показаний в Додатку A.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala hello.scala</code></pre>
</div></div>
<div class="paragraph"><p>Та ви маєте отримати наступне привітання:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, world, from a script!</code></pre>
</div></div>
<div class="paragraph"><p>Аргументи командного рядка скрипта Scala доступні через масив Scala з назвою <code>args</code>. В Scala масиви починаються з нуля, та ви отримуєте доступ до елементів через вказання індексу в дужкає. Так що перший елемент в масиві Scala з назвою <code>steps</code> є <code>steps(0)</code>, не <code>steps[0]</code>, як в Java. Щоб спробувати це, наберіть наступне в новий файл з назвою <code>helloarg.scala</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>// Say hello to the first argument
println("Hello, " + args(0) + "!")</code></pre>
</div></div>
<div class="paragraph"><p>потім виконайте:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala helloarg.scala planet</code></pre>
</div></div>
<div class="paragraph"><p>В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як <code>args(0)</code>. Таким чином ви можете побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, planet!</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що цей скрипт містить коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та любі символи між /* та */. Цей приклад також показує, як рядки конкатенуються (поєднуються) за допомогою оператора + . Це робить як ви очікуєте. Вираз "Hello, " + "world!" призведе до рядка "Hello, world!".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__5___while___if">Крок 5. Цикл з while; рішення з if</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб спробувати <code>while</code>, наберіть наступне в файл на ім'я <code>printargs.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Хоча приклади в цьому розділі допомагають зрозуміти цикли <code>while</code>, вони не демонструють кращий стиль Scala. В настурному розділі ви побачите кращі підходи уникнути ітерації по масивах за допомогою індексів.</td>
</tr></table>
</div>
<div class="paragraph"><p>Цей скрипт починається з визначення змінної <code>var i = 0</code>. Вивід типів надає <code>i</code> тип  <code>scala.Int</code>, оскільки це тип початкового значення, 0. Конструкція <code>while</code> в наступному рядку призводить до того, що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз <code>i &lt; args.length</code> буде <code>false</code>. <code>args.length</code> дає довжину масива <code>args</code>. Блок містить два твердження, кожне зсунуте на два проміжки, рекомендований відступ в Scala. Перше твердження, <code>println(args(i))</code>, друкує i-тий аргумент командного рядка. Наступне твердження, <code>i += 1</code>, інкрементує (збільшує) i на один. Зауважте, що відомі з Java <code>i та i</code> не роблять в Scala. Щоб виконати інкремент в Scala, вам треба сказати або i = i + 1 або i += 1. Виконайте цей скрипт за допомогою наступної команди:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala printargs.scala Scala is fun</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala
is
fun</code></pre>
</div></div>
<div class="paragraph"><p>Для ще більшої розваги наберіть наступний код в файлі на ім'я <code>echoargs.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій версії ми замінили виклик <code>println</code> на виклик <code>print</code>, так що всі ці аргументи будуть друкуватись на тому самому рядку. Щоб зробите читабельним, ви вставляєте один проміжок перед кожним аргументом, за винятком першого, через конструкцію <code>if (i != 0)</code>. Оскільки <code>i != 0</code> буде <code>false</code> перший раз, коли ви проходите через цикл, проміжок не буде надрукований перед першим аргументом. Нарешті, ви додали ще один <code>println</code> в кінці, щоб отримати перевод рядка після друку всіх аргументів. Ваш вивід тепер є досить гарним. Якщо ви виконаєте цей скрипт за допомогою такої команди:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala echoargs.scala Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Ви отримаєте:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що в Scala, як і в Java, ви маєте покладати логічні вирази для <code>while</code> або для <code>if</code> в дужки. (Іншими словами, ви не можете сказати в Scala речі як <code>if i &lt; 10</code>, як ви можете в таких мовах, як Ruby. Ви маєте сказати <code>if (i &lt; 10)</code> в Scala). Інша подібність до Java в тому, що коли блок <code>if</code> має тільки одне твердження, ви можете опціонально випустити фігурні дужки, як демонструєтсья твердженням <code>if</code> в <code>echoargs.scala</code>. І хоча ми не бачили жодної з них, Scala використовує крапку з комою для розділення тверджень, як і Java, за тим винятком, що в Scala кома з крапкою дуже часто опціональна, що дає деяке розслаблення мізинцю правої руки. Однак якщо ви перебуваєте в дещо більш балакучому настрої, ви можете записати скрипт <code>echoargs.scala</code> наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">();</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__6____foreach__for">Крок 6. Ітеруємо за допомогою foreach та for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча ви можете не уявляти цього, коли ви пишете цикли <code>while</code> в попередньому кроці, ви програмуєте в імперативному стилі. В вмперативному стилі, що є стилам, який ви звичайно використовуєте з мовами як Java, C++ та C, ви видаєте одну імперативну команду за раз, ітеруючи за допомогою циклів, та часто змінюєте стан, загальний для різних функцій. Scala дозволяє вам програмувати імперативно, але коли ви будете знати Scala краще, ви будете частіше знаходити себе за програмуванням в більш функціональному стилі. Фактично, одна з головних цілей цієї книги є допомогти вам стати так само комфортним з функціональним стилем, як вам є з імперативним стилем.</p></div>
<div class="paragraph"><p>Одна з головних характеристик функціональної мови в тому, що функції є першокласними конструкціями, і це є дуже вірно в Scala. Наприклад, інший (значно більше стислий) шлях надрукувати кожний аргумент командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">arg</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому коді ви викликаєте метод foreach на <code>args</code>, та передаєте йому функію. В цьому випадку ви передаєте функціональний літерал, що приймає один параметр на ім'я <code>arg</code>. Тілом функції є <code>println(arg)</code>. Якщо ви наберете код вище в новий файл з назвою <code>pa.scala</code> та виконаєте його командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala pa.scala Concise is nice</code></pre>
</div></div>
<div class="paragraph"><p>Ви можете побачили:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Concise
is
nice</code></pre>
</div></div>
<div class="paragraph"><p>В попередньому прикладі інтерпретатор Scala виводить тип <code>arg</code> як <code>String</code>, оскільки <code>String</code> є типом елементів масива, для якого ми викликаємо foreach. Якщо ви схильні бути більш явним, ви можете вказати ім'я типу. Але коли ви зробите це, вам доведеться огорнути аргумент в дужки (що є нормальною формою синтаксиса в жодному разі):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach((arg: String) =&gt; println(arg))</code></pre>
</div></div>
<div class="paragraph"><p>Виконання цього скрипта має ту саму поведінку, що і попереднього.</p></div>
<div class="paragraph"><p>Якщо ви в настрої бути трохи стислішим, ніж більш явним, ви можете отримати перевагу від спеціалного скорочення в Scala. Якщо функціональний літерал складається з одного твердження, що приймає один аргумент, вам не треба явно називати та сказувати аргумент.<span class="footnote"><br />[Це скорочення, що називається частково визначеною функцією, описане в Розділі 8.6.]<br /></span> Таким чином, наступний код також робить:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach(println)</code></pre>
</div></div>
<div class="paragraph"><p>Щоб підсумувати, синтаксис для функціонального літерала є список іменованих параметрів в дужках, стрілка вправо, та потім тіло функції. Синтаксис проілюстрований на Малюнку 2.2.</p></div>
<div class="paragraph"><p>Малюнок 2.2 - Синтаксис функціонального літерала в Scala.</p></div>
<div class="paragraph"><p>Тепер, в цій точці ви можете здивуватись, що трапилось з тіми надійними циклами <code>for</code>, до яких ви звикли при використанні імперативних мов, таких як Java або C. В спробі спрямувати вас в функціональному напрямку, в Scala доступний тільки функціональний родич  <code>for</code> (що називається виразом <code>for</code>). Хоча ви не побачите його повної потужності та виразності, доки не досягнете (або не заглянете наперед) Розділ 7.3, ми дамо вам побіжний погляд. В новому файлі на ім'я <code>forargs.scala</code> наберіть наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Дужки після <code>for</code> містять <code>arg &lt;- args</code>.<span class="footnote"><br />[Ви можете казати "в" для символа &#8592; . Ви будете читати for (arg &#8592; args), таким чином, як "для arg в args."]<br /></span> Зправа від символа <code>&lt;-</code> є знакомий масив <code>args</code>. Зліва від <code>&lt;-</code> є <code>arg</code>, ім'я <code>val</code>, не <code>var</code>. (Оскільки це завжди <code>val</code>, ви просто пишете один <code>arg</code>, не <code>val arg</code>). Хоча <code>arg</code> може виглядати як <code>var</code>, оскільки вона буде отримувати нове значення на кожній ітерації, насправді це <code>val</code>: <code>arg</code> не може бути переприсвоєний в тілі виразу. Замість цього, для кожного елементу масива <code>args</code> буде створений новий <code>val arg</code> та ініціалізований значенням елемента. Після чого буде виконане тіло <code>for</code>.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте скрипт <code>forargs.scala</code> командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala forargs.scala for arg in args</code></pre>
</div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for
arg
in
args</code></pre>
</div></div>
<div class="paragraph"><p>Вираз <code>for</code> в Scala може робити набагато більше ніж це, але цей приклад достатнім для початку. Ми покажемо вам більше щодо <code>for</code> в Розділі 7.3 та Главі 23.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__6">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми вивчили деякі основи Scala, та, надіємось, скористались можливостю написати трохи Scala коду. В наступній главі мо продовжимо цей вступний огляд, та займемось більш складними темами.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3_2">Глава 3</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala_2">Наступні кроки в Scala</h1>
<div class="paragraph"><p>Ця глава продовжує вступ до Scala з попередньої глави. В цій главі ми введемо декілька більш складних можливостей. Коли ви скінчите цю главу, ви будете мати досить знань, щоб почати писати корисні скрипти на Scala. Як і з попередньою главою, ми рекомендуємо вам спробувати ці приклади, по мірі проходження. Кращий спосіб отримати відчуття Scala є почати писати Scala код.</p></div>
<div class="sect1">
<h2 id="__7_____">Крок 7. Параметризація масивів за допомогою типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala ви можете створити примірники об'єктів або примірники класів, використовуючи <code>new</code>. Коли ви створюєте примірник об'єкту в Scala, ви можете параметризувати його за допомогою значень або типів. Параметризація означає "конфігурація" примірника, коли ви створюєте його. Ви параметризуєте примірник значеннями, через передачу об'єктів до конструктора в дужках. Наприклад, наступний код Scala створює нового <code>java.math.BigInteger</code>, та параметризує його значенням "12345":</p></div>
<div class="listingblock">
<div class="content">
<pre><code>val big = new java.math.BigInteger("12345")</code></pre>
</div></div>
<div class="paragraph"><p>Ви параметризуєте примірник типами, коли вказуєте один або більше типів в прямокутних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі <code>greetStrings</code> є значенням типу <code>Array[String]</code>("масив рядків"), що ініціалізований довжиною 3 через його параметризацію значенням 3 в першому рядку кода. Якщо ви запустите код з Лістинга 3.1 як скрипт, ви побачите ще одне привітання <code>Hello, world!</code>. Зауважте, що коли ви параметризуєте примірник обома, типом та значенням, тип іде першим в своїх прямокутних дужках, за якими іде значення в дужках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.1 - Параметризація масива за допомогою типа.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Хоча код в Лістингу 3.1 демонструє важливі концепції, він не показує рекомендований спосіб створювання та ініціалізації масивів в Scala. Ви побачите кращий спосіб в Лістингу 3.2 далі.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо ви знаходитесь в більш явному настрої, ви можете вказати тип <code>greetStrings</code> явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги вивід типів Scala, цей рядок кода семантично еквівалнтний до першого дійсного рядка Лістинга 3.1. Але ця форма демонструє, що хоча частина параметризації типа (імена типів в прямокутних дужках) формує частину типу примірника, частина параметризації значенням (значення в дужках) - ні. Тип <code>greetStrings</code> є <code>Array[String]</code>, не Array[String](3).</p></div>
<div class="paragraph"><p>Наступні три рядка кода з Лістинга 3.1 ініціалізують кожний елемент масиву <code>greetStrings</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви в Scala отримують доступ покладанням індексу в дужках, не прямокутних дужках, як в Java. Таким чином нульовий елемент масива є <code>isgreetStrings(0)</code>, та не <code>greetStrings[0]</code>.</p></div>
<div class="paragraph"><p>Ці три рядка кода ілюструють важливу концепцію для розуміння того, як Scala розглядає визначення <code>val</code>. Коли ви визначаєте змінну за допомогою <code>val</code>, змінна не може бути переприсвоєна, але об'єкт, на який вона посилається, потенційно все ще може бути змінений. Як в цьому випадку, ви не можете переприсвоїти <code>greetStrings</code> на інший масив; <code>greetStrings</code> буде завжди вказувати на той самий примірник <code>Array[String]</code>, яким він був ініціалізований. Але ви можете змінити елементи цього <code>Array[String]</code> з часом, так що сам масив є змінним.</p></div>
<div class="paragraph"><p>Два заключні рядка в Лістингу 3.1 містять вираз <code>for</code>, що друкує кожний елемент <code>greetStringsarray</code> по черзі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший рядок коду в цьому виразі <code>for</code> ілюструє інше загальне правило Scala: якщо метод приймає тільки один параметр, ви можете викликати його без крапки або дужок. В цбому прикладі <code>to</code> насправді є методом, що приймає один аргумент Int. Код <code>0 to 2</code> трансформується в виклик метода <code>(0).to(2)</code>. <span class="footnote"><br />[Цей метод to насправді повертає не масив, але інший різновид послідовності, що містить значення 0, 1 та 2, по якому ітерує for. Послідовності та інші колекції будуть описані в Главі 17.]<br /></span> Зауважте, що цей синтаксис робить, тільки якщо ви явно вказуєте отримувача виклику метода. Ви не можете написати <code>println 10</code>, але ви можете написати <code>Console println 10</code>.</p></div>
<div class="paragraph"><p>Scala технічно не має перевантаження операторів, оскільки вона насправді не має операторів в традиційному сенсі. Замість цього, такі символи, як +, -, * та / можуть бути використані в іменах методів. Таким чином, коли ви друкуєте <code>1 + 2</code> в Scala інтерпретаторі на Кроці 1, ви насправді викликаєте метод з назвою <code>+</code> на <code>Int</code> об'єкті <code>1</code>, передаючи <code>2</code> як параметр. Як ілюстровано на Малюнку 3.1, ви можете альтернативно записати <code>1 + 2</code>, використовуючи традиційний синтаксис виклику метода, <code>(1).+(2)</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.1 - В Scala всі операції є викликами методів.</p></div>
<div class="paragraph"><p>Інша важлива ідея, ілюстрована цім прикладом, це надати вам розуміння того, чому масиви надають доступ через дужки в Scala. Scala має меньше особливих випадків, ніж Java. Масиви є простими примірниками класів, як любі інші класи в Scala. Коли ви застосовуєте дужки, що оточують одне або більше значень до змінної, Scala буде трансформувати код в виклик методу з назвою <code>apply</code> на цій змінній. Так що <code>greetStrings(i)</code> перетвориться на <code>greetStrings.apply(i)</code>. Таким чином, доступ до елемент масива в Scala є простим викликом метода, як любий інший. Цей принцип не ообмежуєть до масивів: любе застосування об'єктів до деяких аргументів в дужках буде трпнсформоване в виклик метода <code>apply</code>. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкта дійсно визначає метод <code>apply</code>. Так що це не особливий випадок; це загальне правило.</p></div>
<div class="paragraph"><p>Подібним чином, коли робиться просвоєння до змінної, до якої застовані дужки з одним або більше аргументом, компілятор буде трансформувати це в виклик метода <code>update</code>, що приймає аргументи в дужках, а такж об'єкт з правого боку від знака рівності. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings(0) = "Hello"</code></pre>
</div></div>
<div class="paragraph"><p>буде трансформовано на:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings.update(0, "Hello")</code></pre>
</div></div>
<div class="paragraph"><p>Таким чином, наступне симантично еквівалентне до коду з лістинга 3.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello&quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;, &quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;world!\n&quot;</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mf">0.</span><span class="n">to</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala досягає концептуальної простоти, трактуючи все, від масивів та виразів, як об'єкти з методами. Ви не маєте пам'ятати особливі випадки, такі, як розбіжності в Java між примітивами та їх відповідними огортаючими типами, або між масивами та звичайними об'єктаи. Більше того, ця одноманітність не накладає значних витрат продуктивності. Компілятор Scala використовує в скомпільованому коді масиви Java, примітивні типи, та природну арифметику, де це можливо.</p></div>
<div class="paragraph"><p>Хоча приклади, що ви бачили на цей момент в цьому кроці, компілюються та виконуються досить гано, Scala провадить більш стислий спосіб для створення та ініціалізації масивів, який в будете звичайно використовувати (Лістинг 3.2). Цей код створює новий масив довжиною три, ініціалізований переданими рядками, <code>"zero"</code>, <code>"one"</code>, <code>"two"</code>. Компілятор виводить тип масива, як <code>Array[String]</code>, оскільки ви передали йому рядки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.2 - Створення та ініціалізація масиву.</p></div>
<div class="paragraph"><p>Що ви насправді робите в Лістингу 3.2, це виклик методу фабрики, під назвою <code>apply</code>, що створює та повертає новий масив. Цей метод <code>apply</code> приймає змінне число аргументів,<span class="footnote"><br />[Список аргументів змінної довжини, або повторювані параметри, описані в Розділі 8.8.]<br /></span> та визначений на об'єкті компанйоні Array. Ви навчитесь більше щодо об'єктов компанйонів в Розділі 4.3. Якщо ви Java програміт, ви можете думати про це, як про виклик статичного методу на ім'я <code>apply</code> на класі <code>Array</code>. Більш балакучий шлях викликати той самий метод <code>apply</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames2</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__8__">Крок 8. Використання списків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна з виликих ідей функціонального стилю програмування є методи, що не мають побічних ефектів. Єдиною дією метода повинне бути обчислення та повернення значення. Деякі переваги, що будуть отримані коли ви приймете цей підхід, в тому, що методи стають менш  заплутаними, і таким чином, більш надійні та використовувані. Інша перевага (в статично типізованій мові) в тому, що все, що входить і виходить з метода перевіряється контролем типів, так що логічні помилки більш вірогідно проявлять себе як помилки типів. Застосування цієї функціональної філософії до світу об'єктів означає зробити об'єкти незмінними.</p></div>
<div class="paragraph"><p>Як ви бачили, масиви Scala є змінними послідовностями об'єктів, що всі поділяють той самий тип. Наприклад, <code>Array[String]</code> містить тільки рядки. Хоча ви не можете змінити довжину масива, після того, як був створений екземпляр, ви можете змінити значення його елементів. Таким чином, масиви є змінні об'єкти.</p></div>
<div class="paragraph"><p>Для незмінних послідовностей об'єктів, що поділяють той самий тип, ви можете використати клас Scala <code>List</code>. Так само, як і з масивами, <code>List[String]</code> містить тільки рядки. Список Scala <code>List</code>, <code>scala.List</code>, відрізняється від типу Java <code>java.util.List</code> в тому, що списки Scala <code>List</code> завжди незмінні (тоді як списки Java <code>List</code> можуть бути змінні). Більш загально, Scala <code>List</code> розроблений дозволити функціональний стиль програмування. Створити список просто, та Лістинг 3.3 показує як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.3 - Створення та ініціалізація списку.</p></div>
<div class="paragraph"><p>Код в Лістингу 3.3 встановлює нову <code>val</code> на ім'я <code>oneTwoThree</code>, ініціалізовану як <code>new List[Int]</code> з цілими елементами 1, 2 та 3.<span class="footnote"><br />[Вам не треба казати new List, оскільки "List.apply()" визначений як метод фабрика на об'єкті компанйоні scala.List. Ви будете читати більше про об'єкти компанйони в Розділі 4.3.]<br /></span> Оскільки <code>List</code> незмінні, вони поводяться трохи подібно до рядків в Java: коли ви викликаєте метод на списку, з імені якого випливає, що список буде змінений, він замість цього створює та повертає нове значення. Наприклад, <code>List</code> має метод на ім'я <code>:::</code> для конкатенації списків. Ось як ви використовуєте його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwo</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">threeFour</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThreeFour</span> <span class="k">=</span> <span class="n">oneTwo</span> <span class="o">:::</span> <span class="n">threeFour</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwo</span> <span class="o">+</span> <span class="s">&quot; and &quot;</span> <span class="o">+</span> <span class="n">threeFour</span> <span class="o">+</span> <span class="s">&quot; were not mutated.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Thus, &quot;</span> <span class="o">+</span> <span class="n">oneTwoThreeFour</span> <span class="o">+</span> <span class="s">&quot; is a new list.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви виконаєте цей скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</code></pre>
</div></div>
<div class="paragraph"><p>Можливо найбільш загальний оператор, якім ви будете користатись зі списками, є <code>::</code>, що вимовляється як "cons". Cons ставить новий елемент до початку існуючого списку, та повертає отриманий список. Наприклад, якщо ви викличете цей скрипт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">twoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">twoThree</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2, 3)</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">В виразі 1 <code>::</code> twoThree, <code>::</code> є методом свого правого операну, списку <code>twoThree</code>. Ви можете запідозрити, що щось не так з асоціативністю метода <code>::</code>, але насправді є просте правило, що треба пам'ятати: якщо метод використовується в операторній нотації, такі, як <code>a * b</code>, метод викликається на лівому операнді, як <code>a.*(b)</code> — за винятком, коли метод закінчується на двокрапку. Якщо ім'я метода закінчується на двокрапку, метод викликається на правому операнді. Таким чином, в 1 <code>::</code> twoThree, метод <code>::</code> викликається на <code>twoThree</code>, передаючи 1: <code>twoThree.::(1)</code>. Асоціативність операторів буде детально дискутована в Розділі 5.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Приймаючи, що скороченим шляхом вказати порожній список є <code>Nil</code>, одним з методів ініціалізувати нові списки є поєднання разом елементів за допомогою оператора <code>cons</code>, з Nil в якості останнього елемента. Причина, з якої вам треба Nil в кінці полягає в тому, що <code>::</code> визначене для класа List. Якщо ви намагатиметесь просто сказати 1 <code>::</code> 2 <code>::</code> 3, це не буде компілюватись, оскільки 3 є Int, що не має метода <code>::</code>. Наприклад, наступний скрипт буде продукувати той самий вихід, що і попередній, <code>List(1, 2, 3)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala List напакований корисними методами, багато з яких показані в Таблиці 3.1. Повна потужність списків буде розкрита в Главі 16.</p></div>
<div class="sect2">
<h3 id="______2">Чому не додавати до списків?</h3>
<div class="paragraph"><p>Клас List пропонує операцію <code>append</code> — вона записується як <code>:+</code> та пояснена в Главі  24 — але ця операція рідко використовується, оскільки час, що займає додати до списку зростає лінійно з розміром списку, тоді як постановка в початок за допомогою <code>::</code> займає сталий час. Якщо ви бажаєте побудувати список ефективно через додавання елементів, ви можете додавати їх в початок, то коли все буде зроблене зробити реверс (обертання) списку. Або ви можете використовувати <code>ListBuffer</code>, змінний список, що пропонує операцію <code>append</code>, та потім, коли все зроблено, викликати <code>toList</code>. <code>ListBuffer</code> буде описаний в Розділі  22.2.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі методи та використання List</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке        </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span> <span class="n">або</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Порожній List</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;Cool&quot;</span><span class="o">,</span> <span class="s">&quot;tools&quot;</span><span class="o">,</span> <span class="s">&quot;rule&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Cool", "tools", "rule"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">thrill</span> <span class="k">=</span> <span class="s">&quot;Will&quot;</span> <span class="o">::</span> <span class="s">&quot;fill&quot;</span> <span class="o">::</span> <span class="s">&quot;until&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Will", "fill", "until"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;d&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Конкатенує два списки (повертає новий List[String] зі значеннями "a", "b", "c", "d")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає елемент з індексом 2 (від нуля) списку thethrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">count</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Рахує число число рядків-елементів в thrill, чия довжина 4 (повертає 2)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без перших двох елементів (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">dropRight</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без двох правих елементів (повертає List("Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">==</span> <span class="s">&quot;until&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Визначає, чи існує елемент-рядок в thrill, що має значення "until" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів thrill, по порядку, що мають довжину 4 (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">forall</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;l&quot;</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи всі елементи в списку thrill закінчуються на літеру "l" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Виконує твердження print на кожному рядку в списку thrill (друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">print</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Те саме що і попередньє, але стисліше (також друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">head</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає перший елемент в списку thrill (повертає "Will")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">init</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає з усіх, крім останнього, елементів в списку thrill (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">isEmpty</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи є список thrill (повертає false)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">last</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає останній елемент в списку thrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає число елементів в списку thrill (повертає 3)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;y&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, отриманий від додавання "y" до кожного елемента-рядка в списку thrill (повертаєList ("Willy", "filly", "untily"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;, &quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Робить рядок з усіх елементів списку (повертає "Will, fill, until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filterNot</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів списку thrill, по порядку, крім тих, що мають довжину 4 (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">reverse</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що складається з усіх елеменітв списку thrill в зворотньому порядку (повертає List("until", "fill", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">sort</span><span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що містить всі елементи thrill в алфавітному порядку по першій літері, переведеній в нижній реєстр (повертає List("fill", "until", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">tail</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill мінус перший елемент (повертає List("fill", "until"))</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__9__">Крок 9. Використання таплів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Інший корисний контейнерний об'єкт є тапл. Як списки, тапли є нехмінними, але на відміну від списків, тапли можуть містити різні типи елементів. Коли список може бути List[Int] або aList[String], тапл може містити обоє, ціле та рядок, одночасно. Тапли дуже корисні, наприклад, коли ви повертаєте декілька об'єктів з метода. В той час, коли в Java ви будете часто створювати JavaBean-подібний клас, що міститиме декілька повертаємих значень, в Scala ви можете просто повернути тапл. Та це просто: щоб ініціалізувати тапл, що містить деякий об'єкти, просто покладіть об'єкти в дужки, розділені комами. Як тільки ви маєте примірник таплу, ви можете отримати доступ до його індивідуальних об'єктів через крапку, підкреслення, та 1-базований індекс елементів. Приклад показаний на Лістингу 3.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">pair</span> <span class="k">=</span> <span class="o">(</span><span class="mi">99</span><span class="o">,</span> <span class="s">&quot;Luftballons&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.4 - Creating and using a tuple.</p></div>
<div class="paragraph"><p>В першому рядку Лістинга 3.4 ви створюєте новий тапл, що містить ціле 99 як перший елемент, та рядок "Luftballons" як другий елемент. Scala виводить тип тапла як <code>Tuple2[Int, String]</code>, та надає цей тип до змінної <code>pair</code>, також. В другому рядку ви отримуєте доступ до поля _1, що буде продукувати перший елемент, <code>99</code>. "." в другому рядку є та сама крапка, яку ви використовуєте для доступу до поля або для виклику метода. В цьому випадку ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>99
Luftballons</code></pre>
</div></div>
<div class="paragraph"><p>Справжній тип тапла залежить від числа елементів, яке він містить, та від типів ціх елементів. Таким чином, тип <code>(99, "Luftballons")</code> є <code>Tuple2[Int, String]</code>. Тип <code>('u', 'r', "the", 1, 4, "me")</code> є <code>Tuple6[Char, Char, String, Int, Int, String]</code>.<span class="footnote"><br />[Хоча концептуально ви можете створити тапли любої довжини, наразі бібліотека Scala визначає їх до Tuple22.]<br /></span></p></div>
<div class="sect2">
<h3 id="_____3">Доступ до елементів тапла</h3>
<div class="paragraph"><p>Ви можете здивуватись, чому ви не можете отримати доступ до елементів тапла як до елементів списку, наприклад, як <code>pair(0)</code>. Причина є в тому, що для списка метод <code>apply</code> завжди повертає той самий тип, але кожний елемент тапла може бути різного типу: _1 може мати одит тип результату, _2 інший, і так далі. Ці числа _N базуються не одиниці, замість нуля, оскільки починати з 1 є традицією, встановленою іншими мовами зі статичними типизованими таплами, як Haskell та ML.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__10____">Крок 10. Використання множин та мап</h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки Scala націлена допомогти вам отриати переваги від обох, функціонального та імперативного стилів, її бібліотеки колекцій наголошують на різниці між змінними та незмінними колекціями. Наприклад, масиви завжди змінні; списки завжди незмінні. Scala також провадить змінні та незмінні альтернативи для множин та мап, але використовує ті ж самі прості імена для обої версій. Для множин та мап Scala моделює змінність в ієрархії класів.</p></div>
<div class="paragraph"><p>Наприклад, Scala API містить базовий трейт для множин, де трейт схожий на Java інтерфейс. (Ви знайдете більше щодо трейтів в Главі 12). Потім Scala провадить два субтрейти, один для змінних множин, та інший для незмінних множин.</p></div>
<div class="paragraph"><p>Як ви можете бачити на Малюнку 3.2, ці три трейти всі поділяють те саме просте ім'я, <code>Set</code>. Однак їх повністю кваліфіковані імена відрізняються, оскільки кожний знаходиться в окремому пакунку. Конкретні класи множин в Scala API, такі як класи <code>HashSet</code>, показані на Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java ви "реалізуєте" інтерфейси, в Scala ви "розширюєте" або "міксуєте" трейти). Таким чином, якщо ви бажаєте використати HashSet, ви маєте обрати між змінним та незмінним варіаціями, в залежності від ваших потреб. Спосіб по замовчанню створити множину показаний на Лістингу 3.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jetSet</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Boeing&quot;</span><span class="o">,</span> <span class="s">&quot;Airbus&quot;</span><span class="o">)</span>
<span class="n">jetSet</span> <span class="o">+=</span> <span class="s">&quot;Lear&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">jetSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;Cessna&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.5 - Створення, ініціалізація та використання незмінної множини.</p></div>
<div class="paragraph"><p>Малюнок 3.2 - Ієрархія класів для множин Scala.</p></div>
<div class="paragraph"><p>В першому рядук кода в Лістингу 3.5 ви визначаєте нову <code>var</code> на ім'я <code>jetSet</code>, та ініціалізуєте її незмінною множиною, що має два рядка, "Boeing" та "Airbus". Як показує приклад, ви можете створити множини в Scala подібно до того, як ви створюєте списки та масиви: через виклик метода фабрики з назвою <code>apply</code> на об'єкті компанйоні Set. В Лістингу 3.5 ви визиваєте <code>apply</code> на об'єкті компанйоні для  <code>scala.collection.immutable.Set</code>, що повертає примірник по замовчанню, незмінний <code>Set</code>. Компілятор Scala виводить тип <code>jetSet</code> як незмінний <code>Set[String]</code>.</p></div>
<div class="paragraph"><p>Щоб додати новий елемент до множини ви застосовуєте виклик + на множині, передаючи новий елемент. На обох, змінній та незмінній множині метод + буде створювати та поверне нову множину з доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною. Хоча змінні множини пропонують справжній метод <code>+=</code>, незмінні множини ні.</p></div>
<div class="paragraph"><p>В цьому випадку другий рядок коду, <code>jetSet += "Lear</code>, в основному є скороченням для:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">jetSet</span> <span class="k">=</span> <span class="n">jetSet</span> <span class="o">+</span> <span class="s">&quot;Lear&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, в другому рядку Лістингу 3.5 ви переприсвоююте <code>jetSet var</code> новою множиною, що містить "Boeing", "Airbus", та "Lear". Нарешіт, в останньому рядку Лістингу 3.5 іде друк того, чи містить або ні множина рядок "Cessna". (Як ви і очікували, друкується false).</p></div>
<div class="paragraph"><p>Якщо ви бажаєте змінну множину, вам треба використовувати імпорт, як показано в Лістингу 3.6:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">movieSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Hitch&quot;</span><span class="o">,</span> <span class="s">&quot;Poltergeist&quot;</span><span class="o">)</span>
<span class="n">movieSet</span> <span class="o">+=</span> <span class="s">&quot;Shrek&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">movieSet</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.6 - Створення, ініціалізація та використання змінної множини.</p></div>
<div class="paragraph"><p>В першому рядку Лістингу 3.6 ви імпортуєте <code>Set</code>. Як і з Java, твердження <code>import</code> дозволяє вам використовувати просте ім'я, таке як  <code>Set</code>, замість довшого, повністю кваліфікованого імені. Як результат, коли ви кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі <code>scala.collection.mutable.Set</code>. В цьому рядку ви ініціалізуєте <code>movieSet</code> новою змінною, що містить рядки "Hitch" та "Poltergeist". Наступний рядок додає "Shrek" до змінної множини, викликаючи метод <code>+=</code> до множини, передаючи йому рядок "Shrek". Як зазначалось раніше, <code>+=</code> насправді є методом, визначеним на змінній множині. За вашим бажанням, замість <code>writingmovieSet += "Shrek"</code>, ви можете написати <code>movieSet.+=("Shrek")</code>.<span class="footnote"><br />[Оскільки множина в Лістингу 3.6 змінна, немає потреби переприсвоювати movieSet, ось чому вона може бути встановлена в val. До контрасту, використання += з незмінною множиною в Лістингу 3.5 потребує переприсвоєння jetSet, ось чому воно має бути var.]<br /></span></p></div>
<div class="paragraph"><p>Хоча реалізація множин по замовчанню, спродукована змінною та незмінною методами фабриками <code>Set</code>, буде достатньою в багатьох ситуаціях, часом ви можете побажати явно задати клас. Нащастя, синтаксис є подібним. Просто імпортуйте потрібний вам клас, та використовуйте метод фабрику на його об'єкті компанйоні. Наприклад, якщо вам треба незмінний <code>HashSet</code>, ви можете зробити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.immutable.HashSet</span>
<span class="k">val</span> <span class="n">hashSet</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="s">&quot;Tomatoes&quot;</span><span class="o">,</span> <span class="s">&quot;Chilies&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">hashSet</span> <span class="o">+</span> <span class="s">&quot;Coriander&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший корисний клас колекції в Scala є <code>Map</code>. Як і з множинами, Scala провадить змінну та незмінну версії <code>Map</code>, використовуючи ієрархію класів. Як ви можете побачити на Малюнку 3.3, ієрархія класів для мап виглядає мажйе так, як така для множин. Існує базовий трейт <code>Map</code> в пакунку <code>packagescala.collection</code>, і два субтрейти Maps: змінний Map в <code>scala.collection.mutable</code> та незмінний в <code>scala.collection.immutable</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.3 - Ієрархія класів для Scala мап.</p></div>
<div class="paragraph"><p>Реалізації Map, такі як <code>HashMaps</code>, показані в ієрархії на Малюнку 3.3, розширюють або змінний, або незмінний трейт. Ви можете створити та ініціалізувати мапи, використовуючи метди фабрики, подібні до таких для масивів, списків та множин.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">treasureMap</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;Go to island.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;Find big X on ground.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;Dig.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">treasureMap</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.7 - Створення, ініціалізація та використання змінної мапи.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 3.7 показує змінну мапу в дії. On the first line of Лістинг 3.7, you import the mutable Map. You then define a val named treasureMap, and initialize it with an empty mutable Map that has integer keys and string values. The map is empty because you pass nothing to the factory method (the parentheses in "Map[Int, String]()" are empty).<span class="footnote"><br />[Явна параметризація типу, "[Int, String]", є необхідною в Лістингу 3.7, оскільки без любих значень, переданих в метод фабрику компілятор не здатний вивести тип параметрів мапи. Для контрасту, компілятор може вивести тип параметрів зі значень, переданих до фабрики мапи, показаної в Лістингу 3.8, так що явних параметрів типу не треба.]<br /></span> На наступних трьох рядках ви додаєте до мапи пари ключ/значення, використовуючи методи <code>-&gt;</code> та <code>+=</code>. Як вже було проілюстровано, компілятор Scala трансформує двомісні вирази операцій, як <code>1 -&gt; "Go to island."</code> на <code>(1).-&gt;("Go to island.")</code>. Таким чином, коли ви кажете <code>1 -&gt; "Go to island."</code>, ви насправді викликаєте метод на ім'я <code>-&gt;</code> на цілому зі значенням <code>1</code>, передаючи йому рядок зі значенням "Go to island." Цей метод <code>-&gt;</code>, який ви можете викликати на об'єкті в програмі Scala, повертає дво-елементний тапл, що містить ключ та значення.<span class="footnote"><br />[Механізм Scala, що дозволяє вам викликати  &#8594; на любому об'єкті, неявне перетворення, буде розкрите в Главі 21.]<br /></span> Потім ви можете передати тапл до метода <code>+=</code> об'єкта мапи, на який посилається <code>treasureMap</code>. Нарешті, останній рядок друкує значення, що відповідає ключу 2 treasureMap.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте цей код, він надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Find big X on ground.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви обираєте незмінну мапу, імпорт непотрібний, бо незмінна є мапою по замовчанню. Приклад показаний в Лістингу 3.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">romanNumeral</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;I&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;II&quot;</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;III&quot;</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="s">&quot;IV&quot;</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="s">&quot;V&quot;</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">romanNumeral</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.8 - Створення, ініціалізація та використання незмінної мапи.</p></div>
<div class="paragraph"><p>Зважаючи на те, що тут немає імпортів, ви можете сказати, що <code>Map</code> в першому рядку Лістинга 3.8 ви отримаєте замовчання, <code>scala.collection.immutable.Map</code>. Ви передаєте п'ять таплів ключ/значення до метода фабрики мапи, що повертає незмінну <code>Map</code>, яка містить передані пари ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__11____">Крок 11. Вчимсоь розпізнавати функціональний стиль</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, Scala дозволяє вам програмувати в імперативному стилі, але заохочує вас адоптувати більш функціональний стиль. Якщо ви прийшли в Scala з імперативного бекграунда, наприклад, якщо ви Java програміст, одним з головних викликів, з яким ви стикаєтесь при вивченні Scala є зрозуміти, як програмувати в функціональному стилі. Ми розуміємо, що цей стиль зпочатку може бути незвичним, але в цій книзі ми намагаємось направляти вас в цьому переході. Це буде потребувати деякої роботи з вашого боку, і ми закликаємо докласти зусиль. Якщо ви прийшли з імперативного бекграунду, ми віримо, що вивчення програмування в функціональному стилі не тільки зробить вам кращим програмістом Scala, але також розширить ваші горизонти, та зробить кращим програмістом взагалі.</p></div>
<div class="paragraph"><p>Перший крок це розпізнати різницю між двома стилями в коді. Один промовистий знак - це якщо код містить любі <code>var</code>, вірогідно що він в імперативному стилі. Якщо код взагалі не містить — тобто, він містить тільки <code>val</code> — вірогідно він в функціональному стилі. Таким чином, одним шляхом рухатись в функціональному стилі є спробувати програмувати без <code>var</code>.</p></div>
<div class="paragraph"><p>Якщо ви походите з імперативного бекграунда, як Java, C++ або C#, ви можете думати про <code>var</code> як про звичану змінну, та про <code>val</code> як про спеціальний різновид змінних. З іншого боку, якщо ви походите з функціонального бекграунда, як Haskell, OCaml або Erlang, ви можете думати про <code>val</code> як про звичану змінну, та <code>var</code> як спробу святотацтва. Однак перспектива Scala полягає в тому, що <code>val</code> та <code>var`є просто два різні інструменти в вашому наборі, обоє корисні, та жодний не є втілення зла. Scala заохочує вас вивчати щодо `val</code>, але кінець кінцем отримати кращий інструмент, що знадобиться для вашої роботи. Однак навіть якщо ви згодні з цією збалансованою філософією, ви все одно можете на початку знайти складним, як позбавитись від <code>var</code> в своєму коді.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо наступний цикл <code>while</code>, адаптований з Глави 2, що використовує <code>var</code>, та є, таким чином, в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трансформувати цей шматок коду в більш функціональний стиль, поклавши край <code>var</code>, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>або так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад ілюструє одну перевагу від програмування з меншою кількістю <code>var</code>. Рефактований (більш функціональний) код є чистіший, більш стислий, та менш схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з якої Scala заохочує до функціонального стилю, в тому, що він може допомогти вам писати більш зрозумілий, менш схильний до помилок код.</p></div>
<div class="paragraph"><p>Але ви можете пійти навіть далі. Рефакторений метод <code>printArgs</code> не є повністю функціональним, бо він має побічні ефекти — в цьому випадку цей побічний ефект є друк у стандартний вихідний потік. Промовистий знак що функція має побічні ефекти, це коли тип її результата Unit. Якщо функція не повертає жодного цікавого значення, що і означає тип результата Unit, єдиним шляхом, яким функція може зробити зміни в світі, че через деякий різновид побічного ефекту. Більше функціональний підхід може бути в визначенні метода, що форматує передані <code>args</code> для друку, але тільки повертає форматований рядок, як показано в Лістингу 3.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">args</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.9 - A function without side effects or vars.</p></div>
<div class="paragraph"><p>Тепер ви дійсно функціональні: немає ні побічних ефектів, ні <code>var</code> в полі зору. Метод <code>mkString</code>, який ви можете викликати на любій ітерабельній колекції (включаючи масиви, списки, множини та мапи), повкртає рядок, що складається з викликів <code>toString</code> на кожному елементі, розділені переданим рядком. Таким чином, якщо аргументи складаються з трьох аргументів, "zero", "one", "two", <code>formatArgs</code> буде повертати <code>"zero\none\ntwo"</code>. Звичайно, ця функція насправді не друкує нічого назовні, як робив метод <code>printArgs</code>, але ви можете просто передати його результат до <code>println</code>, щоб досягти цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожна корисна програма, вірогідно, буде мати побічні ефекти в деякій формі; інакше, буде неможливо провадити значення до зовнішнього світу. Схильність до методів без побічних ефектів заохочує вас розробляти програми, де код з побічними ефектами мінімізований. Одна з переваг цього підходу в тому, щоце може допомогти вашим програмам простіше тестуватись.</p></div>
<div class="paragraph"><p>Наприклад, щоб протестувати любий з трьох методів <code>printArgs</code>, показаних раніше в цьому розділі, вам треба перевизначити <code>println</code>, перехопити переданий йому вивід, та переконатись, що там те, що ви очікуєте. Для контрасту, ви можете тестувати функцію <code>formatArgs</code>, просто перевіряючи її результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">formatArgs</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="s">&quot;zero\none\ntwo&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод Scala <code>assert</code> перевіряє переданий їй <code>Boolean</code>, та якщо воно <code>false</code>, підіймає <code>AssertionError</code>. Якщо передане <code>Boolean</code> є <code>true</code>, <code>assert</code> просто повертає керування. Ви навчитесь більше щодо тверджень в тестах в Главі 14.</p></div>
<div class="paragraph"><p>Кажучи це, майте на увазі, що ні <code>var</code>, ні побічні ефекти не є природним злом. Scala не є чисто функціональною мовою, що змушує вас програмувати все в функціональному стилі. Scala є гібридною, імперативно/функціональною мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще підходить до вирішуваної проблеми, і в таких випадках вам не треба боятись використовувати його. Однак щоб допомогти вам навчитись, як програмувати без <code>var</code>, ми покажемо вам багато специфічних прикладів коду з <code>var</code>, та як трансформувати ці <code>val</code> в Главі 7.</p></div>
<div class="sect2">
<h3 id="____scala_">Збалансоване ставлення для Scala програмістів</h3>
<div class="paragraph"><p>Схиляйтесь до <code>val</code>, незмінних об'єктів та методів без побічних ефектів. Спочатку розпочніть з них. Використовуйте <code>var</code>, змінні об'єкти та методи з побочними ефектами, коли ви маєте специфічні потреби, та обгрунтування для них.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__12____">Крок 12. Читання рядків з файла</h2>
<div class="sectionbody">
<div class="paragraph"><p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробки рядків в файлі. В цьому розділі ви побудуєте скрипт, що читає рядки з файла, та друкує їх, проставляючи напочату кількість символів в кожному рядку. Перша версія показана в Лістингу 3.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">())</span>
    <span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.10 - Читання рядків з файла.</p></div>
<div class="paragraph"><p>Цей скрипт починається з імпорту класу на ім'я <code>Source</code> з пакунка  <code>scala.io</code>. Потім він перевіряє, щоб побачити, що в командному рядку був вказаний хоча б один аргумент. Якщо так, перший аргумент інтерпретується як ім'я файла, що треба відкрити та обробити. Вираз <code>Source.fromFile(args(0))</code> намагається відкрити вказаний файл, та повертає об'єкт <code>Source</code>, на якому ви викликаєте <code>getLines</code>. Метод <code>getLines</code> повертає <code>Iterator[String]</code>, що провадить по одному рядку на кожній ітерації, відкидаючи символ кінця рядка. Вираз <code>for</code> ітерує по цім рядках, та друкує для кожноого довжину рядка, проміжок, та сам рядок. Якщо в командному рядку не надано жодного аргументу, фінальне твердження <code>else</code> буде друкувати повідомлення в стандартний потік помилок. Якщо ви покладете цей код в файл на ім'я <code>countchars1.scala</code>, та викличете його для самого себе командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala countchars1.scala countchars1.scala</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51 for (line &lt;- Source.fromFile(args(0)).getLines())
37 println(line.length + " " + line)
1 }
4 else
46 Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Хоча скрипт в своїй поточній формі друкує потрібну інформацію, ви можете побажати підрівняти числа, вирівняти вправо, та додати символ роздільника, так щоб вивід виглядав так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 | import scala.io.Source
 0 |
22 | if (args.length &gt; 0) {
 0 |
51 |   for (line &lt;- Source.fromFile(args(0)).getLines())
37 |     println(line.length + " " + line)
 1 | }
 4 | else
46 |   Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Щоб досягти цього, ви можете ітерувати по рядках двічі. На першому проході ви будете визначати максимальну довжину, достатню для любого підрахунку символів. На другому проході ви друкуєте вивід, використовуючи максимальну ширину, що обчислена раніше. Оскільки ви будете ітерувати по рядках двічі, ми можете також присвоїти їх до змінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
</pre></div></div></div>
<div class="paragraph"><p>Заключний <code>toList</code> потрібне, бо метод <code>getLines</code> повертає ітератор. Коли ви проходите через ітератор, він вже витрачений. Трансформуючи його в список через виклик <code>toList</code>, ви отримаєте здатність ітерувати так багато раз, як вам треба, ціною зберігання всіх рядків з файла, одночасно. Таким чином, змінна <code>lines</code> посилається на список рядків, що складають вміст файла, вказаного в командному рядку. Далі, оскільки ми будемо обчислювати ширину довжини кожного рядка двічі, по разу для кожної ітерації, ви можете виділити цей вираз в невелику функцію, що обчислює скільки символів в ширину буде займати довжина рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>З такою функцією ви можете обчислювати максимальну ширину таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span>
  <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">maxWidth</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ви ітеруєте по кожному рядку за допомогою вираза <code>for</code>, обчислює символьну ширину довжини рядка, і якщо вона довша ніж поточний максимум, присвоюється до <code>maxWidth</code>, <code>var</code>, що була ініціалізована як 0. (Метод <code>max</code>, який ви можете викликати на Int, повертає більше зі значень, того, на якому вона викликана, та переданого як параметр). Альтернативно, якщо ви обираєте знайти максимум без <code>var</code>, ви можете спочатку знайти довший рядок, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>reduceLeft</code> застосовує передану функцію до перших двох елементів в <code>lines</code>, потім застосовує її до результату першої операції та наступного елементу в <code>lines</code>, і так далі, по всьому списку. На кожному такому застосуванні результат буде довшим рядком, знайденим до цього моменту, оскільки передана функція, <code>(a, b) =&gt; if (a.length &gt; b.length) a else b</code>, повертає довший з переданих рядків. <code>reduceLeft</code> буде повертати результат останнього застосування функції, що в цьому випадку буде найдовшим рядком-елементом, що міститься в <code>lines</code>.</p></div>
<div class="paragraph"><p>Маючи цей результат, ви можете обчислити максимальну ширину, передаючи найдовший рядок в <code>towidthOfLength</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що лишається, це надрукувати рядки з відповідним форматуванням. Ви можете зробити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
<span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
<span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому виразі ви ще раз ітеруєте по рядках. Для кожного рядка ви спочатку обчислюєте число проміжків, потрібних перед довжиною рядка, та присвоюєте його до <code>numSpaces</code>. Потім ви створюєте рядок, що містить <code>numSpaces</code> проміжків за допомогою вираза <code>" " * numSpaces</code>. Нарешті ви друкуєте інформацію з бажаним форматуванням. Повний скрипт виглядає як показано на Лістингу 3.11:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
  <span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
    <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
  <span class="o">)</span>
  <span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
    <span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.11 - Друкування форматованого підрахунку символів для рядків в файлі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__7">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зі знанням, що ви отримали в цій главі, ви повинні бути здатні почати використовувати Scala для малих завдань, особливо скриптів. В подальших главах ми будемо занурюватись далі в ці теми, та введемо інші теми, що не які тут не було натяку.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__4_2">Глава 4</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____4">Класи та об'єкти</h1>
<div class="paragraph"><p>Тепер ви побачили основи класів та об'єетів Scala з попередніх двох символів. В цій главі ми проведемо вас трохи глибше. Ви навчитесь більше щодо класів, полів те методів, та отримаєте огляд виводу крапки з комою. Ми обсудимо об'єкти синглтонів, включаючи як їх використовувати для написання та виконання застосування Scala. Якщо ви знайомі з Java, ви знайдете, що концепції Scala є подібними, але не саме такі самі. Так що навіть якщо ви Java гуру, все одно це читання варте того.</p></div>
<div class="sect1">
<h2 id="_4_1____">4.1 Класи, поля та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас є проектом об'єкту. Коли ви визначаєте клас, ви можете створити об'єкти з проекту класу за допомогою ключового слова <code>new</code>. Наприклад, маючи визначення класа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
<span class="c1">// class definition goes here</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити об'єкти <code>ChecksumAccumulator</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Всередині визначення класа ви покладаєте поля та методи, що разом називаються членами. Поля, що ви визначаєте за допомогою <code>val</code> або <code>var</code>, є змінними, що посилаються на об'єкти. Методи, що ви визначаєте за допомогою <code>def</code>, містять виконавчий код. Поля зберігають стан, або дані об'єкта, тоді як методи використовують ці дані, щоб зробити обчислювальну роботу об'єкта. Коли ви створюєте примірник класу, середовище виконання відкладає деяку пам'ять для зберігання образу стану об'єкта (тобто вмісту його змінних). Наприклад, так ви визначаєте клас <code>ChecksumAccumulator</code>, та даєте йому поле <code>var</code> на ім'я <code>sum</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>та двічі створюєте його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
<span class="k">val</span> <span class="n">csa</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Зображення об'єктів в пам'яті може виглядати так:</p></div>
<div class="paragraph"><p>Оскільки <code>sum</code>, поле, деклароване в класі <code>ChecksumAccumulator</code>, є <code>var</code>, не <code>val</code>, ви можете пізніше переприсвоїти <code>sum</code> інше значення  <code>Int</code>, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">acc</span><span class="o">.</span><span class="n">sum</span> <span class="k">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер картинка може виглядати ось так:</p></div>
<div class="paragraph"><p>Одна річ, що треба зауважити щодо цього малюнка, в тому, що тут дві змінні <code>sum</code>, одна в об'єкті, не який посилається <code>acc</code>, та інша в об'єкті, на який посилається <code>csa</code>. Поля також відомі як взмінні примірника, бо кожний примірник отримує свій власний набір змінних. Колективно, змінні примірника-об'єкта складають образ пам'яті об'єкта. Ви бачите ілюстрацію цього тут, не тільки тому що ви бачите дві змінні <code>sum</code>, але і через те, що коли змінюєте одну, це не впливає на іншу.</p></div>
<div class="paragraph"><p>Інша річ, на яку слід звернути увагу в цьому прикладі, це те, що ви були в змозі змінити об'єкт, на який посилається <code>acc</code>, навіть якщо сам <code>acc</code> <code>val</code>. Що ви не можете робити з <code>acc</code> (або csa), з гляду на те, що вони <code>val</code>, не <code>var</code>, це переприсвоїти їм інший об'єкт. Наприклад, наступна спроба схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Не буде компілюватись, бо acc є val</span>
<span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, все, на що ви можете розраховувати, це що <code>acc</code> буде завжди посилатись на той самий об'єкт <code>ChecksumAccumulator</code>, яким його ініціалізували, але поля, що містяться всередині цього об'єкта, можуть змінюваться з часом.</p></div>
<div class="paragraph"><p>Один важливий шлях досягти надійності об'єкта, є переконатись, що стан об'єкта — значення його змінних примірника — залишаються валідними під час цілого життєвого циклу. Перший крок є заборонити зовнішньому світу напряму отримувати доступ до полів, зробивши поля приватними. Оскільки приватні поля досяжні тільки з методів, визначених в тому ж класі, весь код, що може оновити стан, буде локалізований в класі. Щоб декларувати приватне поле, покладіть модифікатор доступу <code>private</code> перед полем, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи таку декларацію <code>ChecksumAccumulator</code>, люба спроба отримати доступ до <code>sum</code> ззовні класу буде невдалою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
<span class="n">acc</span><span class="o">.</span><span class="n">sum</span> <span class="k">=</span> <span class="mi">5</span> <span class="c1">// Не буде компілюватись, оскільки `sum` є приватним</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Спосіб, в який ви робите члени публічними в Scala, це не вказувати явно жодного модифікатора доступу. Інакше кажучи, там, де ви кажете <code>public</code> в Java, ви просто нічого не кажете в Scala. Публічний рівень доступу в Scala обираєтьмя по замовчанню.</td>
</tr></table>
</div>
<div class="paragraph"><p>Тепер, коли <code>sum</code> є <code>private</code>, єдиний код, що може отримати доступ до <code>sum</code> є код, визначений всередині тіла самого класа. Таким чином, <code>ChecksumAccumulator</code> не буде дуже корисним, якщо ми не визначимо деякі методи для нього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">checksum</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>ChecksumAccumulator</code> має два методи, <code>add</code> та <code>checksum</code>, обоє з яких демонструють базову форму визначення функції, показану на Малюнку 2.1.</p></div>
<div class="paragraph"><p>Любі параметри метода можуть бути використані всередині метода. Одна важлива характеристика пreasonараметрів метода в Scala в тому, що вони <code>val</code>, не <code>var</code>.<span class="footnote"><br />[Причина, з якої параметри є val в тому, що про val простіше розмірковувати. Ви більше не дивитесь, щоб визначити, чи val було перепризначене, як ви маєте робити з var.]<br /></span> Таким чином, якщо ви спробуєте переприсвоїти параметр всередині метода в Scala, це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">b</span> <span class="k">=</span> <span class="mi">1</span> <span class="c1">// Не буде компілюватись, оскільки b є val</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча <code>add</code> та <code>checksum</code> в цій версії <code>ChecksumAccumulator</code> коректно реалізують бажану функціональність, ви можете виразити їх в більш стислому стилі. Перше, <code>return</code> в кінці метода <code>checksum</code> є надлишковим і може бути відкінуте. За відсутності явного твердження  <code>return</code>, метод Scala повертає останнє значення, обчислене методом.</p></div>
<div class="paragraph"><p>Рекомендованим стилем для методів є, фактично, уникати мати явний, а особливо декілька, тверджень <code>return</code>. Замість цього думайте про кожний метод як про вираз, що видає одне значення, яке він повертає. Ця філософія буде надихати вас робити методи досіть малими, та ділити великі методи на декілька меньших. З іншого боку, вибір дизайну залежить від контексту, та Scala спрощує написання методів, що мають декілька явних <code>returns</code>, якщо це те, що ви задумали.</p></div>
<div class="paragraph"><p>Оскільки все, що робить <code>checksum</code> це обчислення значення, він не потребує явного <code>return</code>. Інше скорочення для методів є те, що ви можете опустити фігурні дужки, якщо метод тільки обчислює одне результуюче значення. Якщо результуючий вираз короткий, його навіть можна покласи в той же рядок, що і сам <code>def</code>. Для виключної стислості ви можете відкинути тип результату, і Scala виведе його. З ціма змінами, клас <code>ChecksumAccumulator</code> виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span> <span class="k">=</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
  <span class="k">def</span> <span class="n">checksum</span><span class="o">()</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча компілятор Scala буде коректно виводити типи результату методів <code>add</code> та <code>checksum</code>, показаних в попередньому прикладі, читачам коду буде треба подумки вивести ці типи результату, через дослідження тіла методів. Як результат, часто краще явно провадити типи результату публічних методів, декларованих в класі, навіть якщо компілятор може вивести його за вас. Лістинг 4.1 показує цей стиль.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file ChecksumAccumulator.scala</span>
<span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span> <span class="o">}</span>
  <span class="k">def</span> <span class="n">checksum</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.1 - Фінальна версія класу ChecksumAccumulator.</p></div>
<div class="paragraph"><p>Методи з типом результата Unit, такі як метод <code>add</code> в ChecksumAccumulator, виконуються заради своїх побочних ефектів. Побічний ефект в основному визначений як зміна стану десь зовні до метода, або виконання операції I/O. В випадку <code>add</code> побічний ефект полягає в переприсвоєнні змінної <code>sum</code>. Метод, що виконується виключно ради побічних ефектів, також відомий як процедура.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_2____">4.2 Вивід крапки з комою</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala програмах крапка з комою в кінці твердження часто є опціональними. Ви можете ставити їх, якщо бажаєте, але не зобов'язані робити це, якщо рядок сам по собі розташований на одному рядку. З іншого боку, крапка з комою обов'язкові, якщо ви маєте декілька тверджень в одному рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span><span class="o">;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте ввести твердження, що займає декілька рядків, більшість часу ви можете просто покласти її, і Scala поділить тврдження в коректному місці. Наприклад, наступне трактується як однорядкове твердження:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;too small&quot;</span><span class="o">)</span>
<span class="k">else</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;ok&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак часом Scala буде ділити твердження на дві частини проти вашого бажання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span>
<span class="o">+</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Це розбирається як два твердження, <code>x</code> та <code>+y</code>. Якщо вашим наміром було розібрати це як одне твердження <code>x + y</code>, ви завжди можете огорнути це в дужки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span>
<span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно, ви можете покласти <code>+</code> в кінці рядка. Тільки з цієї причини, коли ви зціплююте інфіксні операції, такі як <code>+</code>, є загальним стилем Scala покладати оператор в кінці рядка, а не напочатку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span>
<span class="n">y</span> <span class="o">+</span>
<span class="n">z</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="______3">Правила виводу крапок з комою</h3>
<div class="paragraph"><p>Точні правила для розділення тверджень дивуюче прості, як для того, як гарно вони роблять. Коротко, кінці рядків трактуються як крапка з комою, за винятком коли вірне одна умова з наступних:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Розглядаємий рядок завершується на слово, яке не може бути легальним в кінці твердження, таке, як крапка або інфіксний оператор.
</p>
</li>
<li>
<p>
Наступний рядок починається зі слова, що не може починати твердження.
</p>
</li>
<li>
<p>
Рядок завершується, коли відкриті дужки (&#8230;) або [&#8230;], оскільки вони в жодному разі не можуть містити декілька тверджень.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_3___">4.3 Об'єкти синглтонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, один спосіб, в який Scala більш об'єктно-орієнтована, ніж Java, це що класи в Scala. Замість цього,  Scala має об'єкти синглтонів. Визначення об'єкта синглтона виглядає як визначення класу, за винятком того, що замість ключового слова <code>class</code> ви використовуєте ключове слово <code>object</code>. Лістинг 4.2 показує приклад.</p></div>
<div class="paragraph"><p>Об'єкт синглтона на цій фігурі названий <code>ChecksumAccumulator</code>, те саме, що і ім'я класу в попередньому прикладі. Коли сінглтон поділяє те саме ім'я з класом, він називається об'єктом компанйоном класа. Ви маєте обох, клас та його об'єкт компанйон в тому ж джерельному файлі. Клас називається компанйон класом об'єкта синглтона. Клас та його об'єкт компанйон можуть отримувати доступ до приватних членів один одного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file ChecksumAccumulator.scala</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">object</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">calculate</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
      <span class="n">cache</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">toByte</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="n">acc</span><span class="o">.</span><span class="n">checksum</span><span class="o">()</span>
      <span class="n">cache</span> <span class="o">+=</span> <span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">cs</span><span class="o">)</span>
      <span class="n">cs</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.2 - Об'єкт компанйон для класа ChecksumAccumulator.</p></div>
<div class="paragraph"><p>Об'єкт сінглтон <code>ChecksumAccumulator</code> має один метод з назвою <code>calculate</code>, що приймає <code>String</code>, та обчислює контрольну суму для символів в <code>String</code>. Він також має одне приватне поле, <code>cache</code>, змінну мапу, в якій кешуються попередньо обчислені контрольні суми.<span class="footnote"><br />[Ми використовуємо тут кеш, щоб показати об'єкт синглтон з полем. Кеш, такий як цей, є оптимізацією продуктивності, що міняє пам'ять на час обчислення. Загалом, ви мали б використовувати такий архів, тільки якщо натрапили на проблему продуктивності, яку може вирішити кеш, та можливо використовувати слабку мапу, таку як <code>WeakHashMap</code> в <code>scala.collection.jcl</code>, так що елементи цього кеша підпали б під збирання сміття, коли з пам'ятю стало скрутно.]<br /></span> Перший рядок цього метода, <code>if (cache.contains(s))</code>, перевіряє кеш, чи переданий рядок вже існує як ключ в кеші. Якщо так, він просто повертає відображене значення, кеш(і). Інакше, він виконує варіант <code>else</code>, що обчислює контрольну суму. Перший рядок <code>else</code> визначає <code>val</code> на ім'я <code>acc</code>, та ініціалізує її новим примірником <code>ChecksumAccumulator</code>.<span class="footnote"><br />[Оскільки ключове слово  <code>new</code> використовується тільки для створення класів, новий створений тут об'єкт є примірником класу <code>ChecksumAccumulator</code>, не об'єкта синглтона з тим самим іменем.]<br /></span> Наступний рядок є виразом <code>for</code>, що проходить по кожному символу в переданому рядку, конвертуючи символ на Byte, через виклик toByte на ньому, та передає його до метода  <code>add</code> примірника <code>ChecksumAccumulator</code>, на який посилається <code>acc</code>. Після завершення виразу <code>for</code>, наступний рядок метода викликає <code>checksum</code> на <code>acc</code>, що отримує контрольну суму для переданого <code>String</code>, та зберігає його в <code>val</code> на ім'я <code>cs</code>. В наступному рядку, <code>cache += (s -&gt; cs)</code>, переданий рядок-ключ відзеркалюється на ціле значення контрольної суми, і ця пара ключ-значення додається до мапи <code>cache</code>. Останній вираз метода, <code>cs</code>, запевняє, що контрольна сума є результатом метода.</p></div>
<div class="paragraph"><p>ЯКщо ви Java програміст, один спосіб щоб думати про об'єкт синглтон як про домівку для любих статичних методів, що ви могли написати в  Java. Ви можете викликати методи на об'єкті синглтоні, використовуючи подібний синтаксис: ім'я об'єкта синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати метод <code>calculate</code> об'єкта синглтона таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">ChecksumAccumulator</span><span class="o">.</span><span class="n">calculate</span><span class="o">(</span><span class="s">&quot;Every value is an object.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак об'єкт синглтон є більше, ніж утримувач статичних методів. Це першокласний об'єкт. Ви можете думати про ім'я об'єкта синглтона, таким чином, як про "тег імені", приєднаного до об'єкту:</p></div>
<div class="paragraph"><p>Визначення об'єкта синглтона не визначає тип (на рівні абстракції Scala). Маючи тільки визначення об'єкту ChecksumAccumulator, ви не зможете створити змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator визначається через клас компанйон об'єкта синглтона. Однак, синглтон об'єкти розширюють суперклас, та можуть міксувати трейти. Беручи, що кожний об'єкт синглтон є примірником свого суперкласу та примішаних трейтів, ви можете викликати його методи через ці типи, посилатись на нього через змінні ціх типів, та передавати його методам, що очікують ці типи. Ми покажемо деякі приклади об'єктів синглтонів, що наслідують від класів та трейтів в Главі 13.</p></div>
<div class="paragraph"><p>Одна відмінність між класами та об'єктами синглтонами в тому, що синглтон об'єкт не може приймати параметрів, тоді як клас може. Оскільки ви не можете створити примірник синглтон об'єкта за допомогою ключового слова <code>new</code>,ви не маєте способа передати йому параметри. Кожний синглтон об'єкт був реалізований як примірник синтетичного класу, на який посилається статична змінна, так що вони мають ту саму семантику ініціалізації, що і статики в Java.<span class="footnote"><br />[Ім'я синтетичного класу є ім'я об'єкту, плюс знак долару. Таким чином, синтетичний клас для об'єкта синглтона на ім'я ChecksumAccumulator є ChecksumAccumulator$.]<br /></span> Зокрема, об'єкт синглтон буде ініціалізований, коли код отримає до нього доступ в перший раз.</p></div>
<div class="paragraph"><p>Синглтон, що не поділяє те саме ім'я з класом компанйоном, називається окремим об'єктом. Ви можете використовувати окремі об'єкти для багатьох призначень, включаючи збір пов'язаних допоміжних методів, або визначення точки входу в застосування Scala. Цей випадок застосування показаний в наступному розділі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_4__scala">4.4 Застосування Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб виконати Scala програму, ви маєте надати ім'я окремого об'єкта синглтона з методом <code>main</code>, що приймає один параметр, <code>Array[String]</code>, та має тип результата Unit. Любий окремий об'єкт з методом <code>main</code> відповідної сигнатури, може бути використаний як вхідна точка в застосування. Приклад показаний в Лістингу 4.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file Summer.scala</span>
<span class="k">import</span> <span class="nn">ChecksumAccumulator.calculate</span>
<span class="k">object</span> <span class="nc">Summer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
       <span class="n">println</span><span class="o">(</span><span class="n">arg</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.3 - Застосування Summer.</p></div>
<div class="paragraph"><p>Ім'я об'єкта синглтона в Лістенгу 4.3 є Summer. Його метод <code>main</code> має відповідну сигнатуру, так що ви можете використовувати його як застосування. Перше твердження в файлі є імпорт метода <code>calculate</code>, визначеного в об'єкті ChecksumAccumulator в попередньому прикладі. Це твердження <code>import</code> дозволяє вам використовувати просте ім'я метода в залишку файла.<span class="footnote"><br />[Якщо ви Java програміст, ви можете думати про цей імпорт, як про можливість статичного імпорту, введену в Java 5. Однак в Scala є одна різниця, в тому, що ви можете імпортувати члени з любого об'єкта, не тільки з об'єктів синглтонів.]<br /></span> Тіло метода <code>main</code> просто друкує кожний аргумент, та контрольну суму для аргумена, відділену роздільником.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Scala неявно імпортує члени пакунків <code>java.lang</code> та <code>scala</code>, так само, як члени об'єкта синглтона на ім'я <code>Predef</code>, в кожний джерельний файл Scala. <code>Predef</code>, що знаходиться в пакунку <code>scala</code>, містить багато корисних методів. Наприклад, коли ви кажете <code>println</code> в джерельному файлі Scala, насправді ви викликаєте <code>println</code> на <code>Predef</code>. (<code>Predef.println</code> обертається, та викликає <code>Console.println</code>, що робить реальну роботу). Коли ви кажете <code>assert</code>, ви викликаєте <code>Predef.assert</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Щоб виконати застосування Summer, покладіть код з Лістинга 4.3 в файл з назвою Summer.scala. Оскільки <code>Summer</code> використовує <code>ChecksumAccumulator</code>, покладіть код для <code>ChecksumAccumulator</code>, обоє, клас, показаний в Лістингу 4.1, та його об'єкт компанйон, показаний в Лістингу 4.2, в файл на ім'я <code>ChecksumAccumulator.scala</code>.</p></div>
<div class="paragraph"><p>Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви покладали публічні класи в файл з іменем класа — наприклад, ви поклали клас <code>SpeedRacer</code> в файл <code>SpeedRacer.java</code> — в Scala ви можете називати <code>.scala</code> файли як побажаєте, не важливо, які Scala класи або код ви покладете до них. Однак загалом, в випадку не-скриптів, є рекомендованим стилем називати файли по іменах класів, які вони містять, як це зроблено в Java, так що програмісти можуть більш просто знайти класи, шукаючи по іменах файлів. Цей підхід, що ми прийняли для двох файлів в цьому  прикладі, <code>Summer.scala</code> та <code>ChecksumAccumulator.scala</code>.</p></div>
<div class="paragraph"><p>Ні <code>ChecksumAccumulator.scala</code>, ані <code>Summer.scala</code> не є скриптами, бо закінчуються на визначення. Скрипт, для контрасту, має завершуватись на вираз результату. Так що якщо ви спробуєте виконати <code>Summer.scala</code> як скрипт, інтерпретатор Scala буде скаржитись, що <code>Summer.scala</code> не завершується на вираз результату (вважаємо, звичайно, що ви не додали якийсь вираз після визначення об'єкта  <code>Summer</code>). Замість цього, вам буде треба насправді скомпілювати ці файли за допомогою Scala компілятора, та потім виконати отримані файли <code>class</code>. Один шлях зробити це є використання <code>scalac</code>, що є базовим компілятором Scala, ось так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scalac ChecksumAccumulator.scala Summer.scala</code></pre>
</div></div>
<div class="paragraph"><p>Це компілює ваш джерельний файл, але може бути відчутня затримка перед завершенням компіляції. Причина в тому, що кожного разу, коли запускається компілятор, він витрачає час, скануючі вміст jar файлів, та роблячи іншу роботу з ініціалізації, перед тим, як він навіть тільки погляне не нові джерельні файли, яки ви надіслали йому. З цієї причини дистрибутив Scala також включає демон компіляції Scala з назвою <code>fsc</code> (fast Scala compiler). Ви використовуєте його таким чином:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fsc ChecksumAccumulator.scala Summer.scala</code></pre>
</div></div>
<div class="paragraph"><p>Перший раз, як ви запустите <code>fsc</code>, він створить локальний демон сервера, підключений до порту вашого комп'ютера. Потім він буде надсилати список файлів на компіляцію до демона через порт, і демон буде компілювати ці файли. Наступний раз, коли ви виконаєте <code>fsc</code>, демон вже буде запущений, так що <code>fsc</code> буде просто посилати список файлів до демона, що буде безпосередньо компілювати ці файли. Використовуючи <code>fsc</code>, вам треба чекати тільки щоб рантайм Java запустився в перший раз. Якщо ви колись побажаєте запинити демона <code>fsc</code>, ви можете зробити це за допомогою <code>fsc - shutdown</code>.</p></div>
<div class="paragraph"><p>Виконання любого з них, команди <code>scalac</code> або <code>fsc</code>, буде продукувати файли класів Java, які ви потім можете виконати через команду <code>scala</code>, ту саму команду, що ви використовували для виклику інтерпретатора в попередніх прикладах. Оданак замість надання їй файла з розширенням <code>.scala</code>, що містить код Scala для інтерпретації, як ви робили в кожному попередньому прикладі,<span class="footnote"><br />[Справжній механізм, який програма <code>scala</code> використовує для "інтерпретації" джерельного файлу Scala, є те, що вона компілює джерельний код Scala в байткоди Java, безпосередньо завантажує їх через завантажувач класів, та виконує їх.]<br /></span> в цьому випадку ви дасте їй ім'я окремого об'єкту, що має метод <code>main</code> з відповідною сигнатурою. Ви можете виконати застосування Summer, таким чином, набравши:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala Summer of love</code></pre>
</div></div>
<div class="paragraph"><p>Ви побачите контрольні суми, роздруковані для двох аргументів командного рядка:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>of: -213
love: -182</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_5__app">4.5 Трейт App</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить трейт <code>scala.App</code>, що може зберігти вам деякий час за друком. Хоча ми ще не розглянули все, що вам треба для розуміння саме як цей трейт робить, ми припускаємо, що ви бажаєте знати про це саме зараз, будь-що. Лістинг 4.4 показує приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">ChecksumAccumulator.calculate</span>
<span class="k">object</span> <span class="nc">FallWinterSpringSummer</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">season</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;fall&quot;</span><span class="o">,</span> <span class="s">&quot;winter&quot;</span><span class="o">,</span> <span class="s">&quot;spring&quot;</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">season</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">season</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.4 - Використання трейта App.</p></div>
<div class="paragraph"><p>Щоб використати цей трейт, зпочатку ви пишете <code>extends App</code> після імені вашого синглтон об'єкта. Потім замість писати метод <code>main</code>, ви кладете код, що ви б мали покласти в метод <code>main</code>, прямо між фігурними дужками об'єкта синглтона. Ви можете отримати доступ до аргументів командного рядка через масив рядків на ім'я <code>args</code>. Це все. Ви можете компілювати та виконувати це застосування, так само як любе інше.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_6_">4.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала вам основи класів та об'єктів в Scala, та показала вам, як компілювати та виконувати застосування. В наступній главі ми вивчимо базові типи Scala, та як їх використовувати.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p>Chapter 5
Basic Types and Operations
Now that you&#8217;ve seen classes and objects in action, it&#8217;s a good time to look at Scala&#8217;s basic types and
operations in more depth. If you&#8217;re familiar with Java, you&#8217;ll be glad to find that Java&#8217;s basic types and
operators have the same meaning in Scala. However, there are some interesting differences that will
make this chapter worth reading even if you&#8217;re an experienced Java developer. Because some aspects of
Scala covered in this chapter are essentially the same as in Java, we&#8217;ve inserted notes indicating what
sections Java developers can safely skip.
In this chapter, you&#8217;ll get an overview of Scala&#8217;s basic types, including Strings and the value
types Int, Long, Short, Byte, Float, Double, Char, and Boolean. You&#8217;ll learn the operations you can
perform on these types, including how operator precedence works in Scala expressions. You&#8217;ll also
learn how implicit conversions can "enrich" variants of these basic types, giving you additional
operations beyond those supported by Java.
5.1 SOME BASIC TYPES
Several fundamental types of Scala, along with the ranges of values instances of these types may have,
are shown in Table 5.1. Collectively, types Byte, Short, Int, Long, and Char are calledintegral
types. The integral types plus Float and Double are called numeric types.
Table 5.1 - Some basic types
Basic type Range
Byte
8-bit signed two&#8217;s complement integer (-27 to 27 - 1, inclusive)
Short
16-bit signed two&#8217;s complement integer (-215 to 215 - 1, inclusive)
Int
32-bit signed two&#8217;s complement integer (-231 to 231 - 1, inclusive)
Long
64-bit signed two&#8217;s complement integer (-263 to 263 - 1, inclusive)
Char
16-bit unsigned Unicode character (0 to 216 - 1, inclusive)
String
a sequence of Chars
Float
32-bit IEEE 754 single-precision float
Double
64-bit IEEE 754 double-precision float
Boolean true or false
Other than String, which resides in package java.lang, all of the types shown in Table 5.1 are members
of package scala.<span class="footnote"><br />[Packages, which were briefly described in Step 1 in Chapter 2, will be covered in depth inChapter 13.]<br /></span> For example, the full name of Int is scala.Int. However, given that all the members
of package scala and java.lang are automatically imported into every Scala source file, you can just use
the simple names (i.e., names like Boolean, Char, or String) everywhere.
Savvy Java developers will note that Scala&#8217;s basic types have the exact same ranges as the
corresponding types in Java. This enables the Scala compiler to transform instances of Scalavalue
types, such as Int or Double, down to Java primitive types in the bytecodes it produces.5.2 LITERALS
All of the basic types listed in Table 5.1 can be written with literals. A literal is a way to write a
constant value directly in code.
FAST TRACK FOR JAVA PROGRAMMERS
The syntax of most literals shown in this section are exactly the same as in Java, so if you&#8217;re a Java
master, you can safely skip much of this section. Some differences you should read about are Scala&#8217;s
literals for raw strings and symbols, described starting here, and string interpolation, described
starting here. Also, Scala does not support octal literals; integer literals that start with a 0, such as 031,
do not compile.
Integer literals
Integer literals for the types Int, Long, Short, and Byte come in two forms: decimal and hexadecimal.
The way an integer literal begins indicates the base of the number. If the number begins with
a 0x or 0X, it is hexadecimal (base 16), and may contain 0 through 9 as well as upper or lowercase
digits A through F. Some examples are:
scala&gt; val hex = 0x5
hex: Int = 5
scala&gt; val hex2 = 0x00FF
hex2: Int = 255
scala&gt; val magic = 0xcafebabe
magic: Int = -889275714
Note that the Scala shell always prints integer values in base 10, no matter what literal form you may
have used to initialize it. Thus the interpreter displays the value of the hex2 variable you initialized
with literal 0x00FF as decimal 255. (Of course, you don&#8217;t need to take our word for it. A good way to
start getting a feel for the language is to try these statements out in the interpreter as you read this
chapter.) If the number begins with a non-zero digit, and is otherwise undecorated, it is decimal (base
10). For example:
scala&gt; val dec1 = 31
dec1: Int = 31
scala&gt; val dec2 = 255
dec2: Int = 255
scala&gt; val dec3 = 20
dec3: Int = 20
If an integer literal ends in an L or l, it is a Long; otherwise it is an Int. Some examples of Longinteger
literals are:
scala&gt; val prog = 0XCAFEBABEL
prog: Long = 3405691582scala&gt; val tower = 35L
tower: Long = 35
scala&gt; val of = 31l
of: Long = 31
If an Int literal is assigned to a variable of type Short or Byte, the literal is treated as if it were
aShort or Byte type so long as the literal value is within the valid range for that type. For example:
scala&gt; val little: Short = 367
little: Short = 367
scala&gt; val littler: Byte = 38
littler: Byte = 38
Floating point literals
Floating point literals are made up of decimal digits, optionally containing a decimal point, and
optionally followed by an E or e and an exponent. Some examples of floating-point literals are:
scala&gt; val big = 1.2345
big: Double = 1.2345
scala&gt; val bigger = 1.2345e1
bigger: Double = 12.345
scala&gt; val biggerStill = 123E45
biggerStill: Double = 1.23E47
Note that the exponent portion means the power of 10 by which the other portion is multiplied. Thus,
1.2345e1 is 1.2345 times 101, which is 12.345. If a floating-point literal ends in an F or f, it is a Float;
otherwise it is a Double. Optionally, a Double floating-point literal can end in D or d. Some examples
of Float literals are:
scala&gt; val little = 1.2345F
little: Float = 1.2345
scala&gt; val littleBigger = 3e5f
littleBigger: Float = 300000.0
That last value expressed as a Double could take these (and other) forms:
scala&gt; val anotherDouble = 3e5
anotherDouble: Double = 300000.0
scala&gt; val yetAnother = 3e5D
yetAnother: Double = 300000.0
Character literals
Character literals are composed of any Unicode character between single quotes, such as:
scala&gt; val a = <em>A</em>
a: Char = AIn addition to providing an explicit character between the single quotes, you can identify a character
using its Unicode code point. To do so, write \u followed by four hex digits with the code point, like
this:
scala&gt; val d = <em>\u0041</em>
d: Char = A
scala&gt; val f = <em>\u0044</em>
f: Char = D
In fact, such Unicode characters can appear anywhere in a Scala program. For instance you could also
write an identifier like this:
scala&gt; val B\u0041\u0044 = 1
BAD: Int = 1
This identifier is treated as identical to BAD, the result of expanding the two Unicode characters in the
code above. In general, it is a bad idea to name identifiers like this because it is hard to read. Rather,
this syntax is intended to allow Scala source files that include non-ASCII Unicode characters to be
represented in ASCII.
Finally, there are also a few character literals represented by special escape sequences, shown in Table
5.2. For example:
scala&gt; val backslash = <em>\\</em>
backslash: Char = \
Table 5.2 - Special character literal escape sequences
Literal
\n
\b
\t
\f
\r
\"
\'
\\
Meaning
line feed (\u000A)
backspace (\u0008)
tab (\u0009)
form feed (\u000C)
carriage return (\u000D)
double quote (\u0022)
single quote (\u0027)
backslash (\u005C)
String literals
A string literal is composed of characters surrounded by double quotes:
scala&gt; val hello = "hello"
hello: String = hello
The syntax of the characters within the quotes is the same as with character literals. For example:
scala&gt; val escapes = "\\\"'"
escapes: String = \"<em>Because this syntax is awkward for strings that contain a lot of escape sequences or strings that span
multiple lines, Scala includes a special syntax for raw strings. You start and end a raw string with three
double quotation marks in a row ("""). The interior of a raw string may contain any characters
whatsoever, including newlines, quotation marks, and special characters, except of course three quotes
in a row. For example, the following program prints out a message using a raw string:
println("""Welcome to Ultamix 3000.
Type "HELP" for help.""")
However, running this code does not produce quite what is desired:
Welcome to Ultamix 3000.
Type "HELP" for help.
The issue is that the leading spaces before the second line are included in the string! To help with this
common situation, you can call stripMargin on strings. To use this method, put a pipe character (|) at
the front of each line, and then call stripMargin on the whole string:
println("""|Welcome to Ultamix 3000.
|Type "HELP" for help.""".stripMargin)
Now the code behaves as desired:
Welcome to Ultamix 3000.
Type "HELP" for help.
Symbol literals
A symbol literal is written 'ident, where ident can be any alphanumeric identifier. Such literals are
mapped to instances of the predefined class scala.Symbol. Specifically, the literal&#8217;cymbal will be
expanded by the compiler to a factory method invocation: Symbol("cymbal"). Symbol literals are
typically used in situations where you would use just an identifier in a dynamically typed language. For
instance, you might want to define a method that updates a record in a database:
scala&gt; def updateRecordByName(r: Symbol, value: Any) = {

}
updateRecordByName: (Symbol,Any)Unit
The method takes as parameters a symbol indicating the name of a record field and a value with which
the field should be updated in the record. In a dynamically typed language, you could invoke this
operation passing an undeclared field identifier to the method, but in Scala this would not compile:
scala&gt; updateRecordByName(favoriteAlbum, "OK Computer")
&lt;console&gt;:6: error: not found: value favoriteAlbum
updateRecordByName(favoriteAlbum, "OK Computer")
<sup>
Instead, and almost as concisely, you can pass a symbol literal:
scala&gt; updateRecordByName('favoriteAlbum, "OK Computer")There is not much you can do with a symbol, except find out its name:
scala&gt; val s = 'aSymbol
s: Symbol = 'aSymbol
scala&gt; val nm = s.name
nm: String = aSymbol
Another thing that&#8217;s noteworthy is that symbols are interned. If you write the same symbol literal twice,
both expressions will refer to the exact same Symbol object.
Boolean literals
The Boolean type has two literals, true and false:
scala&gt; val bool = true
bool: Boolean = true
scala&gt; val fool = false
fool: Boolean = false
That&#8217;s all there is to it. You are now literally an expert in Scala.<span class="footnote"><br />[figuratively speaking]<br /></span>
5.3 STRING INTERPOLATION
Scala includes a flexible mechanism for string interpolation, which allows you to embed expressions
within string literals. Its most common use case is to provide a concise and readable alternative to
string concatenation. Here&#8217;s an example:
val name = "reader"
println(s"Hello, $name!")
The expression, s"Hello, $name!" is a processed string literal. Because the letter s immediately
precedes the open quote, Scala will use the s string interpolator to process the literal. The sinterpolator
will evaluate each embedded expression, invoke toString on each result, and replace the embedded
expressions in the literal with those results. Thus s"Hello, $name!" yields"Hello, reader!", the same
result as "Hello, " + name + "!".
You can place any expression after a dollar sign ($) in a processed string literal. For single-variable
expressions, you can often just place the variable name after the dollar sign. Scala will interpret all
characters up to the first non-identifier character as the expression. If the expression includes non-
identifier characters, you must place it in curly braces, with the open curly brace immediately following
the dollar sign. Here&#8217;s an example:
scala&gt; s"The answer is ${6 * 7}."
res0: String = The answer is 42.
Scala provides two other string interpolators by default: raw and f. The raw string interpolator behaves
like s, except it does not recognize character literal escape sequences (such as those shown in Table
5.2). For example, the following statement prints four backslashes, not two:println(raw"No\\\\escape!") // prints: No\\\\escape!
The f string interpolator allows you to attach printf-style formatting instructions to embedded
expressions. You place the instructions after the expression, starting with a percent sign (%), using the
syntax specified by java.util.Formatter. For example, here&#8217;s how you might format pi:
scala&gt; f"${math.Pi}%.5f"
res1: String = 3.14159
If you provide no formatting instructions for an embedded expression, the f string interpolator will
default to %s, which means the toString value will be substituted, just like thes string interpolator. For
example:
scala&gt; val pi = "Pi"
pi: String = Pi
scala&gt; f"$pi is approximately ${math.Pi}%.8f."
res2: String = Pi is approximately 3.14159265.
In Scala, string interpolation is implemented by rewriting code at compile time. The compiler will treat
any expression consisting of an identifier followed immediately by the open double quote of a string
literal as a string interpolator expression. The s, f, and raw string interpolators are implemented via this
general mechanism. Libraries and users can define other string interpolators for other purposes.
5.4 OPERATORS ARE METHODS
Scala provides a rich set of operators for its basic types. As mentioned in previous chapters, these
operators are actually just a nice syntax for ordinary method calls. For example, 1 + 2really means the
same thing as 1.<code>(2). In other words, class Int contains a method named +that takes an Int and returns
an Int result. This + method is invoked when you add two Ints:
scala&gt; val sum = 1 + 2
sum: Int = 3

To prove this to yourself, you can write the expression explicitly as a method invocation:
scala&gt; val sumMore = 1.</code>(2)
sumMore: Int = 3
In fact, Int contains several overloaded + methods that take different parameter types.<span class="footnote"><br />[3]<br /></span> For
example, Int has another method, also named <code>, that takes and returns a Long. If you add a Longto
an Int, this alternate + method will be invoked, as in:
scala&gt; val longSum = 1 + 2L
longSum: Long = 3

The + symbol is an operator—an infix operator to be specific. Operator notation is not limited to
methods like + that look like operators in other languages. You can use any method in operator
notation. For example, class String has a method, indexOf, that takes one Charparameter.The indexOf method searches the string for the first occurrence of the specified character and returns
its index or -1 if it doesn&#8217;t find the character. You can use indexOf as an operator, like this:
scala&gt; val s = "Hello, world!"
s: String = Hello, world!
scala&gt; s indexOf 'o</em>
res0: Int = 4

In addition, String offers an overloaded indexOf method that takes two parameters, the character for
which to search and an index at which to start. (The other indexOf method, shown previously, starts at
index zero, the beginning of the String.) Even though this indexOfmethod takes two arguments, you
can use it in operator notation. But whenever you call a method that takes multiple arguments using
operator notation, you have to place those arguments in parentheses. For example, here&#8217;s how you use
this other indexOf form as an operator (continuing from the previous example):
scala&gt; s indexOf (<em>o</em>, 5) // Scala invokes s.indexOf(<em>o</em>, 5)
res1: Int = 8
ANY METHOD CAN BE AN OPERATOR
In Scala operators are not special language syntax; any method can be an operator. What makes a
method an operator is how you use it. When you write "s.indexOf(<em>o</em>)",indexOf is not an operator. But
when you write "s indexOf <em>o</em>", indexOf is an operator, because you&#8217;re using it in operator notation.
So far, you&#8217;ve seen examples of infix operator notation, which means the method to invoke sits between
the object and the parameter (or parameters) you wish to pass to the method, as in "7 + 2". Scala also
has two other operator notations: prefix and postfix. In prefix notation, you put the method name before
the object on which you are invoking the method (for example, the &#8216;-&#8217; in -7). In postfix notation, you
put the method after the object (for example, the "toLong" in "7 toLong").
In contrast to the infix operator notation—in which operators take two operands, one to the left and the
other to the right—prefix and postfix operators are unary: they take just one operand. In prefix
notation, the operand is to the right of the operator. Some examples of prefix operators are -2.0, !found,
and <sub>0xFF. As with the infix operators, these prefix operators are a shorthand way of invoking
methods. In this case, however, the name of the method has "unary_" prepended to the operator
character. For instance, Scala will transform the expression -2.0 into the method invocation
"(2.0).unary_-". You can demonstrate this to yourself by typing the method call both via operator
notation and explicitly:
scala&gt; -2.0
res2: Double = -2.0

scala&gt; (2.0).unary_-
res3: Double = -2.0
The only identifiers that can be used as prefix operators are +, -, !, and </sub>. Thus, if you define a method
named unary_!, you could invoke that method on a value or variable of the appropriate type usingprefix operator notation, such as !p. But if you define a method namedunary_*, you wouldn&#8217;t be able to
use prefix operator notation because * isn&#8217;t one of the four identifiers that can be used as prefix
operators. You could invoke the method normally, as inp.unary_*, but if you attempted to invoke it
via <strong>p, Scala will parse it as if you&#8217;d written *.p, which is probably not what you had in mind!<span class="footnote"><br />[All is not necessarily lost, however. There is an extremely slight chance your program with the *p might compile as C<code>.]<br /></span>
Postfix operators are methods that take no arguments, when they are invoked without a dot or
parentheses. In Scala, you can leave off empty parentheses on method calls. The convention is that you
include parentheses if the method has side effects, such as println(), but you can leave them off if the
method has no side effects, such as toLowerCase invoked on aString:
scala&gt; val s = "Hello, world!"
s: String = Hello, world!
scala&gt; s.toLowerCase
res4: String = hello, world!
In this latter case of a method that requires no arguments, you can alternatively leave off the dot and
use postfix operator notation:
scala&gt; s toLowerCase
res5: String = hello, world!
In this case, toLowerCase is used as a postfix operator on the operand s.
Therefore, to see what operators you can use with Scala&#8217;s basic types, all you really need to do is look
at the methods declared in the type&#8217;s classes in the Scala API documentation. Given that this is a Scala
tutorial, however, we&#8217;ll give you a quick tour of most of these methods in the next few sections.
FAST TRACK FOR JAVA PROGRAMMERS
Many aspects of Scala described in the remainder of this chapter are the same as in Java. If you&#8217;re a
Java guru in a rush, you can safely skip to Section 5.8 here, which describes how Scala differs from
Java in the area of object equality.
5.5 ARITHMETIC OPERATIONS
You can invoke arithmetic methods via infix operator notation for addition (</code>), subtraction (-),
multiplication (</strong>), division (/), and remainder (%) on any numeric type. Here are some examples:
scala&gt; 1.2 + 2.3
res6: Double = 3.5
scala&gt; 3 - 1
res7: Int = 2
scala&gt; <em>b</em> - <em>a</em>
res8: Int = 1
scala&gt; 2L * 3L
res9: Long = 6
scala&gt; 11 / 4res10: Int = 2
scala&gt; 11 % 4
res11: Int = 3
scala&gt; 11.0f / 4.0f
res12: Float = 2.75
scala&gt; 11.0 % 4.0
res13: Double = 3.0
When both the left and right operands are integral types (Int, Long, Byte, Short, or Char), the /operator
will tell you the whole number portion of the quotient, excluding any remainder. The % operator
indicates the remainder of an implied integer division.
The floating-point remainder you get with % is not the one defined by the IEEE 754 standard. The
IEEE 754 remainder uses rounding division, not truncating division, in calculating the remainder, so it
is quite different from the integer remainder operation. If you really want an IEEE 754 remainder, you
can call IEEEremainder on scala.math, as in:
scala&gt; math.IEEEremainder(11.0, 4.0)
res14: Double = -1.0
The numeric types also offer unary prefix operators + (method unary_+) and - (method unary_-), which
allow you to indicate whether a literal number is positive or negative, as in -3 or +4.0. If you don&#8217;t
specify a unary + or -, a literal number is interpreted as positive. Unary + exists solely for symmetry
with unary -, but has no effect. The unary - can also be used to negate a variable. Here are some
examples:
scala&gt; val neg = 1 + -3
neg: Int = -2
scala&gt; val y = +3
y: Int = 3
scala&gt; -neg
res15: Int = 2
5.6 RELATIONAL AND LOGICAL OPERATIONS
You can compare numeric types with relational methods greater than (&gt;), less than (&lt;), greater than or
equal to (&gt;=), and less than or equal to (&#8656;), which yield a Boolean result. In addition, you can use the
unary &#8216;!&#8217; operator (the unary_! method) to invert a Boolean value.Here are a few examples:
scala&gt; 1 &gt; 2
res16: Boolean = false
scala&gt; 1 &lt; 2
res17: Boolean = true
scala&gt; 1.0 &#8656; 1.0
res18: Boolean = truescala&gt; 3.5f &gt;= 3.6f
res19: Boolean = false
scala&gt; <em>a</em> &gt;= <em>A</em>
res20: Boolean = true
scala&gt; val untrue = !true
untrue: Boolean = false
Logical methods, logical-and (&amp;&amp; and &amp;) and logical-or (|| and |), take Boolean operands in infix
notation and yield a Boolean result. For example:
scala&gt; val toBe = true
toBe: Boolean = true
scala&gt; val question = toBe || !toBe
question: Boolean = true
scala&gt; val paradox = toBe &amp;&amp; !toBe
paradox: Boolean = false
The &amp;&amp; and || operations short-circuit as in Java: expressions built from these operators are only
evaluated as far as needed to determine the result. In other words, the right-hand side
of&amp;&amp; and || expressions won&#8217;t be evaluated if the left-hand side determines the result. For example, if
the left-hand side of a &amp;&amp; expression evaluates to false, the result of the expression will definitely
be false, so the right-hand side is not evaluated. Likewise, if the left-hand side of a || expression
evaluates to true, the result of the expression will definitely be true, so the right-hand side is not
evaluated.
scala&gt; def salt() = { println("salt"); false }
salt: ()Boolean
scala&gt; def pepper() = { println("pepper"); true }
pepper: ()Boolean
scala&gt; pepper() &amp;&amp; salt()
pepper
salt
res21: Boolean = false
scala&gt; salt() &amp;&amp; pepper()
salt
res22: Boolean = false
In the first expression, pepper and salt are invoked, but in the second, only salt is invoked.
Given salt returns false, there&#8217;s no need to call pepper.
If you want to evaluate the right hand side no matter what, use &amp; and | instead. The &amp; method performs
a logical-and operation, and | a logical-or, but don&#8217;t short-ciruit like &amp;&amp; and ||. Here&#8217;s an example:
scala&gt; salt() &amp; pepper()
salt
pepper
res23: Boolean = falseNote
You may be wondering how short-circuiting can work given operators are just methods. Normally, all
arguments are evaluated before entering a method, so how can a method avoid evaluating its second
argument? The answer is that all Scala methods have a facility for delaying the evaluation of their
arguments, or even declining to evaluate them at all. The facility is called by-name parameters and is
discussed in Section 9.5.
5.7 BITWISE OPERATIONS
Scala enables you to perform operations on individual bits of integer types with several bitwise
methods. The bitwise methods are: bitwise-and (&amp;), bitwise-or (|), and bitwise-xor (</sup>).<span class="footnote"><br />[The bitwise-xor method performs an exclusive or on its operands. Identical bits yield a 0. Different bits yield a 1. Thus 0011 <sup> 0101 yields 0110.]<br /></span> The unary
bitwise complement operator (<sub>, the method unary_</sub>) inverts each bit in its operand. For example:
scala&gt; 1 &amp; 2
res24: Int = 0
scala&gt; 1 | 2
res25: Int = 3
scala&gt; 1 </sup> 3
res26: Int = 2
scala&gt; <sub>1
res27: Int = -2
The first expression, 1 &amp; 2, bitwise-ands each bit in 1 (0001) and 2 (0010), which yields 0 (0000). The
second expression, 1 | 2, bitwise-ors each bit in the same operands, yielding 3 (0011). The third
expression, 1 <sup> 3, bitwise-xors each bit in 1 (0001) and 3 (0011), yielding 2 (0010). The final
expression, </sub>1, inverts each bit in 1 (0001), yielding -2, which in binary looks like
11111111111111111111111111111110.
Scala integer types also offer three shift methods: shift left (&lt;&lt;), shift right (&gt;&gt;), and unsigned shift
right (&gt;&gt;&gt;). The shift methods, when used in infix operator notation, shift the integer value on the left
of the operator by the amount specified by the integer value on the right. Shift left and unsigned shift
right fill with zeroes as they shift. Shift right fills with the highest bit (the sign bit) of the left-hand
value as it shifts. Here are some examples:
scala&gt; -1 &gt;&gt; 31
res28: Int = -1
scala&gt; -1 &gt;&gt;&gt; 31
res29: Int = 1
scala&gt; 1 &lt;&lt; 2
res30: Int = 4
-1 in binary is 11111111111111111111111111111111. In the first example, -1 &gt;&gt; 31, -1 is shifted to the
right 31 bit positions. Since an Int consists of 32 bits, this operation effectively moves the leftmost bit
over until it becomes the rightmost bit.<span class="footnote"><br />[The leftmost bit in an integer type is the sign bit. If the leftmost bit is 1, the number is negative. If 0, the number is positive.]<br /></span> Since the &gt;&gt; method fills with ones as it shifts right, becausethe leftmost bit of -1 is 1, the result is identical to the original left operand, 32 one bits, or -1. In the
second example, -1 &gt;&gt;&gt; 31, the leftmost bit is again shifted right until it is in the rightmost position,
but this time filling with zeroes along the way. Thus the result this time is binary
00000000000000000000000000000001, or 1. In the final example, 1 &lt;&lt; 2, the left operand, 1, is
shifted left two positions (filling in with zeroes), resulting in binary
00000000000000000000000000000100, or 4.
5.8 OBJECT EQUALITY
If you want to compare two objects for equality, you can use either == or its inverse !=. Here are a few
simple examples:
scala&gt; 1 == 2
res31: Boolean = false
scala&gt; 1 != 2
res32: Boolean = true
scala&gt; 2 == 2
res33: Boolean = true
These operations actually apply to all objects, not just basic types. For example, you can use== to
compare lists:
scala&gt; List(1, 2, 3) == List(1, 2, 3)
res34: Boolean = true
scala&gt; List(1, 2, 3) == List(4, 5, 6)
res35: Boolean = false
Going further, you can compare two objects that have different types:
scala&gt; 1 == 1.0
res36: Boolean = true
scala&gt; List(1, 2, 3) == "hello"
res37: Boolean = false
You can even compare against null, or against things that might be null. No exception will be thrown:
scala&gt; List(1, 2, 3) == null
res38: Boolean = false
scala&gt; null == List(1, 2, 3)
res39: Boolean = false
As you see, == has been carefully crafted so that you get just the equality comparison you want in most
cases. This is accomplished with a very simple rule: First check the left side for null. If it is not null,
call the equals method. Since equals is a method, the precise comparison you get depends on the type
of the left-hand argument. Since there is an automatic null check, you do not have to do the check
yourself.<span class="footnote"><br />[The automatic check does not look at the right-hand side, but any reasonable equalsmethod should return false if its argument is null.]<br /></span>This kind of comparison will yield true on different objects, so long as their contents are the same and
their equals method is written to be based on contents. For example, here is a comparison between two
strings that happen to have the same five letters in them:
scala&gt; ("he" + "llo") == "hello"
res40: Boolean = true
HOW SCALA&#8217;S == DIFFERS FROM JAVA&#8217;S
In Java, you can use == to compare both primitive and reference types. On primitive types,
Java&#8217;s == compares value equality, as in Scala. On reference types, however,
Java&#8217;s == compares reference equality, which means the two variables point to the same object on the
JVM&#8217;s heap. Scala provides a facility for comparing reference equality, as well, under the name eq.
However, eq and its opposite, ne, only apply to objects that directly map to Java objects. The full
details about eq and ne are given in Sections 11.1and 11.2. Also, see Chapter 30 on how to write a
good equals method.
5.9 OPERATOR PRECEDENCE AND ASSOCIATIVITY
Operator precedence determines which parts of an expression are evaluated before the other parts. For
example, the expression 2 + 2 * 7 evaluates to 16, not 28, because the * operator has a higher
precedence than the + operator. Thus the multiplication part of the expression is evaluated before the
addition part. You can of course use parentheses in expressions to clarify evaluation order or to override
precedence. For example, if you really wanted the result of the expression above to be 28, you could
write the expression like this:
(2 + 2) * 7
Given that Scala doesn&#8217;t have operators, per se, just a way to use methods in operator notation, you may
be wondering how operator precedence works. Scala decides precedence based on the first character of
the methods used in operator notation (there&#8217;s one exception to this rule, which will be discussed in the
following pages). If the method name starts with a*, for example, it will have a higher precedence than
a method that starts with a +. Thus2 + 2 * 7 will be evaluated as 2 + (2 * 7). Similarly, a </code>
+ b <strong>*</strong> c (in which a, b, and c are variables, and  and *** are methods) will be evaluated a ++
+ (b *** c), because the *** method has a higher precedence than the  method.
Table 5.3 - Operator precedence
(all other special characters)
* / %
+ -
:
= !
&lt; &gt;
&amp;</sup>
|
(all letters)
(all assignment operators)
Table 5.3 shows the precedence given to the first character of a method in decreasing order of
precedence, with characters on the same line having the same precedence. The higher a character is in
this table, the higher the precedence of methods that start with that character. Here&#8217;s an example that
illustrates the influence of precedence:
scala&gt; 2 &lt;&lt; 2 + 2
res41: Int = 32
The &lt;&lt; method starts with the character &lt;, which appears lower in Table 5.3 than the character +,
which is the first and only character of the + method. Thus &lt;&lt; will have lower precedence than +, and
the expression will be evaluated by first invoking the + method, then the &lt;&lt; method, as
in 2 &lt;&lt; (2 + 2). 2 + 2 is 4, by our math, and 2 &lt;&lt; 4 yields 32. If you swap the operators, you&#8217;ll get a
different result:
scala&gt; 2 + 2 &lt;&lt; 2
res42: Int = 16
Since the first characters are the same as in the previous example, the methods will be invoked in the
same order. First the + method will be invoked, then the &lt;&lt; method. So 2 + 2 will again yield 4,
and 4 &lt;&lt; 2 is 16.
The one exception to the precedence rule, alluded to earlier, concerns assignment operators, which end
in an equals character. If an operator ends in an equals character (=), and the operator is not one of the
comparison operators &#8656;, &gt;=, ==, or !=, then the precedence of the operator is the same as that of
simple assignment (=). That is, it is lower than the precedence of any other operator. For instance:
x <strong>= y + 1
means the same as:
x *= (y + 1)
because *= is classified as an assignment operator whose precedence is lower than +, even though the
operator&#8217;s first character is *, which would suggest a precedence higher than +.
When multiple operators of the same precedence appear side by side in an expression,
theassociativity of the operators determines the way operators are grouped. The associativity of an
operator in Scala is determined by its last character. As mentioned here of Chapter 3, any method that
ends in a &#8216;:&#8217; character is invoked on its right operand, passing in the left operand. Methods that end in
any other character are the other way around: They are invoked on their left operand, passing in the
right operand. So a * b yields a.</strong>(b), but a ::: byields b.:::(a).No matter what associativity an operator has, however, its operands are always evaluated left to right.
So if a is an expression that is not just a simple reference to an immutable value, thena ::: b is more
precisely treated as the following block:
{ val x = a; b.:::(x) }
In this block a is still evaluated before b, and then the result of this evaluation is passed as an operand
to b&#8217;s ::: method.
This associativity rule also plays a role when multiple operators of the same precedence appear side by
side. If the methods end in &#8216;:&#8217;, they are grouped right to left; otherwise, they are grouped left to right.
For example, a ::: b ::: c is treated as a ::: (b ::: c). But a * b * c, by contrast, is treated as (a * b) * c.
Operator precedence is part of the Scala language. You needn&#8217;t be afraid to use it. Nevertheless, it is
good style to use parentheses to clarify what operators are operating upon what expressions. Perhaps
the only precedence you can truly count on other programmers knowing without looking up is that
multiplicative operators, <strong>, /, and %, have a higher precedence than the additive ones + and -. Thus
even if a + b &lt;&lt; c yields the result you want without parentheses, the extra clarity you get by
writing (a + b) &lt;&lt; c may reduce the frequency with which your peers utter your name in operator
notation, for example, by shouting in disgust, "bills !</strong>&amp;<sup>%<sub> code!".<span class="footnote"><br />[By now you should be able to figure out that given this code, the Scala compiler would invoke (bills.!*&amp;</sup>%</sub>(code)).!().]<br /></span>
5.10 RICH WRAPPERS
You can invoke many more methods on Scala&#8217;s basic types than were described in the previous
sections. A few examples are shown in Table 5.4. These methods are available viaimplicit conversions,
a technique that will be described in detail in Chapter 21. All you need to know for now is that for each
basic type described in this chapter, there is also a "rich wrapper" that provides several additional
methods. To see all the available methods on the basic types, therefore, you should look at the API
documentation on the rich wrapper for each basic type. Those classes are listed in Table 5.5.
Table 5.4 - Some rich operations
Code
0 max 5
0 min 5
-2.7 abs
-2.7 round
1.5 isInfinity
(1.0 / 0) isInfinity
4 to 6
"bob" capitalize
"robert" drop 2
Result
5
0
2.7
-3L
false
true
Range(4, 5, 6)
"Bob"
"bert"
Table 5.5 - Rich wrapper classes
Basic type Rich wrapper
Byte
scala.runtime.RichByteShort
Int
Long
Char
Float
Double
Boolean
String
scala.runtime.RichShort
scala.runtime.RichInt
scala.runtime.RichLong
scala.runtime.RichChar
scala.runtime.RichFloat
scala.runtime.RichDouble
scala.runtime.RichBoolean
scala.collection.immutable.StringOps
5.11 CONCLUSION
The main take-aways from this chapter are that operators in Scala are method calls, and that implicit
conversions to rich variants exist for Scala&#8217;s basic types that add even more useful methods. In the next
chapter, we&#8217;ll show you what it means to design objects in a functional style that gives new
implementations of some of the operators that you have seen in this chapter.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p>Chapter 6
Functional Objects
With the understanding of Scala basics you&#8217;ve gained from previous chapters, you&#8217;re ready to design
more full-featured classes in Scala. In this chapter, the emphasis is on classes that define functional
objects, or objects that do not have any mutable state. As a running example, we&#8217;ll create several
variants of a class that models rational numbers as immutable objects. Along the way, we&#8217;ll show you
more aspects of object-oriented programming in Scala: class parameters and constructors, methods and
operators, private members, overriding, checking preconditions, overloading, and self references.
6.1 A SPECIFICATION FOR CLASS RATIONAL
A rational number is a number that can be expressed as a ratio n/d, where n and d are integers, except
that d cannot be zero. n is called the numerator and d the denominator. Examples of rational numbers
are 1/2, 2/3, 112/239, and 2/1. Compared to floating-point numbers, rational numbers have the
advantage that fractions are represented exactly, without rounding or approximation.
The class we&#8217;ll design in this chapter must model the behavior of rational numbers, including allowing
them to be added, subtracted, multiplied, and divided. To add two rationals, you must first obtain a
common denominator, then add the two numerators. For example, to add1/2 + 2/3, you multiply both
parts of the left operand by 3 and both parts of the right operand by 2, which gives you 3/6 + 4/6.
Adding the two numerators yields the result, 7/6. To multiply two rational numbers, you can simply
multiply their numerators and multiply their denominators. Thus, 1/2 * 2/5 gives 2/10, which can be
represented more compactly in its "normalized" form as 1/5. You divide by swapping the numerator
and denominator of the right operand and then multiplying. For instance 1/2 / 3/5 is the same
as 1/2 * 5/3, or 5/6.
One, maybe rather trivial, observation is that in mathematics, rational numbers do not have mutable
state. You can add one rational number to another, but the result will be a new rational number. The
original numbers will not have "changed." The immutable Rational class we&#8217;ll design in this chapter
will have the same property. Each rational number will be represented by one Rational object. When
you add two Rational objects, you&#8217;ll create a newRational object to hold the sum.
This chapter will give you a glimpse of some of the ways Scala enables you to write libraries that feel
like native language support. For example, at the end of this chapter you&#8217;ll be able to do this with
class Rational:
scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; (oneHalf / 7) + (1 - twoThirds)
res0: Rational = 17/426.2 CONSTRUCTING A RATIONAL
A good place to start designing class Rational is to consider how client programmers will create a
new Rational object. Given we&#8217;ve decided to make Rational objects immutable, we&#8217;ll require that
clients provide all data needed by an instance (in this case, a numerator and a denominator) when they
construct the instance. Thus, we will start the design with this:
class Rational(n: Int, d: Int)
One of the first things to note about this line of code is that if a class doesn&#8217;t have a body, you don&#8217;t
need to specify empty curly braces (though you could, of course, if you wanted to). The
identifiers n and d in the parentheses after the class name, Rational, are called class parameters. The
Scala compiler will gather up these two class parameters and create aprimary constructor that takes the
same two parameters.
IMMUTABLE OBJECT TRADE-OFFS
Immutable objects offer several advantages over mutable objects, and one potential disadvantage. First,
immutable objects are often easier to reason about than mutable ones, because they do not have
complex state spaces that change over time. Second, you can pass immutable objects around quite
freely, whereas you may need to make defensive copies of mutable objects before passing them to other
code. Third, there is no way for two threads concurrently accessing an immutable to corrupt its state
once it has been properly constructed, because no thread can change the state of an immutable. Fourth,
immutable objects make safe hash table keys. If a mutable object is mutated after it is placed into
a HashSet, for example, that object may not be found the next time you look into the HashSet.
The main disadvantage of immutable objects is that they sometimes require that a large object graph be
copied, whereas an update could be done in its place. In some cases this can be awkward to express and
might also cause a performance bottleneck. As a result, it is not uncommon for libraries to provide
mutable alternatives to immutable classes. For example, class StringBuilder is a mutable alternative to
the immutable String. We&#8217;ll give you more information on designing mutable objects in Scala
in Chapter 18.
Note
This initial Rational example highlights a difference between Java and Scala. In Java, classes have
constructors, which can take parameters; whereas in Scala, classes can take parameters directly. The
Scala notation is more concise—class parameters can be used directly in the body of the class; there&#8217;s
no need to define fields and write assignments that copy constructor parameters into fields. This can
yield substantial savings in boilerplate code, especially for small classes.
The Scala compiler will compile any code you place in the class body, which isn&#8217;t part of a field or a
method definition, into the primary constructor. For example, you could print a debug message like
this:
class Rational(n: Int, d: Int) {}
println("Created " + n + "/" + d)
Given this code, the Scala compiler would place the call to println into Rational&#8217;s primary constructor.
The println call will, therefore, print its debug message whenever you create a new Rational instance:
scala&gt; new Rational(1, 2)
Created 1/2
res0: Rational = <a href="mailto:Rational@2591e0c9">Rational@2591e0c9</a>
6.3 REIMPLEMENTING THE TOSTRING METHOD
When we created an instance of Rational in the previous example, the interpreter printed
"Rational@90110a". The interpreter obtained this somewhat funny looking string by callingtoString on
the Rational object. By default, class Rational inherits the implementation oftoString defined in
class java.lang.Object, which just prints the class name, an @ sign, and a hexadecimal number. The
result of toString is primarily intended to help programmers by providing information that can be used
in debug print statements, log messages, test failure reports, and interpreter and debugger output. The
result currently provided by toString is not especially helpful because it doesn&#8217;t give any clue about the
rational number&#8217;s value. A more useful implementation of toString would print out the values of
the Rational&#8217;s numerator and denominator. You can override the default implementation by adding a
method toString to class Rational, like this:
class Rational(n: Int, d: Int) {
override def toString = n + "/" + d
}
The override modifier in front of a method definition signals that a previous method definition is
overridden (more on this in Chapter 10). Since Rational numbers will display nicely now, we removed
the debug println statement we put into the body of previous version of classRational. You can test the
new behavior of Rational in the interpreter:
scala&gt; val x = new Rational(1, 3)
x: Rational = 1/3
scala&gt; val y = new Rational(5, 7)
y: Rational = 5/7
6.4 CHECKING PRECONDITIONS
As a next step, we will turn our attention to a problem with the current behavior of the primary
constructor. As mentioned at the beginning of this chapter, rational numbers may not have a zero in the
denominator. Currently, however, the primary constructor accepts a zero passed as d:
scala&gt; new Rational(5, 0)
res1: Rational = 5/0
One of the benefits of object-oriented programming is that it allows you to encapsulate data inside
objects so that you can ensure the data is valid throughout its lifetime. In the case of an immutableobject such as Rational, this means that you should ensure the data is valid when the object is
constructed. Given that a zero denominator is an invalid state for a Rationalnumber, you should not let
a Rational be constructed if a zero is passed in the d parameter.
The best way to approach this problem is to define as a precondition of the primary constructor
that d must be non-zero. A precondition is a constraint on values passed into a method or constructor, a
requirement which callers must fulfill. One way to do that is to userequire,<span class="footnote"><br />[The require method is defined in standalone object, Predef. As mentioned in Section 4.4,Predef&#8217;s members are imported automatically into every Scala source file.]<br /></span> like this:
class Rational(n: Int, d: Int) {
require(d != 0)
override def toString = n + "/" + d
}
The require method takes one boolean parameter. If the passed value is true, require will return
normally. Otherwise, require will prevent the object from being constructed by throwing
an IllegalArgumentException.
6.5 ADDING FIELDS
Now that the primary constructor is properly enforcing its precondition, we will turn our attention to
supporting addition. To do so, we&#8217;ll define a public add method on class Rationalthat takes
another Rational as a parameter. To keep Rational immutable, the add method must not add the passed
rational number to itself. Rather, it must create and return a new Rationalthat holds the sum. You might
think you could write add this way:
class Rational(n: Int, d: Int) { // This won&#8217;t compile
require(d != 0)
override def toString = n + "/" + d
def add(that: Rational): Rational =
new Rational(n * that.d + that.n * d, d * that.d)
}
However, given this code the compiler will complain:
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
<sup>
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
</sup>
Although class parameters n and d are in scope in the code of your add method, you can only access
their value on the object on which add was invoked. Thus, when you say n or d in add&#8217;s
implementation, the compiler is happy to provide you with the values for these class parameters. But it
won&#8217;t let you say that.n or that.d because that does not refer to the Rationalobject on which add was
invoked.<span class="footnote"><br />[Actually, you could add a Rational to itself, in which case that would refer to the object on which add was invoked. But because you can pass any Rational object to add, the compiler still won&#8217;t let you say that.n.]<br /></span> To access the numerator and denominator on that, you&#8217;ll need to make them into
fields. Listing 6.1 shows how you could add these fields to classRational.<span class="footnote"><br />[In Section 10.6 you&#8217;ll find out about parametric fields, which provide a shorthand for writing the same code.]<br /></span>
class Rational(n: Int, d: Int) {
require(d != 0)
val numer: Int = n}
val denom: Int = d
override def toString = numer + "/" + denom
def add(that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
Listing 6.1 - Rational with fields.
In the version of Rational shown in Listing 6.1, we added two fields named numer and denom, and
initialized them with the values of class parameters n and d.<span class="footnote"><br />[Even though n and d are used in the body of the class, given they are only used inside constructors, the Scala compiler will not emit fields for them. Thus, given this code the Scala compiler will generate a class with two Int fields, one for numer and one for denom.]<br /></span> We also changed the implementation
of toString and add so that they use the fields, not the class parameters. This version of
class Rational compiles. You can test it by adding some rational numbers:
scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; oneHalf add twoThirds
res2: Rational = 7/6
One other thing you can do now that you couldn&#8217;t do before is access the numerator and denominator
values from outside the object. Simply access the public numer and denom fields, like this:
scala&gt; val r = new Rational(1, 2)
r: Rational = 1/2
scala&gt; r.numer
res3: Int = 1
scala&gt; r.denom
res4: Int = 2
6.6 SELF REFERENCES
The keyword this refers to the object instance on which the currently executing method was invoked, or
if used in a constructor, the object instance being constructed. As an example, consider adding a
method, lessThan, which tests whether the given Rational is smaller than a parameter:
def lessThan(that: Rational) =
this.numer * that.denom &lt; that.numer * this.denom
Here, this.numer refers to the numerator of the object on which lessThan was invoked. You can also
leave off the this prefix and write just numer; the two notations are equivalent.
As an example of where you can&#8217;t do without this, consider adding a max method to classRational that
returns the greater of the given rational number and an argument:
def max(that: Rational) =
if (this.lessThan(that)) that else thisHere, the first this is redundant. You could have left it off and written: lessThan(that). But the
second this represents the result of the method in the case where the test returns false; were you to omit
it, there would be nothing left to return!
6.7 AUXILIARY CONSTRUCTORS
Sometimes you need multiple constructors in a class. In Scala, constructors other than the primary
constructor are called auxiliary constructors. For example, a rational number with a denominator of 1
can be written more succinctly as simply the numerator. Instead of 5/1, for example, you can just write
5. It might be nice, therefore, if instead of writingnew Rational(5, 1), client programmers could simply
write new Rational(5). This would require adding an auxiliary constructor to Rational that takes only
one argument, the numerator, with the denominator predefined to be 1. Listing 6.2 shows what that
would look like.
class Rational(n: Int, d: Int) {
require(d != 0)
val numer: Int = n
val denom: Int = d
def this(n: Int) = this(n, 1) // auxiliary constructor
override def toString = numer + "/" + denom
def add(that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
}
Listing 6.2 - Rational with an auxiliary constructor.
Auxiliary constructors in Scala start with def this(&#8230;). The body of Rational&#8217;s auxiliary constructor
merely invokes the primary constructor, passing along its lone argument, n, as the numerator and 1 as
the denominator. You can see the auxiliary constructor in action by typing the following into the
interpreter:
scala&gt; val y = new Rational(3)
y: Rational = 3/1
In Scala, every auxiliary constructor must invoke another constructor of the same class as its first
action. In other words, the first statement in every auxiliary constructor in every Scala class will have
the form "this(&#8230;)". The invoked constructor is either the primary constructor (as in
the Rational example), or another auxiliary constructor that comes textually before the calling
constructor. The net effect of this rule is that every constructor invocation in Scala will end up
eventually calling the primary constructor of the class. The primary constructor is thus the single point
of entry of a class.Note
If you&#8217;re familiar with Java, you may wonder why Scala&#8217;s rules for constructors are a bit more
restrictive than Java&#8217;s. In Java, a constructor must either invoke another constructor of the same class,
or directly invoke a constructor of the superclass, as its first action. In a Scala class, only the primary
constructor can invoke a superclass constructor. The increased restriction in Scala is really a design
trade-off that needed to be paid in exchange for the greater conciseness and simplicity of Scala&#8217;s
constructors compared to Java&#8217;s. Superclasses and the details of how constructor invocation and
inheritance interact will be explained in Chapter 10.
6.8 PRIVATE FIELDS AND METHODS
In the previous version of Rational, we simply initialized numer with n and denom with d. As a result,
the numerator and denominator of a Rational can be larger than needed. For example, the
fraction 66/42 could be normalized to an equivalent reduced form, 11/7, but Rational&#8217;s primary
constructor doesn&#8217;t currently do this:
scala&gt; new Rational(66, 42)
res5: Rational = 66/42
To normalize in this way, you need to divide the numerator and denominator by theirgreatest common
divisor. For example, the greatest common divisor of 66 and 42 is 6. (In other words, 6 is the largest
integer that divides evenly into both 66 and 42.) Dividing both the numerator and denominator
of 66/42 by 6 yields its reduced form, 11/7. Listing 6.3 shows one way to do this:
class Rational(n: Int, d: Int) {
require(d != 0)
private val g = gcd(n.abs, d.abs)
val numer = n / g
val denom = d / g
def this(n: Int) = this(n, 1)
def add(that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
override def toString = numer + "/" + denom
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 6.3 - Rational with a private field and method.
In this version of Rational, we added a private field, g, and modified the initializers
for numerand denom. (An initializer is the code that initializes a variable; for example, the "n / g" that
initializes numer.) Because g is private, it can be accessed inside the body of the class, but not outside.We also added a private method, gcd, which calculates the greatest common divisor of two passed Ints.
For example, gcd(12, 8) is 4. As you saw in Section 4.1, to make a field or method private you simply
place the private keyword in front of its definition. The purpose of the private "helper method" gcd is to
factor out code needed by some other part of the class, in this case, the primary constructor. To
ensure g is always positive, we pass the absolute value of n and d, which we obtain by invoking abs on
them, a method you can invoke on any Int to get its absolute value.
The Scala compiler will place the code for the initializers of Rational&#8217;s three fields into the primary
constructor in the order in which they appear in the source code. Thus, g&#8217;s initializer,gcd(n.abs, d.abs),
will execute before the other two, because it appears first in the source. Fieldg will be initialized with
the result, the greatest common divisor of the absolute value of the class parameters, n and d. Field g is
then used in the initializers of numer and denom. By dividingn and d by their greatest common
divisor, g, every Rational will be constructed in its normalized form:
scala&gt; new Rational(66, 42)
res6: Rational = 11/7
6.9 DEFINING OPERATORS
The current implementation of Rational addition is OK, but could be made more convenient to use. You
might ask yourself why you can write:
x + y
if x and y are integers or floating-point numbers, but you have to write:
x.add(y)
or at least:
x add y
if they are rational numbers. There&#8217;s no convincing reason why this should be so. Rational numbers are
numbers just like other numbers. In a mathematical sense they are even more natural than, say,
floating-point numbers.
Why should you not use the natural arithmetic operators on them? In Scala you can do this. In the rest
of this chapter, we&#8217;ll show you how.
The first step is to replace add by the usual mathematical symbol. This is straightforward, as <code>is a legal
identifier in Scala. We can simply define a method with + as its name. While we&#8217;re at it, we may as well
implement a method named * that performs multiplication. The result is shown in Listing 6.4:
class Rational(n: Int, d: Int) {
require(d != 0)
private val g = gcd(n.abs, d.abs)
val numer = n / g
val denom = d / gdef this(n: Int) = this(n, 1)
def + (that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
def * (that: Rational): Rational =
new Rational(numer * that.numer, denom * that.denom)
override def toString = numer + "/" + denom
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 6.4 - Rational with operator methods.
With class Rational defined in this manner, you can now write:
scala&gt; val x = new Rational(1, 2)
x: Rational = 1/2
scala&gt; val y = new Rational(2, 3)
y: Rational = 2/3
scala&gt; x + y
res7: Rational = 7/6
As always, the operator syntax on the last input line is equivalent to a method call. You could also
write:
scala&gt; x.</code>(y)
res8: Rational = 7/6
but this is not as readable.
Another thing to note is that given Scala&#8217;s rules for operator precedence, which were described
in Section 5.9, the * method will bind more tightly than the + method for Rationals. In other words,
expressions involving + and * operations on Rationals will behave as expected.For
example, x + x * y will execute as x + (x * y), not (x + x) * y:
scala&gt; x + x * y
res9: Rational = 5/6
scala&gt; (x + x) * y
res10: Rational = 2/3
scala&gt; x + (x * y)
res11: Rational = 5/66.10 IDENTIFIERS IN SCALA
You have now seen the two most important ways to form an identifier in Scala: alphanumeric and
operator. Scala has very flexible rules for forming identifiers. Besides the two forms you have seen
there are also two others. All four forms of identifier formation are described in this section.
An alphanumeric identifier starts with a letter or underscore, which can be followed by further letters,
digits, or underscores. The &#8216;$&#8217; character also counts as a letter; however, it is reserved for identifiers
generated by the Scala compiler. Identifiers in user programs should not contain &#8216;$&#8217; characters, even
though it will compile; if they do, this might lead to name clashes with identifiers generated by the
Scala compiler.
Scala follows Java&#8217;s convention of using camel-case identifiers,<span class="footnote"><br />[This style of naming identifiers is called camel case because the identifiersHaveHumps consisting of the embedded capital letters.]<br /></span> such
as toString andHashSet. Although underscores are legal in identifiers, they are not used that often in
Scala programs, in part to be consistent with Java, but also because underscores have many other non-
identifier uses in Scala code. As a result, it is best to avoid identifiers like to_string,<em>init</em>, or name_.
Camel-case names of fields, method parameters, local variables, and functions should start with a lower
case letter, for example: length, flatMap, and s. Camel-case names of classes and traits should start with
an upper case letter, for example: BigInt, List, and UnbalancedTreeMap.<span class="footnote"><br />[In Section 16.5, you&#8217;ll see that sometimes you may want to give a special kind of class known as a case class a name consisting solely of operator characters. For example, the Scala API contains a class named ::, which facilitates pattern matching on Lists.]<br /></span>
Note
One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to
write a declaration like this, "val name_: Int = 1", you&#8217;ll get a compiler error. The compiler will think
you are trying to declare a val named "name_:". To get this to compile, you would need to insert an
extra space before the colon, as in: "val name_ : Int = 1".
One way in which Scala&#8217;s conventions depart from Java&#8217;s involves constant names. In Scala, the
word constant does not just mean val. Even though a val does remain constant after it is initialized, it is
still a variable. For example, method parameters are vals, but each time the method is called those vals
can hold different values. A constant is more permanent. For example, scala.math.Pi is defined to be the
double value closest to the real value of π, the ratio of a circle&#8217;s circumference to its diameter. This
value is unlikely to change ever; thus, Pi is clearly a constant. You can also use constants to give names
to values that would otherwise bemagic numbers in your code: literal values with no explanation,
which in the worst case appear in multiple places. You may also want to define constants for use in
pattern matching, a use case that will be described in Section 15.2. In Java, the convention is to give
constants names that are all upper case, with underscores separating the words, such
as MAX_VALUE or PI. In Scala, the convention is merely that the first character should be upper case.
Thus, constants named in the Java style, such as X_OFFSET, will work as Scala constants, but the
Scala convention is to use camel case for constants, such as XOffset.
An operator identifier consists of one or more operator characters. Operator characters are printable
ASCII characters such as +, :, ?, ~ or #.<span class="footnote"><br />[More precisely, an operator character belongs to the Unicode set of mathematical symbols(Sm) or other symbols(So), or to the 7-bit ASCII characters that are not letters, digits, parentheses, square brackets, curly braces, single or double quote, or an underscore, period, semi-colon, comma, or back tick character.]<br /></span> Here are some examples of operator identifiers:</p></div>
<div class="paragraph"><p>+
<code>+
::: &lt;?&gt;
:&#8594;The Scala compiler will internally "mangle" operator identifiers to turn them into legal Java identifiers
with embedded $ characters. For instance, the identifier :&#8594; would be represented internally
as $colon$minus$greater. If you ever wanted to access this identifier from Java code, you&#8217;d need to use
this internal representation.
Because operator identifiers in Scala can become arbitrarily long, there is a small difference between
Java and Scala. In Java, the input x&#8592;y would be parsed as four lexical symbols, so it would be
equivalent to x &lt; - y. In Scala, &#8592; would be parsed as a single identifier, giving x &#8592; y. If you want the
first interpretation, you need to separate the &lt; and the - characters by a space. This is unlikely to be a
problem in practice, as very few people would write x&#8592;y in Java without inserting spaces or
parentheses between the operators.
A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an
operator identifier. For example, unary_</code> used as a method name defines a unary <code>operator.
Or, myvar_= used as method name defines an assignment operator. In addition, the mixed identifier
form myvar_= is generated by the Scala compiler to support properties (more on that in Chapter 18).
A literal identifier is an arbitrary string enclosed in back ticks (` &#8230;<code>). Some examples of literal
identifiers are:
`x</code>
<code>&lt;clinit&gt;</code>
<code>yield</code>
The idea is that you can put any string that&#8217;s accepted by the runtime as an identifier between back
ticks. The result is always a Scala identifier. This works even if the name contained in the back ticks
would be a Scala reserved word. A typical use case is accessing the static yieldmethod in
Java&#8217;s Thread class. You cannot write Thread.yield() because yield is a reserved word in Scala.
However, you can still name the method in back ticks, e.g., Thread.<code>yield</code>().
6.11 METHOD OVERLOADING
Back to class Rational. With the latest changes, you can now do addition and multiplication operations
in a natural style on rational numbers. But one thing still missing is mixed arithmetic. For instance, you
cannot multiply a rational number by an integer because the operands of * always have to be Rationals.
So for a rational number r you can&#8217;t write r * 2. You must write r * new Rational(2), which is not as
nice.
To make Rational even more convenient, we&#8217;ll add new methods to the class that perform mixed
addition and multiplication on rational numbers and integers. While we&#8217;re at it, we&#8217;ll add methods for
subtraction and division too. The result is shown in Listing 6.5.
class Rational(n: Int, d: Int) {
require(d != 0)
private val g = gcd(n.abs, d.abs)
val numer = n / g
val denom = d / gdef this(n: Int) = this(n, 1)
def + (that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
def + (i: Int): Rational =
new Rational(numer + i * denom, denom)
def - (that: Rational): Rational =
new Rational(
numer * that.denom - that.numer * denom,
denom * that.denom
)
def - (i: Int): Rational =
new Rational(numer - i * denom, denom)
def * (that: Rational): Rational =
new Rational(numer * that.numer, denom * that.denom)
def * (i: Int): Rational =
new Rational(numer * i, denom)
def / (that: Rational): Rational =
new Rational(numer * that.denom, denom * that.numer)
def / (i: Int): Rational =
new Rational(numer, denom * i)
override def toString = numer + "/" + denom
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 6.5 - Rational with overloaded methods.
There are now two versions each of the arithmetic methods: one that takes a rational as its argument
and another that takes an integer. In other words, each of these method names isoverloaded because
each name is now being used by multiple methods. For example, the name + is used by one method
that takes a Rational and another that takes an Int. In a method call, the compiler picks the version of an
overloaded method that correctly matches the types of the arguments. For instance, if the
argument y in x.</code>(y) is a Rational, the compiler will pick the method + that takes a Rational parameter.
But if the argument is an integer, the compiler will pick the method + that takes an Int parameter
instead. If you try this:
scala&gt; val x = new Rational(2, 3)
x: Rational = 2/3
scala&gt; x * x
res12: Rational = 4/9
scala&gt; x * 2res13: Rational = 4/3
You&#8217;ll see that the * method invoked is determined in each case by the type of the right operand.
Note
Scala&#8217;s process of overloaded method resolution is very similar to Java&#8217;s. In every case, the chosen
overloaded version is the one that best matches the static types of the arguments. Sometimes there is no
unique best matching version; in that case the compiler will give you an "ambiguous reference" error.
6.12 IMPLICIT CONVERSIONS
Now that you can write r * 2, you might also want to swap the operands, as in 2 * r. Unfortunately this
does not work yet:
scala&gt; 2 * r
&lt;console&gt;:10: error: overloaded method value * with
alternatives:
(x: Double)Double &lt;and&gt;
(x: Float)Float &lt;and&gt;
(x: Long)Long &lt;and&gt;
(x: Int)Int &lt;and&gt;
(x: Char)Int &lt;and&gt;
(x: Short)Int &lt;and&gt;
(x: Byte)Int
cannot be applied to (Rational)
2 * r
^
The problem here is that 2 * r is equivalent to 2.*(r), so it is a method call on the number 2, which is an
integer. But the Int class contains no multiplication method that takes a Rationalargument—it couldn&#8217;t
because class Rational is not a standard class in the Scala library.
However, there is another way to solve this problem in Scala: You can create an implicit conversion
that automatically converts integers to rational numbers when needed. Try adding this line in the
interpreter:
scala&gt; implicit def intToRational(x: Int) = new Rational(x)
This defines a conversion method from Int to Rational. The implicit modifier in front of the method
tells the compiler to apply it automatically in a number of situations. With the conversion defined, you
can now retry the example that failed before:
scala&gt; val r = new Rational(2,3)
r: Rational = 2/3
scala&gt; 2 * r
res15: Rational = 4/3
For an implicit conversion to work, it needs to be in scope. If you place the implicit method definition
inside class Rational, it won&#8217;t be in scope in the interpreter. For now, you&#8217;ll need to define it directly in
the interpreter.As you can glimpse from this example, implicit conversions are a very powerful technique for making
libraries more flexible and more convenient to use. Because they are so powerful, they can also be
easily misused. You&#8217;ll find out more on implicit conversions, including ways to bring them into scope
where they are needed, in Chapter 21.
6.13 A WORD OF CAUTION
As this chapter has demonstrated, creating methods with operator names and defining implicit
conversions can help you design libraries for which client code is concise and easy to understand. Scala
gives you a great deal of power to design such easy-to-use libraries. But please bear in mind that with
power comes responsibility.
If used unartfully, both operator methods and implicit conversions can give rise to client code that is
hard to read and understand. Because implicit conversions are applied implicitly by the compiler, not
explicitly written down in the source code, it can be non-obvious to client programmers what implicit
conversions are being applied. And although operator methods will usually make client code more
concise, they will only make it more readable to the extent client programmers will be able to recognize
and remember the meaning of each operator.
The goal you should keep in mind as you design libraries is not merely enabling concise client code,
but readable, understandable client code. Conciseness will often be a big part of that readability, but
you can take conciseness too far. By designing libraries that enable tastefully concise and at the same
time understandable client code, you can help those client programmers work productively.
6.14 CONCLUSION
In this chapter, you saw more aspects of classes in Scala. You saw how to add parameters to a class,
define several constructors, define operators as methods, and customize classes so that they are natural
to use. Maybe most importantly, you saw that defining and using immutable objects is a quite natural
way to code in Scala.
Although the final version of Rational shown in this chapter fulfills the requirements set forth at the
beginning of the chapter, it could still be improved. We will in fact return to this example later in the
book. For example, in Chapter 30, you&#8217;ll learn how to override equals andhashcode to allow Rationals
to behave better when compared with == or placed into hash tables. In Chapter 21, you&#8217;ll learn how to
place implicit method definitions in a companion object forRational, so they can be more easily placed
into scope when client programmers are working with Rationals.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 3.0<br />
Last updated
 2019-01-28 01:38:32 EET
</div>
</div>
</body>
</html>
