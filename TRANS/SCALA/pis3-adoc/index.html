<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Програмування на Scala, 3тє видання</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Програмування на Scala, 3тє видання</h1>
<span id="author">Martin Odersky, Lex Spoon, Bill Venners</span><br />
<span id="revnumber">version 3.0,</span>
<span id="revdate">2016-12</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_______scala">Подяки за ранішні редакції Програмування на Scala</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="content">Програмування на Scala є, можливо, одною з кращих книжок з програмування, що я будь-коли читав. Мені подобається стиль написання, краткість та глибина викладення. Книжка, здається, відповідає на кожне запитання, як тілько воно спадає мені на думку - вона завжди на крок попереду мене. Автори не тільки надають деякий код та викладають речі як належне. Вони дають вам саму суть, так що ви дійсно розумієте що відбувається. Мені це дійсно подобається.</div>
<div class="attribution">
<em>Chief Software Architect</em><br />
&#8212; Ken Egervari
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala написано ясно, глибоко, та їй легко слідувати. Вона має чудові приклади та сповнена чудовими підказками. Вона дозволила нашій організації опанувати мову Scala швидко та ефективно. Ця книжка чудова для кожного програміста, хто намагається налаштувати свою голову на гнучкість та елегантність мови Scala.</div>
<div class="attribution">
<em>власник Morroni Technologies Inc.</em><br />
&#8212; Larry Morroni
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala служить як чудовий туторіал по мові Scala. Просування по книзі іде гладко, де кожна глава будується на концепціях та прикладах, описаних в попередніх главах. Книга турбується про глибоке пояснення конструкцій мови, часто провадячи приклади того, як мова відрізняється від Java. Так само, як і головна мова, також є деяке покриття бібліотек, як контейнери та актори. Я знайшов книгу простою до проробки, і це, можливо, одна з кращих написаних технічних книжок, що я читав останні часом. Я справді можу рекомендувати цю книжку любому програмісту, що бажає знайти більше щодо мови Scala.</div>
<div class="attribution">
&#8212; Matthew Todd
</div></div>
<div class="quoteblock">
<div class="content">Я здивований зусиллями, здісненими авторами Програмування на Scala. Ця книга є неоціненним керівництвом до того, що я називаю платформою Scala: рушій до кращого кодування, постійне натхнення до розробки та реалізації маштабованого програмного забезпечення. Якби я тільки мав Scala в її сучасному зрілому стані, та цю книжку в далекому 2003му році, коли я спів-розробляв та реалізував частини інфраструктури порталу Олімпійськіх Ігор 2004 в Афінах! Всім читачам: не важливо, який ваш програмістській бекграунд, я відчуваю ви знайдете програмування на Scala вивільняючим, та ця книга буде вірним другом в цій подорожі.</div>
<div class="attribution">
<em>Software Consultant & Researcher</em><br />
&#8212; Christos KK Loverdos
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala є довершеним глибинним вступом до Scala,та це також чудове посилання. Я хочу сказати, що вона займає видатне місце на моїй книжній полиці, і крім цього я все ще ношу її з собою майже будь-де, куди я іду.</div>
<div class="attribution">
<em>президент ArdenTex</em><br />
&#8212; Brian Clapper
</div></div>
<div class="quoteblock">
<div class="content">Чудова книга, гарно написана з осмисленими прикладами. Я можу рекомендувати її як для досвідчених програмістів, так і для початківців.</div>
<div class="attribution">
&#8212; Howard Lovatt
</div></div>
<div class="quoteblock">
<div class="content">Книга Програмування на Scala не тільки про те, як, але, більш важливо, чому слід розробляти програми на цій новій мові програмування. Прагматичний підхід в введені до потужності комбінування об'єктно-орієнтовного та функціонального програмування, залишає читача без жодних сумнівів, чим насправді є Scala.</div>
<div class="attribution">
<em>CEO/засновник EXPRO I.T. & консультант</em><br />
&#8212; Dr. Ervin Varga
</div></div>
<div class="quoteblock">
<div class="content">Це чудове введення до функціонального програмування для ОО програмістів. Навчання щодо ФП було моєю головною ціллю, але я також познайомився з деякими милими сюрпризами Scala, як кейс класи та порівняння шаблонів. Scala є інтригуючою мовою, та ця книжка гарно розмовідає про це. Завжди є гарна лінія, вздовж якої треба іти в книжці вступу до мови, між надання дуже багато, та нестачею достатньої інформації. Я знайшов, що Програмування на Scala досягла ідеального балансу.</div>
<div class="attribution">
<em>Programmer Analyst</em><br />
&#8212; Jeff Heon
</div></div>
<div class="quoteblock">
<div class="content">Я придбав ранішню електронну версію книжки Програмування на Scala від Odersky, Spoon та Venners, та безпосередньо став фанатом. На додаток до факту, що вона містить найбільш всеосяжну інформацію щодо мови, існує декілька ключових особливостей електронного формату, що вразили мене. Я ніколи не бачив посилань в PDF, що служать не тільки для закладок, але також провадять активні посилання з таблиці змісту та індексів. Я не знаю, чому більше авторів не використовують цю можливість, оскільки це дійсно радість для читача. Інша можливість, якою я був вражений, були посилання на форуми ("Discuss"), та спосіб надсилати коментарі ("Suggest") до авторів по електронній пошті. Можливість коментувати сама по собі не є незвичною, але проста вставка номера сторінки, що генерується для надсилання авторам, є важливою для обох, авторів та читачів. Я доклав більше коментарів, ніж я мав би, якби процес був би більш важкий. Читайте Програмування на Scala заради вмісту, але якщо ви читаєте електронну версію, обов'язково отримайте переваги від цифрових можливостей, які автори подбали вбудувати в книжку!</div>
<div class="attribution">
<em>засновник/консультант SRT Solutions</em><br />
&#8212; Dianne Marsh
</div></div>
<div class="quoteblock">
<div class="content">Ясність та технічна повнота є відзнакою любої гарно написаної книжки, та я вітаю Martin
Odersky, Lex Spoon та Bill Venners з тим, що вони зробили цю роботу дуже гарно! Книжка Programming in Scala починається з встановлення гарного фундаменту з базовими концепціями,та просуває користувача на середній рівень, та далі. Ця книга беззаперечно обов'язкова для придбання для кожного, що прагне вивчити Scala.</div>
<div class="attribution">
<em>Enterprise Architecture & GMAC Financial Services</em><br />
&#8212; Jagan Nambi
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala приємно читається. Це одна з тих гарно написаних технічних книжок, що провадять глибоке та повне покриття предмету в екстремально стислій та елегантній манері. Книга організована в дуже природний та логічний спосіб. Вона однаково гарно пристосована для зацікавлених технологістів, які просто бажають залишатись на піці поточних трендів, та професіоналів, що шукають глибокого розуміння основних можливостей  мови, та обгрунтувань її дизайну. Я дуже рекомендую її всім зацікавленим в фіункціональному програмуванні взагалі. Для розробників Scala ця книга безумовно є обов'язковою для читання.</div>
<div class="attribution">
<em>Software Architect/Lead Programmer @ Greystone Inc.</em><br />
&#8212; Igor Khlystov
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala прямо точиться кількістю важкої роботи, що пішла до неї. Я ніколи до цього не читав книжку в стилі туторіала, що виконує роль вступу, і при цьому є повною: в їх (помилковій) спробі бути доступними, та не "засмучувати" читача, більшість туторіалів замовчують аспекти предмета, що дуже просунутий для поточного обговорення. Це залишає дуже поганий присмак, бо ніхто не може бути впевнений, якого розуміння ви вже досягли. Завжди існує деяка залишкова "магія", що не була пояснена, та  взагалі не може бути зрозумілою читачеві. Ця книжка нуколи не робить цього, вона нічого не приймає на віру: кожна деталь або достатньо пояснена, або надається посилання на подальше пояснення. Дійсно, текст екстенсивно посилається на себе та індексований, так що формує повну картину складної теми відносно просто.</div>
<div class="attribution">
<em>Enterprise Java Architect</em><br />
&#8212; Gerald Loeffler
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala від Martin Odersky, Lex Spoon та Bill Venners: в часи, коли гарні книжкі є рідкістю, це чудове введення для програмістів середнього рівня дійсно є винятнковим. Ви знайдете тут все, щоб вивчити цю мову програмування.</div>
<div class="attribution">
&#8212; Christian Neukirchen
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>Programmmin in Scala, Third Edition
Martin Odersky, Lex Spoon, Bill Venners
Artima Press
Walnut Creek, California
   Martin Odersky є створювачем мови Scala та професором EPFL in Lausanne, Switzerland.
   Lex Spoon робив над Scala протягом двох років разом з Martin Odersky.
   Bill Venners є президентом Artima, Inc.</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_">Передмова</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви обрали чудовий час взяти до рук цю книгу! Сприйняття Scala продовжує пришвидшуватись, наша спільнота вирує, та навкола пропозиції роботи. Чи ви програмуєте для розваги чи для прибутку (або обоє), обіцяна Scala радість та продуктивність робить супротив складним. Щодо мене, дійсна радість програмування походить від протистояння цікавим викликам, за допомогою простих, витончених рішень. Місія Scala не тільки в тому, щоб зробити це можливим, але приємним, і ця книга покаже вам як.</p></div>
<div class="paragraph"><p>Зпочатку я експериментував з Scala 2.5, та миттєво був втугнутий в її синтаксичну та концептуальну впорядкованість. Коли я натрапив на нерегулярність, що параметри типів самі не можуть мати параметри типів, я (боязко) підійшов до Martin Odersky на конференції в 2006, та запронував стажування, щоб позбутись цього обмеження. Моя контриб'юція була сприйнята, що привнесло підтримку поліморфізм конструкторів типів в Scala 2.7 та вище. З тих пір я робив над більшістю інших частин компілятора. В 2012 я пішов з пост-докторської практики в лабораторії Martin на керівника команди Scala в Typesafe, по мірі того, як Scala, з версією 2.10, подорослішала від своїх прагматичних академічних коренів до надійної мови рівня корпорації.</p></div>
<div class="paragraph"><p>Scala 2.10 була поворотною точкою від швидко розвинених, багатих можливостями релізів, базованих на академічних дослідах, в напрямку фокусування на спрощенні та збільшенні прийняття адаптації підприємствами. Ми змістили нашу увагу на проблеми, які неможливо описати в дисертаціях, такі, як бінарна сумісність між головними релізами. Щоб збалансувати стабільність з нашим бажанням продовжувати розробку та покращення платформи Scala, ми робимо в напрямку меньшої головної бібліотеки, яку ми збираємось стабілізувати, при цьому розвиваючи платформу як ціле. Щоб зробити це можливим, мій перший проект в якості технічного керівника Scala був початок модулярізації стандартної бібліотеки Scala в 2.11.</p></div>
<div class="paragraph"><p>Щоб зменшити частоту змін, Typesafe також вирішила поперемінно змінювати бібліоттеку та компілятор. Ця редакція Програмування на Scala відноситься до Scala 2.12, що буде релізом компілятора, який матиме новий бек-енд та оптимізатор, щоб отримати більше від нових можливостей Java 8. Для взаємодії з Java, та насолодження тими ж перевагами від оптимізації JVM, Scala компілює функції в той самий байткод, що і компілятор Java 8. Подібно, трейти Scala тепер компілюються в інтерфейси Java з методами по замовчанню. Обоє схеми компіляції зменшують магію, яку мали виконувати старіші компілятори Scala, більш тісно наближаючи нас до платформи Java, при цьому покращуючи обоє, час компіляції та продуктивність часу виконання, з гладшою бінарною сумісністю!</p></div>
<div class="paragraph"><p>Це покращення до платформи Java 8 дуже захоалююче для Scala, та це дуже приємно бачити, що Java рівняється на тренд, який Scala встановлювала протягом дисятиріччя! Без жодного сумніву, що Scala провадить значно більш функціональний досвід програмування, з незмінністю по замовчанню, уніформним трактуванням виразів (навряд чи в цій книзі можливо побачити твердження return), співпадіння шаблонів, варіативність в місці визначення (варіативність в місці використання Java робить створення субтипів функції незграбним), і так далі! Кажучи прямо, існує дещо в функціональному програмуванні, ніж милий синтаксис для лямбди.</p></div>
<div class="paragraph"><p>В якості розпорядників мови, наша ціль є розробляти основу мови, так само, як зрощувати екосистему. Scala є успішною, оскільки вона має багато чудових бібліотек, видатні IDE та інструменти, та дружніх і завжди готових допомогти членів нашої спільноти. Я глибоко насолоджуюсь своєю першою декадою зі Scala — як реалізатор мови, це є великим збудженням і натхненням бачити стільки програмістів, що насолоджуються Scala в безлічі напрямків.</p></div>
<div class="paragraph"><p>Я люблю програмувати на Scala, і маю надію ви полюбите також. Від імені спільноти Scala вітаю вас!</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Adriaan Moors
San Francisco, CA
January 14, 2016</code></pre>
</div></div>
<div class="sect1">
<h2 id="__2">Подяки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато людей доклали до цієї книги, та до матеріалів, які вона розкриває. Ми вдячні всім їм.</p></div>
<div class="paragraph"><p>Scala сама по собі була колективним зусиллям багатьох людей. Розробці та реалізації версії 1.0 допомагали Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman та Matthias Zenger. Phil Bagwell, Antonio Cunei, Iulian Dragos, Gilles Dubochet, Miguel Garcia, Philipp Haller, Sean McDirmid, Ingo Maier, Donna Malayeri, Adriaan Moors, Hubert Plociniczak, Paul Phillips, Aleksandar Prokopec, Tiark Rompf, Lukas Rytz та Geoffrey Washburn приєднали зусилля для розробки другої та поточної версії мови та інструментів.</p></div>
<div class="paragraph"><p>Gilad Bracha, Nathan Bronson, Caoyuan, Aemon Cannon, Craig Chambers, Chris Conrad, Erik Ernst, Matthias Felleisen, Mark Harrah, Shriram Krishnamurti, Gary Leavens, David MacIver, Sebastian Maneth, Rickard Nilsson, Erik Meijer, Lalit Pant, David Pollak, Jon Pretty, Klaus Ostermann, Jorge Ortiz, Didier Rémy, Miles Sabin, Vijay Saraswat, Daniel Spiewak, James Strachan, Don Syme, Erik Torreborre, Mads Torgersen, Philip Wadler, Jamie Webb, John Williams, Kevin Wright та Jason Zaugg окреслили дизайн мови, щедро подоілившись своїми ідеями з нами в живих та надихаючих дискусіях, через контриб'юцію важливих частин коду до зусиль відкритого коду, так само, як і через коментарі до попередніх версій цього документу. Дописувачі в список розсилки Scala також надали дуже корисний зворотній зв'язок, що допоміг нам покращити мову та інструменти.</p></div>
<div class="paragraph"><p>George Berger працював наполегливо, щоб зробити процес побудови та веб присутність книги роблячими гладко. Як результат, цей проект був чудово вільний від технічних непередбачуваностей.</p></div>
<div class="paragraph"><p>Багато людей надали нам цінний зворотній зв'язок щодо ранішніх версій цього тексту. Подяки надходять до Eric Armstrong, George Berger, Alex Blewitt, Gilad Bracha, William Cook, Bruce Eckel, Stéphane Micheloud, Todd Millstein, David Pollak, Frank Sommers, Philip Wadler, and Matthias Zenger. Також дякуємо до групи Silicon Valley Patterns, за їх дуже корисний огляд: Dave Astels, Tracy Bialik, John Brewer, Andrew Chase, Bradford Cross, Raoul Duke, John P. Eurich, Steven Ganz, Phil Goodwin, Ralph Jocham, Yan-Fa Li, Tao Ma, Jeffery Miller, Suresh Pai, Russ Rufer, Dave W. Smith, Scott Turnquest, Walter Vannini, Darlene Wallach та Jonathan Andrew Wolter. Та нам приємно подякувати Dewayne
Johnson та Kim Leedy за їх допомогу з оформленням обкладинки, та Frank Sommers за його роботу з індексом.</p></div>
<div class="paragraph"><p>Нам також приємно поширити особливі подяки всім нашим читачам, що надали коментарі. Ваші коментарі дуже корисні для нас в окресленні цієї, навіть кращої книжки. Ми не можемо надрукувати імена всіх, хто надіслав коментарі. але ось імена тих читачів, які надіслали щонайменьше п'ять коментарів на протязі стадії eBook PrePrint®, через клацання на посиланні Suggest, впорядковані від найбільшого загального числа надісланих коментарів, та потім за алфавітом. Подякі до: David Biesack, Donn Stephan, Mats Henricson, Rob Dickens, Blair Zajac, Tony Sloane, Nigel Harrison, Javier Diaz Soto, William Heelan, Justin Forder, Gregor Purdy, Colin Perkins, Bjarte S. Karlsen, Ervin Varga, Eric
Willigers, Mark Hayes, Martin Elwin, Calum MacLean, Jonathan Wolter, Les Pruszynski, Seth Tisue, Andrei Formiga, Dmitry Grigoriev, George Berger, Howard Lovatt, John P. Eurich, Marius Scurtescu,Jeff Ervin, Jamie Webb, Kurt Zoglmann, Dean Wampler, Nikolaj Lindberg, Peter McLain, Arkadiusz Stryjski, Shanky Surana, Craig Bordelon, Alexandre Patry, Filip Moens, Fred Janon, Jeff Heon, Boris Lorbeer, Jim Menard, Tim Azzopardi, Thomas Jung, Walter Chang, Jeroen Dijkmeijer, Casey Bowman, Martin Smith, Richard Dallaway, Antony Stubbs, Lars Westergren, Maarten Hazewinkel, Matt Russell, Remigiusz Michalowski, Andrew Tolopko, Curtis Stanford, Joshua Cough, Zemian Deng, Christopher Rodrigues Macias, Juan Miguel Garcia Lopez, Michel Schinz, Peter Moore, Randolph Kahle, Vladimir Kelman, Daniel Gronau, Dirk Detering, Hiroaki Nakamura, Ole Hougaard, Bhaskar Maddala, David Bernard, Derek Mahar, George Kollias, Kristian Nordal, Normen Mueller, Rafael Ferreira, Binil
Thomas, John Nilsson, Jorge Ortiz, Marcus Schulte, Vadim Gerassimov, Cameron Taggart, Jon-Anders Teigen, Silvestre Zabala, Will McQueen та Sam Owen.</p></div>
<div class="paragraph"><p>Ми також бажаемо подякувати тим, хто надіслав коментарі та помилки після друку перших двох видань, включаючи Felix Siegrist, Lothar Meyer-Lerbs, Diethard Michaelis, Roshan Dawrani, Donn Stephan, William Uther, Francisco Reverbel, Jim Balter, and Freek de Bruijn, Ambrose Laing, Sekhar Prabhala, Levon Saldamli, Andrew Bursavich, Hjalmar Peters, Thomas Fehr, Alain O&#8217;Dea, Rob Dickens, Tim Taylor, Christian Sternagel, Michel Parisien, Joel Neely, Brian McKeon, Thomas Fehr, Joseph Elliott, Gabriel da Silva Ribeiro, Thomas Fehr, Pablo Ripolles, Douglas Gaylor, Kevin Squire, Harry-Anton Talvik, Christopher Simpkins, Martin Witmann-Funk, Jim Balter, Peter Foster, Craig Bordelon, Heinz-Peter Gumm, Peter Chapin, Kevin Wright, Ananthan Srinivasan, Omar Kilani, Donn Stephan, Guenther Waffler.
Lex would like to thank Aaron Abrams, Jason Adams, Henry and Emily Crutcher, Joey Gibson, Gunnar Hillert, Matthew Link, Toby Reyelts, Jason Snape, John та Melinda Weathers, та всім членам Atlanta Scala Enthusiasts за багато корисних дискусій щодо розробки мови, її матеатичних засадах, та як презентувати Scala працюючим інженерам.</p></div>
<div class="paragraph"><p>Спеціальна подяка для Dave Briccetti та Adriaan Moors за огляд третього видання, та до Marconi Lanna за не тільки огляд, але за надання мотивації для третього видання, надаючи розмову, озаглавлену "Що нового з часів Програмування на Scala."</p></div>
<div class="paragraph"><p>Bill має подякувати Gary Cornell, Greg Doench, Andy Hunt, Mike Leonard, Tyler Ortman, Bill
Pollock, Dave Thomas та Adam Wright за провадження розуміння та поради по друку книжки. Bill також дякує Dick Wall за взаємодію над курсом Escalate Stairway to Scala, що значною частиною базується на цій книжці. Наші багато років досвіду викладання Stairway to Scala допомогло зробити цю книжку краще. Нарешті, Bill має подякувати Darlene Gruendl та Samantha Woolf за їх допомогу в тому, щоб третє видання було закінчене.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__3">Вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця книжка є туторіалом по мові програмування Scala, написану людьми, напряму причетними до розробки Scala. Наша ціль полягає в тому, щоб читаючи цю книжку ви могли навчитись всьому, що треба, щоб бути продуктивним Scala програмістом. Всі приклади в цій книжці компілюються за допомогою Scala версії 2.11.7, за винятком тих, що відмічені 2.12, що компілюються за допомогою 2.12.0-M3.</p></div>
<div class="sect2">
<h3 id="_____">Кому слідує читати цю книжку</h3>
<div class="paragraph"><p>Головна цільова аудієнція для цієї книжки є програмісти, які бажають навчитись програмуванню на Scala. Якщо ви бажаєте робити ваш наступний проект на Scala, тоді ця книжка для вас. На додаток, книжка має бути цікавою для програмістів, що бажають розширити свої горизонти через навчання нових концепцій. Наприклад, якщо ви Java програміст, читання цієї книжки відкриє вас до багатьох концепцій з функціонального програмування, так само, як просунутих об'єктно-орієнтовних ідей. Ми віримо, що навчання  Scala, та стоячих за нею ідей, може допомогти стати кращим програмістом, загалом.</p></div>
<div class="paragraph"><p>Передбачається загальне знання програмування. Хоча Scala є гарною першою мовою програмування, це не книжка для навчання програмуванню.</p></div>
<div class="paragraph"><p>З іншого боку, ніякого спеціального знання мов програмування не потрібне. Навіть якщо більшість людей використовують Scala на платформі Java, ця книга не очікує, що ви знаєте щось про Java. Однак ми очікуємо, що багато читачів будуть знайомі з Java, так що часом порівнюємо Scala з Java, щоб допомогти таким читачам розуміти відмінності.</p></div>
</div>
<div class="sect2">
<h3 id="____">Як використовувати цю книгу</h3>
<div class="paragraph"><p>Оскільки головне призначення цієї книжки служити туторіалом, рекомендований спосіб читати цю книгу в порядку глав, зпочатку до кінця. Ми дуже намагались викладати одну тему за раз, та пояснюємо нові теми тільки в термінах тем, що ми вже розглянули. Таким чином, якщо ви пересунетесь в кінець, що скоріше підхопити щось, ви можете винайти, що це пояснено в термінах концепцій, що ви не зовсім розумієте. Доки ви читаєте глави по порядку, ми вважаємо, що ви знайдете досить прямолінійним отримати знання в Scala, по одному кроку за раз.</p></div>
<div class="paragraph"><p>Якщо ви бачите невідомий вам термін, будьте певні, що перевірили глосарій та індекс. Багато читачів будуть швидко переглядати частини книжки, і це непогано. Глосарій та індекс можуть допомогти вам надолужити, якщо ви проскочили щось дуже швидко.</p></div>
<div class="paragraph"><p>Після того, як ви прочитали книжку один раз, вона може також служити посиланням мови. Існує формальна специфікація мови Scala, але специфікація мови намагається бути точною, ціною читабельності. Хоча ця книга не покриває кожної деталі Scala, вона досить повна, та може служити як доступне посилання до мови, по мірі як ви ставатимете більш адаптованим в програмуванні Scala.</p></div>
</div>
<div class="sect2">
<h3 id="___scala">Як навчатись Scala</h3>
<div class="paragraph"><p>Ви можете багато чому навчитись про Scala, просто читаючи цю книжку від корки до корки. Однак, ви можете навчитись Scala швидше та більш глибоко, якщо зробите декілька додаткових речей.</p></div>
<div class="paragraph"><p>Зпершу, ви можете отримати вигоду від багатьох прикладів програм, включених в цю книжку. Набираючи їх самотужки є шляхом змісити ваші думки проходити через кожний рядок коду. Пробуючи варіації є шляхом зробити це більш веселим, та переконатись, що ви дійсно розумієте, як вони працюють.</p></div>
<div class="paragraph"><p>Друге, пристаньте до багатьох онлайн форумів. Таким чином ви та інші інтузіасти Scala можете допомагати один одному. Є багато списків розсилки, дискусійних форумів, чат кімнат, wiki, та декілька Scala-специфічних фідів статей. Витратьте деякий час для пошуку такого, що задовільняє вашим інформаційним потребам. Ви будете витрачати значно меньше часу за вирішенням простих проблем, так що ви зможете витрачати час на глибші, більш важливі питання.</p></div>
<div class="paragraph"><p>Нарешті, коли ви прочитаєте досить, оберіть собі власний програмний проект. Робіть над малою програмою від початку, або розробляйте додаток до більшої програми. Ви можете зайти тільки так далеко, читаючи.</p></div>
</div>
<div class="sect2">
<h3 id="__ebook">Можливості eBook</h3>
<div class="paragraph"><p>Ця книжка доступна в обох, паперовій формі та PDF eBook. eBook не просто електронна копія паперової версії книжки. Хоча вміст той самий, що і в паперовій версії, eBook була прискіпливо розроблена та оптимізована для читання на комп'ютерному екрані.</p></div>
<div class="paragraph"><p>Перша річ, що треба зауважити, це що більшість посилань в eBook і гіперпосиланнями. Якщо ви виберете главу, малюнок, або елемент глосарію, ваш PDF переглядач  повинене перенести вас прямо до обраного елементу, так що вам не знадобиться гортати, щоб знайти його.</p></div>
<div class="paragraph"><p>Додатково, знизу кожної сторінки в eBook є декілька навігаційних посилань. Посилання Обкладинка, Огляд та Вміст перенесуть вас на вступні сторінки книжки. Глосарій та Індекс посилаються на частини посилань книжки. Нарешті, посилання Обговорення перенесе вас до онлайн форуму, де ви обговорюєте питання з другими читачами, авторами та ширшою спільнотою Scala. Якщо ви знайдете помилку друку, або щось, що ви вважаєте має пояснюватись краще, будь ласка клацніть на посилання Зауваження, що перенесе вас до онлайн веб застосування, де ви можете надати зворотній зв'язок авторам.</p></div>
<div class="paragraph"><p>Хоча та сама сторінка з'являється в eBook як і в друкованій книжці, порожні сторінки видалені, та залишені сторінки перенумеровані. Сторінки пронумеровані по-різному, так що вам простіше визначати номери сторінок PDF при друці тільки частини eBook. Таким чином, сторінки в eBook є нумеровані саме так, як їх нумероватиме PDF переглядач.</p></div>
</div>
<div class="sect2">
<h3 id="__">Типографічні домовленості</h3>
<div class="paragraph"><p>Перший раз, коли визначається <em>термін</em>, він виділяється прописом. Малий приклад коду як  <code>x + 1</code>, записується інлайн моноширинним шрифтом. Більші приклади коду покладаються в моноширинні блоки запозичень, як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">hello</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли показується інтерактивна оболонка, відповіді від оболонки показуються легшим шрифтом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>scala&gt; <span class="m">3</span> + <span class="m">4</span>
res0: <span class="nv">Int</span> <span class="o">=</span> <span class="m">7</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Огляд вмісту</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Глава 1 "Маштабована мова", надає вам огляд дизайну Scala, разом з міркуваннями, історією, що стоять за нею.
</p>
</li>
<li>
<p>
Глава 2 "Перші кроки в Scala", показує вам, як робити декілька базових завдань програмування в Scala, не вдаючись в великі деталі щодо того, як воно робить. Ціль цієї глави є змусити ваші пальці почати друкувати та виконувати код Scala.
</p>
</li>
<li>
<p>
Глава 3 "Наступні кроки в Scala", показує вам декілька більш базових програмних завдань,  що будуть допомагати вам швидко набрати темп в Scala. Після завершення цієї глави, ви повинні бути в змозі почати використовувати Scala для простих скриптових задач.
</p>
</li>
<li>
<p>
Глава 4 "Класи та об'єкти", розпочинає глибинне покриття Scala з визначення його базових об'єктно-орієнтованих будівельних блоків та інструкцій щодо того, як компілювати та виконувати застосування Scala.
</p>
</li>
<li>
<p>
Глава 5 "Базові типи та операції", розкриває базові типи Scala, їх літерали, операції, що ви можете виконувати з ними, як роблять преоритети та асоційованість, та що таке збагачені обертки.
</p>
</li>
<li>
<p>
Глава 6 "Функціональні об'єкти", занурюється більш глибоко в об'єктно-орієнтовні можливості Scala, використовуючи функціональні (тобто незмінні) раціональні числа в якості приклада.
</p>
</li>
<li>
<p>
Глава 7 "Вбудовані керівні структури", показує вам, як використовувати вбудовані структури керування Scala: if, while, for, try, та match.
</p>
</li>
<li>
<p>
Глава 8 "Функції та замикання", провадить глибинне пояснення функцій, базових будівельних блоків функціональних мов.
</p>
</li>
<li>
<p>
Глава 9 "Абстракції керування", показує, як розширювати базові керуючі структури Scala через визначення ваших власних керівних абстракцій.
</p>
</li>
<li>
<p>
Глава 10 "Композиція та наслідування", обговорює більше з підтримки Scala об'єктно-орієнтовного програмування. Теми не такі фундаментальні, як ті що в Главі 4, але вони часто постають на практиці.
</p>
</li>
<li>
<p>
Глава 11 "Ієрархія Scala", пояснює ієрархію наслідування Scala, та обговорює її універсальні методи та нижні типи.
</p>
</li>
<li>
<p>
Глава 12 "Трейти", розказує про механізм Scala для міксін композиції. Глава показує, як роблять трейти, описує загальні використання, та пояснює, як трейти покращують традиційне множинне наслідування.
</p>
</li>
<li>
<p>
Глава 13 "Пакунки та імпорти", обговорює проблеми програмування в широкому сенсі, включаючи пакунки вищого рівня, твердження імпорту, та модифікатори контроля доступа, як <code>protected</code> та <code>private</code>.
</p>
</li>
<li>
<p>
Глава 14 "Твердження та тести", показує механізм тверджень Scala, та надає тур по декількох інструментах для написання тестів в Scala, зокрема фокусуючись на ScalaTest.
</p>
</li>
<li>
<p>
Глава 15 "Кейс класи та співпадіння шаблонів", вводять конструкції-близьнюки, що підтримують вас при написанні регулярних, неінкапсульованих структур даних. Кейс класи та співпадіння шаблонів зокрема корисні для дерево-подібних рекурсивних даних.
</p>
</li>
<li>
<p>
Глава 16 "Робота зі списками", пояснює в деталях списки, що, можливо, найбільш загально уживані структури даних в програмах Scala.
</p>
</li>
<li>
<p>
Глава 17 "Робота з іншими колекціями", показує вам, як використовувати базові колекції Scala, такі як списки, масиси, кортежі, множини та мапи.
</p>
</li>
<li>
<p>
Глава 18 "Змінні об'єкти", пояснює змінні об'єкти, та синтаксис, що провадить Scala для їх вираження. Глава завершується практичним заняттям на симуляцію дискретних подій, що показує деякі змінні об'єкти в дії.
</p>
</li>
<li>
<p>
Глава 19 "Типова параметризація", пояснює деякі з прийомів для приховування інформації, введеної в Главі 13 з допомогою конкретного прикладу: розробкою класу для чисто функціональних черг. Глава будується до визначення варіантності типових параметрів, та як це взаємодіє з приховуванням інформації.
</p>
</li>
<li>
<p>
Глава 20 "Абстрактні члени", описує всі типи абстрактних членів, як підтримує Scala; не тільки методи, але також поля та типи, можуть бути декларовані як абстрактні.
</p>
</li>
<li>
<p>
Глава 21 "Неявні переткорення та параметри", розкриває дві конструкції, що можуть допомогти вам оминути нудних деталей джерельного коду, та дозволяючи компілятору надати їх замість цього.
</p>
</li>
<li>
<p>
Глава 22 "Реалізація списків", описує реалізацію класу List. Важливо розуміти, як списки роблять в Scala, і більше того, реалізація демонструє використання деяких можливостей Scala.
</p>
</li>
<li>
<p>
Глава 23 "Переосмислені вирази for", показує як вирази for транслюються на виклики map, flatMap, filter та foreach.
</p>
</li>
<li>
<p>
Глава 24 "Колекції поглиблено", Надає детальний тур по бібліотеці колекцій.
</p>
</li>
<li>
<p>
Глава 25 "Архитектура колекцій Scala", показує як побудована бібліотека колекцій, та як ви можете реалізувати свої власні колекції.
</p>
</li>
<li>
<p>
Глава 26 "Екстрактори", показує, як робити співпадіння шаблонів з довільними класами, не тільки з кейс класами.
</p>
</li>
<li>
<p>
Глава 27 "Анотації", показує, як робити з розширенням мови через анотації. Глава описує декілька стандартних анотацій, та показує, як робити ваші власні.
</p>
</li>
<li>
<p>
Глава 28 "Робота з XML", пояснює, як обробляти XML в Scala. Глава показує вам ідіоми генерації XML, його розбір, та обробку, коли він вже розібраний.
</p>
</li>
<li>
<p>
Глава 29 "Модулярне програмування з використанням об'єктів", показує, як ви можете використовувати об'єкти Scala як модульну систему.
</p>
</li>
<li>
<p>
Глава 30 "Еквівалентність об'єктів", вказує на деякі проблеми, які треба розглядати, коли пишете метод <code>equals</code>. Є декільки ловушок, що треба уникнути.
</p>
</li>
<li>
<p>
Глава 31 "Комбінація Scala та Java", обговорює проблеми, що постають, коли комбінуєте Scala та Java разом в одному проекті, та рекомендовані методи щодо їх подолання.
</p>
</li>
<li>
<p>
Глава 32 "Ф'ючерси та конкурентність", показує вам, як використовувати Scala Future. Хоча ви можете використовувати примітиви конкуренції платформи Java для Scala програм, ф'ючерси можуть допомогти вам уникнути мертвого блокування та стану гонок, що зачумлюють традиційний підхід "потоки та блокування" до конкуренції.
</p>
</li>
<li>
<p>
Глава 33 "Комбінаторний розібр", показує, як побудувати парсери з використанням бібліотеки Scala парсерних комбінаторів.
</p>
</li>
<li>
<p>
Глава 34 "Програмування користувацького інтерфейсу", надає швидкий тур бібліотеки Scala, що спрощує програмування GUI за допомогою Swing.
</p>
</li>
<li>
<p>
Глава 35 "Електронна таблиця SCells", зв'язує все разом, показуючи повне застосування електронної таблиці, написане на Scala.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="__4">Ресурси</h3>
<div class="paragraph"><p>На <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>, головному веб ресурсі для Scala, ви знайдете останній реліз Scala та посилання на документацію та ресурси спільноти. Для більш стиснутої сторінки з посиланнями навідайтесь на сайт книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>. Щоб поспілкуватись з іншими читачами цієї книжки, перевірте форум Programming in Scala Forum,
за адресою: <a href="http://www.artima.com/forums/forum.jsp?forum=282">http://www.artima.com/forums/forum.jsp?forum=282</a>.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Джерельний код</h3>
<div class="paragraph"><p>Ви можете завантажити ZIP файл, що містить джерельний код цієї книги, що випущений пді відкритою ліцензією Apache 2.0, с зайта книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>.</p></div>
</div>
<div class="sect2">
<h3 id="__5">Помилки</h3>
<div class="paragraph"><p>Хоча ця книжки була щільно переглянута та перевірена, помилки всеж-таки неодмінно будуть прослизати. Для (надіємось, короткого) списку помилок друку для цієї книжки навідайтесь на <a href="http://booksites.artima.com/programming_in_scala_3ed/errata">http://booksites.artima.com/programming_in_scala_3ed/errata</a>. Якщо ви знайшли помилку, будь ласка повідомьте про неї за носиланням нижче URL, так що ми виправимо її при наступному друці або виданні цієї книжки.
:ascii-ids:
:doctype: book
:source-highlighter: pygments</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__1">Глава 1</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___4">Маштабована мова</h1>
<div class="paragraph"><p>Ім'я Scala означає "scalable language", тобто маштабована мова. Мова названа так, оскільки вона була розроблена зростати разом з потребами своїх користувачів. Ви можете застосувати Scala до широкого диапазону програмних завдань, від написання невеликіх скриптів, до побудови великих систем.<span class="footnote"><br />[Scala вимовляється skah-lah.]<br /></span></p></div>
<div class="paragraph"><p>До Scala легко дістатись. Вона працює на стандартній Java платформі, та без проблем взаємодіє з усіма бібліотеками Java. Це досить гарна мова для напсання скриптів, що стягають разом Java компоненти. Але вона може застосувати свою потужність навіть більше для побудови великих систем та фреймворків реюзабельних компонент.</p></div>
<div class="paragraph"><p>Технічно Scala є сумішшю об'єктно-орієнтованих та функціональних програмних концепцій в статично типізованій мові. Зплав об'єктно-орієнтовного та функціонального програмування виявляється в багатьох різних аспектах Scala; воно, можливо, більш проникаюче, ніж в любій іншій широко уживаній мові. Два стилі програмування мають доповнюючі сильні сторони, коли доходить до маштабованості. Функціональні програмні конструкції Scala роблять простим будувати цікаві речі швидко, з простих частин. Її об'єктно-орієнтовні конструкції спрощують структурувати більші системи, та адаптувати їх до нових вимог. Комбінація двох стилів в Scala робить можливим виражати нові типи програмних шаблонів та компонентних абстракцій. Це також призводить до виразного та стислого стилю програмування. Та оскільки вона така піддатлива, програмування на Scala може бути дуже втішним.</p></div>
<div class="paragraph"><p>Ця початкова глава відповідає на запитання "чому Scala?". Вона дає високорівневий погляд на дизайн Scala та міркування позаду неї. Після читання глави ви повинні мати базове відчуття того, що таке є Scala, та які типи задач вона може допомогти виконати. Хоча ця книжка є туторіалом в Scala, ця глава насправді не є частиною туторіала. Якщо вам нетерпляче хочеться почати писати деякий Scala код, вам слідує перестрибнути далі до Глави 2.</p></div>
<div class="sect1">
<h2 id="_1_1______">1.1 Мова, що зростає разом з вами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Програми різного розміру схильні потребувати різних програмних конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця програма встановлює мапу з країн та їх столиць, модифікує мапу, додаючи нову прив'язку ("Japan" &#8594; "Tokyo"), та друкує столицю, що асоційована з країною France.<span class="footnote"><br />[Будь ласка, слідуйте за нами, якщо ви не розумієте всі деталі цієї програми. Вони будуть пояснені в наступних двох главах.]<br /></span> Нотація в цьому прикладі високорівнева, до діла, та не захаращена зайвими крапками з комою або анотаціями типів. Дійсно, відчувається що це сучасна "скриптова" мова, Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що має відношення до приклада вище, в тому, що всі вони підтримують конструкцію "асоціативної мапи" в синтаксисі мови.</p></div>
<div class="paragraph"><p>Асоциативні мапи дуже корисні, оскільки вони дозволяють утримувати програми чіткими та лаконічними, але іноді ви можете не погодитись з їх філософією "один розмір підходить всім", оскільки вам треба контролювати властивості мап, які ви використовуваєте в вашій програмі, в більше гарно-контрольований спосіб. Scala надає вам цей гарний контроль, якщо ви потребуєте його, оскільки мапи в Scala не є синтаксисом мови. Вони є бібліотечними абстракціями, які ви можете розширити та адаптувати.</p></div>
<div class="paragraph"><p>В програмі вище ви отримали реалізацію Map по замовчанню, але ви можете легко змінити це. Ви можете, наприклад, вказати окрему реалізацію, таку як HashMap або TreeMap, або визвати метод <code>par</code> що отримати <code>ParMap</code>, що виконує операції паралельно. Ви можете вказати значення по замовчанню для мапи, або ви можете переписати любий інший метод мапи, яку ви створюєте. В кожному випадку, ви можете використовувати той самий простий синтаксис доступу для мап, що і в прикладі вище.</p></div>
<div class="paragraph"><p>Цей приклад показує, що Scala дати вам обоє, зручність та гнучкість. Scala має набір зручних конструкцій, що допомагають вам стартовати швидко, та дозволяють вам програмувати в приємно стислому стилі. В той же час, ви маєте впевненість, що ви не переростете мову. Ви завжди можете підкроїти програму до ваших потреб, оскільки все базується на бібліотечних модулях, які ви можете обрати та адаптувати, якщо треба.</p></div>
<div class="sect2">
<h3 id="___">Вирощування нових типів</h3>
<div class="paragraph"><p>Eric Raymond ввів собор та базар як дві метафори софтверної розробки.<span class="footnote"><br />[Raymond, The Cathedral and the Bazaar. [Ray99]]<br /></span> Собор майже досконала будівля, що займає довгий час доки збудується. Коли вже побудований, він стоїть незмінний довгий час. На відміну від цього базар адаптується та розширюється кожного дня, людьми, що роблять на ньому. В роботі Raymond базар є метафорою розробки програм з відкритим кодом. Guy Steele зауважив в розмові про "зростаючу мову", що ту саму різницю можна застосувати до дизайна мови.<span class="footnote"><br />[Steele, Growing a language. [Ste99]]<br /></span> Scala є значно більше базаром, ніж собором, в сміслі, що вона розроблена бути розширеною та адаптованою людьми, що програмують на ній. Заміть провадити всі конструкції, що можуть будь-коли вам знадобитись в "досконало повній мові", Scala покладає в ваші руки інструменти для побудови таких конструкцій.</p></div>
<div class="paragraph"><p>Ось приклад. Багато застосувань потребують тип цілих, що може стати довільно великим без переповнення або "циклічного переносу" арифметичних операцій. Scala визначає такий тип в бібліотечному класі scala.BigInt. Ось визначення метода, що використовує цей тип, що обчислює факторіал переданого цілого значення:<span class="footnote"><br />[factorial(x), або в математичній нотації x!, є результатом обчислення 1 * 2 * &#8230; * x, де 0! визначене як 1.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ми викличемо <code>factorial(30)</code>, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">265252859812191058636308480000000</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt виглядає як вбудований тип, оскільки ви можете використовувати цілі літерали та оператори, як * та - зі значеннями цього типу. Але це все ще клас, що визначений в стандартній бібліотеці.<span class="footnote"><br />[Scala іде зі стандартною бібліотекою, дещо з якої буде показане в цій книжці. Для додаткової інформації ви можете звернутись до документації Scaladoc по бібліотеці, що доступна в дистрибутиві та онлайн <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>.]<br /></span> Якщо клас був би відсутній, було б прямолінійним для кожного програміста Scala написати реалізацію, наприклад, через огортання Java класу java.math.BigInteger (фактично, саме так реалізований клас Scala).</p></div>
<div class="paragraph"><p>Звичайно, ви можете використовувати клас Java напряму. Але результат і близько не такий приємний, бо хоча Java дозволяє вам створювати нові типи, ці типи не дуже виглядають як природна підтримка мови:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.math.BigInteger</span>
<span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInteger</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInteger</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ZERO</span><span class="o">)</span>
    <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span>
  <span class="k">else</span>
    <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">subtract</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt є представником багатьох інших число-подібних типів - великих десятичних, комплексних чисел, раціональних чисел, довірчих інтервалів, поліноміалів - список продовжується. Деякі мови програмування реалізують деяки з ціх типів природно. Наприклад, Lisp, Haskell та Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але кожна мова, що намагається реалізувати всі з ціх абструкцій одночасно, просто стане дуже великою, щоб бути керованою. Що ще більше, навіть якщо б така мова могла б існувати, деякі застосування напевно могли б отримати переваги від інших число-подібних типів, що не були включені. Так що спроба запровадити все в одній мові маштабується не дуже добре. Замість цього Scala дозволяє користувачам вирощувати та адаптувати мову в напрямках, які ї потрібні, визначаючи прості-в-використанні бібліотеки, що виглядають як природна підтримка мови.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Вирощування нових керуючих структур</h3>
<div class="paragraph"><p>Попередній приклад демонструє, що Scala дозвляє вам додавати нові типи, що можуть бути такі ж зручні в використанні, що і вбудовані типи. Той же принцип розширення також стосується до керуючих структур. Цей різновид розширюваності ілюстрований Akka, Scala API до "актор-базованого" конкурентного програмування.</p></div>
<div class="paragraph"><p>По мірі того, як багатоядерні процесори будуть продовжувати розмножуватись в наступні роки, досягнення прийнятної продуктивності може підвищувати потребу, щоб ви використовували більше парлелизма в ваших програмах. Часто це буде означати переписування вашого коду, так, щоб розподілити обчислення між декількома конкурентними потоками. Нажаль, створення надійних багатопоточних застосувань доведено складна задача на практиці. Модель поточності Java побудована навколо загальної пам'яті та блокування, модель, яку часто складно промислити, особливо коли система зростає в розмірі та складності. Складно бути впевненим, що ви не маєте стану гонок або мертвого блокування, що десь причаїлись — дещо, що не проявилось під час тестування, але може проявитись під час використатння. Як можливо безпечніша альтернатива є архитектура передачі повідомлень, така, як підхід "акторів", використаний в мові програмування Erlang.</p></div>
<div class="paragraph"><p>Java іде з багатою, основаною на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, так само, як любе інше Java API. Однак існує Akka, що є додатковою бібліотекою Scala, яка реалізує модель акторів, подібних то таких в Erlang.</p></div>
<div class="paragraph"><p>Актори є абстракцією конкурентності, що може бути реалізвана поверху потоків. Вони комунікують через надсилання повідомлень один одному. Актор може виконувати дві базові операції, надсилання та отримання повідомлення. Операція <code>send</code>, позначена знаком наголосу(!), надсилає повідомлення актору. Ось приклад, в якому актор називається <code>recipient</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>recipient ! msg</code></pre>
</div></div>
<div class="paragraph"><p>Надсилання асинхронне; тобто, надсилаючий актор може продовжувати безпосередньо, без очікування щоб повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, в якому накопичуються повідомлення. Актор обробляє повідомлення, що надійшли в поштову скриньку через блок <code>receive</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Msg1</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg1</span>
  <span class="k">case</span> <span class="nc">Msg2</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg2</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Блок <code>receive</code> складається з декількох <code>case</code>, кожний з яких опитує поштову скриньку за шаблоном повідомлення. Перше повідомлення в скриньці, що співпаде з любим <code>case</code>, буде обране, та для нього виконується відповідна дія. Як тільки скринька більше не містить повідомлень, актор призупиняється, та очікує подальших входящих повідомлень.</p></div>
<div class="paragraph"><p>Як приклад, ось простий актор Akka, що реалізує сервіс калькулятора контрольних сум:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Data</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">byte</span>
    <span class="k">case</span> <span class="nc">GetChecksum</span><span class="o">(</span><span class="n">requester</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">checksum</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">requester</span> <span class="o">!</span> <span class="n">checksum</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зпочатку цей актор визначає локальну змінну на ім'я <code>sum</code> з початковим значенням нуль. Далі він визначає блок <code>receive</code>, що буде обробляти повідомлення. Якщо він отримає повідомлення Data, він додає збережений байт до змінної <code>sum</code>. Якщо отримано повідомлення GetChecksum, актор обчислює контрольну суму для поточного значення <code>sum</code>, та надсилає результат назад до запитувача, використовуючи надсилання повідомлення <code>requester ! sum</code>. Поле <code>requester</code> вбудоване в повідомлення GetChecksum; воно звичайно посилається актора, що зробив запит.</p></div>
<div class="paragraph"><p>Ми не очікуємо, що ви повністю розумієте приклад з актором на цей момент. Скоріше, що важливе щодо цього прикладу в плані маштабованості, це те, що ані блок <code>receive</code>, ані повідомлення <code>send</code> (!) не є вбудовані операції в Scala. Навіть вважаючи, що блок <code>receive</code> може виглядати та діяти дуже подібними до вбудованих керівних конструкцій, фактично це метод, визначений в бібліотеці акторів Akka. Подібно до цього, навіть вважаючи, що <em>!</em> виглядає як вбудований оператор, він також є тільки методом, визначеним в бібліотеці акторів Akka. Обоє з ціх конструкцій повністю незалежні від мови програмування Scala.</p></div>
<div class="paragraph"><p>Синтаксис блоку <code>receive</code> та <code>send</code> (!) вигладає в Scala здебільшого як вони виглядають в Erlang, але в Erlang ці конструкції вбудовані в мову. Akka також реалізує більшість з інших конкурентних програмних конструкцій Erlang, таких, як моніторинг схибивших акторів та тайм-аути. Кінець кінцем, модель акторів виявилась дуже приємним засобом для вираження конкурентних та розподілених обчислень. Навіть якщо вони визначені в біблиотеці, актори можуть відчуватись як інтегральна частина мови Scala.</p></div>
<div class="paragraph"><p>Цей приклад ілюструє, як ви можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Звичайно, вам знадобляться гарні архітектори та програмісти, щоб зробити це. Але вирішальна річ в тому, що це можливо — ви можете розробляти та реалізувати абстракції в Scala, що адресують радикально нові галузі застосування, та все ще відчувати це як природну підтримку мови при використанні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_2___scala_">1.2 Що робить Scala маштабованою?</h2>
<div class="sectionbody">
<div class="paragraph"><p>На маштабованість впливає багато факторів, в диапазоні від синтаксичних деталей до абстрактних конструкцій компонент. Однак якщо б нам доводилось назвати тільки один аспект Scala, що допомагає маштабованості, ми б обрали комбінацію об'єктно-орієнтованого та функціонально програмування (гаразд, ми змахлювали, насправді це два аспекти, але вони пов'язані).</p></div>
<div class="paragraph"><p>Scala іде далі, ніж всі інші гарно-відомі мови в справі зплавлення об'єкто-орієнтовного та функціонального програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції як дві окремі концепції, в Scala значення функції є об'єктом. Функціональні типи є класами, що можуть наслідуватись субкласами. Це може виглядати нічим іншим, ніж академічними тонкощами, але це має глибокі наслідки для маштабованості. Фактично, показана раніше концепція актора не могла б бути реалізованою без цієї уніфікації функцій та об'єктів. Цей розділ дає огляд шляху Scala по змішуванню об'єктно-орієнтовної та функціональної концепцій.</p></div>
<div class="sect2">
<h3 id="_scala____">Scala є об'єктно-орієнтовна</h3>
<div class="paragraph"><p>Об'єктно-орієнтоване програмування було назвичайно успішним. Починаючи з Simula в середині 60х та Smalltalk в 70х, воно зараз доступне в більшій кількості мов, ніж навпаки. В деяких галузях об'єкти повністю перебрали все на себе. Хоча немає точного визначення того, що означає об'єкт-орієнтовне, але ясно, що це щось щодо об'єктів, що апелює до програмістів.</p></div>
<div class="paragraph"><p>В принципі, мотивація для об'єктно-орієнтовного програмування дуже проста: всі, крім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, це покласти дані та операції в деяку форму контейнерів. Чудова ідея об'єктно-орієнтовного програмування це зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як і дані, та що вони самі по собі є значеннями, що можуть зберігатись в інших контейнерах, або передані як параметри до операцій. Такі контейнери називаються об'єктами. Alan Kay, винахідник Smalltalk, зауважував, що в такий спосіб найпростіший об'єкт має ті самі принципи конструкції, що і цілий компьп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом.<span class="footnote"><br />[Kay, "The Early History of Smalltalk." [Kay96]]<br /></span> Так що об'єкти мають багато чого докласти до маштабованості мови: та сама технологія застосовується до конструкції малих, так само як і до великих програм.</p></div>
<div class="paragraph"><p>Навіть якщо об'єктно-орієнтоване програмування було мейнстримом протягом довгого часу, є відносно мало мов, що послідували за Smalltalk в протисканні цього конструктивного принипу до його логічного висновку. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні значення в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтовного програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнюівати речі, та обмежувати маштабованість.</p></div>
<div class="paragraph"><p>Для контрасту Scala є об'єктно-орієнтовною мовою в чистій формі: кожне значення є об'єктом, та кожна операція є викликом метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви насправді викликаєте метод на ім'я + , визначений в класі Int. Ви можете визначити методи з оператор-подібними назвами, які потім клієнти вашого API використовують для використання в операторній нотації. Ось як розробник Akka API акторів дозволив вам використовувати вирази, такі як <code>requester ! sum</code>, показані в попередньому прикладі: ! є методом класу Actor.</p></div>
<div class="paragraph"><p>Scala є більш досвідченою, ніж багато інших мови, коли йдеться про композицію об'єктів. Прикладом є трейти Scala. Трейти подібні до інтерфейсів в Java, але вони також можуть мати реалізації методів, та навіть поля.<span class="footnote"><br />[Починаючи з Java 8, інтерфейси можуть мати реалізації методів по замовчанню, але вони не надають всі можливості трейтів Scala.]<br /></span> Об'єкти конструюються через композицію міксінів, що бере методи класу, та додає до них члени декількох трейтів. В цей спосіб різні аспекти класів можуть бути інкапсульовані в різні трейти. Це виглядає трохи схожим на множинне наслідування, але відрізняється, коли річ доходить до деталей. Це робить трейти більш "плагабельними", ніж класи. Зокрема, вони уникають класичних проблем "діамантового наслідування" множинних інтерфейсів, що виникає, коли деякий клас наслідується через декілька різних шляхів.</p></div>
</div>
<div class="sect2">
<h3 id="_scala__">Scala є функціональною</h3>
<div class="paragraph"><p>На додаток до того, що вона є чистою об'єктно-орієнтовною мовою, Scala також є повно-функціональною функціональною мовою. Ці ідеі функціонального програмування старіші ніж (електронні) комп'ютері. Їх основи були покладені в лямбда обчисленні Alonzo Church, що було розроблене в 1930х. Першою функціональною мовою був Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. Протягом довгого часу функціональне програмування було дещо на узбіччі — популярне в академічних колах, але не так широко використане в індустрії. Однак в останні роки намітилась зростаюча зацікавленість в функціональному програмуванні та технологіях.</p></div>
<div class="paragraph"><p>Функціональне програмування направляється двома головними ідеями. Перша ідея в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з тим самим статусом, що і, скажімо, ціле або рядок. Ви можете передати функції як аргументи в інші функції, повернути їх як результат з функції, або зберігати їх в змінних. Ви також можете визначити функцію всередині іншої функції, так само, як ви можете визначити ціле значення всередині функції. Та ви можете визначити функції без надання їм імен, скрапляючи ваш код функціональними літералами так просто, як ви можете записати цілий літерал, як 42.</p></div>
<div class="paragraph"><p>Функції, що є першокласними значеннями, провадять зручні засоби для абстрагування над операціями, та створення нових керівних структур. Це узагальнення функцій провадить чудову виразність, що часто призводить до дуже виразних та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, бібліотека тестування ScalaTest пропонує конструкцію <code>eventually</code>, що приймає функцію як аргумент. Це використовується приблизно так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">iterator</span>
<span class="n">eventually</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="n">shouldBe</span> <span class="mi">3</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Код всередині <code>eventually</code> — твердження, <code>it.next() shouldBe 3</code> — огорнуте в функцію, що передається без виконання до метода <code>eventually</code>. Для сконфігурованого проміжку часу, <code>eventually</code> буде виконувати функцію, доки буде виконуватись твердження.</p></div>
<div class="paragraph"><p>В більшості традиційних мов, для контрасту, функції не є значеннями. Мови, що є значення функцій, часто відсувають їх на другій план. Наприклад, указателі на функції в C та C++ не мають того самого статусу, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись тільки на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення в своєму оточенні. Також вони не дозволяють визначати неіменовані функціональні літерали.</p></div>
<div class="paragraph"><p>Друга головна ідея функціонального програмування в тому, що операції програми мають відзеркалювати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці.  Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масив символів. Символи в рядку можуть бути змінені індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку на кому, всередині того самого об'єкта рядка. В Java та Scala, з іншого боку, рядок є послідовність символі в математичному сенсі. Заміна символа в рядку, використовуючи вираз як s.replace(";","."), повертає новий об'єкт рядка, що є іншим від s. Інший шлях виразити те саме, це сказати, що рядкі незмінні в Java, тоді як вони змінні в Ruby. Так що з погляду тільки на рядки, Java є функціональною мовою, тоді як Ruby ні. Незмінні структури даних є один з наріжних каменів функціонального програмування. Бібліотеки Scala визначають значно більше незмінних типів даних, крім тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, тапли, мапи та множини.</p></div>
<div class="paragraph"><p>Інший шлях затвердити цю другу ідею функціонального програмування є те, що методам не слідує мати любі побічні ефекти. Вони мають комунікувати зі своїм оточенням тільки через прийняття аргументів, та повернення результатів. Наприклад, метод <code>replace</code> в класі Java String підходить під цей опис. Він приймає рядок та два символи, та видає новий рядок, де всі появлення одного символа замінюється на інший. Немає іншого ефекту виклику <code>replace</code>. Методи як <code>replace</code> називаються референційно прозорими, що означає, що для кожного взятого вводу виклик методу може бути замінений на свій результат, без впливу на семантику програми.</p></div>
<div class="paragraph"><p>Функціональні мови заохочують незмінні структури даних та референсно прозорі методи. Деякі функціональні мови навіть вимагають їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є назвою для програмування зі змінними даними та побічними ефектами. Але Scala загалом робить простим уникати імперативних конструкцій, коли ви бажаєте цього, бо існують гарні функціональні альтернативи.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_3__scala">1.3 Чому Scala?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Чи Scala для вас? Вам доведеться зрозуміти та прийняти рішення самостійно. Ми винайшли, що насправді багато причин, крім маштабованості, щоб програмувати на Scala. В цьому розділі будуть розглянуті чотири з найбільш важливих аспектів: сумісність, краткість, високорівневі абстракції та розвинена статична типізація.</p></div>
<div class="sect2">
<h3 id="_scala___2">Scala є сумісною</h3>
<div class="paragraph"><p>Scala не потребує, щоб ви зістрибували назад з платформи Java, щоб зробити крок вперед від мови Java. Вона дозволяє вам додати вартість до існуючого коду — щоб будувати на тому, що вже маєте, оскільки вона була розроблена для безшовної взаємодії з Java.<span class="footnote"><br />[Зпочатку була реалізація Scala, що робила на платформі .NET, але вона більше не активна. Останнім часом все більше популярною стає реалізація Scala, що робить на JavaScript, Scala.js.]<br /></span> Програми Scala компілюються на байткоди JVM. Її продуктивність часу виконання звичано співпадає з Java програмами. Код Scala може викликати методи Java, отримувати доступ до полів Java, наслідувати від Java класів, та реалізувати Java інтерфейси. Ніщо з цього не потребує спеціального синтаксису, явного визначення інтерфейсів, або зклеючого коду. Фактично, весь код Scala дуже тяжко використовує Java бібліотеки, часто без того, щоб програміст переймався цім фактом.</p></div>
<div class="paragraph"><p>Інший аспект повної взаємодії є те, що Scala потужно пере-використовує типи Java. Scala <code>Int</code> представлений як примітивне ціле Java типу <code>int</code>, <code>Float</code> представлені як <code>float</code>, <code>Boolean</code> як <code>boolean</code>, і так далі. Масиви Scala відображуються на масиві Java. Scala також пере-використовує багато зі стандартних бібліотечних типів Java. Наприклад, тип рядкового літерала "abc" в Scala є <code>java.lang.String</code>, та підійняті виключення мають бути субкласом <code>java.lang.Throwable</code>.</p></div>
<div class="paragraph"><p>Scala не тільки пере-використовує Java типи, але також "принаряджує" їх, щоб зробити їх кращими. Наприклад, методи підтримки рядків в Scala, як <code>toInt</code> або <code>toFloat</code>, що конвертують рядок на ціле або на число з плаваючою крапкою. Так що ви можете писати <code>str.toInt</code> замість <code>Integer.parseInt(str)</code>. Як це може бути досягнуте без руйнування сумісності? Клас Java String напевне не має метода <code>toInt</code>! Фактично, Scala має дуже загальне рішення для вирішення цього тертя між розширеним дизайном бібліотек, та взаємодією. Scala дозволяє вам вирішити неявні перетворення, що завжди застосовуються, коли типи не будуть звичайно співпадати, або коли обираються неіснуючі члени. В випадку вище, коли шукається метод <code>toInt</code> для рядка, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String на примірник класу Scala StringOps, що визначає такий член. Це перетворення буде потім неявно застосоване перед виконанням операції <code>toInt</code>. Код Scala також може викликатись з кода Java. Іноді це більш тонка матерія, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш розвинених можливостей Scala мають бути закодовані, перед тим, як іх можна буде відобразити на Java. Глава 31 пояснює деталі.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___3">Scala є стислою</h3>
<div class="paragraph"><p>Програми Scala мають схильність бути короткими. Програмісти на Scala повідомляють зменшення числа рядків до десяти раз, порівняно з Java. Це може бути екстремальним випадком. Більш консервативне очікування може бути таким: типова Scala програма має бути приблизно в половину довжини за числом рядків, до такої самої програми, написаної на Java. Меньше рядків коду означає не тільки менше друку, але також менше зусиль по читанню та розумінню програм, та менші можливості для дефектів. Існують різні фактори, що докладаються до цього зменшення рядків коду.</p></div>
<div class="paragraph"><p>Перше, синтаксис Scala уникає деяких шаблонів, що обтяжують Java програми. Наприклад, крапка з комою є опціональною в Scala, та звичано відкидається. Також є декілька інших площин, де синтаксис Scala менш шумлячий. Як приклад, порівняйте, як ви пишете класи та конструктори в Java та Scala. В Java клас з конструктором часто виглядає подібно до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// це Java</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala ви скоріше всього замість цього напишете таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код компілятор Scala спродукує клас, що має дві приватні змінні примірника, <code>Int</code> на ім'я <code>index</code> та <code>String</code> на ім'я <code>name</code>, та конструктор, що приймає первинні значення для ціх змінних в якості параметрів. Код цього конструктора буде ініціалізувати дві змінні примірника значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча Java версія.<span class="footnote"><br />[Єдина реальна різниця в тому, що змінні примірника, вироблені в випадку Scala, будуть фінальні. Ви навчитесь, як робити їх не-фінальними в Розділі 10.6.]<br /></span> Клас Scala швидше писати, протіше читати, та більш важливо - менше схильний до помилок, ніж Java клас.</p></div>
<div class="paragraph"><p>Вивід типів Scala є іншим фактором, що докладається до її стислості. Повторювана інформація інйормація про типи може бути відкинута, так що програми стають менш захащені та більш читабельні.</p></div>
<div class="paragraph"><p>Але, можливо, найбільш важливим ключем до компактного коду є код, що ви не маєте писати, бо він вже зроблений в бібліотеці за вас. Scala надає вам інструменти для визначення потужних бібліотек, що дають вам захопити та виділити загальну поведінку. Наприклад, різні аспекти класів бібліотеки можуть бути виділені в трейти, що можуть потім бути зміксовані разом в гнучкий спосіб. Або методи бібліотеки можуть бути параметризовані за допомогою операцій, що дозволяє вам визначати конструкції, які ефективно є вашими власними керівними структурами. Разом ці конструкції дозволяють визначення бібліотек, що одночасно високорівневі та гнучки в використанні.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___4">Scala є високорівневою</h3>
<div class="paragraph"><p>Програмісти постійно борються зі складністю. Щоб програмувати продуктивно, ви маєте розуміти код, з яким ви робите. Надскладний код був причиною падіння багатьох софтверних проектів. Нажаль, важливі програми звичано мають складні вимоги. Такої складності неможливо уникнути; замість цього єю треба керувати.</p></div>
<div class="paragraph"><p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракції в інтерфейсах, що ви розробляєте і якими користуєтесь. Як приклад, уявіть, що ви маєте змінну <code>String name</code>, та ви бажаєте визначити, чи містить цей рядок символи в великому реєстрі. До Java 8 ви могли написати такий цикл:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// this is Java</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
         <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
         <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як в Scala ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">nameHasUpperCase</span> <span class="k">=</span> <span class="n">name</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Код Java сприймає рядки як низьковірневі сутнсті, по яких можна крокувати символ за символом в циклі. Код Scala сприймає той самий рядок як високорівневу послідовність символів, до якої можливо робити запити за допомогою предикатів. Зрозуміло, що код Scala значно коротший, та — для тренованого ока — простіший для розуміння, ніж Java код. Так що код Scala менше заважує до загального бюджету складності. Він також дає вам менше можливостей робити помилки.</p></div>
<div class="paragraph"><p>Предикат _.isUpper є прикладом функціонального літералу в Scala.<span class="footnote"><br />[Функціональні літерали можуть бути названі предикатами, якщо тип їх результату Boolean.]<br /></span> Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи це символ верхнього реєстра.<span class="footnote"><br />[Це використання підкреслення як заповнювача для аргументів описане в Розділі 8.5.]<br /></span></p></div>
<div class="paragraph"><p>Java 8 вводить підтримку для лямбда та потоків, що дозволяє вам виконувати подібну операцію в Java. Ось як це може виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span>
<span class="c1">// це Java 8</span>
<span class="n">name</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">anyMatch</span><span class="o">(</span>
    <span class="o">(</span><span class="kt">int</span> <span class="n">ch</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">ch</span><span class="o">)</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це велике покращення над ранішніми версіями Java, код Java 8 все ще більше балакучий, ніж еквівалентний код Scala. Ця додаткова "важкість" Java коду, так само, як довгі традиції циклів Java, можуть заохотити багатьох Java програмістів за браком нових методів, як <code>exists</code>, просто писати цикли, та жити з підвищеною складністю їх кода.</p></div>
<div class="paragraph"><p>З іншого боку, функціональні літерали в Scala насправді легковажні, так що вони використовуютсья часто. Коли ви знатимете Scala краще, ви будете знаходити більше і більше можливостей для визначення та використання ваших власних керівних абстракцій. Ви побачите, що це допомагає уникати дублікації коду, і, таким чином, утримують ваш код коротним та чистішим.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування Scala також пропонує високорівневі принципи розмірковувати про програмування. Ключова ідея в тому, що ці функції є референтно прозорими — застосування функції характеризується тільки її результатом. Таким чином ви можете вільно замінити застосування функції на праву сторону функції (тобто тіло, що слідує за знаком рівняння), не турбуючись щодо жодних побічних ефектів. Цей принцип надає багато корисних законів, які ви можете задіяти для кращого розуміння або для рефакторинга вашого коду. Як приклад, ще раз візьмемо метод <code>exists</code>, описаний вище. Цей метод має задовільняти наступному правилу: для кожної послідовності <code>s</code>, та для кожної пари предикатів <code>p</code> та <code>q</code> має виконуватись таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">q</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">||</span> <span class="n">q</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, опитуючи ту саму послідовність двома предикатами p та q, та роблячи АБО з результатами є те саме, що перевірити один предикат, що одночасно перевіряє на p або q. Правило, подібне до цього, вочевідь корисне для написання та рефакторингу програм. Однак, якщо <code>exists</code> має побічні ефекти, загалом не буде коректно припускати існування такого закону, оскільки ліва частина виконує <code>exists</code> двічі для кожного елемента послідовності, тоді як права частина виконується тільки один раз для кожного елементу. Так що це є прикладом, коли чисто функціональний код призводить до додаткових правил, і корисний для розуміння та рефакторингу вашого коду.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування також прибирає проблеми накладання, що трапляються в імперативному програмуванні. Накладання трапляється, коли декілька змінних посилаються на той самий об'єкт. Це підіймає деякі тернисті запитання та ускладнення. Наприклад, чи зміна поля <code>r.x</code> також впливатиме на <code>s.x</code>? Це відбуватиметься, якщо <code>r</code> та <code>s</code> посилаються на той самий об'єкт. На практиці дуже складно відслідити такі накладання. З іншого боку, незмінні правила можуть вільно поділятись, оскільки копія не відрізняється від загального посилання. Ця перевага є практично ключовою, коли ви пишете конкурентний код. (Ось чому Java має незмінні рядки).</p></div>
</div>
<div class="sect2">
<h3 id="_scala___5">Scala статично типізована</h3>
<div class="paragraph"><p>Статичні системи типів класифікують змінні та вирази відповідно до властивостей значень, що вони зберігають на обчислюють. Scala виділяється як мова з дуже розширеною статичною системою типів. Починаючи від системи типів вкладених класів, подібних до Java, вона дозволяє вам параметризувати типи за допомогою дженериків, комбінувати типи з використанням перетинів, та приховувати деталі типів з використанням абстрактних типів.<span class="footnote"><br />[Дженеріки обговорюються в Главі 19; перетини (тобто, A with B with C) в Главі 12; та абстрактні типи в Главі 20.]<br /></span> Це дає міцний фундамент для будівництва та компонування ваших власних типів, так що ви можете розробити інтерфейси, що одночасно безпечні, та гнучкі в використанні.</p></div>
<div class="paragraph"><p>Якщо вам подобаються динамічні мови, такі як Perl, Python, Ruby, або Groovy, ви можете винайти трохи дивним, що статична система типів Scala попала в перелік як одна з сильних сторін. Кінець кінцем, відсутність статичної системи типів наводиться як одна з головних переваг динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми над балакучими, заважають програмістам виражати себе так, як вони бажають, та роблять неможливим деякі шаблони динамічних модифікацій софтверних систем. Однак часто ці аргументи не ідуть проти самої ідеі статичних типів взагалі, але проти окремих систем типів, що сприймаються як дуже балакучі або негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись замітив: "Я не проти типів, але я не знаю жодної системи типів, що не є суцільною біллю, так що я все ще люблю динамічні типи".<span class="footnote"><br />[Kay, поштою щодо значення об'єктно-орієнтовного програмування. [Kay03]]<br /></span></p></div>
<div class="paragraph"><p>Ми надіємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільною біллю". Фактично, вона адресує дві звичайні турботи щодо статичної типізації: балакучість іникається через вивід типів, та гнучкість досягається через співпадіння шаблонів та декльіка нових шляхів писати та компонувати типи. Коли ці перешкоди прибрані з нашого шляху, класичні переваги статичних типів можуть бути краще помічені. Серед найбільш важливих з ціх переваг є перевіряємі властивості програмних абстракцій, безпечний рефакторинг, та краща документація.</p></div>
<div class="paragraph"><p><strong>Перевіряємі властивості.</strong> Статичні системи типів можуть забезпечити відсутність певних помилок часу виконання. Наприклад, вони можуть доказати такі властивості: <code>Boolean</code> не буде доданий до цілого; приватні змінні не отримують доступ поза меж класу; функції застосовуються до відповідного числа аргументів; тільки рядки будь-коли будуть додаватись до множини рядків.</p></div>
<div class="paragraph"><p>Інші відомі помилки не виявляються сьогоднішніми статичними системами типів. Наприклад, вони зазвичай не будуть не-терміновані функції, порушення меж масивів, або ділення на ноль. Вони також не детектують, що ваша програма не відповідає її специфікації (вважаємо що така специфікація є, саме так!). Статичні системи типів, мають бути звільнені, як не дуже корисні. Аргумент, що надається, що оскільки такі системи можуть виявляти тільки прості помилки, тоді як юніт тести провадять більш екстенсивне покриття, чому треба борсатись зі статичними типами взагалі? Ми впевнені, що ці аргументи позбавлені змісту. Хоча статичні системи типів напевне не можуть замінити юніт тести, вони можуть зменшити число потрібних юніт тестів, пілчкуючись про деякі властивості, для яких інакше знадобились би тести. Подібним чином, юніт тести не можуть замінити статичну типізацію. Кінець кінцем, як казав Edsger Dijkstra, тестування може тільки довести наявність присутності помилок, та ніколи їх відсутність.<span class="footnote"><br />[Dijkstra, "Notes on Structured Programming." [Dij70]]<br /></span> Так що гарантії, що надає статична типізація, може бути слабкою, але це реальні гарантії в формі, яку не може забезпечити ніяка кількість тестів.</p></div>
<div class="paragraph"><p><strong>Безпечний рефакторинг.</strong> Статичні системи типів провадять страховку, що дозволяє вам робити зміни в базі коду з високою мірою довіри. Розглянемо примірник рефакторингу, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто підігнати всі рядки, що видають помилку типу. Коли ви скінчите з цім, ви впевнені, що найшли всі місця, що треба змінити. Те саме вірно для багатьох інших випадків простого рефакторингу, як зміни імені методу, або переміщення методів з одного класу до іншого. В усіх ціх випадках перевірка статичного типу буде провадити досить акуратності, щоб нова система робила так само, як стара.</p></div>
<div class="paragraph"><p><strong>Документація.</strong> Статичні типи є документацією програми, що перевіряється компілятором на коректність. На відміну від звичайних коментарів, анотації типів ніколи не можуть застаріти (щонайменьше якощ файл коду, що містить їх, недавно проходив через компілятор). Більше того, компілятори і інтегровані середовища розробки (IDE) можуть використовувати анотації типів для провадження кращої контекстної підказки. Наприклад, IDE може відображувати всі члени, доступні для вибору, через визначення статичного типу виразу, на якому робиться вибір, та перегляд членів цього типу.</p></div>
<div class="paragraph"><p>Навіть хоча статичні типи загалом корисні для документації програми, вони можуть інколи бути надокучливі, коли вони захаращують програму. Типово, корисна документація - це те, що читачі програми не можуть просто вивести самі по собі. В визначенні метода як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>корисно знати, що аргумент має бути <code>String</code>. Або, з іншого боку, щонайменьше одна з двох анотацій в наступному прикладі є подразником:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
</pre></div></div></div>
<div class="paragraph"><p>Зрозуміло, що має бути достатньо сказати тільки один раз, що <code>x</code> є <code>HashMap</code> з <code>Int</code> в якості ключа, та <code>Strings</code> як значення; немає потреби повторювати ту саму фразу двічі. Scala має дуже складну систему виводу типів, що дозволяє вам оминати майже всю інформацію типів, що звичайно сприймається як надокучлива. В попередньому прикладі наступні дві менш дратливі альтернативи також будуть робити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>ВИвід типів в Scala може зайти досить далеко. Фактично, не є рідкістю для користувацького кода, взагалі не мати явних типів. Таким чином, програми Scala часто виглядають трохи як програми, написані на динамічно типізованій скриптоівій мові. Це вірно зокрема для кода клієнтськіх застосувань, що зліплюють разом попередньо написані бібліотечні компоненти. Це менш вірно для самих компонент бібліотек, оскільки вони часто вживають дуже складні типи, щоб забезпечити гнучкі шаблони застосування. Це просто природно. Кінець кінцем, сигнатури типів членів, що складають інтерфейс реюзабельного компонента, повинен бути наданий явно, оскільки вони складають основну частину контракту між компонентом та його клієнтами.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_4__scala">1.4 Корені Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Дизайн Scala бів під впливом багатьох мов програмування, та ідей в дослідженні програмних мов. Фактично, тільки декілька можливостей Scala чисто нові; більшість вже мали застосування в деякій формі в інших мовах. Інновація Scala в основному походить від того, як вона покладає ці конструкції разом. В цьому розділі ми перелічимо головні впливи на розробку Scala. Список не може бути вичерпним — існує дуже багато розумних ідей коло розробки мови програмування, щоб перелічити тут їх всі.</p></div>
<div class="paragraph"><p>На поверхневому рівні Scala адоптує значну частину синтаксиса Java та C#, що, в свою чергу, позичає більшість зі своїх синтаксичних домовленостей від C та C++. Вирази, твердження та блокі здебільшо як в Java, так само, як синтаксис класів, пакунків та імпортів.<span class="footnote"><br />[Головне відхидення від Java в плані синтаксису для анотацій типу, це "змінна: типу" замість "тип змінної" в Java. Постфіксний синтаксис типу в Scala копіює Pascal, Modula-2, або Eiffel. Головна причина для цього відхилення має відношення до виводу типів, що часто дозволяє вам оминути тип змінної або тип повернення метода. Використання синтаксису "змінна: типу" просте - тільки опустіть крапку з комою та тип. Але в C-style синтаксисі "тип змінної" ви не можете просто відкинути тип; більше намає маркера що почалась декларація. Вам знадобиться деяке альтернативне ключове слово, щоб бути заповнювачем для відсутнього типу (C# 3.0, що робить деякий вивід типів, використовує <code>var</code> для ціх цілей). Таке альтернативне ключове слово виглядає більш притягнутим, та менш регулярним, ніж підхід Scala.]<br /></span> Крім синтаксиса Scala адоптує багато інших елементів Java, такі як базові типи, її бібліотеки типів, та її модель виконання.</p></div>
<div class="paragraph"><p>Scala також заборгувала багатьом іншим мовам. Її уніформна об'єктна модель започаткована  Smalltalk, і згодом прийнята Ruby. Її ідея про універсальне вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, більш пізніше, в Beta та gbeta. Її принцип уніформного доступу для виклику методів та виборів полів надходить від Eiffel. Її підхід до функціонального програмування є дуже подібним до духу сім'ї мов ML, таких як SML, OCaml та F#, в якості видатних членів. Багато високорівневих функцій в стандартній бібліотеці Scala також присутні в ML або Haskell. Неявні параметри були мотивовані класами типів Haskell; вони досягли аналогічних результатів в більше класичной об'єктно-орієнтовному оточенні. Головна актор-базована бібліотека конкурентності, Akka, дуже надихалась Erlang.</p></div>
<div class="paragraph"><p>Scala не є першою мовою, що наголошує на маштабованості та розширюваності. Історичні корені розширюваної мови, що може перетинати різні області застосування, знаходяться в статті Peter Landin 1966го року,"The Next 700 Programming Languages."<span class="footnote"><br />[Landin, "The Next 700 Programming Languages." [Lan66]]<br /></span> (Мова, описана в цьому документі, Iswim, стоїть поряд з Lisp як один з першопроходців функціональних мов). Специфічна ідея трактувати інфіксний оператор як функцію можна прослідкувати до Iswim та Smalltalk. Інша важлива ідея є дозволити функціональні літерали (або блоки) в якості параметрів, що дозвоялє бібліотекам визначати керівні структури. Знову, це тягнеться назад до Iswim та Smalltalk. Smalltalk та Lisp обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх, домен-специфічних мов. C++ є іншою маштабованою мовою, що може бути адаптований та розширений через перевантаження операторів, та його систему шаблонів; порівняно зі Scala він побудований на ніжньому рівні, більш системно-орієнтовному ядрі. Scala також не є першою мовою, що інтегрує функціональне та об'єкт-орієнтовне програмування, хоча вона, можливо, зашла найбільш далеко в цьому напрямку. Інші мови, що інтегрували деякі елементи функціонального програмування в об'єкто-орієнтовне програмування (OOP) включають Ruby, Smalltalk та Python. На Java платформі, Pizza, Nice, Multi-Java — та сама Java 8  — мають розширене Java-подібне ядро з функціональними ідеями. Також існують здебільше функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F#, та PLT-Scheme.</p></div>
<div class="paragraph"><p>Scala також привнесла деякі інновації до поля мов програмування. Наприклад, її абстрактні типи провадять більше об'єктно-орієнтовної альтернативи до дженерік типів, її трейти дозволяють гнучкі збірки компонент, та її екстрактори провадять незалежний від представлення спосіб співпадіння шаблонів. Ці інновації були представлені в документах на конференціях з мов програмування в останні роки.<span class="footnote"><br />[Для додаткової інформації дивіться [Ode03], [Ode05], та [Emi07] в бібліографії.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_1_5_">1.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми дали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Напевне, Scala не є срібною кулею, що магічно зробить вас більш продуктивним. Щоб просуватись, вам знадобиться містецьки застосувати Scala, та це буде потребувати деякого навчання та практики. Якщо ви прийшли до Scala від Java, найбільш викличний аспект у вивченні Scala може включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книжки м'яко провести вас кривою навчання Scala, по кроку за раз. Ми вважаємо, що ви знайдете це корисним інтелектуальним досвідом, що розширить ваші горизонти, та змусить вас думати інакше щодо розробки програм. Надіємось, що ви також отримаєте задоволення та натхнення від програмуванн на Scala.</p></div>
<div class="paragraph"><p>В наступній главі ми почнемо з вами писати деякий Scala код.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2_2">Глава 2</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala">Перші кроки в Scala</h1>
<div class="paragraph"><p>Прийшов час написати деякий код на Scala. Перед тим, як ми почнемо заглиблений туторіал Scala, ми покладемо дві глави, що дасть нам більшу картину Scala, та більш важливо, дасть вам написати код. Ми закликаємо вас справді спробувати всі приклади коду, представлені в цій главі, та наступному, куди ми теж дійдемо. Простий шлях почати вивчати Scala, це програмувати на ній.</p></div>
<div class="paragraph"><p>Щоб виконати приклади в цій главі, вам слідує мати стандартну інсталяцію Scala. Щоб отримати її, перейдіть до <a href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a> та слідуйте інструкціям для своєї платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans. Для кроків в цій главі ми вважатимемо, що ви використовуєте дистрибутив Scala з scala-lang.org.<span class="footnote"><br />[Ми тестували приклади в цій книзі на Scala версії 2.11.7.]<br /></span></p></div>
<div class="paragraph"><p>Якщов ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, що дозволить вам почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий матеріал може видатись вам трохи містичним. Але не хвилюйтесь. Щоб ви жваво набрали швидкість ми полишили деякі деталі. Все буде пояснене в трохи "пожарному" стилі в наступних главах. На додаток ми вставили декілька зносок в ціх наступних двох главах, що вказують вам на пізніші розділи книги, де ви знайдете більш докладні пояснення.</p></div>
<div class="sect1">
<h2 id="__1____scala">Крок 1. Навчаємось викорстовувати інтерпретатор Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Простіший спосіб розпочати зі Scala є використання інтерпретатора Scala, інтерактивної  "оболонки" для написання Scala виразів та програм. Інтерпретатор, що називається scala, буде обчислювати вирази, які ви набираєте, та друкувати отримане значення. Ви використовуєте його, набравши scala в командній підказці:<span class="footnote"><br />[Якщо ви використовуєте Windows, вам буде треба друкувати команду scala у вікно "Command Prompt" DOS.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala
Welcome to Scala version 2.11.7
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Після того, як ви наберете вираз, такий як 1 + 2, та нажмете enter:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; 1 + 2</code></pre>
</div></div>
<div class="paragraph"><p>Інтерпретатор надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>res0: Int = 3</code></pre>
</div></div>
<div class="paragraph"><p>Цей рядок включає:</p></div>
<div class="ulist"><ul>
<li>
<p>
автоматично згенероване або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає результат 0),
</p>
</li>
<li>
<p>
дві крапки (:), за якими іде тип виразу (Int),
</p>
</li>
<li>
<p>
знак рівнсоті (=),
</p>
</li>
<li>
<p>
значення, отримане від обчислення виразу (3).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Тип <code>Int</code> є назвою класа <code>Int</code> в пакунку <code>scala</code>. Пакунки в Scala подібні до пакунків в Java: вони поділяють глобальний простір імен, та провадять механізм для приховування інформації.<span class="footnote"><br />[Якщо ви не знайомі з пакунками Java, ви можете думати про них, як про впроваджене повне ім'я класу. Оскільки Int є членом пакунку scala, "Int" є простим ім'ям класу, та "scala.Int" є його повним ім'ям. Деталі щодо пакунків пояснюються в Главі 13.]<br /></span> Значення класу <code>Int</code> відповідають значенням <code>Java</code> <code>int</code>. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку <code>scala</code>. Наприклад, <code>scala.Boolean</code> відповідає до Java <code>boolean</code>. <code>scala.Float</code> відповідає до Java <code>float</code>. Та коли ви компілюєте ваш Scala код в байткод Java, компілятор Scala коли можливо буде використовувати примітивні типи Java, щоб надати вам переваги продуктивності примітивних типів.</p></div>
<div class="paragraph"><p>Ідентифікатор <code>resX</code> може бути використаний в подальших рядках. Наприклад, оскільки res0 був встановлений в 3 до цього, res0 * 3 буде давати 9:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; res0 * 3
res1: Int = 9</code></pre>
</div></div>
<div class="paragraph"><p>Щоб надрукувати необхідне, але недостатнє привітання Hello, world!, наберіть:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println("Hello, world!")
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Функція <code>println</code> друкує переданий рядок на стандартний вивід, подібно до <code>System.out.println</code> в Java.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2___">Крок 2. Визначаємо декілька змінних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має два типи змінних, <code>vals</code> та <code>vars</code>. <code>val</code> подібні до <code>final</code> змінних в Java. Коли ініціалізована, <code>val</code> ніколи не може бути перепризначеною. На відміну від цього, <code>var</code>, подібно до не-фінальної змінної в Java. <code>var</code> може бути переприсвоєна на протязі свого життя. Ось визначення <code>val</code> definition:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg = "Hello, world!"
msg: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Це твордження вводить <code>msg</code> як ім'я для рядка "Hello, world!". Тип <code>msg</code> є <code>java.lang.String</code>, оскільки рядки в <code>Scala</code> реалізовані через клас Java <code>String</code>.</p></div>
<div class="paragraph"><p>Якщо ви визначали змінні в Java, ви зауважили тут одну вбивчу різницю: ані <code>java.lang.String</code>, ані <code>String</code> не з'являються ніде в визначенні <code>val</code>. Цей приклад ілюструє вивід типу, здатність Scala здогадуватись про типи, які ви оминули. В цьому випадку, оскільки ініціалізували <code>msg</code> рядковим літералом, Scala виводить тип <code>msg</code> як <code>String</code>. Коли інтерпретатор Scala (або компілятор) може вивести це, часто є кращим дозволити йому зробити це, ніж заповнювати код непотрібними, явними анотаціями типів. Однак ви можете вказати тип явно, якщо бажаєте, та іноді ви, вірогідно, повинні. Явна анотація типу може одночасно переконатись, що компілятор Scala виводить типи як задумано, і так само прислужитись в якості корисної документації для майбутніх читачів коду. На відміну від Java, коли ви вказуєте тип змінної перед її ім'ям, в Scala ви вказуєте тип змінної після її ім'ям, відокремлений двома крапками. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg2: java.lang.String = "Hello again, world!"
msg2: String = Hello again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Або, оскільки типи <code>java.lang</code> видимі в частині простих імен для програм Scala, просто:<span class="footnote"><br />[Просте ім'я java.lang.String є String.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Переходя до оригінального <code>msg</code>, тепер, коли вона визначена, ви можете використовувати її як очікується, наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println(msg)
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Що ви не можете робити з <code>msg</code>, зважаючи що вона <code>val</code>, не <code>var</code>, це переприсвоїти її.<span class="footnote"><br />[Однак в інтерпретаторі ви можете визначити нове val з іменем, що вже використовувалось до цього. Цей механізм пояснено в Розділі 7.7.]<br /></span> Наприклад, дивіться, як інтерпретатор скаржиться, коли ви намагаєтесь зробити наступне:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; msg = "Goodbye cruel world!"
&lt;console&gt;:8: error: reassignment to val
msg = "Goodbye cruel world!"
^</code></pre>
</div></div>
<div class="paragraph"><p>Якщо переприсвоєння саме те, чого ви бажаєте, вам треба вкористовувати <code>var</code>, як тут:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; var greeting = "Hello, world!"
greeting: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Оскільки <code>greeting</code> є <code>var</code> а не <code>val</code>, ви можете переприсвоїти її пізніше. Якщо ви пізнаше будете почуватись буркотливим, ви можете, наприклад, змінити ваше привітання на таке:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; greeting = "Leave me alone, world!"
greeting: String = Leave me alone, world!</code></pre>
</div></div>
<div class="paragraph"><p>Щоб ввести щось в інтерпретатор, що займатиме декілька рядків, просто продовжуйте друкувати доки не скінчите, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val multiLine =
|
"This is the next line."
multiLine: String = This is the next line.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви зрозуміли, що набрали щось невірно, але інтерпретатор ще чекає для додаткового вводу, ви можете вийти, натиснувши enter двічі:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val oops =
|
|
You typed two blank lines.
Starting a new command.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>В залишку книги ми полишимо вертикальні стовпчики, щоб зробити код простішим для читання (та простіше копіювати та вставляти з PDF eBook в інтерпретатор).</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3___">Крок 3. Визначаємо деякі функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
}
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Визначення функцій починається з <code>def</code>. Ім'я функції, в нашому випадку <code>max</code>, за яким слідує розділений комами список параметрі в дужках. Анотація типу має слідувати за кожним параметром функції черед дві крапки, оскільки компілятор Scala (і інтерпретатор, вле відтепер ми будемо казати тільки компілятор) не виводить типи параметрів функцій. В цьому прикладі функція на ім'я <code>max</code> приймає два параметри, <code>x</code> та <code>y</code>, обоє типу <code>Int</code>. Після того, як ви закрили дужки списку параметрів <code>max</code>, ви знайдете інішу анотацію типу <code>: Int</code>. Це визначає тип результату самої функції <code>max</code>.<span class="footnote"><br />[В Java тип значення, що повертається з метода, є його типом повернення. В Scala та сама концепція називається типом результата.]<br /></span> За типом результату іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить один вираз <code>if</code>, що обирає або <code>x</code> або <code>y</code>, що більше, як результат функції <code>max</code>. Як продемонстровано тут, в Scala <code>if</code> вираз може видавати значення, подібно то тримісного оператора в Java. Наприклад, вираз Scala  <code>if (x &gt; y) x else y</code> поводить себе подібно до <code>(x &gt; y) ? x : y</code> в Java. Знак рівності, що стоїть перед тілом функції, дає підказку, що з точки зору функціонального світу, функція визначає вираз, що видає значення. Базова структура функції ілюстрована на Малюнку 2.1.</p></div>
<div class="paragraph"><p>Малюнок 2.1 - базова форма визначення функції в Scala.</p></div>
<div class="paragraph"><p>Іноді компілятор Scala буде потребувати, щоб ви вказували тип результату функції. Якщо функція рекурсивна,<span class="footnote"><br />[Функція називається рекурсивною, якщо вона викликає сама себе.]<br /></span> наприклад, ви маєте явно вказати тип результату функції. Однак в випадку <code>max</code> ви можете випустити тип результату, і компілятор буде виводити його.<span class="footnote"><br />[Тим не менш, часто є гарною ідеєю вказати тип результата функції явно, навіть коли компілятор не потребує цього. Така анотація типу може зробити код простішим до читання, оскільки читач на повинен вивчати тіло функції, щоб з'ясувати виведений тип результата.]<br /></span> Також, якщо функція складається тільки з одного твердження, ви можете опціонально випустити і фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int) = if (x &gt; y) x else y
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Коли ви визначили функцію, ви можете викликати її:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; max(3, 5)
res4: Int = 5</code></pre>
</div></div>
<div class="paragraph"><p>Ось визначення функції, що не приймає параметрів, та не повертає цікавих результатів:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</code></pre>
</div></div>
<div class="paragraph"><p>Коли ви визначаєте функцію <code>greet()</code>, інтерпретатор буде відповідати <code>greet: ()Unit</code>.  "greet" є, звичайно, іменем функції. Порожні дужки вказують, що функція не сприймає параметрів. Та <code>Unit</code> є тип повернення <code>greet</code>. Тип результата <code>Unit</code> вказує, що функція не повертає цікавих значень. Тип Scala <code>Unit</code> подібний на тип Java <code>void</code>; фактично, кожинй метод, що повертає в Java <code>void</code>, відзеркалюється на метод Scala, що повертає <code>Unit</code>. Методи з типом результата <code>Unit</code>, таким чином, виконуються тільки для заради їх побічних ефектів. В випадку greet(), побічний ефект є дружнє привітання, роздруковане на стандартний вихід.</p></div>
<div class="paragraph"><p>На наступному кроці ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, ввівші :quit або :q.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; :quit
$</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="__4___scala_">Крок 4. Пишемо деякі Scala скрипти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча Scala розроблена допомогти в побудові дуже велико-маштабованих систем, вона також гарно маштабується донизу до скриптинга. Скрипт це тільки послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть це в файл з назвою <code>hello.scala</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>println("Hello, world, from a script!")</code></pre>
</div></div>
<div class="paragraph"><p>потім виконайте:<span class="footnote"><br />[Ви можете виконати скрипт без набирання "scala" під Unix та Windows, використовуючи синтаксис "pound-bang", що показаний в Додатку A.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala hello.scala</code></pre>
</div></div>
<div class="paragraph"><p>Та ви маєте отримати наступне привітання:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, world, from a script!</code></pre>
</div></div>
<div class="paragraph"><p>Аргументи командного рядка скрипта Scala доступні через масив Scala з назвою <code>args</code>. В Scala масиви починаються з нуля, та ви отримуєте доступ до елементів через вказання індексу в дужкає. Так що перший елемент в масиві Scala з назвою <code>steps</code> є <code>steps(0)</code>, не <code>steps[0]</code>, як в Java. Щоб спробувати це, наберіть наступне в новий файл з назвою <code>helloarg.scala</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>// Say hello to the first argument
println("Hello, " + args(0) + "!")</code></pre>
</div></div>
<div class="paragraph"><p>потім виконайте:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala helloarg.scala planet</code></pre>
</div></div>
<div class="paragraph"><p>В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як <code>args(0)</code>. Таким чином ви можете побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, planet!</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що цей скрипт містить коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та любі символи між /* та */. Цей приклад також показує, як рядки конкатенуються (поєднуються) за допомогою оператора + . Це робить як ви очікуєте. Вираз "Hello, " + "world!" призведе до рядка "Hello, world!".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__5___while___if">Крок 5. Цикл з while; рішення з if</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб спробувати <code>while</code>, наберіть наступне в файл на ім'я <code>printargs.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Хоча приклади в цьому розділі допомагають зрозуміти цикли <code>while</code>, вони не демонструють кращий стиль Scala. В настурному розділі ви побачите кращі підходи уникнути ітерації по масивах за допомогою індексів.</td>
</tr></table>
</div>
<div class="paragraph"><p>Цей скрипт починається з визначення змінної <code>var i = 0</code>. Вивід типів надає <code>i</code> тип  <code>scala.Int</code>, оскільки це тип початкового значення, 0. Конструкція <code>while</code> в наступному рядку призводить до того, що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз <code>i &lt; args.length</code> буде <code>false</code>. <code>args.length</code> дає довжину масива <code>args</code>. Блок містить два твердження, кожне зсунуте на два проміжки, рекомендований відступ в Scala. Перше твердження, <code>println(args(i))</code>, друкує i-тий аргумент командного рядка. Наступне твердження, <code>i += 1</code>, інкрементує (збільшує) i на один. Зауважте, що відомі з Java <code>i та i</code> не роблять в Scala. Щоб виконати інкремент в Scala, вам треба сказати або i = i + 1 або i += 1. Виконайте цей скрипт за допомогою наступної команди:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala printargs.scala Scala is fun</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala
is
fun</code></pre>
</div></div>
<div class="paragraph"><p>Для ще більшої розваги наберіть наступний код в файлі на ім'я <code>echoargs.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій версії ми замінили виклик <code>println</code> на виклик <code>print</code>, так що всі ці аргументи будуть друкуватись на тому самому рядку. Щоб зробите читабельним, ви вставляєте один проміжок перед кожним аргументом, за винятком першого, через конструкцію <code>if (i != 0)</code>. Оскільки <code>i != 0</code> буде <code>false</code> перший раз, коли ви проходите через цикл, проміжок не буде надрукований перед першим аргументом. Нарешті, ви додали ще один <code>println</code> в кінці, щоб отримати перевод рядка після друку всіх аргументів. Ваш вивід тепер є досить гарним. Якщо ви виконаєте цей скрипт за допомогою такої команди:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala echoargs.scala Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Ви отримаєте:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що в Scala, як і в Java, ви маєте покладати логічні вирази для <code>while</code> або для <code>if</code> в дужки. (Іншими словами, ви не можете сказати в Scala речі як <code>if i &lt; 10</code>, як ви можете в таких мовах, як Ruby. Ви маєте сказати <code>if (i &lt; 10)</code> в Scala). Інша подібність до Java в тому, що коли блок <code>if</code> має тільки одне твердження, ви можете опціонально випустити фігурні дужки, як демонструєтсья твердженням <code>if</code> в <code>echoargs.scala</code>. І хоча ми не бачили жодної з них, Scala використовує крапку з комою для розділення тверджень, як і Java, за тим винятком, що в Scala кома з крапкою дуже часто опціональна, що дає деяке розслаблення мізинцю правої руки. Однак якщо ви перебуваєте в дещо більш балакучому настрої, ви можете записати скрипт <code>echoargs.scala</code> наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">print</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">();</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__6____foreach__for">Крок 6. Ітеруємо за допомогою foreach та for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча ви можете не уявляти цього, коли ви пишете цикли <code>while</code> в попередньому кроці, ви програмуєте в імперативному стилі. В вмперативному стилі, що є стилам, який ви звичайно використовуєте з мовами як Java, C++ та C, ви видаєте одну імперативну команду за раз, ітеруючи за допомогою циклів, та часто змінюєте стан, загальний для різних функцій. Scala дозволяє вам програмувати імперативно, але коли ви будете знати Scala краще, ви будете частіше знаходити себе за програмуванням в більш функціональному стилі. Фактично, одна з головних цілей цієї книги є допомогти вам стати так само комфортним з функціональним стилем, як вам є з імперативним стилем.</p></div>
<div class="paragraph"><p>Одна з головних характеристик функціональної мови в тому, що функції є першокласними конструкціями, і це є дуже вірно в Scala. Наприклад, інший (значно більше стислий) шлях надрукувати кожний аргумент командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">arg</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому коді ви викликаєте метод foreach на <code>args</code>, та передаєте йому функію. В цьому випадку ви передаєте функціональний літерал, що приймає один параметр на ім'я <code>arg</code>. Тілом функції є <code>println(arg)</code>. Якщо ви наберете код вище в новий файл з назвою <code>pa.scala</code> та виконаєте його командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala pa.scala Concise is nice</code></pre>
</div></div>
<div class="paragraph"><p>Ви можете побачили:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Concise
is
nice</code></pre>
</div></div>
<div class="paragraph"><p>В попередньому прикладі інтерпретатор Scala виводить тип <code>arg</code> як <code>String</code>, оскільки <code>String</code> є типом елементів масива, для якого ми викликаємо foreach. Якщо ви схильні бути більш явним, ви можете вказати ім'я типу. Але коли ви зробите це, вам доведеться огорнути аргумент в дужки (що є нормальною формою синтаксиса в жодному разі):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach((arg: String) =&gt; println(arg))</code></pre>
</div></div>
<div class="paragraph"><p>Виконання цього скрипта має ту саму поведінку, що і попереднього.</p></div>
<div class="paragraph"><p>Якщо ви в настрої бути трохи стислішим, ніж більш явним, ви можете отримати перевагу від спеціалного скорочення в Scala. Якщо функціональний літерал складається з одного твердження, що приймає один аргумент, вам не треба явно називати та сказувати аргумент.<span class="footnote"><br />[Це скорочення, що називається частково визначеною функцією, описане в Розділі 8.6.]<br /></span> Таким чином, наступний код також робить:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach(println)</code></pre>
</div></div>
<div class="paragraph"><p>Щоб підсумувати, синтаксис для функціонального літерала є список іменованих параметрів в дужках, стрілка вправо, та потім тіло функції. Синтаксис проілюстрований на Малюнку 2.2.</p></div>
<div class="paragraph"><p>Малюнок 2.2 - Синтаксис функціонального літерала в Scala.</p></div>
<div class="paragraph"><p>Тепер, в цій точці ви можете здивуватись, що трапилось з тіми надійними циклами <code>for</code>, до яких ви звикли при використанні імперативних мов, таких як Java або C. В спробі спрямувати вас в функціональному напрямку, в Scala доступний тільки функціональний родич  <code>for</code> (що називається виразом <code>for</code>). Хоча ви не побачите його повної потужності та виразності, доки не досягнете (або не заглянете наперед) Розділ 7.3, ми дамо вам побіжний погляд. В новому файлі на ім'я <code>forargs.scala</code> наберіть наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Дужки після <code>for</code> містять <code>arg &lt;- args</code>.<span class="footnote"><br />[Ви можете казати "в" для символа &#8592; . Ви будете читати for (arg &#8592; args), таким чином, як "для arg в args."]<br /></span> Зправа від символа <code>&lt;-</code> є знакомий масив <code>args</code>. Зліва від <code>&lt;-</code> є <code>arg</code>, ім'я <code>val</code>, не <code>var</code>. (Оскільки це завжди <code>val</code>, ви просто пишете один <code>arg</code>, не <code>val arg</code>). Хоча <code>arg</code> може виглядати як <code>var</code>, оскільки вона буде отримувати нове значення на кожній ітерації, насправді це <code>val</code>: <code>arg</code> не може бути переприсвоєний в тілі виразу. Замість цього, для кожного елементу масива <code>args</code> буде створений новий <code>val arg</code> та ініціалізований значенням елемента. Після чого буде виконане тіло <code>for</code>.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте скрипт <code>forargs.scala</code> командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala forargs.scala for arg in args</code></pre>
</div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for
arg
in
args</code></pre>
</div></div>
<div class="paragraph"><p>Вираз <code>for</code> в Scala може робити набагато більше ніж це, але цей приклад достатнім для початку. Ми покажемо вам більше щодо <code>for</code> в Розділі 7.3 та Главі 23.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__6">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми вивчили деякі основи Scala, та, надіємось, скористались можливостю написати трохи Scala коду. В наступній главі мо продовжимо цей вступний огляд, та займемось більш складними темами.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3_2">Глава 3</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala_2">Наступні кроки в Scala</h1>
<div class="paragraph"><p>Ця глава продовжує вступ до Scala з попередньої глави. В цій главі ми введемо декілька більш складних можливостей. Коли ви скінчите цю главу, ви будете мати досить знань, щоб почати писати корисні скрипти на Scala. Як і з попередньою главою, ми рекомендуємо вам спробувати ці приклади, по мірі проходження. Кращий спосіб отримати відчуття Scala є почати писати Scala код.</p></div>
<div class="sect1">
<h2 id="__7_____">Крок 7. Параметризація масивів за допомогою типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala ви можете створити примірники об'єктів або примірники класів, використовуючи <code>new</code>. Коли ви створюєте примірник об'єкту в Scala, ви можете параметризувати його за допомогою значень або типів. Параметризація означає "конфігурація" примірника, коли ви створюєте його. Ви параметризуєте примірник значеннями, через передачу об'єктів до конструктора в дужках. Наприклад, наступний код Scala створює нового <code>java.math.BigInteger</code>, та параметризує його значенням "12345":</p></div>
<div class="listingblock">
<div class="content">
<pre><code>val big = new java.math.BigInteger("12345")</code></pre>
</div></div>
<div class="paragraph"><p>Ви параметризуєте примірник типами, коли вказуєте один або більше типів в прямокутних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі <code>greetStrings</code> є значенням типу <code>Array[String]</code>("масив рядків"), що ініціалізований довжиною 3 через його параметризацію значенням 3 в першому рядку кода. Якщо ви запустите код з Лістинга 3.1 як скрипт, ви побачите ще одне привітання <code>Hello, world!</code>. Зауважте, що коли ви параметризуєте примірник обома, типом та значенням, тип іде першим в своїх прямокутних дужках, за якими іде значення в дужках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.1 - Параметризація масива за допомогою типа.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Хоча код в Лістингу 3.1 демонструє важливі концепції, він не показує рекомендований спосіб створювання та ініціалізації масивів в Scala. Ви побачите кращий спосіб в Лістингу 3.2 далі.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо ви знаходитесь в більш явному настрої, ви можете вказати тип <code>greetStrings</code> явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги вивід типів Scala, цей рядок кода семантично еквівалнтний до першого дійсного рядка Лістинга 3.1. Але ця форма демонструє, що хоча частина параметризації типа (імена типів в прямокутних дужках) формує частину типу примірника, частина параметризації значенням (значення в дужках) - ні. Тип <code>greetStrings</code> є <code>Array[String]</code>, не Array[String](3).</p></div>
<div class="paragraph"><p>Наступні три рядка кода з Лістинга 3.1 ініціалізують кожний елемент масиву <code>greetStrings</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви в Scala отримують доступ покладанням індексу в дужках, не прямокутних дужках, як в Java. Таким чином нульовий елемент масива є <code>isgreetStrings(0)</code>, та не <code>greetStrings[0]</code>.</p></div>
<div class="paragraph"><p>Ці три рядка кода ілюструють важливу концепцію для розуміння того, як Scala розглядає визначення <code>val</code>. Коли ви визначаєте змінну за допомогою <code>val</code>, змінна не може бути переприсвоєна, але об'єкт, на який вона посилається, потенційно все ще може бути змінений. Як в цьому випадку, ви не можете переприсвоїти <code>greetStrings</code> на інший масив; <code>greetStrings</code> буде завжди вказувати на той самий примірник <code>Array[String]</code>, яким він був ініціалізований. Але ви можете змінити елементи цього <code>Array[String]</code> з часом, так що сам масив є змінним.</p></div>
<div class="paragraph"><p>Два заключні рядка в Лістингу 3.1 містять вираз <code>for</code>, що друкує кожний елемент <code>greetStringsarray</code> по черзі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший рядок коду в цьому виразі <code>for</code> ілюструє інше загальне правило Scala: якщо метод приймає тільки один параметр, ви можете викликати його без крапки або дужок. В цбому прикладі <code>to</code> насправді є методом, що приймає один аргумент Int. Код <code>0 to 2</code> трансформується в виклик метода <code>(0).to(2)</code>. <span class="footnote"><br />[Цей метод to насправді повертає не масив, але інший різновид послідовності, що містить значення 0, 1 та 2, по якому ітерує for. Послідовності та інші колекції будуть описані в Главі 17.]<br /></span> Зауважте, що цей синтаксис робить, тільки якщо ви явно вказуєте отримувача виклику метода. Ви не можете написати <code>println 10</code>, але ви можете написати <code>Console println 10</code>.</p></div>
<div class="paragraph"><p>Scala технічно не має перевантаження операторів, оскільки вона насправді не має операторів в традиційному сенсі. Замість цього, такі символи, як +, -, * та / можуть бути використані в іменах методів. Таким чином, коли ви друкуєте <code>1 + 2</code> в Scala інтерпретаторі на Кроці 1, ви насправді викликаєте метод з назвою <code>+</code> на <code>Int</code> об'єкті <code>1</code>, передаючи <code>2</code> як параметр. Як ілюстровано на Малюнку 3.1, ви можете альтернативно записати <code>1 + 2</code>, використовуючи традиційний синтаксис виклику метода, <code>(1).+(2)</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.1 - В Scala всі операції є викликами методів.</p></div>
<div class="paragraph"><p>Інша важлива ідея, ілюстрована цім прикладом, це надати вам розуміння того, чому масиви надають доступ через дужки в Scala. Scala має меньше особливих випадків, ніж Java. Масиви є простими примірниками класів, як любі інші класи в Scala. Коли ви застосовуєте дужки, що оточують одне або більше значень до змінної, Scala буде трансформувати код в виклик методу з назвою <code>apply</code> на цій змінній. Так що <code>greetStrings(i)</code> перетвориться на <code>greetStrings.apply(i)</code>. Таким чином, доступ до елемент масива в Scala є простим викликом метода, як любий інший. Цей принцип не ообмежуєть до масивів: любе застосування об'єктів до деяких аргументів в дужках буде трпнсформоване в виклик метода <code>apply</code>. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкта дійсно визначає метод <code>apply</code>. Так що це не особливий випадок; це загальне правило.</p></div>
<div class="paragraph"><p>Подібним чином, коли робиться просвоєння до змінної, до якої застовані дужки з одним або більше аргументом, компілятор буде трансформувати це в виклик метода <code>update</code>, що приймає аргументи в дужках, а такж об'єкт з правого боку від знака рівності. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings(0) = "Hello"</code></pre>
</div></div>
<div class="paragraph"><p>буде трансформовано на:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings.update(0, "Hello")</code></pre>
</div></div>
<div class="paragraph"><p>Таким чином, наступне симантично еквівалентне до коду з лістинга 3.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello&quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;, &quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;world!\n&quot;</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mf">0.</span><span class="n">to</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala досягає концептуальної простоти, трактуючи все, від масивів та виразів, як об'єкти з методами. Ви не маєте пам'ятати особливі випадки, такі, як розбіжності в Java між примітивами та їх відповідними огортаючими типами, або між масивами та звичайними об'єктаи. Більше того, ця одноманітність не накладає значних витрат продуктивності. Компілятор Scala використовує в скомпільованому коді масиви Java, примітивні типи, та природну арифметику, де це можливо.</p></div>
<div class="paragraph"><p>Хоча приклади, що ви бачили на цей момент в цьому кроці, компілюються та виконуються досить гано, Scala провадить більш стислий спосіб для створення та ініціалізації масивів, який в будете звичайно використовувати (Лістинг 3.2). Цей код створює новий масив довжиною три, ініціалізований переданими рядками, <code>"zero"</code>, <code>"one"</code>, <code>"two"</code>. Компілятор виводить тип масива, як <code>Array[String]</code>, оскільки ви передали йому рядки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.2 - Створення та ініціалізація масиву.</p></div>
<div class="paragraph"><p>Що ви насправді робите в Лістингу 3.2, це виклик методу фабрики, під назвою <code>apply</code>, що створює та повертає новий масив. Цей метод <code>apply</code> приймає змінне число аргументів,<span class="footnote"><br />[Список аргументів змінної довжини, або повторювані параметри, описані в Розділі 8.8.]<br /></span> та визначений на об'єкті компанйоні Array. Ви навчитесь більше щодо об'єктов компанйонів в Розділі 4.3. Якщо ви Java програміт, ви можете думати про це, як про виклик статичного методу на ім'я <code>apply</code> на класі <code>Array</code>. Більш балакучий шлях викликати той самий метод <code>apply</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames2</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__8__">Крок 8. Використання списків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна з виликих ідей функціонального стилю програмування є методи, що не мають побічних ефектів. Єдиною дією метода повинне бути обчислення та повернення значення. Деякі переваги, що будуть отримані коли ви приймете цей підхід, в тому, що методи стають менш  заплутаними, і таким чином, більш надійні та використовувані. Інша перевага (в статично типізованій мові) в тому, що все, що входить і виходить з метода перевіряється контролем типів, так що логічні помилки більш вірогідно проявлять себе як помилки типів. Застосування цієї функціональної філософії до світу об'єктів означає зробити об'єкти незмінними.</p></div>
<div class="paragraph"><p>Як ви бачили, масиви Scala є змінними послідовностями об'єктів, що всі поділяють той самий тип. Наприклад, <code>Array[String]</code> містить тільки рядки. Хоча ви не можете змінити довжину масива, після того, як був створений екземпляр, ви можете змінити значення його елементів. Таким чином, масиви є змінні об'єкти.</p></div>
<div class="paragraph"><p>Для незмінних послідовностей об'єктів, що поділяють той самий тип, ви можете використати клас Scala <code>List</code>. Так само, як і з масивами, <code>List[String]</code> містить тільки рядки. Список Scala <code>List</code>, <code>scala.List</code>, відрізняється від типу Java <code>java.util.List</code> в тому, що списки Scala <code>List</code> завжди незмінні (тоді як списки Java <code>List</code> можуть бути змінні). Більш загально, Scala <code>List</code> розроблений дозволити функціональний стиль програмування. Створити список просто, та Лістинг 3.3 показує як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.3 - Створення та ініціалізація списку.</p></div>
<div class="paragraph"><p>Код в Лістингу 3.3 встановлює нову <code>val</code> на ім'я <code>oneTwoThree</code>, ініціалізовану як <code>new List[Int]</code> з цілими елементами 1, 2 та 3.<span class="footnote"><br />[Вам не треба казати new List, оскільки "List.apply()" визначений як метод фабрика на об'єкті компанйоні scala.List. Ви будете читати більше про об'єкти компанйони в Розділі 4.3.]<br /></span> Оскільки <code>List</code> незмінні, вони поводяться трохи подібно до рядків в Java: коли ви викликаєте метод на списку, з імені якого випливає, що список буде змінений, він замість цього створює та повертає нове значення. Наприклад, <code>List</code> має метод на ім'я <code>:::</code> для конкатенації списків. Ось як ви використовуєте його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwo</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">threeFour</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThreeFour</span> <span class="k">=</span> <span class="n">oneTwo</span> <span class="o">:::</span> <span class="n">threeFour</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwo</span> <span class="o">+</span> <span class="s">&quot; and &quot;</span> <span class="o">+</span> <span class="n">threeFour</span> <span class="o">+</span> <span class="s">&quot; were not mutated.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Thus, &quot;</span> <span class="o">+</span> <span class="n">oneTwoThreeFour</span> <span class="o">+</span> <span class="s">&quot; is a new list.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви виконаєте цей скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</code></pre>
</div></div>
<div class="paragraph"><p>Можливо найбільш загальний оператор, якім ви будете користатись зі списками, є <code>::</code>, що вимовляється як "cons". Cons ставить новий елемент до початку існуючого списку, та повертає отриманий список. Наприклад, якщо ви викличете цей скрипт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">twoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">twoThree</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2, 3)</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">В виразі 1 <code>::</code> twoThree, <code>::</code> є методом свого правого операну, списку <code>twoThree</code>. Ви можете запідозрити, що щось не так з асоціативністю метода <code>::</code>, але насправді є просте правило, що треба пам'ятати: якщо метод використовується в операторній нотації, такі, як <code>a * b</code>, метод викликається на лівому операнді, як <code>a.*(b)</code> — за винятком, коли метод закінчується на двокрапку. Якщо ім'я метода закінчується на двокрапку, метод викликається на правому операнді. Таким чином, в 1 <code>::</code> twoThree, метод <code>::</code> викликається на <code>twoThree</code>, передаючи 1: <code>twoThree.::(1)</code>. Асоціативність операторів буде детально дискутована в Розділі 5.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Приймаючи, що скороченим шляхом вказати порожній список є <code>Nil</code>, одним з методів ініціалізувати нові списки є поєднання разом елементів за допомогою оператора <code>cons</code>, з Nil в якості останнього елемента. Причина, з якої вам треба Nil в кінці полягає в тому, що <code>::</code> визначене для класа List. Якщо ви намагатиметесь просто сказати 1 <code>::</code> 2 <code>::</code> 3, це не буде компілюватись, оскільки 3 є Int, що не має метода <code>::</code>. Наприклад, наступний скрипт буде продукувати той самий вихід, що і попередній, <code>List(1, 2, 3)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala List напакований корисними методами, багато з яких показані в Таблиці 3.1. Повна потужність списків буде розкрита в Главі 16.</p></div>
<div class="sect2">
<h3 id="______2">Чому не додавати до списків?</h3>
<div class="paragraph"><p>Клас List пропонує операцію <code>append</code> — вона записується як <code>:+</code> та пояснена в Главі  24 — але ця операція рідко використовується, оскільки час, що займає додати до списку зростає лінійно з розміром списку, тоді як постановка в початок за допомогою <code>::</code> займає сталий час. Якщо ви бажаєте побудувати список ефективно через додавання елементів, ви можете додавати їх в початок, то коли все буде зроблене зробити реверс (обертання) списку. Або ви можете використовувати <code>ListBuffer</code>, змінний список, що пропонує операцію <code>append</code>, та потім, коли все зроблено, викликати <code>toList</code>. <code>ListBuffer</code> буде описаний в Розділі  22.2.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі методи та використання List</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке        </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span> <span class="n">або</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Порожній List</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;Cool&quot;</span><span class="o">,</span> <span class="s">&quot;tools&quot;</span><span class="o">,</span> <span class="s">&quot;rule&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Cool", "tools", "rule"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">thrill</span> <span class="k">=</span> <span class="s">&quot;Will&quot;</span> <span class="o">::</span> <span class="s">&quot;fill&quot;</span> <span class="o">::</span> <span class="s">&quot;until&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Will", "fill", "until"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;d&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Конкатенує два списки (повертає новий List[String] зі значеннями "a", "b", "c", "d")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає елемент з індексом 2 (від нуля) списку thethrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">count</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Рахує число число рядків-елементів в thrill, чия довжина 4 (повертає 2)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без перших двох елементів (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">dropRight</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без двох правих елементів (повертає List("Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">==</span> <span class="s">&quot;until&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Визначає, чи існує елемент-рядок в thrill, що має значення "until" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів thrill, по порядку, що мають довжину 4 (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">forall</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;l&quot;</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи всі елементи в списку thrill закінчуються на літеру "l" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Виконує твердження print на кожному рядку в списку thrill (друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">print</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Те саме що і попередньє, але стисліше (також друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">head</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає перший елемент в списку thrill (повертає "Will")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">init</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає з усіх, крім останнього, елементів в списку thrill (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">isEmpty</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи є список thrill (повертає false)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">last</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає останній елемент в списку thrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає число елементів в списку thrill (повертає 3)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;y&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, отриманий від додавання "y" до кожного елемента-рядка в списку thrill (повертаєList ("Willy", "filly", "untily"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;, &quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Робить рядок з усіх елементів списку (повертає "Will, fill, until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filterNot</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів списку thrill, по порядку, крім тих, що мають довжину 4 (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">reverse</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що складається з усіх елеменітв списку thrill в зворотньому порядку (повертає List("until", "fill", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">sort</span><span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що містить всі елементи thrill в алфавітному порядку по першій літері, переведеній в нижній реєстр (повертає List("fill", "until", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">tail</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill мінус перший елемент (повертає List("fill", "until"))</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__9__">Крок 9. Використання таплів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Інший корисний контейнерний об'єкт є тапл. Як списки, тапли є нехмінними, але на відміну від списків, тапли можуть містити різні типи елементів. Коли список може бути List[Int] або aList[String], тапл може містити обоє, ціле та рядок, одночасно. Тапли дуже корисні, наприклад, коли ви повертаєте декілька об'єктів з метода. В той час, коли в Java ви будете часто створювати JavaBean-подібний клас, що міститиме декілька повертаємих значень, в Scala ви можете просто повернути тапл. Та це просто: щоб ініціалізувати тапл, що містить деякий об'єкти, просто покладіть об'єкти в дужки, розділені комами. Як тільки ви маєте примірник таплу, ви можете отримати доступ до його індивідуальних об'єктів через крапку, підкреслення, та 1-базований індекс елементів. Приклад показаний на Лістингу 3.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">pair</span> <span class="k">=</span> <span class="o">(</span><span class="mi">99</span><span class="o">,</span> <span class="s">&quot;Luftballons&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.4 - Creating and using a tuple.</p></div>
<div class="paragraph"><p>В першому рядку Лістинга 3.4 ви створюєте новий тапл, що містить ціле 99 як перший елемент, та рядок "Luftballons" як другий елемент. Scala виводить тип тапла як <code>Tuple2[Int, String]</code>, та надає цей тип до змінної <code>pair</code>, також. В другому рядку ви отримуєте доступ до поля _1, що буде продукувати перший елемент, <code>99</code>. "." в другому рядку є та сама крапка, яку ви використовуєте для доступу до поля або для виклику метода. В цьому випадку ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>99
Luftballons</code></pre>
</div></div>
<div class="paragraph"><p>Справжній тип тапла залежить від числа елементів, яке він містить, та від типів ціх елементів. Таким чином, тип <code>(99, "Luftballons")</code> є <code>Tuple2[Int, String]</code>. Тип <code>('u', 'r', "the", 1, 4, "me")</code> є <code>Tuple6[Char, Char, String, Int, Int, String]</code>.<span class="footnote"><br />[Хоча концептуально ви можете створити тапли любої довжини, наразі бібліотека Scala визначає їх до Tuple22.]<br /></span></p></div>
<div class="sect2">
<h3 id="_____3">Доступ до елементів тапла</h3>
<div class="paragraph"><p>Ви можете здивуватись, чому ви не можете отримати доступ до елементів тапла як до елементів списку, наприклад, як <code>pair(0)</code>. Причина є в тому, що для списка метод <code>apply</code> завжди повертає той самий тип, але кожний елемент тапла може бути різного типу: _1 може мати одит тип результату, _2 інший, і так далі. Ці числа _N базуються не одиниці, замість нуля, оскільки починати з 1 є традицією, встановленою іншими мовами зі статичними типизованими таплами, як Haskell та ML.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__10____">Крок 10. Використання множин та мап</h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки Scala націлена допомогти вам отриати переваги від обох, функціонального та імперативного стилів, її бібліотеки колекцій наголошують на різниці між змінними та незмінними колекціями. Наприклад, масиви завжди змінні; списки завжди незмінні. Scala також провадить змінні та незмінні альтернативи для множин та мап, але використовує ті ж самі прості імена для обої версій. Для множин та мап Scala моделює змінність в ієрархії класів.</p></div>
<div class="paragraph"><p>Наприклад, Scala API містить базовий трейт для множин, де трейт схожий на Java інтерфейс. (Ви знайдете більше щодо трейтів в Главі 12). Потім Scala провадить два субтрейти, один для змінних множин, та інший для незмінних множин.</p></div>
<div class="paragraph"><p>Як ви можете бачити на Малюнку 3.2, ці три трейти всі поділяють те саме просте ім'я, <code>Set</code>. Однак їх повністю кваліфіковані імена відрізняються, оскільки кожний знаходиться в окремому пакунку. Конкретні класи множин в Scala API, такі як класи <code>HashSet</code>, показані на Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java ви "реалізуєте" інтерфейси, в Scala ви "розширюєте" або "міксуєте" трейти). Таким чином, якщо ви бажаєте використати HashSet, ви маєте обрати між змінним та незмінним варіаціями, в залежності від ваших потреб. Спосіб по замовчанню створити множину показаний на Лістингу 3.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jetSet</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Boeing&quot;</span><span class="o">,</span> <span class="s">&quot;Airbus&quot;</span><span class="o">)</span>
<span class="n">jetSet</span> <span class="o">+=</span> <span class="s">&quot;Lear&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">jetSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;Cessna&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.5 - Створення, ініціалізація та використання незмінної множини.</p></div>
<div class="paragraph"><p>Малюнок 3.2 - Ієрархія класів для множин Scala.</p></div>
<div class="paragraph"><p>В першому рядук кода в Лістингу 3.5 ви визначаєте нову <code>var</code> на ім'я <code>jetSet</code>, та ініціалізуєте її незмінною множиною, що має два рядка, "Boeing" та "Airbus". Як показує приклад, ви можете створити множини в Scala подібно до того, як ви створюєте списки та масиви: через виклик метода фабрики з назвою <code>apply</code> на об'єкті компанйоні Set. В Лістингу 3.5 ви визиваєте <code>apply</code> на об'єкті компанйоні для  <code>scala.collection.immutable.Set</code>, що повертає примірник по замовчанню, незмінний <code>Set</code>. Компілятор Scala виводить тип <code>jetSet</code> як незмінний <code>Set[String]</code>.</p></div>
<div class="paragraph"><p>Щоб додати новий елемент до множини ви застосовуєте виклик + на множині, передаючи новий елемент. На обох, змінній та незмінній множині метод + буде створювати та поверне нову множину з доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною. Хоча змінні множини пропонують справжній метод <code>+=</code>, незмінні множини ні.</p></div>
<div class="paragraph"><p>В цьому випадку другий рядок коду, <code>jetSet += "Lear</code>, в основному є скороченням для:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">jetSet</span> <span class="k">=</span> <span class="n">jetSet</span> <span class="o">+</span> <span class="s">&quot;Lear&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, в другому рядку Лістингу 3.5 ви переприсвоююте <code>jetSet var</code> новою множиною, що містить "Boeing", "Airbus", та "Lear". Нарешіт, в останньому рядку Лістингу 3.5 іде друк того, чи містить або ні множина рядок "Cessna". (Як ви і очікували, друкується false).</p></div>
<div class="paragraph"><p>Якщо ви бажаєте змінну множину, вам треба використовувати імпорт, як показано в Лістингу 3.6:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">movieSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Hitch&quot;</span><span class="o">,</span> <span class="s">&quot;Poltergeist&quot;</span><span class="o">)</span>
<span class="n">movieSet</span> <span class="o">+=</span> <span class="s">&quot;Shrek&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">movieSet</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.6 - Створення, ініціалізація та використання змінної множини.</p></div>
<div class="paragraph"><p>В першому рядку Лістингу 3.6 ви імпортуєте <code>Set</code>. Як і з Java, твердження <code>import</code> дозволяє вам використовувати просте ім'я, таке як  <code>Set</code>, замість довшого, повністю кваліфікованого імені. Як результат, коли ви кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі <code>scala.collection.mutable.Set</code>. В цьому рядку ви ініціалізуєте <code>movieSet</code> новою змінною, що містить рядки "Hitch" та "Poltergeist". Наступний рядок додає "Shrek" до змінної множини, викликаючи метод <code>+=</code> до множини, передаючи йому рядок "Shrek". Як зазначалось раніше, <code>+=</code> насправді є методом, визначеним на змінній множині. За вашим бажанням, замість <code>writingmovieSet += "Shrek"</code>, ви можете написати <code>movieSet.+=("Shrek")</code>.<span class="footnote"><br />[Оскільки множина в Лістингу 3.6 змінна, немає потреби переприсвоювати movieSet, ось чому вона може бути встановлена в val. До контрасту, використання += з незмінною множиною в Лістингу 3.5 потребує переприсвоєння jetSet, ось чому воно має бути var.]<br /></span></p></div>
<div class="paragraph"><p>Хоча реалізація множин по замовчанню, спродукована змінною та незмінною методами фабриками <code>Set</code>, буде достатньою в багатьох ситуаціях, часом ви можете побажати явно задати клас. Нащастя, синтаксис є подібним. Просто імпортуйте потрібний вам клас, та використовуйте метод фабрику на його об'єкті компанйоні. Наприклад, якщо вам треба незмінний <code>HashSet</code>, ви можете зробити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.immutable.HashSet</span>
<span class="k">val</span> <span class="n">hashSet</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="s">&quot;Tomatoes&quot;</span><span class="o">,</span> <span class="s">&quot;Chilies&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">hashSet</span> <span class="o">+</span> <span class="s">&quot;Coriander&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший корисний клас колекції в Scala є <code>Map</code>. Як і з множинами, Scala провадить змінну та незмінну версії <code>Map</code>, використовуючи ієрархію класів. Як ви можете побачити на Малюнку 3.3, ієрархія класів для мап виглядає мажйе так, як така для множин. Існує базовий трейт <code>Map</code> в пакунку <code>packagescala.collection</code>, і два субтрейти Maps: змінний Map в <code>scala.collection.mutable</code> та незмінний в <code>scala.collection.immutable</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.3 - Ієрархія класів для Scala мап.</p></div>
<div class="paragraph"><p>Реалізації Map, такі як <code>HashMaps</code>, показані в ієрархії на Малюнку 3.3, розширюють або змінний, або незмінний трейт. Ви можете створити та ініціалізувати мапи, використовуючи метди фабрики, подібні до таких для масивів, списків та множин.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">treasureMap</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;Go to island.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;Find big X on ground.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;Dig.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">treasureMap</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.7 - Створення, ініціалізація та використання змінної мапи.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 3.7 показує змінну мапу в дії. On the first line of Лістинг 3.7, you import the mutable Map. You then define a val named treasureMap, and initialize it with an empty mutable Map that has integer keys and string values. The map is empty because you pass nothing to the factory method (the parentheses in "Map[Int, String]()" are empty).<span class="footnote"><br />[Явна параметризація типу, "[Int, String]", є необхідною в Лістингу 3.7, оскільки без любих значень, переданих в метод фабрику компілятор не здатний вивести тип параметрів мапи. Для контрасту, компілятор може вивести тип параметрів зі значень, переданих до фабрики мапи, показаної в Лістингу 3.8, так що явних параметрів типу не треба.]<br /></span> На наступних трьох рядках ви додаєте до мапи пари ключ/значення, використовуючи методи <code>-&gt;</code> та <code>+=</code>. Як вже було проілюстровано, компілятор Scala трансформує двомісні вирази операцій, як <code>1 -&gt; "Go to island."</code> на <code>(1).-&gt;("Go to island.")</code>. Таким чином, коли ви кажете <code>1 -&gt; "Go to island."</code>, ви насправді викликаєте метод на ім'я <code>-&gt;</code> на цілому зі значенням <code>1</code>, передаючи йому рядок зі значенням "Go to island." Цей метод <code>-&gt;</code>, який ви можете викликати на об'єкті в програмі Scala, повертає дво-елементний тапл, що містить ключ та значення.<span class="footnote"><br />[Механізм Scala, що дозволяє вам викликати  &#8594; на любому об'єкті, неявне перетворення, буде розкрите в Главі 21.]<br /></span> Потім ви можете передати тапл до метода <code>+=</code> об'єкта мапи, на який посилається <code>treasureMap</code>. Нарешті, останній рядок друкує значення, що відповідає ключу 2 treasureMap.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте цей код, він надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Find big X on ground.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви обираєте незмінну мапу, імпорт непотрібний, бо незмінна є мапою по замовчанню. Приклад показаний в Лістингу 3.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">romanNumeral</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;I&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;II&quot;</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;III&quot;</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="s">&quot;IV&quot;</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="s">&quot;V&quot;</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">romanNumeral</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.8 - Створення, ініціалізація та використання незмінної мапи.</p></div>
<div class="paragraph"><p>Зважаючи на те, що тут немає імпортів, ви можете сказати, що <code>Map</code> в першому рядку Лістинга 3.8 ви отримаєте замовчання, <code>scala.collection.immutable.Map</code>. Ви передаєте п'ять таплів ключ/значення до метода фабрики мапи, що повертає незмінну <code>Map</code>, яка містить передані пари ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__11____">Крок 11. Вчимсоь розпізнавати функціональний стиль</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, Scala дозволяє вам програмувати в імперативному стилі, але заохочує вас адоптувати більш функціональний стиль. Якщо ви прийшли в Scala з імперативного бекграунда, наприклад, якщо ви Java програміст, одним з головних викликів, з яким ви стикаєтесь при вивченні Scala є зрозуміти, як програмувати в функціональному стилі. Ми розуміємо, що цей стиль зпочатку може бути незвичним, але в цій книзі ми намагаємось направляти вас в цьому переході. Це буде потребувати деякої роботи з вашого боку, і ми закликаємо докласти зусиль. Якщо ви прийшли з імперативного бекграунду, ми віримо, що вивчення програмування в функціональному стилі не тільки зробить вам кращим програмістом Scala, але також розширить ваші горизонти, та зробить кращим програмістом взагалі.</p></div>
<div class="paragraph"><p>Перший крок це розпізнати різницю між двома стилями в коді. Один промовистий знак - це якщо код містить любі <code>var</code>, вірогідно що він в імперативному стилі. Якщо код взагалі не містить — тобто, він містить тільки <code>val</code> — вірогідно він в функціональному стилі. Таким чином, одним шляхом рухатись в функціональному стилі є спробувати програмувати без <code>var</code>.</p></div>
<div class="paragraph"><p>Якщо ви походите з імперативного бекграунда, як Java, C++ або C#, ви можете думати про <code>var</code> як про звичану змінну, та про <code>val</code> як про спеціальний різновид змінних. З іншого боку, якщо ви походите з функціонального бекграунда, як Haskell, OCaml або Erlang, ви можете думати про <code>val</code> як про звичану змінну, та <code>var</code> як спробу святотацтва. Однак перспектива Scala полягає в тому, що <code>val</code> та <code>var`є просто два різні інструменти в вашому наборі, обоє корисні, та жодний не є втілення зла. Scala заохочує вас вивчати щодо `val</code>, але кінець кінцем отримати кращий інструмент, що знадобиться для вашої роботи. Однак навіть якщо ви згодні з цією збалансованою філософією, ви все одно можете на початку знайти складним, як позбавитись від <code>var</code> в своєму коді.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо наступний цикл <code>while</code>, адаптований з Глави 2, що використовує <code>var</code>, та є, таким чином, в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трансформувати цей шматок коду в більш функціональний стиль, поклавши край <code>var</code>, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>або так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад ілюструє одну перевагу від програмування з меншою кількістю <code>var</code>. Рефактований (більш функціональний) код є чистіший, більш стислий, та менш схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з якої Scala заохочує до функціонального стилю, в тому, що він може допомогти вам писати більш зрозумілий, менш схильний до помилок код.</p></div>
<div class="paragraph"><p>Але ви можете пійти навіть далі. Рефакторений метод <code>printArgs</code> не є повністю функціональним, бо він має побічні ефекти — в цьому випадку цей побічний ефект є друк у стандартний вихідний потік. Промовистий знак що функція має побічні ефекти, це коли тип її результата Unit. Якщо функція не повертає жодного цікавого значення, що і означає тип результата Unit, єдиним шляхом, яким функція може зробити зміни в світі, че через деякий різновид побічного ефекту. Більше функціональний підхід може бути в визначенні метода, що форматує передані <code>args</code> для друку, але тільки повертає форматований рядок, як показано в Лістингу 3.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">args</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.9 - A function without side effects or vars.</p></div>
<div class="paragraph"><p>Тепер ви дійсно функціональні: немає ні побічних ефектів, ні <code>var</code> в полі зору. Метод <code>mkString</code>, який ви можете викликати на любій ітерабельній колекції (включаючи масиви, списки, множини та мапи), повкртає рядок, що складається з викликів <code>toString</code> на кожному елементі, розділені переданим рядком. Таким чином, якщо аргументи складаються з трьох аргументів, "zero", "one", "two", <code>formatArgs</code> буде повертати <code>"zero\none\ntwo"</code>. Звичайно, ця функція насправді не друкує нічого назовні, як робив метод <code>printArgs</code>, але ви можете просто передати його результат до <code>println</code>, щоб досягти цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожна корисна програма, вірогідно, буде мати побічні ефекти в деякій формі; інакше, буде неможливо провадити значення до зовнішнього світу. Схильність до методів без побічних ефектів заохочує вас розробляти програми, де код з побічними ефектами мінімізований. Одна з переваг цього підходу в тому, щоце може допомогти вашим програмам простіше тестуватись.</p></div>
<div class="paragraph"><p>Наприклад, щоб протестувати любий з трьох методів <code>printArgs</code>, показаних раніше в цьому розділі, вам треба перевизначити <code>println</code>, перехопити переданий йому вивід, та переконатись, що там те, що ви очікуєте. Для контрасту, ви можете тестувати функцію <code>formatArgs</code>, просто перевіряючи її результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">formatArgs</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="s">&quot;zero\none\ntwo&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод Scala <code>assert</code> перевіряє переданий їй <code>Boolean</code>, та якщо воно <code>false</code>, підіймає <code>AssertionError</code>. Якщо передане <code>Boolean</code> є <code>true</code>, <code>assert</code> просто повертає керування. Ви навчитесь більше щодо тверджень в тестах в Главі 14.</p></div>
<div class="paragraph"><p>Кажучи це, майте на увазі, що ні <code>var</code>, ні побічні ефекти не є природним злом. Scala не є чисто функціональною мовою, що змушує вас програмувати все в функціональному стилі. Scala є гібридною, імперативно/функціональною мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще підходить до вирішуваної проблеми, і в таких випадках вам не треба боятись використовувати його. Однак щоб допомогти вам навчитись, як програмувати без <code>var</code>, ми покажемо вам багато специфічних прикладів коду з <code>var</code>, та як трансформувати ці <code>val</code> в Главі 7.</p></div>
<div class="sect2">
<h3 id="____scala_">Збалансоване ставлення для Scala програмістів</h3>
<div class="paragraph"><p>Схиляйтесь до <code>val</code>, незмінних об'єктів та методів без побічних ефектів. Спочатку розпочніть з них. Використовуйте <code>var</code>, змінні об'єкти та методи з побочними ефектами, коли ви маєте специфічні потреби, та обгрунтування для них.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__12____">Крок 12. Читання рядків з файла</h2>
<div class="sectionbody">
<div class="paragraph"><p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробки рядків в файлі. В цьому розділі ви побудуєте скрипт, що читає рядки з файла, та друкує їх, проставляючи напочату кількість символів в кожному рядку. Перша версія показана в Лістингу 3.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">())</span>
    <span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.10 - Читання рядків з файла.</p></div>
<div class="paragraph"><p>Цей скрипт починається з імпорту класу на ім'я <code>Source</code> з пакунка  <code>scala.io</code>. Потім він перевіряє, щоб побачити, що в командному рядку був вказаний хоча б один аргумент. Якщо так, перший аргумент інтерпретується як ім'я файла, що треба відкрити та обробити. Вираз <code>Source.fromFile(args(0))</code> намагається відкрити вказаний файл, та повертає об'єкт <code>Source</code>, на якому ви викликаєте <code>getLines</code>. Метод <code>getLines</code> повертає <code>Iterator[String]</code>, що провадить по одному рядку на кожній ітерації, відкидаючи символ кінця рядка. Вираз <code>for</code> ітерує по цім рядках, та друкує для кожноого довжину рядка, проміжок, та сам рядок. Якщо в командному рядку не надано жодного аргументу, фінальне твердження <code>else</code> буде друкувати повідомлення в стандартний потік помилок. Якщо ви покладете цей код в файл на ім'я <code>countchars1.scala</code>, та викличете його для самого себе командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala countchars1.scala countchars1.scala</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51 for (line &lt;- Source.fromFile(args(0)).getLines())
37 println(line.length + " " + line)
1 }
4 else
46 Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Хоча скрипт в своїй поточній формі друкує потрібну інформацію, ви можете побажати підрівняти числа, вирівняти вправо, та додати символ роздільника, так щоб вивід виглядав так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 | import scala.io.Source
 0 |
22 | if (args.length &gt; 0) {
 0 |
51 |   for (line &lt;- Source.fromFile(args(0)).getLines())
37 |     println(line.length + " " + line)
 1 | }
 4 | else
46 |   Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Щоб досягти цього, ви можете ітерувати по рядках двічі. На першому проході ви будете визначати максимальну довжину, достатню для любого підрахунку символів. На другому проході ви друкуєте вивід, використовуючи максимальну ширину, що обчислена раніше. Оскільки ви будете ітерувати по рядках двічі, ми можете також присвоїти їх до змінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
</pre></div></div></div>
<div class="paragraph"><p>Заключний <code>toList</code> потрібне, бо метод <code>getLines</code> повертає ітератор. Коли ви проходите через ітератор, він вже витрачений. Трансформуючи його в список через виклик <code>toList</code>, ви отримаєте здатність ітерувати так багато раз, як вам треба, ціною зберігання всіх рядків з файла, одночасно. Таким чином, змінна <code>lines</code> посилається на список рядків, що складають вміст файла, вказаного в командному рядку. Далі, оскільки ми будемо обчислювати ширину довжини кожного рядка двічі, по разу для кожної ітерації, ви можете виділити цей вираз в невелику функцію, що обчислює скільки символів в ширину буде займати довжина рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>З такою функцією ви можете обчислювати максимальну ширину таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span>
  <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">maxWidth</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ви ітеруєте по кожному рядку за допомогою вираза <code>for</code>, обчислює символьну ширину довжини рядка, і якщо вона довша ніж поточний максимум, присвоюється до <code>maxWidth</code>, <code>var</code>, що була ініціалізована як 0. (Метод <code>max</code>, який ви можете викликати на Int, повертає більше зі значень, того, на якому вона викликана, та переданого як параметр). Альтернативно, якщо ви обираєте знайти максимум без <code>var</code>, ви можете спочатку знайти довший рядок, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>reduceLeft</code> застосовує передану функцію до перших двох елементів в <code>lines</code>, потім застосовує її до результату першої операції та наступного елементу в <code>lines</code>, і так далі, по всьому списку. На кожному такому застосуванні результат буде довшим рядком, знайденим до цього моменту, оскільки передана функція, <code>(a, b) =&gt; if (a.length &gt; b.length) a else b</code>, повертає довший з переданих рядків. <code>reduceLeft</code> буде повертати результат останнього застосування функції, що в цьому випадку буде найдовшим рядком-елементом, що міститься в <code>lines</code>.</p></div>
<div class="paragraph"><p>Маючи цей результат, ви можете обчислити максимальну ширину, передаючи найдовший рядок в <code>towidthOfLength</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що лишається, це надрукувати рядки з відповідним форматуванням. Ви можете зробити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
<span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
<span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому виразі ви ще раз ітеруєте по рядках. Для кожного рядка ви спочатку обчислюєте число проміжків, потрібних перед довжиною рядка, та присвоюєте його до <code>numSpaces</code>. Потім ви створюєте рядок, що містить <code>numSpaces</code> проміжків за допомогою вираза <code>" " * numSpaces</code>. Нарешті ви друкуєте інформацію з бажаним форматуванням. Повний скрипт виглядає як показано на Лістингу 3.11:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
  <span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
    <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
  <span class="o">)</span>
  <span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
    <span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.11 - Друкування форматованого підрахунку символів для рядків в файлі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__7">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зі знанням, що ви отримали в цій главі, ви повинні бути здатні почати використовувати Scala для малих завдань, особливо скриптів. В подальших главах ми будемо занурюватись далі в ці теми, та введемо інші теми, що не які тут не було натяку.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__4_2">Глава 4</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____4">Класи та об'єкти</h1>
<div class="paragraph"><p>Тепер ви побачили основи класів та об'єетів Scala з попередніх двох символів. В цій главі ми проведемо вас трохи глибше. Ви навчитесь більше щодо класів, полів те методів, та отримаєте огляд виводу крапки з комою. Ми обсудимо об'єкти синглтонів, включаючи як їх використовувати для написання та виконання застосування Scala. Якщо ви знайомі з Java, ви знайдете, що концепції Scala є подібними, але не саме такі самі. Так що навіть якщо ви Java гуру, все одно це читання варте того.</p></div>
<div class="sect1">
<h2 id="_4_1____">4.1 Класи, поля та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас є проектом об'єкту. Коли ви визначаєте клас, ви можете створити об'єкти з проекту класу за допомогою ключового слова <code>new</code>. Наприклад, маючи визначення класа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
<span class="c1">// class definition goes here</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити об'єкти <code>ChecksumAccumulator</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Всередині визначення класа ви покладаєте поля та методи, що разом називаються членами. Поля, що ви визначаєте за допомогою <code>val</code> або <code>var</code>, є змінними, що посилаються на об'єкти. Методи, що ви визначаєте за допомогою <code>def</code>, містять виконавчий код. Поля зберігають стан, або дані об'єкта, тоді як методи використовують ці дані, щоб зробити обчислювальну роботу об'єкта. Коли ви створюєте примірник класу, середовище виконання відкладає деяку пам'ять для зберігання образу стану об'єкта (тобто вмісту його змінних). Наприклад, так ви визначаєте клас <code>ChecksumAccumulator</code>, та даєте йому поле <code>var</code> на ім'я <code>sum</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>та двічі створюєте його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
<span class="k">val</span> <span class="n">csa</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Зображення об'єктів в пам'яті може виглядати так:</p></div>
<div class="paragraph"><p>Оскільки <code>sum</code>, поле, деклароване в класі <code>ChecksumAccumulator</code>, є <code>var</code>, не <code>val</code>, ви можете пізніше переприсвоїти <code>sum</code> інше значення  <code>Int</code>, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">acc</span><span class="o">.</span><span class="n">sum</span> <span class="k">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер картинка може виглядати ось так:</p></div>
<div class="paragraph"><p>Одна річ, що треба зауважити щодо цього малюнка, в тому, що тут дві змінні <code>sum</code>, одна в об'єкті, не який посилається <code>acc</code>, та інша в об'єкті, на який посилається <code>csa</code>. Поля також відомі як взмінні примірника, бо кожний примірник отримує свій власний набір змінних. Колективно, змінні примірника-об'єкта складають образ пам'яті об'єкта. Ви бачите ілюстрацію цього тут, не тільки тому що ви бачите дві змінні <code>sum</code>, але і через те, що коли змінюєте одну, це не впливає на іншу.</p></div>
<div class="paragraph"><p>Інша річ, на яку слід звернути увагу в цьому прикладі, це те, що ви були в змозі змінити об'єкт, на який посилається <code>acc</code>, навіть якщо сам <code>acc</code> <code>val</code>. Що ви не можете робити з <code>acc</code> (або csa), з гляду на те, що вони <code>val</code>, не <code>var</code>, це переприсвоїти їм інший об'єкт. Наприклад, наступна спроба схибить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Не буде компілюватись, бо acc є val</span>
<span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, все, на що ви можете розраховувати, це що <code>acc</code> буде завжди посилатись на той самий об'єкт <code>ChecksumAccumulator</code>, яким його ініціалізували, але поля, що містяться всередині цього об'єкта, можуть змінюваться з часом.</p></div>
<div class="paragraph"><p>Один важливий шлях досягти надійності об'єкта, є переконатись, що стан об'єкта — значення його змінних примірника — залишаються валідними під час цілого життєвого циклу. Перший крок є заборонити зовнішньому світу напряму отримувати доступ до полів, зробивши поля приватними. Оскільки приватні поля досяжні тільки з методів, визначених в тому ж класі, весь код, що може оновити стан, буде локалізований в класі. Щоб декларувати приватне поле, покладіть модифікатор доступу <code>private</code> перед полем, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи таку декларацію <code>ChecksumAccumulator</code>, люба спроба отримати доступ до <code>sum</code> ззовні класу буде невдалою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
<span class="n">acc</span><span class="o">.</span><span class="n">sum</span> <span class="k">=</span> <span class="mi">5</span> <span class="c1">// Не буде компілюватись, оскільки `sum` є приватним</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Спосіб, в який ви робите члени публічними в Scala, це не вказувати явно жодного модифікатора доступу. Інакше кажучи, там, де ви кажете <code>public</code> в Java, ви просто нічого не кажете в Scala. Публічний рівень доступу в Scala обираєтьмя по замовчанню.</td>
</tr></table>
</div>
<div class="paragraph"><p>Тепер, коли <code>sum</code> є <code>private</code>, єдиний код, що може отримати доступ до <code>sum</code> є код, визначений всередині тіла самого класа. Таким чином, <code>ChecksumAccumulator</code> не буде дуже корисним, якщо ми не визначимо деякі методи для нього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">def</span> <span class="n">checksum</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">return</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>ChecksumAccumulator</code> має два методи, <code>add</code> та <code>checksum</code>, обоє з яких демонструють базову форму визначення функції, показану на Малюнку 2.1.</p></div>
<div class="paragraph"><p>Любі параметри метода можуть бути використані всередині метода. Одна важлива характеристика пreasonараметрів метода в Scala в тому, що вони <code>val</code>, не <code>var</code>.<span class="footnote"><br />[Причина, з якої параметри є val в тому, що про val простіше розмірковувати. Ви більше не дивитесь, щоб визначити, чи val було перепризначене, як ви маєте робити з var.]<br /></span> Таким чином, якщо ви спробуєте переприсвоїти параметр всередині метода в Scala, це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">b</span> <span class="k">=</span> <span class="mi">1</span> <span class="c1">// Не буде компілюватись, оскільки b є val</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча <code>add</code> та <code>checksum</code> в цій версії <code>ChecksumAccumulator</code> коректно реалізують бажану функціональність, ви можете виразити їх в більш стислому стилі. Перше, <code>return</code> в кінці метода <code>checksum</code> є надлишковим і може бути відкінуте. За відсутності явного твердження  <code>return</code>, метод Scala повертає останнє значення, обчислене методом.</p></div>
<div class="paragraph"><p>Рекомендованим стилем для методів є, фактично, уникати мати явний, а особливо декілька, тверджень <code>return</code>. Замість цього думайте про кожний метод як про вираз, що видає одне значення, яке він повертає. Ця філософія буде надихати вас робити методи досіть малими, та ділити великі методи на декілька меньших. З іншого боку, вибір дизайну залежить від контексту, та Scala спрощує написання методів, що мають декілька явних <code>returns</code>, якщо це те, що ви задумали.</p></div>
<div class="paragraph"><p>Оскільки все, що робить <code>checksum</code> це обчислення значення, він не потребує явного <code>return</code>. Інше скорочення для методів є те, що ви можете опустити фігурні дужки, якщо метод тільки обчислює одне результуюче значення. Якщо результуючий вираз короткий, його навіть можна покласи в той же рядок, що і сам <code>def</code>. Для виключної стислості ви можете відкинути тип результату, і Scala виведе його. З ціма змінами, клас <code>ChecksumAccumulator</code> виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span> <span class="k">=</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span>
  <span class="k">def</span> <span class="n">checksum</span><span class="o">()</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча компілятор Scala буде коректно виводити типи результату методів <code>add</code> та <code>checksum</code>, показаних в попередньому прикладі, читачам коду буде треба подумки вивести ці типи результату, через дослідження тіла методів. Як результат, часто краще явно провадити типи результату публічних методів, декларованих в класі, навіть якщо компілятор може вивести його за вас. Лістинг 4.1 показує цей стиль.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file ChecksumAccumulator.scala</span>
<span class="k">class</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">b</span> <span class="o">}</span>
  <span class="k">def</span> <span class="n">checksum</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.1 - Фінальна версія класу ChecksumAccumulator.</p></div>
<div class="paragraph"><p>Методи з типом результата Unit, такі як метод <code>add</code> в ChecksumAccumulator, виконуються заради своїх побочних ефектів. Побічний ефект в основному визначений як зміна стану десь зовні до метода, або виконання операції I/O. В випадку <code>add</code> побічний ефект полягає в переприсвоєнні змінної <code>sum</code>. Метод, що виконується виключно ради побічних ефектів, також відомий як процедура.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_2____">4.2 Вивід крапки з комою</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala програмах крапка з комою в кінці твердження часто є опціональними. Ви можете ставити їх, якщо бажаєте, але не зобов'язані робити це, якщо рядок сам по собі розташований на одному рядку. З іншого боку, крапка з комою обов'язкові, якщо ви маєте декілька тверджень в одному рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span><span class="o">;</span> <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте ввести твердження, що займає декілька рядків, більшість часу ви можете просто покласти її, і Scala поділить тврдження в коректному місці. Наприклад, наступне трактується як однорядкове твердження:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;too small&quot;</span><span class="o">)</span>
<span class="k">else</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;ok&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак часом Scala буде ділити твердження на дві частини проти вашого бажання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span>
<span class="o">+</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Це розбирається як два твердження, <code>x</code> та <code>+y</code>. Якщо вашим наміром було розібрати це як одне твердження <code>x + y</code>, ви завжди можете огорнути це в дужки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span>
<span class="o">+</span> <span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Альтернативно, ви можете покласти <code>+</code> в кінці рядка. Тільки з цієї причини, коли ви зціплююте інфіксні операції, такі як <code>+</code>, є загальним стилем Scala покладати оператор в кінці рядка, а не напочатку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span>
<span class="n">y</span> <span class="o">+</span>
<span class="n">z</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="______3">Правила виводу крапок з комою</h3>
<div class="paragraph"><p>Точні правила для розділення тверджень дивуюче прості, як для того, як гарно вони роблять. Коротко, кінці рядків трактуються як крапка з комою, за винятком коли вірне одна умова з наступних:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Розглядаємий рядок завершується на слово, яке не може бути легальним в кінці твердження, таке, як крапка або інфіксний оператор.
</p>
</li>
<li>
<p>
Наступний рядок починається зі слова, що не може починати твердження.
</p>
</li>
<li>
<p>
Рядок завершується, коли відкриті дужки (&#8230;) або [&#8230;], оскільки вони в жодному разі не можуть містити декілька тверджень.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_3___">4.3 Об'єкти синглтонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, один спосіб, в який Scala більш об'єктно-орієнтована, ніж Java, це що класи в Scala. Замість цього,  Scala має об'єкти синглтонів. Визначення об'єкта синглтона виглядає як визначення класу, за винятком того, що замість ключового слова <code>class</code> ви використовуєте ключове слово <code>object</code>. Лістинг 4.2 показує приклад.</p></div>
<div class="paragraph"><p>Об'єкт синглтона на цій фігурі названий <code>ChecksumAccumulator</code>, те саме, що і ім'я класу в попередньому прикладі. Коли сінглтон поділяє те саме ім'я з класом, він називається об'єктом компанйоном класа. Ви маєте обох, клас та його об'єкт компанйон в тому ж джерельному файлі. Клас називається компанйон класом об'єкта синглтона. Клас та його об'єкт компанйон можуть отримувати доступ до приватних членів один одного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file ChecksumAccumulator.scala</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">object</span> <span class="nc">ChecksumAccumulator</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">calculate</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
      <span class="n">cache</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">acc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ChecksumAccumulator</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">c</span> <span class="k">&lt;-</span> <span class="n">s</span><span class="o">)</span>
        <span class="n">acc</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">c</span><span class="o">.</span><span class="n">toByte</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="n">acc</span><span class="o">.</span><span class="n">checksum</span><span class="o">()</span>
      <span class="n">cache</span> <span class="o">+=</span> <span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">cs</span><span class="o">)</span>
      <span class="n">cs</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.2 - Об'єкт компанйон для класа ChecksumAccumulator.</p></div>
<div class="paragraph"><p>Об'єкт сінглтон <code>ChecksumAccumulator</code> має один метод з назвою <code>calculate</code>, що приймає <code>String</code>, та обчислює контрольну суму для символів в <code>String</code>. Він також має одне приватне поле, <code>cache</code>, змінну мапу, в якій кешуються попередньо обчислені контрольні суми.<span class="footnote"><br />[Ми використовуємо тут кеш, щоб показати об'єкт синглтон з полем. Кеш, такий як цей, є оптимізацією продуктивності, що міняє пам'ять на час обчислення. Загалом, ви мали б використовувати такий архів, тільки якщо натрапили на проблему продуктивності, яку може вирішити кеш, та можливо використовувати слабку мапу, таку як <code>WeakHashMap</code> в <code>scala.collection.jcl</code>, так що елементи цього кеша підпали б під збирання сміття, коли з пам'ятю стало скрутно.]<br /></span> Перший рядок цього метода, <code>if (cache.contains(s))</code>, перевіряє кеш, чи переданий рядок вже існує як ключ в кеші. Якщо так, він просто повертає відображене значення, кеш(і). Інакше, він виконує варіант <code>else</code>, що обчислює контрольну суму. Перший рядок <code>else</code> визначає <code>val</code> на ім'я <code>acc</code>, та ініціалізує її новим примірником <code>ChecksumAccumulator</code>.<span class="footnote"><br />[Оскільки ключове слово  <code>new</code> використовується тільки для створення класів, новий створений тут об'єкт є примірником класу <code>ChecksumAccumulator</code>, не об'єкта синглтона з тим самим іменем.]<br /></span> Наступний рядок є виразом <code>for</code>, що проходить по кожному символу в переданому рядку, конвертуючи символ на Byte, через виклик toByte на ньому, та передає його до метода  <code>add</code> примірника <code>ChecksumAccumulator</code>, на який посилається <code>acc</code>. Після завершення виразу <code>for</code>, наступний рядок метода викликає <code>checksum</code> на <code>acc</code>, що отримує контрольну суму для переданого <code>String</code>, та зберігає його в <code>val</code> на ім'я <code>cs</code>. В наступному рядку, <code>cache += (s -&gt; cs)</code>, переданий рядок-ключ відзеркалюється на ціле значення контрольної суми, і ця пара ключ-значення додається до мапи <code>cache</code>. Останній вираз метода, <code>cs</code>, запевняє, що контрольна сума є результатом метода.</p></div>
<div class="paragraph"><p>ЯКщо ви Java програміст, один спосіб щоб думати про об'єкт синглтон як про домівку для любих статичних методів, що ви могли написати в  Java. Ви можете викликати методи на об'єкті синглтоні, використовуючи подібний синтаксис: ім'я об'єкта синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати метод <code>calculate</code> об'єкта синглтона таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">ChecksumAccumulator</span><span class="o">.</span><span class="n">calculate</span><span class="o">(</span><span class="s">&quot;Every value is an object.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак об'єкт синглтон є більше, ніж утримувач статичних методів. Це першокласний об'єкт. Ви можете думати про ім'я об'єкта синглтона, таким чином, як про "тег імені", приєднаного до об'єкту:</p></div>
<div class="paragraph"><p>Визначення об'єкта синглтона не визначає тип (на рівні абстракції Scala). Маючи тільки визначення об'єкту ChecksumAccumulator, ви не зможете створити змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator визначається через клас компанйон об'єкта синглтона. Однак, синглтон об'єкти розширюють суперклас, та можуть міксувати трейти. Беручи, що кожний об'єкт синглтон є примірником свого суперкласу та примішаних трейтів, ви можете викликати його методи через ці типи, посилатись на нього через змінні ціх типів, та передавати його методам, що очікують ці типи. Ми покажемо деякі приклади об'єктів синглтонів, що наслідують від класів та трейтів в Главі 13.</p></div>
<div class="paragraph"><p>Одна відмінність між класами та об'єктами синглтонами в тому, що синглтон об'єкт не може приймати параметрів, тоді як клас може. Оскільки ви не можете створити примірник синглтон об'єкта за допомогою ключового слова <code>new</code>,ви не маєте способа передати йому параметри. Кожний синглтон об'єкт був реалізований як примірник синтетичного класу, на який посилається статична змінна, так що вони мають ту саму семантику ініціалізації, що і статики в Java.<span class="footnote"><br />[Ім'я синтетичного класу є ім'я об'єкту, плюс знак долару. Таким чином, синтетичний клас для об'єкта синглтона на ім'я ChecksumAccumulator є ChecksumAccumulator$.]<br /></span> Зокрема, об'єкт синглтон буде ініціалізований, коли код отримає до нього доступ в перший раз.</p></div>
<div class="paragraph"><p>Синглтон, що не поділяє те саме ім'я з класом компанйоном, називається окремим об'єктом. Ви можете використовувати окремі об'єкти для багатьох призначень, включаючи збір пов'язаних допоміжних методів, або визначення точки входу в застосування Scala. Цей випадок застосування показаний в наступному розділі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_4__scala">4.4 Застосування Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб виконати Scala програму, ви маєте надати ім'я окремого об'єкта синглтона з методом <code>main</code>, що приймає один параметр, <code>Array[String]</code>, та має тип результата Unit. Любий окремий об'єкт з методом <code>main</code> відповідної сигнатури, може бути використаний як вхідна точка в застосування. Приклад показаний в Лістингу 4.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// In file Summer.scala</span>
<span class="k">import</span> <span class="nn">ChecksumAccumulator.calculate</span>
<span class="k">object</span> <span class="nc">Summer</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
       <span class="n">println</span><span class="o">(</span><span class="n">arg</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.3 - Застосування Summer.</p></div>
<div class="paragraph"><p>Ім'я об'єкта синглтона в Лістенгу 4.3 є Summer. Його метод <code>main</code> має відповідну сигнатуру, так що ви можете використовувати його як застосування. Перше твердження в файлі є імпорт метода <code>calculate</code>, визначеного в об'єкті ChecksumAccumulator в попередньому прикладі. Це твердження <code>import</code> дозволяє вам використовувати просте ім'я метода в залишку файла.<span class="footnote"><br />[Якщо ви Java програміст, ви можете думати про цей імпорт, як про можливість статичного імпорту, введену в Java 5. Однак в Scala є одна різниця, в тому, що ви можете імпортувати члени з любого об'єкта, не тільки з об'єктів синглтонів.]<br /></span> Тіло метода <code>main</code> просто друкує кожний аргумент, та контрольну суму для аргумена, відділену роздільником.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Scala неявно імпортує члени пакунків <code>java.lang</code> та <code>scala</code>, так само, як члени об'єкта синглтона на ім'я <code>Predef</code>, в кожний джерельний файл Scala. <code>Predef</code>, що знаходиться в пакунку <code>scala</code>, містить багато корисних методів. Наприклад, коли ви кажете <code>println</code> в джерельному файлі Scala, насправді ви викликаєте <code>println</code> на <code>Predef</code>. (<code>Predef.println</code> обертається, та викликає <code>Console.println</code>, що робить реальну роботу). Коли ви кажете <code>assert</code>, ви викликаєте <code>Predef.assert</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Щоб виконати застосування Summer, покладіть код з Лістинга 4.3 в файл з назвою Summer.scala. Оскільки <code>Summer</code> використовує <code>ChecksumAccumulator</code>, покладіть код для <code>ChecksumAccumulator</code>, обоє, клас, показаний в Лістингу 4.1, та його об'єкт компанйон, показаний в Лістингу 4.2, в файл на ім'я <code>ChecksumAccumulator.scala</code>.</p></div>
<div class="paragraph"><p>Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви покладали публічні класи в файл з іменем класа — наприклад, ви поклали клас <code>SpeedRacer</code> в файл <code>SpeedRacer.java</code> — в Scala ви можете називати <code>.scala</code> файли як побажаєте, не важливо, які Scala класи або код ви покладете до них. Однак загалом, в випадку не-скриптів, є рекомендованим стилем називати файли по іменах класів, які вони містять, як це зроблено в Java, так що програмісти можуть більш просто знайти класи, шукаючи по іменах файлів. Цей підхід, що ми прийняли для двох файлів в цьому  прикладі, <code>Summer.scala</code> та <code>ChecksumAccumulator.scala</code>.</p></div>
<div class="paragraph"><p>Ні <code>ChecksumAccumulator.scala</code>, ані <code>Summer.scala</code> не є скриптами, бо закінчуються на визначення. Скрипт, для контрасту, має завершуватись на вираз результату. Так що якщо ви спробуєте виконати <code>Summer.scala</code> як скрипт, інтерпретатор Scala буде скаржитись, що <code>Summer.scala</code> не завершується на вираз результату (вважаємо, звичайно, що ви не додали якийсь вираз після визначення об'єкта  <code>Summer</code>). Замість цього, вам буде треба насправді скомпілювати ці файли за допомогою Scala компілятора, та потім виконати отримані файли <code>class</code>. Один шлях зробити це є використання <code>scalac</code>, що є базовим компілятором Scala, ось так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scalac ChecksumAccumulator.scala Summer.scala</code></pre>
</div></div>
<div class="paragraph"><p>Це компілює ваш джерельний файл, але може бути відчутна затримка перед завершенням компіляції. Причина в тому, що кожного разу, коли запускається компілятор, він витрачає час, скануючі вміст jar файлів, та роблячи іншу роботу з ініціалізації, перед тим, як він навіть тільки погляне не нові джерельні файли, яки ви надіслали йому. З цієї причини дистрибутив Scala також включає демон компіляції Scala з назвою <code>fsc</code> (fast Scala compiler). Ви використовуєте його таким чином:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ fsc ChecksumAccumulator.scala Summer.scala</code></pre>
</div></div>
<div class="paragraph"><p>Перший раз, як ви запустите <code>fsc</code>, він створить локальний демон сервера, підключений до порту вашого комп'ютера. Потім він буде надсилати список файлів на компіляцію до демона через порт, і демон буде компілювати ці файли. Наступний раз, коли ви виконаєте <code>fsc</code>, демон вже буде запущений, так що <code>fsc</code> буде просто посилати список файлів до демона, що буде безпосередньо компілювати ці файли. Використовуючи <code>fsc</code>, вам треба чекати тільки щоб рантайм Java запустився в перший раз. Якщо ви колись побажаєте запинити демона <code>fsc</code>, ви можете зробити це за допомогою <code>fsc - shutdown</code>.</p></div>
<div class="paragraph"><p>Виконання любого з них, команди <code>scalac</code> або <code>fsc</code>, буде продукувати файли класів Java, які ви потім можете виконати через команду <code>scala</code>, ту саму команду, що ви використовували для виклику інтерпретатора в попередніх прикладах. Оданак замість надання їй файла з розширенням <code>.scala</code>, що містить код Scala для інтерпретації, як ви робили в кожному попередньому прикладі,<span class="footnote"><br />[Справжній механізм, який програма <code>scala</code> використовує для "інтерпретації" джерельного файлу Scala, є те, що вона компілює джерельний код Scala в байткоди Java, безпосередньо завантажує їх через завантажувач класів, та виконує їх.]<br /></span> в цьому випадку ви дасте їй ім'я окремого об'єкту, що має метод <code>main</code> з відповідною сигнатурою. Ви можете виконати застосування Summer, таким чином, набравши:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala Summer of love</code></pre>
</div></div>
<div class="paragraph"><p>Ви побачите контрольні суми, роздруковані для двох аргументів командного рядка:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>of: -213
love: -182</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_5__app">4.5 Трейт App</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить трейт <code>scala.App</code>, що може зберігти вам деякий час за друком. Хоча ми ще не розглянули все, що вам треба для розуміння саме як цей трейт робить, ми припускаємо, що ви бажаєте знати про це саме зараз, будь-що. Лістинг 4.4 показує приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">ChecksumAccumulator.calculate</span>
<span class="k">object</span> <span class="nc">FallWinterSpringSummer</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">season</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;fall&quot;</span><span class="o">,</span> <span class="s">&quot;winter&quot;</span><span class="o">,</span> <span class="s">&quot;spring&quot;</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">season</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">calculate</span><span class="o">(</span><span class="n">season</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 4.4 - Використання трейта App.</p></div>
<div class="paragraph"><p>Щоб використати цей трейт, зпочатку ви пишете <code>extends App</code> після імені вашого синглтон об'єкта. Потім замість писати метод <code>main</code>, ви кладете код, що ви б мали покласти в метод <code>main</code>, прямо між фігурними дужками об'єкта синглтона. Ви можете отримати доступ до аргументів командного рядка через масив рядків на ім'я <code>args</code>. Це все. Ви можете компілювати та виконувати це застосування, так само як любе інше.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_6_">4.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала вам основи класів та об'єктів в Scala, та показала вам, як компілювати та виконувати застосування. В наступній главі ми вивчимо базові типи Scala, та як їх використовувати.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__5_2">Глава 5</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____5">Базові типи і операції</h1>
<div class="paragraph"><p>Тепер, коли ви побачили класи і об'єкти в дії, настав гарний час подивитись на базові типи та операції Scala більш глибоко. Якщо ви знайомі з Java, ви будете раді узнати, що базові типи і операції  Java мають те саме значення в Scala. Однак є деякі цікаві розбіжності, що роблять цю главу варту прочитання, навіть якщо ви досвідчений Java розробник. Оскільки деякі аспекти Scala, розглянуті в цій главі в основі ти самі, що і в Java, ми вставили зауваження, що ці частини Java розробники можуть пропустити.</p></div>
<div class="paragraph"><p>В цій главі ви отримаєте огляд базових класів Scala, включаючи  <code>String</code> та типи значень, <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>, <code>Double</code>, <code>Char</code>, та <code>Boolean</code>. Ви вивчите операції, що ви можете виконувати з ціма типами, включаючи те, як робить преоритетність операторів в виразах Scala. Ви також вивчите, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи додаткові операції, крім тих, що підтримуються в Java.</p></div>
<div class="sect1">
<h2 id="_5_1___">5.1 Деякі базові типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Декілька фундаментальних типів Scala, разом и диапазонами знічень ціх типів, яки вони можуть приймати, показані в Таблиці 5.1. Загалом типи <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code> та <code>Char</code> називаються інтегральними типами. Інтегральні типи разом з <code>Float</code> та <code>Double</code> називаються числовими типами.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі базові типи</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Диапазон</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="left" valign="top"><p class="table">8-бітне ціле зі знаком (від -2<sup>7</sup> до 2<sup>7</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="left" valign="top"><p class="table">16-бітне ціле зі знаком (від -2<sup>15</sup> до 2<sup>15</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="left" valign="top"><p class="table">32-бітне ціле зі знаком (від -2<sup>31</sup> до 2<sup>31</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="left" valign="top"><p class="table">64-бітне ціле зі знаком (від -2<sup>63</sup> до 2<sup>63</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="left" valign="top"><p class="table">16-бітний беззнаковий символ Unicode (від 0 до 2<sup>16</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">послідовність Char</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="left" valign="top"><p class="table">32-бітне IEEE 754 з плаваючою крапкою одинарна точність</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="left" valign="top"><p class="table">64-бітне IEEE 754 з плаваючою крапкою подвійна</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="left" valign="top"><p class="table">true або false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Всі крім <code>String</code>, що знаходиться в пакунку <code>java.lang</code>, всі типи, показані в Таблиці 5.1 є членами пакунку <code>scala</code>.<span class="footnote"><br />[Пакунки, що були коротко описані на Кроці 1 в Главі 2, будуть розглянуті глибоко в Главі 13.]<br /></span> Наприклад, повне ім'я <code>Int</code> є <code>scala.Int</code>. Однак беручи, що всі члени з пакунку <code>scala</code> та <code>java.lang</code> автоматично імпортуються в кожний джерельний файл Scala, ви можете використовувати самі прості імена (тобто імена як Boolean, Char, або String) будь-де.</p></div>
<div class="paragraph"><p>Допитливі Java розробники зауважать, базові типи Scala мають ті самі диапазони, що і відповідні типи в Java. Це дозволяє компілятору  Scala трансформувати примірники значень Scala, такі як <code>Int</code> або <code>Double</code>, до примітивних типів Java в спродукованому байткоді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2_">5.2 Літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі базові типи, перелічені в Таблиці 5.1 можуть бути записані як літерали. Літерал - це шлях написати стале значення прямо в коді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java_">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис більшосі літералів, показаних в цьому розділі, є саме таким, як і в Java, так що якщо ви майстер Java, ви можете безпечно пропустити більшість цього розділу. Деякі розбіжності з описаних тут ви можете прочитати щодо Scala літералів для сирих рядків та символів, а також про інтерполяцію рядків. Також Scala не підтримує восьмиричні літерали; цілі літерали, що починаються з нуля, такі як  031, не будуть компілюватись.</p></div>
<div class="sect2">
<h3 id="___5">Цілі літерали</h3>
<div class="paragraph"><p>Цілі літерали для типів <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code> ідуть в двох форматах: десятичному та шістнадцятиричному. Від того, з чого починається літерал, залежить основа числа. Якщо число починається з 0x або 0X, це шістнадцятирічне (основа 16), та може містити цифри від 0 до 9, так само як літери в верхньому або нижньому реєстрі від A до F. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hex</span> <span class="k">=</span> <span class="mh">0x5</span>
<span class="n">hex</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hex2</span> <span class="k">=</span> <span class="mh">0x00FF</span>
<span class="n">hex2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">magic</span> <span class="k">=</span> <span class="mh">0xcafebabe</span>
<span class="n">magic</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">889275714</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що оболонка Scala завжди друкує цілі значення по основі 10, не важливо, якою формою літерала ви ініціалізували її. Таким чином, інтерпретатор відображує значення змінної <code>hex2</code>, що ви ініціалізували літералом <code>0x00FF</code> як десятичне <code>255</code>. (Звичайно, ви не маєте вірити нам на слово. Гарний спосіб почати відчувати мову є спробувати твердження в інтерпретаторі по мірі читання цієї глави.) Якщо число починається з не-нульової цифри, воно десяткове (основа
10). Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec1</span> <span class="k">=</span> <span class="mi">31</span>
<span class="n">dec1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">31</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec2</span> <span class="k">=</span> <span class="mi">255</span>
<span class="n">dec2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec3</span> <span class="k">=</span> <span class="mi">20</span>
<span class="n">dec3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо цілий літерал закінчується на L або l, це <code>Long</code>; інакше це <code>Int</code>. Деякі приклади <code>Long</code> літералів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">prog</span> <span class="k">=</span> <span class="mi">0</span><span class="nc">XCAFEBABEL</span>
<span class="n">prog</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">3405691582</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">tower</span> <span class="k">=</span> <span class="mi">35L</span>
<span class="n">tower</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">35</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">of</span> <span class="k">=</span> <span class="mi">31</span><span class="n">l</span>
<span class="n">of</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">31</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>Int</code> літерал присвоюється змінній <code>Short</code> або <code>Byte</code>, литерал розглядається як би він був <code>Short</code> або <code>Byte</code>, доки значення літерала в валідному диапазоні. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">little</span><span class="k">:</span> <span class="kt">Short</span> <span class="o">=</span> <span class="mi">367</span>
<span class="n">little</span><span class="k">:</span> <span class="kt">Short</span> <span class="o">=</span> <span class="mi">367</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">littler</span><span class="k">:</span> <span class="kt">Byte</span> <span class="o">=</span> <span class="mi">38</span>
<span class="n">littler</span><span class="k">:</span> <span class="kt">Byte</span> <span class="o">=</span> <span class="mi">38</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____6">Літерали з плаваючою крапкою</h3>
<div class="paragraph"><p>Літерали з плаваючою крапкою складаються з десятичних цифр, опціонально містять десятичну крапку, опціонально далі іде E або e та експонента. Деякі приклади літералів з плаваючою крапкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">big</span> <span class="k">=</span> <span class="mf">1.2345</span>
<span class="n">big</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.2345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bigger</span> <span class="k">=</span> <span class="mf">1.2345e1</span>
<span class="n">bigger</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">12.345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">biggerStill</span> <span class="k">=</span> <span class="mi">123</span><span class="n">E45</span>
<span class="n">biggerStill</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.23E47</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що частина експоненти означає ступінь десяти, на яку домножається інша частина. Таким чином 1.2345e1 є 1.2345 разів по 10<sup>1</sup>, що є 12.345. Якщо літерал з плаваючою крапкою завершується на F або f, це <code>Float</code>; інакше це <code>Double</code>. Опціонально, літерал з плаваючою крапкою <code>Double</code> може завершуватись на D або d. Деякі приклади літералів <code>Float</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">little</span> <span class="k">=</span> <span class="mf">1.2345F</span>
<span class="n">little</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">1.2345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">littleBigger</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5f</span>
<span class="n">littleBigger</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">300000.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Це останнє значення, виражене як <code>Double</code> може приймати такі (ті інші) форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">anotherDouble</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5</span>
<span class="n">anotherDouble</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">300000.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">yetAnother</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5D</span>
<span class="n">yetAnother</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">300000.0</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___6">Символі літерали</h3>
<div class="paragraph"><p>Символьні літерали складаються з Unicode символа між поодинокими лапками, такі як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="sc">&#39;A&#39;</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">A</span>
</pre></div></div></div>
<div class="paragraph"><p>На додаток до провадження явного символа між поодинокими лапками, ви можете сказати символ, використовуючи кодову точку Unicode. Щоб зробити це, запишіть \u, за якими чотири шіснадцятиричних цифри кодовою точки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="sc">&#39;\u0041&#39;</span>
<span class="n">d</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">A</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="sc">&#39;\u0044&#39;</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">D</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, такі Unicode символи можуть з'являтись будь-де в програмі Scala. Наприклад, ви можете також написати ідентифікатор таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">B</span><span class="o">\</span><span class="n">u0041</span><span class="o">\</span><span class="n">u0044</span> <span class="k">=</span> <span class="mi">1</span>
<span class="nc">BAD</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей ідентифікатор розглядається як ідентичний до BAD, результат двох Unicode символів в коді вище. Загалом це погана ідея називати ідентифікатори таким чином, оскільки їх важко читати. Скоріше цей синтаксис призначений щоб дозволити джерельним файлам Scala, що містять не-ASCII Unicode символи бути представленими в ASCII.</p></div>
<div class="paragraph"><p>Нарешті, існують також декілька літералів, представлених спеціалними ескейп виключеннями, показаними в Таблиці 5.2. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">backslash</span> <span class="k">=</span> <span class="sc">&#39;\\&#39;</span>
<span class="n">backslash</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="o">\</span>
</pre></div></div></div>
<div class="paragraph"><p>Специальні символи, ескейп послідовності</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Літерал </th>
<th align="center" valign="top"> Значення</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">\n</p></td>
<td align="center" valign="top"><p class="table">перевод рядка (\u000A)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\b</p></td>
<td align="center" valign="top"><p class="table">сторно (\u0008)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\t</p></td>
<td align="center" valign="top"><p class="table">табуляція (\u0009)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\f</p></td>
<td align="center" valign="top"><p class="table">нова сторінка (\u000C)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\r</p></td>
<td align="center" valign="top"><p class="table">повернення каретки (\u000D)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\"</p></td>
<td align="center" valign="top"><p class="table">подвійні лапки (\u0022)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\'</p></td>
<td align="center" valign="top"><p class="table">поодинокі лапки (\u0027)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\\</p></td>
<td align="center" valign="top"><p class="table">зворотня коса (\u005C)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="___7">Рядкові літерали</h3>
<div class="paragraph"><p>Рядкові літерали складаються з символів в подвійних лапках:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hello</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">hello</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span>
</pre></div></div></div>
<div class="paragraph"><p>Стнтаксис символів в дужках той самий, як і в символьних літералах. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">escapes</span> <span class="k">=</span> <span class="s">&quot;\\\&quot;\&#39;&quot;</span>
<span class="n">escapes</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">\</span><span class="err">&quot;&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки цей синтаксис незручний для рядків, що містять багато ескейп послідовностей, або рядків, що перетинають багато рядків,  Scala включає особливий синтаксис для сирих рядків. Ви починаєте та завершуєте сирий рядок трьома подвійними лапками поспіль ("""). Внутрішність сирого рядка може містити любі символи, будь-що, включаючи нові рядки, лапки, спеціальні символи, за винятком, зрозуміло, тьох подвійних лапок повпіль. Наприклад, наступна програма друкує повідомлення використовуючи сирий рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">&quot;&quot;&quot;Welcome to Ultamix 3000.</span>
<span class="s">           Type &quot;HELP&quot; for help.&quot;&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак виконання цього кода не продукує саме те, що задумане:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Welcome to Ultamix 3000.
           Type "HELP" for help.</code></pre>
</div></div>
<div class="paragraph"><p>Проблема в тому, що початкові проміжки в другому рядку включені в рядок! Щоб допомогти в цій загальній ситуації, ви можете викликати для рядків stripMargin. Щоб використати цей метод, покладіть символ роздільника (|) спереду кожного рядка, та потім викличте  <code>stripMargin</code> для цілого рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">&quot;&quot;&quot;|Welcome to Ultamix 3000.</span>
<span class="s">           |Type &quot;HELP&quot; for help.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">stripMargin</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер код поводиться як задумано:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Welcome to Ultamix 3000.
Type "HELP" for help.</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="___8">Символьні літерали</h3>
<div class="paragraph"><p>Символьний літерал записується <code>'ident</code>, де <code>ident</code> може бути любим ідентифікатором з літер та цифр. Такі літерали відображуються на примірники передвизначеного класу <code>scala.Symbol</code>. Зокрема, літерал <code>'cymbal</code> буде розширений компілятором до виклику метода фабрики: <code>Symbol("cymbal")</code>. Символьні літерали типово використовуються в ситуаціях, де ви можете використовувати ідентифікатор в динамічно типизованих мовах. Наприклад, ви можете побажати визначити метод, що оновлює запис в базі даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
<span class="c1">// code goes here</span>
<span class="o">}</span>
<span class="n">updateRecordByName</span><span class="k">:</span> <span class="o">(</span><span class="kt">Symbol</span><span class="o">,</span><span class="kt">Any</span><span class="o">)</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод приймає в якості параметра символ, що вказує ім'я поля запису,в яке траба внести зміни. В динамічно типизованих ви можете визвати цю операцію, передаючи в метод недекларований ідентифікатор поля, але в Scala це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class="n">favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="kt">value</span> <span class="kt">favoriteAlbum</span>
<span class="n">updateRecordByName</span><span class="o">(</span><span class="n">favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього, і майже так стисло, ви можете передати символьний літерал:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class=" -Symbol">&#39;favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З символом ви можете робити не дуже багато чого, крім з'ясувати його ім'я:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class=" -Symbol">&#39;aSymbol</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">Symbol</span> <span class="o">=</span> <span class=" -Symbol">&#39;aSymbol</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nm</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="n">nm</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">aSymbol</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша річ, що варта уваги, це те, що символи інтерновані. Якщо ви пишете той самий літерал двічі, обоє вирази будуть посилатись на той самий об'єкт <code>Symbol</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___9">Логічні літерали</h3>
<div class="paragraph"><p>Тип Boolean має два літерала, <code>true</code> та <code>false</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bool</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">bool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fool</span> <span class="k">=</span> <span class="kc">false</span>
<span class="n">fool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Це все щодо цього. Тепер ви буквально експерт в Scala.<span class="footnote"><br />[фігурально кажучи]<br /></span></p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_3__">5.3 Інтерполяція рядків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala включає гнучкий механізм для інтерполяції рядків, що дозполяє вам вбудовувати вирази в рядкові літерали. Її найбільш загальний випадок викорстання є провадження стислої та читабельної альтернативи до конкатенації рядків. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;reader&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="s">s&quot;Hello, </span><span class="si">$name</span><span class="s">!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>s"Hello, $name!"</code> є обробляємий рядковий літерал. Оскільки літера <code>s</code> безпосередньо передує відкриваючим лапкам, Scala скала буде використовувати інтерполяцію рядка <code>s</code> для обробки літерала. Цей <code>s</code> інтерполятор буде обчислювати кожний вбудований вираз, викликаючи <code>toString</code> для кожного результата, та замінює вбудовані вирази в літералі на ці результати. Таким чином, <code>s"Hello, $name!"</code> дає <code>"Hello, reader!"</code>, той самий результат, що і <code>"Hello, " + name + "!"</code>.</p></div>
<div class="paragraph"><p>Ви можете покласти любий вираз після знаку долара ($) в оброблюваний рядковий літерал. Для одно-змінних виразів, ви часто можете ім'я змінної після знаку долару. Scala буде інтерпретувати всі символи до першого не-ідентифікаторного символа як вираз. Якщо вираз включає не-ідентифікаторні символи, ви маєте покласли його в фігурні дужки, з відкриваючою дужкою прямо за знаком долара. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">s&quot;The answer is </span><span class="si">${</span><span class="mi">6</span> <span class="o">*</span> <span class="mi">7</span><span class="si">}</span><span class="s">.&quot;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">The</span> <span class="n">answer</span> <span class="n">is</span> <span class="mf">42.</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala провадить два інші інтерполятора по замовчанню: <code>raw</code> та <code>f</code>. Інтерпретатор рядків <code>raw</code> поводиться як <code>s</code>, за винятком того, що він не розпізнає сивольні літерали ескейп послідовності (такі як показані в Таблиці 5.2). Наприклад, наступне твердження друкує чотири зворотні косі, не дві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">raw&quot;No\\\\escape!&quot;</span><span class="o">)</span> <span class="c1">// prints: No\\\\escape!</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерполятор рядка <code>f</code> дозволяє вам додати вам інструкції форматування в стилі <code>printf</code> для вбудованих виразів. Ви покладаєте інструкції після виразу, починаючи зі знака відсотків (%), використовуючи синтаксис, заданий в <code>java.util.Formatter</code>. Наприклад, ось як ви можете форматувати число pi</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">f&quot;</span><span class="si">${</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="si">}</span><span class="s">%.5f&quot;</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mf">3.14159</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви не провадите інструкцій форматування для вбудованого виразу, рядковий інтерпретатор <code>f</code> буде по замовчанню вважати <code>%s</code>, що означає, що буде підставлено значення <code>toString</code>, так само як інтерпретатор рядків <code>s</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="s">&quot;Pi&quot;</span>
<span class="n">pi</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Pi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="s">f&quot;</span><span class="si">$pi</span><span class="s"> is approximately </span><span class="si">${</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="si">}</span><span class="s">%.8f.&quot;</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Pi</span> <span class="n">is</span> <span class="n">approximately</span> <span class="mf">3.14159265</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala інтерполяція рядків реалізована через переписування кода під час компіляції. Компілятор буде трактувати любий вираз, що складається з ідентифікатора, безпосередньо за яким іде подвійни лапки рядкового літералу, є виразом інтерполятора рядка. Інтерпретатори рядків <code>s</code>, <code>f</code>, та <code>raw</code> реалізовані через цей загальний механізм. Бібліотеки та користувачі можуть визначати інші інтерполятори рядків для інших цілей.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_4___">5.4 Оператори та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить потужний набір операторів для своїх базових типів. Як згадувалось в попередніх главах, ці операції насправді є милим синтаксисом для звичайних викликів методів. Наприклад, <code>1 + 2</code> насправді означає те саме, що <code>1.+(2)</code>. Іншими словами, клас <code>Int</code> містить метод <code>+</code>, що приймає <code>Int</code> та повертає результат <code>Int</code>. Цей метод <code>+ викликається, коли ви додаєте два `Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// Scala invokes 1.+(2)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб переконатись в цьому, ви можете написати вираз явно як виклик метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sumMore</span> <span class="k">=</span> <span class="mf">1.</span><span class="o">+(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">sumMore</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, <code>Int</code> містить декілка перевантажених методів <code>+</code>, що приймають різні типів параметрів.<span class="footnote"><br />[3]<br /></span> For example, Int has another method, also named +, that takes and returns a Long. If you add a Longto an Int, this alternate + method will be invoked, as in:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">longSum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2L</span>
<span class="n">longSum</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// Scala invokes 1.+(2L)</span>
</pre></div></div></div>
<div class="paragraph"><p>Символ <code>+</code> є оператором — інфіксним оператором, якщо бути точнішим. Операторна нотація не обмежена до методів, як <code>+</code>, що виглядають як оператори в інших мовах. Ви можете використовувати любий метод в операторній натації. Наприклад, клас <code>String</code> має метод <code>indexOf</code>, що приймає один параметр <code>Char</code>. Метод <code>indexOf</code> шукає рядок на перше співпадіння вказаного символа, та повертає його індекс, або <code>-1</code>, якщо вона не знайшла символ. Ви можете використовувати <code>indexOf</code> як оператор, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">indexOf</span> <span class="sc">&#39;o&#39;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1">// Scala invokes s.indexOf(&#39;o&#39;)</span>
</pre></div></div></div>
<div class="paragraph"><p>На додаток, <code>String</code> пропонує перевантажений метод <code>indexOf</code>, що приймає два параметри, символ, що треба шукати, та індекс, з якого починати. (Інший метод <code>indexOf</code>, показаний попередньо, починає з індексу 0, початку <code>String</code>.) Навіть якщо цей метод <code>indexOf</code> приймає два аргументи, ви можете використовувати його в операторній нотації. Але коли ви викликаєте метод, що приймає декілька аргументів використовуючи операторну нотацію, ви маєте поклачти ці аргументи в дужках. Наприклад, ось як ви використовуєте цей інший <code>indexOf</code> як оператор (продовжуючи попередній приклад):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">indexOf</span> <span class="o">(</span><span class="sc">&#39;o&#39;</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="c1">// Scala invokes s.indexOf(&#39;o&#39;, 5)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="______4">Любий метод може бути оператором</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala оператори не є особливим мовним синтаксисом; любий метод може бути оператором. Що робить метод оператором, це те, як ви використовуєте його. Коли ви пишете <code>s.indexOf('o')</code>, <code>indexOf</code> не є оператором. Але коли ви пишете <code>s indexOf 'o'</code>, <code>indexOf</code> є оператором, оскільки ви використовуєте його в операторній нотації.</p></div>
<div class="paragraph"><p>Досі ви бачили приклади інфіксної операторної нотації, що означає, що викликаємий метод сидить між об'єктом і параметром (або параметрами), які ви бажаєте передати в метод, як в <code>7 + 2</code>. Scala також має дві інші операторні нотації: префіксну та постфіксну. В префіксній нотації ви кладете метод перед об'єктом, на якому ви викликаєте метод (наприклад, <code>-</code> в <code>-7</code>). В постфіксній нотації ви кладете метод після об'єкта (наприклад, <code>toLong</code> в <code>7 toLong</code>).</p></div>
<div class="paragraph"><p>Для контрасту до інфіксної нотації, де оператори мають два операнди, один зліва та інший зправа, префіксні та постфіксні оператори є унарними: вони приймають тільки один операнд. В префіксній нотації операнд іде зправа від операнда. Деякі приклади префіксних операторів є <code>-2.0</code>, <code>!found</code>, та <code>~0xFF</code>. Як і з інфіксними операторами, ці префіксні оператори є скороченнями до виклику методів. Однак в цьому випадку ім'я метода має <code>unary_</code> перед символом оператора. Наприклад, Scala буде трансформувати вираз <code>-2.0</code> в виклик метода <code>(2.0).unary_-</code>. Ви можете продемонструвати це собі, набравши виклик метода обоє, через операторну нотацію та явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="c1">// Scala invokes (2.0).unary_-</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mf">2.0</span><span class="o">).</span><span class="n">unary_-</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдині ідентифікатори, що можуть бути викортстані як префіксні оператори, є <code>\+</code>, <code>-</code>, <code>!</code>, та <code>~</code>. Таким чином, якщо ви визначите метод на ім'я <code>unary_!</code>, ви можете викликати цей метод на значенні або змінній відповідного типу, використавши префіксну операторну нотацію, таку як <code>!p</code>. Але якщо ви визначите метод <code>unary_*</code>, ви не будете в змозі використовувати префіксну операторну нотацію, бо <code>*</code> не є одним з чотирьох ідентифікаторів, що можуть використовуватись в префіксних операторах. Ви можете викликати метод звичайно, як <code>inp.unary_*</code>, але якщо ви спробуєте визвати його через <code>*p</code>, Scala буде розбирати його, якби ви записали <code>*.p</code>, що, можливо, не те, що ви мали на увазі!<span class="footnote"><br />[Однак не все втрачено. Існує вкрай слабкий шанс, що ваша програма з *p може компілюватись як C++.]<br /></span></p></div>
<div class="paragraph"><p>Постфіксні оператори є методи, що не приймають аргументів, коли вони викликаються без крапки та дужок. В Scala ви можете відкинути пусті дужки на виклику метода. Домовленість полягає в тому, що ви залишаєте дужки, якщо метод має побічні ефекти, як в println(), але ви можете не вживати їх, якщо метод не має побічних ефектів, як в <code>toLowerCase</code> викликане на <code>String</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">toLowerCase</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому останньому випадку метода, що не потребує аргументів, ви можете альтернативно відкинути крапку, і використовувати постфіксну операторну нотацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">toLowerCase</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку <code>toLowerCase</code> використовується як постфіксний оператор на операнді <code>s</code>.</p></div>
<div class="paragraph"><p>Таким чином, щоб побачити, які оператори ви можете використовувати з базовими типами Scala, все що вам дійсно треба зробити, це подивитись на методи, задекларовані в класах типу в документації Scala API. Зважаючи, що це Scala туторіал, однак, ми надамо вам швидкий тур по більшості з ціх методів в наступних декільках розділах.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java__2">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато аспектів Scala, описані в залишку цієї глави, такі ж самі, що і в Java. Якщо ви практикуючий Java гуру в розквиті, ви можете безпечно пропустити все до Розділу 5.8, що описує як Scala відрізняється від Java в сфері еквівалентності об'єктів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_5__">5.5 Арифметичні оператори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете викликати арифметичні методи через інфіксну операторну нотацію для додавання (+), віднімання (-), множення (*), ділення (/), та залишку (%) на любих числових типах. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">+</span> <span class="mf">2.3</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;b&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2L</span> <span class="o">*</span> <span class="mi">3L</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">4</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">11</span> <span class="o">%</span> <span class="mi">4</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">11.0f</span> <span class="o">/</span> <span class="mf">4.0f</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">2.75</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">11.0</span> <span class="o">%</span> <span class="mf">4.0</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли обоє, лівий та правий операнди є інтегральними типами (<code>Int</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code>), оператор <code>/</code> буде казати вам цілу частину від ділення, без залишку. Оператор <code>%</code> вказує залишок від цілого ділення.</p></div>
<div class="paragraph"><p>Залишок з плаваючою крапкою, що ви отримаєте за допомогою <code>%</code> не є тим, що визначений в стандарті IEEE 754. Залишок IEEE 754 використовує округлююче ділення, не відсікаюче ділення, при обчисленні залишка, так що повністю інше від операції цілого залишку. Якщо ви дійсно бажаєте залишок IEEE 754, ви можете викликати <code>IEEEremainder</code> зі <code>scala.math</code>, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="nc">IEEEremainder</span><span class="o">(</span><span class="mf">11.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Числові типи також пропонують унарний префіксний оператор <code>+</code> (метод <code>unary_+</code>) та <code>-</code> (метод <code>unary_-</code>), що дає вам вказати, чи є літеральне число позитивним або негативним (додатним або від'ємним), як в <code>-3</code> або <code>+4.0</code>. Якщо ви не вказуєте унарний <code>+</code> або <code>-</code>, літеральне число розглядається як позитивне. Унарний <code>+</code> існує виключно для симетрії з <code>-</code>, але не має ефекту. Унарний <code>-</code> може також використовуватись для обернення змінної. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">neg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="mi">3</span>
<span class="n">neg</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="o">+</span><span class="mi">3</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">neg</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_6____">5.6 Відносні та логічні операції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете порівняти числові типи за допомогою відносних методів: більше ніж (&gt;), менше ніж (&lt;), більше або рівне (&gt;=), менше або рівне (&#8656;), що дають результат типу Boolean. На додаток ви можете використати унарний оператор <code>!</code> (метод <code>unary_!</code>), щоб інвертувати значення Boolean. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">3.5f</span> <span class="o">&gt;=</span> <span class="mf">3.6f</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">untrue</span> <span class="k">=</span> <span class="o">!</span><span class="kc">true</span>
<span class="n">untrue</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Логічні методи, ТА (<code>&amp;&amp;</code> та <code>&amp;</code>), АБО (<code>||</code> та <code>|</code>), приймають <code>Boolean</code> операнди в інфіксній нотації, та видають Boolean результат. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">toBe</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">toBe</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">question</span> <span class="k">=</span> <span class="n">toBe</span> <span class="o">||</span> <span class="o">!</span><span class="n">toBe</span>
<span class="n">question</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">paradox</span> <span class="k">=</span> <span class="n">toBe</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">toBe</span>
<span class="n">paradox</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Операції <code>&amp;&amp;</code> та <code>||</code> короткого обчислення, як в Java: вирази, побудовані з ціх операторів, обчислюються так далеко, як треба для визначення результату. Іншими словами, права частина виразів <code>&amp;&amp;</code> та <code>||</code> не буде обчислюватись, якщо ліва визначає результат. Наприклад, як ліва сторона виразу ТА буде обчислена як <code>false</code>, результат виразу буде обчислений як <code>false</code>, так що права частина не буде обчислена. Подібно,якщо ліва частина виразу АБО обчисляється до <code>true</code>, результат виразу буде однозначно <code>true</code>, так що права сторона не буде обчислюватись.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">salt</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;salt&quot;</span><span class="o">);</span> <span class="kc">false</span> <span class="o">}</span>
<span class="n">salt</span><span class="k">:</span> <span class="o">()</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">pepper</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pepper&quot;</span><span class="o">);</span> <span class="kc">true</span> <span class="o">}</span>
<span class="n">pepper</span><span class="k">:</span> <span class="o">()</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">pepper</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">salt</span><span class="o">()</span>
<span class="n">pepper</span>
<span class="n">salt</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">salt</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pepper</span><span class="o">()</span>
<span class="n">salt</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому виразі викликаються <code>pepper</code> та <code>salt</code>, але в другому викликається тільки <code>salt</code>. Припускаючи, що <code>salt</code> повертає <code>false</code>, немає потреби викликати <code>pepper</code>. Якщо ви бажаєте обчислити праву сторону в любому випадку, використовуйте оператори <code>&amp;</code> та <code>|</code>. Метод <code>&amp;</code> виконує логічне ТА, <code>|</code> логічне АБО, але не скорочено, як <code>&amp;&amp;</code> та <code>||</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">salt</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">pepper</span><span class="o">()</span>
<span class="n">salt</span>
<span class="n">pepper</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">falseNote</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете зацікавитись, як може працювати, якщо оператори всього лише методи. Звичайно всі аргументи обчислюються перед входом в метод, так що як метод уникає обчислення свого второго аргумента? Відповідь полягає в тому, що всі методи Scala мають можливість відкладати обчислення своїх аргументів, або навіть відмовлятись обчислювати їх взагалі. Можливість називається параметри за-ім'ям, та обговорюється в Розділі 9.5.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_7__">5.7 Побітові операції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala дозволяє вам виконувати операції з окремими бітами цілих типів за допомогою декількох побітових методів. Оператори настіпні: побітне ТА (&amp;), побітне АБО (|), побітне XOR (!АБО) (^).<span class="footnote"><br />[ Метод побітне XOR виконує ексклюзивне АБО на операторах. Ідентичні біти дають 0. Різні біти дають 1. Таким чином, 0011 ^ 0101 дає 0110.]<br /></span>Унарний побітовий оператор (<code>~</code>, метод <code>unary_~</code>) інвертує кожний біт свого операнда. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">^</span> <span class="mi">3</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">1</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший вираз, <code>1 &amp; 2</code>, побітно перевіряє біти в 1 (0001) та 2 (0010), що дає 0 (0000). Другий вираз, <code>1 | 2</code>, побітно складає біти тих же операндів, даючи 3 (0011). Третій вираз, <code>1 ^ 3</code>, побітно виконує   xor для 1 (0001) та 3 (0011), даючи 2 (0010). Заключний вираз, <code>~1</code>, інвертує кожний біт в 1 (0001), даючи -2, що в бінарній формі виглядає як 11111111111111111111111111111110.</p></div>
<div class="paragraph"><p>Цілі типи Scala також пропонують три методи зсуву: зсув вліво (&lt;&lt;), зсув вправо (&gt;&gt;), та беззнаковий зсув вправо (&gt;&gt;&gt;). Методи зсува, коли використовуються в інфіксній операторні нотації, зсувають ціле значення лівого операнда на кількість біт, заданих правим оператором. Зсув вправо та беззнаковий зсув вліво заповнюють нові біти нулями. Зсув вправо заповнює ліві біти знаковим (старшим) бітом. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">31</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>-1 в двійниковій системі є 11111111111111111111111111111111. В першому прикладі, -1 &gt;&gt; 31, -1 зсувається вправо на 31 позицій. Оскільки <code>Int</code> складається з 32 біт, ця операція ефективно рухає самий лівий біт, доки він не стане самий правий.<span class="footnote"><br />[Самий лівий біт цілого типу є бітом знаку. Якщо самий лівий біт 1, число від'ємне. Якщо 0 число додатнє.]<br /></span> Наш метод &gt;&gt; заповнює одиницями при зсуві вправо, оскільки лівий біт -1 є 1, результат ідентичний до оригіналу лівого операну, 32 біти одиниць, або -1. В другому прикладі -1 &gt;&gt;&gt; 31, самий лівий біт знову зсувається в саму праву позицію, але на цей раз заповнюється нулями. Результат на цей раз буде двоїчне 00000000000000000000000000000001, або 1. В фінальному прикладі, 1 &lt;&lt; 2, лівий операнд, 1, зсувається вліво на ді позиції, даючи бінарне 00000000000000000000000000000100, або 4.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_8___">5.8 Еквівалентність об'єктів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви бажаєте порівняти два об'єкти на еквівалентність, ви можете використовувати або <code>==</code> або його інверсію <code>!=</code>. Ось декілька простих прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">2</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці операції насправді застосовуються для всіх об'єктів, не тільки для базових типів. Так що ви можете, наприклад, застосувати <code>==</code> для порівняння списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ідучи далі, ви можете порівняти два об'єкта, що мають різні типи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви навіть можете порівняти з <code>null</code>, або з чимось, що може бути <code>null</code>. Виключення не спрацює:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span>
<span class="n">res38</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="kc">null</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите, <code>==</code> було майстерно зроблене, так що ви отримаєте в більшості випадків тілкьи ту еквівалентність, яку побажаєте. Це досягається дуже простим правилом: спочатку перевіряється ліва сторона щодо <code>null</code>. Якщо це не <code>null</code>, викликається метод <code>equals</code>. Оскільки <code>equals</code> є методом, точне порівняння, що ви отримаєте, залежить від типу лівого аргументу. Оскільки перевірка на <code>null</code> автоматична, ви не повинні перевіряти самостійно.<span class="footnote"><br />[Автоматична перевірка не дивиться на праву частину, але любий адекватний метод <code>equals</code> повинен повертати <code>false</code>, якщо аргумент є <code>null</code>.]<br /></span>Цей різновид порівняння видасть <code>true</code> на різних об'єктах, доки їх вміст той самий, та їх методи <code>equals</code> написані на основі їх вмісту. Наприклад, ось порівняння між двома рядками, що мають ті самі п'ять літер:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="s">&quot;he&quot;</span> <span class="o">+</span> <span class="s">&quot;llo&quot;</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___scala___java">Як == в Scala відрізняється від Java</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Java ви можете використовувати <code>==</code> для порівняння обох, примітивних та типів посилань. На примітивних типах Java <code>==</code> перевіряє еквівалентінсть значень, як в Scala. На типах посилань, однак, Java <code>==</code> порівнює еквівалентність посилань, що означає, що дві змінні посилаються на той самий об'єкт в купі JVM. Scala також провадить здатність порівняти еквівалентність посилань, під ім'ям <code>eq</code>. Однак <code>eq</code> та його протилежність, <code>ne</code>, застосовується тільки для об'єктів. що напряму відзеркалюються на Java об'єкти. Повні деталі щодо <code>eq</code> та <code>ne</code> надаються в Розділі 11.1 та 11.2. Також дивіться Главу 30 щодо того, як писати гарний метод <code>equals</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_9____">5.9 Преоритети та асоціативність операторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Преоритет операторів визначає, яка частина виразу обчислюється перед іншими частинами. Наприклад, вираз <code>2 + 2 * 7</code> обчислюється до <code>16</code>, не <code>28</code>, оскільки оператор <code>*</code> має вищий преоритет, ніж оператор <code>+</code>. Таким чином, частина множення обчислюється перед частиною додавання. Ви можете, звичайно, використати дужки для прояснення порядку обчислення, або щоб перекрити преоритети. Наприклад, якщо ви дійсно бажаєте отримати результат виразу вище 28, ви можете записати вираз таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">*</span> <span class="mi">7</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги, що Scala не має операторів як таких, а тільки спосіб використовувати методи в операторній нотації, ви можете здивуватись, як роблять преоритети операцій. Scala визначає преоритет базуючись на першому символі методів, використаних в операторній нотації (є одне виключення з цього правила, що буде продискутоване на наступних сторінках). Якщо ім'я метода починається з <code>*</code>, наприклад, він буде мати вищий преоритет, ніж метод, що починається з <code>+</code>. Таким чином, <code>2 + 2 * 7</code> буде еквівалентне до <code>2 + (2 * 7)</code>. Подібно, <code>a  b *** c` (в якому `a`, `b`, та 'c' є змінні, а `</code> та <code>***</code> є методи) буде обчислене як <code>a  (b *** c)`, оскікльки метод `***` має вищий преоритет, ніж метод `</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.3: Преоритети операцій</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі спеціальні символи)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">* / %</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">+ -</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">:</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">= !</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">&lt;</p></td>
<td align="right" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">&amp;</p></td>
<td align="center" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">|</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі літери)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі оператори присвоєння)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Таблиця 5.3 показує преоритети, надані першим літерам метода в порярдку зменшення преоритету, де символи на одному рядку мають один преоритет. Чим вище символ в цій таблиці, тим вищий преоритет методів, що починаються з цього символа. Ось приклад, що ілюструє вплив преоритетів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">32</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>&lt;&lt;</code> починається з символа <code>&lt;</code>, що стоїть нижче в Таблиці 5.3, ніж символ <code>+</code>, що є першим та єдиним символом метода <code>+</code>. Таким чином, <code>&lt;&lt;</code> буде мати нижчий преоритет, ніж <code>+</code>, і вираз буде обчислений починаючи з метода <code>+</code>, потім метода <code>&lt;&lt;</code>, як в <code>2 &lt;&lt; (2 + 2)</code>. <code>2 + 2</code> є <code>4</code>, за нашими підрахунками, та <code>2 &lt;&lt; 4</code> дає <code>32</code>. Якщо ми поміняємо оператори, ви отримаєте інший результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">16</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки перші символи такі самі, що в попередньому прикладі, методи будуть викликані в тому самому порядку. Спочатку буде викликаний метод <code>+</code>, потім метод <code>&lt;&lt;</code>. Так що <code>2 + 2</code> знову дасть 4, та <code>4 &lt;&lt; 2</code> є <code>16</code>.</p></div>
<div class="paragraph"><p>Одне виключення з правила преоритетів, до якого ми посилались раніше, стосується  операторів присвоєння, що завершуються на знак рівності. Якщо оператор закінчується на знак рівності(=), і це не один з операторів порівняння: <code>&gt;=</code>, <code>==</code>, або <code>!=</code>, тоді преоритет оператора такий самий, як в простого присвоєння (=). Тобто, він меньший ніж преоритет любого іншого оператора. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">*=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>значить те саме, що і:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">*=</span> <span class="o">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>оскільки <code>*=</code> класифікується як оператор присвоєння, чий преоритет нижчий, ніж <code>+</code>, навіть незважаючи, що перший символ оператора <code>*</code>, що мало б підказувати преоритет, вищий за <code>+</code>.</p></div>
<div class="paragraph"><p>Коли декілька операторів з однаковим преоритеттом стоять поряд в виразі, асоциативність операторів визначає групування. Асоциативність операторів в Scala визначається останнімсимволом. Як зазначалось в Главі 3, любий метод, що завершується на симол <code>:</code> викликається не своєму правому операнді. Методи, що завершуються на любий інший символ, роблять навпаки: вони викликаються на своєму лівому операнді, передаючи правий операнд.</p></div>
<div class="paragraph"><p>Так що <code>a * b</code> дає <code>a.*(b)</code>, але <code>a:::b</code> дає <code>b.:::(a)</code>.</p></div>
<div class="paragraph"><p>Оданк неважливо, яку асоциативніть має оператор, його операнди завжди використовуються зліва направо. Так що якщо <code>a</code> є виразом, що не тільки просте посилання на незмінне значення, тоді <code>a:::b</code> більш точно трактується як в наступному блоці:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">{</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">a</span><span class="o">;</span> <span class="n">b</span><span class="o">.:::(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому блоці <code>a</code> все одне обчислюється раніше за <code>b</code>, та потім результат передається до метода <code>b.:::</code>.</p></div>
<div class="paragraph"><p>Це правило асоціативності також відіграє роль, коли декілька оператоорів з однаковим преоритетом стоять поряд. Якщо метод завершується на <code>:</code>, вони групуються зліва направо. Наприклад, <code>a:::b:::c</code> трактується як <code>a:::(b:::c)</code>. Але <code>a * b * c</code>, для контрасту, трактується як <code>(a * b) * c</code>. Преоритетність операторів я частиною мови Scala. Вам не треба лякатись використовувати її. Тим не менш, є гарним стилем використовувати дужки для прояснення, які операції ідуть за якими в виразі. Можливо, єдині преоритети, на які ви можете дійсно розраховувати, що інші програмісти мають знати без підглядання, це мультиплікативні оператори: <code>*</code>, <code>/</code>, та <code>%</code>, мають преоритет над аддитивними, <code>+</code> та <code>-</code>. Так що навіть якщо <code>a + b &lt;&lt; c</code> дає бажаний вами результат без дужок, додаткова ясність, яку дасть запис <code>(a + b) &lt;&lt; c</code>, може зменшити частоту, з якою ваш колега буде використовувати ваше ім'я в операторній нотації, наприклад, вигукуючи в розпачі "<code>bills !*&amp;\^%~ code!</code>".<span class="footnote"><br />[Тепер в маєте бути в змозі зрозуміти, що маючи цей код, компілятор Scala буде викликати (bills.!*&amp;\^%~(code)).!().]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_10__">5.10 Багаті огортки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете викликати значно більше методів на базових типах Scala, ніж показано в Таблиці 5.4. Ці методи доступні через неявні перетворення, прийом, що буде описаний в деталях в Главі 21. Все що вам покі що треба знати, це що для кожного базового типу, описаного в цій главі, також існує "багата огортка", що провадить декілька додаткових методів. Таким чином, щоб подивитись всі доступні методи для базового типу, вам слід дивитись документацію API по багатій огортці для базового типу. Ці класи перелічені в Таблиці 5.5.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.4: Деякі багаті операції</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Код </th>
<th align="center" valign="top"> Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="n">max</span> <span class="mi">5</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">5</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="n">min</span> <span class="mi">5</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mf">2.7</span> <span class="n">abs</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">2.7</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mf">2.7</span> <span class="n">round</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">-3L</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mf">1.5</span> <span class="n">isInfinity</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">0</span><span class="o">)</span> <span class="n">isInfinity</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">true</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="n">to</span> <span class="mi">6</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Range(4, 5, 6)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;bob&quot;</span> <span class="n">capitalize</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">"Bob"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;robert&quot;</span> <span class="n">drop</span> <span class="mi">2</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">"bert"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.5: Багаті типи огортки</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Багата огортка</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichByte</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichShort</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichInt</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichLong</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichChar</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichFloat</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichDouble</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichBoolean</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="center" valign="top"><p class="table">scala.collection.immutable.StringOps</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_11_">5.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Головний висновок з цієї глави в тому, що операції в Scala є викликами методів, та що для базових типів Scala існують неявні перетворення до збагачених типів, що додають це більше корисних методів. В наступній главі ми покажемо, що це значить розробляти об'єкти в функціональному стилі, що дає нові реалізації операторів, які ви бачили в цій главі.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__6_2">Глава 6</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____2">Функціональні об'єкти</h1>
<div class="paragraph"><p>З розумінням основ Scala, яке ви отримали від попередніх глав, ви готові до розробки більш наповнених можливістями класів в Scala. В цій главі ми зробимо наголос не класах, що визначають функціональні об'єкти, або об'єкти, що не мають жодного змінного стану. В якості роблячого прикладу, ми створимо декілька варіантів класу, що моделює раціональні числа як незмінні об'єкти. По ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного програмування в Scala: параметри класів та конструктори, методи та оператори, приватні члени, перекриття, перевірку передумов, перевантаження та посилання на себе.</p></div>
<div class="sect1">
<h2 id="_6_1___rational">6.1 Специфікація класа Rational</h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Раціональне число</em> є таке, що може бути виражене як відношеня <code>n/d</code>, де <code>n</code> та <code>d</code> є цілі, за винятком того, що <code>d</code> не може бути нулем. <code>n</code> називається чисельником, та <code>d</code> знаменником. Приклади раціональних чисел є 1/2, 2/3, 112/239, та 2/1. Порівняно з числами з плаваючою крапкою, раціональні числа мають перевагу в тому, що дробі представлені точно, без округлення або апроксимації.</p></div>
<div class="paragraph"><p>Клас, який ми будемо розробляти в цей главі, має моделювати поведінку раціональних чисел, включаючи можливіть додавати їх, віднімати, множити та ділити. Щоб додати двоє раціональних числа, вам треба зпочатку отримати загальний знаменник, потім додати два чисельника. Наприклад, щоб додати <code>1/2 + 2/3</code>, ви множите обі частини лівого операнда на 3, та обі частини правого операнда на 2, що дає вам <code>3/6 + 4/6</code>. Додавання двох чисельників дає вам результат, <code>7/6</code>. Щоб помножити два раціональні числа, ви просто множите їх чисельники, та множите їх займенники. Таким чином, <code>1/2 * 2/5</code> дає <code>2/10</code>, що може бути представлено більш компактно в "нормалізованій" формі як <code>1/5</code>. Ви ділите обмінюючи чисельник та займенник правого операнда, та потім виконуєте множення. Наприклад, <code>1/2 / 3/5</code> є те саме, що <code>1/2 * 5/3</code>, або <code>5/6</code>.</p></div>
<div class="paragraph"><p>Одне, можливо тривіальне, спостереження полягає в тому, що раціональні числа не мають змінного стану. Ви можете дадати одне раціональне до іншого, але результат буде новим раціональним числом. Оригінальні числа не будуть "змінені". Незмінний клас <code>Rational</code>, що ми будемо розробляти в цій главі, буде мати ту саму властивість. Кожне раціональне число буде представлене одним об'єктом <code>Rational</code>. Коли ми додаємо два об'єкти <code>Rational</code>, ви будете створювати новий об'єкт <code>Rational</code> щоб утримувати суму. Ця глава надасть вам  побіжне враження, як Scala дозволяє вам писати бібліотеки, що відчуваються як природна підтримка мови. Наприклад, в кінці цієї глави ви будете в змозі зробити це з класом <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoThirds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">twoThirds</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">oneHalf</span> <span class="o">/</span> <span class="mi">7</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">twoThirds</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">17</span><span class="o">/</span><span class="mi">42</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_2__rational">6.2 Конструювання Rational</h2>
<div class="sectionbody">
<div class="paragraph"><p>Гарне місце почати розробку класа <code>Rational</code> є вирішити, як програмісти клієнти будуть створювати новий об'єкт <code>Rational</code>. Зважаючи, що ми приняли рішення зробити об'єкти <code>Rational</code> незмінними, ми потребуємо, щоб клієнти надали всі дані, що треба для примірника (в цьому випадку чисельник та займенник), коли вони конструюють примірник. Таким чином, ми почнемо розробку з такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з перших речей, що треба зауважити щодо цього рядка кода, це те, що якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча ви можете, звичайно, якщо бажаєте). Ідентифікатори <code>n</code> та <code>d</code> в дужках після імені класу <code>Rational</code>, називаються параметрами класу. Компілятор Scala збере докупи ці параметри класу, та створить первинний конструктор, що матиме саме два параметри.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_____7">Компроміс незмінних об'єктів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Незмінні об'єкти пропонують декілька переваг над змінним об'єктами, та один потенційний недолік. Перше, незмінні об'єкти часто простіше продумуються, ніж змінні, бо вони не мають складних просторів стану, що змінюються з часом. Друге, ви можете передавати незмінні об'екти довкола досить вільно, тоді як вам може знадобитись робити захисні копії змінних об'єктів, перед тим, як передаватий їх в інший код. Третє, немає способу для двох потоків, що одночасно отримують доступ до незмінного об'єкту, пошкодити його стан, коли він вже відповідно створений, бо потік взагалі не може змінити стан незмінного. Четверте, незмінні об'єкти роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт зміниться після того, як він покладений, наприклад, в <code>HashSet</code>, цей об'єкт може бути не знайдений наступний раз, коли ви шукаєте в <code>HashSet</code>.</p></div>
<div class="paragraph"><p>Головний недолік незмінних об'єктів в тому, що вони іноді потребують копіювання великого об'єктного графа, тоді як оновлення може бути зроблене на місці. В деяких випадках це може бути незручно виразити, і також може стати вузьким місцем продуктивності. Як результат, не нє рідкістю для бібліотек провадити змінні альтернативи до незмінних класів. Наприклад, клас <code>StringBuilder</code> є змінною альтернативою до незмінного  <code>String</code>. Ми надамо вам більше інформації щодо розробки змінних класів в Scala в Главі 18.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Цей початковий приклад <code>Rational</code> підкреслює різницю між Java та Scala. В Java класи мають конструктори, що можуть приймати параметри; тоді як в Scala класи самі можуть приймати параметри. Нотація Scala більше стисла — параметри класу можуть бути використані напряму в тілі класу; немає потреби визначати поля та писати присвоєння, що копіюють параметри конструктора в поля. Це може дати значну економію в шаблонному коді, особливо для малих класів.</td>
</tr></table>
</div>
<div class="paragraph"><p>Компілятор Scala буде компілювати любий код, який ви покладете в тіло класа, що не є частиною поля або визначення метода, в первинний конструктор. Наприклад, ви можете надрукувати повідомлення зневадження таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Created &quot;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи цей код, компілятор Scala покладе виклик до <code>println</code> в первинний конструктор <code>Rational</code>. Таким чином, виклик <code>println</code> буде друкувати своє повідолениня зпевадження, коли ви будете створювати новий примірник <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="nc">Created</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="nc">Rational</span><span class="k">@</span><span class="mi">2591</span><span class="n">e0c9</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_3___tostring">6.3 Реалізація метода toString</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли ви створили примірник <code>Rational</code> в попередньому прикладі, інтерпретатор надрукував <code>Rational@90110a</code>. Інтерпретатор отримав цей, дещо дивно вигладаючий, рядок викликаючи <code>toString</code> на об'єкті <code>Rational</code>. По замовченню клас <code>Rational</code> наслідує реалізацію <code>toString</code>, визначену в класі <code>java.lang.Object</code>, що просто друкує ім'я класу, символ <code>@</code>, та шістнадцятирічне число. Метод <code>toString</code> початково призначений для допомоги програмістам, провадячи інформацію, що може використовуватись для друкування повідомлень зневадження, журналювання повідомлень, звітів про збій тестів, та виводу інтерпретатора та знаваджувача. Результат, що наразі провадиться <code>toString</code>, не особливо корисний, бо він не надає жодного натяку щодо значення раціонального числа. Більш корисна реалізація <code>toString</code> може друкувати значення чисельника та займенника Rational. Ви можете <em>перекрити</em> реалізацію по замовчанню, через додавання метода <code>toString</code> до класу <code>Rational</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>override</code> попереду визначення метода сигналить, що попереднє визначення перекривається (більше про це в Главі 10). Оскільки числа <code>Rational</code> тепер будуть гарно відображатись, ми видалили твердження  <code>println</code>, що ми поклали в тіло попередньої версії класа <code>Rational</code>. Ви можете протестувати нову поведінку  <code>Rational</code> в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">7</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_4__">6.4 Перевірка передумов</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми звернемо нашу увагу на проблему з поточною поведінкою первинного конструктора. Як зазначалось на початку цієї глави, раціональні числа не можуть мати нуль в якості займенника. Однак зараз первинний конструктор приймає нуль, переданий для <code>d</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з переваг об'єктно-орієнтовного програмування є те, що воно дозволяє вам інкапсулювати дані в об'єкті, так що ви можете бути впевнені, що дані валідні на протязі його життя. В випадку незмінних об'єктів, таких як <code>Rational</code>, це означає, що вам треба переконатись, що дані валідні при конструюванні об'єкта. Зважаючи, що нульовий займенник є невілідним станом для числа Rational, вам не слідує дозволити конструювання  <code>Rational</code>, якщо нуль передається в параметрі <code>d</code>.</p></div>
<div class="paragraph"><p>Кращий шлях підійти до цієї проблеми є визначити передумову в первинному конструкторі, що <code>d</code> не має бути нулем. Передумова є обмеження на значення, передані в метод або конструктор, вимога, якій має задовільняти вікликаюча сторона. Один спосіб зробити це є використанян <code>require</code>,<span class="footnote"><br />[Метод <code>require</code> визначений в окремому об'єкті <code>Predef</code>. Як зазначено в Главі 4.4, члени <code>Predef</code> імпортуються автоматично в кожний файл Scala.]<br /></span> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>require</code> приймає один логічний параметр. Якщо передане значення є <code>true</code>, <code>require</code> поверне керування звичайно. Інакше <code>require</code> буде запобігати створенню об'єкта, через виклик <code>IllegalArgumentException</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_5__">6.5 Додавання полів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли первинний конструктор відповідно перевіряє виконання передумови, ми звернемо нашу увагу на підтримку додавання. Щоб зробити це, ми визначимо публічний метод <code>add</code> на класі <code>Rational</code>, що приймає інше <code>Rational</code> як параметр. Щоб утримувати <code>Rational</code> незмінним, метод <code>add</code> не має додавати передане раціональне число до себе. Скоріше, він має створити та повернути нове <code>Rational</code>, що міститиме суму. Ви можете подумати, що можете написати <code>add</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Не буде компілюватись</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="o">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак, маючи цей код, компілятор буде скаржитись:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^</code></pre>
</div></div>
<div class="paragraph"><p>Хоча параметри класу <code>n</code> та <code>d</code> в полі зору коду вашого метода <code>add</code>, ви можете отримувати доступ до їх значень тільки для об'єкта, на якому був викликаний метод <code>add</code>. Таким чином, коли ви кажете <code>n</code> або <code>d</code> в реалізцаії <code>add</code>, компілятор буде щасливий провадити значення для ціх параметрів класу. Але він не дає вам казати <code>that.n</code> або <code>that.d</code>, оскільки це не посилається на об'єкт <code>Rational</code>, на якому був визваний <code>add</code>.<span class="footnote"><br />[Насправді, ви можете додати Rational до себе, в якому випадку це буде посилатись на об'єкт, на якому викликається <code>add</code>. Але оскільки ви можете передати любий об'єкт <code>Rational</code> до <code>add</code>, компілятор все ще не дає вам сказати <code>that.n</code>.]<br /></span> Щоб отримати чисельник та займенник на <code>that</code>, вам треба перетворити їх на поля. Лістинг 6.1 показує, як ви можете додати ці поля до класу <code>Rational</code>.<span class="footnote"><br />[В Розділі 10.6 ви прочитаєте щодо параметричних полів, що провадять скорочення для написання того самого кода.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">d</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.1 - Rational з полями.</p></div>
<div class="paragraph"><p>В версії <code>Rational</code>, показаній в Лістингу 6.1 ми дадали два поля на ім'я <code>numer</code> та <code>denom</code>, та ініціалізували їх значеннями параметрів класу, <code>n</code> та <code>d</code>.<span class="footnote"><br />[Навіть якщо <code>n</code> та <code>d</code> використовуються в тілі класу, виходячи з того, що вони використовуються тільки в конструкторах, компілятор Scala не буде створювати поля для них. Таким чином, маючи цей код компілятор Scala буде генерувати клас з двома полями <code>Int</code>, одне для <code>numer</code> та одне для <code>denom</code>.]<br /></span> Ми змінили реалізацію <code>toString</code> та <code>add</code>, так що вони використовують поля, а не параметри класу. Ця версія <code>Rational</code> компілюється. Ви можете протестувати її, додавши деякі раціональні числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoThirds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">twoThirds</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="n">add</span> <span class="n">twoThirds</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша річ, яку ви можете зробити тепер, але не могли раніше, є доступ до значень чисельника та займенника з поза меж об'єкта. Просто отримайте доступ до публічних полів <code>numer</code> та <code>denom</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">numer</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">denom</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_6___">6.6 Посилання на себе</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ключове слово <code>this</code> посилається на примірник об'єкту, на якому був визваний метод, який наразі виконується, або в випадку конструктора - примірник об'єкта, що створюється. Як приклад, розглянемо додавання метода  <code>lessThan</code>, що перевіряє, що дане Rational меньше ніж параметр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lessThan</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>this.numer</code> посилається на чисельник об'єкта, на якому викликане <code>lessThan</code>. Ви також можете облишити цей префікс, та записати тільки <code>numer</code>; дві нотифікації є еквівалентними. Як приклад того, що ви не можете робити без <code>this</code>, розглянемо додавання метода <code>max</code> до класу <code>Rational</code>, що повертає більше з даного раціонального та аргумента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">lessThan</span><span class="o">(</span><span class="n">that</span><span class="o">))</span> <span class="n">that</span> <span class="k">else</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут перше <code>this</code> є надлишковим. Ви можете відкинути його, та записати: <code>lessThan(that)</code>. Але друге <code>this</code> представляє результат метода, в випадку, коли перевірка поверне <code>false</code>; коли ми оминемо його, нам нічого не залишиться повертати!</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_7__">6.7 Додаткові конструктори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді вам треба декілька конструкторів класу. В Scala конструктори, крім первинного, називаються додатковими конструкторами. Наприклад, раціональне число з займенником 1 може бути записане більш лаконічно як один чисельник. Наприклад, замість <code>5/1</code>, ви можете записати лише 5. Таким чином, це було б гарно, якщо замість запису <code>Rational(5, 1)</code>, програмісти клієнти могли просто писати <code>new Rational(5)</code>. Це буде потребувати додавання додаткового конструктора до <code>Rational</code>, що приймає лише один аргумент, чисельник, з займенником передвизначеним як 1. Лістинг 6.2 показує, на що це може бути схоже.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">d</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// додатковий конструктор</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.2 - Rational з додатковим конструктором.</p></div>
<div class="paragraph"><p>Додаткові конструктори в Scala починаються з <code>def this(...)</code>. Тіло додаткового конструктора <code>Rational</code> просто викликає первинний конструктор, передаючи йому всій єдиний аргумент, <code>n</code>, як чисельник, та 1 як займенник. Ви можете бачити додатковий конструктор в дії, написавши таке в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala кожний зовнішінй конструктор має викликати інший конструктор того самого класу в якості першої дії. Іншими словами, перше твердження в кожному додатковому конструкторі кожного класа Scala буде мати форму <code>this(...)</code>. Викликаний конструктор є або первинним конструктором (як в прикладі <code>Rational</code>), або інший додатковий конструктор, що текстуально іде перед викликаючим конструктором. Нетто ефект з цього правила в тому, що кожний виклик конструктора в Scala згодом буде закінчувати викликом первинного конструктора класу. Первинний конструктор, таким чином, є єдиною точкою входу класу.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Якщо ви знакомі з Java, ви можете здивуватись, чому правила Scala для конструкторів трохи більш обмежуючі, ніж в Java. В Java конструктор в якості першой дії має або викликати інший конструктор того самого класу, або напряму викликати конструктор суперкласу. В класах Scala тільки первинний конструктор може викликати конструктор суперкласу. Збільшення обмеження в Scala насправді є компроміс дизайну, який треба заплатити за більшу стислість та простоту констуркторів Scala, порівняно з Java. Суперкласи та деталі, як взаємодіють виклики конструкторів та наслідування, пояснені в Главі 10.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_8____">6.8 Приватні поля та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередній версії <code>Rational</code> ми просто ініціалізували <code>numer</code> як <code>n</code> та <code>denom</code> як <code>d</code>. Як результат, чисельник та займенник <code>Rational</code> можуть бути більші, ніж треба. Наприклад, дріб <code>66/42</code> може бути нормалізована до екввалентної скороченої форми, <code>11/7</code>, але первинний конструктор <code>Rational</code> наразі не робить цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">66</span><span class="o">/</span><span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб нормалізувати число і такий спосіб, нам треба розділити чисельник та займенник на їх спільний дільник. Наприклад, найбільший дільник для <code>66</code> та <code>42</code> є <code>6</code>. (Іншими словами, 6 є більшим цілим, що рівно ділить обоє, 66 та 42.) Ділення обох, чисельника та займенника <code>66/42</code> на <code>6</code> дає скорочену форму, 11/7. Лістинг 6.3 показує спосіб, як зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
  <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.3 - Rational з приватним полем та методом.</p></div>
<div class="paragraph"><p>В цій версії Rational ми додали приватне поле <code>g</code>, та модифікували ініціалізатори для <code>numer</code> та <code>denom</code>. (Ініціалізатор є код, що ініціалізує змінну; наприклад, <code>n / g</code>, що ініціалізує <code>numer</code>.) Оскільки <code>g</code> є приватним, доступ до неї може відбуватись тільки з тіла класу, але не ззовні. Ми також додали приватний метод, <code>gcd</code>, що обчислює найбільший загальний дільник двох переданих <code>Int</code>. Наприклад, <code>gcd(12, 8)</code> є <code>4</code>. Як ви бачили в Розділі 4.1, щоб зробити поле або метод приватними, ви просто можете покласти ключове слово <code>private</code> перед його визначенням. Призначення приватного "допоміжного метода" <code>gcd</code> є виділити код, потрібний для якоїсь іншої частини класу, в цьому випадку первинному конструктору. Щоб переконатись, що <code>g</code> завжди додатнє, ми передаємо абсолютні значення <code>n</code> та <code>d</code>, що ми отримали через виклик на них метода <code>abs</code>, метод, що ви можете викликати на кожному <code>Int</code> щоб отримати його абсолютне значення.</p></div>
<div class="paragraph"><p>Компілятор Scala буде покладати код для ініціалізаторів трьох полів <code>Rational</code> в первинний конструктор, в порядку як вони з'являються в джерельному коді. Таким чином, ініціалізатор <code>g</code>, <code>gcd(n.abs, d.abs)</code>, буде виконуватись перед іншими двома, оскільки він іде першим в тексті. Поле <code>g</code> буде ініціалізоване результатом, найбільшим загальним дільником абсолютних значень параметрів класу, <code>n</code> та <code>d</code>. Поле <code>g</code> потім використовується в ініціалізаторах <code>numer</code> та <code>denom</code>. Після ділення <code>n</code> та <code>d</code> на їх найбільший загальний дільник, <code>g</code>, кожний <code>Rational</code> буде сконструйований в його нармалізованій формі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">11</span><span class="o">/</span><span class="mi">7</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_9__">6.9 Визначення операцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поточна реалізація додавання <code>Rational</code> є OK, але може бути зроблене зручнішим в роботі. Ви можете спитати себе, чому ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>якщо <code>x</code> та <code>y</code> є цілі або з плаваючою крапкою, але ви маєте писати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або щонайменше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="n">add</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>якщо вони раціональні числа. Немає переконливої причини, чому має бути саме так. Раціональні числа є числами, як любі інші числа. В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з плаваючою крапкою.</p></div>
<div class="paragraph"><p>Чому ми не повинні використовувати природні арифметичні оператори для них? В Scala ви можете робити це. В залишку глави ми покажемо вам як.</p></div>
<div class="paragraph"><p>Перший крок є замінити <code>add</code> на звичайний математичний символ. Це прямолінійне, бо <code>+</code> є легальним ідентифікатором в Scala. Ми можемо просто визначили метод з <code>+</code> в якості імені. Поки ми вже в цьому, ми можемо також реалізувати метод на ім'я <code>*</code>, що виконує множення. Результат показаний в Лістингу 6.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">gdef</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.4 - Rational з операторними методами.</p></div>
<div class="paragraph"><p>Коли клас <code>Rational</code> визначений в цей спосіб, тепер ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Як завжди, операторний синтаксис в останньому рядку еквівалентний до викликуу метода. Ви можете також записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.+(</span><span class="n">y</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>але це не читабельне.</p></div>
<div class="paragraph"><p>Інша річ, що треба зауважити, є приймаючи до уваги правила Scala для преоритетів операторів, описані в Розділі 5.9, метод <code>*</code> буде притулятись більш тісно, ніж метод <code>+</code> для <code>Rationals</code>. Іншими словами, вираз, що включає операції <code>+</code> та <code>*</code> на <code>Rationals</code> буде поводитись як очікується. Наприклад, <code>x + x * y</code> буде виконуватись як <code>x + (x * y)</code>, не <code>(x + x) * y</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">66.10</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___scala_2">Ідентифікатори в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили два найбільш важливі способи сформувати ідентифікатор в Scala: алфавітно-цифрові та оператори. Scala має дуже гнучки правила для формування ідентифікаторів. Кірм двох форм ви також бачили тут дві інші. Всі чотири форми створенні ідентифікатоірв описані і цьому розділі. Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення, за яким можуть далі слідувати літери, цифри або підкреслення. Символ <code>$</code> також рахується як літера; однак, вона зарезервована для ідентифікатором, згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах по повинні містити символи <code>$</code>, навіть якщо це і буде компілюватись; якщо вони будуть, це може призвести до стикання імен з ідентифікаторами, згенерованих компілятором Scala.</p></div>
<div class="paragraph"><p>Scala слідує домовленості Java використання кемел-кейсу в ідентифікаторах,<span class="footnote"><br />[Цей стиль іменування ідентифікаторів названий кемел-кейс (верблюжий реєстр), оскільки ідентифікатори HaveHumps мають вбудовані великі літери.]<br /></span> такі як <code>toString</code> та <code>HashSet</code>. Хоча підкреслення є легальні в ідентифікаторах, вони не використовуються так часто в Scala програмах, частково щоб бути узгодженою з Java, але також оскільки підкреслення мають багато інших не-ідентифікаторних використань в Scala коді. Як результат, накраще уникати ідентифікаторів, як <code>to_string</code>, <code>__init__</code>, або <code>name_</code>.</p></div>
<div class="paragraph"><p>Кемел-кейс імена полів, параметрів методів, локальних змінних та функцій повинні починатись з літери в нижньому реєстрі, наприклад: <code>length</code>, <code>flatMap</code> та <code>s</code>. Кемел-кейс імена класів та трейтів повинні починатись з літери в верхньому реєстрі, наприклад: <code>BigInt</code>, <code>List</code> та <code>UnbalancedTreeMap</code>.<span class="footnote"><br />[В Розділі 16.5 ви побачите, що іноді ви бажаєте надати спеціальному типу класу, відомому як кейс клас, ім'я, що повністю складається з символів операторів. Наприклад, Scala API має клас на ім'я <code>::</code>, що спрощує співпадіння шаблонів для List.]<br /></span></p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Один наслідок з використання заключного підкреслення в ідентифікаторі є в тому, що якщо ви спробуєте, наприклад, написати декларацію, як цю: <code>val name_: Int = 1</code>, ви отримаєте помилку компілятора. Компілятор буде думати, що ви намагаєтесь декларувати <code>val</code> на ім'я <code>name_:</code>. Щоб змісити це компілюватись, вам треба вставити додатковий проміжок перед двокрапкою, як тут: <code>val name_ : Int = 1</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Один шлях, в який домовленості Scala відходять від Java включають імена констант. В Scala слово <code>constant</code> означає на просто <code>val</code>. Навіть якщо <code>val</code> має залишатись сталою після ініціалізації, це все ще змінна. Наприклад, параметри методів є <code>vals</code>, але кожний раз, коли визивається метод, ці <code>val</code> може містити різні значення. <code>constant</code> більш стійкі. Наприклад, <code>scala.math.Pi</code> визначена щоб бути значенням подвійної точності, найближчим до дійсного значення <code>π</code>, відношення довжини кола до його диаметру. Це значення навряд чи зміниться будь-коли; таким чином, <code>Pi</code> явно є константою. Ви можете також використовувати константи для надання імен значенням, що інакше були б магічними числами в коді: літеральні значення без пояснення, що в гіршому випадку з'являються в декількох місцях. Ви можете також побажати визначити константи для використання в співпадінні шаблонів, приклади використання яких описані в Розділі 15.2. В Java домовленість полягає в використанні імен констант з великих літер, з підкресленнями в якості роздільнииків слів, таких як <code>MAX_VALUE</code> або <code>PI</code>. В Scala домовленість просто така, щоб перша літера була великою. Таким чином, константи, названі в стилі Java, такі як <code>X_OFFSET</code>, будуть робити як Scala константи, але домовленість Scala використовувати кемел-кейс для констант, такі як <code>XOffset</code>.</p></div>
<div class="paragraph"><p>Операторний ідентифікатор складається з одного або більше операторних символів. Операторні символи є друковані ASCII символи, такі як <code>+</code>, <code>:</code>, <code>?</code>, <code>~</code> або <code>#</code>.<span class="footnote"><br />[Більш точно, операторний символ належить до множини Unicode математичних символів (Sm) або інших символів (So), або до 7-бітних ASCII символів, що не є літерами, цифрами, дужками, прямокутними дужками, фігурними дужками, поодинокими та подвійними лапками, або підкресленням, крапкою, крапкою з комою, комою, або апострофом.]<br /></span> Ось деякі приклади операторних ідентифікаторів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">+</span>
<span class="o">++</span>
<span class="o">:::</span> <span class="o">&lt;?&gt;</span>
<span class="o">:-&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор Scala буде всредині "колдувати" з операторними ідентифікаторами, щоб перетворити їх на легальні  Java ідентифікатори з вбудованими символами <code>$</code>. Наприклад, ідентифкатор <code>:-&gt;</code> внутрішньо буде представлений як <code>$colon$minus$greater</code>. Якщо ви колись побажаєте отримати доступ до цього ідентифікатора з Java кода, вам знадобиться використовувати цю внутрішню репрезентацію.</p></div>
<div class="paragraph"><p>Оскільки операторні ідентифікатори в Scala можуть стати довільно довгі, існує мала різниця між Java та Scala. В Java ввод <code>x&lt;-y</code> буде розібране як чотири лексичні символі, так що це буде еквівалентне до <code>x &lt; - y</code>. В Scala <code>&lt;-</code> буде розібране як єдиний ідентифікатор, даючи <code>x &lt;- y</code>. Якщо ви бажаєте першу інтерпретацію, вам треба відокремити символи <code>&lt;</code> та <code>-</code> проміжками. Це навряд чи буде проблемою на практиці, бо дуже мало людей пишуть <code>x&lt;-y</code> в Java, без вставлення проміжків або дужок між операторами.</p></div>
<div class="paragraph"><p>Змішений ідентифікатор складається з алфавітно-цифрового ідентифікатора, за яким слідує підкреслення, та операторний ідентифікатор. Наприклад, <code>unary_+</code> використовується як ім'я метода, що визначає унарний оператор <code>+</code>. Або <code>myvar_=</code>, що використовується як ім'я метода, що визначає оператор присвоєння. На додаток, змішані ідентифікатори в формі <code>myvar_=</code> генеруються компілятором Scala для підтримки властивостей (більше про це в Главі 18).</p></div>
<div class="paragraph"><p>Літеральний ідентифікатор є довільним рядком, оточений зворотніми апострофами `&#8230;\`. Деякі приклади літеральних ідентифікатоірв:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">`x`</span>
<span class="n">`&lt;clinit&gt;`</span>
<span class="n">`yield`</span>
</pre></div></div></div>
<div class="paragraph"><p>Ідея в тому, що ви покладаєте любий рядок, що допустимий під час виконання, як ідентифікатор між апострофами. Результат завжди є Scala ідентифікатор. Це робить навіть якщо ім'я в апострофах буде зарезервованим словом Scala. Типове використання є доступ до статичного метода <code>yield</code> в класі Java Thread. Ви не можете писати <code>Thread.yield()</code>, оскільки <code>yield</code> є зарезервованим словом Scala. Однак ви можете все ще назвати метод в апострофах, тобто <code>Thread.`yield</code>()`.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_11__">6.11 Перевантаження методів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Повернемось до класу <code>Rational</code>. З останніми змінами ви тепер можете робити операції додавання та множення в природний спосіб на раціональних числах. Але одна річ все ще відсутня - це змішана арифметика. Наприклад, ви не можете множити раціональне число на ціле, оскільки операнди <code>*</code> завжди мають бути <code>Rational</code>. Так що для раціонального числа <code>r</code> ви не можете написати <code>r * 2</code>. Ви маєте писати <code>r * new Rational(2)</code>, що не таке гарне.</p></div>
<div class="paragraph"><p>Щоб зробити <code>Rational</code> навіть ще зручнішим, ми додаємо методи до класу, що виконують змішане додавання та множення на раціональних числах та цілих. Доки ми тут, ми також додаємо методи для віднімання та ділення. Результат показаний на Лістингу 6.5.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">i</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.5 - Rational з перевантаженими методами.</p></div>
<div class="paragraph"><p>Тепер є дві версії для кожного арифметичного метода: одна що приймає раціональне в якості аргумента, та інша, що приймає ціле. Іншими словами, ім'я кожного з ціх методів перевантажене, оскільки кожне ім'я може використовуватись для декількох методів. Наприклад, ім'я <code>+</code> використовується одним методом, що приймає <code>Rational</code>, та інший, що приймає <code>Int</code>. В виклику метода компілятор обирає версію перевантаженого методу, що коректно співпадає з типами аргументів. Наприклад, якщо аргумент <code>y</code> в <code>x.+(y)</code> є <code>Rational</code>, компілятор буде обирати метод <code>+</code>, що приймає параметр <code>Rational</code>. Але якщо аргумент є цілим, компілятор обере метод <code>+</code>, що приймає параметр <code>Int</code>. Якщо ви спробуєте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">9</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите, що викликаний метод <code>*</code> визначений в кожному випадку по типу правого операнду.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">процес Scala з розрішення перевантажених методів дуже подібний до Java. В жодному разі обрана перевантажена версія є однією, що найкраще співпадає зі статичними типами аргументів. Іноді немає версії для унікального кращого співпадіння; в такому випадку компілятор видасть вам помилку "ambiguous reference".</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_12__">6.12 Неявні перетворення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви можете написати <code>r * 2</code>, ви можете також побажати обміняти операнди, як <code>2 * r</code>. Нажаль, це все ще не робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">overloaded</span> <span class="kt">method</span> <span class="kt">value</span> <span class="kt">*</span> <span class="kt">with</span>
<span class="n">alternatives</span><span class="k">:</span>
<span class="o">(</span><span class="kt">x:</span> <span class="kt">Double</span><span class="o">)</span><span class="kt">Double</span> <span class="kt">&lt;and&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="nc">Float</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="nc">Long</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Short</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="nc">Int</span>
<span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="o">(</span><span class="nc">Rational</span><span class="o">)</span>
<span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема тут в тому, що <code>2 * r</code> еквівалентне до <code>2.*(r)</code>, так що це виклик метода на числі 2, що є цілим. Але клас <code>Int</code> не містить метода множення, що приймає аргумент <code>Rational</code> — він не може, бо клас <code>Rational</code> не є стандартним класом в бібліотеці Scala.</p></div>
<div class="paragraph"><p>Однак є інший шлях вирішити цю проблему в Scala: ви можете створити неявне перетворення, що автоматично конвертує цілі на раціональні числа в разі потреби. Спробуйте додавання цього рядка в інтерпретатор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це викликає метод перетвоерння з <code>Int</code> до <code>Rational</code>. Модифікатор <code>implicit</code> попереду метода каже компілятору застосувати його автоматично в декількох ситуаціях. З визначеним перетворенням, ви можете повторити спробу приклада, що схибив до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб неявне перетворення працювало, воно має бути в полі зору. Якщо ми покладемо визначення неявного метода в клас <code>Rational</code>, він не буде в полі зору інтерпретатора. Поки ви повинні визначати його прямо в інтерпретаторі. Як ви здогадались з цього приклада, неявні перетворення дуже потужний прийом, щоб зробити бібліотеки більш гнучкими та більш зручними для використання. Оскільки вони такі потужні, вони можуть бути легко невірно використані. Ви побачите більше щодо неявних перетворень, включаючи шляхи занести їх в поле зору коли треба, в Главі 21.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_13__">6.13 Слово попередження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як демонструє ця глава, створення методів з іменами операторів та визначення неявних перетворень може допомогти вам розробляти бібліотеки, для яких клієнтськіій код є стислим та легко зрозумілим. Scala дає вам велику пропозицію щодо потужності, щоб розробляти такі прості-в-використанні бібліотеки. Але майте на увазі, що з силою іде відповідальність.</p></div>
<div class="paragraph"><p>Використані без майстерності, обоє, операторні методи та неявні перетворення можуть дати поштовх клієнтському коду, що складно читати та розуміти. Оскільки неявні перетворення застосовуються неявно компілятором, не явно прописані в коді, може бути неочевидним для програмістів клієнтів, що невні перетворення були застосовані. Та хоча операторні методи будуть звичайно робити клієнтський код більш стислим, вони будуть робити його краще читаємим тільки в тій мірі, в якій програмісти клієнітв будуть здатні розпізнавати та запам'ятовувати значення кожного оператора. Ціль, яку ви маєте тримати в голові, коли розробляєте бібліотеки, це не просто зрообити можливим підвищити стислість клієнтського кода, але також читабельний, зрозумілий клієнтський код. Стислість часто буде великою часткою читабельності, але ви можете зайти в стислості дуже далеко. Розробляючі бібліотеки, що дозволяють стислість зі смаком, та в той же час зрозумілий клієнтський код, ви можете допомогти програмістам клієнтів робити продуктивно.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_14_">6.14 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили багато аспектів класів в Scala. Ви бачили, як додавати параметри до класу, визначати декілька конструкторів, визначати оператори як методи, та налаштовувати класи, так щоб користування їми було природним. Можливо, більш важливо, ви побачили, що визначення та використання незмінних об'єктів є досить натуральним шляхом кодувати в Scala.</p></div>
<div class="paragraph"><p>Хоча фінальна версія <code>Rational</code>, показана в цій главі, задовільняє всім вимогам, встановленим напочатку глави, він все ще може покращений. Ми будемо фактично повертатись до цього прикладу пізніше в цій книзі. Наприклад, в Главі 30 ми вивчемо, як перекривати <code>equals</code> та <code>hashcode</code>, щоб дозволити <code>Rationals</code> краще поводитись при порівнянні за допомогою <code>==</code> або покладаючись в хеш таблиці. В Главі 21 ви навчитесь, як покласти визначення неявних методів в об'єкт компанйон <code>Rational</code>, так що вони можуть бути більш легко покладені в поле зору, коли програмісти клієнтів роблять з <code>Rationals</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__7_2">Глава 7</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____3">Вбудовані керівні структури</h1>
<div class="paragraph"><p>Scala має тільки декілька вбудованих керівних структур. Все, що є, це тільки: <code>if</code>, <code>while</code>, <code>for</code>, <code>try</code>, <code>match</code>, та виклики функцій. Причина, з якої Scala має їх так мало, в тому, що вона включає функціональні літерали з моменту свого створення. Замість накопичення в своєму синтаксисі однієї за одною високорівневих керівних структір, Scala накопичує їх в бібліотеках. (Глава 9 покаже в точності, як це зроблене.) Ця глава покаже ті декілька керівних структур, що є вбудованими.</p></div>
<div class="paragraph"><p>Одна річ, що ви помітите, це що майже всі керівні структури в Scala призводять до деякого результату. Цей підхід взятий від функціональних мов, де програми розглядаються як обчислення значення, так що компоненти програми також повинні обчислювати значення. Ви також можете розглядати цей підхід як логічний висновок з тренду, що вже присутній в імперативних мовах. В імперативних мовах виклики функцій можуть повертати значення, навіть коли викликана функція так само гарно може просто оновити значення вихідної змінної, переданої як аргумент. На додаток, імперативні мови часто мають тримісний оператор (такий як оператор <code>?:</code> в C, C++ та Java), що ефективно поводиться як <code>if</code>, але результатом є значення. Scala адаптує цю модель тримісного оператора, але називає його <code>if</code>. Іншими словами,в Scala <code>if</code> може повертати значення. Потім Scala продовжує цей тренд, маючи <code>for</code>, <code>try</code> та <code>match</code>, що також повертають значення.</p></div>
<div class="paragraph"><p>Програмісти можуть використовувати ці значення для спрощення свого коду, так само, якби вони використовували значення повернуті з функцій. Без цієї можливості програміст має створювати тимчасові змінні, тільки щоб зберігати результати, що обчислюються всередині керівної структури. Видалення ціх змінних робить код  трохи простішим, та він також запобігає багатьом вадам, коли ви встановлюєте змінну в одній гілці, але забуваєте встановити в іншому.</p></div>
<div class="paragraph"><p>Загалом, базові керівні структури Scala, мінімальні як вони є, провадяться всі основи з імперативних мов. Більше того, вони дозволяють скоротити ваш код, узгоджена маючі значення результату. Щоб показати, як це робить, давайте подивимось на базові керівні структури Scala.</p></div>
<div class="sect1">
<h2 id="_7_1__em_if_em">7.1 Вирази <em>if</em></h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala <code>if</code> робить так само, як і в багатьох інших мовах. Він перевіряє умову, і потім виконує одну з двох гілок коду, в залежності чи умова виконується. Ось загальний приклад, написаний в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">filename</span> <span class="k">=</span> <span class="s">&quot;default.txt&quot;</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
  <span class="n">filename</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код декларує змінну <code>filename</code>, та ініціалізує її значенням по замовчанню. Потім він виконує вираз <code>if</code>, щоб перевірити, чи програмі були надані якісь аргументи. Якщо це так, значення змінної змінюється, щоб вона містила значення, вказане в списку аргументів. Якщо аргументи не надані, змінна залішається встановленою в значення по замовчанню.</p></div>
<div class="paragraph"><p>Цей код може бути записаний краще, оскільки, як зазначалось в Кроці 3 в Главі 2, в Scala <code>if</code> є виразом, що повертає значення. Лістинг 7.1 показує, як ви можете досягти того самого ефекту, що і в попередньому прикладі, без використання жодних <code>var</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filename</span> <span class="k">=</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">else</span> <span class="s">&quot;default.txt&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.1 - Ідіома Scala для умовної ініціалізації.</p></div>
<div class="paragraph"><p>На цей раз <code>if</code> має дві гілки. Якщо аргументи не порожні, буде обраний перший елемент, <code>args(0)</code>; інакше буде обране значення по замовчанню. Вираз <code>if</code> має результат в вигляді обраного значення, і змінна <code>filename</code> ініціалізується цім значенням. Цей код трохи коротший, але його справжня перевага в тому, що він використовує <code>val</code> замість <code>var</code>. Використання <code>val</code> є функціональним стилем, і це допомагає вам майже в той спосіб, що і використання фінальних змінних в Java. Це каже читачам коду, що змінна ніколи не буде змінюватись, вберігаючи їх від сканування всього коду в полі зору змінної, дивлячись, чи вона не змінилась.</p></div>
<div class="paragraph"><p>Друга перевага використовувати <code>val</code> замість <code>var</code> в тому, що вони краще підтримують розуміння рівнянь. Введене значення еквівалентне до виразу, що обчислює його, припускаючи, що вираз не має побічних ефектів. Таким чином, кожного разу, коли ви збираєтесь записати ім'я змінної, замість нього ви можете записати вираз. Наприклад, замість <code>println(filename)</code>, ви можете просто записати це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;default.txt&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вибір за вами. Ви можете записати це любим способом. Використання <code>vals</code> допомагає вам безпечно робити цей тип рефакторингу, по мірі того, як ваш код буде розвиватись з часом. Шукайте можливості використовувати <code>val</code>. Вони можуть зробити ваш код більш простим для читання, та простішим для рефакторингу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_2__while">7.2 Цикли while</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala&#8217;s while loop behaves as in other languages. It has a condition and a body, and the body is executed over and over as long as the condition holds true. Listing 7.2 shows an example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">gcdLoop</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">var</span> <span class="n">b</span> <span class="k">=</span> <span class="n">y</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">temp</span> <span class="k">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="k">=</span> <span class="n">b</span> <span class="o">%</span> <span class="n">a</span>
    <span class="n">b</span> <span class="k">=</span> <span class="n">temp</span>
  <span class="o">}</span>
  <span class="n">b</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.2 - Обчислення найбільшого загального дільника за допомогою цикла <code>while</code>.</p></div>
<div class="paragraph"><p>Scala також має цикл <code>do-while</code>. Він робить як цикл <code>while</code>, за винятком того, що він перевіряє умову після тіла циклу, а не до. Лістинг 7.3 показує скрипт Scala, що використовує <code>do-while</code> для відлуння рядків, введених в стандартний вивід, докі не буде введений порожній рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">()</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Read: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.3 - Читання зі стандартного вводу за допомогою do-while.</p></div>
<div class="paragraph"><p>Конструкції <code>while</code> та <code>do-while</code> називаються "циклами", а не виразами, оскільки вони не продукують цікавого значення. Тип результата є <code>Unit</code>. Існує одне значення цього (та загалом тільки одне) типу <code>Unit</code>. Воно називається юніт значенням, та записується <code>()</code>. Існування <code>()</code> є тим, як Scala <code>Unit</code> відрізняється від Java <code>void</code>. Спробуйте це в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">greet</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">)</span> <span class="o">}</span>
<span class="n">greet</span><span class="k">:</span> <span class="o">()</span><span class="kt">Unit</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">()</span> <span class="o">==</span> <span class="n">greet</span><span class="o">()</span>
<span class="n">hi</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки перед тілом немає знаку рівняння, <code>greet</code> визначене як процедура з типом результата <code>Unit</code>. Таким чином, <code>greet</code> повертає юніт значення <code>()</code>. Це підтверджується в наступному рядку: порівнюючи результат <code>greet</code> на рівність з юніт значенням <code>()</code>, що дає <code>true</code>.</p></div>
<div class="paragraph"><p>Одна інша конструкція, що має результат в вигляді юніт значення, що релевантне тут, є переприсвоєння до <code>vars</code>. Наприклад, коли ви намагаєтесь читати рядки в Scala, використовуючи наступну ідіому Java, цикл <code>while</code> (та C і C++), ви потрапите в небезпеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="c1">// Це не робить!</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Read: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви компілюєте цей код, Scala надасть вам попередження, що порівняння значень типів <code>Unit</code> та <code>String</code> з використанням <code>!=</code> буде завжди давати <code>true</code>. Тоді як в Java присвоєння скінчиться присвоєнням значення (в цьому випадку рядка зі стандартного вводу), в Scala присвоєння завжди зкінчиться юніт значенням, <code>()</code>. Таким чином, значення присвоєння <code>line = readLine()</code> завжди буде <code>()</code>, та ніколи не буде <code>""</code>. Як результат, умова цього цикла <code>while</code> ніколи не буде <code>false</code>, і, таким чином, цикл ніколи не завершиться.</p></div>
<div class="paragraph"><p>Оскікльки цикл <code>while</code> не призводить до значення, він часто відсутній в чисто функціональних мовах. Такі мови мають вирази, а не цикли. Тим не менш, Scala включає цикл <code>while</code>, оскільки деякі імперативні рішення можуть бути більш читабельні, особливо для програмістів з переважно імперативним досвідом. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує процес докі деяка умова не зміниться, цикл <code>while</code> може виразити це напряму, тоді як функціональна альтернатива, що вірогідно використовуватиме рекурсію, може бути менш очевидною для деяких читачів коду.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 7.4 показує альтернативний шлях визначити найбільший загальний дільник двох чисел.<span class="footnote"><br />[Функція gcd, показана в Лістингу 7.4, використовує той самий підхід, що використовується в подібно-названій функції, спершу показаній в Лістингу 6.3, щоб обчислювати найбільший загальний дільник для класу Rational. Головна різниця в тому, що замість Int, gcd з Лістингу 7.4 робить з Long.]<br /></span> Беручи деякі два значення для <code>x</code> та <code>y</code>, функція <code>gcd</code>, показана в Лістингу 7.4 буде повертати той самий результат, що і <code>gcdLoop</code> функція, показана в Лістингу 7.2. Різниця між ціма двома підходами а тому, що <code>gcdLoop</code> написана в імперативному стилі, використовуючи <code>var</code> та цикл <code>while</code>, тоді як <code>gcd</code> написане в більш функціональному стилі, що включає рекурсію (<code>gcd</code> викликає себе), та не потребує <code>var</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.4 - Обчислення найбільшого загального дільника за допомогою рекурсії.</p></div>
<div class="paragraph"><p>Загалом, ми рекомендуємо вас кидати виклик циклам <code>while</code> в вашому коді, так само, як ви кидаєте виклик <code>var</code>. Фактично, цикли <code>while</code> та <code>var</code> часто ідуть рука об руку. Оскільки цикли <code>while</code> не видають результату, щоб призвести до якіхось змін в вашій програмі, цикл  <code>while</code> буде звичайно оновлювати <code>var</code> або виконувати I/O. Ви можете бачити це в дії в <code>gcdLoop</code>, показаному раніше. По мірі того, як цикл <code>while</code> робить свою справу, він оновлює <code>var</code> <code>a</code> та <code>b</code>. Таким чином, ми радимо вам бути трохи підозрілим щодо циклів <code>while</code> в вашому коді. Якщо немає гарного обгрунтування для окремого використання циклів <code>while</code> або <code>do-while</code>, спробуйте знайти спосіб зробити те саме без них.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_3__for">7.3 Вирази for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вираз <code>for</code> в Scala є швейцарським розкладним ножем ітерації. Він дозволяє комбінувати декілька простих інструментів в різний спосіб, щоб виразити широку різноманітність ітерацій. Прості використання дозволяють вирішувати загальні завдання, такі, як ітерація по послідовності цілих. Більш розвинені вирази можуть ітерувати по декількох колекціях різних типів, фільтрувати елементи на основі довільних умов, та продукувати нові колекції.</p></div>
<div class="sect2">
<h3 id="____4">Ітерації по колекціях</h3>
<div class="paragraph"><p>Простіша річ, що ви можете зробити за допомогою <code>for</code> це ітерувати по всіх елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що друкує всі файли в поточній директорії. I/O виконується з використанням Java API. Зпочатку ми створюємо <code>java.io.File</code> на поточній директорії,".", та викликаємо його метод <code>listFiles</code>. Цей метод повертає масив з об'єктів <code>File</code>, по одному для кожної директорії та файлу, що містяться в поточній директорії. Ми зберігаємо отриманий масив в змінній <code>filesHere</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

<span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.5 - Перелічує файли в поточній директорії за допомогою вираза <code>for</code>.</p></div>
<div class="paragraph"><p>За допомогою синтаксиса <code>file &lt;- filesHere</code>, що називається <em>генератором</em>, ми ітеруємо по елементах <code>filesHere</code>. В кожній ітерації ініціалізується нова <code>val</code> на ім'я <code>file</code> зі значенням елемента. Компілятор виводить тип <code>file</code> як <code>File</code>, оскільки <code>filesHere</code> має тип <code>Array[File]</code>. Для кожної ітерації буде виконане тіло вираза, <code>println(file)</code>. Оскільки в <code>File</code> метод <code>toString</code> видає ім'я файла або директорії, будуть роздруковані імена всіх файлів та директорій в поточній директорі.</p></div>
<div class="paragraph"><p>Синтаксис виразу <code>for</code> робить для любого типу колекції, не тільки для масивів.<span class="footnote"><br />[Щоб бути точним, вираз зправа від символа <code>&lt;-</code> в виразі for може бути любого типу, що має певні методи (в цьому випадку foreach) з відповідними сигнатурами. Деталі щодо того, як компілятор Scala обробляє вирази <code>for</code> описані в Главі 23.]<br /></span> Один зручний особливий випадок є тип <code>Range</code>, що ви похопцем бачили в Таблиці 5.4. Ви можете створити <code>Range</code> з використанням синтаксису як <code>1 to 5</code>, та можете ітерувати по ньому за допомогою <code>for</code>. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
<span class="nc">Iteration</span> <span class="mi">1</span>
<span class="nc">Iteration</span> <span class="mi">2</span>
<span class="nc">Iteration</span> <span class="mi">3</span>
<span class="nc">Iteration</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви не бажаєте включати верхню межу диапазона в значення, по яких піде ітерація використовуйте <code>until</code> замість <code>to</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
<span class="nc">Iteration</span> <span class="mi">1</span>
<span class="nc">Iteration</span> <span class="mi">2</span>
<span class="nc">Iteration</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітерація по цілим, як ця, є загальною в Scala, але не так сильно, як в інших мовах. В інших мовах ви можете використати цю можливість для ітерації по масиву, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Не загальне в Scala...</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">filesHere</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">filesHere</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз <code>for</code> вводить змінну <code>i</code>, встановлює її по черзі в коже ціле між <code>0</code> та <code>filesHere.length - 1</code>, та виконує тіло виразу для кожного встановленого <code>i</code>. Для кожного встановленого <code>i</code>, <code>i`тий елемент `filesHere</code> отримується та обробляється.</p></div>
<div class="paragraph"><p>Причина, з якої цей тип ітерації менш загальний в Scala в тому, що ви можете ітерувати по колекції напряму. Коли ви робите це, ваш код стає коротшим, та ви обходите багато "помилкових помилок", що можуть виникати, коли ви ітеруєте по масивах. Маєте ви почати з 0 або 1? Маєте ви додавати -1, +1, або нічого до фінального значення? На такі запитання легко відповісти, але також легко відповісти помилково. Безпечніше взагалі повністю уникати таких запитань.</p></div>
</div>
<div class="sect2">
<h3 id="__8">Фільтрація</h3>
<div class="paragraph"><p>Іноді ви не бажаєте ітерувати по повній колекції; ви бажаєте відфільтрувати її до деякої підмножини. Ви можете зробити це за допомогою вираза <code>for</code> через додавання фільтра, твердження <code>if</code> всередині дужок <code>for</code>. Наприклад, код, показаний в Лістингу 7.6, перелічує тільки ті файли в поточній директорії, чиї імена закінчуються на <code>.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>
<span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
  <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.6 - Пошук файлів <code>.scala</code> використовуючи <code>for</code> з фільтром.</p></div>
<div class="paragraph"><p>Ви можете альтернативно досягти тієї самої цілі за допомогою цього коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
<span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код дає той самий вихід, що і попередній код, та, можливо, виглядає більш знайомим для програмістів з імперативним підгрунтям. Однак імперативна форма є тільки цибулиною, оскільки цей часний вираз <code>for</code> викликається тільки для побічного ефекту друкування, і має результатом юніт значення <code>()</code>. Як буде показано далі в цьому розділі, вираз <code>for</code> названий "виразом", оскільки він може давати в результаті цікаве значення, колекцію, тип якої визначається твердженням <code>&lt;-</code> виразу <code>for</code>.</p></div>
<div class="paragraph"><p>Ви можете включити більше фільтрів, якщо ви бажаєте. Просто продовжуйте додавати фільтри <code>if</code>. Наприклад, щоб бути екстра захищеним, код в Лістингу 7.7 друкує тільки файли, але не директорії. Він робить це через додавання фільтрів, що перевіряють метод <code>isFile</code> для файлів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">isFile</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.7 - Використання декількох фільтрів в виразі <code>for</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___10">Вкладена ітерація</h3>
<div class="paragraph"><p>Якщо ви додасте декілька тверджень <code>&lt;-</code>, ви отримаєте вкладені "цикли". Наприклад, вираз <code>for</code>, показаний в Лістингу 7.8 має два вкладених цикли. Зовнішній цикл ітерує по <code>filesHere</code>, та внутрішній ітерує по <code>fileLines(file)</code> для кожного файлу, що закінчується на <code>.scala</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">java.io.File</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
<span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">);</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
  <span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
<span class="n">grep</span><span class="o">(</span><span class="s">&quot;.*gcd.*&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.8 - Використання декількох генераторів в виразі <code>for</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте, ви можете використовувати фігурні дужки замість звичайних дужок щоб оточити генератори та фільтри. Одна з переваг використання фігурних дужок в тому, що ви можете відкинути деякі з крапок з комою, що потрібні вам, коли ви використовуєте дужки, бо, як пояснено в Розділі 4.2, компілятор Scala не буде виводити коми з крапками, коли знаходиться в дужках.</p></div>
</div>
<div class="sect2">
<h3 id="_____8">Серед-поточні прикріплення змінних</h3>
<div class="paragraph"><p>Зауважте, що в попередньому коді повторюється вираз <code>line.trim</code>. Це нетривіальне обчислення, так що ви можете побажати обчислити його тільки один раз. Ви можете зробити це, прикріпивши результат до нової змінної, використовуючи знак рівності (=). Прикріплена змінна буде створена, та використовується як звичайна <code>val</code>, тільки без ключового слова <code>val</code>. Лістинг 7.9 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
  <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>
  <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
<span class="o">}</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">trimmed</span><span class="o">)</span>
<span class="n">grep</span><span class="o">(</span><span class="s">&quot;.*gcd.*&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.9 - Серед-поточне присвоєння в виразі <code>for</code>.</p></div>
<div class="paragraph"><p>В Лістингу 7.9 змінна на ім'я <code>trimmed</code> вводиться посеред виразу <code>for</code>. Ця змінна ініціалізована результатом <code>line.trim</code>. Потім залишок виразу використовує її в двох місцях, один раз в <code>if</code>, та ще раз в <code>println</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____5">Продукування нової колекції</h3>
<div class="paragraph"><p>Хоча доки всі приклади тільки оперували з ітерованими значеннями, та потім забували їх, ви також можете генерувати значення, що буде запам'ятовуватись на кожній ітерації. Щоб зробити це, ви ставите перед тілом виразу <code>for</code> ключове слово <code>yield</code>. Наприклад, ось функція, що ідентифікує файли <code>.scala</code>, та зберігає їх в масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">scalaFiles</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний раз, коли виконується тіло виразу, воно продукує одне значення, в цьому разі просто <code>file</code>. Коли вираз <code>for</code> завершується, результат буде включати всі з отриманих значень, що міститимуться в одній колекції. Тип отриманої колекції базується на типі колекцій, оброблених в твердженнях ітерації. В цьому випадку результат буде  <code>Array[File]</code>, оскільки <code>filesHere</code> є масивом, і тип отриманого виразу є <code>File</code>.</p></div>
<div class="paragraph"><p>Будьте уважні, поміж всього, коли ви розташовуєте ключове слово <code>yield</code>. Синтаксис виразу <code>for-yield</code> виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">clauses</span> <span class="k">yield</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p><code>yield</code> іде перед всім тілом. Навіть якщо тіло є блок, оточений фігурними дужками, покладіть <code>yield</code> перед першою фігурною дужкою, не перед останнім виразом в блоці. Уникайте спокуси писати речі, подібні до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">yield</span> <span class="n">file</span> <span class="c1">// Синтаксична помилка!</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, вираз <code>for</code>, показаний в Лістингу 7.10 спочатку трансформує <code>Array[File]</code> на ім'я <code>filesHere</code>, що містить всі файли в поточній директорії, до такого, що містить тільки файли <code>.scala</code>. Для кожного з них він генерує <code>Iterator[String]</code>, результат метода <code>fileLines</code>, чиє визначення показане в Лістингу 7.8. <code>Iterator</code> пропонує методи <code>next</code> та <code>hasNext</code>, що дозволяють вам ітерувати по колекції елементів. Цей внутрішній ітератор трансформується в інший ітератор ` Iterator[String]<code>, який містить тільки обрізані рядки, що містять субрядок `"for"</code>. Нарешті, для кожного з них, видається ціла довжина. Результатом цього виразу <code>for</code> є <code>Array[Int]</code>, що містить довжини.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">forLineLengths</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>
    <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="s">&quot;.*for.*&quot;</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.10 - Трансформування <code>Array[File]</code> на <code>Array[Int]</code> з допомогою <code>for</code>.</p></div>
<div class="paragraph"><p>В цій точці ви бачили всі головні функції виразів Scala <code>for</code>, але ми пройшли по них дуже швидко. Більш докладне покриття виразів <code>for</code> надається в Главі 23.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_4______try">7.4 Обробка виключень за допомогою виразів try</h2>
<div class="sectionbody">
<div class="paragraph"><p>Виключення Scala поводяться як в багатьох інших мовах. Замість повернення значення в в нормальний спосіб, метод може завершитись викликом виключення. Викликач метода може або перехопити та обробити це виключення, або він може сам по собі завершитись, що спричинить поширення виключення до викликача викликача. Виключення розповсюджується в такий спосіб, розкручуючи стек викликів, доки метод не обробить його, або доки не залишиться методів.</p></div>
<div class="sect2">
<h3 id="___11">Виклик виключень</h3>
<div class="paragraph"><p>Виклик виключення в Scala виглядає так само, як і в Java. Ви створюєте об'єкт виключення, та потім закидаєте його ключовим словом <code>throw</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це може виглядати трохи парадоксальним, в Scala <code>throw</code> є виразом, що має тип результа. Ось приклад, коли тип результата має значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">half</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">else</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;n must be even&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут трапиться, коли <code>n</code> є парним - <code>half</code> буде ініціалізоване до половини <code>n</code>. Якщо воно не парне, буде викликане виключення перед тим, як <code>half</code> взагалі зможе бути ініціалізоване. Через це, безпечно трактувати закидання виключення як взагалі будь-який тип. Любий контекст, що намагатиметься використовувати повернення з <code>throw</code>, ніколи не зможе цього зробити, так що не слід чекати ніякої шкоди.</p></div>
<div class="paragraph"><p>Технічно <code>throw</code> виключення має тип <code>Nothing</code>. Ви можете використовувати <code>throw</code> як вираз, навіть якщо він ніколи нічого не обчислює. Цей невеликий шматок технічної гімнастики може виглядати збоченим, але часто корисний в випадках, як попередній приклад. Одна з гілок <code>if</code> обчислює значення, тоді як інша закидає виключення, та обчислює <code>Nothing</code>. Тип цілого виразу <code>if</code> після цього є типом тієї гілки, що щось обчислює. Тип <code>Nothing</code> дискутується далі в Розділі 11.3.</p></div>
</div>
<div class="sect2">
<h3 id="___12">Перехоплення виключень</h3>
<div class="paragraph"><p>Ви перехоплюєте виключення, використовуючи синтаксис, показаний в Лістингу 7.11 Синтаксис для тверджень <code>catch</code> був обраний за його узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння шаблонів, потужна можливість, коротко описана в цій главі, та в більших деталях в Главі 15.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>
<span class="k">import</span> <span class="nn">java.io.FileNotFoundException</span>
<span class="k">import</span> <span class="nn">java.io.IOException</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">&quot;input.txt&quot;</span><span class="o">)</span>
<span class="c1">// Використовуємо та зачиняємо файл</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">FileNotFoundException</span> <span class="o">=&gt;</span> <span class="c1">// Обробляємо відсутній файл</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">IOException</span> <span class="o">=&gt;</span> <span class="c1">// Обробляємо помилки I/O</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.11 - Твердження <code>try-catch</code> clause in Scala.</p></div>
<div class="paragraph"><p>Поведінка цього виразу <code>try-catch</code> така сама, як і інших мов з виключенями. Тіло виконується, та якщо виникає виключення, кожне твердження <code>catch</code> викликається по черзі. В цьому прикладі, якщо виникає включення типу <code>FileNotFoundException</code>, буде виконане перше твердження. Якщо тип виключення <code>IOException</code>, виконується друге твердження. Якщо виключення не одного з ціх типів, <code>try-catch</code> завершиться, та виключення розповсюдиться далі.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Одна різниця, що ви швидко зауважите, в тому, що на відміну від Java, Scala не вимагає від вас перехоплювати перевірені виключення, або декларувати їх в твердженні <code>throws</code>. Ви можете декларувати <code>throws</code>, якщо бажатєте, за допомогою анотації <code>@throws</code>, але це не вимагається. Дивіться Розділ 31.2 для додаткової інформації щодо <code>@throws</code>.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="__finally">Твердження finally</h3>
<div class="paragraph"><p>Ви можете огорнути вираз за допомогою твердження <code>finally</code>, якщо ви бажаєте виконати деякий код, не важливо як скінчиться вираз. Наприклад, ви можете побажати переконатись, що відкритий файл буде закритий, навіть якщо метод завершується виникненням виключення. Лістинг 7.12 показує приклад.<span class="footnote"><br />[Хоча ви маєте завжди оточувати твердження case в catch в дужки, try та finally не потребують дужок, якщо вони містять тільки один вираз. Наприклад, ви можете написати: try t() catch { case e: Exception &#8658; &#8230; } finally f().]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>
<span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">&quot;input.txt&quot;</span><span class="o">)</span>
<span class="k">try</span> <span class="o">{</span>
<span class="c1">// Використовуємо файл</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
  <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="o">()</span> <span class="c1">// Переконуємось що зачинили файл</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.12 - Твердження <code>try-finally</code> в Scala.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Лістинг 7.12 показує ідиоматичний спосіб переконатись, що об'єкт не-з-пам'яті, такий як файл, сокет або з'єднання з базою даних, є зачинений. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок <code>try</code>, в якому ви використовуєте ресурс. Нарешті, ви зачиняєте ресурс в блоці <code>finally</code>. Ця ідіома є тою самою в Scala, як в Java; альтернативно, в Scala ви можете задіяти прийом з назвою <em>шаблон позичання</em>, щоб досягти цієї цілі більш стисло. Шаблон позичання буде описаний в Розділі 9.4.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="___13">Отримання значення</h3>
<div class="paragraph"><p>Як і з багатьма іншими керівними структурами Scala, <code>try-catch-finally</code> повертає значення. Наприклад, Лістинг 7.13 показує, як ви можете спробувати розібрати URL, але використати значення по замовчанню, якщо URL погано сформований. Результатом є те, що полишає твердження <code>try</code>, якщо не виникло виключення, або відповідний код <code>catch</code>, якщо виключення виникло і було перехоплене. Якщо виключення було закинуте, але не перехоплене, вираз взагалі не має результату. Значення, обчислене в твердженні <code>finally</code>, якщо таке є, відкидається. Звичайно в <code>finally</code> робиться деякий різновид очищення, такий як закриття файлів. Звичайно, вони не мають змінювати значення, обчислене в головному тілі або блоці <code>catch</code> твердження <code>try</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.net.URL</span>
<span class="k">import</span> <span class="nn">java.net.MalformedURLException</span>
<span class="k">def</span> <span class="n">urlFor</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">MalformedURLException</span> <span class="o">=&gt;</span>
      <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="s">&quot;http://www.scala-lang.org&quot;</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.13 - Твердження <code>catch</code>, що надає значення.</p></div>
<div class="paragraph"><p>Якщо ви знайомі з Java, вам зрозуміло, що поведінка Scala відрізняється від Java <code>try-finally</code> тільки в тій частині, що остання не повертає значення. Як і в Java, якщо твердження <code>finally</code> включає явне твердження <code>return</code>, або закидає виключення, значення повернення або виключення буде "анулювати" любі попередні значення, що походять з блоку <code>try</code> або з одного з його тверджень <code>catch</code>. Наприклад, маючи таке, скоріше надумане, визначення функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">finally</span> <span class="k">return</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>виклик f() дає 2. Для контрасту, маючи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">g</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span> <span class="mi">1</span> <span class="k">finally</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>виклик g() дає 1. Обоє з ціх функцій показують поведінку, що може здивувати багатьох програмістів, так що зазвичай краще уникати повернення значень з твердження <code>finally</code>. Кращий спосіб думати про блок <code>finally</code>, як про спосіб переконатись, що відбувся деякий побічний ефект, такий як зачинення відкритого файлу.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_5__match">7.5 Вирази match</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala вираз <code>match</code> дозволяють вам обрати з декількох альтернатив, так само, як твердження <code>switch</code> в інших мовах. Загалом, вираз <code>match</code> дозволяє вам зробити вибір, використовуючі довільні шаблони, що будуть описані в Главі 15. Загальна форма може почекати. Доки розглянемо тільки використання <code>match</code> для обрання між декількома альтернативами.</p></div>
<div class="paragraph"><p>Як приклад, скрипт в Лістингу 7.14 читає назву їжі зі списку аргументів, та друкує додаток до цієї їжі. Цей вираз <code>match</code> перевіряє <code>firstArg</code>, що була встановлена в перший аргумент зі списку аргументів. Якщо рядок є <code>"salt"</code>, друкується <code>"pepper"</code>, та якщо рядок <code>"chips"</code>, друкується <code>"salsa"</code>, і так далі. Випадок по замовчанню вказаний підкресленням (<code>_</code>), підстановочним символом, що часто використовується в Scala як заміщувач для повністю невідомого значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">firstArg</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
<span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`&quot;salt&quot;`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pepper&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;chips&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;salsa&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;eggs&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;bacon&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;huh?&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.14 - Вираз <code>match</code> з побічними ефектами.</p></div>
<div class="paragraph"><p>Існує декілька важливих відмінностей від твердження Java <code>switch</code>. Одна в тому, що любий різновид констант, так само як і інших речей, може використовуватись в <code>case</code> в Scala, не тільки цілі типи, enum, та константи рядків в твердженнях Java <code>case</code>. В Лістингу 7.14 альтернативами є рядки. Інша відмінність в тому, що нема переривань <code>break</code> в кінці кожної альтернативи. Замість цього, <code>break</code> є неявним, і немає провалювання від однієї альтернативи до іншої. Загальний випадок — відсутність провалювання — стає коротший, та уникається джерело помилок, оскільки програмісти більше не провалюватимуться випадково.</p></div>
<div class="paragraph"><p>Однак найбільш значуща різниця з Java <code>switch</code> може полягати в тому, що вирази <code>match</code> повертають значення. В попередньому прикладі кожна з альтернатив в виразі <code>match</code> друкує значення. Також гарно буде робити повернення значення, ніж його друк, як показано в Лістингу  7.15. Значення, що є результатом цього виразу <code>match</code>, зберігається в змінній <code>friend</code>. Крім того, що код став коротший (в любому випадку за числом токенів), код тепер розрізняє дві різні турботи: спочатку він обирає їжу, та потім друкує її.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">firstArg</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
<span class="k">val</span> <span class="n">friend</span> <span class="k">=</span>
  <span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;salt&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;pepper&quot;</span>
    <span class="k">case</span> <span class="s">&quot;chips&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;salsa&quot;</span>
    <span class="k">case</span> <span class="s">&quot;eggs&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;bacon&quot;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;huh?&quot;</span>
  <span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="n">friend</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.15 - Вираз <code>match</code>, що продукує значення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_6___break__continue">7.6 Життя без break та continue</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви, можливо, помітили, що ми не споминули <code>break</code> або <code>continue</code>. Scala полишила ці дві команди, оскільки вони не дуже гарно перетинаються з функціональними літералами, можливістю, описаною в наступній главі. Ясно, що значить <code>continue</code> означає в циклі <code>while</code>,але що воно може значити в функціональному літералі? Хоча Scala підтримує обоє, імперативний та функціональний стилі програмування, в цьому випадку вона трохи схиляється до функціонального програмування, в обмін на спрощення мови. Однак не турбуйтесь. Існує багато шляхів програмувати без <code>break</code> та <code>continue</code>, та якщо ви отримаєте переваги функціональних літералів, ці альтернативи можуть часто бути коротші, ніж оригінальний код.</p></div>
<div class="paragraph"><p>Найпростіший підхід є замінити кожний <code>continue</code> на <code>if</code>, та кожний <code>break</code> на логічну змінну. Логічна змінна вказує, чи оточуючий цикл має продовжуватись. Наприклад, уявімо, що ви шукаєте в списку аргументів рядок, що закінчується на <code>".scala"</code> але не починається на дефіс. В Java ви можете — якщо ви великий прихильник циклів <code>while</code>, <code>break</code> та <code>continue</code> — написати наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="c1">// Це Java</span>
<span class="kt">boolean</span> <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб перекласти цей Java код прямо на Scala, замість робити <code>if</code> та потім <code>continue</code>, ви можете написати <code>if</code>, що оточує весь залишок цикла <code>while</code>. Щоб позбавитись <code>break</code>, ви можете звичайно додати логічну змінну, що вказує, чи варто продовжувати, але в цьому випадку ми можемо повторно використати <code>foundIt</code>. Викорисистовуючи обоє з ціх трюків, код приходить до вигляду, як показано на Лістингу 7.16.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="n">foundIt</span> <span class="k">=</span> <span class="kc">false</span>

<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">foundIt</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
      <span class="n">foundIt</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="o">}</span>
  <span class="n">i</span> <span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.16 - Цикл без <code>break</code> або <code>continue</code>.</p></div>
<div class="paragraph"><p>Цей Scala код в Лістингу 7.16 досить подібний до оригінального Java коду. Всі базові частини все ще тут, і в тому ж порядку. Є дві переприсвоювані змінні та цикл <code>while</code>. В циклі є перевірка, що <code>i</code> менше ніж <code>args.length</code>, перевірка на <code>"-"</code>, та перевірка на <code>".scala"</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте позбутись <code>var</code> в Лістингу 7.16, один підхід, що ви можете спробувати, це переписати цикл як рекурсивну функцію. Ви можете, наприклад, визначити функцію <code>searchFrom</code>, що приймає ціле на вході, шукає з цього місця, та потім повертає індекс потрібного аргументу. Використовуючи цей прийом, код буде виглядати, як показано в Лістингу 7.17:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="n">i</span>
  <span class="k">else</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">i</span> <span class="k">=</span> <span class="n">searchFrom</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.17 - Рекурсивна альтернатива до циклів з <code>var</code>.</p></div>
<div class="paragraph"><p>Версія в Лістингу 7.17 дає змістовне ім'я тому, що робить функція, та вона використовує рекурсію для заміни циклу. Кожне <code>continue</code> замінюється рекурсивним викликом з аргументом <code>i + 1</code>, що ефективно просуває до наступного аргументу. Багато людей знаходять, що цей стиль програмування простіший для розуміння, як тільки вони переходять до використання рекурсії.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Компілятор Scala насправді не видасть рекурсивну функцію для коду, показаному на Лістингу 7.17. Оскільки всі рекурсівні виклики в позиції хвостового-виклику, компілятор буде генерувати код, подібний до циклу <code>while</code>. Кожний рекурсивний виклик буде реалізований як стрибок в зворотньому напрямку на початок функції. Оптимізація хвостового виклику обговорюється в Розділі 8.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо після всієї цієї дискусії ви все ще потребуєте використовувати <code>break</code>, існує допомого з боку стандартної бібліотеки Scala. Клас <code>Breaks</code> в пакунку <code>scala.util.control</code> пропонує метод <code>break</code>, що може бути використаний для виходу з оточуючого блоку, що відмічений як <code>breakable</code>. Ось приклад, як може бути застосований цей наданий бібліотекою метод <code>break</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.control.Breaks._</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">in</span><span class="o">))</span>

<span class="n">breakable</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;? &quot;</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="n">break</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде читати непусті рядки зі стандартного входу. Коли користувач введе порожній рядок, керування потоком вийде з оточуючого  <code>breakable</code>, і разом з цім з циклу <code>while</code>. Клас <code>Breaks</code> реалізує  <code>break</code> через закидання виключення, що перехоплюється оточуючим застосуванням метода <code>breakable</code>. Таким чином, виклик до <code>break</code> не обов'язково повинен бути в тому самому методі, що викликає <code>breakable</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_7___">7.7 Поле зору змінної</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили вбудовані керівні структури Scala, ми будемо використовувати їх в цьому розділі для пояснення, як поле зору робить в Scala.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java__3">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви Java програміст, ви знайдете, що правила поля зору в Scala майже ідентичні до Java. Одна різниця між Java та Scala в тому, що  Scala дозволяє вам визначати змінні з тим самим ім'ям у вкладених блоках. Так що якщо ви Java програміст, ви маєте щанайменьше передивитись цей розділ.</p></div>
<div class="paragraph"><p>Декларації змінинх в Scala програмах мають поле зору, яке визначає, де ви можете використовувати ім'я. Найбільш загальни приклад поля зору полягаеє в тому, що фігурні дужки загалом вводять нове поле зору, так що будь-що, визначене в фігурних дужках виходить з поля зору після закриваючої фігурної дужки.<span class="footnote"><br />[Є декілька виключень з цього правила, оскільки в Scala ви іноді використовуєте фігурні дужки замість дужок. Один приклад цього різновиду використання фігурних дужок альтернативний синтаксис виразу <code>for</code>, описаний в Розділі 7.3.]<br /></span> Як ілюстрацію розгліянемо функцію, показану в Лістингу  7.18.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printMultiTable</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">1</span>
<span class="c1">// в полі зору тільки i</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="mi">1</span>
<span class="c1">// в полі зору i та j</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="o">).</span><span class="n">toString</span>
<span class="c1">// в полі зору  i, j, prod</span>
      <span class="k">var</span> <span class="n">k</span> <span class="k">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">length</span>
<span class="c1">// в полі зору i, j, prod, k</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">print</span><span class="o">(</span><span class="n">prod</span><span class="o">)</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
 <span class="c1">// в полі зору i та j; prod та k вийшли</span>
  <span class="o">}</span>
  <span class="n">println</span><span class="o">()</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c1">// в полі зору все ще i; j, prod, k вийшли</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.18 - Поле зору змінних при друкуванні таблиці множення.</p></div>
<div class="paragraph"><p>Функція <code>printMultiTable</code>, показана в Лістингу 7.18, друкує таблицю множення.<span class="footnote"><br />[Функція <code>printMultiTable</code>, показана в Лістингу 7.18 написана в імперативному стилі. Ми зробимо її рефактор в функціональному стилі в наступному розділі.]<br /></span> Перше твердження цієї функції вводить змінну на ім'я <code>i</code>, та ініціалізує її цілим <code>1</code>. Потім ви можете використовувати ім'я <code>i</code> в залишку функції.</p></div>
<div class="paragraph"><p>Наступне твердження в <code>printMultiTable</code> є цикл <code>while</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете використовутати тут <code>i</code> також, бо вона все ще в полі зору. В першому твердженні в циклі <code>while</code> ви вводите іншу змінну, не цей раз з назвою <code>j</code>, та знову ініціалізуємо її в <code>1</code>. Оскільки змінна <code>j</code> була визначена в відкритих фігурних дужках циклу <code>while</code>, вона може бути вкористана тільки в циклі <code>while</code>. Якщо ви спробуєте зробити щось з <code>j</code> після зачинення фігурних дужок цикла <code>while</code>, після коментаря, що каже, що <code>j</code>, <code>prod</code>, та <code>k</code> за полем зору, ваша програма не буде компілюватись.</p></div>
<div class="paragraph"><p>Всі змінні, визначені в цьому прикладі — <code>i</code>, <code>j</code>, <code>prod</code>, <code>k</code> — є локальними змінними. Такі змінні "локальні" для функції, в якій вони визначені. Кожного разу, коли функція викликається, використовується новий набір локальних змінних.</p></div>
<div class="paragraph"><p>Коли змінна визначена, ви не можете визначити нову змінну з тим самим ім'ям в тому ж самому полі зору. Наприклад, наступний скрипт з двома змінними на ім'я <code>a</code> в тому ж полі зору не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// Не компілюється</span>
<span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку ви можете визначити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. Наступний скрипт буде компілюватись та виконуватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// Чудово компілюється</span>
  <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>При виконанні показаний перед цім скрипт буде друкувати 2, та потім 1, оскільки <code>a</code> визначене в фігурних дужках, є іншою змінною, яка в полі зору доки не будуть закриті фігурні дужки.<span class="footnote"><br />[Доречі, в цьому випадку крапка з комою є необхідними після першого визначення <code>a</code>, оскільки механізм виводу крапки з комою Scala не буде ставити її в цьому випадку.]<br /></span> Одна різниця між Scala та Java в тому, що Java не дозволить вам створити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. В програмі Scala внутрішня змінна, як кажуть, <em>затінює</em> змінну з таким же ім'ям, оскільки зовнішня змінна стає невидимою у внутрішньому полі зору.</p></div>
<div class="paragraph"><p>Ви могли вже зазначити в інтерпретаторі дещо, що виглядає як затінення, :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>В інтерпретаторі ви можете повторно використовувати імена змінних за покликом вашого серця. Поміж інших речей, це дозволяє вам змінити вашу думку, якщо ви зробили помилку, коли перший раз визначали змінну в інтерпретаторі. Ви можете робити це, бо інтерпретатор відкриває нове вкладене поле зору для кожного нового твердження, яке ви набираєте. Таким чином, ви можете віалізувати попередній інтерпретований код так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
  <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код буде компілюватись та виконуватись як Scala скрипт, та, як і код, набраний в інтерпретаторі, буде друкувати 2. Майте на увазі, що такий код буде дуже бентежливий для читачів, оскільки імена змінних приймають нові значення у вкладених полях зору. Зазвичай краще створити нове, осмислене ім'я, ніж затінювати зовнішню змінну.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_8_____">7.8 Рефакторинг коду в імперативному стилі</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб допомогти вам отримати уявлення про функціональний стиль, в цьому розділі ми зробимо рефакторинг імперативного підходу до друку таблиці множеннчя, показаного в Лістингу 7.18. Наша функціональна альтернатива показана на Лістингу 7.19.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Повертає рядок як послідовність</span>
<span class="k">def</span> <span class="n">makeRowSeq</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">col</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="o">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">col</span><span class="o">).</span><span class="n">toString</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">prod</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">padding</span> <span class="o">+</span> <span class="n">prod</span>
  <span class="o">}</span>

<span class="c1">// Повертає рядок як рядок</span>
<span class="k">def</span> <span class="n">makeRow</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">makeRowSeq</span><span class="o">(</span><span class="n">row</span><span class="o">).</span><span class="n">mkString</span>

<span class="c1">// Повертає таблицю як рядок</span>
<span class="k">def</span> <span class="n">multiTable</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">tableSeq</span> <span class="k">=</span> <span class="c1">// послідовність сирих рядків</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span>
      <span class="k">yield</span> <span class="n">makeRow</span><span class="o">(</span><span class="n">row</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">tableSeq</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span><span class="nc">Listing</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>7.19 - Функціональний спосіб створити таблицю множення.</p></div>
<div class="paragraph"><p>Імперативний стиль виявляє себе в Лістинуг 7.18 в два способи. Перше, виклик <code>printMultiTable</code> має побічний ефект: друк таблиці множення на стандартний вивід. В Лістингу 7.19 ми зробили рефакторинг функції, так що вона повертає таблицю множення як рядок. Оскільки функція більше не друкує, ми переіменували її на <code>multiTable</code>. Як зазначалось до цього, одна з переваг функцій, вільних від побічних ефектів, в тому, що їх легче тестувати. Щоб протестувати <code>printMultiTable</code>, вам знадобиться якось перевизначити <code>print</code> та <code>println</code>, так що ви зможете перевірити вивід на коректність. Ви можете тестувати <code>multiTable</code> більш просто, перевіряючи рядок її результата.</p></div>
<div class="paragraph"><p>Інший промовистий знак імперативного стилю в <code>printMultiTable</code> є її цикл <code>while</code> та <code>var</code>. Для контрасту, функція <code>multiTable</code> використовує <code>val</code>, вирази <code>for</code>, допоміжні функції та виклики до <code>mkString</code>.</p></div>
<div class="paragraph"><p>Ми виділили дві допоміжні функції, <code>makeRow</code> та <code>makeRowSeq</code>, щоб спростити читанян кода. Функція <code>makeRowSeq</code> використовує вираз <code>for</code>, чий генератор ітерує по номерах стовпчиків від 1 до 10. Тіло цього <code>for</code> обчислює добуток рядка та стовпчика, визначає відступ для результату, та видає результат конкатенації рядків відступу та добутку. Результатом виразу <code>for</code> буде послідовність (деякий субклас <code>scala.Seq</code>), до міститиме ці отримані рядки як елементи. Інша допоміжна функція, <code>makeRow</code>, просто викликає <code>mkString</code> на результаті, повернутому <code>makeRowSeq</code>. <code>mkString</code> буде конкатенувати рядки в послідовності, та поверне їх як один рядок.</p></div>
<div class="paragraph"><p>Метод <code>multiTable</code> зпочатку ініціалізує <code>tableSeq</code> результатом виразу <code>for</code>, чий генератор ітерує по номерах рядків від 1 до 10, та для кожного викликає <code>makeRow</code>, щоб отримати рядок. Цей рядок отримається через <code>yield</code>; так що результатом виразу буде послідовність рядків. Єдине завдання, що залишилось, це конвертувати рядки в один рядок. Це робить виклик <code>mkString</code>, та оскільки ми передаємо <code>"\n"</code>, ми отримуємо символ нового рядка між кожним рядком. Якщо ви передасте рядок, повернутий <code>multiTable</code>, до <code>println</code>, ви побачите той самий вивід, що продукує і виклик <code>printMultiTable</code>.</p></div>
<div class="literalblock">
<div class="content">
<pre><code> 1  2  3  4  5  6  7  8  9 10
 2  4  6  8 10 12 14 16 18 20
 3  6  9 12 15 18 21 24 27 30
 4  8 12 16 20 24 28 32 36 40
 5 10 15 20 25 30 35 40 45 50
 6 12 18 24 30 36 42 48 54 60
 7 14 21 28 35 42 49 56 63 70
 8 16 24 32 40 48 56 64 72 80
 9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_9_">7.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вбудовані керівні структури Scala є мінімальними, але вони роблять свою справу. Вони роблять подібно до своїх імперативних еквівалентів, але оскільки вони схильні повертати значення, вони також підтримують функціональний стиль. Що також важливо, вони уважні щодо того, що вони оминають, таким чином лишаючи простір для однієї з найбільш потужних можливостей Scala, функціональних літералів, що будуть описані в наступній главі.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__8_2">Глава 8</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____6">Функції та замикання</h1>
<div class="paragraph"><p>Коли програма стає більшою, вам треба якийсь спосіб поділити її на меньші, більш керовані частини. Щоб поділити поток керування, Scala пропонує підхід, знайомий всім досвідченим програмістам: поділення коду на функції. Фактично, Scala пропонує декілька способів визначити фінкції, які не присутні в Java. Крім методів, що є функціями, що є членами деякого об'єкту, також є функції, що вкладені в функції, функціональні літерали, та функціональні значення. Ця глава бере вас в тур по всім цім різновидам функцій в Scala.</p></div>
<div class="sect1">
<h2 id="_8_1_">8.1 Методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Найбільш загальний спосіб визначити функцію є член деякого об'єкта; така функція називається методом. Наприклад, Лістинг 8.1 показує два методи, що разом читають файл з заданим ім'ям, та друкують всі рядки, чия довжина перевищує задану довжину. Кожний надрукований рядок має префікс з імені файлу, де він з'являєтья.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>

<span class="k">object</span> <span class="nc">LongLines</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">processFile</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">source</span><span class="o">.</span><span class="n">getLines</span><span class="o">())</span>
      <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">width</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 8.1 - <code>LongLines</code> з приватним методом <code>processLine</code>.</p></div>
<div class="paragraph"><p>Метод <code>processFile</code> приймає ім'я файлу та ширину як параметри. Він створює об'єкт <code>Source</code> з файла, в генераторі виразу <code>for</code>, викликає <code>getLines</code> на <code>source</code>. Як зазначається на Кроці 12 в Главі 3, <code>getLines</code> повертає ітератор, що провадить один рядок з файла на кожній ітерації, виключаючи символ нового рядка. Вираз <code>for</code> обробляє кожний з ціх рядків, викликаючи допоміжний метод <code>processLine</code>. Метод <code>processLine</code> приймає три параметри: ім'я файлу, ширину та рядок. Він перевіряє, чи довжина рядка більша, ніж задана довжина, і якщо це так, друкує ім'я файла, дві крапки та рядок.</p></div>
<div class="paragraph"><p>Щоб використовувати <code>LongLines</code> з командного рядка, ми створимо застосування, що очікує довжину рядка в якості свого першого аргументу командного рядка, та інтерпретує подальші аргументи як імена файлів:<span class="footnote"><br />[І цій книжці ми зазвичай не будемо перевіряти аргументи командного рядка на валідність в застосування-прикладах, обоє, щоб зберігти дерева, та зменшити шаблонний код, що може затьмарити важливий код приклада. Компромісом є те, що замість продукувати корисне повідомлення про помилку, коли отриманий поганий ввід, наше приклад застосування буде закидати виключення.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">FindLongLines</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">width</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toInt</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
      <span class="nc">LongLines</span><span class="o">.</span><span class="n">processFile</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">width</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як ви використовуєте це застосування для пошуку рядків в <code>LongLines.scala</code>, що понад 45 символів в довжину (такий тільки один):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala FindLongLines 45 LongLines.scala
LongLines.scala: def processFile(filename: String, width: Int) = {</code></pre>
</div></div>
<div class="paragraph"><p>Доки все це дуже подібне до того, що ми робити в любій об'єктно-орієнтовній мові. Однак концепція функції в  Scala є більш загальною, ніж метод. Інші шляхи Scala для вираженян функцій будуть пояснені в наступних розділах.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_2__">8.2 Локальні функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Конструкція метода <code>processFile</code> в попередньму розділі демонструє важливий принцип розробки в стилі функціонального програмування: програми мають бути розкладені на багато малих функцій, кожна з яких робить добре визначене завдання. Окремі функції часто досить малі. Перевага цього стилю в тому, що він дає програмісту багато будівельних блоків, що можуть бути гнучко скомпоновані для виконання більш складних речей. Кожний будівельний блок має бути досить простим, щоб бути індивідуально зрозумілим.</p></div>
<div class="paragraph"><p>Одна проблема з цім підходом в тому, що всі імена допоміжних функцій можуть заповнити простір імен програми. В інтерпретаторі це невелика проблема, але коли функції запаковані в повторно використовувані класи та об'єкти, бажано приховати допоміжні функції від клієнтів класу. Вони часто не мають сенсу окремо, та ви часто бажаєте зберігти досить гнучкості видалити допомжіну функцію, якщо потім перепишете клас в інший спосіб.</p></div>
<div class="paragraph"><p>В Java ваш головний інструмент для цієї цілі є приватний метод. Підхід приватних методів робить в Scala також, як демонструє Лістинг 8.1, але Scala пропонує додатковий підхід: ви можете визначити функцію всередині іншої функції. Так само, як локальні змінні, такі локальні функції видимі тільки в своєму оточуючому блоці. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">processFile</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
      <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">width</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">source</span><span class="o">.</span><span class="n">getLines</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">processLine</span><span class="o">(</span><span class="n">filename</span><span class="o">,</span> <span class="n">width</span><span class="o">,</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі ми зробили рефакторинг оригінальної версії <code>LongLines</code>, показаної в Лістингу 8.1, трансформуючи приватний метод <code>processLine</code> в локальну функцію <code>processFile</code>. Щоб зробити це, ми видалили модифікатор <code>private</code>, який може бути застосований (і тілько коли потрібно) тільки для методів, та поклали визначення <code>processLine</code> всередину визначення <code>processFile</code>. Як локальна функція, <code>processLine</code> в полі зору <code>processFile</code>, але недоступна ззовні. Однак тепер, коли <code>processLine</code> визначена всередині <code>processFile</code>, стає можливим ще одне покращення. Зауважте, як <code>filename</code> та <code>width</code> передаються незмінними до допоміжної функції? Це не є необхідним, бо локальні функції можуть отримувати доступ до параметрів оточуючої їх функції. Ви можете просто використовувати параметри зовнішньої функції <code>processLine</code>, як показане в Лістингу 8.2.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>

<span class="k">object</span> <span class="nc">LongLines</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">processFile</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">processLine</span><span class="o">(</span><span class="n">line</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">width</span><span class="o">)</span>
        <span class="n">println</span><span class="o">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">source</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">source</span><span class="o">.</span><span class="n">getLines</span><span class="o">())</span>
      <span class="n">processLine</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 8.2 - <code>LongLines</code> з локальною функцією <code>processLine</code>.</p></div>
<div class="paragraph"><p>Простіше, чи не так? Це використання параметрів оточуючою функції є загальним та корисним прикладом загального вкладання, яке провадить Scala. Вкладання та поле зору, описані в Розділі 7.7, стосуються всіх конструкцій Scala, включаючи функції. Це простий принцип, але дуже потужний, особливо в мові з першокласними функціями.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_3__">8.3 Першокласні функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має першокласні функції. Не тільки вона визначає функції та викликає їх, але ви можете писати функції як неіменовані літерали, та потім передавати їх як значення. Ми ввели функціональні літерали в Главі 2, та показані в базовому синтаксисі на Малюнку 2.2.</p></div>
<div class="paragraph"><p>Функціональний літерал компілюється в клас, екземпляр якого створюється під час виконання, що і є значенням функції.<span class="footnote"><br />[Кожне функціональне значення є примірником деякого класу, що розширює один з <code>FunctionNtraits</code> в пакунку <code>scala</code>, такий як <code>Function0</code> для функцій без параметрів, <code>Function1</code> для функцій з одним параметром, і так далі. Кожний трейт <code>FunctionN</code> має метод <code>apply</code>, що використовується для виклику функції.]<br /></span> Таким чином, різниця між функціональними літералами і значеннями в тому, що функціональні літерали існують в джерельному коді, тоді як значення функцій існують як об'єкт під час виконання. Різниця в основному така, як між класами (джерельний код) та об'єктами (час виконання).</p></div>
<div class="paragraph"><p>Ось простий приклад функціонального літерала, що додає одиницю до числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p><code>=&gt;</code> означає, що ця функція конвертує річ зліва (любе ціле <code>x</code>) на річ зправа <code>(x + 1)</code>. Так що ця функція конвертує любе ціле <code>x</code> на <code>x + 1</code>. Значення функцій є об'єктами, так що ви можете зберігати їх в змінних, якщо бажаєте. Вони також функції, так що ви можете викликати їх, використовуючи звичайну нотацію виклику функцій з дужками. Ось приклад того і іншого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">increase</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">increase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки в цьому прикладі <code>increase</code> є <code>var</code>, пізніше ви можете присвоїти їй інше функціональне значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">9999</span>
<span class="n">increase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10009</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте більше ніж одне твердження в функціональному літералі, оточіть його тіло в фігурні дужки, та покладіть твердження по одному на рядок, таким чином формуючи блок. Так само, як в методі, коли обчислюється функціональний літерал всі твердження будуть обчислені, та буде повернуте значення з функції, що відповідає обчисленню останнього виразу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;We&quot;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;are&quot;</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;here!&quot;</span><span class="o">)</span>
  <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>

<span class="n">increase</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">increase</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="nc">We</span>
<span class="n">are</span>
<span class="n">here</span><span class="o">!</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви бачили всі принаддя функціональних літералів та функціональних значень. Багато Scala бібліотек дають вам можливіть використовувати їх. Наприклад, метод <code>foreach</code> доступний для всіх колекцій.<span class="footnote"><br />[Метод <code>foreach</code> визначений в трейті <code>Traversable</code>, це загальний супертрейт для <code>List</code>, <code>Set</code>, <code>Array</code>, та <code>Map</code>. Дивіться Главу 17 щодо деталей.]<br /></span> Він приймає функцію як аргумент, та викликає цю функцію для кожного елемента. Ось як він може використовуватись для друку всіх елементів списка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">someNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">someNumbers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">-</span><span class="mi">11</span>
<span class="o">-</span><span class="mi">10</span>
<span class="o">-</span><span class="mi">5</span>
<span class="mi">0</span>
<span class="mi">5</span>
<span class="mi">10</span>
</pre></div></div></div>
<div class="paragraph"><p>Як інший приклад, типи колекцій мають метод <code>filter</code>. Цей метод відбирає елементи колекції, що проходять наданий користувачем тест. Цей тест надається використовуючи функцію. Наприклад, функція <code>function (x: Int) =&gt; x &gt; 0</code> може використовуватись для фільтрації. Ця функція відзеркалює додатні цілі на <code>true</code>, та всі інші на <code>false</code>. Ось як використовувати її з фільтром:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи, як <code>foreach</code> та <code>filter</code> описані далі в цій книжці. Глава 16 каже про їх використання в класі <code>List</code>. Глава 17 обговорює їх використання з іншими типами колекцій.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_4____">8.4 Короткі форми функціональних літералів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить декілька шляхів для відкидання надлишкової інформації, та написання функціональних літералів більш скорочено. Придивіться краще до ціх можливостей, оскільки вони дозволяють вам видалити безлад з вашого кода.</p></div>
<div class="paragraph"><p>Один шлях зробити функціональні літерали більш короткими, це відкинути типи парамертів. Такім чином, попередній приклад з <code>filter</code> може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">((</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор Scala знає, що <code>x</code> має бути цілим, оскільки він бачить, що ви безпосередньо фикористовуєте функцію для фільтрації списку цілих (на який посилається <code>someNumbers</code>). Це називається цільовий тип, оскільки цільове використання виразу (в цьому випадку аргумент до <code>someNumbers.filter()</code>) може впливати на тип цього виразу (в цьому випадку для визначення типу параметра <code>x</code>). Точні деталі цільової типізації не є важливі. Ви можете просто почати написання функціонального літералу без типу аргументу, та якщо компілятор збентежений додайте тип. З часом ви набудете відчуття, в яких ситуаціях компілятор може або не може вирішити загадку.</p></div>
<div class="paragraph"><p>Другий шлях видалити непотрібні символи, це прибрати дужки коло параметра, чий тип виведений. В попередньому прикладі дужки коло <code>x</code> непотрібні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_5__">8.5 Синтаксис замінника</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб зробити функціональний функціонал ще більш стислим, ви можете використовувати підкреслення для одного або більше параметрів, доки кожний параметр з'являється тільки один раз в функціональному літералі. Наприклад, <code>_ &gt; 0</code> є дуже коротка нотація для функції, що перевіряє, чи значення більше за нуль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете думати про підкреслення як про "порожнє місце" в виразі, що треба "заповнити". Пусте місце буде заповнене аргументом функції, кожний раз, коли функція викликається. Наприклад, приймаючи, що <code>someNumbers</code> було тут ініціалізоване як <code>valueList(-11, -10, -5, 0, 5, 10)</code>, метод <code>filter</code> буде замінювати порожнє місце в <code>_ &gt; 0</code> спочатку на <code>-11</code>, як в <code>-11 &gt; 0</code>, потім на <code>-10</code>, як в <code>-10 &gt; 0</code>, потім на <code>-5</code>, як в <code>- 5 &gt; 0</code>, і так далі, до кінця <code>List</code>. Таким чином, функція <code>literal _ &gt; 0</code>, еквівалентна до трохи більш балакучої <code>x =&gt; x &gt; 0</code>, як продемонстроване тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Іноді, коли ви використовуєте підкреслення як замінники для параметрів, компілятор може не мати досить інформації, щоб вивести відсутні типи параметрів. Наприклад, уявімо, що ви пишете окреме  <code>_ + _</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">missing</span> <span class="kt">parameter</span> <span class="k">type</span> <span class="kt">for</span> <span class="kt">expanded</span>
<span class="n">function</span> <span class="o">((</span><span class="n">x$1</span><span class="o">,</span> <span class="n">x$2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x$1</span><span class="o">.</span><span class="nc">$plus</span><span class="o">(</span><span class="n">x$2</span><span class="o">))</span>
       <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>In such cases, you can specify the types using a colon, like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function2</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>_ + _</code> розширюється до літерала для функції, що приймає два параметри. Ось чому ви можете писати цю коротку форму, тільки якщо кожний параметр з'являється в функціональному літералі рівно один раз. Декілька підкреслень означають декілька параметрі, не повторне використання одного параметра. Перше підкреслення представляє перший параметр, друге підкреслення - другий параметр, третє підкреслення третій параметр, і так далі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_6___">8.6 Частково застосовані функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча попередні приклади замінюють підкреслення на окремі параметри, ви також можете замітити цілий список параметрів на підкреслення. Наприклад, скоріше, ніж писати <code>println(_)</code>, ви можете написати <code>println _</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala розглядає цю коротку форму так, якби ми написали наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, підкреслення в цьому випадку не є замінником для одного параметру. Це замінник для цілого списку параметрів. Пам'ятайте, що вам треба залишити один проміжок між ім'ям функції та підкресленням; інакше компілятор буде думати, що ви посилаєтесь на інший символ, як, наприклад, мето на ім'я <code>println_</code>, що навряд чи існує.</p></div>
<div class="paragraph"><p>Коли ви використовуєте підкреслення в цей спосіб, ви пишете частково застосовану функцію. В Scala, коли ви викликаєте функцію, передаючи любі необхідні аргументи, ви застосовуєте цю функцію до аргументів. Наприклад, маючи наступну функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
<span class="n">sum</span><span class="k">:</span> <span class="o">(</span><span class="kt">a:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">b:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете застосувати функцію <code>sum</code> до аргументів <code>1</code>, <code>2</code>, та <code>3</code> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>ЧАстково застосована функція є вираз, до якого ви не застосували всі аргументи, потрібні для функції. Замість цього ви надаєте деякі, або жодних з потрібних аргументів. Наприклад, щоб створити вираз частково застосованої функції, що включає <code>sum</code>, якій ви не надаєте жодної з трьох потрібних аргументів, ви просто ставите підкреслення після <code>sum</code>. Результуюча функція потім може бути збережена в змінній. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">sum</span> <span class="k">_</span>
<span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function3</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код, компілятор Scala створює примірник функції, що приймає три цілі параметри, відсутні в виразі частково застосованої функції <code>sum _</code>, та присвоює посилання на значення цієї нової функції до змінної <code>a</code>. Потім ви застосовуєте три аргументи до значення цієї нової функції, яка в свою чергу викликає <code>sum</code>, передаючи ті самі три параметри:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось що тільки но тут відбулось: змінна на ім'я <code>a</code> посилається на об'єкт з функціональним значенням. Це функціональне значення є примірником класу, згенерованого автоматично компілятором Scala з <code>sum _</code>, вираза частково застосованої функції. Згенерований компілятором клас має метод <code>apply</code>, що приймає три аргументи.<span class="footnote"><br />[Згенерований клас розширює трейт <code>Function3</code>, що декларує метод <code>apply</code> з трьома аргументами.]<br /></span> Метод <code>apply</code> згенерованого класу приймає три аргументи, оскільки рівно стільки аргументів не вистачає в виразі <code>sum _</code>. Компілтор Scala транслює вираз <code>a(1, 2, 3)</code> на виклик меетода значення <code>apply</code>, передаючи три аргументи, <code>1</code>, <code>2</code>, та <code>3</code>. Таким чином, <code>a(1, 2, 3)</code> є скороченням для:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей метод <code>apply</code>, визначений в автоматично згенерованому класі компілятором Scala з виразу <code>sum _</code>, просто пересилає ці три невистачаючі параметри до <code>sum</code>, та повертає результат. В цьому випадку, <code>apply</code> викликає <code>sum(1, 2, 3)</code>, та повертає те, що повертає <code>sum</code>, наразі <code>6</code>. Інший спосіб думати про цей різновид виразів, в яких підкреслення використовується для представлення цілого списку параметрів, як про шлях перетворити <code>def</code> в функціональне значення. Наприклад, якщо ви маєте локальну функцію, таку як <code>sum(a: Int, b: Int, c: Int): Int</code>, ви можете "огорнути" її в функціональне значення, чий метод <code>apply</code> матиме той самий список параметрів та типи результата. Потім ви застосовуєте <code>apply</code> цього функціонального значення до деяких аргументів, який, в свою чергу, застосовує <code>sum</code> до тих самих аргументів, та повертає повернутий результат. Хоча ви не можете присвоїти метод або вкладену функцію до змінної, або передати її як аргумент до іншої функції, ви можете робити ці речі, якщо ви огорнете метод або вкладену функцію в функціональне значення, поставивши підкреслення після її імені.</p></div>
<div class="paragraph"><p>Тепер, хоча <code>sum _</code> безумовно частково застосована функція, в такий спосіб вам може не виглядати очевидним, чому вона названа саме так. Вона має це ім'я, оскільки ви не застосовуєте цю функцію до всіх аргументів. В випадку <code>sum _</code>, ви не застосували її до жодного аргументу. Але ви також можете виразити частково застосовану функцію, надавши тільки деякі з потрібних аргументів. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">Int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку ви надали перший та останній аргумент до <code>sum</code>, але не до середнього аргументу. Оскікльки один аргумент відсутній, компілятор Scala генерує функціональний клас, чий метод <code>apply</code> приймає один аргумент. Коли викликаний з одним аргументом, метод <code>apply</code> цієї згенерованої функції викликає <code>sum</code>, передаючи <code>1</code>, аргумент, переданий до функції, та <code>3</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку <code>b.apply</code> викликає <code>sum(1, 2, 3)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>І в цьому випадку <code>b.apply</code> викликає <code>sum(1, 5, 3)</code>.</p></div>
<div class="paragraph"><p>Якщо ви пишете частково застосовану функцію, в якій ви залишаєте всі параметри, таку як <code>println _</code> або <code>sum _</code>, ви можете виразити її більш стисло, відкинувши підкреслення, коли функція потрібна в цьому місці в коді. Наприклад, замість друкувати кожне число в <code>someNumbers</code> (визначена тут) ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете просто записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця остання форма дозволяється тільки в місціх, де потрібна функція, таких, як виклик  <code>foreach</code> в цьому прикладі. В цьому випадку компілятор знає що потрібна функція, оскільки <code>foreach</code> вимагає, щоб в якості аргумента була передана функція. В ситуаціях, коли функція не вимагається, спроба використати цю форму спричинить помилку компіляції. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">sum</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">missing</span> <span class="kt">arguments</span> <span class="kt">for</span> <span class="kt">method</span> <span class="kt">sum</span><span class="o">;</span>
<span class="n">follow</span> <span class="k">this</span> <span class="n">method</span> <span class="k">with</span> <span class="err">`</span><span class="k">_</span><span class="err">&#39;</span> <span class="k">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">treat</span> <span class="n">it</span> <span class="n">as</span> <span class="n">a</span>
<span class="n">partially</span> <span class="n">applied</span> <span class="n">function</span>
       <span class="k">val</span> <span class="n">c</span> <span class="k">=</span> <span class="n">sum</span>
               <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="n">sum</span> <span class="k">_</span>
<span class="n">d</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function3</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">d</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">60</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_7_">8.7 Замикання</h2>
<div class="sectionbody">
<div class="paragraph"><p>Докі в цій главі всі приклади функціональних літералів посилались тільки для переданих параметрів. Наприклад, в <code>(x: Int) =&gt; x &gt; 0</code>, єдиною змінною, що використовується в тілі функції, <code>x &gt; 0</code>, <code>x</code>, що визначається як параметр функції. Однак ви можете посилатись на змінні, визначені деінде:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span> <span class="c1">// наскільки much?</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція додає <code>more</code> до свого аргументу, але що таке <code>more</code>? З точки зору цієї функції, <code>more</code> є <em>вільна змінна</em>, оскільки сам функціональний літерал сам по собі не надає їй значення. На відміну, змінна <code>x</code> є <em>прив'язаною змінною</em>, оскільки вона має значення в контексті функції: вона визначена як єдиний параметр функції, <code>Int</code>. Якщо ви спробуєте використати цей функціональний літера сам по собі, без деякого <code>more</code>, визначеного в полі зору, компілятор буде скаржитись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="kt">value</span> <span class="kt">more</span>
               <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
                               <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="____7">Чому завершуюче підкреслення?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис Scala для частково застосованих функцій підкреслює різницю між компромісами дизайну Scala, та класичних функціональних мов, таких як <code>Haskell</code> або <code>ML</code>. В ціх мовах, частково застосовані функції розглядаються як звичайний випадок. Більше того, ці мови мають досить сувору статичну систему типів, що зазвичай буде підкреслювати кожну помилку з частковим застосуванням, що ви можете зробити. Scala дотримується значно блищого відношення до імперативних мов, таких як Java, де метод, що не застосовується до всіх своїх аргументів розглядається як помилка. Більше того, об'єктно-орієнтовні традиції субтипізації і універсального кореневого типу приймає деякі програми, що мали б розглядатись як помилкові в класичних функціональних мовах.</p></div>
<div class="paragraph"><p>Наприклад, скажімо, ви переплутали метод <code>drop(n: Int)</code> в <code>List</code> з <code>tail()</code>, і, таким чином, забули, що вам треба передати число до <code>drop</code>. Ви можете записати <code>println(drop)</code>. Коли б Scala приймала класичну функціональну традицію, що частково застосовані функції гарні будь-де, цей код пройшов би перевірку типів. Однак ви можете бути здивовані знайти, що результат, який буде друкувати це твердження <code>println</code>, буде завжди <code>&lt;function&gt;</code>! Що відбуєеться, це те, що вираз <code>drop</code> буде трактуватись як функціональний об'єкт. Оскільки  <code>println</code> приймає об'єкти любого типу, це буде компілюватись OK, але це матиме непередбачуваний результат.</p></div>
<div class="paragraph"><p>Щоб уникати ситуацій як така, Scala звичайно потребує, щоб ви вказували аргументи функцій, що зщалишились, явно, навіть якщо вони вказані так просто, як символом <code>_</code>. Scala дозволяє вам відкинути <code>_</code> тільки коли очікується функціональний тип. З іншого боку, той же функціональний літерал буде робити добре, доки доступне дещо на ім'я <code>more</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">more</span> <span class="k">=</span> <span class="mi">1</span>
<span class="n">more</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">addMore</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
<span class="n">addMore</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addMore</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Функціональне значення (об'єкт), що створений під час виконання з цього функціонального літерала, називається <em>замиканням</em>. Назва походить з дії "замикання" функціонального літерала, через "захоплення" прив'язок його вільних змінних. Функціональний літерал без вільних змінних, такий як <code>(x: Int) =&gt; x + 1</code>, називається <em>замкненим термом</em>, де <em>терм</em> це фрагмент джерельного коду. Таким чином, функціональне значення, створене під час виконання з цього функціонального літерала не є замиканням в суворішому сенсі, оскікльи <code>(x: Int) =&gt; x + 1</code> вже замкнений як є написаний. Але кожний функціональний літерал з вільними змінними, як <code>(x: Int) =&gt; x + more</code>, є <em>відкритим термом</em>. Таким чином, любе функціональне значення, створене під час виконання з <code>(x: Int) =&gt; x + more</code> буде, по визначення, потребувати, щоб прив'язка до вільної змінної  <code>more</code> була захоплена. Отримане функціональне значення, що буде містити посилання на захоплену змінну <code>more</code>, називається замиканням, оскільки значення функції є кінцевим продуктом дії замикання відкритого терму <code>(x: Int) =&gt; x + more</code>.</p></div>
<div class="paragraph"><p>This example brings up a question: What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change. For example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">more</span> <span class="k">=</span> <span class="mi">9999</span>
<span class="n">more</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9999</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addMore</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10009</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтуітивно, замикання Scala захоплюють самі змінні, не значення, на які посилаються змінні.<span class="footnote"><br />[На відміну, внутрішні класи Java взагалі не дозволяють вам отримувати доступ до непостійних змінних в оточуючому полі зору, так що немає різниці між захопленням змінної, та захопленням її поточного значення.]<br /></span> Як показує попередній приклад, замикання, створене для <code>(x: Int) =&gt; x + more</code> бачить зміни в <code>more</code>, зроблені за межами замикання. Те саме вірно в зворотньому напрямку. Зміни, зроблені в замиканні до захопленої змінної, видимі за межами замикання. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">someNumbers</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">someNumbers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">11</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">someNumbers</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="k">_</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад використовує обхідний шлях до підрахунку суми чисел в <code>List</code>. Змінна <code>sum</code> знаходиться в оточуючому полі зору відносно функціонального літерала <code>sum += _</code>, що додає числа до <code>sum</code>. Навіть зважаючи, що це замикання модифікує <code>sum</code> під час виконання, результуючий загал, <code>-11</code>, все ще видимий за межами замикання.</p></div>
<div class="paragraph"><p>Що буде, якщо замикання має доступ до деякої змінної, що має декілька різних копій по мірі роботи програми? Наприклад, якщо замикання використовує локальну змінну деякої функції, та функція викликається декілька раз? ЯКий примірник цієї змінної буде використовуватись при кожному доступі?</p></div>
<div class="paragraph"><p>Тільки одна відповідь узгоджена з залишком мови: використовується той примірник, що був активний під час створення замикання. Наприклад, ось функція, що створює та повертає замикання "збільшити":</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">makeIncreaser</span><span class="o">(</span><span class="n">more</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">more</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний раз, коли викликається ця функція, вона буде створювати нове замикання. Кожне замикання буде отримувати доступ до змінної <code>more</code>, що була активною під час створення змінної.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">inc1</span> <span class="k">=</span> <span class="n">makeIncreaser</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">inc1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">inc9999</span> <span class="k">=</span> <span class="n">makeIncreaser</span><span class="o">(</span><span class="mi">9999</span><span class="o">)</span>
<span class="n">inc9999</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви викликаєте <code>makeIncreaser(1)</code>, створюється та повертається замикання, що захоплює значення <code>1</code> як прив'язку для <code>more</code>. Подібним чином, коли ви викликаєте <code>makeIncreaser(9999)</code>, повертається замикання, що захоплює значення <code>9999</code> для <code>more</code>. Коли ви застосовуєте ці замикання для аргументів (в цьому випадку є тільки один аргумент, <code>x</code>, що має бути переданий), результат, що повертається, залежить від того, як було визначене <code>more</code> при створенні замикання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">inc1</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">11</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">inc9999</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10009</span>
</pre></div></div></div>
<div class="paragraph"><p>Немає різниці, що <code>more</code> в цьому випадку є параметром до виклику метода, який вже завершився. Компілятор Scala переставляє речі в випадках як цей, так що захоплений параметр живе в кіпі, замість стеку, і, таким чином, може пережити виклик метода, що створює його. Ця перестановка турботливо виконується автоматично, так що вам не треба про це турбуватись. Обчислюйте любу змінну, яку побажаєте: <code>val</code>, <code>var</code>, або параметр.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_8_8____">8.8 Спеціальні форми виклику функцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Більшість функцій та викликів функцій, які вам трапляться, будуть такі, які ви вже бачили в цій главі. Функція буде мати фіксоване число параметрів, виклик буде мати так же число аргументів, та аргументи будуть вказані в такому ж порядку та числі, що і параметри.</p></div>
<div class="paragraph"><p>Одонак, оскільки виклики функцій є такими центральними для програмування в Scala, були додані декілька особливих форм визначення та викликів функцій, що націлені на вирішення особливих потреб. Scala підтримує повторювані параметри, іменовані аргументи та значення по замовчанню.</p></div>
<div class="sect2">
<h3 id="_repeated_parameters">Repeated parameters</h3>
<div class="paragraph"><p>Scala дозволяє вам вказати, що вписок параметрів до функції може бути повторений. Це дозволяє клієнтам передати до функції список аргументів змінної довжини. Щоб позначити повторюваний параметр, поставьте зірочку після типу параметру. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">echo</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span> <span class="k">=</span>
<span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="n">echo</span><span class="k">:</span> <span class="o">(</span><span class="kt">args:</span> <span class="kt">String*</span><span class="o">)</span><span class="kt">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначений таким чином, <code>echo</code> може бути викликаний з нулем або багатьма аргументів <code>String</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">)</span>
<span class="n">one</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world!&quot;</span><span class="o">)</span>
<span class="n">hello</span>
<span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>Всередині функції тип повторюваного параметру є <code>Array</code> декларованого типу параметру. Таким чином, тип <code>args</code> всередині функції <code>echo</code>, що декларований як тип <code>String*</code> насправді є <code>Array[String]</code>. Тим не менш, якщо ви маєте масив відповідного типу, ви можете спробувати передати його як повторюваний параметр, але отримаєте помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;What&#39;s&quot;</span><span class="o">,</span> <span class="s">&quot;up&quot;</span><span class="o">,</span> <span class="s">&quot;doc?&quot;</span><span class="o">)</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">What</span><span class=" -Symbol">&#39;s</span><span class="o">,</span> <span class="n">up</span><span class="o">,</span> <span class="n">doc</span><span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>    <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">required</span> <span class="k">:</span> <span class="kt">String</span>
              <span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="o">)</span>
              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб досягти цього, вам треба додати аргумент масиву з двокрапкою, та символ <code>_*</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">echo</span><span class="o">(</span><span class="n">arr</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
<span class="nc">What</span><span class=" -Symbol">&#39;s</span>
<span class="n">up</span>
<span class="n">doc</span><span class="o">?</span>
</pre></div></div></div>
<div class="paragraph"><p>ЦЯ нотація каже компілятору передати кожний елемент <code>arr</code> як окремий аргумент, ніж всі разом як один аргумент.</p></div>
</div>
<div class="sect2">
<h3 id="___14">Іменовані аргументи</h3>
<div class="paragraph"><p>В звичайному виклику функції аргументи в виклику співпадають один до одного в порядку параметрів викликаної функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">speed</span><span class="o">(</span><span class="n">distance</span><span class="k">:</span> <span class="kt">Float</span><span class="o">,</span> <span class="n">time</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span>
         <span class="n">distance</span> <span class="o">/</span> <span class="n">time</span>
<span class="n">speed</span><span class="k">:</span> <span class="o">(</span><span class="kt">distance:</span> <span class="kt">Float</span><span class="o">,</span> <span class="kt">time:</span> <span class="kt">Float</span><span class="o">)</span><span class="nc">Float</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">speed</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому виклику <code>100</code> відповідає до <code>distance</code>, та <code>10</code> до <code>time</code>. <code>100</code> та <code>10</code> співпадають в тому ж порядку, в якому перелічені формальні параметри.</p></div>
<div class="paragraph"><p>Іменовані аргументи дозволяють передати вам аргументи в функцію в іншому порядку. Синтаксис просто полягає в тому, що перед кожним аргументом стоіть ім'я параметру та знак рівності. Наприклад, наступний виклик до <code>speed</code> еквівалентний до <code>speed(100,10)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">speed</span><span class="o">(</span><span class="n">distance</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">10</span><span class="o">)</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Called with named arguments, the arguments can be reversed without changing the meaning:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; speed(time = 10, distance = 100)
res29: Float = 10.0</code></pre>
</div></div>
<div class="paragraph"><p>Також можливо змішувати позиційні та іменовані аргументи. В цьому випадку позщиційні аргументи ідуть першими. Іменовані аргументи найбільш часто використовуються в комбінації зі заначеннями параметрів по замовчанню.</p></div>
</div>
<div class="sect2">
<h3 id="_____9">Значення параметрів по замовчанню</h3>
<div class="paragraph"><p>Scala дозволяє вам вказувати значення по замовчанню для параметрів функцій. Аргумент для кожного такого параметру може бути опціонально пропущений в виклику функції, та в такому випадку відповідний аргумент буде заповнений значенням по замовчанню.</p></div>
<div class="paragraph"><p>Приклад показаний в Лістингу 8.3. Функція <code>printTime</code> маж один параметр, <code>out</code>, і він має значення по замовчанню <code>Console.out</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printTime</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">java.io.PrintStream</span> <span class="o">=</span> <span class="n">`Console.out`</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;time = &quot;</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Listing 8.3 - Параметр зі значенням по замовчанню.</p></div>
<div class="paragraph"><p>Якщо ви викличете функцію як <code>printTime()</code>, таким чином не вказуючи аргумента, що буде вказувати на пристрій виводу <code>out</code>, тоді <code>out</code> буде встановлений в його значення по замовчанню, <code>Console.out</code>. Ви можете також викликати функцію з явним потоком виводу. Наприклад, ви можете надіслати журналювання до стандарного виводу помилок, викликавши функцію як <code>printTime(Console.err)</code>. Параметри по замовчанню особливо корисні, коли використовуються в комбінації з іменованими параметрами. В Лістигу 8.4 функція <code>printTime2</code> має два опціональні параметри. Параметр <code>out</code> має по замовчанню значення <code>Console.out</code>, та параметр <code>divisor</code> має значення по замовчанню <code>1</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printTime2</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">java.io.PrintStream</span> <span class="o">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">out</span><span class="o">,</span>
               <span class="n">divisor</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="o">)</span> <span class="k">=</span>
<span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;time = &quot;</span> <span class="o">+</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">()/</span><span class="n">divisor</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 8.4 - Функція з двома параметрами, що мають значення по замовчанню.</p></div>
<div class="paragraph"><p>Функція <code>printTime2</code> може бути викликана як <code>printTime2()</code> щоб мати обоє свої параметри заповненими їх значеннями по замовчанню. Однак через іменовані аргументи один з параметрів може бути заданий, коли інший буде встановлений по замовчанню. Щоб вказати вихідний потік, викличте функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">printTime2</span><span class="o">(</span><span class="n">out</span> <span class="k">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб задати дільник часу, викличте його так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">printTime2</span><span class="o">(</span><span class="n">divisor</span> <span class="k">=</span> <span class="mi">1000</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_9__">8.9 Хвостова рекурсія</h2>
<div class="sectionbody">
<div class="paragraph"><p>В розділі 7.2 ми згадували, що для трансформації цикла <code>while</code>, що оновлює <code>var</code>, на більш функціональний стиль, що використовує тільки <code>val</code>, ви можете іноді потребувати використання рекурсії. Ось приклад рекурсивоної функції, що апроксимує значення, постійно покращуючи здогадку, доки вона не стане досить гарною:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">approximate</span><span class="o">(</span><span class="n">guess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span> <span class="n">guess</span>
  <span class="k">else</span> <span class="n">approximate</span><span class="o">(</span><span class="n">improve</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція як ця часто використовується в проблемах пошуку, з відповідними реалізаціями <code>isGoodEnough</code> та <code>improve</code>. Якщо ви бажаєте, щоб функція <code>approximate</code> виконувались скоріше, ви можете підпасти в спокусу написати цикл <code>while</code>, що спробувати пришвидшити її, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">approximateLoop</span><span class="o">(</span><span class="n">initialGuess</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">guess</span> <span class="k">=</span> <span class="n">initialGuess</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">isGoodEnough</span><span class="o">(</span><span class="n">guess</span><span class="o">))</span>
    <span class="n">guess</span> <span class="k">=</span> <span class="n">improve</span><span class="o">(</span><span class="n">guess</span><span class="o">)</span>
  <span class="n">guess</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Яка з двох версій <code>approximate</code> переважає? В термінах краткості та уникнення <code>var</code> перша, функціональна, перемагає. Але імперативний підхід, можливо, більш ефективний? Фактично, якщо заміряти час виконання, з'ясується, що вони майже ідеально однакові!</p></div>
<div class="paragraph"><p>Це може виглядати несподіванкою, оскільки рекурсивний виклик виглядає значно більш "коштовним", чи простий стрибок з кінця циклу на початок. Однак в випадку <code>approximate</code> вище компілятор Scala здатний застосувати важливу оптимізацію. Зверніть увагу, що рекурсивний виклик є останєю річчю, що трапляється в обчисленні тіла функції <code>approximate</code>. Функції як <code>approximate</code>, що викликають себе як свою останню дію, називаються хвостово рекурсивними. Компілятор Scala детектує хвостову рекурсію, та замінює його на стрибок назад, на початок функції, після оновлення параметрів функції новими значеннями.</p></div>
<div class="paragraph"><p>Мораль цього в том, що ви не повинні цураитсь використання рекурсивних алгоритмів для вирішення ваших проблем. Часто рекурсивне рішення є більш елегантним та стислим, ніж базований на циклі. Як рішення має хвостову рекурсію, не виникне ніякого навантаження часу виконання, що треба сплачувати.</p></div>
<div class="sect2">
<h3 id="______5">Трасування функцій з хвостовою рекурсією</h3>
<div class="paragraph"><p>Функція з хвостовою рекорсією не буде будувати новий фрейм стека для кожного виклика; всі виклики будуть викликатись в одному фреймі. Це може бути несподіванкою для програмістів, коли вони переглядатимуть трасу стеку програми, що схибила. Наприклад, ця функція викликає сама себе деяке число разів, та потім закидає виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">boom</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;boom!&quot;</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">boom</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція не має хвостової рекурсії, оскільки вона виконує операцію інкремента після рекурсивного виклику. Ви отримаєте те що очікували, якщо запустите цю програму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">boom</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">boom!</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">boom</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span>
<span class="o">...</span>

<span class="n">Оптимізаця</span> <span class="n">хвостової</span> <span class="n">рекурсії</span>
</pre></div></div></div>
<div class="paragraph"><p>Скомпільований код для <code>approximate</code> в основному є те саме, що і скомпільований код для <code>approximateLoop</code>. Обоє функції компілюються до тих самих тринадцяти інструкцій байткоду Java. Якщо ви подивитесь на байткод, згенерований компілятором Scala для метода з хвостовою рекурсією, <code>approximate</code>, ви побачите, що хоча обоє, <code>isGoodEnough</code> та <code>improveare</code> викликаються в тілі метода, <code>approximate</code> - ні. Компілятор Scala оптимізував геть рекурсивний виклик:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">double</span> <span class="n">approximate</span><span class="o">(</span><span class="n">double</span><span class="o">);</span>
  <span class="nc">Code</span><span class="k">:</span>
  <span class="err">0</span><span class="kt">:</span>    <span class="kt">aload_0</span>
  <span class="mi">1</span><span class="k">:</span>    <span class="kt">astore_3</span>
  <span class="mi">2</span><span class="k">:</span>    <span class="kt">aload_0</span>
  <span class="mi">3</span><span class="k">:</span>    <span class="kt">dload_1</span>
  <span class="mi">4</span><span class="k">:</span>    <span class="kt">invokevirtual</span> <span class="k">#</span><span class="err">24</span><span class="o">;</span> <span class="c1">//Method isGoodEnough:(D)Z</span>
  <span class="mi">7</span><span class="k">:</span>    <span class="kt">ifeq</span>  <span class="err">12</span>
  <span class="err">10</span><span class="kt">:</span>   <span class="kt">dload_1</span>
  <span class="mi">11</span><span class="k">:</span>   <span class="kt">dreturn</span>
  <span class="mi">12</span><span class="k">:</span>   <span class="kt">aload_0</span>
  <span class="mi">13</span><span class="k">:</span>   <span class="kt">dload_1</span>
  <span class="mi">14</span><span class="k">:</span>   <span class="kt">invokevirtual</span> <span class="k">#</span><span class="err">27</span><span class="o">;</span> <span class="c1">//Method improve:(D)D</span>
  <span class="mi">17</span><span class="k">:</span>   <span class="kt">dstore_1</span>
  <span class="mi">18</span><span class="k">:</span>   <span class="kt">goto</span> <span class="err">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви тепер модифікуєте <code>boom</code>, так, щоб вона тепер стала хвостово рекурсивною:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">bang</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span><span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">&quot;bang!&quot;</span><span class="o">)</span>
  <span class="k">else</span> <span class="n">bang</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">bang</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">bang!</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>НА цей раз ви бачите тільки один фрейм стеку для <code>bang</code>. Ви можете думати, що <code>bang</code> впала до того, як викликати себе, але це не той випадок. Якщо ви думаєте, що ви можете бути збентежені через хвостовою оптимізацією, коли переглядаєте на трасу стеку, ви можете відключити її, надавши наступний аргумент до оболонки <code>scala</code> або компілятору <code>scalac</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>-g:notailcalls</code></pre>
</div></div>
<div class="paragraph"><p>Коли вказана ця опція ви знову отримаєте довшу трасу стеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">bang</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Exception</span><span class="k">:</span> <span class="kt">bang!</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.</span><span class="n">bang</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="o">)</span>
<span class="n">at</span> <span class="o">.&lt;</span><span class="n">init</span><span class="o">&gt;(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="o">)</span> <span class="o">...</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____8">Обмеження хвостової рекурсії</h3>
<div class="paragraph"><p>Використання хвостової рекурсії в Scala є досить обмеженої, оскільки набір інструкцій JVM робить реалізацію більш розвинених форм хвостової рекурсії дуже складною. Scala тільки оптимізує прямі рекурсивні виклики назад, до тої самої функції, що робить виклики. Якщо рекурсія непряма, оптимізація неможлива:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isEven</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="kc">true</span> <span class="k">else</span> <span class="n">isOdd</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">def</span> <span class="n">isOdd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="kc">false</span> <span class="k">else</span> <span class="n">isEven</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також не отримаєте хвостову оптимізацію, якщо фінальний виклик іде до функціонального значення. Розгляньте наприклад наступний рекурсивний код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">funValue</span> <span class="k">=</span> <span class="n">nestedFun</span> <span class="k">_</span>
<span class="k">def</span> <span class="n">nestedFun</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span> <span class="n">funValue</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення змінної <code>funValue</code> посилається на функціональне значення, що в основному огортає виклик до <code>nestedFun</code>. Коли ви застосовуєте функціональне значення до аргументу, він робить свій хід, застосовує <code>nestedFun</code> до того самого аргументу, та повертає результат. Таким чином, ви маєте надію, що компілятор Scala буде робити хвостову оптимізацію, але в цьому випадку цього не буде. Оптимізація хвостового виклику обмежена до ситуацій, коли метод або вкладена функція викликає себе напряму в якості своєї останньої операції, без проходженню через функціональне значення, або деякий інший посередник. (Якщо ви досі не повністю розумієте хвостову рекурсію, дивіться Розділ 8.9).</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_8_10_">8.10 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала вам гранд тур по функціях в Scala. На додаток до методів, Scala провадить локальні функції, функціональні літерали та функціональні значення. На додаток до нормальних функціональних викликів Scala провадить частково застосовані функції, та функції з повторюваними параметрами. Коли можливо, функціональні виклики реалізовані як оптимізовані хвостові виклики, і, таким чином, багато гарно виглядаючих рекурсивних функцій роблять так само швидко, як і оптимізовані вручну версії, що використовують цикли <code>while</code>. Наступна глава буде будуватись на ціх засадах, та покаже, як багата підтримка функцій в Scala допомагає вам абстрогуватись над керуванням.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__9">Глава 9</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___15">Абстракції керування</h1>
<div class="paragraph"><p>В Главі 7 ми вказали, що Scala не має багато вбудованих абстракцій керування, оскільки вона надає вам можливість створювати ваші власні. В попередній главі ви навчились щодо функціональних значень. В цій главі ми покажемо вам, як застосовувати функціональні значення для створення нових абстракцій керування. По ходу справи ми вивчимо, що таке карування та параметри за ім'ям.</p></div>
<div class="sect1">
<h2 id="_9_1___">9.1 Зменьшення дублікації коду</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі функції поділяються на загальні частини, що є ті самі за кожного виклику функції, та незагальні частини, що можуть змінюватись від одного виклику до іншого. Загальні частини знаходяться в тілі функції, тоді як незагальні частини мають бути надані через аргументи. Коли ви використовуєте функцію як аргумент, незагальна частина алгоритму сама є деяким іншим алгоритмом! За кожного виклику такої функції ви можете передати інше функціональне значення як аргумент, і викликана функція буде, за своїм вибором, викликати передане функціональне значення. Ці <em>функції вищих порядків</em> — функції, що приймають функції як параметри, даватимуть вам додаткові можливості стиснути та спростити код.</p></div>
<div class="paragraph"><p>Одна з вигод функцій вищого порядку в тому, що вони надають можливість створювати керівні абстракції, які дозволяють вам зменшити дублікацію кода. Наприклад, уявімо, що ви пишете переглядач файлів, і ви бажаєте впровадити API, що дозволяє користувачам шукати файли, які співпадають з деяким критерієм. Перше, ви додаєте можливість пошуку файлів, чиє ім'я закінчується на певний рядок. Це надасть можливість вашим користувачам шукати, наприклад, всі файли з розширенням <code>.scala</code>. Ви можете провадити таке API, визначивши публічний метод <code>filesEnding</code> в об'єкті синглтоні, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">FileMatcher</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

  <span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
      <span class="k">yield</span> <span class="n">file</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>filesEnding</code> отримує список з усіх файлів в поточній директорії, використовуючи приватний допоміжний метод <code>filesHere</code>, потім фільтрує їх на сонові того, чи ім'я кожного файлу завершується на вказаний користувачем суфікс. Зважаючи що <code>filesHere</code> є приватним, метод <code>filesEnding</code> є єдиним доступним методом в  <code>FileMatcher</code>, API, що ви провадите для своїх користувачів.</p></div>
<div class="paragraph"><p>Докі все гарно, і немає коду, що повторюється. Однак пізніше ви вирішуєте дозволити людям шукати на основі любої частини імені файла. Це гарно, коли користувачі не пам'ятають, чи вони назвали файл <code>phb-important.doc</code>, <code>stupid-phb-report.doc</code>, <code>may2003salesdoc.phb</code>, або якось зовсім інакше; вони можуть тільки запам'ятати, що десь в імен з'являється <code>phb</code>. Ви повертаєтесь до роботи, і додаєте цю функцію до вашого <code>FileMatcher API</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція робить так само, як <code>filesEnding</code>. Вона шукає <code>filesHere</code>, перевіряє ім'я, та повертає файл, якщо ім'я співпадає. Одна різниця в тому, що ця функція використовує <code>contains</code> замість <code>ofendsWith</code>.</p></div>
<div class="paragraph"><p>Пройшли місяці, і програма стала більш успішною. З часом ви отримуєте запит від декількох досвідчених користувачів, які бажають шукати на основі регулярних запитів. Ці недбалі хлопці мають величезні каталоги з тисячами файлів, і вони бажають робити такі речі, як шукати всі файли <code>pdf</code>, що мають десь в назві <code>"oopsla"</code>. Щоб підтримати їх, ви пишете цю функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>ДОсвідчені програмісти зауважать всі ці повторення, та поміркують, чи не можна все це винести в загальну допоміжну функцію. Однак, якщо зробити це в очевидний спосіб не буде робити. Ви, можливо, хотіли б зробити щось таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="kc">null</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей підхід буде робити в деяких динамічних мовах, але Scala не дозволяє зліплювати код разом під час виконання, як тут. Так що ви можете зробити?</p></div>
<div class="paragraph"><p>Функціональні значення провадять відповідь. Хоча ви не можете передати по колу ім'я метода як значення, ви можете досягти того ж ефекту, передаючи по колу функціональне значення, що викликає метод за вас. В цьому випадку ви можете додати до метода параметр <code>matcher</code>, чиє єдине призначення є перевіряти ім'я файлу відносно деякого запиту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">matcher</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">matcher</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">,</span> <span class="n">query</span><span class="o">))</span>
    <span class="k">yield</span> <span class="n">file</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій версії метода, вираз <code>if</code> тепер використовує <code>matcher</code> для перевірки імені файла відносно запиту. Що в точності це перевіряє залежить від того, що вказане як <code>matcher</code>. Тепер погляньте на тип самого <code>matcher</code>. Це функція, і таким чином має <code>=&gt;</code> в своєму типі. Ця функція приймає два рядкових аргумента, ім'я файлу та запит, та повертає логічне значення, так що тип цієї функції є <code>(String, String) =&gt; Boolean</code>.</p></div>
<div class="paragraph"><p>Маючи цей новий допоміжний метод <code>filesMatching</code> ви можете спростити три пошукові методи, щоб вони викликати допоміжний метод, якому передається відповідна функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>

<span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>

<span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Функціональні літерали, показані в цьому прикладі, використовують синтаксис замінників, введений в попередній главі, що, можливо, не є досі природним для вас. Так що ось роз'яснення як роблять замінники: функціональний літерал</p></div>
<div class="listingblock">
<div class="content">
<pre><code>_.endsWith(_)</code></pre>
</div></div>
<div class="paragraph"><p>використаний в методі <code>filesEnding</code>, означає те саме, що і:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fileName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>filesMatching</code> приймає функцію, що потребує два аргумента <code>String</code>, вам не треба вказувати типи його аргументів; ви можете просто писати <code>(fileName, query) =&gt; fileName.endsWith(query)</code>. Оскільки параметри використовуються тільки по одному разу кожний в тілі функції (тобто, перший параметр, <code>fileName</code>, використовується першим в тілі, та другий параметр, <code>query</code>, використовується другим), ви можете використовувати синтаксис замінників: <code>_.endsWith(_)</code>. Перше підкреслення є замінником для першого параметру, імені файлу, та друге підкреслення замінником для другого параметру, рядка запиту.</p></div>
<div class="paragraph"><p>Цей код вже спрощений, але насправді він може бути ще коротший. Зауважте, що щапит був переданий до <code>filesMatching</code>, але <code>filesMatching</code> нічого не робить з <code>query</code>, крім того, що передає назад, до функції <code>matcher</code>. Це пересилання туди і назад непотрібне, оскільки викликач вже знає <code>query</code>, з якого починати! Ви можете також видалити параметр <code>query</code> з <code>filesMatching</code> та <code>matcher</code>, тим самим спростивши код так, як показано в Лістингу 9.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">FileMatcher</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">matcher</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span> <span class="k">if</span> <span class="n">matcher</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">))</span>
      <span class="k">yield</span> <span class="n">file</span>

  <span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.1 - Використання замикань для зменьшення дублікації коду.</p></div>
<div class="paragraph"><p>Цей приклад демонструє спосіб, в який першокласні функції можуть допомогти уникнути дублікації коду, коли б це було дуже складно зробити без них. Наприклад, в Java ви можете створити інтерфейс, що містить метод, що приймає <code>String</code> та повертає <code>Boolean</code>, потім створити та передати примірники анонімних внутрішніх класів, що реалізують цей інтерфейс до <code>filesMatching</code>. Хоча цей підхід буде видаляти дублікацію, якої ми бажаємо уникнути, він буде, в той самий час, стільки ж, або більше, нового коду. Таким чином, вигоди не вартують ціли, і ви можете так само гарно жити з дублікацією.</p></div>
<div class="paragraph"><p>Більше того, цей приклад демонструє, як замикання можуть допомогти зменшити дублікацію коду. Функціональні літерали, використані в попередньому прикладі, такі як <code>_.endsWith(_)</code> та <code>_.contains(_)</code>, під час виконання утворюють примірники функціональних значень, що не є замиканнями, бо вони не захоплюють жодних вільних змінних. Обі змінні, використані в вирарзі, наприклад, <code>_.endsWith(_)</code>, представлені підкресленнями, що означає, що вони взяті з аргументів функції. Таким чином, <code>_.endsWith(_)</code> використовує дві прив'язані змінні, і жодних вільних змінних. Для контрасту, функціональний літерал <code>_.endsWith(query)</code>, використана в останньому прикладі, містить прив'язану змінну, аргумент, представлений підкресленням, та одну вільну змінну на ім'я <code>query</code>. Це так тільки через те, що Scala підтримує замикання, так що ви були в змозі видалити параметр <code>query</code> з <code>filesMatching</code> в самому останньому прикладі, тим самим ще більше скоротивши код.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_2___">9.2 Спрощення клієнтського кода</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад демонструє, що функції вищого порядку можуть допомогти зменьшити дублікацію кода, коли ви реалізуєте API. Але важливе використання функцій вищого порядку є покладання їх в саме API, щоб зробити клієнтський код більш стислим. Гарний приклад надається методами циклів спеціального призначення на типах колекцій Scala.<span class="footnote"><br />[Ці методи циклів спеціального призначення визначені в трейті <code>Traversable</code>, що розширюється <code>List</code>, <code>Set</code>, та <code>Map</code>. Дивіться Главу 17 щодо дискусії.]<br /></span> Багато з них перелічені в Таблиці 3.1 в Главі 3, але поки ми поглянемо тільки на один приклад, щоб побачити, чому ці методи такі користні.</p></div>
<div class="paragraph"><p>Розглянемо метод <code>exists</code>, що визначає, чи передане значення міститься в колекції. Звичайно, ви можете шукати елементи, маючи <code>var</code> ініціалізоване в <code>false</code>, в циклі переглядадти колекцію, перевіряючи кожний елемент, та встановити <code>var</code> в <code>true</code>, якщо ви знайдете те, що шукаєте. Ось метод, що використовує цей підхід для визначення, чи переданий <code>List</code> містить від'ємне число:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsNeg</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">exists</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">num</span> <span class="k">&lt;-</span> <span class="n">nums</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">exists</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="n">exists</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви визначите цей метод в інтерпретаторі, ви зможете викликати його ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак більш стислий шлях визначити цей метод, це викликати функцію вищого порядку <code>exists</code> на переданому <code>List</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsNeg</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">nums</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця версія <code>containsNeg</code> видає той самий резільтат, що і попередній:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">containsNeg</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>exists</code> представляє абстракцію керування. Це циклічна конструкція особливого призначення, запровадженна бібліотекою Scala, скоріше ніж вбудована в мову Scala, як <code>while</code> або <code>for</code>. В попередньому розділі функція вищого порядку, <code>filesMatching</code>, зменьшує дублікацію коду в реалізації об'єкта <code>FileMatcher</code>. Метод <code>exists</code> провадить подібну перевагу, але оскільки <code>exists</code> є публічним в API колекцій Scala, дублікація коду, який він зменшує, є клієнтський код цього API. Якщо б не існував <code>exists</code>, і ви б бажали написати метод <code>containsOdd</code> для перевірки, чи список містить непарні числа, ви б могли написати це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsOdd</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">exists</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">num</span> <span class="k">&lt;-</span> <span class="n">nums</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
      <span class="n">exists</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">exists</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви порівняєте тіло <code>containsNeg</code> з таким в <code>containsOdd</code>, ви знайдете, що все повторюється, за винятком умови перевірки в виразі <code>if</code>. Використовуючи <code>exists</code>, замість ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">containsOdd</span><span class="o">(</span><span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">nums</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тіло кода в цій версії знову ідентичне до тіла відповідного метода <code>containsNeg</code> (версія, що використовує <code>exists</code>), за винятком того, що відрізняється умова, по якій виконується пошук. Знову, кількість дублікованого коду є значно меньшим, оскільки вся циклічна інфраструктура виділена в самий метод <code>exists</code>. В стандартній бібліотеці Scala існує багато інших циклічних методів. Як і з <code>exists</code>, вони часто можуть скоротити ваш код, якщо ви розпізнаєте можливість використати їх.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_3_">9.3 Карування</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Главі 1 ми казали, що Scala дозволяє вам створювати нові абстракції керування, що "відчуваються як природна підтримка мови". Хоча приклади, що ви бачили досі, напевне є абстраціями керування, навряд що хтось помилково зплутає їх з природною підтримкою мови. Щоб зрозуміти, як створити абстракції керування, що відчуваються більш подібно до розширень мови, зпочатку вам треба зрозуміти прийом функціонального програмування, що називається <em>карування</em>. Карована функція застосовується до декількох списків аргументів, замість тільки одного. Лістинг 9.2 показує звичайну, некаровану функцію, що додає два <code>Int</code> параметри, <code>x</code> та <code>y</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">plainOldSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">plainOldSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">plainOldSum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3L</span><span class="n">isting</span> <span class="mf">9.2</span> <span class="o">-</span> <span class="nc">Defining</span> <span class="n">and</span> <span class="n">invoking</span> <span class="n">a</span> <span class="s">&quot;plain old&quot;</span> <span class="n">function</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>На відміну, Лістинг 9.3 показує подібну функцію, що є карованою. Замість одного списку з двох <code>Int</code>, ви застосовуєте цю функцію до двох списків, по одному параметру <code>Int</code> кожний.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">curriedSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">curriedSum</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)(</span><span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">Int</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.3 - Визначення та виклик карованої функції.</p></div>
<div class="paragraph"><p>Що тут відбувається, це коли ви викликаєте <code>curriedSum</code>, насправді ви отримуєте два традиційні виклики функцій, пліч-о-пліч. Перший виклик функції приймає один параметр <code>Int</code> на ім'я <code>x</code>, та повертає значення функції для другої функції. Ця друга функція приймає <code>Int</code> параметр <code>y</code>. Ось функція на ім'я <code>first</code>, що діє в дусі, що мав би робити перший традиційний виклик функції <code>curriedSum</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">first</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосовуючи першої функції до 1 — іншими словами, викликаючи першу функцію, та передаючі їй 1 — дає другу функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">second</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосовуючи другу функцію до 2 дає результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці функції, <code>first</code> та <code>second</code>, є просто ілюстраціями процесу карування. Вони напряму не пов'язані до функції <code>curriedSum</code>. Тим не менш, існує спосіб отримати дійсне посилання на "другу" функцію <code>curriedSum</code>. Ви можете використовувати нотацію замінників для використання <code>curriedSum</code> в частково застосованому функціональному виразі, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">onePlus</span> <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="k">_</span>
<span class="n">onePlus</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Підкреслення в <code>curriedSum(1)_</code> є замінником для другого списку параметрів.<span class="footnote"><br />[В попередній главі, коли нотація замінників була застосована в традиційному методі, як <code>println _</code>, ви маєте залишати проміжок між ім'ям та підкресленням. В цьому випадку ви не змушені робити це, оскільки хоча <code>println_</code> є легальним ідентифікатором в Scala, <code>curriedSum(1)_</code> - ні.]<br /></span> Результатом буде посилання на функцію, що, коли буде викликана, додає один до свого єдиного аргумента <code>Int</code>, та повертає результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">onePlus</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Та ось як ви отримуєте функцію, що додає два до свого єдиного аргументу <code>Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoPlus</span> <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span><span class="k">_</span>
<span class="n">twoPlus</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">twoPlus</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_4____">9.4 Написання нових керівних структур</h2>
<div class="sectionbody">
<div class="paragraph"><p>В мові з першокласними функціями ви можете ефективно створити нові керівні структури, навіть якщо синтаксис мови фіксований. Все що вам треба зробити - це створити методи, що приймають функції як аргументи. Наприклад, ось керівна структура <code>twice</code>, що повторює операцію два рази, та повертає результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">twice</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">twice</span><span class="k">:</span> <span class="o">(</span><span class="kt">op:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="nc">Double</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">twice</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">7.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>op</code> в цьому прикладі є <code>Double =&gt; Double</code>, що означає, що це функція, що приймає одне <code>Double</code> в якості аргументу, та повертає інше <code>Double</code>. Кожного разу, коли ви знайдете шаблон керування, повторюваний в декількох частинах вашого коду, вам слідує подувати про реалізацію його як нової керуючої структури. Раніше в цій главі ви бачили <code>filesMatching</code>, дуже спеціалізований керівний шаблон. Тепер розглянемо більш широко використовуваний шаблон кодування: відкрити ресурс, виконувати операції з ним, та потім зачинити ресурс. Ви можете захопити це в керівній абстракції, використовуючи метод, подібний до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">op</span><span class="k">:</span> <span class="kt">PrintWriter</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">op</span><span class="o">(</span><span class="n">writer</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи такий метод, ви можете використати його таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">withPrintWriter</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&quot;date.txt&quot;</span><span class="o">),</span>
  <span class="n">writer</span> <span class="k">=&gt;</span> <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевага від використання цього метода в тому, що це <code>withPrintWriter</code>, а не код користувача, переконується, що в кінці файл буде зачинений . Так що неможливо забути зачинити файл. Цей прийом називається <em>шаблоном позичання</em>, оскікльи функція абстракції керування, така як <code>withPrintWriter</code>, відкриває ресурс, та "позичає" його функції. Наприклад, <code>withPrintWriter</code> в попередньому прикладі позичає <code>PrintWriter</code> функції <code>op</code>. Коли функція завершується, вона сигналить, що вона більше не потребує "запозичений" ресурс. Потім ресурс зачиняється в блоці <code>finally</code>, щоб переконатись, що він напевне зачинений, безвідносно від того, чи функція завершилась через нормальне повернення, або через закидання виключення.</p></div>
<div class="paragraph"><p>Один зі шляхів, як ви можете зробити, щоб код клієнта виглядав як вбудована структура керування, це використовувати фігурні дужки замість дужок для оточення списку аргументів. В любому виклику метода в Scala, в якому ви передаєте рівно один аргумент, ви можете обрати використовувати фігурні дужки для оточення аргумента замість дужок. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span> <span class="o">{</span> <span class="s">&quot;Hello, world!&quot;</span> <span class="o">}</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В другому прикладі ви використали фігурні дужки замість дужок, щоб оточити аргументи <code>println</code>. Однак цей прийом з фігурними дужками буде робить, тілкьи якщо ви передаєте один аргумент. Ось спроба порушити це правило:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">g</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">substring</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span> <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">1</span><span class="k">:</span> <span class="kt">error:</span> <span class="err">&#39;</span><span class="o">;</span><span class="err">&#39;</span> <span class="n">expected</span> <span class="n">but</span> <span class="sc">&#39;,&#39;</span> <span class="n">found</span><span class="o">.</span>
        <span class="n">g</span><span class="o">.</span><span class="n">substring</span> <span class="o">{</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">9</span> <span class="o">}</span>
                       <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ви намагаєтесь передати два аргументи до <code>substring</code>, ви отримуєте помилку, коли ви намагаєтесь оточити ці аргументи фігурними дужками. Замість цього вам треба використовувати дужки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">g</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">7</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">wo</span>
</pre></div></div></div>
<div class="paragraph"><p>Призначення цієї здатності замінювати дужки на фігурні дужки для передачі одного аргумента, є дозволити програмісту клієнта писати функціональні літерали між фігурними дужками. Це може зробити виклик метода більш подібним до абстракції керування. Розгляньте визначений до цього метод <code>withPrintWriter</code> як приклад. В його самій останній формі <code>withPrintWriter</code> приймає два аргументи, так що ви не можете використовувати фігурні дужки.</p></div>
<div class="paragraph"><p>Тим не менш, оскільки функція, передана в <code>withPrintWriter</code> є останнім аргументом в списку, ви можете виконати карування для підтягування першого аргументу, <code>File</code>, в окремий список аргументів. Це залишить функцію як окремий параметр в другому списку аргументів. Лістинг 9.4 показує, як вам треба перевизначити <code>withPrintWriter</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="kt">PrintWriter</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">op</span><span class="o">(</span><span class="n">writer</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.4 - Використання шаблона позичання для запису в файл.</p></div>
<div class="paragraph"><p>Нова версія відрізняється від старої тільки в тому, що тепер в нас два списки параметрів, з одним параметром в кожному, замість одного списку параметрів з двома параметрами. В показаній тут попередній версії <code>withPrintWriter</code> ви бачили <code>...File, op...</code>. Але в цій версії ви бачите <code>...File)(op...</code>. Беручи до уваги визначення вище, ви можете викликати метод з більш приємним синтаксисом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">&quot;date.txt&quot;</span><span class="o">)</span>

<span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="o">{</span> <span class="n">writer</span> <span class="k">=&gt;</span>
  <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі перший список аргументів, що містить один аргумент <code>File</code>, записаний в оточенні дужок. Другий список аргументів, що містить один функціональний аргумент, оточений в фігурні дужки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_5____">9.5 Параметри за ім'ям</h2>
<div class="sectionbody">
<div class="paragraph"><p>Метод <code>withPrintWriter</code>, показаний в попередньому розділі, відрізняється від вбудованих керівних структур мови, таких як <code>if</code> та <code>while</code>, тому що код між фігурними дужками приймає аргумент. Функція, передана до <code>withPrintWriter</code> потребує один аргумент типу PrintWriter. Цей аргумент показаний як <code>writer =&gt;</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="o">{</span> <span class="n">writer</span> <span class="k">=&gt;</span>
  <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але що, якщо ви бажаєте реалізувати дещо більш подібне до <code>if</code> або <code>while</code>, де немає значення, що треба передати в код між фігурними дужками? Щоб допомогти в таких ситуаціях Scala провадить параметри за іменем.</p></div>
<div class="paragraph"><p>В якості конкретного прикладу, уявімо ви бажаєте реалізувати конструкцію твердження <code>myAssert</code>. <span class="footnote"><br />[Ми назвемо це <code>myAssert</code>, не <code>assert</code>, оскільки Scala провадить свій власний <code>assert</code>, що буде описане в Розділі 14.1.]<br /></span> Функція <code>myAssert</code> буде приймати функціональне значення на вході, та звірятись з флагом, щоб вирішити, що робити. Якщо флаг встановлений, <code>myAssert</code> буде викликати передану функцію, та перевіряти, чи вона повертає <code>true</code>. Якщо флаг не встановлений, <code>myAssert</code> буде тихо взагалі нічого не робити.</p></div>
<div class="paragraph"><p>Без параметрів за ім'ям ви можете записати <code>myAssert</code> десь так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">assertionsEnabled</span> <span class="k">=</span> <span class="kc">true</span>
<span class="k">def</span> <span class="n">myAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначення гарне, але її використання трохи незручне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">myAssert</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете дійсно схилятись до відкидання пустого списку параметрів та символа <code>=&gt;</code> в функціональному літералі, та записати код таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">myAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span> <span class="c1">// Не буде робити, оскільки відсутнє () =&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри за ім'ям існують саме для того, щоб це було можливо зробити. Щоб створити параметр за ім'ям, ви даєте параметру тип, що починається з <code>=&gt;</code> замість <code>() =&gt;</code>. Наприклад, ви можете змінити параметр предикату <code>myAssert</code> в параметр за ім'ям, змінивши його тип <code>() =&gt; Boolean</code> на <code>=&gt; Boolean</code>. Лістинг 9.5 показує, як це має виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">byNameAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 9.5 - Використання параметра за ім'ям.</p></div>
<div class="paragraph"><p>Тепер ви можете відкинути пустий параметр у властивості, що ви бажаєте перевірити. Результат в тому, що  <code>byNameAssert</code> виглядає точно як вбудована структура керування:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">byNameAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип за ім'ям, в якому відкидається пустий список параметрів, <code>()</code>, дозволений тільки для параметрів. Немає такого, як змінна за ім'ям або поле за ім'ям. Тепер ви можете здивуватись, чому ви не можете просто написати  <code>myAssert</code>, використовуючи простий старий <code>Boolean</code> для типу його параметра, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">boolAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, це формулювання також легальне, та код з використанням ціє версії <code>boolAssert</code> все ще буде виглядати точно як раніше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">boolAssert</span><span class="o">(</span><span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тим не менш, існує одна відмінінсть між ціма двома підходами, яку важливо зазначити. Оскільки тип параметру <code>boolAssert</code> є <code>Boolean</code>, вираз всередині дужок в <code>boolAssert(5 &gt; 3)</code> обчислюється перед викликом до <code>boolAssert</code>. Вираз <code>5 &gt; 3</code> дає <code>true</code>, що передається до <code>boolAssert</code>. Для контрасту, оскільки тип параметра предикату <code>byNameAssert</code> є <code>=&gt; Boolean</code>, вираз в дужках в <code>byNameAssert(5 &gt; 3)</code> не обчислюється перед викликом до <code>byNameAssert</code>. Замість цього буде створено функціональне значення, метод <code>apply</code> якого буде обчислювати <code>5 &gt; 3</code>, та це функціональне значення буде передане в <code>byNameAssert</code>.</p></div>
<div class="paragraph"><p>Таким чином, різниця між двома підходами в тому, що якщо твердження відключене, ви побачите тільки побічний ефект цього виразу, який може мати вираз в дужках для <code>boolAssert</code>, але не для <code>byNameAssert</code>. Наприклад, якщо твердження відключені, спроба перевірити <code>x / 0 == 0</code> буде видавати виключення в випадку <code>boolAssert</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">5</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">assertionsEnabled</span> <span class="k">=</span> <span class="kc">false</span>
<span class="n">assertionsEnabled</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">boolAssert</span><span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArithmeticException</span><span class="k">:</span> <span class="kt">/</span> <span class="kt">by</span> <span class="kt">zero</span>
<span class="o">...</span> <span class="mi">33</span> <span class="n">elided</span>
</pre></div></div></div>
<div class="paragraph"><p>Але спроба виконати той самий код в випадку <code>byNameAssert</code> не дає виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">byNameAssert</span><span class="o">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_9_6_">9.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава показала вам, як багата функціональна підтримка в Scala використовується для побудови абстракцій керування. Ви можете використовувати функції в вашому коді для виділення загальних шаблонів керування, та ви можете отримати переваги функцій вищих порядків в бібліотеці Scala, щоб повторно використовувати шаблони керування, що є загальними поміж коду всіх програмістів. Ми також розглянули, як використовувати карування та параметри за ім'ям, так що ваші власні функції вищих порядків можуть бути використані зі стислим синтаксисом.</p></div>
<div class="paragraph"><p>В попередній та цій главі ви бачили досить багато інформації щодо функцій. Наступні декілька глав повертатимуть назад, до обговорення більш об'єктно-орієнтовних можливостей мови.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__10">Глава 10</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____9">Композиція та наслідування</h1>
<div class="paragraph"><p>Глава 6 вводить деякі базові об'єктно-орієнтовні аспекти Scala. Ця глава підхоплює там, де полишила Глава 6, та занурюється в підтримку в Scala об'єктно-орієнтовного програмування в значно більших деталях. Ми будемо порівнювати два фундаментальні співвідношення між класами: композицію та наслідування. Композиція означає, що один клас зберігає посилання на інший, використовуючи цей клас для допомоги в виконанні своєї міссії. Наслідування є відношенням суперклас/субклас. На додаток до ціх тем, ми будемо обговорювати абстрактні класи, методи без параметрів, розширення класів, перекриття методів та полів, параметрічні поля, виклик конструкторів суперкласу, поліморфізм та динамічна прив'язка, фінальні члени та класи, та об'єкти та методи фабрик.</p></div>
<div class="sect1">
<h2 id="_10_1___">10.1 Бібліотека двохмірного розташування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як робочий приклад в цій главі ми створимо бібліотеку для побудови та відображення прямокутника, заповненого текстом. Для зручності бібліотека буде провадити методи фабрики на ім'я <code>elem</code>, що конструює елементи з переданих даних. Наприклад, ви будете в змозі створити елемент розташування, що містить рядок, використовуючи метод фабрики з наступною сігнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">elem</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, елементи будуть змодельовані за допомогою типу на ім'я <code>Element</code>. Ви зможете викликати <code>above</code> або <code>beside</code> на <code>element</code>, передаючи другий елемент, щоб створити новий елемент, який є комбінацією двох. Наприклад, наступний вираз буде конструювати більший елемент, що складається з двох колонок, кожна висотою 2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">column1</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="n">above</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;***&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">column2</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;***&quot;</span><span class="o">)</span> <span class="n">above</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;world&quot;</span><span class="o">)</span>
<span class="n">column1</span> <span class="n">beside</span> <span class="n">column2</span>
</pre></div></div></div>
<div class="paragraph"><p>Друк результате цього виразу буде давати вам таке:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>hello ***
*** world</code></pre>
</div></div>
<div class="paragraph"><p>Елементи розташування є гарним прикладом системи, в якій об'єкти можуть бути сконструйовані з простих частин за допомогою оераторів композиції. В цій главі ми будемо визначати класи, що дозволять конструювання об'єктів-елементів з масивів, ліній та прямокутників. Ці базові об'єкти елементів будуть простими частинами. Ми також визначимо операції композиції <code>above</code> та <code>beside</code>. Такі компонуючі оператори також часто називають <em>комбінаторами</em>, оскікльи вони комбінують елементи в деякій галузі в нові елементи.</p></div>
<div class="paragraph"><p>Думаючи в термінах комбінаторів загалом гарний підхід розробки бібліотеки: це відплачується - думати про фундаментальні шляхи конструювання об'єктів в домені застосування. Що таке прості об'єкти? В який спосіб найбільш цікаві об'єкти можуть бути сконструйовані з простіших? Як комбінатори поводяться разом? Які комбінатори найбільш загальні? Чи вони задовільняють цікавим законам? Якщо ви маєте гарні відповіді на ці запитання, розробка вашої бібліотеки на вірному шляху.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_2__">10.2 Абстрактні класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наше перше завдання є визначити тип <code>Element</code>, що предаставляє елементи розташування. Оскільки елементи є двохвимірні прямокутники символів, має сенс включити член <code>contents</code>, що посалається на вміст елемента розташування. Цей <code>contents</code> може бути представлений як масив рядків, до кожний рядок представляє лінію. Таким чином, тип результата, що повертається <code>contents</code> буде <code>Array[String]</code>. Лістинг 10.1 показує, як це буде виглядати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.1 - Визначення абстрактного метода та класа.</p></div>
<div class="paragraph"><p>В цьому класі <code>contents</code> декларовано як метод, що не має реалізації. Іншими словами, метод є абстрактним членом класа <code>Element</code>. Клас з абстрактинми методами має сам бути визначений як абстрактний, що робиться додаванням модифікатора <code>abstract</code> перед ключовим словом <code>class</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>abstract</code> означає, що клас може мати абстрактні члени, що не мають реалізації. Як результат, ви не можете створити примірник абстрактного класу. Якщо ви спробуєте зробити це, ви отримаєте помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Element</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Element</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span>
    <span class="n">cannot</span> <span class="n">be</span> <span class="n">instantiated</span>
       <span class="k">new</span> <span class="nc">Element</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Пізніше в цій главі ви побачите, як створити субкласи класа <code>Element</code>, для яких ви будете в змозі створити примірники, оскільки вони заповнюють відсутнє визначення дла <code>contents</code>.</p></div>
<div class="paragraph"><p>Зауважте, що метод <code>contents</code> в класі <code>Element</code> не має модифікатора <code>abstract</code>. Метод є абстрактним, якщо він не має реалізації (тобто знака рівності або тіла). На відміну від Java, для декларацій методів модифікатор <code>abstract</code> не потрібен (та не дозволений). Методи, що мають реалізцію, називаються <em>суцільними</em>.</p></div>
<div class="paragraph"><p>Інша частка термінології відрізняє декларації та визначення. Клас <code>Element</code> <em>декларує</em> абстрактний метод <code>contents</code>, але наразі не <em>визначає</em> конкретинх методів. Однак в наступному розділі ми розширимо <code>Element</code>, визначаючи деякі суцільні методи.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_3____">10.3 Визначення методів без параметрів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми додамо методи до <code>Element</code>, що з'ясовують його ширину та довжину, як показано в Лістингу 10.2. Метод <code>height</code> повертає число рядків в <code>contents</code>. Метод <code>width</code> повертає довжину першого рядка, або повертає нуль, якщо в елементі немає нічого. (Це означає, що ви не можете визначити елемент з висотою нуль, та ненульовою шириною.)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.2 - Визначення методів без параметрів, <code>width</code> та <code>height</code>.</p></div>
<div class="paragraph"><p>Зауважте, що жодний з трьох методів <code>Element</code> не має списку параметрів, навіть порожнього. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">width</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>метод визначений без дужок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">width</span><span class="k">:</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Такі <em>безпараметричні</em> методи є досить загальними в Scala. На відміну, методи, визначені з порожніми дужками, такі як <code>def height(): Int</code>, називаються <em>методами з порожніми дужками</em>. Рекомендована домовленість є використовувати безпараметричні методи, коли немає параметрів, і метод отримує доступ до змінного стану тільки через читання полів містячого об'єкта (зокрема, він не змінює змінний стан). Ця домовленість підтримує принцип уніфіормного доступу,<span class="footnote"><br />[Meyer, Object-Oriented Software Construction [Mey00]]<br /></span> який каже, що клієнтський код не має зазнати впливу від рішення реалізувати атрибут як поле або метод.</p></div>
<div class="paragraph"><p>Наприклад, ми можемо реалізувати <code>width</code> та <code>height</code> елемента як поля, замість методів, просто змінивши <code>def</code> в кожному визначенні на <code>val</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">height</span> <span class="k">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">length</span>
  <span class="k">val</span> <span class="n">width</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">height</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">contents</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">length</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дві пари визначень повністю еквівалентні з клієнтської точки зору. Єдине що відрізняється, це те, що доступ до поля може бути трохи швидший, ніж виклик метода, оскільки значення полів попередньо обчислені при ініціалізації класа, замість бути обчислені при кожному виклику метода. З іншого боку, поля потребують додаткового простору в пам'яті в кожному елементі <code>Element</code>. Так що це залежить від профілю використання класа, чи атрибут краще представляти як поле чи метод, і цей профіль використання може змінитись з часом. Суть в тому, що клієнти класа <code>Element</code> не мають зазнати впливу, коли змінюється внутрішнє представлення.</p></div>
<div class="paragraph"><p>Зокрема, клієнт класу <code>Element</code> не має бути переписаний, якщо поле цього класа буде змінено на функцію доступу, доки ця функція є чистою (тобто вона не має жодних побічних ефектів, та не залежить від змінного стану). Клієнт не має турбуватись в жодному випадку.</p></div>
<div class="paragraph"><p>Доки все гарно. Але все ще є невелике ускладнення, що має справу з тим, як Java обробляє речі. Проблема в тому, що Java не реалізує принцип уніформного доступу. Так що існує <code>string.length()</code> в Java, не <code>string.length</code>, навіть якщо <code>array.length</code>, не <code>array.length()</code>. Нічого і казати, що це дуже бентежить.</p></div>
<div class="paragraph"><p>Щоб полатати цю дірку, Scala є дуже ліберальною, коли доходить до міксування безпараметричних методів, та методів з порожніми дужками. Зокрема, ви можете перекрити безпараметричні методи методом порожніх дужок, та навпаки. Ви також можете відкинути порожні дужки при виклику функції, що не приймає аргументів. Наприклад, наступні два рядка обоє є легальними в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">toString</span>
<span class="s">&quot;abc&quot;</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>В принципі можливо відкинути всі порожні дужки в викликах функцій Scala. Однак все ще рекомендовано писати порожні дужки, коли викликаний метод представляє більше ніж властивість об'єкта отримувача. Наприклад, порожні дужки на місці, коли метод виконує I/O, записує переприсвоювані змінні (<code>var</code>), або читає <code>var</code> окрім полів отримувача, прямо або непрямо через використання змінних об'єктів. Таким чином, список параметрів діє як візуальна підказка, що виклик запускає деякі цікаві обчислення. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;hello&quot;</span><span class="o">.</span><span class="n">length</span> <span class="c1">// немає (), бо немає побічних ефектів</span>
<span class="n">println</span><span class="o">()</span> <span class="c1">// краще не відкидати ()</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб підсумувати, в Scala заохочується визначати методи, що не приймають параметрів, та не мають побічних ефектів, як безпараметричні методи (тобто відкидаючи порожні дужки). З іншого боку, вам ніколи не слід визначати метод, що має побічні ефекти, без дужок, оскільки виклики цього метода потім будуть виглядати як вибір поля. Так що ваші клієнти можуть бути здивовані, коли побачать побічні ефекти.</p></div>
<div class="paragraph"><p>Подібним чином, коли ви викликаєте функцію, що має побічний ефект, переконайтесь, що коли писали виклик включили порожні дужки. Інший спосіб думати про це: коли функція, що ви викликаєте, виконує операцію, використовуйте дужки. Але якщо вона просто провадить доступ до властивості, прибирайте дужки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_4__">10.4 Розширення класів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нам все ще треба бути в змозі створювати нові об'єкти елементів. Ви вже бачили, що <code>new Element</code> не може бути використаний для цього, оскільки <code>Element</code> є абстрактним. Таким чином, щоб створити примірник елемента, нам треба створити субклас, що розширює <code>Element</code>, та реалізує абстрактний метод <code>contents</code>. Лістинг 10.3 показує можливий спосіб зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.3 - Визначення <code>ArrayElement</code> як субкласа <code>Element</code>.</p></div>
<div class="paragraph"><p>Клас <code>ArrayElement</code> визначений для розширення класу <code>Element</code>. Так само, як в Java, ви використовуєте твердження <code>extends</code> після імені класу, щоб виразити цей факт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Малюнок 10.1 - Діаграма класів для <code>ArrayElement</code>.</p></div>
<div class="paragraph"><p>Таке твердження <code>extends</code> має два ефекти: це дає класу <code>ArrayElement</code> наслідувати всі неприватні члени від класу <code>Element</code>, та це робить тип <code>ArrayElement</code> субтипом типу <code>Element</code>. Зважаючи що <code>ArrayElement</code> розширює <code>Element</code>, клас <code>ArrayElement</code> називається субкласом класу <code>Element</code>. І навпаки, <code>Element</code> є суперкласом <code>ArrayElement</code>. Якщо ви приберете твердження <code>extends</code>, компілятор Scala неявно вважатиме, що ваш клас розширює <code>scala.AnyRef</code>, що на Java платформі є те саме, що і клас <code>java.lang.Object</code>. Таким чином, клас <code>Element</code> неявно розширює клас <code>AnyRef</code>. Ви можете бачити ці відношення наслідування на Малюнку 10.1.</p></div>
<div class="paragraph"><p>Наслідування означає, що всі члени суперкласа також є членами субкласу, з двома виключеннями. Перше, приватні члени суперкласу не наслідуються в субкласі. Друге, члени суперкласа не наслідуються, якщо член з таким же ім'ям та параметрами вже реалізовані в субкласі. В такому випадку ми кажемо, що субклас <em>перекриває</em> член в суперкласі. Якщо член субкласу є суцільним, та член суперкласу є абстрактним, ми також кажемо, що суцільний член реалізує абстрактний.</p></div>
<div class="paragraph"><p>Наприклад, метод <code>contents</code> в <code>ArrayElement</code> перекриває (або, альтернативно, реалізує) абстрактний метод <code>contents</code> в класі <code>Element</code>.<span class="footnote"><br />[Одна проріха в цьому дизайні в тому, що оскільки повернутий масив є змінним, клієнти можуть змінити його. Для книжки ми будемо підтримувати речі простими, але коли <code>ArrayElement</code> є частиною реального проекта, ви можете розглянути можливість повертати захисну копію масива замість цього. Інша проблема полягає в тому, що ми досі не переконались, що кожний елемент <code>String</code> масиву  <code>contents</code> має ту саму довжину. Це може бути вирішене через перевірку передумови в первинному конструкторі, за закиданні виключення, якщо вона порушується.]<br /></span> Для контрасту, клас <code>ArrayElement</code> наслідує методи <code>width</code> та <code>height</code> від класа <code>Element</code>. Наприклад, маючи <code>ArrayElement ae</code>, ви можете запитати його <code>width</code> використовуючи <code>ae.width</code>, так, якби <code>width</code> було визначене в класі <code>ArrayElement</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ae</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="s">&quot;world&quot;</span><span class="o">))</span>
<span class="n">ae</span><span class="k">:</span> <span class="kt">ArrayElement</span> <span class="o">=</span> <span class="nc">ArrayElement</span><span class="k">@</span><span class="mi">39274</span><span class="n">bf7</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ae</span><span class="o">.</span><span class="n">width</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p>Створення субтипів означає, що значення субкласу може бути використане, коли потрібне значення суперкласу. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">e</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна <code>e</code> визначена як тип <code>Element</code>, так що його значення ініціалізації також має бути <code>Element</code>. Фактично, значення ініціалізації є <code>ArrayElement</code>. Це OK, оскільки клас <code>ArrayElement</code> розширює клас <code>Element</code>, і як результат, тип <code>ArrayElement</code> сумісний з типом <code>Element</code>.<span class="footnote"><br />[Для додаткової перспективи на різницю між суперкласом та субкласом дивіться входження глассарію щодо субтипів.]<br /></span></p></div>
<div class="paragraph"><p>Малюнок 10.1 також показує порівняння відношень, що існують між <code>ArrayElement</code> та <code>Array[String]</code>. Це відношення називається композицією, та  клас <code>ArrayElement</code> є "скомпонований" з класу <code>Array[String]</code>, тому що компілятор Scala буде покладати в двійниковий клас, що він генерує для <code>ArrayElement</code>, поле, що містить посилання на переданий масив <code>conts</code>. Ми обговоримо деякі рішення дизайну композиції та наслідування далі в цій главі, в Розділі 10.11.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_5____">10.5 Перекриття методів та полей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Принцип уніформного доступу є тільки одним аспектом, коли Scala розглядає поля та методи в більш уніформний спосіб, ніж Java. Інша різниця в тому, що в Scala поля та методи належать до того самого простору імен. Це робить можливим для поля перекривати метод без параметрів. Наприклад, ви можете змінити реалізацію <code>contents</code> в класі <code>ArrayElement</code> з метода на поле, без модифікації визначення абстрактного метода <code>contents</code> в класі <code>Element</code>, як показано в Лістингу 10.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="n">conts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Element</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">conts</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 10.4 - Перекриття метода без параметрів за допомогою поля.</p></div>
<div class="paragraph"><p>Поле <code>contents</code> (визначене як <code>val</code>) в цій версії <code>ArrayElement</code> є чудово гарною реалізацією метода без параметрів <code>contents</code> (декларований за допомогою <code>def</code>) в класі <code>Element</code>. З іншої сторони, в Scala заборонено визначати поле та метод з тим самим ім'ям в тому самому класі, хоча це дозволено в Java.</p></div>
<div class="paragraph"><p>Наприклад, цей Java клас буде чудово компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="kd">class</span> <span class="nc">CompilesFine</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">f</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але відповідний клас Scala не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">WontCompile</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">0</span> <span class="c1">// Не буде компілюватись, оскільки поле</span>
  <span class="k">def</span> <span class="n">f</span> <span class="k">=</span> <span class="mi">1</span>         <span class="c1">// та метод мають те саме ім&#39;я</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Загалом, Scala має лише два простору імен для визначень, на відміну від чотирьох в Java. Чотири простори імен в Java є поля, методи, типи та пакунки. На відміну в Scala лише два простори імен:</p></div>
<div class="ulist"><ul>
<li>
<p>
значення (поля, методи, пакунки та об'єкти синглтони)
</p>
</li>
<li>
<p>
types (імена класів та трейтів)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Причина, з якої Scala покладає поля та методи в той самий простір імен в точності та, щоб ви могли перекривати методи без параметірв за допомогою <code>val</code>, дещо, чого ви не можете робити в Java.<span class="footnote"><br />[Причина, з якої в Scala пакунки подіяють той самий простір імен, що поля і методи - бо це дозволяє вам імпортувати пакунки (на додаток до тільки імен типів) та поля і методи об'єктів синглтонів. Це знову дещо, чого ви не можете в Java. Це буде описане в Розділі 13.3.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_10_6___">10.6 Визначення параметричних полів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знову розглянемо визначення класу <code>ArrayElement</code>, показану в попередній главі. Він 