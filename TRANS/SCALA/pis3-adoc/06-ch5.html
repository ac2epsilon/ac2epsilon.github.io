<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__5">Глава 5</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____">Базові типи і операції</h1>
<div class="paragraph"><p>Тепер, коли ви побачили класи і об'єкти в дії, настав гарний час подивитись на базові типи та операції Scala більш глибоко. Якщо ви знайомі з Java, ви будете раді узнати, що базові типи і операції  Java мають те саме значення в Scala. Однак є деякі цікаві розбіжності, що роблять цю главу варту прочитання, навіть якщо ви досвідчений Java розробник. Оскільки деякі аспекти Scala, розглянуті в цій главі в основі ти самі, що і в Java, ми вставили зауваження, що ці частини Java розробники можуть пропустити.</p></div>
<div class="paragraph"><p>В цій главі ви отримаєте огляд базових класів Scala, включаючи  <code>String</code> та типи значень, <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>, <code>Double</code>, <code>Char</code>, та <code>Boolean</code>. Ви вивчите операції, що ви можете виконувати з ціма типами, включаючи те, як робить преоритетність операторів в виразах Scala. Ви також вивчите, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи додаткові операції, крім тих, що підтримуються в Java.</p></div>
<div class="sect1">
<h2 id="_5_1___">5.1 Деякі базові типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Декілька фундаментальних типів Scala, разом и диапазонами знічень ціх типів, яки вони можуть приймати, показані в Таблиці 5.1. Загалом типи <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code> та <code>Char</code> називаються інтегральними типами. Інтегральні типи разом з <code>Float</code> та <code>Double</code> називаються числовими типами.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі базові типи</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Диапазон</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="left" valign="top"><p class="table">8-бітне ціле зі знаком (від -2<sup>7</sup> до 2<sup>7</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="left" valign="top"><p class="table">16-бітне ціле зі знаком (від -2<sup>15</sup> до 2<sup>15</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="left" valign="top"><p class="table">32-бітне ціле зі знаком (від -2<sup>31</sup> до 2<sup>31</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="left" valign="top"><p class="table">64-бітне ціле зі знаком (від -2<sup>63</sup> до 2<sup>63</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="left" valign="top"><p class="table">16-бітний беззнаковий символ Unicode (від 0 до 2<sup>16</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">послідовність Char</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="left" valign="top"><p class="table">32-бітне IEEE 754 з плаваючою крапкою одинарна точність</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="left" valign="top"><p class="table">64-бітне IEEE 754 з плаваючою крапкою подвійна</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="left" valign="top"><p class="table">true або false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Всі крім <code>String</code>, що знаходиться в пакунку <code>java.lang</code>, всі типи, показані в Таблиці 5.1 є членами пакунку <code>scala</code>.<span class="footnote"><br />[Пакунки, що були коротко описані на Кроці 1 в Главі 2, будуть розглянуті глибоко в Главі 13.]<br /></span> Наприклад, повне ім'я <code>Int</code> є <code>scala.Int</code>. Однак беручи, що всі члени з пакунку <code>scala</code> та <code>java.lang</code> автоматично імпортуються в кожний джерельний файл Scala, ви можете використовувати самі прості імена (тобто імена як Boolean, Char, або String) будь-де.</p></div>
<div class="paragraph"><p>Допитливі Java розробники зауважать, базові типи Scala мають ті самі диапазони, що і відповідні типи в Java. Це дозволяє компілятору  Scala трансформувати примірники значень Scala, такі як <code>Int</code> або <code>Double</code>, до примітивних типів Java в спродукованому байткоді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2_">5.2 Літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі базові типи, перелічені в Таблиці 5.1 можуть бути записані як літерали. Літерал - це шлях написати стале значення прямо в коді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java_">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис більшосі літералів, показаних в цьому розділі, є саме таким, як і в Java, так що якщо ви майстер Java, ви можете безпечно пропустити більшість цього розділу. Деякі розбіжності з описаних тут ви можете прочитати щодо Scala літералів для сирих рядків та символів, а також про інтерполяцію рядків. Також Scala не підтримує восьмиричні літерали; цілі літерали, що починаються з нуля, такі як  031, не будуть компілюватись.</p></div>
<div class="sect2">
<h3 id="__">Цілі літерали</h3>
<div class="paragraph"><p>Цілі літерали для типів <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code> ідуть в двох форматах: десятичному та шістнадцятиричному. Від того, з чого починається літерал, залежить основа числа. Якщо число починається з 0x або 0X, це шістнадцятирічне (основа 16), та може містити цифри від 0 до 9, так само як літери в верхньому або нижньому реєстрі від A до F. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hex</span> <span class="k">=</span> <span class="mh">0x5</span>
<span class="n">hex</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hex2</span> <span class="k">=</span> <span class="mh">0x00FF</span>
<span class="n">hex2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">magic</span> <span class="k">=</span> <span class="mh">0xcafebabe</span>
<span class="n">magic</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">889275714</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що оболонка Scala завжди друкує цілі значення по основі 10, не важливо, якою формою літерала ви ініціалізували її. Таким чином, інтерпретатор відображує значення змінної <code>hex2</code>, що ви ініціалізували літералом <code>0x00FF</code> як десятичне <code>255</code>. (Звичайно, ви не маєте вірити нам на слово. Гарний спосіб почати відчувати мову є спробувати твердження в інтерпретаторі по мірі читання цієї глави.) Якщо число починається з не-нульової цифри, воно десяткове (основа
10). Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec1</span> <span class="k">=</span> <span class="mi">31</span>
<span class="n">dec1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">31</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec2</span> <span class="k">=</span> <span class="mi">255</span>
<span class="n">dec2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">255</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dec3</span> <span class="k">=</span> <span class="mi">20</span>
<span class="n">dec3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо цілий літерал закінчується на L або l, це <code>Long</code>; інакше це <code>Int</code>. Деякі приклади <code>Long</code> літералів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">prog</span> <span class="k">=</span> <span class="mi">0</span><span class="nc">XCAFEBABEL</span>
<span class="n">prog</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">3405691582</span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">tower</span> <span class="k">=</span> <span class="mi">35L</span>
<span class="n">tower</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">35</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">of</span> <span class="k">=</span> <span class="mi">31</span><span class="n">l</span>
<span class="n">of</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">31</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>Int</code> літерал присвоюється змінній <code>Short</code> або <code>Byte</code>, литерал розглядається як би він був <code>Short</code> або <code>Byte</code>, доки значення літерала в валідному диапазоні. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">little</span><span class="k">:</span> <span class="kt">Short</span> <span class="o">=</span> <span class="mi">367</span>
<span class="n">little</span><span class="k">:</span> <span class="kt">Short</span> <span class="o">=</span> <span class="mi">367</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">littler</span><span class="k">:</span> <span class="kt">Byte</span> <span class="o">=</span> <span class="mi">38</span>
<span class="n">littler</span><span class="k">:</span> <span class="kt">Byte</span> <span class="o">=</span> <span class="mi">38</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____2">Літерали з плаваючою крапкою</h3>
<div class="paragraph"><p>Літерали з плаваючою крапкою складаються з десятичних цифр, опціонально містять десятичну крапку, опціонально далі іде E або e та експонента. Деякі приклади літералів з плаваючою крапкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">big</span> <span class="k">=</span> <span class="mf">1.2345</span>
<span class="n">big</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.2345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bigger</span> <span class="k">=</span> <span class="mf">1.2345e1</span>
<span class="n">bigger</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">12.345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">biggerStill</span> <span class="k">=</span> <span class="mi">123</span><span class="n">E45</span>
<span class="n">biggerStill</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.23E47</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що частина експоненти означає ступінь десяти, на яку домножається інша частина. Таким чином 1.2345e1 є 1.2345 разів по 10<sup>1</sup>, що є 12.345. Якщо літерал з плаваючою крапкою завершується на F або f, це <code>Float</code>; інакше це <code>Double</code>. Опціонально, літерал з плаваючою крапкою <code>Double</code> може завершуватись на D або d. Деякі приклади літералів <code>Float</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">little</span> <span class="k">=</span> <span class="mf">1.2345F</span>
<span class="n">little</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">1.2345</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">littleBigger</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5f</span>
<span class="n">littleBigger</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">300000.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Це останнє значення, виражене як <code>Double</code> може приймати такі (ті інші) форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">anotherDouble</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5</span>
<span class="n">anotherDouble</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">300000.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">yetAnother</span> <span class="k">=</span> <span class="mi">3</span><span class="n">e5D</span>
<span class="n">yetAnother</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">300000.0</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___2">Символі літерали</h3>
<div class="paragraph"><p>Символьні літерали складаються з Unicode символа між поодинокими лапками, такі як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="sc">&#39;A&#39;</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">A</span>
</pre></div></div></div>
<div class="paragraph"><p>На додаток до провадження явного символа між поодинокими лапками, ви можете сказати символ, використовуючи кодову точку Unicode. Щоб зробити це, запишіть \u, за якими чотири шіснадцятиричних цифри кодовою точки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d</span> <span class="k">=</span> <span class="sc">&#39;\u0041&#39;</span>
<span class="n">d</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">A</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="sc">&#39;\u0044&#39;</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">D</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, такі Unicode символи можуть з'являтись будь-де в програмі Scala. Наприклад, ви можете також написати ідентифікатор таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">B</span><span class="o">\</span><span class="n">u0041</span><span class="o">\</span><span class="n">u0044</span> <span class="k">=</span> <span class="mi">1</span>
<span class="nc">BAD</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей ідентифікатор розглядається як ідентичний до BAD, результат двох Unicode символів в коді вище. Загалом це погана ідея називати ідентифікатори таким чином, оскільки їх важко читати. Скоріше цей синтаксис призначений щоб дозволити джерельним файлам Scala, що містять не-ASCII Unicode символи бути представленими в ASCII.</p></div>
<div class="paragraph"><p>Нарешті, існують також декілька літералів, представлених спеціалними ескейп виключеннями, показаними в Таблиці 5.2. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">backslash</span> <span class="k">=</span> <span class="sc">&#39;\\&#39;</span>
<span class="n">backslash</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="o">\</span>
</pre></div></div></div>
<div class="paragraph"><p>Специальні символи, ескейп послідовності</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Літерал </th>
<th align="center" valign="top"> Значення</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">\n</p></td>
<td align="center" valign="top"><p class="table">перевод рядка (\u000A)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\b</p></td>
<td align="center" valign="top"><p class="table">сторно (\u0008)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\t</p></td>
<td align="center" valign="top"><p class="table">табуляція (\u0009)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\f</p></td>
<td align="center" valign="top"><p class="table">нова сторінка (\u000C)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\r</p></td>
<td align="center" valign="top"><p class="table">повернення каретки (\u000D)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\"</p></td>
<td align="center" valign="top"><p class="table">подвійні лапки (\u0022)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\'</p></td>
<td align="center" valign="top"><p class="table">поодинокі лапки (\u0027)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">\\</p></td>
<td align="center" valign="top"><p class="table">зворотня коса (\u005C)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="___3">Рядкові літерали</h3>
<div class="paragraph"><p>Рядкові літерали складаються з символів в подвійних лапках:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">hello</span> <span class="k">=</span> <span class="s">&quot;hello&quot;</span>
<span class="n">hello</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span>
</pre></div></div></div>
<div class="paragraph"><p>Стнтаксис символів в дужках той самий, як і в символьних літералах. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">escapes</span> <span class="k">=</span> <span class="s">&quot;\\\&quot;\&#39;&quot;</span>
<span class="n">escapes</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">\</span><span class="err">&quot;&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки цей синтаксис незручний для рядків, що містять багато ескейп послідовностей, або рядків, що перетинають багато рядків,  Scala включає особливий синтаксис для сирих рядків. Ви починаєте та завершуєте сирий рядок трьома подвійними лапками поспіль ("""). Внутрішність сирого рядка може містити любі символи, будь-що, включаючи нові рядки, лапки, спеціальні символи, за винятком, зрозуміло, тьох подвійних лапок повпіль. Наприклад, наступна програма друкує повідомлення використовуючи сирий рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">&quot;&quot;&quot;Welcome to Ultamix 3000.</span>
<span class="s">           Type &quot;HELP&quot; for help.&quot;&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак виконання цього кода не продукує саме те, що задумане:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Welcome to Ultamix 3000.
           Type "HELP" for help.</code></pre>
</div></div>
<div class="paragraph"><p>Проблема в тому, що початкові проміжки в другому рядку включені в рядок! Щоб допомогти в цій загальній ситуації, ви можете викликати для рядків stripMargin. Щоб використати цей метод, покладіть символ роздільника (|) спереду кожного рядка, та потім викличте  <code>stripMargin</code> для цілого рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">&quot;&quot;&quot;|Welcome to Ultamix 3000.</span>
<span class="s">           |Type &quot;HELP&quot; for help.&quot;&quot;&quot;</span><span class="o">.</span><span class="n">stripMargin</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер код поводиться як задумано:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Welcome to Ultamix 3000.
Type "HELP" for help.</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="___4">Символьні літерали</h3>
<div class="paragraph"><p>Символьний літерал записується <code>'ident</code>, де <code>ident</code> може бути любим ідентифікатором з літер та цифр. Такі літерали відображуються на примірники передвизначеного класу <code>scala.Symbol</code>. Зокрема, літерал <code>'cymbal</code> буде розширений компілятором до виклику метода фабрики: <code>Symbol("cymbal")</code>. Символьні літерали типово використовуються в ситуаціях, де ви можете використовувати ідентифікатор в динамічно типизованих мовах. Наприклад, ви можете побажати визначити метод, що оновлює запис в базі даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Symbol</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
<span class="c1">// code goes here</span>
<span class="o">}</span>
<span class="n">updateRecordByName</span><span class="k">:</span> <span class="o">(</span><span class="kt">Symbol</span><span class="o">,</span><span class="kt">Any</span><span class="o">)</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод приймає в якості параметра символ, що вказує ім'я поля запису,в яке траба внести зміни. В динамічно типизованих ви можете визвати цю операцію, передаючи в метод недекларований ідентифікатор поля, але в Scala це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class="n">favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="kt">value</span> <span class="kt">favoriteAlbum</span>
<span class="n">updateRecordByName</span><span class="o">(</span><span class="n">favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього, і майже так стисло, ви можете передати символьний літерал:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">updateRecordByName</span><span class="o">(</span><span class=" -Symbol">&#39;favoriteAlbum</span><span class="o">,</span> <span class="s">&quot;OK Computer&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З символом ви можете робити не дуже багато чого, крім з'ясувати його ім'я:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class=" -Symbol">&#39;aSymbol</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">Symbol</span> <span class="o">=</span> <span class=" -Symbol">&#39;aSymbol</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nm</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">name</span>
<span class="n">nm</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">aSymbol</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша річ, що варта уваги, це те, що символи інтерновані. Якщо ви пишете той самий літерал двічі, обоє вирази будуть посилатись на той самий об'єкт <code>Symbol</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___5">Логічні літерали</h3>
<div class="paragraph"><p>Тип Boolean має два літерала, <code>true</code> та <code>false</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bool</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">bool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fool</span> <span class="k">=</span> <span class="kc">false</span>
<span class="n">fool</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Це все щодо цього. Тепер ви буквально експерт в Scala.<span class="footnote"><br />[фігурально кажучи]<br /></span></p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_3__">5.3 Інтерполяція рядків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala включає гнучкий механізм для інтерполяції рядків, що дозполяє вам вбудовувати вирази в рядкові літерали. Її найбільш загальний випадок викорстання є провадження стислої та читабельної альтернативи до конкатенації рядків. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;reader&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="s">s&quot;Hello, </span><span class="si">$name</span><span class="s">!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>s"Hello, $name!"</code> є обробляємий рядковий літерал. Оскільки літера <code>s</code> безпосередньо передує відкриваючим лапкам, Scala скала буде використовувати інтерполяцію рядка <code>s</code> для обробки літерала. Цей <code>s</code> інтерполятор буде обчислювати кожний вбудований вираз, викликаючи <code>toString</code> для кожного результата, та замінює вбудовані вирази в літералі на ці результати. Таким чином, <code>s"Hello, $name!"</code> дає <code>"Hello, reader!"</code>, той самий результат, що і <code>"Hello, " + name + "!"</code>.</p></div>
<div class="paragraph"><p>Ви можете покласти любий вираз після знаку долара ($) в оброблюваний рядковий літерал. Для одно-змінних виразів, ви часто можете ім'я змінної після знаку долару. Scala буде інтерпретувати всі символи до першого не-ідентифікаторного символа як вираз. Якщо вираз включає не-ідентифікаторні символи, ви маєте покласли його в фігурні дужки, з відкриваючою дужкою прямо за знаком долара. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">s&quot;The answer is </span><span class="si">${</span><span class="mi">6</span> <span class="o">*</span> <span class="mi">7</span><span class="si">}</span><span class="s">.&quot;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">The</span> <span class="n">answer</span> <span class="n">is</span> <span class="mf">42.</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala провадить два інші інтерполятора по замовчанню: <code>raw</code> та <code>f</code>. Інтерпретатор рядків <code>raw</code> поводиться як <code>s</code>, за винятком того, що він не розпізнає сивольні літерали ескейп послідовності (такі як показані в Таблиці 5.2). Наприклад, наступне твердження друкує чотири зворотні косі, не дві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="s">raw&quot;No\\\\escape!&quot;</span><span class="o">)</span> <span class="c1">// prints: No\\\\escape!</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерполятор рядка <code>f</code> дозволяє вам додати вам інструкції форматування в стилі <code>printf</code> для вбудованих виразів. Ви покладаєте інструкції після виразу, починаючи зі знака відсотків (%), використовуючи синтаксис, заданий в <code>java.util.Formatter</code>. Наприклад, ось як ви можете форматувати число pi</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">f&quot;</span><span class="si">${</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="si">}</span><span class="s">%.5f&quot;</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mf">3.14159</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви не провадите інструкцій форматування для вбудованого виразу, рядковий інтерпретатор <code>f</code> буде по замовчанню вважати <code>%s</code>, що означає, що буде підставлено значення <code>toString</code>, так само як інтерпретатор рядків <code>s</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="s">&quot;Pi&quot;</span>
<span class="n">pi</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Pi</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="s">f&quot;</span><span class="si">$pi</span><span class="s"> is approximately </span><span class="si">${</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="si">}</span><span class="s">%.8f.&quot;</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Pi</span> <span class="n">is</span> <span class="n">approximately</span> <span class="mf">3.14159265</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala інтерполяція рядків реалізована через переписування кода під час компіляції. Компілятор буде трактувати любий вираз, що складається з ідентифікатора, безпосередньо за яким іде подвійни лапки рядкового літералу, є виразом інтерполятора рядка. Інтерпретатори рядків <code>s</code>, <code>f</code>, та <code>raw</code> реалізовані через цей загальний механізм. Бібліотеки та користувачі можуть визначати інші інтерполятори рядків для інших цілей.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_4___">5.4 Оператори та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala провадить потужний набір операторів для своїх базових типів. Як згадувалось в попередніх главах, ці операції насправді є милим синтаксисом для звичайних викликів методів. Наприклад, <code>1 + 2</code> насправді означає те саме, що <code>1.+(2)</code>. Іншими словами, клас <code>Int</code> містить метод <code>+</code>, що приймає <code>Int</code> та повертає результат <code>Int</code>. Цей метод <code>+ викликається, коли ви додаєте два `Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// Scala invokes 1.+(2)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб переконатись в цьому, ви можете написати вираз явно як виклик метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sumMore</span> <span class="k">=</span> <span class="mf">1.</span><span class="o">+(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">sumMore</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, <code>Int</code> містить декілка перевантажених методів <code>+</code>, що приймають різні типів параметрів.<span class="footnote"><br />[3]<br /></span> For example, Int has another method, also named +, that takes and returns a Long. If you add a Longto an Int, this alternate + method will be invoked, as in:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">longSum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2L</span>
<span class="n">longSum</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">3</span>
<span class="c1">// Scala invokes 1.+(2L)</span>
</pre></div></div></div>
<div class="paragraph"><p>Символ <code>+</code> є оператором — інфіксним оператором, якщо бути точнішим. Операторна нотація не обмежена до методів, як <code>+</code>, що виглядають як оператори в інших мовах. Ви можете використовувати любий метод в операторній натації. Наприклад, клас <code>String</code> має метод <code>indexOf</code>, що приймає один параметр <code>Char</code>. Метод <code>indexOf</code> шукає рядок на перше співпадіння вказаного символа, та повертає його індекс, або <code>-1</code>, якщо вона не знайшла символ. Ви можете використовувати <code>indexOf</code> як оператор, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">indexOf</span> <span class="sc">&#39;o&#39;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
<span class="c1">// Scala invokes s.indexOf(&#39;o&#39;)</span>
</pre></div></div></div>
<div class="paragraph"><p>На додаток, <code>String</code> пропонує перевантажений метод <code>indexOf</code>, що приймає два параметри, символ, що треба шукати, та індекс, з якого починати. (Інший метод <code>indexOf</code>, показаний попередньо, починає з індексу 0, початку <code>String</code>.) Навіть якщо цей метод <code>indexOf</code> приймає два аргументи, ви можете використовувати його в операторній нотації. Але коли ви викликаєте метод, що приймає декілька аргументів використовуючи операторну нотацію, ви маєте поклачти ці аргументи в дужках. Наприклад, ось як ви використовуєте цей інший <code>indexOf</code> як оператор (продовжуючи попередній приклад):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">indexOf</span> <span class="o">(</span><span class="sc">&#39;o&#39;</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="c1">// Scala invokes s.indexOf(&#39;o&#39;, 5)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_____">Любий метод може бути оператором</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala оператори не є особливим мовним синтаксисом; любий метод може бути оператором. Що робить метод оператором, це те, як ви використовуєте його. Коли ви пишете <code>s.indexOf('o')</code>, <code>indexOf</code> не є оператором. Але коли ви пишете <code>s indexOf 'o'</code>, <code>indexOf</code> є оператором, оскільки ви використовуєте його в операторній нотації.</p></div>
<div class="paragraph"><p>Досі ви бачили приклади інфіксної операторної нотації, що означає, що викликаємий метод сидить між об'єктом і параметром (або параметрами), які ви бажаєте передати в метод, як в <code>7 + 2</code>. Scala також має дві інші операторні нотації: префіксну та постфіксну. В префіксній нотації ви кладете метод перед об'єктом, на якому ви викликаєте метод (наприклад, <code>-</code> в <code>-7</code>). В постфіксній нотації ви кладете метод після об'єкта (наприклад, <code>toLong</code> в <code>7 toLong</code>).</p></div>
<div class="paragraph"><p>Для контрасту до інфіксної нотації, де оператори мають два операнди, один зліва та інший зправа, префіксні та постфіксні оператори є унарними: вони приймають тільки один операнд. В префіксній нотації операнд іде зправа від операнда. Деякі приклади префіксних операторів є <code>-2.0</code>, <code>!found</code>, та <code>~0xFF</code>. Як і з інфіксними операторами, ці префіксні оператори є скороченнями до виклику методів. Однак в цьому випадку ім'я метода має <code>unary_</code> перед символом оператора. Наприклад, Scala буде трансформувати вираз <code>-2.0</code> в виклик метода <code>(2.0).unary_-</code>. Ви можете продемонструвати це собі, набравши виклик метода обоє, через операторну нотацію та явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
<span class="c1">// Scala invokes (2.0).unary_-</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mf">2.0</span><span class="o">).</span><span class="n">unary_-</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдині ідентифікатори, що можуть бути викортстані як префіксні оператори, є <code>\+</code>, <code>-</code>, <code>!</code>, та <code>~</code>. Таким чином, якщо ви визначите метод на ім'я <code>unary_!</code>, ви можете викликати цей метод на значенні або змінній відповідного типу, використавши префіксну операторну нотацію, таку як <code>!p</code>. Але якщо ви визначите метод <code>unary_*</code>, ви не будете в змозі використовувати префіксну операторну нотацію, бо <code>*</code> не є одним з чотирьох ідентифікаторів, що можуть використовуватись в префіксних операторах. Ви можете викликати метод звичайно, як <code>inp.unary_*</code>, але якщо ви спробуєте визвати його через <code>*p</code>, Scala буде розбирати його, якби ви записали <code>*.p</code>, що, можливо, не те, що ви мали на увазі!<span class="footnote"><br />[Однак не все втрачено. Існує вкрай слабкий шанс, що ваша програма з *p може компілюватись як C++.]<br /></span></p></div>
<div class="paragraph"><p>Постфіксні оператори є методи, що не приймають аргументів, коли вони викликаються без крапки та дужок. В Scala ви можете відкинути пусті дужки на виклику метода. Домовленість полягає в тому, що ви залишаєте дужки, якщо метод має побічні ефекти, як в println(), але ви можете не вживати їх, якщо метод не має побічних ефектів, як в <code>toLowerCase</code> викликане на <code>String</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;Hello, world!&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">toLowerCase</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому останньому випадку метода, що не потребує аргументів, ви можете альтернативно відкинути крапку, і використовувати постфіксну операторну нотацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span> <span class="n">toLowerCase</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку <code>toLowerCase</code> використовується як постфіксний оператор на операнді <code>s</code>.</p></div>
<div class="paragraph"><p>Таким чином, щоб побачити, які оператори ви можете використовувати з базовими типами Scala, все що вам дійсно треба зробити, це подивитись на методи, задекларовані в класах типу в документації Scala API. Зважаючи, що це Scala туторіал, однак, ми надамо вам швидкий тур по більшості з ціх методів в наступних декільках розділах.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java__2">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато аспектів Scala, описані в залишку цієї глави, такі ж самі, що і в Java. Якщо ви практикуючий Java гуру в розквиті, ви можете безпечно пропустити все до Розділу 5.8, що описує як Scala відрізняється від Java в сфері еквівалентності об'єктів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_5__">5.5 Арифметичні оператори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете викликати арифметичні методи через інфіксну операторну нотацію для додавання (+), віднімання (-), множення (*), ділення (/), та залишку (%) на любих числових типах. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">+</span> <span class="mf">2.3</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;b&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2L</span> <span class="o">*</span> <span class="mi">3L</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">11</span> <span class="o">/</span> <span class="mi">4</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">11</span> <span class="o">%</span> <span class="mi">4</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">11.0f</span> <span class="o">/</span> <span class="mf">4.0f</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">2.75</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">11.0</span> <span class="o">%</span> <span class="mf">4.0</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли обоє, лівий та правий операнди є інтегральними типами (<code>Int</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code>), оператор <code>/</code> буде казати вам цілу частину від ділення, без залишку. Оператор <code>%</code> вказує залишок від цілого ділення.</p></div>
<div class="paragraph"><p>Залишок з плаваючою крапкою, що ви отримаєте за допомогою <code>%</code> не є тим, що визначений в стандарті IEEE 754. Залишок IEEE 754 використовує округлююче ділення, не відсікаюче ділення, при обчисленні залишка, так що повністю інше від операції цілого залишку. Якщо ви дійсно бажаєте залишок IEEE 754, ви можете викликати <code>IEEEremainder</code> зі <code>scala.math</code>, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="nc">IEEEremainder</span><span class="o">(</span><span class="mf">11.0</span><span class="o">,</span> <span class="mf">4.0</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Числові типи також пропонують унарний префіксний оператор <code>+</code> (метод <code>unary_+</code>) та <code>-</code> (метод <code>unary_-</code>), що дає вам вказати, чи є літеральне число позитивним або негативним (додатним або від'ємним), як в <code>-3</code> або <code>+4.0</code>. Якщо ви не вказуєте унарний <code>+</code> або <code>-</code>, літеральне число розглядається як позитивне. Унарний <code>+</code> існує виключно для симетрії з <code>-</code>, але не має ефекту. Унарний <code>-</code> може також використовуватись для обернення змінної. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">neg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="o">-</span><span class="mi">3</span>
<span class="n">neg</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="o">+</span><span class="mi">3</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="n">neg</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_6____">5.6 Відносні та логічні операції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете порівняти числові типи за допомогою відносних методів: більше ніж (&gt;), менше ніж (&lt;), більше або рівне (&gt;=), менше або рівне (&#8656;), що дають результат типу Boolean. На додаток ви можете використати унарний оператор <code>!</code> (метод <code>unary_!</code>), щоб інвертувати значення Boolean. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="mi">2</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">3.5f</span> <span class="o">&gt;=</span> <span class="mf">3.6f</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;=</span> <span class="sc">&#39;A&#39;</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">untrue</span> <span class="k">=</span> <span class="o">!</span><span class="kc">true</span>
<span class="n">untrue</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Логічні методи, ТА (<code>&amp;&amp;</code> та <code>&amp;</code>), АБО (<code>||</code> та <code>|</code>), приймають <code>Boolean</code> операнди в інфіксній нотації, та видають Boolean результат. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">toBe</span> <span class="k">=</span> <span class="kc">true</span>
<span class="n">toBe</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">question</span> <span class="k">=</span> <span class="n">toBe</span> <span class="o">||</span> <span class="o">!</span><span class="n">toBe</span>
<span class="n">question</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">paradox</span> <span class="k">=</span> <span class="n">toBe</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">toBe</span>
<span class="n">paradox</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Операції <code>&amp;&amp;</code> та <code>||</code> короткого обчислення, як в Java: вирази, побудовані з ціх операторів, обчислюються так далеко, як треба для визначення результату. Іншими словами, права частина виразів <code>&amp;&amp;</code> та <code>||</code> не буде обчислюватись, якщо ліва визначає результат. Наприклад, як ліва сторона виразу ТА буде обчислена як <code>false</code>, результат виразу буде обчислений як <code>false</code>, так що права частина не буде обчислена. Подібно,якщо ліва частина виразу АБО обчисляється до <code>true</code>, результат виразу буде однозначно <code>true</code>, так що права сторона не буде обчислюватись.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">salt</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;salt&quot;</span><span class="o">);</span> <span class="kc">false</span> <span class="o">}</span>
<span class="n">salt</span><span class="k">:</span> <span class="o">()</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">pepper</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pepper&quot;</span><span class="o">);</span> <span class="kc">true</span> <span class="o">}</span>
<span class="n">pepper</span><span class="k">:</span> <span class="o">()</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">pepper</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">salt</span><span class="o">()</span>
<span class="n">pepper</span>
<span class="n">salt</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">salt</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">pepper</span><span class="o">()</span>
<span class="n">salt</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому виразі викликаються <code>pepper</code> та <code>salt</code>, але в другому викликається тільки <code>salt</code>. Припускаючи, що <code>salt</code> повертає <code>false</code>, немає потреби викликати <code>pepper</code>. Якщо ви бажаєте обчислити праву сторону в любому випадку, використовуйте оператори <code>&amp;</code> та <code>|</code>. Метод <code>&amp;</code> виконує логічне ТА, <code>|</code> логічне АБО, але не скорочено, як <code>&amp;&amp;</code> та <code>||</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">salt</span><span class="o">()</span> <span class="o">&amp;</span> <span class="n">pepper</span><span class="o">()</span>
<span class="n">salt</span>
<span class="n">pepper</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">falseNote</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете зацікавитись, як може працювати, якщо оператори всього лише методи. Звичайно всі аргументи обчислюються перед входом в метод, так що як метод уникає обчислення свого второго аргумента? Відповідь полягає в тому, що всі методи Scala мають можливість відкладати обчислення своїх аргументів, або навіть відмовлятись обчислювати їх взагалі. Можливість називається параметри за-ім'ям, та обговорюється в Розділі 9.5.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_7__">5.7 Побітові операції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala дозволяє вам виконувати операції з окремими бітами цілих типів за допомогою декількох побітових методів. Оператори настіпні: побітне ТА (&amp;), побітне АБО (|), побітне XOR (!АБО) (^).<span class="footnote"><br />[ Метод побітне XOR виконує ексклюзивне АБО на операторах. Ідентичні біти дають 0. Різні біти дають 1. Таким чином, 0011 ^ 0101 дає 0110.]<br /></span>Унарний побітовий оператор (<code>~</code>, метод <code>unary_~</code>) інвертує кожний біт свого операнда. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;</span> <span class="mi">2</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">^</span> <span class="mi">3</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">~</span><span class="mi">1</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший вираз, <code>1 &amp; 2</code>, побітно перевіряє біти в 1 (0001) та 2 (0010), що дає 0 (0000). Другий вираз, <code>1 | 2</code>, побітно складає біти тих же операндів, даючи 3 (0011). Третій вираз, <code>1 ^ 3</code>, побітно виконує   xor для 1 (0001) та 3 (0011), даючи 2 (0010). Заключний вираз, <code>~1</code>, інвертує кожний біт в 1 (0001), даючи -2, що в бінарній формі виглядає як 11111111111111111111111111111110.</p></div>
<div class="paragraph"><p>Цілі типи Scala також пропонують три методи зсуву: зсув вліво (&lt;&lt;), зсув вправо (&gt;&gt;), та беззнаковий зсув вправо (&gt;&gt;&gt;). Методи зсува, коли використовуються в інфіксній операторні нотації, зсувають ціле значення лівого операнда на кількість біт, заданих правим оператором. Зсув вправо та беззнаковий зсув вліво заповнюють нові біти нулями. Зсув вправо заповнює ліві біти знаковим (старшим) бітом. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;&gt;</span> <span class="mi">31</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>-1 в двійниковій системі є 11111111111111111111111111111111. В першому прикладі, -1 &gt;&gt; 31, -1 зсувається вправо на 31 позицій. Оскільки <code>Int</code> складається з 32 біт, ця операція ефективно рухає самий лівий біт, доки він не стане самий правий.<span class="footnote"><br />[Самий лівий біт цілого типу є бітом знаку. Якщо самий лівий біт 1, число від'ємне. Якщо 0 число додатнє.]<br /></span> Наш метод &gt;&gt; заповнює одиницями при зсуві вправо, оскільки лівий біт -1 є 1, результат ідентичний до оригіналу лівого операну, 32 біти одиниць, або -1. В другому прикладі -1 &gt;&gt;&gt; 31, самий лівий біт знову зсувається в саму праву позицію, але на цей раз заповнюється нулями. Результат на цей раз буде двоїчне 00000000000000000000000000000001, або 1. В фінальному прикладі, 1 &lt;&lt; 2, лівий операнд, 1, зсувається вліво на ді позиції, даючи бінарне 00000000000000000000000000000100, або 4.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_8___">5.8 Еквівалентність об'єктів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви бажаєте порівняти два об'єкти на еквівалентність, ви можете використовувати або <code>==</code> або його інверсію <code>!=</code>. Ось декілька простих прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">2</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">2</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці операції насправді застосовуються для всіх об'єктів, не тільки для базових типів. Так що ви можете, наприклад, застосувати <code>==</code> для порівняння списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ідучи далі, ви можете порівняти два об'єкта, що мають різні типи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mf">1.0</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви навіть можете порівняти з <code>null</code>, або з чимось, що може бути <code>null</code>. Виключення не спрацює:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span>
<span class="n">res38</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="kc">null</span> <span class="o">==</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите, <code>==</code> було майстерно зроблене, так що ви отримаєте в більшості випадків тілкьи ту еквівалентність, яку побажаєте. Це досягається дуже простим правилом: спочатку перевіряється ліва сторона щодо <code>null</code>. Якщо це не <code>null</code>, викликається метод <code>equals</code>. Оскільки <code>equals</code> є методом, точне порівняння, що ви отримаєте, залежить від типу лівого аргументу. Оскільки перевірка на <code>null</code> автоматична, ви не повинні перевіряти самостійно.<span class="footnote"><br />[Автоматична перевірка не дивиться на праву частину, але любий адекватний метод <code>equals</code> повинен повертати <code>false</code>, якщо аргумент є <code>null</code>.]<br /></span>Цей різновид порівняння видасть <code>true</code> на різних об'єктах, доки їх вміст той самий, та їх методи <code>equals</code> написані на основі їх вмісту. Наприклад, ось порівняння між двома рядками, що мають ті самі п'ять літер:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="s">&quot;he&quot;</span> <span class="o">+</span> <span class="s">&quot;llo&quot;</span><span class="o">)</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___scala___java">Як == в Scala відрізняється від Java</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Java ви можете використовувати <code>==</code> для порівняння обох, примітивних та типів посилань. На примітивних типах Java <code>==</code> перевіряє еквівалентінсть значень, як в Scala. На типах посилань, однак, Java <code>==</code> порівнює еквівалентність посилань, що означає, що дві змінні посилаються на той самий об'єкт в купі JVM. Scala також провадить здатність порівняти еквівалентність посилань, під ім'ям <code>eq</code>. Однак <code>eq</code> та його протилежність, <code>ne</code>, застосовується тільки для об'єктів. що напряму відзеркалюються на Java об'єкти. Повні деталі щодо <code>eq</code> та <code>ne</code> надаються в Розділі 11.1 та 11.2. Також дивіться Главу 30 щодо того, як писати гарний метод <code>equals</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_9____">5.9 Преоритети та асоціативність операторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Преоритет операторів визначає, яка частина виразу обчислюється перед іншими частинами. Наприклад, вираз <code>2 + 2 * 7</code> обчислюється до <code>16</code>, не <code>28</code>, оскільки оператор <code>*</code> має вищий преоритет, ніж оператор <code>+</code>. Таким чином, частина множення обчислюється перед частиною додавання. Ви можете, звичайно, використати дужки для прояснення порядку обчислення, або щоб перекрити преоритети. Наприклад, якщо ви дійсно бажаєте отримати результат виразу вище 28, ви можете записати вираз таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">)</span> <span class="o">*</span> <span class="mi">7</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги, що Scala не має операторів як таких, а тільки спосіб використовувати методи в операторній нотації, ви можете здивуватись, як роблять преоритети операцій. Scala визначає преоритет базуючись на першому символі методів, використаних в операторній нотації (є одне виключення з цього правила, що буде продискутоване на наступних сторінках). Якщо ім'я метода починається з <code>*</code>, наприклад, він буде мати вищий преоритет, ніж метод, що починається з <code>+</code>. Таким чином, <code>2 + 2 * 7</code> буде еквівалентне до <code>2 + (2 * 7)</code>. Подібно, <code>a  b *** c` (в якому `a`, `b`, та 'c' є змінні, а `</code> та <code>***</code> є методи) буде обчислене як <code>a  (b *** c)`, оскікльки метод `***` має вищий преоритет, ніж метод `</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.3: Преоритети операцій</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі спеціальні символи)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">* / %</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">+ -</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">:</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">= !</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">&lt;</p></td>
<td align="right" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">&amp;</p></td>
<td align="center" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">|</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі літери)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">(всі оператори присвоєння)</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Таблиця 5.3 показує преоритети, надані першим літерам метода в порярдку зменшення преоритету, де символи на одному рядку мають один преоритет. Чим вище символ в цій таблиці, тим вищий преоритет методів, що починаються з цього символа. Ось приклад, що ілюструє вплив преоритетів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">32</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>&lt;&lt;</code> починається з символа <code>&lt;</code>, що стоїть нижче в Таблиці 5.3, ніж символ <code>+</code>, що є першим та єдиним символом метода <code>+</code>. Таким чином, <code>&lt;&lt;</code> буде мати нижчий преоритет, ніж <code>+</code>, і вираз буде обчислений починаючи з метода <code>+</code>, потім метода <code>&lt;&lt;</code>, як в <code>2 &lt;&lt; (2 + 2)</code>. <code>2 + 2</code> є <code>4</code>, за нашими підрахунками, та <code>2 &lt;&lt; 4</code> дає <code>32</code>. Якщо ми поміняємо оператори, ви отримаєте інший результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">16</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки перші символи такі самі, що в попередньому прикладі, методи будуть викликані в тому самому порядку. Спочатку буде викликаний метод <code>+</code>, потім метод <code>&lt;&lt;</code>. Так що <code>2 + 2</code> знову дасть 4, та <code>4 &lt;&lt; 2</code> є <code>16</code>.</p></div>
<div class="paragraph"><p>Одне виключення з правила преоритетів, до якого ми посилались раніше, стосується  операторів присвоєння, що завершуються на знак рівності. Якщо оператор закінчується на знак рівності(=), і це не один з операторів порівняння: <code>&gt;=</code>, <code>==</code>, або <code>!=</code>, тоді преоритет оператора такий самий, як в простого присвоєння (=). Тобто, він меньший ніж преоритет любого іншого оператора. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">*=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>значить те саме, що і:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">*=</span> <span class="o">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>оскільки <code>*=</code> класифікується як оператор присвоєння, чий преоритет нижчий, ніж <code>+</code>, навіть незважаючи, що перший символ оператора <code>*</code>, що мало б підказувати преоритет, вищий за <code>+</code>.</p></div>
<div class="paragraph"><p>Коли декілька операторів з однаковим преоритеттом стоять поряд в виразі, асоциативність операторів визначає групування. Асоциативність операторів в Scala визначається останнімсимволом. Як зазначалось в Главі 3, любий метод, що завершується на симол <code>:</code> викликається не своєму правому операнді. Методи, що завершуються на любий інший символ, роблять навпаки: вони викликаються на своєму лівому операнді, передаючи правий операнд.</p></div>
<div class="paragraph"><p>Так що <code>a * b</code> дає <code>a.*(b)</code>, але <code>a:::b</code> дає <code>b.:::(a)</code>.</p></div>
<div class="paragraph"><p>Оданк неважливо, яку асоциативніть має оператор, його операнди завжди використовуються зліва направо. Так що якщо <code>a</code> є виразом, що не тільки просте посилання на незмінне значення, тоді <code>a:::b</code> більш точно трактується як в наступному блоці:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">{</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">a</span><span class="o">;</span> <span class="n">b</span><span class="o">.:::(</span><span class="n">x</span><span class="o">)</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому блоці <code>a</code> все одне обчислюється раніше за <code>b</code>, та потім результат передається до метода <code>b.:::</code>.</p></div>
<div class="paragraph"><p>Це правило асоціативності також відіграє роль, коли декілька оператоорів з однаковим преоритетом стоять поряд. Якщо метод завершується на <code>:</code>, вони групуються зліва направо. Наприклад, <code>a:::b:::c</code> трактується як <code>a:::(b:::c)</code>. Але <code>a * b * c</code>, для контрасту, трактується як <code>(a * b) * c</code>. Преоритетність операторів я частиною мови Scala. Вам не треба лякатись використовувати її. Тим не менш, є гарним стилем використовувати дужки для прояснення, які операції ідуть за якими в виразі. Можливо, єдині преоритети, на які ви можете дійсно розраховувати, що інші програмісти мають знати без підглядання, це мультиплікативні оператори: <code>*</code>, <code>/</code>, та <code>%</code>, мають преоритет над аддитивними, <code>+</code> та <code>-</code>. Так що навіть якщо <code>a + b &lt;&lt; c</code> дає бажаний вами результат без дужок, додаткова ясність, яку дасть запис <code>(a + b) &lt;&lt; c</code>, може зменшити частоту, з якою ваш колега буде використовувати ваше ім'я в операторній нотації, наприклад, вигукуючи в розпачі "<code>bills !*&amp;\^%~ code!</code>".<span class="footnote"><br />[Тепер в маєте бути в змозі зрозуміти, що маючи цей код, компілятор Scala буде викликати (bills.!*&amp;\^%~(code)).!().]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_10__">5.10 Багаті огортки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете викликати значно більше методів на базових типах Scala, ніж показано в Таблиці 5.4. Ці методи доступні через неявні перетворення, прийом, що буде описаний в деталях в Главі 21. Все що вам покі що треба знати, це що для кожного базового типу, описаного в цій главі, також існує "багата огортка", що провадить декілька додаткових методів. Таким чином, щоб подивитись всі доступні методи для базового типу, вам слід дивитись документацію API по багатій огортці для базового типу. Ці класи перелічені в Таблиці 5.5.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.4: Деякі багаті операції</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Код </th>
<th align="center" valign="top"> Результат</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="n">max</span> <span class="mi">5</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">5</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="n">min</span> <span class="mi">5</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">0</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mf">2.7</span> <span class="n">abs</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">2.7</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">-</span><span class="mf">2.7</span> <span class="n">round</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">-3L</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mf">1.5</span> <span class="n">isInfinity</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">false</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mi">0</span><span class="o">)</span> <span class="n">isInfinity</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">true</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="n">to</span> <span class="mi">6</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Range(4, 5, 6)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;bob&quot;</span> <span class="n">capitalize</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">"Bob"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;robert&quot;</span> <span class="n">drop</span> <span class="mi">2</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">"bert"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 5.5: Багаті типи огортки</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Багата огортка</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichByte</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichShort</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichInt</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichLong</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichChar</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichFloat</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichDouble</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="center" valign="top"><p class="table">scala.runtime.RichBoolean</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="center" valign="top"><p class="table">scala.collection.immutable.StringOps</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_5_11_">5.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Головний висновок з цієї глави в тому, що операції в Scala є викликами методів, та що для базових типів Scala існують неявні перетворення до збагачених типів, що додають це більше корисних методів. В наступній главі ми покажемо, що це значить розробляти об'єкти в функціональному стилі, що дає нові реалізації операторів, які ви бачили в цій главі.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-01 05:22:56 EET
</div>
</div>
</body>
</html>
