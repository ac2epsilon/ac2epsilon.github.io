<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__5">Глава 5</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____">Базові типи і операції</h1>
<div class="paragraph"><p>Тепер, коли ви побачили класи і об'єкти в дії, настав гарний час подивитись на базові типи та операції Scala більш глибоко. Якщо ви знайомі з Java, ви будете раді узнати, що базові типи і операції  Java мають те саме значення в Scala. Однак є деякі цікаві розбіжності, що роблять цю главу варту прочитання, навіть якщо ви досвідчений Java розробник. Оскільки деякі аспекти Scala, розглянуті в цій главі в основі ти самі, що і в Java, ми вставили зауваження, що ці частини Java розробники можуть пропустити.</p></div>
<div class="paragraph"><p>В цій главі ви отримаєте огляд базових класів Scala, включаючи  <code>String</code> та типи значень, <code>Int</code>, <code>Long</code>, <code>Short</code>, <code>Byte</code>, <code>Float</code>, <code>Double</code>, <code>Char</code>, та <code>Boolean</code>. Ви вивчите операції, що ви можете виконувати з ціма типами, включаючи те, як робить преоритетність операторів в виразах Scala. Ви також вивчите, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи додаткові операції, крім тих, що підтримуються в Java.</p></div>
<div class="sect1">
<h2 id="_5_1___">5.1 Деякі базові типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Декілька фундаментальних типів Scala, разом и диапазонами знічень ціх типів, яки вони можуть приймати, показані в Таблиці 5.1. Загалом типи <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code> та <code>Char</code> називаються інтегральними типами. Інтегральні типи разом з <code>Float</code> та <code>Double</code> називаються числовими типами.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі базові типи</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Базовий тип </th>
<th align="center" valign="top"> Диапазон</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">Byte</p></td>
<td align="left" valign="top"><p class="table">8-бітне ціле зі знаком (від -2<sup>7</sup> до 2<sup>7</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Short</p></td>
<td align="left" valign="top"><p class="table">16-бітне ціле зі знаком (від -2<sup>15</sup> до 2<sup>15</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Int</p></td>
<td align="left" valign="top"><p class="table">32-бітне ціле зі знаком (від -2<sup>31</sup> до 2<sup>31</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Long</p></td>
<td align="left" valign="top"><p class="table">64-бітне ціле зі знаком (від -2<sup>63</sup> до 2<sup>63</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Char</p></td>
<td align="left" valign="top"><p class="table">16-бітний беззнаковий символ Unicode (від 0 до 2<sup>16</sup> - 1, включно)</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">String</p></td>
<td align="left" valign="top"><p class="table">послідовність Char</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Float</p></td>
<td align="left" valign="top"><p class="table">32-бітне IEEE 754 з плаваючою крапкою одинарна точність</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Double</p></td>
<td align="left" valign="top"><p class="table">64-бітне IEEE 754 з плаваючою крапкою подвійна</p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">Boolean</p></td>
<td align="left" valign="top"><p class="table">true або false</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Всі крім <code>String</code>, що знаходиться в пакунку <code>java.lang</code>, всі типи, показані в Таблиці 5.1 є членами пакунку <code>scala</code>.<span class="footnote"><br />[Пакунки, що були коротко описані на Кроці 1 в Главі 2, будуть розглянуті глибоко в Главі 13.]<br /></span> Наприклад, повне ім'я <code>Int</code> є <code>scala.Int</code>. Однак беручи, що всі члени з пакунку <code>scala</code> та <code>java.lang</code> автоматично імпортуються в кожний джерельний файл Scala, ви можете використовувати самі прості імена (тобто імена як Boolean, Char, або String) будь-де.</p></div>
<div class="paragraph"><p>Допитливі Java розробники зауважать, базові типи Scala мають ті самі диапазони, що і відповідні типи в Java. Це дозволяє компілятору  Scala трансформувати примірники значень Scala, такі як <code>Int</code> або <code>Double</code>, до примітивних типів Java в спродукованому байткоді.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2_">5.2 Літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі базові типи, перелічені в Таблиці 5.1 можуть бути записані як літерали. Літерал - це шлях написати стале значення прямо в коді
.
Швидкий шлях для Java програмістів</p></div>
<div class="listingblock">
<div class="content">
<pre><code>The syntax of most literals shown in this section are exactly the same as in Java, so if you're a Java master, you can safely skip much of this section. Some differences you should read about are Scala's literals for raw strings and symbols, described starting here, and string interpolation, described starting here. Also, Scala does not support octal literals; integer literals that start with a 0, such as 031, do not compile.

Integer literals</code></pre>
</div></div>
<div class="paragraph"><p>Integer literals for the types Int, Long, Short, and Byte come in two forms: decimal and hexadecimal.
The way an integer literal begins indicates the base of the number. If the number begins with
a 0x or 0X, it is hexadecimal (base 16), and may contain 0 through 9 as well as upper or lowercase
digits A through F. Some examples are:
scala&gt; val hex = 0x5
hex: Int = 5
scala&gt; val hex2 = 0x00FF
hex2: Int = 255
scala&gt; val magic = 0xcafebabe
magic: Int = -889275714
Note that the Scala shell always prints integer values in base 10, no matter what literal form you may
have used to initialize it. Thus the interpreter displays the value of the hex2 variable you initialized
with literal 0x00FF as decimal 255. (Of course, you don&#8217;t need to take our word for it. A good way to
start getting a feel for the language is to try these statements out in the interpreter as you read this
chapter.) If the number begins with a non-zero digit, and is otherwise undecorated, it is decimal (base
10). For example:
scala&gt; val dec1 = 31
dec1: Int = 31
scala&gt; val dec2 = 255
dec2: Int = 255
scala&gt; val dec3 = 20
dec3: Int = 20
If an integer literal ends in an L or l, it is a Long; otherwise it is an Int. Some examples of Longinteger
literals are:
scala&gt; val prog = 0XCAFEBABEL
prog: Long = 3405691582scala&gt; val tower = 35L
tower: Long = 35
scala&gt; val of = 31l
of: Long = 31
If an Int literal is assigned to a variable of type Short or Byte, the literal is treated as if it were
aShort or Byte type so long as the literal value is within the valid range for that type. For example:
scala&gt; val little: Short = 367
little: Short = 367
scala&gt; val littler: Byte = 38
littler: Byte = 38
Floating point literals
Floating point literals are made up of decimal digits, optionally containing a decimal point, and
optionally followed by an E or e and an exponent. Some examples of floating-point literals are:
scala&gt; val big = 1.2345
big: Double = 1.2345
scala&gt; val bigger = 1.2345e1
bigger: Double = 12.345
scala&gt; val biggerStill = 123E45
biggerStill: Double = 1.23E47
Note that the exponent portion means the power of 10 by which the other portion is multiplied. Thus,
1.2345e1 is 1.2345 times 101, which is 12.345. If a floating-point literal ends in an F or f, it is a Float;
otherwise it is a Double. Optionally, a Double floating-point literal can end in D or d. Some examples
of Float literals are:
scala&gt; val little = 1.2345F
little: Float = 1.2345
scala&gt; val littleBigger = 3e5f
littleBigger: Float = 300000.0
That last value expressed as a Double could take these (and other) forms:
scala&gt; val anotherDouble = 3e5
anotherDouble: Double = 300000.0
scala&gt; val yetAnother = 3e5D
yetAnother: Double = 300000.0
Character literals
Character literals are composed of any Unicode character between single quotes, such as:
scala&gt; val a = <em>A</em>
a: Char = AIn addition to providing an explicit character between the single quotes, you can identify a character
using its Unicode code point. To do so, write \u followed by four hex digits with the code point, like
this:
scala&gt; val d = <em>\u0041</em>
d: Char = A
scala&gt; val f = <em>\u0044</em>
f: Char = D
In fact, such Unicode characters can appear anywhere in a Scala program. For instance you could also
write an identifier like this:
scala&gt; val B\u0041\u0044 = 1
BAD: Int = 1
This identifier is treated as identical to BAD, the result of expanding the two Unicode characters in the
code above. In general, it is a bad idea to name identifiers like this because it is hard to read. Rather,
this syntax is intended to allow Scala source files that include non-ASCII Unicode characters to be
represented in ASCII.
Finally, there are also a few character literals represented by special escape sequences, shown in Table
5.2. For example:
scala&gt; val backslash = <em>\\</em>
backslash: Char = \
Table 5.2 - Special character literal escape sequences
Literal
\n
\b
\t
\f
\r
\"
\'
\\
Meaning
line feed (\u000A)
backspace (\u0008)
tab (\u0009)
form feed (\u000C)
carriage return (\u000D)
double quote (\u0022)
single quote (\u0027)
backslash (\u005C)
String literals
A string literal is composed of characters surrounded by double quotes:
scala&gt; val hello = "hello"
hello: String = hello
The syntax of the characters within the quotes is the same as with character literals. For example:
scala&gt; val escapes = "\\\"'"
escapes: String = \"<em>Because this syntax is awkward for strings that contain a lot of escape sequences or strings that span
multiple lines, Scala includes a special syntax for raw strings. You start and end a raw string with three
double quotation marks in a row ("""). The interior of a raw string may contain any characters
whatsoever, including newlines, quotation marks, and special characters, except of course three quotes
in a row. For example, the following program prints out a message using a raw string:
println("""Welcome to Ultamix 3000.
Type "HELP" for help.""")
However, running this code does not produce quite what is desired:
Welcome to Ultamix 3000.
Type "HELP" for help.
The issue is that the leading spaces before the second line are included in the string! To help with this
common situation, you can call stripMargin on strings. To use this method, put a pipe character (|) at
the front of each line, and then call stripMargin on the whole string:
println("""|Welcome to Ultamix 3000.
|Type "HELP" for help.""".stripMargin)
Now the code behaves as desired:
Welcome to Ultamix 3000.
Type "HELP" for help.
Symbol literals
A symbol literal is written 'ident, where ident can be any alphanumeric identifier. Such literals are
mapped to instances of the predefined class scala.Symbol. Specifically, the literal&#8217;cymbal will be
expanded by the compiler to a factory method invocation: Symbol("cymbal"). Symbol literals are
typically used in situations where you would use just an identifier in a dynamically typed language. For
instance, you might want to define a method that updates a record in a database:
scala&gt; def updateRecordByName(r: Symbol, value: Any) = {

}
updateRecordByName: (Symbol,Any)Unit
The method takes as parameters a symbol indicating the name of a record field and a value with which
the field should be updated in the record. In a dynamically typed language, you could invoke this
operation passing an undeclared field identifier to the method, but in Scala this would not compile:
scala&gt; updateRecordByName(favoriteAlbum, "OK Computer")
&lt;console&gt;:6: error: not found: value favoriteAlbum
updateRecordByName(favoriteAlbum, "OK Computer")
<sup>
Instead, and almost as concisely, you can pass a symbol literal:
scala&gt; updateRecordByName('favoriteAlbum, "OK Computer")There is not much you can do with a symbol, except find out its name:
scala&gt; val s = 'aSymbol
s: Symbol = 'aSymbol
scala&gt; val nm = s.name
nm: String = aSymbol
Another thing that&#8217;s noteworthy is that symbols are interned. If you write the same symbol literal twice,
both expressions will refer to the exact same Symbol object.
Boolean literals
The Boolean type has two literals, true and false:
scala&gt; val bool = true
bool: Boolean = true
scala&gt; val fool = false
fool: Boolean = false
That&#8217;s all there is to it. You are now literally an expert in Scala.<span class="footnote"><br />[figuratively speaking]<br /></span>
5.3 STRING INTERPOLATION
Scala includes a flexible mechanism for string interpolation, which allows you to embed expressions
within string literals. Its most common use case is to provide a concise and readable alternative to
string concatenation. Here&#8217;s an example:
val name = "reader"
println(s"Hello, $name!")
The expression, s"Hello, $name!" is a processed string literal. Because the letter s immediately
precedes the open quote, Scala will use the s string interpolator to process the literal. The sinterpolator
will evaluate each embedded expression, invoke toString on each result, and replace the embedded
expressions in the literal with those results. Thus s"Hello, $name!" yields"Hello, reader!", the same
result as "Hello, " + name + "!".
You can place any expression after a dollar sign ($) in a processed string literal. For single-variable
expressions, you can often just place the variable name after the dollar sign. Scala will interpret all
characters up to the first non-identifier character as the expression. If the expression includes non-
identifier characters, you must place it in curly braces, with the open curly brace immediately following
the dollar sign. Here&#8217;s an example:
scala&gt; s"The answer is ${6 * 7}."
res0: String = The answer is 42.
Scala provides two other string interpolators by default: raw and f. The raw string interpolator behaves
like s, except it does not recognize character literal escape sequences (such as those shown in Table
5.2). For example, the following statement prints four backslashes, not two:println(raw"No\\\\escape!") // prints: No\\\\escape!
The f string interpolator allows you to attach printf-style formatting instructions to embedded
expressions. You place the instructions after the expression, starting with a percent sign (%), using the
syntax specified by java.util.Formatter. For example, here&#8217;s how you might format pi:
scala&gt; f"${math.Pi}%.5f"
res1: String = 3.14159
If you provide no formatting instructions for an embedded expression, the f string interpolator will
default to %s, which means the toString value will be substituted, just like thes string interpolator. For
example:
scala&gt; val pi = "Pi"
pi: String = Pi
scala&gt; f"$pi is approximately ${math.Pi}%.8f."
res2: String = Pi is approximately 3.14159265.
In Scala, string interpolation is implemented by rewriting code at compile time. The compiler will treat
any expression consisting of an identifier followed immediately by the open double quote of a string
literal as a string interpolator expression. The s, f, and raw string interpolators are implemented via this
general mechanism. Libraries and users can define other string interpolators for other purposes.
5.4 OPERATORS ARE METHODS
Scala provides a rich set of operators for its basic types. As mentioned in previous chapters, these
operators are actually just a nice syntax for ordinary method calls. For example, 1 + 2really means the
same thing as 1.<code>(2). In other words, class Int contains a method named +that takes an Int and returns
an Int result. This + method is invoked when you add two Ints:
scala&gt; val sum = 1 + 2
sum: Int = 3

To prove this to yourself, you can write the expression explicitly as a method invocation:
scala&gt; val sumMore = 1.</code>(2)
sumMore: Int = 3
In fact, Int contains several overloaded + methods that take different parameter types.<span class="footnote"><br />[3]<br /></span> For
example, Int has another method, also named <code>, that takes and returns a Long. If you add a Longto
an Int, this alternate + method will be invoked, as in:
scala&gt; val longSum = 1 + 2L
longSum: Long = 3

The + symbol is an operator—an infix operator to be specific. Operator notation is not limited to
methods like + that look like operators in other languages. You can use any method in operator
notation. For example, class String has a method, indexOf, that takes one Charparameter.The indexOf method searches the string for the first occurrence of the specified character and returns
its index or -1 if it doesn&#8217;t find the character. You can use indexOf as an operator, like this:
scala&gt; val s = "Hello, world!"
s: String = Hello, world!
scala&gt; s indexOf 'o</em>
res0: Int = 4

In addition, String offers an overloaded indexOf method that takes two parameters, the character for
which to search and an index at which to start. (The other indexOf method, shown previously, starts at
index zero, the beginning of the String.) Even though this indexOfmethod takes two arguments, you
can use it in operator notation. But whenever you call a method that takes multiple arguments using
operator notation, you have to place those arguments in parentheses. For example, here&#8217;s how you use
this other indexOf form as an operator (continuing from the previous example):
scala&gt; s indexOf (<em>o</em>, 5) // Scala invokes s.indexOf(<em>o</em>, 5)
res1: Int = 8
ANY METHOD CAN BE AN OPERATOR
In Scala operators are not special language syntax; any method can be an operator. What makes a
method an operator is how you use it. When you write "s.indexOf(<em>o</em>)",indexOf is not an operator. But
when you write "s indexOf <em>o</em>", indexOf is an operator, because you&#8217;re using it in operator notation.
So far, you&#8217;ve seen examples of infix operator notation, which means the method to invoke sits between
the object and the parameter (or parameters) you wish to pass to the method, as in "7 + 2". Scala also
has two other operator notations: prefix and postfix. In prefix notation, you put the method name before
the object on which you are invoking the method (for example, the &#8216;-&#8217; in -7). In postfix notation, you
put the method after the object (for example, the "toLong" in "7 toLong").
In contrast to the infix operator notation—in which operators take two operands, one to the left and the
other to the right—prefix and postfix operators are unary: they take just one operand. In prefix
notation, the operand is to the right of the operator. Some examples of prefix operators are -2.0, !found,
and <sub>0xFF. As with the infix operators, these prefix operators are a shorthand way of invoking
methods. In this case, however, the name of the method has "unary_" prepended to the operator
character. For instance, Scala will transform the expression -2.0 into the method invocation
"(2.0).unary_-". You can demonstrate this to yourself by typing the method call both via operator
notation and explicitly:
scala&gt; -2.0
res2: Double = -2.0

scala&gt; (2.0).unary_-
res3: Double = -2.0
The only identifiers that can be used as prefix operators are +, -, !, and </sub>. Thus, if you define a method
named unary_!, you could invoke that method on a value or variable of the appropriate type usingprefix operator notation, such as !p. But if you define a method namedunary_*, you wouldn&#8217;t be able to
use prefix operator notation because * isn&#8217;t one of the four identifiers that can be used as prefix
operators. You could invoke the method normally, as inp.unary_*, but if you attempted to invoke it
via <strong>p, Scala will parse it as if you&#8217;d written *.p, which is probably not what you had in mind!<span class="footnote"><br />[All is not necessarily lost, however. There is an extremely slight chance your program with the *p might compile as C<code>.]<br /></span>
Postfix operators are methods that take no arguments, when they are invoked without a dot or
parentheses. In Scala, you can leave off empty parentheses on method calls. The convention is that you
include parentheses if the method has side effects, such as println(), but you can leave them off if the
method has no side effects, such as toLowerCase invoked on aString:
scala&gt; val s = "Hello, world!"
s: String = Hello, world!
scala&gt; s.toLowerCase
res4: String = hello, world!
In this latter case of a method that requires no arguments, you can alternatively leave off the dot and
use postfix operator notation:
scala&gt; s toLowerCase
res5: String = hello, world!
In this case, toLowerCase is used as a postfix operator on the operand s.
Therefore, to see what operators you can use with Scala&#8217;s basic types, all you really need to do is look
at the methods declared in the type&#8217;s classes in the Scala API documentation. Given that this is a Scala
tutorial, however, we&#8217;ll give you a quick tour of most of these methods in the next few sections.
FAST TRACK FOR JAVA PROGRAMMERS
Many aspects of Scala described in the remainder of this chapter are the same as in Java. If you&#8217;re a
Java guru in a rush, you can safely skip to Section 5.8 here, which describes how Scala differs from
Java in the area of object equality.
5.5 ARITHMETIC OPERATIONS
You can invoke arithmetic methods via infix operator notation for addition (</code>), subtraction (-),
multiplication (</strong>), division (/), and remainder (%) on any numeric type. Here are some examples:
scala&gt; 1.2 + 2.3
res6: Double = 3.5
scala&gt; 3 - 1
res7: Int = 2
scala&gt; <em>b</em> - <em>a</em>
res8: Int = 1
scala&gt; 2L * 3L
res9: Long = 6
scala&gt; 11 / 4res10: Int = 2
scala&gt; 11 % 4
res11: Int = 3
scala&gt; 11.0f / 4.0f
res12: Float = 2.75
scala&gt; 11.0 % 4.0
res13: Double = 3.0
When both the left and right operands are integral types (Int, Long, Byte, Short, or Char), the /operator
will tell you the whole number portion of the quotient, excluding any remainder. The % operator
indicates the remainder of an implied integer division.
The floating-point remainder you get with % is not the one defined by the IEEE 754 standard. The
IEEE 754 remainder uses rounding division, not truncating division, in calculating the remainder, so it
is quite different from the integer remainder operation. If you really want an IEEE 754 remainder, you
can call IEEEremainder on scala.math, as in:
scala&gt; math.IEEEremainder(11.0, 4.0)
res14: Double = -1.0
The numeric types also offer unary prefix operators + (method unary_+) and - (method unary_-), which
allow you to indicate whether a literal number is positive or negative, as in -3 or +4.0. If you don&#8217;t
specify a unary + or -, a literal number is interpreted as positive. Unary + exists solely for symmetry
with unary -, but has no effect. The unary - can also be used to negate a variable. Here are some
examples:
scala&gt; val neg = 1 + -3
neg: Int = -2
scala&gt; val y = +3
y: Int = 3
scala&gt; -neg
res15: Int = 2
5.6 RELATIONAL AND LOGICAL OPERATIONS
You can compare numeric types with relational methods greater than (&gt;), less than (&lt;), greater than or
equal to (&gt;=), and less than or equal to (&#8656;), which yield a Boolean result. In addition, you can use the
unary &#8216;!&#8217; operator (the unary_! method) to invert a Boolean value.Here are a few examples:
scala&gt; 1 &gt; 2
res16: Boolean = false
scala&gt; 1 &lt; 2
res17: Boolean = true
scala&gt; 1.0 &#8656; 1.0
res18: Boolean = truescala&gt; 3.5f &gt;= 3.6f
res19: Boolean = false
scala&gt; <em>a</em> &gt;= <em>A</em>
res20: Boolean = true
scala&gt; val untrue = !true
untrue: Boolean = false
Logical methods, logical-and (&amp;&amp; and &amp;) and logical-or (|| and |), take Boolean operands in infix
notation and yield a Boolean result. For example:
scala&gt; val toBe = true
toBe: Boolean = true
scala&gt; val question = toBe || !toBe
question: Boolean = true
scala&gt; val paradox = toBe &amp;&amp; !toBe
paradox: Boolean = false
The &amp;&amp; and || operations short-circuit as in Java: expressions built from these operators are only
evaluated as far as needed to determine the result. In other words, the right-hand side
of&amp;&amp; and || expressions won&#8217;t be evaluated if the left-hand side determines the result. For example, if
the left-hand side of a &amp;&amp; expression evaluates to false, the result of the expression will definitely
be false, so the right-hand side is not evaluated. Likewise, if the left-hand side of a || expression
evaluates to true, the result of the expression will definitely be true, so the right-hand side is not
evaluated.
scala&gt; def salt() = { println("salt"); false }
salt: ()Boolean
scala&gt; def pepper() = { println("pepper"); true }
pepper: ()Boolean
scala&gt; pepper() &amp;&amp; salt()
pepper
salt
res21: Boolean = false
scala&gt; salt() &amp;&amp; pepper()
salt
res22: Boolean = false
In the first expression, pepper and salt are invoked, but in the second, only salt is invoked.
Given salt returns false, there&#8217;s no need to call pepper.
If you want to evaluate the right hand side no matter what, use &amp; and | instead. The &amp; method performs
a logical-and operation, and | a logical-or, but don&#8217;t short-ciruit like &amp;&amp; and ||. Here&#8217;s an example:
scala&gt; salt() &amp; pepper()
salt
pepper
res23: Boolean = falseNote
You may be wondering how short-circuiting can work given operators are just methods. Normally, all
arguments are evaluated before entering a method, so how can a method avoid evaluating its second
argument? The answer is that all Scala methods have a facility for delaying the evaluation of their
arguments, or even declining to evaluate them at all. The facility is called by-name parameters and is
discussed in Section 9.5.
5.7 BITWISE OPERATIONS
Scala enables you to perform operations on individual bits of integer types with several bitwise
methods. The bitwise methods are: bitwise-and (&amp;), bitwise-or (|), and bitwise-xor (</sup>).<span class="footnote"><br />[The bitwise-xor method performs an exclusive or on its operands. Identical bits yield a 0. Different bits yield a 1. Thus 0011 <sup> 0101 yields 0110.]<br /></span> The unary
bitwise complement operator (<sub>, the method unary_</sub>) inverts each bit in its operand. For example:
scala&gt; 1 &amp; 2
res24: Int = 0
scala&gt; 1 | 2
res25: Int = 3
scala&gt; 1 </sup> 3
res26: Int = 2
scala&gt; <sub>1
res27: Int = -2
The first expression, 1 &amp; 2, bitwise-ands each bit in 1 (0001) and 2 (0010), which yields 0 (0000). The
second expression, 1 | 2, bitwise-ors each bit in the same operands, yielding 3 (0011). The third
expression, 1 <sup> 3, bitwise-xors each bit in 1 (0001) and 3 (0011), yielding 2 (0010). The final
expression, </sub>1, inverts each bit in 1 (0001), yielding -2, which in binary looks like
11111111111111111111111111111110.
Scala integer types also offer three shift methods: shift left (&lt;&lt;), shift right (&gt;&gt;), and unsigned shift
right (&gt;&gt;&gt;). The shift methods, when used in infix operator notation, shift the integer value on the left
of the operator by the amount specified by the integer value on the right. Shift left and unsigned shift
right fill with zeroes as they shift. Shift right fills with the highest bit (the sign bit) of the left-hand
value as it shifts. Here are some examples:
scala&gt; -1 &gt;&gt; 31
res28: Int = -1
scala&gt; -1 &gt;&gt;&gt; 31
res29: Int = 1
scala&gt; 1 &lt;&lt; 2
res30: Int = 4
-1 in binary is 11111111111111111111111111111111. In the first example, -1 &gt;&gt; 31, -1 is shifted to the
right 31 bit positions. Since an Int consists of 32 bits, this operation effectively moves the leftmost bit
over until it becomes the rightmost bit.<span class="footnote"><br />[The leftmost bit in an integer type is the sign bit. If the leftmost bit is 1, the number is negative. If 0, the number is positive.]<br /></span> Since the &gt;&gt; method fills with ones as it shifts right, becausethe leftmost bit of -1 is 1, the result is identical to the original left operand, 32 one bits, or -1. In the
second example, -1 &gt;&gt;&gt; 31, the leftmost bit is again shifted right until it is in the rightmost position,
but this time filling with zeroes along the way. Thus the result this time is binary
00000000000000000000000000000001, or 1. In the final example, 1 &lt;&lt; 2, the left operand, 1, is
shifted left two positions (filling in with zeroes), resulting in binary
00000000000000000000000000000100, or 4.
5.8 OBJECT EQUALITY
If you want to compare two objects for equality, you can use either == or its inverse !=. Here are a few
simple examples:
scala&gt; 1 == 2
res31: Boolean = false
scala&gt; 1 != 2
res32: Boolean = true
scala&gt; 2 == 2
res33: Boolean = true
These operations actually apply to all objects, not just basic types. For example, you can use== to
compare lists:
scala&gt; List(1, 2, 3) == List(1, 2, 3)
res34: Boolean = true
scala&gt; List(1, 2, 3) == List(4, 5, 6)
res35: Boolean = false
Going further, you can compare two objects that have different types:
scala&gt; 1 == 1.0
res36: Boolean = true
scala&gt; List(1, 2, 3) == "hello"
res37: Boolean = false
You can even compare against null, or against things that might be null. No exception will be thrown:
scala&gt; List(1, 2, 3) == null
res38: Boolean = false
scala&gt; null == List(1, 2, 3)
res39: Boolean = false
As you see, == has been carefully crafted so that you get just the equality comparison you want in most
cases. This is accomplished with a very simple rule: First check the left side for null. If it is not null,
call the equals method. Since equals is a method, the precise comparison you get depends on the type
of the left-hand argument. Since there is an automatic null check, you do not have to do the check
yourself.<span class="footnote"><br />[The automatic check does not look at the right-hand side, but any reasonable equalsmethod should return false if its argument is null.]<br /></span>This kind of comparison will yield true on different objects, so long as their contents are the same and
their equals method is written to be based on contents. For example, here is a comparison between two
strings that happen to have the same five letters in them:
scala&gt; ("he" + "llo") == "hello"
res40: Boolean = true
HOW SCALA&#8217;S == DIFFERS FROM JAVA&#8217;S
In Java, you can use == to compare both primitive and reference types. On primitive types,
Java&#8217;s == compares value equality, as in Scala. On reference types, however,
Java&#8217;s == compares reference equality, which means the two variables point to the same object on the
JVM&#8217;s heap. Scala provides a facility for comparing reference equality, as well, under the name eq.
However, eq and its opposite, ne, only apply to objects that directly map to Java objects. The full
details about eq and ne are given in Sections 11.1and 11.2. Also, see Chapter 30 on how to write a
good equals method.
5.9 OPERATOR PRECEDENCE AND ASSOCIATIVITY
Operator precedence determines which parts of an expression are evaluated before the other parts. For
example, the expression 2 + 2 * 7 evaluates to 16, not 28, because the * operator has a higher
precedence than the + operator. Thus the multiplication part of the expression is evaluated before the
addition part. You can of course use parentheses in expressions to clarify evaluation order or to override
precedence. For example, if you really wanted the result of the expression above to be 28, you could
write the expression like this:
(2 + 2) * 7
Given that Scala doesn&#8217;t have operators, per se, just a way to use methods in operator notation, you may
be wondering how operator precedence works. Scala decides precedence based on the first character of
the methods used in operator notation (there&#8217;s one exception to this rule, which will be discussed in the
following pages). If the method name starts with a*, for example, it will have a higher precedence than
a method that starts with a +. Thus2 + 2 * 7 will be evaluated as 2 + (2 * 7). Similarly, a </code>
+ b <strong>*</strong> c (in which a, b, and c are variables, and  and *** are methods) will be evaluated a ++
+ (b *** c), because the *** method has a higher precedence than the  method.
Table 5.3 - Operator precedence
(all other special characters)
* / %
+ -
:
= !
&lt; &gt;
&amp;</sup>
|
(all letters)
(all assignment operators)
Table 5.3 shows the precedence given to the first character of a method in decreasing order of
precedence, with characters on the same line having the same precedence. The higher a character is in
this table, the higher the precedence of methods that start with that character. Here&#8217;s an example that
illustrates the influence of precedence:
scala&gt; 2 &lt;&lt; 2 + 2
res41: Int = 32
The &lt;&lt; method starts with the character &lt;, which appears lower in Table 5.3 than the character +,
which is the first and only character of the + method. Thus &lt;&lt; will have lower precedence than +, and
the expression will be evaluated by first invoking the + method, then the &lt;&lt; method, as
in 2 &lt;&lt; (2 + 2). 2 + 2 is 4, by our math, and 2 &lt;&lt; 4 yields 32. If you swap the operators, you&#8217;ll get a
different result:
scala&gt; 2 + 2 &lt;&lt; 2
res42: Int = 16
Since the first characters are the same as in the previous example, the methods will be invoked in the
same order. First the + method will be invoked, then the &lt;&lt; method. So 2 + 2 will again yield 4,
and 4 &lt;&lt; 2 is 16.
The one exception to the precedence rule, alluded to earlier, concerns assignment operators, which end
in an equals character. If an operator ends in an equals character (=), and the operator is not one of the
comparison operators &#8656;, &gt;=, ==, or !=, then the precedence of the operator is the same as that of
simple assignment (=). That is, it is lower than the precedence of any other operator. For instance:
x <strong>= y + 1
means the same as:
x *= (y + 1)
because *= is classified as an assignment operator whose precedence is lower than +, even though the
operator&#8217;s first character is *, which would suggest a precedence higher than +.
When multiple operators of the same precedence appear side by side in an expression,
theassociativity of the operators determines the way operators are grouped. The associativity of an
operator in Scala is determined by its last character. As mentioned here of Chapter 3, any method that
ends in a &#8216;:&#8217; character is invoked on its right operand, passing in the left operand. Methods that end in
any other character are the other way around: They are invoked on their left operand, passing in the
right operand. So a * b yields a.</strong>(b), but a ::: byields b.:::(a).No matter what associativity an operator has, however, its operands are always evaluated left to right.
So if a is an expression that is not just a simple reference to an immutable value, thena ::: b is more
precisely treated as the following block:
{ val x = a; b.:::(x) }
In this block a is still evaluated before b, and then the result of this evaluation is passed as an operand
to b&#8217;s ::: method.
This associativity rule also plays a role when multiple operators of the same precedence appear side by
side. If the methods end in &#8216;:&#8217;, they are grouped right to left; otherwise, they are grouped left to right.
For example, a ::: b ::: c is treated as a ::: (b ::: c). But a * b * c, by contrast, is treated as (a * b) * c.
Operator precedence is part of the Scala language. You needn&#8217;t be afraid to use it. Nevertheless, it is
good style to use parentheses to clarify what operators are operating upon what expressions. Perhaps
the only precedence you can truly count on other programmers knowing without looking up is that
multiplicative operators, <strong>, /, and %, have a higher precedence than the additive ones + and -. Thus
even if a + b &lt;&lt; c yields the result you want without parentheses, the extra clarity you get by
writing (a + b) &lt;&lt; c may reduce the frequency with which your peers utter your name in operator
notation, for example, by shouting in disgust, "bills !</strong>&amp;<sup>%<sub> code!".<span class="footnote"><br />[By now you should be able to figure out that given this code, the Scala compiler would invoke (bills.!*&amp;</sup>%</sub>(code)).!().]<br /></span>
5.10 RICH WRAPPERS
You can invoke many more methods on Scala&#8217;s basic types than were described in the previous
sections. A few examples are shown in Table 5.4. These methods are available viaimplicit conversions,
a technique that will be described in detail in Chapter 21. All you need to know for now is that for each
basic type described in this chapter, there is also a "rich wrapper" that provides several additional
methods. To see all the available methods on the basic types, therefore, you should look at the API
documentation on the rich wrapper for each basic type. Those classes are listed in Table 5.5.
Table 5.4 - Some rich operations
Code
0 max 5
0 min 5
-2.7 abs
-2.7 round
1.5 isInfinity
(1.0 / 0) isInfinity
4 to 6
"bob" capitalize
"robert" drop 2
Result
5
0
2.7
-3L
false
true
Range(4, 5, 6)
"Bob"
"bert"
Table 5.5 - Rich wrapper classes
Basic type Rich wrapper
Byte
scala.runtime.RichByteShort
Int
Long
Char
Float
Double
Boolean
String
scala.runtime.RichShort
scala.runtime.RichInt
scala.runtime.RichLong
scala.runtime.RichChar
scala.runtime.RichFloat
scala.runtime.RichDouble
scala.runtime.RichBoolean
scala.collection.immutable.StringOps
5.11 CONCLUSION
The main take-aways from this chapter are that operators in Scala are method calls, and that implicit
conversions to rich variants exist for Scala&#8217;s basic types that add even more useful methods. In the next
chapter, we&#8217;ll show you what it means to design objects in a functional style that gives new
implementations of some of the operators that you have seen in this chapter.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-28 03:46:42 EET
</div>
</div>
</body>
</html>
