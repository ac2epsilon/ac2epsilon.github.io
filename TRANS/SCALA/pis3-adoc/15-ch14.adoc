include::headers.adoc[]

Глава 14
--------

Твердження та тести
===================

Твердження та тести є два важливі шляхи, яким ви можете перевірити, що програмне забезпечення, яке ви пишете, поводиться так, як ви очікуєте. В цій главі ми покажемо декілька опцій, що ви маєте в Scala для написання та виконання тестів.

14.1 Твердження
---------------
Твердження в Scala написані як виклики попередньо визначеного метода `assert`.footnote:[Метод `assert` визначений в об'єкті синглтоні `Predef`, чиї члени автоматично імпортуються в кожний джерельний файл Scala.] Вираз `assert(умова)` закидає `AssertionError`, якщо умова не дотримується. Існує також версія `assert` з двома аргументами: вираз `assert(умова, пояснення)` перевіряє умову, та, якщо воно не дотримується, закидає `AssertionError`, що містить надане пояснення. Тип пояснення `Any`, так що ви можете передати любий об'єкт в якості пояснення. Метод `assert` буде викликати `toString` не ньому, щоб отримати рядок пояснення, що покладається в `AssertionError`. Наприклад, в методі з назвою `above` класа `Element`, показаному в Лістингу 10.13, ви можете розмістити `assert` після виклику до `widen`, щоб переконатись, що поширені елементи мають однакову ширину. Це показано в Лістингу 14.1.
[source,scala]
----
def above(that: Element): Element = {
  val this1 = this widen that.width
  val that1 = that widen this.width
  assert(this1.width == that1.width)
  elem(this1.contents ++ that1.contents)
}
----
Лістинг 14.1 - Використання твердження.

Інший шлях, як ви можете обрати зробити це, є перевірити ширини в кінці метода `widen`, прямо перед поверненням значення. Ви можете досягти цього через зберігання результату як `val`, виконуя твердження для результату, потім вказуючи `val` останнім, так що результат буде повернений, якщо твердження справджується. Однак ви можете зробити це більш стисло, за допомогою зручного метода в `Predef` на ім'я `ensuring`, як показано в Лістингу 14.2.

Метод `ensuring` може бути використаний з любим типом результату завдяки неявному перетворенню. Хоча це виглядає в цьому коді так, якби ми викликали `ensuring` на результаті `widen`, що має тип `Element`, насправді викликаючи `ensuring` на типі, до якого `Element` неявно конвертоване. Метод `ensuring` приймає один аргумент, функцію предикати, що приймає тип результату та повертає `Boolean`, та передає результат в предикат. Якщо предикат повертає `true`, `ensuring` буде повертати результат; інакше  `ensuring` буде закидати `AssertionError`.

В цьому прикладі предикат є `w <= _.width`. Підкреслення є заповнювачем для одного аргумента, переданого до предикату, результату `Element` метода `widen`. Якщо ширина, передана як `w` до `widen` меньше або рівне до ширини результуючого `Element`, предикат буде давати результат `true`, та `ensuring` буде давати результат `Element`, на якому він був викликаний. Оскільки це останній вираз метода `widen`, сам `widen` потім буде мати результат `Element`.
[source,scala]
----
private def widen(w: Int): Element =
  if (w <= width)
    this
  else {
    val left = elem(' ', (w - width) / 2, height)
    var right = elem(' ', w - width - left.width, height)
    left beside this beside right
  } ensuring (w <= _.width)
----
Лістинг 14.2 - Використання `ensuring` для твердження щодо результата функції.

Твердження можуть бути вімкнені та вимкнені з використанням флагів командного рядка JVM, `-ea` та `-da`. Коли ввімкнено, кожне твердження служить як малий тест, що використовує дійсні дані, що використовуються при виконанні програми. В залишку цієї глави ми сфокусуємось на написанні зовнішніх тестів, що провадять свої власні тестові дані, та виконуються незалежно від застосування.

14.2 Тестування в Scala
-----------------------
Ви маєте багато опцій для тестування в Scala, від визнаних Java інструментів, таких як JUnit та TestNG, до інструментів, написаних на Scala, таких як ScalaTest, specs2, та ScalaCheck. В залишку цієї глави ми надамо вам швидкий тур по цім інструментам. Ми почнемо з ScalaTest.

ScalaTest є найбільш гнучким фреймворком тестування Scala: він може бути налаштований для вирішення різних проблем. Гнучкість ScalaTest означає, що команди можуть використовувати такі стилі тестування, що найкраще підходять до їх потреб. Наприклад, для команд, знайомих з JUnit, стиль FunSuite буде відчуватись комфортабельним в знайомим. Лістинг 14.3 показує приклад.
[source,scala]
----
import org.scalatest.FunSuite
import Element.elem

class ElementSuite extends FunSuite {

  test("elem result should have passed width") {
    val ele = elem('x', 2, 3)
    assert(ele.width == 2)
  }
}
----
Лістинг 14.3 - Writing tests with FunSuite.

Центральна концепція в ScalaTest є сюїта, колекція тестів. Тестом може бути будь-що з ім'ям, що може розпочатись, та або мати вдачу, або схибити, бути в стані очікування або скасованим. Трейт `Suite` є центральною одиницею композиції в ScalaTest. Сюїта декларує методи "життєвого цикла", що визначають шлях по замовчанню для виконання тесту, що може бути перекрите для налаштування того, як тести можуть бути написані або виконані.

ScalaTest пропонує трейти стилів, що розширюють `Suite`, та перекривають методи життєвого циклу, щоб підтримувати різні стилі тестування. Він також провадить міксіни трейтів, що що перекривають методи життєвого циклу, щоб адресувати окремі потреби тестування. Ви визначаєте тестові класи через композицію стилів `Suite` та міксін трейтів, та визначаєте тестові сюїти, через композицію примірників `Suite`.

`FunSuite`, що розширюється тестовим класом, показаним на Лістингу 14.3, є прикладом тестового стилю. `Fun` в `FunSuite` означає функцію; `test` є методом, визначеним в  `FunSuite`, що викликається первинним конструктором `ElementSuite`. Ви вказуєте ім'я тесту як рядок в дужках, та сам код тестування між фігурними дужками. Тестовий код є функцією, переданою як параметр за-ім'ям до `test`, що реєструє її для подальшого виклику.

ScalaTest інтегрований в загальні інструменти побудови (такі як sbt та Maven), та IDE (такі як IntelliJ IDEA та Eclipse). Також ви можете виконати `Suite` напряму, через застосування ScalaTest Runner, або з інтерпретатора Scala, просто викликавши на ньому `execute`. Ось приклад:
[source,scala]
----
scala> (new ElementSuite).execute()
ElementSuite:
- elem result should have passed width
----
Всі стилі ScalaTest, включаючи `FunSuite`, розроблені для заохочення написання сфокусованих тестів з описовими назвами. На додаток, всі стилі генерують специфікація-подібний вихід, що може спростити комунікацію між зацікавленими сторонами. Стиль, що ви обираєте, диктує тільки те, як будуть виглядати декларації вашого тесту. Все інше в ScalaTest робить узгоджено в однаковий спосіб, не важливо, який стиль ви оберете.footnote:[Більше деталей щодо ScalaTest досутпні на http://www.scalatest.org/.[3\]]

14.3 Інформативні звіти про збої
--------------------------------
Тест в Лістингу 14.3 намагається створити елемент ширини 2, та стверджує, що ширина отриманого елементу, відповідно, 2. Коли твердження схибить, звіт про збій повинен включати ім'я файлу та номер рядка винного твердження, а також інформативне повідомлення про помилку:
[source,scala]
----
scala> val width = 3
width: Int = 3

scala> assert(width == 2)
org.scalatest.exceptions.TestFailedException:
    3 did not equal 2
----
Щоб запровадити описові повідомлення про помилки тверджень, ScalaTest аналізує вирази, передані в кожному виклику `assert` під час компіляції. Якщо ви бажаєте бачити навіть більш детальну інформацію щодо збоїв тверджень, ви можете використовувати ScalaTest `DiagrammedAssertions`, чиї повідомлення про помилки відображають діаграму виразу, передану до `assert`:
[source,scala]
----
scala> assert(List(1, 2, 3).contains(4))
org.scalatest.exceptions.TestFailedException:

  assert(List(1, 2, 3).contains(4))
         |    |  |  |  |        | 
         |    1  2  3  false    4
         List(1, 2, 3)
----
В ScalaTest методи `assert` не роблять різницю між дійсним та очікуваним результатом в повідомленнях помилок. Вони просто вказують, що лівий операнд не дорівнює правому операнду, або показує значення на діаграмі. Якщо ви бажаєте наголосити на різниці між дійсним та очікуваним, ви можете альтернативно використовувати метод ScalaTest  `assertResult`, ось так:
[source,scala]
----
assertResult(2) {
   ele.width
}
----
Маючи такий вираз, ви вказуєте, що ви очікуєте, що код між фігурними дужками дає результат `2`. Коли код в дужках дасть результат `3`, ви побачите повідомлення "Expected 2, but got 3" в звіті про збій тесту.

Якщо ви бажаєте перевірити, що метод закидає очікувані виключення, ви можете використовувати метод ScalaTest `assertThrows`, ось так:
[source,scala]
----
assertThrows[IllegalArgumentException] {
  elem('x', -2, 3)
}
----
Якщо код між фігурними дужками закидає інше виключення, ніж очікується, або не закидає виключення взагалі, `assertThrows` терміново переривається з `TestFailedException`. Ви отримаєте корисне повідомлення про помилку в звіті, таке як:
----
Expected IllegalArgumentException to be thrown,
  but NegativeArraySizeException was thrown.
----
З іншого боку, якщо код завершується терміново з примірником переданого класу виключення, `assertThrows` буде повертатись звичайно. Якщо ви бажаєте проінспектувати далі очікуване виключення, ви можете використовувати `intercept` замість `assertThrows`. Метод `intercept` робить так саме, як `asassertThrows`, за винятком того, що коли очікуване виключення спрацьовує, `intercept` повертає його:
[source,scala]
----
val caught =
  intercept[ArithmeticException] {
    1 / 0
  }

assert(caught.getMessage == "/ by zero")
----
Коротше, твердження ScalaTest тяжко роблять для провадження корисних повідомлень, що допомагатимуть вам діагностувати та поладнати проблеми в вашому коді.

14.4 Тести як специфікації
--------------------------
В стилі тестування _поведінко-рушійної розробки_ (behavior-driven development, BDD), наголос робиться на написанні зрозумілих для людей специфікацій очікуваної поведінки коду, та додавання супроводжуючих тестів, які перевіряють код на задану поведінку. ScalaTest включає декілька трейтів, що спрощує цей стиль тестування. Приклад використання такого трейту, `FlatSpec`, показаний в Лістингу 14.4.
[source,scala]
----
import org.scalatest.FlatSpec
import org.scalatest.Matchers
import Element.elem

class ElementSpec extends FlatSpec with Matchers {
  "A UniformElement" should
       "have a width equal to the passed value" in {
    val ele = elem('x', 2, 3)
    ele.width should be (2)
  }
    
  it should "have a height equal to the passed value" in {
    val ele = elem('x', 2, 3)
    ele.height should be (3)
  }

  it should "throw an IAE if passed a negative width" in {
    an [IllegalArgumentException] should be thrownBy {
      elem('x', -2, 3)
    }
  }
}
----
Лістинг 14.4 - Специфікація та тестування поведінки за допомогою ScalaTest `FlatSpec`.

В `FlatSpec` ви пишете тести як твердження специфікації. Ви починаєте писати з імені для субпроекту під тестом як рядок ("A UniformElement" в Лістингу 14.4), потім `should` (або `must` або `can`), потім рядок, що вказує частину поведінки, яка очікується від предмета, потім `in`. В фігурних дужках, що ідуть далі, ви пишете код, що перевіряє вказану поведінку. В наступних реченнях ви можете писати `it` для посилання до найбільш останнього взятого предмета. Коли виконується `FlatSpec`, він буде проганяти кожне речення специфікації як тест ScalaTest. При виконанні `FlatSpec` (та інші трейти специфікацій  ScalaTest) генерує вивід, що читається як специфікація. Наприклад, ось на що буде схожий вивід, якщо ви запустите `ElementSpec` з Лістинга 14.4 в інтерпретаторі:
[source,scala]
----
scala> (new ElementSpec).execute()
A UniformElement
- should have a width equal to the passed value
- should have a height equal to the passed value
- should throw an IAE if passed a negative width
----
Лістинг 14.4 також ілюструє домен-специфічну мову (domain-specific language, DSL) матчерів в ScalaTest. Міксуючи трейт `Matchers`, ви можете написати твердження, що читаються майже як природна мова. ScalaTest провадить багато матчерів в своєму DSL, та також дозволяє вам визначати нові матчери з власними повідомленнями. Матчери, показані в Лістингу 14.4 включають синтаксис `should be` та `an [...] should be thrownBy { ...}`. Як альтернатива, ви можете зміксувати `MustMatchers`, якщо ви бажаєте `must` замість `should`. Наприклад, міксування `MustMatchers` дозволить вам писати вирази, такі як:
[source,scala]
----
result must be >= 0
map must contain key 'c'
----
Якщо останнє твердження схибить, ви побачите повідомлення про помилку, подібне до такого:
[source,scala]
----
Map('a' -> 1, 'b' -> 2) did not contain key 'c'
----
Тестовий фреймворк specs2 є інструментом з відкритим кодом, написаний на Scala Eric Torreborre, також підтримує стиль тестування BDD, але з іншим синтаксисом. Наприклад, ви можете використати specs2 для написання тесту, показаного в Лістингу 14.5:
[source,scala]
----
import org.specs2._
import Element.elem

object ElementSpecification extends Specification {
  "A UniformElement" should {
    "have a width equal to the passed value" in {
      val ele = elem('x', 2, 3)
      ele.width must be_==(2)
    }
    "have a height equal to the passed value" in {
      val ele = elem('x', 2, 3)
      ele.height must be_==(3)
    }
    "throw an IAE if passed a negative width" in {
      elem('x', -2, 3) must
      throwA[IllegalArgumentException]
    }
  }
}
----
Лістинг 14.5 - Специфікація та тестування поведінки за допомогою фреймворка specs2.

Як і ScalaTest, specs2 провадить DSL. Ви можете бачити деякі приклади матчерів specs2 в дії в Лістингу 14.5 в рядках, що містять `must be_==` та `must throwA`.footnote:[Ви можете завантажити specs2 на http://specs2.org/.] Ви можете використовувати specs2 окремо, але він також інтегрований з ScalaTest та JUnit, так що ви можете використати тести specs2 з ціма інструментами, також.

Одна з великих ідей BDD в тому, що тести можуть бути використані для спрощення комунікації між людьми, які визначають, що програмне забезпечення має робити, людьми, що реалізують програмне забезпечення, та людьми, що визначають, коли програма завершена та робить. Хоча любий зі стилів ScalaTest або specs2 можуть бути використаний в цій манері, ScalaTest `FeatureSpec` навмисне розроблений для цього. Лістинг 14.6 показує приклад:
[source,scala]
----
import org.scalatest._

class TVSetSpec extends FeatureSpec with GivenWhenThen {

  feature("TV power button") {
      scenario("User presses power button when TV is off") {
      Given("a TV set that is switched off")
      When("the power button is pressed")
      Then("the TV should switch on")
      pending
    }
  }
}
----
Лістинг 14.6 - Використання тестів для спрощення комунікації між зацікавленими сторонами.

FeatureSpec розроблений для направлення спілкування щодо потреб до програмних систем: ви маєте ідентифікувати специфічні можливості, потім вказати ці можливості в термінах сценаріїв. Методи `Given`, `When` та `Then` (запроваджені трейтом `GivenWhenThen`) можуть допомогти сфокусувати обговорення на особливостях окремих сценаріїв. Виклик `pending` в кінці вказує, що ані тести, вні справжня поведінка не були реалізовані, тільки специфікація. Як тільки всі тести та задана поведінка будуть реалізовані, тести будуть пройдені, та вимоги можуть вважатись задовільненими.

14.5 Базоване на властивостях тестування
----------------------------------------
Інший корисний інструмент тестування для Scala є ScalaCheck, фреймворк з відкритим кодом, написаний Rickard Nilsson. ScalaCheck дозволяє вам задавати властивості, яким має підкорюватись код під тестуванням. Для кожної властивості ScalaCheck буде генерувати дані, та виконувати твердження, що перевіряють, чи властивість буде справджуватись. Лістинг 14.7 показує приклад використання ScalaCheck з ScalaTest `WordSpec`, що міксує трейт `PropertyChecks`.
[source,scala]
----
import org.scalatest.WordSpec
import org.scalatest.prop.PropertyChecks
import org.scalatest.MustMatchers._
import Element.elem

class ElementSpec extends WordSpec with PropertyChecks {
  "elem result" must {
    "have passed width" in {
      forAll { (w: Int) =>
        whenever (w > 0) {
          elem('x', w, 3).width must equal (w)
        }
      }
    }
  }
}
----
Лістинг 14.7 - Написання властивість-базованих тестів за допомогою ScalaCheck.

`WordSpec` є класом стилю ScalaTest. Трейт `PropertyChecks` провадить декілька методів `forAll`, що дозволяють вам міксувати властивість-базовані тести з традиційними твердження-базованими або матчер-базованими тестами. В цьому прикладі ми перевіряємо властивість, якій має підкорюватись фабрика `elem`. Властивості ScalaCheck виражені як функціональне значення, що приймає як параметри дані, потрібні для твердження властивості. Ці дані будуть згенеровані ScalaCheck. У властивості, показаній в Лістингу 14.7, дані є ціле на ім'я `w`, що представляє ширину. В тілі функції ви бачите цей код:
[source,scala]
----
whenever (w > 0) {
  elem('x', w, 3).width must equal (w)
}
----
Твердження `whenever` вказує, що коли ліва частина вираза є `true`, вираз зправа має також бути `true`. Так що в цьому випадку, вираз в блоці має бути `true`, коли `w` є більше ніж `0`. Права частина виразу в цьому випадку буде давати `true`, якщо ширина, передана до фабрики `elem` є тою самою, що і `width` для Element, що повертається з фабрики.

З цією малою кількістю коду ScalaCheck буде генерувати, можливо, сотні значень для керування тестуванням кожного з них, шукаючи значення, для якого властивість не справджується. Якщо властивість дає `true` для кожного значення, що пробує ScalaCheck, тест буде пройдений. Інакше тест завершиться несподівано з `TestFailedException`, що містить інформацію, включаючи значення, яке спричинило збій.

14.6 Організація та виконання тестів
------------------------------------
Кожний фреймворк, згаданий в цій главі, провадить деякий механізм для організації та виконання тестів. В цьому розділі ми надамо швидкий огляд підходу ScalaTest. Щоб отримати повну історію по кожному з ціх фреймворків, вам треба проконсультуватись з їх документацією.

В ScalaTest ви організуєте великі тестові сюїти, вкладаючи `Suite` в `Suite`. Коли `Suite` виконується, вона буде виконувати свої вкладені сюїти, так само, як і їх тести. Вкладені `Suite` будуть в свою чергу виконувати свої вкладені `Suite`, і так далі. Таким чином, велика сюїта представлена як дерево об'єктів `Suite`. Коли ви виконуєте кореневу  `Suite` в дереві, всі сюїти в дереві будуть виконані.

Ви можете вкладувати сюїти іручну або автоматично. Щоб вкладати вручну, ви або перекриваєте метод `nested` для вашої `Suite`, або передаєте всі `Suite`, що ви бажаєте вкласти, в конструктор класу `Suites`, який ScalaTest провадить саме для цієї цілі. Щоб вкласти сюїти автоматично, ви провадите імена пакунків до ScalaTest Runner, що буде визначати `Suite` автоматично, вкладати їх під кореневою `Suite`, та виконувати кореневу `Suite`.

Ви можете визвати застосування ScalaTest Runner з командного рядка або через інструмент побудови, такий як `sbt`, `maven` або `ant`. Найпростіший спосіб викликати Runner з командного рядка через застосування `org.scalatest.run`. Це застосування очікує повністю кваліфіковане ім'я тестованого класу. Наприклад, щоб виконати тестовий клас, показаний в Лістингу 14.6, ви маєте компілювати його такою командою:
[source,scala]
----
$ scalac -cp scalatest.jar TVSetSpec.scala
----
Потім ви можете виконати його:
----
$ scala -cp scalatest.jar org.scalatest.run TVSetSpec
----

Малюнок 14.1 - Вивід `org.scalatest.run`.

За допомогою `-cp` ви покладаєте файл ScalaTest JAR на шлях до класів. (При завантаженні ім'я JAR файла буде включати номери версій вбудованих Scala та ScalaTest.) Наступний токен, `org.scalatest.run`, є повністю кваліфікованим іменем застосування. Scala буде виконувати це застосування, та передасть залишок токенів як аргументи командного рядка. Аргумент `TVSetSpec` вказує на сюїту, що треба виконати. Результат показаний на Малюнку 14.1.

14.7 Висновок
-------------
В цій главі ви бачили приклади міксування тверджень напряму в промисловий код, так само, як і написання їх назовні, в тестах. Ви бачили, що як Scala програміст, ви можете отримати переваги від популярних тестових інструментів від спільноти Java, таких, як JUnit та TestNG, так само, як і від новіших інструментів, розроблених спеціально для Scala, таких як ScalaTest, ScalaCheck, та specs2. Обоє, твердження в коді та зовнішні тести можуть допомогти вам досягти цілі щодо якості вашого коду. Ми відчуваємо, що ці технології досить важливі, щоб виправдати короткий відступ від Scala туторіала, що представляє ця глава. Однак в наступній главі ми повернемось до туторіала по мові, та розглянемо дуже корисний аспект Scala: співпадіння шаблонів.
