<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="paragraph"><p>Chapter 4
Classes and Objects
You&#8217;ve now seen the basics of classes and objects in Scala from the previous two chapters. In this
chapter, we&#8217;ll take you a bit deeper. You&#8217;ll learn more about classes, fields, and methods, and get an
overview of semicolon inference. We&#8217;ll discuss singleton objects, including how to use them to write
and run a Scala application. If you are familiar with Java, you&#8217;ll find that the concepts in Scala are
similar, but not exactly the same. So even if you&#8217;re a Java guru, it will pay to read on.
4.1 CLASSES, FIELDS, AND METHODS
A class is a blueprint for objects. Once you define a class, you can create objects from the class
blueprint with the keyword new. For example, given the class definition:
class ChecksumAccumulator {

}
You can create ChecksumAccumulator objects with:
new ChecksumAccumulator
Inside a class definition, you place fields and methods, which are collectively called members.Fields,
which you define with either val or var, are variables that refer to objects. Methods, which you define
with def, contain executable code. The fields hold the state, or data, of an object, whereas the methods
use that data to do the computational work of the object. When you instantiate a class, the runtime sets
aside some memory to hold the image of that object&#8217;s state (i.e., the content of its variables). For
example, if you defined a ChecksumAccumulator class and gave it a var field named sum:
class ChecksumAccumulator {
var sum = 0
}
and you instantiated it twice with:
val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator
The image of the objects in memory might look like this:Since sum, a field declared inside class ChecksumAccumulator, is a var, not a val, you can later
reassign to sum a different Int value, like this:
acc.sum = 3
Now the picture would look like this:
One thing to notice about this picture is that there are two sum variables, one in the object referenced
by acc and the other in the object referenced by csa. Fields are also known asinstance
variables, because every instance gets its own set of the variables. Collectively, an object&#8217;s instance
variables make up the memory image of the object. You see this illustrated here not only in that you see
two sum variables, but also that when you changed one, the other was unaffected.
Another thing to note in this example is that you were able to mutate the object acc referred to, even
though acc is a val. What you can&#8217;t do with acc (or csa), given that they are vals, notvars, is reassign a
different object to them. For example, the following attempt would fail:

acc = new ChecksumAccumulator
What you can count on, therefore, is that acc will always refer to the
same ChecksumAccumulatorobject with which you initialize it, but the fields contained inside that
object might change over time.
One important way to pursue robustness of an object is to ensure that the object&#8217;s state—the values of
its instance variables—remains valid during its entire lifetime. The first step is to prevent outsidersfrom accessing the fields directly by making the fields private. Because private fields can only be
accessed by methods defined in the same class, all the code that can update the state will be localized to
the class. To declare a field private, you place a privateaccess modifier in front of the field, like this:
class ChecksumAccumulator {
private var sum = 0
}
Given this definition of ChecksumAccumulator, any attempt to access sum from the outside of the class
would fail:
val acc = new ChecksumAccumulator
acc.sum = 5 // Won&#8217;t compile, because sum is private
Note
The way you make members public in Scala is by not explicitly specifying any access modifier. Put
another way, where you&#8217;d say "public" in Java, you simply say nothing in Scala. Public is Scala&#8217;s
default access level.
Now that sum is private, the only code that can access sum is code defined inside the body of the class
itself. Thus, ChecksumAccumulator won&#8217;t be of much use to anyone unless we define some methods in
it:
class ChecksumAccumulator {
private var sum = 0
def add(b: Byte): Unit = {
sum += b
}
}
def checksum(): Int = {
return <sub>(sum &amp; 0xFF) + 1
}
The ChecksumAccumulator now has two methods, add and checksum, both of which exhibit the basic
form of a function definition, shown in Figure 2.1 here.
Any parameters to a method can be used inside the method. One important characteristic of method
parameters in Scala is that they are vals, not vars.[1] If you attempt to reassign a parameter inside a
method in Scala, therefore, it won&#8217;t compile:
def add(b: Byte): Unit = {
b = 1

sum += b
}
Although add and checksum in this version of ChecksumAccumulator correctly implement the desired
functionality, you can express them using a more concise style. First, the return at the end ofthe checksum method is superfluous and can be dropped. In the absence of any explicit return
statement, a Scala method returns the last value computed by the method.
The recommended style for methods is in fact to avoid having explicit, and especially multiple, return
statements. Instead, think of each method as an expression that yields one value, which is returned.
This philosophy will encourage you to make methods quite small, to factor larger methods into
multiple smaller ones. On the other hand, design choices depend on the design context, and Scala
makes it easy to write methods that have multiple, explicitreturns if that&#8217;s what you desire.
Because all checksum does is calculate a value, it does not need an explicit return. Another shorthand
for methods is that you can leave off the curly braces if a method computes only a single result
expression. If the result expression is short, it can even be placed on the same line as the def itself. For
the utmost in conciseness, you can leave off the result type and Scala will infer it. With these changes,
class ChecksumAccumulator looks like this:
class ChecksumAccumulator {
private var sum = 0
def add(b: Byte) = sum += b
def checksum() = </sub>(sum &amp; 0xFF) + 1
}
Although the Scala compiler will correctly infer the result types of the add and checksummethods
shown in the previous example, readers of the code will also need to mentally inferthe result types by
studying the bodies of the methods. As a result it is often better to explicitly provide the result types of
public methods declared in a class even when the compiler would infer it for you. Listing 4.1 shows
this style.

class ChecksumAccumulator {
private var sum = 0
def add(b: Byte): Unit = { sum += b }
def checksum(): Int = ~(sum &amp; 0xFF) + 1
}
Listing 4.1 - Final version of class ChecksumAccumulator.
Methods with a result type of Unit, such as ChecksumAccumulator&#8217;s add method, are executed for their
side effects. A side effect is generally defined as mutating state somewhere external to the method or
performing an I/O action. In add&#8217;s case, the side effect is that sum is reassigned. A method that is
executed only for its side effects is known as a procedure.
4.2 SEMICOLON INFERENCE
In a Scala program, a semicolon at the end of a statement is usually optional. You can type one if you
want but you don&#8217;t have to if the statement appears by itself on a single line. On the other hand, a
semicolon is required if you write multiple statements on a single line:
val s = "hello"; println(s)If you want to enter a statement that spans multiple lines, most of the time you can simply enter it and
Scala will separate the statements in the correct place. For example, the following is treated as one
four-line statement:
if (x &lt; 2)
println("too small")
else
println("ok")
Occasionally, however, Scala will split a statement into two parts against your wishes:
x
+ y
This parses as two statements x and +y. If you intend it to parse as one statement x + y, you can always
wrap it in parentheses:
(x
+ y)
Alternatively, you can put the + at the end of a line. For just this reason, whenever you are chaining an
infix operation such as +, it is a common Scala style to put the operators at the end of the line instead of
the beginning:
x<br />
y<br />
z
THE RULES OF SEMICOLON INFERENCE
The precise rules for statement separation are surprisingly simple for how well they work. In short, a
line ending is treated as a semicolon unless one of the following conditions is true:
1. The line in question ends in a word that would not be legal as the end of a statement, such as a
period or an infix operator.
2. The next line begins with a word that cannot start a statement.
3. The line ends while inside parentheses (&#8230;) or brackets [&#8230;], because these cannot contain
multiple statements anyway.
4.3 SINGLETON OBJECTS
As mentioned in Chapter 1, one way in which Scala is more object-oriented than Java is that classes in
Scala cannot have static members. Instead, Scala has singleton objects. A singleton object definition
looks like a class definition, except instead of the keyword class you use the keyword object. Listing
4.2 shows an example.
The singleton object in this figure is named ChecksumAccumulator, the same name as the class in the
previous example. When a singleton object shares the same name with a class, it is called that
class&#8217;s companion object. You must define both the class and its companion object in the same sourcefile. The class is called the companion class of the singleton object. A class and its companion object
can access each other&#8217;s private members.

import scala.collection.mutable
object ChecksumAccumulator {
private val cache = mutable.Map.empty[String, Int]
def calculate(s: String): Int =
if (cache.contains(s))
cache(s)
else {
val acc = new ChecksumAccumulator
for (c &#8592; s)
acc.add(c.toByte)
val cs = acc.checksum()
cache += (s &#8594; cs)
cs
}
}
Listing 4.2 - Companion object for class ChecksumAccumulator.
The ChecksumAccumulator singleton object has one method, named calculate, which takes a Stringand
calculates a checksum for the characters in the String. It also has one private field, cache, a mutable
map in which previously calculated checksums are cached.[2] The first line of the method,
"if (cache.contains(s))", checks the cache to see if the passed string is already contained as a key in the
map. If so, it just returns the mapped value, cache(s). Otherwise, it executes the else clause, which
calculates the checksum. The first line of the else clause defines a val named acc and initializes it with
a new ChecksumAccumulator instance.[3] The next line is a for expression, which cycles through each
character in the passed string, converts the character to a Byte by invoking toByte on it, and passes that
to the add method of theChecksumAccumulator instances to which acc refers. After the for expression
completes, the next line of the method invokes checksum on acc, which gets the checksum for the
passed String, and stores it into a val named cs. In the next line, cache += (s &#8594; cs), the passed string
key is mapped to the integer checksum value, and this key-value pair is added to the cache map. The
last expression of the method, cs, ensures the checksum is the result of the method.
If you are a Java programmer, one way to think of singleton objects is as the home for any static
methods you might have written in Java. You can invoke methods on singleton objects using a similar
syntax: the name of the singleton object, a dot, and the name of the method. For example, you can
invoke the calculate method of singleton object ChecksumAccumulator like this:
ChecksumAccumulator.calculate("Every value is an object.")
A singleton object is more than a holder of static methods, however. It is a first-class object. You can
think of a singleton object&#8217;s name, therefore, as a "name tag" attached to the object:Defining a singleton object doesn&#8217;t define a type (at the Scala level of abstraction). Given just a
definition of object ChecksumAccumulator, you can&#8217;t make a variable of type ChecksumAccumulator.
Rather, the type named ChecksumAccumulator is defined by the singleton object&#8217;s companion class.
However, singleton objects extend a superclass and can mix in traits. Given each singleton object is an
instance of its superclasses and mixed-in traits, you can invoke its methods via these types, refer to it
from variables of these types, and pass it to methods expecting these types. We&#8217;ll show some examples
of singleton objects inheriting from classes and traits in Chapter 13.
One difference between classes and singleton objects is that singleton objects cannot take parameters,
whereas classes can. Because you can&#8217;t instantiate a singleton object with the newkeyword, you have
no way to pass parameters to it. Each singleton object is implemented asan instance of a synthetic
class referenced from a static variable, so they have the same initialization semantics as Java statics.
[4] In particular, a singleton object is initialized the first time some code accesses it.
A singleton object that does not share the same name with a companion class is called astandalone
object. You can use standalone objects for many purposes, including collecting related utility methods
together or defining an entry point to a Scala application. This use case is shown in the next section.
4.4 A SCALA APPLICATION
To run a Scala program, you must supply the name of a standalone singleton object with amain method
that takes one parameter, an Array[String], and has a result type of Unit. Any standalone object with
a main method of the proper signature can be used as the entry point into an application. An example is
shown in Listing 4.3:

import ChecksumAccumulator.calculate
object Summer {
def main(args: Array[String]) = {
for (arg &#8592; args)
println(arg + ": " + calculate(arg))
}
}
Listing 4.3 - The Summer application.
The name of the singleton object in Listing 4.3 is Summer. Its main method has the proper signature, so
you can use it as an application. The first statement in the file is an import of thecalculate method
defined in the ChecksumAccumulator object in the previous example. This import statement allowsyou to use the method&#8217;s simple name in the rest of the file.[5] The body of the main method simply
prints out each argument and the checksum for the argument, separated by a colon.
Note
Scala implicitly imports members of packages java.lang and scala, as well as the members of a
singleton object named Predef, into every Scala source file. Predef, which resides in package scala,
contains many useful methods. For example, when you say println in a Scala source file, you&#8217;re actually
invoking println on Predef. (Predef.println turns around and invokes Console.println, which does the
real work.) When you say assert, you&#8217;re invoking Predef.assert.
To run the Summer application, place the code from Listing 4.3 into a file named Summer.scala.
Because Summer uses ChecksumAccumulator, place the code for ChecksumAccumulator, both the
class shown in Listing 4.1 and its companion object shown in Listing 4.2, into a file
namedChecksumAccumulator.scala.
One difference between Scala and Java is that whereas Java requires you to put a public class in a file
named after the class—for example, you&#8217;d put class SpeedRacer in file SpeedRacer.java—in Scala, you
can name .scala files anything you want, no matter what Scala classes or code you put in them. In
general in the case of non-scripts, however, it is recommended style to name files after the classes they
contain as is done in Java, so that programmers can more easily locate classes by looking at file names.
This is the approach we&#8217;ve taken with the two files in this
example, Summer.scala and ChecksumAccumulator.scala.
Neither ChecksumAccumulator.scala nor Summer.scala are scripts, because they end in a definition. A
script, by contrast, must end in a result expression. Thus if you try to run Summer.scala as a script, the
Scala interpreter will complain that Summer.scala does not end in a result expression (assuming of
course you didn&#8217;t add any expression of your own after the Summer object definition). Instead, you&#8217;ll
need to actually compile these files with the Scala compiler, then run the resulting class files. One way
to do this is to use scalac, which is the basic Scala compiler, like this:
$ scalac ChecksumAccumulator.scala Summer.scala
This compiles your source files, but there may be a perceptible delay before the compilation finishes.
The reason is that every time the compiler starts up, it spends time scanning the contents of jar files and
doing other initial work before it even looks at the fresh source files you submit to it. For this reason,
the Scala distribution also includes a Scala compilerdaemon called fsc (for fast Scala compiler). You
use it like this:
$ fsc ChecksumAccumulator.scala Summer.scala
The first time you run fsc, it will create a local server daemon attached to a port on your computer. It
will then send the list of files to compile to the daemon via the port, and the daemon will compile the
files. The next time you run fsc, the daemon will already be running, so fsc will simply send the file list
to the daemon, which will immediately compile the files. Using fsc, you only need to wait for the Javaruntime to startup the first time. If you ever want to stop the fsc daemon, you can do so with fsc -
shutdown.
Running either of these scalac or fsc commands will produce Java class files that you can then run via
the scala command, the same command you used to invoke the interpreter in previous
examples. However, instead of giving it a filename with a .scala extension containing Scala code to
interpret as you did in every previous example,[6] in this case you&#8217;ll give it the name of a standalone
object containing a main method of the proper signature. You can run theSummer application,
therefore, by typing:
$ scala Summer of love
You will see checksums printed for the two command line arguments:
of: -213
love: -182
4.5 THE APP TRAIT
Scala provides a trait, scala.App, that can save you some finger typing. Although we haven&#8217;t yet
covered everything you&#8217;ll need to understand exactly how this trait works, we figured you&#8217;d want to
know about it now anyway. Listing 4.4 shows an example:
import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends App {
}
for (season &#8592; List("fall", "winter", "spring"))
println(season + ": " + calculate(season))
Listing 4.4 - Using the App trait.
To use the trait, you first write "extends App" after the name of your singleton object. Then instead of
writing a main method, you place the code you would have put in the main method directly between
the curly braces of the singleton object. You can access command-line arguments via an array of strings
named args. That&#8217;s it. You can compile and run this application just like any other.
4.6 CONCLUSION
This chapter has given you the basics of classes and objects in Scala, and shown you how to compile
and run applications. In the next chapter, you&#8217;ll learn about Scala&#8217;s basic types and how to use them.
Footnotes for Chapter 4:
[1] The reason parameters are vals is that vals are easier to reason about. You needn&#8217;t look further to
determine if a val is reassigned, as you must do with a var.
[2] We used a cache here to show a singleton object with a field. A cache such as this is a performance
optimization that trades off memory for computation time. In general, you would likely use such acache only if you encountered a performance problem that the cache solves, and might use a weak map,
such as WeakHashMap in scala.collection.jcl, so that entries in the cache could be garbage collected if
memory becomes scarce.
[3] Because the keyword new is only used to instantiate classes, the new object created here is an
instance of the ChecksumAccumulator class, not the singleton object of the same name.
[4] The name of the synthetic class is the object name plus a dollar sign. Thus the synthetic class for the
singleton object named ChecksumAccumulator is ChecksumAccumulator$.
[5] If you&#8217;re a Java programmer, you can think of this import as similar to the static import feature
introduced in Java 5. One difference in Scala, however, is that you can import members from any
object, not just singleton objects.
[6] The actual mechanism that the scala program uses to "interpret" a Scala source file is that it
compiles the Scala source code to Java bytecodes, loads them immediately via a class loader, and
executes them.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-24 07:07:48 EET
</div>
</div>
</body>
</html>
