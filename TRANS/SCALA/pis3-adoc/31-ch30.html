<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__30">Глава 30</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Еквівалентність об'єктів</h1>
<div class="paragraph"><p>Порівняння двох об'єктів на еквівалентність є наріжним в програмуванні. Воно більш заплутане, ніж здається на перший погляд. Ця глава дає погляд на еквівалентність в деталях, та дає деякі рекомендації для розгляду, коли ви розробляєте ваші власні тести еквівалентності.</p></div>
<div class="sect1">
<h2 id="_30_1___scala">30.1 Еквівалентність в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Розділі 11.2, визначення еквівалентності є різне в Scala та Java. Java має два порівняння на еквівалентність: оператор <code>==</code>, що є природною рівністю для типів значення та ідентичності об'єктів для типів посилань, та метод <code>equals</code>, що є  (визначена користувачем) канонічна еквівалентність для типів посилань. Ця домовленість є проблематичною, оскільки більш природний символ <code>==</code> не завжди відповідає до природної нотації еквівалентності. При програмуванні на Java загальна пастка для початківців є порівняння об'єктів за допомогою <code>==</code>, коли вони мають порівнюватись за допомогою <code>equals</code>. Наприклад, порівняння двох рядків <code>x</code> та <code>y</code> з використанням <code>x == y</code> може дати <code>false</code> в Java, навіть якщо <code>x</code> та <code>y</code> мають ті самі символи в тому ж порядку.</p></div>
<div class="paragraph"><p>Scala також має метод еквівалентності, що означає ідентичність об'єктів, але він використовується не часто. Цей різновид еквівалентності, що записується <code>x eq y</code>, є <code>true</code>, якщо <code>x</code> та <code>y</code> посилаються на той самий об'єкт. Еквівалентність <code>==</code> зарезервована в Scala для "природної" еквівалентності кожного типу. Для типів значень <code>==</code> є порівняння значень, так само, як в Java. Для типів посилань <code>==</code> є те саме, що <code>equals</code> в Java. Ви можете перевизначити поведінку <code>==</code> для нових типів через перевизначення метода <code>equals</code>, що завжди наслідується від класу <code>Any</code>. Наслідуване <code>equals</code>, що набуває сили якщо не перекрите, є ідентичність об'єкта, як це відбувається в Java. Так що <code>equals</code> (та разом і <code>==</code>) по замовчанню те саме, що і <code>eq</code>, але ви можете змінити його поведінку через перекриття метода <code>equals</code> в класі, що ви визначаєте. Неможливо перекрити <code>==</code> напряму, бо це визначене як фінальний метод в класі <code>Any</code>. Тобто Scala трактує <code>==</code> якби воно було визначене наступним чином в класі <code>Any</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">def</span> <span class="o">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="kc">null</span> <span class="n">eq</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span><span class="kc">null</span> <span class="n">eq</span> <span class="n">that</span><span class="o">}</span> <span class="k">else</span> <span class="o">{</span><span class="k">this</span> <span class="n">equals</span> <span class="n">that</span><span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_30_2___">30.2 Написання метода еквівалентності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як має бути визначений метод <code>equals</code>? З'ясовується, що написання коректного метода еквівалентності є несподівано складним в об'єктно орієнтованих мовах. Фактично, після вивчення великого обсягу Java коду, автори документу 2007 прийшли до висновку, що майже всі реалізації метода <code>equals</code> невдалі.<span class="footnote"><br />[Vaziri, et. al., "Declarative Object Identity Using Relation Types" [Vaz07]]<br /></span> Це проблематично, бо еквівалентність є базисом багатьої інших речей. Для початку, хибний метод еквівалентності для типу <code>C</code> може означати, що ви не можете надійно покласти об'єкт типу <code>C</code> до колекції.</p></div>
<div class="paragraph"><p>Наприклад, ви можете мати два елементи, <code>elem1</code> та <code>elem2</code>, типу <code>C</code>, що еквівалентні (тобто, <code>elem1 equals elem2</code> дає <code>true</code>). Тим не менше, з загально зустріваною хибною реалізацією метода <code>equals</code> ви можете все ще бачити поведінку, подібну до такої:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">hashSet</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">HashSet</span>
<span class="n">hashSet</span> <span class="o">+=</span> <span class="n">elem1</span>
<span class="n">hashSet</span> <span class="n">contains</span> <span class="n">elem2</span> <span class="c1">// повертає false!</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось чотири загальні пастки,<span class="footnote"><br />[Всі крім третьої описані і контексті Java в книзі Effective Java Second Edition, by Joshua Bloch. [Blo08]]<br /></span> що можуть спричинити неузгоджену поведінку при перекритті <code>equals</code>:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Визначення <code>equals</code> з помилковою сигнатурою.
</p>
</li>
<li>
<p>
Зміна <code>equals</code> без одночасної зміни <code>hashCode</code>.
</p>
</li>
<li>
<p>
Визначення <code>equals</code> в термінах змінних полів.
</p>
</li>
<li>
<p>
Схиблене визнечення <code>equals</code> як відношення еквівалентності.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Ці чотири пастки дискутуються в залишку цього розділу.</p></div>
<div class="sect2">
<h3 id="__1__code_equals_code___">Пастка #1: Визначення <code>equals</code> з помилковою сигнатурою</h3>
<div class="paragraph"><p>Розглянемо додавання метода еквівалентності до наступного класу простих точок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Майже очевидний, але невірний шлях буде визначити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Повністю невірне визначення `equals`</span>
<span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Що не так з цім методом? На перший погляд здається, що все робить OK:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p1</span><span class="o">,</span> <span class="n">p2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p1</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">37</span><span class="n">d7d90f</span>
<span class="n">p2</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">3</span><span class="n">beb846d</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">q</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="nd">@e0cf182</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="n">equals</span> <span class="n">p2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="n">equals</span> <span class="n">q</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак проблеми починаються, як тільки ви починаєте покладати точки до колекції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="n">p1</span><span class="o">)</span>
<span class="n">coll</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Point</span><span class="k">@</span><span class="mi">37</span><span class="n">d7d90f</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p2</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Як пояснити, що <code>coll</code> не містить <code>p2</code>, навіть якщо <code>p1</code> був доданий до неї, та <code>p1</code> та <code>p2</code> еквівалентні об'єкти? Причина явно полягає в наступній ітерації, де точний тип однієї з порівнюваних точок замаскований. Визначте <code>p2a</code> як псевдоним <code>p2</code>, але з типом <code>Any</code> замість <code>Point</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p2a</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="n">p2</span>
<span class="n">p2a</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">3</span><span class="n">beb846d</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли ви повторите перше порівняння, але з псевдонимом <code>p2a</code> замість <code>p2</code>, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="n">equals</span> <span class="n">p2a</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Що не так? Версія <code>equals</code>, надана до цього, не перекриває стандартний метод <code>equals</code>, оскільки її тип інший. Ось тип метода <code>equals</code>, як він визначений в кореневому класі <code>Any</code>:<span class="footnote"><br />[Якщо ви багато пишете на Java, ви можете очікувати, що аргумент цього метода буде типу <code>Object</code>, замість типу <code>Any</code>. Не турбуйтесь про це; це той самий метод <code>equals</code>. Компілятор просто робить що воно виглядає як тип <code>Any</code>.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки метод <code>equals</code> в <code>Point</code> приймає <code>Point</code> замість <code>Any</code> як аргумент, він не перекриває <code>equals</code> в <code>Any</code>. Замість цього він просто є перевантаженою альтернативою. Тепер, перевантаження в Scala та в Java розрішене статичним типом аргумента, не типом часу виконання. Так що доки статичний тип аргумента є <code>Point</code>, буде викликатись метод <code>equals</code> в <code>Point</code>. Однак як тільки статичний аргумент стає типу <code>Any</code>, замість цього починає викликатись метод <code>equals</code> в Any. Цей метод не був перекритий, так що він досі реалізований через порівняння ідентичності об'єктів.</p></div>
<div class="paragraph"><p>Ось чому порівняння  <code>p1 equals p2a</code> дає <code>false</code>, навіть якщо точки <code>p1</code> та <code>p2a</code> мають ті самі значення <code>x</code> та <code>y</code>. Ось чому метод <code>contains</code> в <code>HashSet</code> повертає <code>false</code>. Оскільки цей метод оперує на дженерік множинах, він викликає дженерік метод <code>equals</code> в <code>Object</code>, замість перевантаженого варіанта в <code>Point</code>. Ось кращий метод <code>equals</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Краще визначення, але все ще не ідеальне</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>equals</code> має коректний тип. Він приймає значення типу <code>Any</code> як параметр, та дає результат <code>Boolean</code>. Реалізація цього метода використовує порівняння шаблонів. Спочатку він перевіряє, чи об'єкт також є типу <code>Point</code>. Якщо це так, він порівнює координати двох точок, та повертає результат. Інакше результат <code>false</code>.</p></div>
<div class="paragraph"><p>Пов'язана пастка є визначити <code>==</code> з невірноє сигнатурою. Нормально, якщо ви намагаєтесь перевизначити <code>==</code> з коректною сигнатурою, що приймає аргумент типу <code>Any</code>, компілятор буде давати вам помилку, оскільки ви намагаєтесь переписати фінальний метод типу <code>Any</code>.</p></div>
<div class="paragraph"><p>Новачки в Scala іноді роблять дві помилки разом: вони намагаються перекрити <code>==</code>, і вони дають невірну сигнатуру. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">==(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="c1">// Не робіть цього!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку визначений користувачем метод <code>==</code> трактується як перевантажений варіант так само названого метода з класа <code>Any</code>, і програма компілюється. Однак поведінка програми буде такою ж сумнівною, якби ви визначили <code>equals</code> з невірною сигнатурою.</p></div>
<div class="paragraph"><p>Пастка #2: Зміна <code>equals</code> без одночасної зміни <code>hashCode</code></p></div>
<div class="listingblock">
<div class="content">
<pre><code>Ми будемо продовжувати використовувати приклад з пастки #1. Якщо ви продовжите порівняння `p1` та `p2a` з останнім визначенням `Point`, ви отримаєте `true`, як очікувалось. Однак якщо ми повторимо перевірку `HashSet.contains`, ви будете вірогідно все ще отримувати `false`:
[source,scala]
----
scala> val p1, p2 = new Point(1, 2)
p1: Point = Point@122c1533
p2: Point = Point@c23d097

scala> collection.mutable.HashSet(p1) contains p2
res4: Boolean = false
----
Але цей результат не на 100% певний. Ви можете також отримати `true` в простому експерименті. Якщо ви зробите це, ви можете спробувати деякі інші точки з координатами 1 та 2. З часом ви отримаєте таку, що не містилась в множині. Що тут не так, це те, що `Point` перевизначає `equals`, при цьому також не перевизначаючи `hashCode`.

Зауважте, що колекція в прикладі є `HashSet`. Це означає, що елементи колекції покладаються в "хеш ьакети", що визначаються їх хеш кодом. Перевірка `contains` спершу визначає хеш бакет, де дивитись, та потім порівнює надані елементи з усіма елементами в бакеті. Тепер, остання версія класу `Point` перевизначила `equals`, але вона в той же час не перевизначила `hashCode`. Так що `hashCode` все ще той, що був в версії для класа `AnyRef`: деяка трансформація адреси розміщеного об'єкта.

Хеш коди `p1` та `p2` майже напевне різні, навіть якщо поля обох точок однакові. Різні хеш коди означають, з великою вірогідністю, різні хеш бакети в множині. Перевірка `contains` буде шукати співпадаючий елемент в бакеті, що відповідає до хеш коду `p2`. В більшості випадків точка `p1` буде в іншому бакеті, так що вона ніколи не буде знайдена. `p1` та `p2` можуть також з вірогідністю попасти в той самий хеш бакет. В цьому випадку перевірка поверне `true`. Проблема в тому, що остання реалізація `Point` порушує контракт на `hashCode`, як визначено для класа `Any`:footnote:[Текст контракту `Any` `hashCode` надихнено документацією Javadoc класу `java.lang.Object`.]

  Якщо два класи еквівалентні відповідно до метода `equals`, тоді виклик `hashCode` на кожному з двох об'єктів має продукувати той самий цілий результат.

Фактично, це добре відомо в Java, що `hashCode` та `equals` повинні завжди бути перевизначені разом. Більше того, `hashCode` можу залежати тільки від полів, на які покладається `equals`. Для класа `Point` наступне може бути підходящим визначенням `hashCode`:
[source,scala]
----
class Point(val x: Int, val y: Int) {
  override def hashCode = (x, y).##
  override def equals(other: Any) = other match {
    case that: Point => this.x == that.x && this.y == that.y
    case _ => false
  }
}
----
Це тільки одне з багатьох можливих реалізацій `hashCode`. Нагадаємо, що метод `##`є скороченням для обчислення хеш кодів, що роблять з примітивними значеннями, типами посилань та `null`. Коли викликається на колекції або таплі, він обчислює змішаний хеш, що чутливий до хеш кодів всіх елементів в колекції. Ми запровадимо більше настанов по написанню  `hashCode` пізніше в цій главі.

Додавання `hashCode` лагодить проблему еквівалентності, коли визначаються класи як `Point`; однак є інші проблемні місця, до яких треба придивитись.

Пастка #3: Визначення `equals` в термінах змінних полів</code></pre>
</div></div>
<div class="paragraph"><p>Розглянемо наступну невелику варіацію класу <code>Point</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Проблематично</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдина відмінність в тому, що поля <code>x</code> та <code>y</code> тепер <code>var</code> замість <code>val</code>. Методи <code>equals</code> та <code>hashCode</code> тепер визначені в термінах ціх змінних полів, так що їх результати змінюються, коли змінюються поля. Це може мати дивний ефект, коли ваші точки потраплять до колекції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
<span class="n">coll</span><span class="k">:</span> <span class="kt">scala.collection.mutable.HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ви зміните поле в <code>p</code>, чи буде колекція все ще містити точку? Ми спробуємо це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Це виглядає дивно. Куди зникла <code>p</code>? Більше дивини буде, якщо ви перевірите, чи ітератор по множині містить <code>p</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що тут множина, що не містить <code>p</code>, але <code>p</code> є серед елементів множини! Що трапилось, це те, що після зміни поля <code>x</code>, точка <code>p</code> залишилась з невірним хеш бакетом в множині <code>coll</code>. Тобто, її оригінальний хеш бакет більше не відповідає до нового значення її хеш коду. Кажучи розмовною мовою, точка <code>p</code> "випала з поля зору" в множині <code>coll</code>, навіть якщо вона все ще належить до її елементів.</p></div>
<div class="paragraph"><p>Урок, що треба винести з цього прикладу, в тому, що коли <code>equals</code> та <code>hashCode</code> залежать від змінного стану, це призводить до проблем для потенційних користувачів. Якщо ви покладете такі об'єкти до колекцій, ви маєте бути уважними, щоб ніколи не модифікувати цей стан, і це складно. Якщо вам треба порівняння, що приймає до уваги поточний стан об'єкта, вам слідує назвати це якось інакше, не <code>equals</code>.</p></div>
<div class="paragraph"><p>Розглядаючи останнє визначення <code>Point</code>, можливо буде мати вигоду оминути перевизначення <code>hashCode</code>, та назвати метод порівняння <code>equalContents</code> або деяким ішим ім'ям, відмінним від <code>equals</code>. Після цього <code>Point</code> буде наслідувати реалізацію по замовчанню <code>equals</code> та <code>hashCode</code>; <code>p</code> буде шукатись в <code>coll</code> навіть після модифікацій до його поля <code>x</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__4___code_equals_code___">Пастка #4: Схиблене визнечення <code>equals</code> як відношення еквівалентності</h3>
<div class="paragraph"><p>Контракт метода <code>equals</code> в <code>scala.Any</code> вказує, що <code>equals</code> має реалізувати відношення еквівалентності на не-<code>null</code> об'єктах:<span class="footnote"><br />[Як з <code>hashCode</code>, контракт <code>Any</code> для метода <code>equals</code> базується на контракті метода equals в <code>java.lang.Object</code>.]<br /></span></p></div>
<div class="ulist"><ul>
<li>
<p>
Він рефлексивний: Для любого не-<code>null</code> значення <code>x</code> вираз <code>x.equals(x)</code> повинен повертати <code>true</code>.
</p>
</li>
<li>
<p>
Він симетричний: для любих не-<code>null</code> значень <code>x</code> та <code>y</code>, <code>x.equals(y)</code> повинно повертати <code>true</code> тоді і тільки тоді, якщо <code>y.equals(x)</code> повертає <code>true</code>.
</p>
</li>
<li>
<p>
Він транзитивний: для любих не-<code>null</code> значень <code>x</code>, <code>y</code>, та <code>z</code>, якщо <code>x.equals(y)</code> повертає <code>true</code>, та <code>y.equals(z)</code> повертає <code>true</code>, тоді <code>x.equals(z)</code> повинно повертати <code>true</code>.
</p>
</li>
<li>
<p>
Він узгоджений: для любих не-<code>null</code> значень <code>x</code> та <code>y</code>, декілька викликів <code>x.equals(y)</code> повинно узгоджено повертати <code>true</code>, або узгоджено повертати <code>false</code>, вважаючи, що інформація, яка використовувалась для порівнянь не змінювалась.
</p>
</li>
<li>
<p>
Для кожного не-<code>null</code> значення <code>x</code>, <code>x.equals(null)</code> повинно повертати <code>false</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Визначення <code>equals</code>, розроблене для класа <code>Point</code> дотепер, задовільняє контракту для <code>equals</code>. Однак речі стають складнішими, коли прийняти до уваги субкласи. Скажімо, існує субклас <code>ColoredPoint</code> від <code>Point</code>, що додає поле <code>color</code> типу <code>Color</code>. Нехай <code>Color</code> визначений як перелік, як представлено в Розділі 20.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Yellow</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span><span class="o">,</span> <span class="nc">Indigo</span><span class="o">,</span> <span class="nc">Violet</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>ColoredPoint</code> перекриває <code>equals</code>, щоб прийняти до уваги нове поле <code>color</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Пробелма: equals не симетричне</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те, що більшість програмістів скоріше всього напишуть. Зауважте, що в цьому випадку клас <code>ColoredPoint</code> не повинен перекрити <code>hashCode</code>. Оскільки нове визначення <code>equals</code> на <code>ColoredPoint</code> суворіше, ніж перекрите визначення в <code>Point</code> (що означає, що воно прирівняє меньшу кількість об'єктів), контракт для <code>hashCode</code> залишається валідним. Якщо дві кольорові точки еквівалентні, вони повинні мати ті самі координати, так що їх хеш коди також гарантовано рівні.</p></div>
<div class="paragraph"><p>Беручи сам клас <code>ColoredPoint</code>, його визначення <code>equals</code> виглядає OK. Однак контракт для <code>equals</code> ламається, як тільки точки і кольорові точки змішуються. Розглянемо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>
<span class="n">cp</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span> <span class="n">equals</span> <span class="n">cp</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">cp</span> <span class="n">equals</span> <span class="n">p</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння <code>p equals cp</code> викликає метод <code>p.equals</code>, що визначений в класі <code>Point</code>. Цей метод приймає до уваги тільки координати двох точок. Як слідоцтво, порівняння дає <code>true</code>. З іншого боку, порівняння <code>cp equals p</code> викликає метод <code>cp.equals</code>, що визначений в класі <code>ColoredPoint</code>. Цей метод повертає <code>false</code>, оскільки <code>p</code> не є <code>ColoredPoint</code>. Так що відношення, визначене <code>equals</code>, не є симетричним.</p></div>
<div class="paragraph"><p>Втрата симетрії може мати неочікувані наслідки для колекцій. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">](</span><span class="n">p</span><span class="o">)</span> <span class="n">contains</span> <span class="n">cp</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">](</span><span class="n">cp</span><span class="o">)</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть якщо <code>p</code> та <code>cp</code> рівні, одна перевірка <code>contains</code> буде успішна, та інша невдала:</p></div>
<div class="paragraph"><p>Як ви можете змінити визначення <code>equals</code>, так щоб він став симетричний? В основному є два шляхи. Ви можете або зробити відношення більш загальним, або більш суворим. Створення його більш загальним означає, що пара з двох об'єктів, <code>x</code> та <code>y</code>, має вважатись рівними, якщо любе з порівнянь <code>x</code> до <code>y</code>, або <code>y</code> до <code>x</code>, дасть <code>true</code>. Ось код що робить це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Проблема: equals не транзитивне</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="n">that</span> <span class="n">equals</span> <span class="k">this</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нове визначення <code>ColoredPoint</code> має один додатковий <code>case</code>, ніж старе: якщо об'єкт <code>other</code> є <code>Point</code>, але не <code>ColoredPoint</code>, метод відсилає до метода <code>equals</code> в <code>Point</code>. Це має бажаний ефект, що робить <code>equals</code> симетричним. Тепер обоє, <code>cp equals p</code> та <code>p equals cp</code> дають <code>true</code>. Однак контракт для <code>equals</code> все ще поломаний. Проблема в тому, що нове відношення більше не транзитивне!</p></div>
<div class="paragraph"><p>Ось послідовність тверджень, що демонструють це. Визначте точку і дві кольорові точки різного кольору, всі з однаковими координатами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">redp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>
<span class="n">redp</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bluep</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>
<span class="n">bluep</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>
</pre></div></div></div>
<div class="paragraph"><p>Взяті окремо, <code>redp</code> рівне до <code>p</code>, та <code>p</code> рівне до <code>bluep</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">redp</span> <span class="o">==</span> <span class="n">p</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">==</span> <span class="n">bluep</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак порівняння <code>redp</code> та <code>bluep</code> дає <code>false</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">redp</span> <span class="o">==</span> <span class="n">bluep</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, твердження транзитивності контракту <code>equals</code> порушене.</p></div>
<div class="paragraph"><p>Створення відношення <code>equals</code> більш загальним, здається, призводить до глухого кута. Ми спробуємо зробити його замість цього суворішим. Один спосіб зробити <code>equals</code> суворішим - це завжди вприймати об'єкти різних типів як різні. Цього можна досягти, можифікуючи методи <code>equals</code> в класах <code>Point</code> та <code>ColoredPoint</code>. В класі <code>Point</code> ви можете додати додаткове порівняння, що перевіряє, чи клас часу виконання іншої <code>Point</code> точно такий самий, як і в класа цієї <code>Point</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Технічно валідний, але незадовільний метод equals</span>
<span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span>
          <span class="k">this</span><span class="o">.</span><span class="n">getClass</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">getClass</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ви можете відкатити реалізацію класа <code>ColoredPoint</code> назад до версії, що перед цім порушувала вимогу симетричності:<span class="footnote"><br />[Маючи нову реалізацію <code>equals</code> в <code>Point</code>, ця версія <code>ColoredPoint</code> більше не порушує вимогу симетрії.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут примірник класу <code>Point</code> визнається рівним до деякого іншого примірника того самого класу, тільки якщо об'єкти мають ті самі координати, та вони мають той клас часу виконання, що означає, що <code>getClass</code> на кожному об'єкті поверне те саме значення. Нові визначення задовільняють симетрії та транзитивності, оскільки тепер кожне порівняння між об'єктами різних класів дає <code>false</code>. Так що кольорова точка ніколи не буде рівна точці. Ця домовленість виглядає логічною, але ви можете сказати, що нове обмеження дуже суворе.</p></div>
<div class="paragraph"><p>Розглянеом наступний обхідний шлях визначити точку з координатами <code>(1, 2)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pAnon</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">}</span>
<span class="n">pAnon</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>
</pre></div></div></div>
<div class="paragraph"><p>Чи <code>pAnon</code> рівне до <code>p</code>? Відповідь є ні, оскільки об'єкти <code>java.lang.Class</code>, асоційовані з <code>p</code> та <code>pAnon</code> є різні. Для <code>p</code> це <code>Point</code>, тоді як для <code>pAnon</code> це анонімний субклас <code>Point</code>. Але ясно, що <code>pAnon</code> є тільки нова точка з координатами <code>(1, 2)</code>. Не виглядає логічним розглядати її як іншу, ніж <code>p</code>.</p></div>
<div class="paragraph"><p>Виглядає що ми буксуємо. Чи існує розумний спосіб перевизначити еквівалентність на декількох рівнях ієрархії класів, при цьому дотримуючись контракту? Фактично, існує такий метод, але він потребує одночасного перевизначення ще одного метода разом з <code>equals</code> та <code>hashCode</code>. Ідея в тому, що як тільки клас перевизначає <code>equals</code> (та <code>hashCode</code>), він також має явно встановити, що об'єкти цього класу ніколи не рівні до об'єктів деякого суперкласу, що реалізує інший метод еквівалентності. Це досягається додаванням методу <code>canEqual</code> до кожного класу, що перевизначає <code>equals</code>. Ось сигнатура метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод повинен повертати <code>true</code>, якщо інший об'єкт є примірником класу, в якому <code>canEqual</code> є (пере)визначеним, інакше <code>false</code>. Він викликається з <code>equals</code>, щоб переконатись, що об'єкти можна порівняти в обох напрямках. Лістинг 30.1 показує нову (та фінальну) реалізацію класу <code>Point</code>, разом з ціма рядками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
          <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.1 - Метод суперкласа <code>equals</code>, що викликає <code>canEqual</code>.</p></div>
<div class="paragraph"><p>Метод <code>equals</code> в цій версії класу <code>Point</code> містить додаткову вимогу, щоб об'єкт <code>other</code> міг бути еквівалентним до <code>this</code>, як визначено в методі <code>canEqual</code>. Реалізація <code>canEqual</code> в <code>Point</code> стверджує, що всі примірники <code>Point</code> можуть бути рівними.</p></div>
<div class="paragraph"><p>Лістинг 30.2 показує відповідну реалізацію <code>ColoredPoint</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">hashCode</span><span class="o">,</span> <span class="n">color</span><span class="o">).#</span><span class="k">#</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
          <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">ColoredPoint</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.2 - Метод субкласу <code>equals</code>, що викликає <code>canEqual</code>.</p></div>
<div class="paragraph"><p>Може бути показане, що нове визначення <code>Point</code> та <code>ColoredPoint</code> дотрумуються контракту для <code>equals</code>. Еквівалентність є симетричною та транзитивною. Порівняння <code>Point</code> з <code>ColoredPoint</code> завжди дає <code>false</code>. Зрозуміло, що для кожної точки <code>p</code> та кольорової точки <code>cp</code>, <code>p equals cp</code> буде повертати <code>false</code>, оскільки <code>cp canEqual p</code> буде повертати <code>false</code>. Зворотнє порівняння <code>cp equals p</code> буде також повертати <code>false</code>, оскільки <code>p</code> не є <code>ColoredPoint</code>, так що перше співпадіння шаблонів в тілі <code>equals</code> в <code>ColoredPoint</code> схибить.</p></div>
<div class="paragraph"><p>З іншого боку, примірники різних субкласів <code>Point</code> можуть бути рівні, доти, докі ніякий з субкласів не перевизначає метод рівності. Наприклад, з повим визначенням класу, порівняння <code>p</code> та <code>pAnon</code> даватиме <code>true</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">p</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Indigo</span><span class="o">)</span>
<span class="n">cp</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=</span> <span class="nc">ColoredPoint</span><span class="nd">@e6230d8f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pAnon</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">}</span>
<span class="n">pAnon</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
<span class="n">coll</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Point</span><span class="k">@</span><span class="mi">5428</span><span class="n">bd62</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">cp</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">coll</span> <span class="n">contains</span> <span class="n">pAnon</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці приклади демонструють, що якщо реалізація <code>equals</code> суперкласа визначає та викликає <code>canEqual</code>, тоді програмісти, що реалізують субкласи можуть вирішувати, зможе чи ні примірник їхнього субкласу бути рівний примірникам суперкласу. Наприклад, оскільки <code>ColoredPoint</code> перекриває <code>canEqual</code>, кольорова точка ніколи не може бути рівною до простої старої точки. Але оскільки анонімний субклас, на який посилається <code>pAnon</code> не перекриває <code>canEqual</code>, його примірник може бути рівним до примірника <code>Point</code>.</p></div>
<div class="paragraph"><p>Одне з потенційних зауважень підходу <code>canEqual</code> в тому, що він порушує Принцип Підстановки Ліскова (LSP). Наприклад, техніка реалізації <code>equals</code> через порівняння типів часу виконання, що призводить до неможливості визначити субклас, чиї примірники можуть бути рівні примірникам суперкласу, була описана як порушення LSP.<span class="footnote"><br />[Bloch, Effective Java Second Edition, p. 39 [Blo08]]<br /></span> LSP стверджує, що повинна бути можливість використовувати (підставляти) примірники субкласів, там, де потрібні примірники суперкласа.</p></div>
<div class="paragraph"><p>Однак в попередньому прикладі <code>coll contains cp</code> повертає <code>false</code>, навіть якщо в <code>cp</code> значення <code>x</code> та <code>y</code> співпадають з такими для точки в колекції. Таким чином, це може виглядати як порушення LSP, оскільки ви не можете використовувати <code>ColoredPoint</code> там, де очікувався <code>Point</code>. Ми віримо, що це помилкова інтерпретація, оскільки LSP не вимагає, щоб субклас поводився ідентично до своїх суперкласів, а тільки щоб він поводився так, щоб задовільняти контракту свого суперкласу.</p></div>
<div class="paragraph"><p>Проблема з написанням метода <code>equals</code>, що порівнює класи часу виконання не в тому, що він порушує LSP, але в тому, що він не дає вам спосіб створити субклас, чиї примірники можуть бути еквівалентні примірникам суперкласу. Наприклад, як ми використовували техніку рантайм класів в попередньому прикладі, <code>coll contains pAnon</code> мало б повертати <code>false</code>, але не те, чого ми б хотіли. Для контрасту, ми реально хочемо, щоб <code>coll contains cp повертав `false</code>, оскільки через перекриття <code>equals</code> в <code>ColoredPoint</code> ми в основному кажемо, що точка кольору індіго з координатами <code>(1, 2)</code> не те саме, що некольорова точка <code>(1, 2)</code>. Таким чином, в попередньому прикладі ми були в змозі передати два різні примірники субкласа <code>Point</code> до метода <code>contains</code>, та ми отримали назад дві різні відповіді, обоє коректні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_30_3_____">30.3 Визначення параметрів для параметризованих типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В методі <code>equals</code> в попередніх прикладах все починалось з шаблона порівняння, що перевіряв, чи тип операнда відповідав типу класу, що містить метод <code>equals</code>. Коли класи параметризовані, ця схема потребує невеликої адаптації.</p></div>
<div class="paragraph"><p>Як приклад розглянемо бінарні дерева. Ієрархія класів, показана на Лістингу 30.3 визначає абстрактний клса <code>Tree</code> для бінарного дерева, з двома альтернативними реалізаціями: об'єкт <code>EmptyTree</code>, та клас <code>Branch</code>, що представляє непорожні дерева. Непорожне дерево складається з деякого елемента <code>elem</code>, та лівого та правого дочірніх дерев. Тип цього елементу береться з параметру типу <code>T</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">EmptyTree</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;EmptyTree.elem&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;EmptyTree.left&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;EmptyTree.right&quot;</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">+T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span><span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.3 - Ієрархія для бінарних дерев.</p></div>
<div class="paragraph"><p>Тепер ми додамо методи <code>equals</code> та <code>hashCode</code> до ціх класів. Для самого класу <code>Tree</code> нічого робити, оскільки ми вважаємо, що ці методи реалізовані окремо для кожної реалізації абстрактного класу. Для об'єкту <code>EmptyTree</code> все ще нічого робити, оскільки реалізація по замовчанню для <code>equals</code> та <code>hashCode</code>, які <code>EmptyTree</code> наслідує від <code>AnyRef</code>, роблять чудово. Кінець кінцем, <code>EmptyTree</code> единий буде рівний сам собі, так що еквівалентність буде посилатись на ідентичність, що наслідується від <code>AnyRef</code>.</p></div>
<div class="paragraph"><p>Але додавання <code>equals</code> та <code>hashCode</code> до <code>Branch</code> потребує деякої роботи. Значення <code>Branch</code> має бути рівне тільки іншим значенням <code>Branch</code>, та тільки в тому випадку, якщо два значення мають рівні поля <code>elem</code>, <code>left</code> та <code>right</code>. Буде природним застосувати схему для <code>equals</code>, що була розроблена в попередніх розділах цієї глави. Це дасть вам:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак компіляція цього прикладу дає позначку, що виникло попередження "unchecked". Нова компіляція з опцією -unchecked викриває наступну проблему:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">fsc</span> <span class="o">-</span><span class="n">unchecked</span> <span class="nc">Tree</span><span class="o">.</span><span class="n">scala</span>
<span class="nc">Tree</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">14</span><span class="kt">:</span> <span class="kt">warning:</span> <span class="kt">non</span> <span class="kt">variable</span> <span class="k">type</span><span class="kt">-argument</span> <span class="kt">T</span> <span class="kt">in</span> <span class="k">type</span>
<span class="kt">pattern</span> <span class="kt">is</span> <span class="kt">unchecked</span> <span class="kt">since</span> <span class="kt">it</span> <span class="kt">is</span> <span class="kt">eliminated</span> <span class="kt">by</span> <span class="kt">erasure</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Як каже попередження, існує порівняння шаблонів щодо типу <code>Branch[T]</code>, але вивтема може тільки перевірити, що інше посилання є (деяким різновидом) <code>Branch</code>; вона не може перевірити, що тип елементу дерева є <code>T</code>. В Главі 19 ви зустрічали причину цього: типи елементів параметризованих типів видаляються на фазі затирання компілятора; вони недоступні для інспекції під час виконання.</p></div>
<div class="paragraph"><p>Так що ми можемо зробити? Нащастя, з'ясовується, що вам не обов'язково перевіряти, що два <code>Branch</code> мають той самий тип елементів при їх порівнянні. Досить можливо, що два <code>Branch</code> з різними типами елементів рівні, доки їх поля такі самі. Простий приклад цього може бути <code>Branch</code>, що складається з одного елементу <code>Nil</code> та двох порожніх субдерев. Прийнятно вважати любі два таких  <code>Branch</code> як рівні, не важливо, які статичні типи вони мають:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">b1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span>
           <span class="nc">EmptyTree</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">)</span>
<span class="n">b1</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Branch</span><span class="k">@</span><span class="mi">9</span><span class="n">d5fa4f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">b2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span>
           <span class="nc">EmptyTree</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">)</span>
<span class="n">b2</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Branch</span><span class="k">@</span><span class="mi">56</span><span class="n">cdfc29</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Позитивний результат порівняння вище було отримане від реалізації <code>equals</code> на <code>Branch</code>, показаної до цього. Це демонструє, що тип елементу <code>Branch</code> не був перевірений — якщо б він був перевірений, результатом мало б бути <code>false</code>.</p></div>
<div class="paragraph"><p>Ми можемо не погоджуватись, який з двох результатів буде більш натуральний. Кінець цінцем, це залежить від ментальної моделі того, як класи представлені. В моделі, де параметри типу присутні лише під час компіляції, природно вважати, що два <code>Branch</code>, <code>b1</code> та <code>b2</code>, рівні. В альтернатівній моделі, де параметри типу формують частину значення об'єкту, так само природно розглядати їх як різні. Оскільки Scala приймає модель затирання типів, параметри типів неприсутні під час виконання, так що <code>b1</code> та <code>b2</code> природно розглядаються як рівні.</p></div>
<div class="paragraph"><p>Існує тільки маленька зміна, потрібна для формулювання методу <code>equals</code>, що не продукує неперевіреного попередження. Замість елементу типу <code>T</code> використовуйте літеру малого реєсту, таку як <code>t</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
                        <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
                        <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
</pre></div></div></div>
<div class="paragraph"><p>Згадайте з Розділу 15.2, що параметр типу в шаблоні, що починається з малої літери, представляє невідомий тип. Тепер шаблон співпаде:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>буде успішним для значень <code>Branch</code> любого типу. Параметр типу <code>t</code> представляє невідомий елемент типу для <code>Branch</code>. Він також може бути замінений на підкреслення, що те саме, що і попередній варіант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна річ, що залишилось визначити для класу <code>Branch</code> є два інші методи, <code>hashCode</code> та <code>canEqual</code>, що ідуть з <code>equals</code>. Ось можлива реалізація <code>hashCode</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Це тільки одна з багатьох можливих реалізацій. Як показано раніше, принцип є взяти <code>hashCode</code> з усіх полів, та скомбінувати їх. Ось реалізація методу <code>canEqual</code> в класі <code>Branch</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація метода <code>canEqual</code> використовує типізоване порівняння шаблонів. Також можливо свормулювати його за допомогою <code>isInstanceOf</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви почуваєтесь як nit-picking — і ми заохочуємо, щоб ви так і почувались! — ви можете здивуватись, що значить поява підкреслення в типі вище. Кінець кінцем, <code>Branch[_]</code> є технічно параметром типу для метода, не типом шаблону. То як це можливо залишити деякі його частини невизначеними?</p></div>
<div class="paragraph"><p>Відповідь на це запитання обговорюється в наступній главі. <code>Branch[_]</code> є скороченням для так званого підстановочного типу, що є, грубо кажучи, типом з деякими невідомими частинами. Так що навіть якщо технічно підкреслення означає дві різні речі в порівнянні шаблонів та параметрі типу в виклику метода, в основному значення те саме: воно дозволяє вам помітити дещо, що є невідомим. Фінальна версія <code>Branch</code> показана в Лістингу 30.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
                            <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">elem</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">).#</span><span class="k">#</span>
<span class="o">}</span>

<span class="n">Лістинг</span> <span class="mf">30.4</span> <span class="o">-</span> <span class="n">Параметризований</span> <span class="n">тип</span> <span class="n">з</span> <span class="n">`equals`</span> <span class="n">та</span> <span class="n">`hashCode`</span><span class="o">.</span>

<span class="mf">30.4</span> <span class="n">Рецепти</span> <span class="n">щодо</span> <span class="n">`equals`</span> <span class="n">та</span> <span class="n">`hashCode`</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому розділі ми надамо крок-за-кроком рецепти для створення методів <code>equals</code> та <code>hashCode</code>, що повинні підходити для більшості ситуацій. Як ілюстрація, ми будемо використовувати методи класу <code>Rational</code>, показаного в Лістингу 30.5.</p></div>
<div class="paragraph"><p>Щоб створити цей клас ми видалили методи математичних операцій з версії класу <code>Rational</code>, показаного в Лістингу 6.5. Ми також зробили мінорні покращення до <code>toString</code>, та модифікували ініціалізатори <code>numer</code> та <code>denom</code>, щоб нормалізувати всі дробі, що мають додатний дільник (тобто, трансформувати <code>1/-2</code> до <code>-1/2</code>).</p></div>
<div class="sect2">
<h3 id="___code_equals_code">Рецепт для <code>equals</code></h3>
<div class="paragraph"><p>Ось рецепт для перекриття <code>equals</code>:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Щоб перекрити <code>equals</code> в нефінальному класі, створіть метод <code>canEqual</code>. Якщо наслідуване визначення <code>equals</code> походить від <code>AnyRef</code> (тобто <code>equals</code> не був перевизначений вище в ієрархії класів), визначення <code>canEqual</code> повинне бути нове; інакше воно буде перекривати повереднє визначення метода з таким же ім'ям. Одне виключення до цієї вимоги є для фінальних класів, що перевизначають метод <code>equals</code>, наслідуваний від <code>AnyRef</code>. Для них аномалії субкласів, описані в Розділі 30.2 не можуть виникти; відповідно вони не мають визначати <code>canEqual</code>. Тип об'єкту, переданий до <code>canEqual</code> повинен бути <code>Any</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Метод <code>canEqual</code> повинен давати <code>true</code>, якщо об'єкт аргумента є примірником поточного класу (iтобто класу, в якому визначений <code>canEqual</code>), та <code>false</code> інакше:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
В методі <code>equals</code> переконайтесь, що ви задекларували тип об'єкта, переданого як <code>Any</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Напишіть тіло метода <code>equals</code> як єдиний вираз <code>match</code>. Селектор  <code>match</code> повинен бути об'єктом, переданим до <code>equals</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Вираз <code>match</code> повинен мати два випадки. Перший повинен декларувати шаблон типу для класу, в якому ви визначаєте метод <code>equals</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=&gt;</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
В тілі цього <code>case</code> запишіть вираз, що логчно пов'язує разом окремі вирази, що мають бути <code>true</code> для рівних об'єктів. Якщо метод <code>equals</code>, що ви перекриваєте, не походить від <code>AnyRef</code>, ви будете найбільш вірогідно включати виклик метода <code>equals</code> суперкласа:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви визначаєте <code>equals</code> для класа, що перший визначає <code>canEqual</code>,ви повинні викликати <code>canEqual</code> на аргументі до метода рівності, передавши його як аргумент:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
</pre></div></div></div>
<div class="paragraph"><p>Перекриття перевизначень <code>equals</code> також повенне включати виклик <code>canEqual</code>, якщо вони не включають виклик до <code>super.equals</code>. В останньому випадку перевірка <code>canEqual</code> буде вже зроблена викликом суперкласа. Нарешті, для кожного поля, що має відношення до рівності, перевірте, що поле для об'єкту <code>this</code> рівне до відповідного поля переданого об'єкта:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">numer</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">&amp;&amp;</span>
<span class="n">denom</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Для другого випадку використовуйте підстановочний шаблон, що дає <code>false</code>:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви дотримуватиметесь цього рецепту для <code>equals</code>, рівність гарантовано буде відношенням еквівалентності, як вимагається контрактом <code>equals</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="o">(</span><span class="k">if</span> <span class="o">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">-</span><span class="n">n</span> <span class="k">else</span> <span class="n">n</span><span class="o">)</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=&gt;</span>
        <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">numer</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">&amp;&amp;</span>
        <span class="n">denom</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">).#</span><span class="k">#</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">denom</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="n">numer</span><span class="o">.</span><span class="n">toString</span> <span class="k">else</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 30.5 - Клас <code>Rational</code> з <code>equals</code> та <code>hashCode</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_hashcode_code">Рецепт для <code>hashCode</code></h3>
<div class="paragraph"><p>Для <code>hashCode</code> ви звичайно можете досягти задовільних результатів, якщо будете використовувати наступний рецепт, що подібний до рецепту, рекомендуємого для Java класів в Effective Java.<span class="footnote"><br />[Bloch, Effective Java Second Edition. [Blo08]]<br /></span> Включіть в обчислення кожне поле в вашому об'єкту, що використовується для визначення рівності в методі <code>equals</code> ("відповідні" поля). Зробіть тапл, що містить значення з усіх ціх полів. Потім викличте <code>##</code> на отриманому таплі.</p></div>
<div class="paragraph"><p>Наприклад, щоб реалізувати хеш код для об'єкта, що має п'ять відповідних полів з іменами <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо метод <code>equals</code> викликає <code>super.equals(that)</code> як частину своїх обчислень, ви маєет почати ваше обчислення <code>hashCode</code> з виклика` super.hashCode`. Наприклад, якщо метод <code>Rational</code> <code>equals</code> мав викликати <code>super.equals(that)</code>, його <code>hashCode</code> був би такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">hashCode</span><span class="o">,</span> <span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна річ, що треба пам'ятати коли пишете методи <code>hashCode</code> за допомогою цього підходу, це те, ваш хеш код буде гарний тільки настільки, наскільки гарні хеш коди, на яких він побудований, а саме хеш коди, що ви отримали викликаючи <code>hashCode</code> на відповідних полях вашого об'єкта. Іноді вам буде треба дещо крім простого виклику  <code>hashCode</code> на полі, щоб отримати корисний хеш код для цього поля. Наприклад, якщо одне з ваших полів є колекція, ви вірогідно бажаєте хеш код для цього поля, що базується на всіх елементах, що містяться в цій колекції. Якщо поле є <code>Vector</code>, <code>List</code>, <code>Set</code>, <code>Map</code>, або тапл, ви можете просто включити його в список елементів, по яких ви хешуєте, оскільки <code>equals</code> та <code>hashCode</code> перекриті в ціх класах, щоб прийняти до уваги елементи, які вони містять. Але це не так для  <code>Array</code>, що не приймає до уваги елементи при обчисленні хеш коду. таким чином для масивів ви маєте трактувати кожний елемент масиву як окреме поле вашого об'єкту, викликаюч <code>##</code> на кожному елементі явно, або передаючи масив до одного з методів <code>hashCode</code> в синглтон об'єкті <code>java.util.Arrays</code>.</p></div>
<div class="paragraph"><p>Нарешті, якщо ви знайдете, що окреме обчислення хеш коду шкодить продуктивності вашої програми, розгляньте кешування хеш коду. Якщо об'єкт незмінний, ви можете обчислити хеш код, коли об'єкт створюється, та зберігти його в полі. Ви можете зробити це, просто перекривши <code>hashCode</code> за допомогою <code>val</code> замість <code>def</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">val</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span><span class="o">).#</span><span class="k">#</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей підхід є компроміс між пам'ятю та часом виконання, оскільки кожний примірник незмінного класу буде мати на одне поле більше, що зберігатиме кешоване значення хеш коду.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_30_5_">30.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В ретроспктиві визначення коректної реалізації <code>equals</code> було несподівано тонким. Ви маєте бути уважним щодо сигнатури типу; ви маєте перекрити <code>hashCode</code>; ви повинні уникати залежностей від змінного стану; та ви маєте реалізувати та використовувати метод <code>canEqual</code>, якщо ваш клас не є фінальним.</p></div>
<div class="paragraph"><p>Беручи до уваги, як складно реалізувати коректний метод рівності, ви можете схилитись до визначення ваших класів для об'єктів що порівнюються як кейс класів. Таким чином компілятор Scala буде додавати методи <code>equals</code> та <code>hashCode</code> з правильними властивостями автоматично.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-17 05:03:01 EEST
</div>
</div>
</body>
</html>
