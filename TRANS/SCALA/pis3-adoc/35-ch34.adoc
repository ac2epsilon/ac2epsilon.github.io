include::headers.adoc[]

Глава 34
--------

Програмування користувацького інтерфейсу
========================================

В цій главі ми навчимось, як розробляти Scala застосування, що використовують графічний користувацький інтерфейс (GUI). Застосування, що ми будемо розробляти, базуються на Scala бібліотеці, що провадить доступ до класів фреймворку Java Swing GUI. Концептуально бібліотека Scala повторює підлеглі класи Swing, але приховує більшість з їх складності. Ви знайдете, що використовуючи цей фреймворк розробка GUI застосувань насправді досить проста.

Навіть зі спрощеннями Scala, фреймворк як Swing є досить багатим, з багатьма різними класами, та багатьма методами в кожному класі. Щоб знайти свій шлях в такій багатій бібліотеці, допомагає використовувати IDE, таку як Eclipse зі Scala плагіном. Перевага в тому, що IDE може вам інтерактивно показувати через завершення команд, які класи доступні в пакунку, та які методи доступні для о'бєктів, на які ви посилаєтесь. Це помітно прискорює ваше навчання коли ви вперше досліджуєте невідомий космос бібліотеки.

Малюнок 34.1 - Просте застосування Swing: початкове (зліва) та збільшене (зправа).

34.1 Перше Swing застосування
-----------------------------
Як перше Swing застосування ми почнемо з вікна, що містить одну кнопку. Щоб програмувати зі Swing вам треба імпортувати різні класи з пакунка Scala Swing API:
[source,scala]
----
import scala.swing._
----
Лістинг 34.1 показує код вашого першого Swing застосування в Scala. Якщо ви скомпілюєте та виконаєте цей файл, ви маєте побачити вікно, як показано зліва на Малюнку 34.1. Вікно може змінити розмір до більшого розділу, як показано зправа на Малюнку 34.1.
[source,scala]
----
import scala.swing._

object FirstSwingApp extends SimpleSwingApplication {
  def top = new MainFrame {
    title = "First Swing App"
    contents = new Button {
      text = "Click me"
    }
  }
}
----
Лісинг 34.1 - Просте Scala Swing застосування.

Якщо ви проаналізуєте код в Лістингу 34.1 рядок за рядком, ви помітите наступні елементи:
[source,scala]
----
object FirstSwingApp extends SimpleSwingApplication {
----
В першому рядку після `import` об'єкт `FirstSwingApp` наслідує від `scala.swing.SimpleSwingApplication`. Це застосування відрізняється від традиційних застосувань командного рядка, що може наслідувати від `scala.App`. Клас `SimpleSwingApplication` завжди визначає метод `main`, що містить деякий код встановлення для фреймворку Java Swing. Потім метод `main` обробляє виклик до метода `top`, який ви надаєте:
[source,scala]
----
def top = new MainFrame {
----
Наступний рядок реалізує метод `top`. Цей метод містить код, що визначає ваш високорівневий GUI компонент. Це зазвичай деякий різновид `Frame` — тобто вікно, що може містити довільні дані.

В Лістингу 34.1 ми обрали `MainFrame` в якості високорівневого компонента. `MainFrame` такий самий, як звичайний Swing `Frame`, за тим винятком, що його закриття також буде зачиняти ціле GUI застосування.
[source,scala]
----
title = "First Swing App"
----
Фрейми мають декілька атрибутів. Два з найбільш важливих є заголовок фрейма, ща з'явиться в рядку заголовка, та його вміст, що буде відображений в самому вікні. В Scala Swing API такі атрибути моделюються як властивсоті. Ви знаєте з Розділу 18.2, що пластивості в Scala закодовані як пари методів геттера та сеттера. Наприклад, властивість `title` об'єкта `Frame` моделюється як метод геттера:
[source,scala]
----
def title: String
----
та метод сеттера:
[source,scala]
----
def title_=(s: String)
----
Це той самий метод, що буде викликаний присвоєнням до `title` вище. Ефект від присвоєння в тому, що обраний заголовок буде показаний в рядку заголовка вікна. Якщо ви не вкажете його, вікно матиме порожній заголовок.
[source,scala]
----
contents = new Button {
----
Фрейм вищого рівня є кореневим компонентом Swing застосування. Це `Container`, що означає, що наступні помпоненти будуть визначені в ньому. Кожний Swing контейнер має властивість `contents`, що дозволяє вам отримати та встановити компоненти, які містить контейнер. Геттер `contents` на цій властивості має тип `Seq[Component]`, що вказує, що компонент може в загальному випадку мати декілька об'єктів в якості вмісту. Однак фрейми завжди мають тільки один компонент в якості `contents`. Цей компонент встановлюється та потенційно змінюється з використанням сеттеа `contents_=`. Наприклад, в Лістингу 34.1 один `Button` складає `contents` фрейма `top`.
[source,scala]
----
text = "Click me"
----
Кнопка також отримує заголовок, в цьому випадку `"Click me"`.

34.2 Панелі та розташування
---------------------------
Як наступний крок ми додамо деякий текст як другий компонент до фрейма `top` нашого застосування. Ліва частина Малюнка 34.2 показує, як має виглядати наше застосування. 

Малюнок 34.2 - Реактивне Swing застосування: початкове (зліва) та після натискання (зправа).

[source,scala]
----
import scala.swing._

object SecondSwingApp extends SimpleSwingApplication {
  def top = new MainFrame {
    title = "Second Swing App"
    val button = new Button {
      text = "Click me"
    }
    val label = new Label {
      text = "No button clicks registered"
    }
    contents = new BoxPanel(Orientation.Vertical) {
      contents += button
      contents += label
      border = Swing.EmptyBorder(30, 30, 10, 30)
    }
  }
}
----
Лістинг 34.2 - Збірка компонентів на панелі.

Ви бачили в останньому розділі, що фрейм містить рівно один дочірній компонент. Таким чином, щоб зробити фрейм з обома, кнопкою та міткою, вам треба створити інший компонент контейнера, що містить обоє. Ось для чого створені панелі. `Panel` є контейнером, що відображує всі компоненти, що він містить, відповідно до деяких фіксованих правил розташування. Є декілька різних розташувань, що реалізовані різними субкласами класу `Panel`, в диапазоні від простих до досить заплутаних. Фактично, одна зі складніших частин складного GUI застосування може бути отримання правильного розташування — непросто запропонувати дещо, що відображується досить гарно на всіх різновидах пристроїв для всіх розмірів вікна.

Лістинг 34.2 показує повну реалізацію. В цьому класі два субкомпоненти фрейма `top` названі `button` та `label`. `button` визначений як раніше. Мітка `label` відображує текст, що не може бути редагований:
[source,scala]
----
val label = new Label {
  text = "No button clicks registered"
}
----
Код в Лістингу 34.2 обирає просте вертикальне розташування, коли компоненти покладені один на інший в `BoxPanel`:
[source,scala]
----
contents = new BoxPanel(Orientation.Vertical) {
----
Властивість `contents` для `BoxPanel` є (спочатку порожнім) буфером, до якого елементи `button` та `label` додані за допомогою оператора `+=`:
[source,scala]
----
contents += button
contents += label
----
Ми також додали границю кругом двох об'єктів, через присвоєння властивості `border` панелі:
[source,scala]
----
border = Swing.EmptyBorder(30, 30, 10, 30)
----
Як і в випадку з іншими GUI компонентами, границі представлені об'єктами. `EmptyBorder` є методом фабрики в об'єкті Swing, що приймає чотири параметри, вказуючи ширину границі зверху, зправа, знизу та злівого боку об'єктів, які ми малюємо. 

Простий як є, цей приклад вже показав базовий спосіб структурувати GUI застосування. Воно побудоване з компонент, що є примірниками класів зі `scala.swing`, таких як `Frame`, `Panel`, `Label` або `Button`. Компоненти мають властивості, що можуть бути налаштовані з боку застосування. Компоненти панелі можеть містить декілька інших компонент в своїй властивості `contents`, так що кінець кінцем GUI застосування складаються з дерева компонент.

34.3 Обробка подій
------------------
З іншого боку застосуванню все ще бракую базової властивості. Якщо ви виконаєте код з Лістинга 34.2, та клацнете на кнопці, нічого не станеться. Фактично, застосування повністю статичне; воно не реагує в жодний спосіб на події користувача, за винятком кнопки закриття фрейма `top`, що завершує застосування. Як наступний крок, ми покращимо застосування, так що воно відображатиме разом кнопку та мітку, що вказує, як часто натискається кнопка. Права частина Малюнка 34.2 містить знімок екрану, де зображено як виглядатиме застосування після натискання кнопки.

Щоб досягти цієї поведінки, вам треба під'єднати користувацьку подію (натискання кнопки) з дією (відображення оновленої мітки). Java та Scala мають фундаментально однаковий підхід "публікації/підписки" до обробки подій: компоненти можуть бути паблішерами та/або підписчиками. Паблішер публікує події. Підписчик підписується на паблішері для отримання повідомлень щодо любих опублікованих подій. Паблішери також називають "джерелами подій", та підписчики також називають "слухачами подій". Наприклад, `Button` є джерелом подій,що публікує подію, `ButtonClicked`, вказуючи, що кнопка була натиснута.

В Scala підписка на джерело подій `source` робиться викликом `listenTo(source)`. Є також шлях відписатись від подій від `source` використовуючи `deafTo(source)`. В поточному прикладі застосування перша річ, що треба зробити, це зробити щоб фрейм `top` слухав на своїй кнопці, так що він отримуватиме повідомлення щодо подій на кнопці. Щоб зробити це, вам треба додати наступний виклик до тіла фрейма `top`:
[source,scala]
----
listenTo(button)
----
Бути повідомленим про події є тільки частиною справи; друга частина є їх обробка. Ось де фреймворк Scala Swing найбільш відрізняється від (та радикально простіший за) Java Swing API. В Java сигнал події означає виклик метода `notify` об'єкта, що реалізує деякий інтерфейс `Listener`. Зазвичай це включає гарну порцію перенаправлень та шаблонного коду, що робить застосування з обробкою подій складними для написання та читання. Для контрасту, в Scala, подія є реальним об'єктом, що надсилається до підписаних компонент, що більше схоже на те, як повідомлення надсилаються до акторів. Наприклад, натискання кнопки буде створювати подію, що є примірником наступного кейс класу:
[source,scala]
----
case class ButtonClicked(source: Button)
----
Параметр кейс класу посилається на кнопку, що буна натиснута. Як з усіма іншими подіями Scala Swing, цей клас події міститься в пакунку з назвою `scala.swing.event`.

Щоб ваш компонент реагував на входящі події, вам треба додати обробник до властивості з назвою `reactions`. Ось код, який робить це:
[source,scala]
----
var nClicks = 0
reactions += {
  case ButtonClicked(b) =>
  nClicks += 1
  label.text = "Number of button clicks: " + nClicks
}
----
Перший рядок вище визначає змінну `nClicks`, що містить число раз, скільки кнопка була натиснута. Решта рядків додають код між фігурними дужками як обробник до властивості `reactions` фрейма `top`. Обробники є функціями, визначеними через порівняння шаблонів на подіях, більше схоже як Akka актор в методі `receive`, визначеному через порівняння на повідомленнях. Обробник вище порівнює події в формі `ButtonClicked(b)`, тобто любі події, що є примірником класу `ButtonClicked`. Змінна шаблону `b` посилається на справжню кнопку, що була натиснута. Дія, що відповідає до цієї події в коді вище, збільшує `nClicks`, та оновлює текст мітки.

Загалом, обробник є `PartialFunction`, що співпадає на подіях, та виконує деякі дії. Також можливо порівняти на більше ніж одному різновиді подій в одному обробнику з декількома `case`.
[source,scala]
----
import scala.swing._
import scala.swing.event._

object ReactiveSwingApp extends SimpleSwingApplication {
  def top = new MainFrame {
    title = "Reactive Swing App"
    val button = new Button {
      text = "Click me"
    }
    val label = new Label {
      text = "No button clicks registered"
    }
    contents = new BoxPanel(Orientation.Vertical) {
      contents += button
      contents += label
      border = Swing.EmptyBorder(30, 30, 10, 30)
    }
    listenTo(button)
    var nClicks = 0
    reactions += {
      case ButtonClicked(b) =>
        nClicks += 1
        label.text = "Number of button clicks: " + nClicks
    }
  }
}
----
Лістинг 34.3 - Реалізація реактивного Swing застосування.

Властивість `reactions` реалізує колекцію, так само, як робить властивість `contents`. Деякі компоненти приходять з передвизначеними реакціями. Наприклад, `Frame` має передвизначену реакцію, що закриє фрейм, якщо користувач натисне кнопку закриття в заголовку. Якщо ви встановите ваші власні реакції через додавання за допомогою `+=` до властивості `reactions`, реакції, що ви встановите, будуть розглядатись як додаток до стандартних. Концептуально, обробники, встановлені в `reactions`, формують стек. В цьому прикладі, якщо фрейм `top` отримує повідомлення, перший обробник, що буде спробуваний, буде той, що співпадає на `ButtonClicked`, оскільки він був останнім обробником, встановленим для фрейма. Якщо отримана подія має тип `ButtonClicked`, код, асоційований з шаблоном, буде викликаний. Після того, як цей код буде завершений, система буде шукати серед подальших обробників в стеку подій, що також можуть бути застосовані. Якщо отримана подія не має тип `ButtonClicked`, подія безпосередньо просувається до решти встановлених обробників. Також можливо видалити обробники з властивості `reactions` за допомогою оператора `-=`.

Лістинг 34.3 показує завершене застосування, включаючи реакції. Код ілюструє основні елементи GUI застосування в фреймворці Scala Swing: застосування складається з дерева компонент, починаючи з фрейма `top`. Компоненти, показані в коді: `Frame`, `BoxPanel`, `Button`, `Label`, але є багато інших різновидів компонент, визначених в бібліотеках Swing. Кожний компонент налаштований через встановлення атрибутів. Два важливі атрибути це `contents`, що визначає дочірні компоненти в дереві, та `reactions`, що визначає, як компонент реагує на події.

Малюнок 34.3 - Конвертор між градусами Цельсія та Фаренгейта.

[source,scala]
----
import swing._
import event._

object TempConverter extends SimpleSwingApplication {
  def top = new MainFrame {
    title = "Celsius/Fahrenheit Converter"
    object celsius extends TextField { columns = 5 }
    object fahrenheit extends TextField { columns = 5 }
    contents = new FlowPanel {
      contents += celsius
      contents += new Label(" Celsius = ")
      contents += fahrenheit
      contents += new Label(" Fahrenheit")
      border = Swing.EmptyBorder(15, 10, 10, 10)
      listenTo(celsius, fahrenheit)
      reactions += {
        case EditDone(`fahrenheit`) =>
          val f = fahrenheit.text.toInt
          val c = (f - 32) * 5 / 9
          celsius.text = c.toString
        case EditDone(`celsius`) =>
          val c = celsius.text.toInt
          val f = c * 9 / 5 + 32
          fahrenheit.text = f.toString
      }
    }
  }
}
----
Лістинг 34.4 - Реалізація конвертора температури.

34.4 Приклад: конвертор Цельсій/Фаренгейт
-----------------------------------------
Як інший приклад, ми напишемо GUI програму, що конвертує між градусами температури в Цельсіях та Фаренгейтах. Користувацький інтерфейс програми показаний на Малюнку 34.3. Він складається з двох полів (показані білими) з міткою, що стоїть за кожним. Одне текстове поле показує температуру в градусах Цельсія, інше в градусах Фаренгейта. Кожне з двох полів може бути відредаговане користувачем застосування. Як тільки користувач змінює температуру в полі, температура в іншому полі оновлюється автоматично.

Лістинг 34.4 показує повний код, що реалізує це застосування. Імпорти зверху коду використовують скорочення:
[source,scala]
----
import swing._
import event._
----
Це фактично, еквівалентне до імпортів, що використовувались раніше:
[source,scala]
----
import scala.swing._
import scala.swing.event._
----
Причина, з якої ви можете використовувати скорочення, в тому, що ці пакунки вкладені в Scala. Оскільки пакунок `scala.swing` міститься в пакунку `scala`, та все в цьому пакунку імпортоване автоматично, ви можете писати лише `swing` для посилання на пакунок. Подібно до цього, пакунки в `scala.swing.event` містяться як субпакунок `event` в пакунку `scala.swing`. Оскільки ви імпортували все в `scala.swing` в першому імпорті, ви можете посилатись на пакунок `event` просто як на `event`.

Два компоненти, `celsius` та `fahrenheit`, в `TempConverter` є об'єкти класу `TextField`. `TextField` в Swing є компонент, що дозволяє вам редагувати єдиний рядок тексту. Він має довжину по замовчанню, що дається у властивості `columns`, обчисленої в символах (встановлене в 5 для обох полів).

Вміст `TempConverter` зібраний в панель, що включає два текстових поля та дві мітки, що пояснюють, що таке ці поля. Панель класу `FlowPanel`, що означає, що вона відображує елементи один за одним, в один або більше рядків, в залежності від ширини фрейма.

`reactions` `TempConverter` визначені обробником, що містить два `case`. Кожний `case` співпадає з подією `EditDone` для одного з двох текстових полів. Така подія видається, коли текстове поле редагується користувачем. Зауважте форму шаблонів, що мають зворотні апострофи коло імен аргументів:
[source,scala]
----
case EditDone(`celsius`)
----
Як було пояснено в Розділі 15.2, ці апострофи коло `celsius` дають переконання, що шаблон співпаде тільки якщо джерелом події був об'єкт `celsius`. Якщо ви пропустили апостроф, та просто написали `case EditDone(celsius)`, шаблон буде співпадати з кожною подією класу `EditDone`. Змінене поле потім буде збережене в змінній шаблона `celsius`. Очевидно, це не те, що ви хочете. Альтернативно ви можете визначити два об'єкта `TextField`, що починаються з великої літери, тобто, `Celsius` та `Fahrenheit`. В такому випадку ви можете порівняти їх напряму, без апострофів, як `case EditDone(Celsius)`.

Дві дії подій `EditDone` конвертують одні одиниці на інші. Кожне починається з читання вмісту модифікованого поля, та його перетворення на `Int`. До нього застосовується формула переводу температури з одних градусів в інші, та зберігання результата як рядка в іншому текстовому полі.

34.5 Висновок
-------------
Ця глава надала вам перший присмак GUI програмування використовуючи Scala огортки для Swing фреймворку. Вона показала, як збирати GUI компоненти, як налаштовувати їх властивості, та як обробляти події. З причин вільного місця ми можемо обговорити тільки невелику кількість простих компонент. Існує значно більше різновидів компонент. Ви можете дізнатись про них через консультації з документацією Scala по пакунку `scala.swing`. Наступний розділ буде розробляти приклад більш складного Swing застосування.

Існує також багато туторіалів по оригінальному фреймворку Java Swing,на якому базується огортка Scala.footnote:[Дивіться, наприклад, The Java Tutorials. [Jav\]] Огортки Scala повторюють підлеглі класи Swing, але намагаються де можливо спростити концепції, та зробити їх більш одноманітними. Спрощення екстенсивно використовує властивості мови Scala. Наприклад, емуляція властивостей в Scala та її перевантаження операторів дозволяє зручні визначення властивостей з використанням присвоєнь та операторів `+=`. Її філософія "все є об'єкт" робить можливим наслідувати метод `main` GUI застосування. Таким чином метод може бути прихований від користувацьких застосувань, включаючи шаблонний код для встановлення речей, що іде з цім. Нарешті, та більш важливо, першокласні функції Scala та порівняння шаблонів робить можливим формулювати обробку подій як властивсоті компонента `reactions`, що дуже спрощує життя розробника застосування.
