include::headers.adoc[]

Глава 28
--------

Робота з XML
============

Ця глава вводить в підтримку XML в Scala. Після дискутування напів-структурованих даних взагалі, вона показує основну функціональність в Scala для маніпулювання XML: як створити вузли з допомогою XML літералів, як зберігти та завантажити XML з файлів, та як розбити XML вузли з використанням методів запитів та порівняння шаблонів. Ця глава є тільки коротким введенням в те, що можливо з допомогою XML, але вона показує вам досить для початку.

28.1 Напів-структуровані дані
-----------------------------
XML є формою _напів-структурованих_ даних. Він є більш структурованим ніж прості рядки, оскільки він організує вміст даних в вигляді дерев. Однак простий XML менш структурований, ніж об'єкти в мові програмування, оскільки він дозволяє довільний текст між тегами, та йому бракує системи типів.footnote:[Існують системи типів для XML, такі як XML Schemas, але вони за полем зору цієї книги.]

Напів-структуровані дані дуже корисні кожного разу, коли вам треба серіалізувати дані програми для збереження в файлі або доставки через мережу. Замість конвертування структурованих даних кожного разу до байтів, ви конвертуєте їх до-та-з напів-структурованих даних. Потім ви використовуєте існуючу бібліотечні процедури для конвертації напів-структурованих даних в бінарні дані, зберігаючи ваш час для більш важливих проблем.

Існує багато форм напів-структурованих даних, але XML є найбільш широко використовуваною формою в інтернеті. Існують XML інструменти для більшості операційних систем, та більшість мов програмування мають доступні XML бібліотеки. Його популярність само-підсилююча. Чим більше інструментів та бібліотек розробляється у відповідь на популірність XML, тим вірогідніше інженери програмного забезпечення оберуть XML як частину своїх форматів. Якщо ви пишете програмне забезпечення, що комунікує через інтернет, тоді скоріше або пізніше вам буде треба взаємодіяти з якимось сервісом, що розмовляє мовою XML.

З усіх ціх причин Scala включає спеціальну підтримку для обробки XML. Ця глава показує вам підтримку Scala для конструювання XML, його обробку звичайними методами, та обробку за допомогою порівняння шаблонів Scala. На додаток до ціх основ, глава по ходу показує декілька загальних ідіом по використанню XML в Scala.

28.2 Огляд XML
--------------
XML побудований з двох базових елементів, тексту та тегів.footnote:[Повна історія трохи складніша, але цього достатньо щоб бути ефективним з XML.] Текст є, як звичайно, любою послідовністю символів. Теги, записані як `<pod>`, складаються зі знака меньше, літерної мітки, та знака більше. Тегі можуть бути відкриваючими та закриваючими. Закриваючий тег виглядає як відкриваючий, за винятком того, що він має косу прямо перед міткою тега, як тут: </pod>.

Відкриваючий та закриваючий тег мають відповідати один до одного, так само як дужки. Кожний відкриваючий тег повинен раніше чи пізніше мати закриваючий тег з такою ж міткою. Так що наступне нелегальне:
[source,xml]
----
// Illegal XML
One <pod>, two <pod>, three <pod> zoo
----
Більше того, вміст любих двух парних тегів сам має бути валідним XML. Ви не можете мати дві пари тегів, які перекривають один одного:
[source,xml]
----
// Also illegal
<pod>Three <peas> in the </pod></peas>
----
Ви можете, однак, написати таке:
[source,xml]
----
<pod>Three <peas></peas> in the </pod>
----
Оскільки теги мають співпадати один з одним в такий спосіб, XML структурований як вкладені елементи. Кожна пара відповідних відкриваючих та закриваючих тегів формують елемент, та елементи можуть бути вкладені один в другий. В прикладі вище цілий `<pod>Three <peas></peas> in the </pod>` є елементом, `<peas></peas>` є елементом, вкладеним в перший.

Такі основи. Дві інші речі, які вам треба знати: перше, існує скорочена нотація для відкриваючого тега, за яким зразу іде закриваючий тег. Просто запишіть один тег з косою після мітки тегу. Такий тег складається з порожнього елементу. Використовуючи порожній елемент, попередній приклад може бути просто записаний таким чином:
[source,scala]
----
<pod>Three <peas/> in the </pod>
----
Друге, початковий тег може мати приєднані до нього атрибути. Атрибут є пара ім'я-значення, написана зі знаком рівності між ними. Ім'я атрибуту є простим, неструктурованим текстом, та значення оточене або подвійними (`""`) або поодинокими (`''`) лапками. Атрибути виглядають так: 
[source,xml]
----
<pod peas="3" strings="true"/>
----

28.3 XML літерали
-----------------
Scala дозволяє вам вбивати XML як літерал будь-де, де є валідним вираз. Просто набираєте початковий тег та потім продовжуєте писати XML вміст. Компілятор перейде в режим вводу XML та буде читати вміст XML доки не побачить закриваючий тег, що співпадає з тим, з якого ви почали:
[source,scala]
----
scala> <a>
          This is some XML.
          Here is a tag: <atag/>
       </a>
res0: scala.xml.Elem =
<a>
  This is some XML.
  Here is a tag: <atag/>
</a>
----
Результатом цього виразу є тип `Elem`, що означає елемент XML з міткою `a` та вмістом `"This is some XML...,"`. Деякі інші важливі XML класи:

* Клас `Node` є абстрактним суперкласом всіх класів вузлів XML.

* Клас `Text` є вузол, що містить лише текст. Наприклад, `"stuff"` що є частиною `<a>stuff</a>` має клас `Text`.

* Клас `NodeSeq` містить послідовність вузлів. Багато методів в XML бібліотеці обробляють `NodeSeqs` в місцях, де ви б могли очікувати, що вони обробляють окремі `Node`. Ви все ще можете використовувати такі методи з окремими вузлами, однак, оскільки `Node` є розширенням `NodeSeq`. Це може виглядати збочено, але це гарно робить для XML. Ви можете думати про окремі `Node`, як про одно-елементні `NodeSeq`.

Ви не обмежені виписувати точний XML який бажаєте, символ в символ. Ви можете обислити Scala код всередині XML дітерала, через використання фігурних дужок `{}` як виключення. Ось простий приклад:
[source,scala]
----
scala> <a> {"hello" + ", world"} </a>
res1: scala.xml.Elem = <a> hello, world </a>
----
Виключення фігурними дужками включає довільний Scala вміст, включаючи подальші XML літерали. Таким чином, по мірі зростання рівня вкладеності, ваш код може перемикатись між XML та звичайним Scala кодом.

Ось приклад:
[source,scala]
----
scala> val yearMade = 1955
yearMade: Int = 1955

scala>  <a> { if (yearMade < 2000) <old>{yearMade}</old>
              else xml.NodeSeq.Empty }
        </a>
res2: scala.xml.Elem =
<a> <old>1955</old>
  </a>
----
Якщо код в фігурних дужках обчислюється або до XML вузла, або до послідовності XML вузлів, ці вузли вставляються прямо як є. В прикладі вище, якщо `yearMade` меньше ніж `2000`, він огортається в теги `<old>`, та додається до елемента `<a>`. Інакше нічого не додається. Зауважте щодо прикладу вище, що "нічого" як XML вузол позначається `xml.NodeSeq.Empty`. Вираз виключення в фігурних дужках не має обчислюватись до вузла XML. Він може обчислюватись до любого значення Scala. В такому випадку результат буде перетворено на рядок, та вставлено як текстовий вузол:
[source,scala]
----
scala> <a> {3 + 4} </a>
res3: scala.xml.Elem = <a> 7 </a>
----
Любі символи `<`, `>` та `&` в тексті будуть виключені, якщо ви роздрукуєте вузол:
[source,scala]
----
scala> <a> {"</a>potential security hole<a>"} </a>
res4: scala.xml.Elem = <a> &lt;/a&gt;potential security
hole&lt;a&gt; </a>
----
Для контрасту, якщо ви створюєте XML з низькорівневими операціями з рядками, ви попадете в пастку, як наступна:
[source,scala]
----
scala> "<a>" + "</a>potential security hole<a>" + "</a>"
res5: String = <a></a>potential security hole<a></a>
----
Що тут відбувається, це що наданий користувачем рядок включає XML теги самі по собі, в цьому випадку `</a>` та `<a>`. Ця поведінка може дозволити деякі капосні сюрпризи для початкового програміста, оскільки дозволяє користувачеві впливати на результуюче дерево XML за межами простору, наданому для користувача в елементі `<a>`. Ви можете запобігти всьому цьому класу проблем, завжди конструюючи XML з використанням XML літералів, а не додавання рядків.

28.4 Сериалізація
-----------------
Тепер ви бачили досить щодо Scala підтримки XML, щоб написати першу частину серіалізатора: перетворення від внутрішніх структур даних до XML. Все що вам треба для цього, це XML літерали та їх виключення в фігурних дужках. 

Як приклад, уявімо, що ви реалізуєте базу даних, яка відстежує вашу екстенсивну колекцію вінтажних термометрів Coca-Cola. Ви можете зробити наступний внутрішній клас, що утримуватиме елементи каталогу:
[source,scala]
----
abstract class CCTherm {
  val description: String
  val yearMade: Int
  val dateObtained: String
  val bookPrice: Int // in US cents
  val purchasePrice: Int // in US cents
  val condition: Int // 1 to 10
  override def toString = description
}
----
Це прямолінійний, набитий даними клас, що містить різні частини інформації, такі, як де термометр було зроблено, коли ви його отримали, та скільки заплатили за нього. Щоб конвертувати примірники цього класу до XML, просто додайте метод `toXML`, що використовує XML літерали та виключення в фігурних дужках, ось так:
[source,scala]
----
abstract class CCTherm {
...
def toXML =
  <cctherm>
    <description>{description}</description>
    <yearMade>{yearMade}</yearMade>
    <dateObtained>{dateObtained}</dateObtained>
    <bookPrice>{bookPrice}</bookPrice>
    <purchasePrice>{purchasePrice}</purchasePrice>
    <condition>{condition}</condition>
  </cctherm>
}
----
Ось цей метод в дії:
[source,scala]
----
scala> val therm = new CCTherm {
        val description = "hot dog #5"
        val yearMade = 1952
        val dateObtained = "March 14, 2006"
        val bookPrice = 2199
        val purchasePrice = 500
        val condition = 9
      }
therm: CCTherm = hot dog #5

scala> therm.toXML
res6: scala.xml.Elem =
<cctherm>
  <description>hot dog #5</description>
  <yearMade>1952</yearMade>
  <dateObtained>March 14, 2006</dateObtained>
  <bookPrice>2199</bookPrice>
  <purchasePrice>500</purchasePrice>
  <condition>9</condition>
</cctherm>

NOTE: Вираз `new CCTherm` в попередньому прикладі робить, навіть якщо `CCTherm` є абстрактним класом, оскільки цей синтаксис насправді створює примірник анонімного субкласу `CCTherm`. Анонімні класи описані в Розділі 20.5.

Доречі, якщо ви бажаєте включити фігурні дужки `{` або `}` як XML текст, але не використовувати їх для виключення Scala коду, просто запишіть їх два рази поспіль: [source,scala]
----
scala> <a> {{{{brace yourself!}}}} </a>
res7: scala.xml.Elem = <a> {{brace yourself!}} </a>
----
28.5 Розбиття XML на частини
----------------------------
Серед багатьох методів, доступних для XML класів, існує щонайменьше три, про які вам слідує знати. Вони дозволяють вам розбити XML на частини, багато не думаючи щодо того, як саме в точності XML представлений в Scala. Ці методи базуються на мові XPath для обробки XML. Як взагалі в Scala, ви можете писати їх напряму в коді Scala, замість викликати зовнішній інструмент.

*Екстрагування тексту.* Через виклик метода `text` на любому вузлі XML ви отримуєте весь текст в вузлі, мінус тегі елементів:
[source,scala]
----
scala> <a>Sounds <tag/> good</a>.text
res8: String = Sounds good
----
Любі закодовані символи розкодуються автоматично:
[source,scala]
----
scala> <a> input ---&gt; output </a>.text
res9: String = " input ---> output "
----
*Екстрагування суб-елементів.* Якщо ви бажаєте знайти суб-елементи за іменем тегу, просто викличте `\` з ім'ям тегу:
[source,scala]
----
scala> <a><b><c>hello</c></b></a> \"b"
res10: scala.xml.NodeSeq = NodeSeq(<b><c>hello</c></b>)
----
Ви також можете зробити "глибокий пошук", щоб шукати в суб-елементах, і так далі, використовуючи оператор `\\` замість `\`:
[source,scala]
----
scala>
<a><b><c>hello</c></b></a> \"c"
res11: scala.xml.NodeSeq = NodeSeq()

scala> <a><b><c>hello</c></b></a> \\"c"
res12: scala.xml.NodeSeq = NodeSeq(<c>hello</c>)

scala> <a><b><c>hello</c></b></a> \"a"
res13: scala.xml.NodeSeq = NodeSeq()

scala> <a><b><c>hello</c></b></a> \\"a"
res14: scala.xml.NodeSeq =
NodeSeq(<a><b><c>hello</c></b></a>)
----

NOTE: Scala використовує `\` та `\\` замість `/` та `//` в XPath. Причина в тому, що `//` починає коментар в Scala! Таким чином мав використовуватись якійсь інший символ, і інші косі роблять добре.

*Екстракція атрибутів.* Ви можете екстрагувати атрибути тегу, використовуючі ті самі методи `\` та `\\`. Просто покладіть знак `at`
(`@`) перед ім'ям атрибуту:
[source,scala]
----
scala> val joe = <employee
          name="Joe"
          rank="code monkey"
          serial="123"/>
joe: scala.xml.Elem = <employee name="Joe" rank="code monkey"
 serial="123"/>

scala> joe \"@name"
res15: scala.xml.NodeSeq = Joe

scala> joe \"@serial"
res16: scala.xml.NodeSeq = 123
----

28.6 Десеаріалізація
--------------------
Використовуючи попередні методи для розбиття XML на частини, тепер ви можете написати пару до серіалізатора, парсер з XML знову назад до ваших внутрішніх структур даних. Наприклад, ви можете знови розбити примірник `CCTherm`, через використання наступного коду:
[source,scala]
----
def fromXML(node: scala.xml.Node): CCTherm =
  new CCTherm {
    val description = (node \"description").text
    val yearMade = (node \"yearMade").text.toInt
    val dateObtained = (node \"dateObtained").text
    val bookPrice = (node \"bookPrice").text.toInt
    val purchasePrice = (node \"purchasePrice").text.toInt
    val condition = (node \"condition").text.toInt
  }
----
Цей код шукає по вхідному вузлу XML на ім'я `node`, щоб знайти кожну з шести частин даних, потрібних щоб зібрати `CCTherm`. Дані, що є текстом, отримуються через `.text` та залишаються як є. Ось цей метод в дії:
[source,scala]
----
scala> val node = therm.toXML
node: scala.xml.Elem =
<cctherm>
  <description>hot dog #5</description>
  <yearMade>1952</yearMade>
  <dateObtained>March 14, 2006</dateObtained>
  <bookPrice>2199</bookPrice>
  <purchasePrice>500</purchasePrice>
  <condition>9</condition>
</cctherm>

scala> fromXML(node)
res17: CCTherm = hot dog #5
----
28.7 Загрузка та збереження
---------------------------
Є одна остання частина, потрібна для серіалізатора даних: перетворення між XML anта потоками даних. Ця остання частина є найпростішою, оскільки є бібліотечні процедури, що будуть робити все це за вас. Ви просто маєте викликати правильну процедуру на правильних даних.

Щоб конвертувати XML в рядок все що вам треба, це `toString`. Присутність робочого `toString` це те, чому ви можете експериментувати з XML в оболонці Scala. Однак краще використавувати бібліотетчні процедури, та конвертувати все підряд до байтів. Таки чином, результуючий XML може включати директиву, що вказує, яке кодування символів було використане. Якщо ви закодуєте рядок до байтів самі, тоді відповідальність за відстеження кодування символів лягає на вас.

Щоб конвертувати з XML до файлу з байтів, ви можете використовувати команду `XML.save`. Ви маєте задати ім'я файлу і вузол, що треба зберегти:
[source,scala]
----
scala.xml.XML.save("therm1.xml", node)
----
Після виконання команди вище, отриманий файл `therm1.xml` виглядає наступним чином:
[source,xml]
----
<?xml version='1.0' encoding='UTF-8'?>
<cctherm>
  <description>hot dog #5</description>
  <yearMade>1952</yearMade>
  <dateObtained>March 14, 2006</dateObtained>
  <bookPrice>2199</bookPrice>
  <purchasePrice>500</purchasePrice>
  <condition>9</condition>
</cctherm>
----
Завантаження простіше ніж збереження, оскільки файл містить все, що повинно знати завантажувачу. Просто викличте `XML.loadFile` з ім'ям файлу:
[source,scala]
----
scala> val loadnode = xml.XML.loadFile("therm1.xml")
loadnode: scala.xml.Elem =
<cctherm>
  <description>hot dog #5</description>
  <yearMade>1952</yearMade>
  <dateObtained>March 14, 2006</dateObtained>
  <bookPrice>2199</bookPrice>
  <purchasePrice>500</purchasePrice>
  <condition>9</condition>
</cctherm>

scala> fromXML(loadnode)
res14: CCTherm = hot dog #5
----
Those are the basic methods you need. There are many variations on these loading and saving methods, including methods for reading and writing to various kinds of readers, writers, input and output streams.

28.8 Порівняння шаблонів на XML
-------------------------------
Поки що ми бачили, як розділяти XML використовуючи `text` та методи, подібні до XPath `\` та `\\`. Вони гарні, коли ви знаєте точно, який тип структури XML ви розбиваєте на частки. Однак іноді існує декілька можливих структур, які може мати XML. Можливо багато різновидів записів з даними, наприклад, оскільки ви розширили вашу колекцію термометрів, щоб включити годинники та тарілки для сендвічів. Можливо ви просто бажаєте пропустити всі проміжки між тегами. З будь якої причини ви можете використовувати порівняння шаблонів для перемикання між можливостями.

Шаблон XML виглядає просто як XML літерал. Головна різниця в тому, що якщо ви вставляєте виключення `{}`, тоді код в `{}` не є виразом, але шаблоном. Шаблон, вставлений в `{}` може використовувати повну мову шаблонів Scala, включаючи прив'язку нових змінних, виконання перевірки типів, та ігнорування контенту з використанням шаблонів `_` та `_*`. Ось простий приклад:
[source,scala]
----
def proc(node: scala.xml.Node): String =
  node match {
    case <a>{contents}</a> => "It's an a: " + contents
    case <b>{contents}</b> => "It's a b: " + contents
    case _ => "It's something else."
  }
----  
Ця функція має перевірку шаблонів з трьома випадками. Перший випадок шукає елемент `<a>`, чий вміст складається з одного підвузла. Він прикліплює цей вміст до змінної на ім'я `contents`, та потім обчислює код зправа від асоційованої стрілки вправо (`=>`). Другий випадок робить те саме для `<b>` замість `<a>`, та третій випадок співпадає з будь-чим, що не співпало з іншими випадками. Ось ця функція в дії:
[source,scala]
----
scala> proc(<a>apple</a>)
res18: String = It's an a: apple

scala> proc(<b>banana</b>)
res19: String = It's a b: banana 

scala> proc(<c>cherry</c>)
res20: String = It's something else.
----
Скоріше всього, ця функція не саме те, що вам треба, тому що вона шукає точно такий вміст, що складається з одного субвузла в `<a>` або `<b>`. Таким чином вона буде хибити в випадках як наступний:
[source,scala]
----
scala> proc(<a>a <em>red</em> apple</a>)
res21: String = It's something else.

scala> proc(<a/>)
res22: String = It's something else.
----
Якщо ви бажаєте функцію, що співпадає з випадками, як цей, ви можете порівняти з послідовністю вузлів замість одного. Шаблон для "любої послідовності" XML вузлів записується `_*`. Візуально ця послідовність виглядає як підстановочний шаблон (`_`), за яким слідує regex-стильна зірочка Kleene (`*`). Ось оновлена функція, що порівнює послідовності субелементів, замість одного субелемента:
[source,scala]
----
def proc(node: scala.xml.Node): String =
  node match {
    case <a>{contents @ _*}</a> => "It's an a: " + contents
    case <b>{contents @ _*}</b> => "It's a b: " + contents
    case _ => "It's something else."
  }
----
Зауважте, що результат `_*` прикріплений до вмісту змінної через використання шаблону `@`, описаного в Розділі 15.2. Тут нова версія в дії:
[source,scala]
----
scala> proc(<a>a <em>red</em> apple</a>)
res23: String = It's an a: ArrayBuffer(a , <em>red</em>, apple)

scala> proc(<a/>)
res24: String = It's an a: WrappedArray()
----
Як фінальна підказка, майте на увазі, що шаблони XML роблять дуже гарно з виразами `for`, як шлях ітерувати по деяких частинах дерева XML, при цьому ігноруючі інші частини. Наприклад, уявімо, що ви бажаєте пропустити деякі проміжки між записами в наступній XML структурі:
[source,scala]
----
val catalog =
  <catalog>
    <cctherm>
      <description>hot dog #5</description>
      <yearMade>1952</yearMade>
      <dateObtained>March 14, 2006</dateObtained>
      <bookPrice>2199</bookPrice>
      <purchasePrice>500</purchasePrice>
      <condition>9</condition>
    </cctherm>
    <cctherm>
      <description>Sprite Boy</description>
      <yearMade>1964</yearMade>
      <dateObtained>April 28, 2003</dateObtained>
      <bookPrice>1695</bookPrice>
      <purchasePrice>595</purchasePrice>
      <condition>5</condition>
    </cctherm>
</catalog>
----
Візуально це виглядає як два елементи в елементі `<catalog>`. Однак насправді їх п'ять. Існує проміжок перед, після та між двома елементами! Якщо ви не приймете до уваги ці проміжки, ви можете некоретно обробити записи термометрів, таким чином:
[source,scala]
----
catalog match {
  case <catalog>{therms @ _*}</catalog> =>
    for (therm <- therms)
      println("processing: " +
              (therm ~"description").text)
}
processing:
processing: hot dog #5
processing:
processing: Sprite Boy
processing:
----
Зауважте рядки, де іде спроба обробити всі проміжки так, якби це були б дійсними записами термометрів. Що б ви дійсно бажали зробити, це ігнорувати ці проміжки, та обробляти тільки ті субвузли, що є всередині елементу `<cctherm>`. Ви можете описати цю підмножину, використовуючи шаблон `<cctherm>{_*}</cctherm>`, та ви можете обмежити вираз `for` до ітерації по елементах, що співпадають з шаблоном:
[source,scala]
----
catalog match {
  case <catalog>{therms @ _*}</catalog> =>
    for (therm @ <cctherm>{_*}</cctherm> <- therms)
      println("processing: " +
              (therm /"description").text)
}

processing: hot dog #5
processing: Sprite Boy
----

28.9 Висновок
-------------
Ця глава тільки подерла поверхню того, що можна робити за допомогою XML. Існує багато інших розширень, бібліотек та інструментів, про які ви можете знати, деякі з яких прилаштовані для Scala, деякі зроблені для Java, але корисні в Scala, та деякі мово-нейтральні. Що ми можемо винести з цієї глави, це як використовувати напів-структуровані дані для обміну, та як отримувати доступ до напів-структурованих даних через підтримку XML в Scala.