<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Програмування на Scala, 3тє видання</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Програмування на Scala, 3тє видання</h1>
<span id="author">Martin Odersky, Lex Spoon, Bill Venners</span><br />
<span id="revnumber">version 3.0,</span>
<span id="revdate">2016-12</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_______scala">Подяки за ранішні редакції Програмування на Scala</h2>
<div class="sectionbody">
<div class="quoteblock">
<div class="content">Програмування на Scala є, можливо, одною з кращих книжок з програмування, що я будь-коли читав. Мені подобається стиль написання, краткість та глибина викладення. Книжка, здається, відповідає на кожне запитання, як тілько воно спадає мені на думку - вона завжди на крок попереду мене. Автори не тільки надають деякий код та викладають речі як належне. Вони дають вам саму суть, так що ви дійсно розумієте що відбувається. Мені це дійсно подобається.</div>
<div class="attribution">
<em>Chief Software Architect</em><br />
&#8212; Ken Egervari
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala написано ясно, глибоко, та їй легко слідувати. Вона має чудові приклади та сповнена чудовими підказками. Вона дозволила нашій організації опанувати мову Scala швидко та ефективно. Ця книжка чудова для кожного програміста, хто намагається налаштувати свою голову на гнучкість та елегантність мови Scala.</div>
<div class="attribution">
<em>власник Morroni Technologies Inc.</em><br />
&#8212; Larry Morroni
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala служить як чудовий туторіал по мові Scala. Просування по книзі іде гладко, де кожна глава будується на концепціях та прикладах, описаних в попередніх главах. Книга турбується про глибоке пояснення конструкцій мови, часто провадячи приклади того, як мова відрізняється від Java. Так само, як і головна мова, також є деяке покриття бібліотек, як контейнери та актори. Я знайшов книгу простою до проробки, і це, можливо, одна з кращих написаних технічних книжок, що я читав останні часом. Я справді можу рекомендувати цю книжку любому програмісту, що бажає знайти більше щодо мови Scala.</div>
<div class="attribution">
&#8212; Matthew Todd
</div></div>
<div class="quoteblock">
<div class="content">Я здивований зусиллями, здісненими авторами Програмування на Scala. Ця книга є неоціненним керівництвом до того, що я називаю платформою Scala: рушій до кращого кодування, постійне натхнення до розробки та реалізації маштабованого програмного забезпечення. Якби я тільки мав Scala в її сучасному зрілому стані, та цю книжку в далекому 2003му році, коли я спів-розробляв та реалізував частини інфраструктури порталу Олімпійськіх Ігор 2004 в Афінах! Всім читачам: не важливо, який ваш програмістській бекграунд, я відчуваю ви знайдете програмування на Scala вивільняючим, та ця книга буде вірним другом в цій подорожі.</div>
<div class="attribution">
<em>Software Consultant & Researcher</em><br />
&#8212; Christos KK Loverdos
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala є довершеним глибинним вступом до Scala,та це також чудове посилання. Я хочу сказати, що вона займає видатне місце на моїй книжній полиці, і крім цього я все ще ношу її з собою майже будь-де, куди я іду.</div>
<div class="attribution">
<em>президент ArdenTex</em><br />
&#8212; Brian Clapper
</div></div>
<div class="quoteblock">
<div class="content">Чудова книга, гарно написана з осмисленими прикладами. Я можу рекомендувати її як для досвідчених програмістів, так і для початківців.</div>
<div class="attribution">
&#8212; Howard Lovatt
</div></div>
<div class="quoteblock">
<div class="content">Книга Програмування на Scala не тільки про те, як, але, більш важливо, чому слід розробляти програми на цій новій мові програмування. Прагматичний підхід в введені до потужності комбінування об'єктно-орієнтовного та функціонального програмування, залишає читача без жодних сумнівів, чим насправді є Scala.</div>
<div class="attribution">
<em>CEO/засновник EXPRO I.T. & консультант</em><br />
&#8212; Dr. Ervin Varga
</div></div>
<div class="quoteblock">
<div class="content">Це чудове введення до функціонального програмування для ОО програмістів. Навчання щодо ФП було моєю головною ціллю, але я також познайомився з деякими милими сюрпризами Scala, як кейс класи та порівняння шаблонів. Scala є інтригуючою мовою, та ця книжка гарно розмовідає про це. Завжди є гарна лінія, вздовж якої треба іти в книжці вступу до мови, між надання дуже багато, та нестачею достатньої інформації. Я знайшов, що Програмування на Scala досягла ідеального балансу.</div>
<div class="attribution">
<em>Programmer Analyst</em><br />
&#8212; Jeff Heon
</div></div>
<div class="quoteblock">
<div class="content">Я придбав ранішню електронну версію книжки Програмування на Scala від Odersky, Spoon та Venners, та безпосередньо став фанатом. На додаток до факту, що вона містить найбільш всеосяжну інформацію щодо мови, існує декілька ключових особливостей електронного формату, що вразили мене. Я ніколи не бачив посилань в PDF, що служать не тільки для закладок, але також провадять активні посилання з таблиці змісту та індексів. Я не знаю, чому більше авторів не використовують цю можливість, оскільки це дійсно радість для читача. Інша можливість, якою я був вражений, були посилання на форуми ("Discuss"), та спосіб надсилати коментарі ("Suggest") до авторів по електронній пошті. Можливість коментувати сама по собі не є незвичною, але проста вставка номера сторінки, що генерується для надсилання авторам, є важливою для обох, авторів та читачів. Я доклав більше коментарів, ніж я мав би, якби процес був би більш важкий. Читайте Програмування на Scala заради вмісту, але якщо ви читаєте електронну версію, обов'язково отримайте переваги від цифрових можливостей, які автори подбали вбудувати в книжку!</div>
<div class="attribution">
<em>засновник/консультант SRT Solutions</em><br />
&#8212; Dianne Marsh
</div></div>
<div class="quoteblock">
<div class="content">Ясність та технічна повнота є відзнакою любої гарно написаної книжки, та я вітаю Martin
Odersky, Lex Spoon та Bill Venners з тим, що вони зробили цю роботу дуже гарно! Книжка Programming in Scala починається з встановлення гарного фундаменту з базовими концепціями,та просуває користувача на середній рівень, та далі. Ця книга беззаперечно обов'язкова для придбання для кожного, що прагне вивчити Scala.</div>
<div class="attribution">
<em>Enterprise Architecture & GMAC Financial Services</em><br />
&#8212; Jagan Nambi
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala приємно читається. Це одна з тих гарно написаних технічних книжок, що провадять глибоке та повне покриття предмету в екстремально стислій та елегантній манері. Книга організована в дуже природний та логічний спосіб. Вона однаково гарно пристосована для зацікавлених технологістів, які просто бажають залишатись на піці поточних трендів, та професіоналів, що шукають глибокого розуміння основних можливостей  мови, та обгрунтувань її дизайну. Я дуже рекомендую її всім зацікавленим в фіункціональному програмуванні взагалі. Для розробників Scala ця книга безумовно є обов'язковою для читання.</div>
<div class="attribution">
<em>Software Architect/Lead Programmer @ Greystone Inc.</em><br />
&#8212; Igor Khlystov
</div></div>
<div class="quoteblock">
<div class="content">Книжка Програмування на Scala прямо точиться кількістю важкої роботи, що пішла до неї. Я ніколи до цього не читав книжку в стилі туторіала, що виконує роль вступу, і при цьому є повною: в їх (помилковій) спробі бути доступними, та не "засмучувати" читача, більшість туторіалів замовчують аспекти предмета, що дуже просунутий для поточного обговорення. Це залишає дуже поганий присмак, бо ніхто не може бути впевнений, якого розуміння ви вже досягли. Завжди існує деяка залишкова "магія", що не була пояснена, та  взагалі не може бути зрозумілою читачеві. Ця книжка нуколи не робить цього, вона нічого не приймає на віру: кожна деталь або достатньо пояснена, або надається посилання на подальше пояснення. Дійсно, текст екстенсивно посилається на себе та індексований, так що формує повну картину складної теми відносно просто.</div>
<div class="attribution">
<em>Enterprise Java Architect</em><br />
&#8212; Gerald Loeffler
</div></div>
<div class="quoteblock">
<div class="content">Програмування на Scala від Martin Odersky, Lex Spoon та Bill Venners: в часи, коли гарні книжкі є рідкістю, це чудове введення для програмістів середнього рівня дійсно є винятнковим. Ви знайдете тут все, щоб вивчити цю мову програмування.</div>
<div class="attribution">
&#8212; Christian Neukirchen
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>Programmmin in Scala, Third Edition
Martin Odersky, Lex Spoon, Bill Venners
Artima Press
Walnut Creek, California
   Martin Odersky є створювачем мови Scala та професором EPFL in Lausanne, Switzerland.
   Lex Spoon робив над Scala протягом двох років разом з Martin Odersky.
   Bill Venners є президентом Artima, Inc.</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_">Передмова</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви обрали чудовий час взяти до рук цю книгу! Сприйняття Scala продовжує пришвидшуватись, наша спільнота вирує, та навкола пропозиції роботи. Чи ви програмуєте для розваги чи для прибутку (або обоє), обіцяна Scala радість та продуктивність робить супротив складним. Щодо мене, дійсна радість програмування походить від протистояння цікавим викликам, за допомогою простих, витончених рішень. Місія Scala не тільки в тому, щоб зробити це можливим, але приємним, і ця книга покаже вам як.</p></div>
<div class="paragraph"><p>Зпочатку я експериментував з Scala 2.5, та миттєво був втугнутий в її синтаксичну та концептуальну впорядкованість. Коли я натрапив на нерегулярність, що параметри типів самі не можуть мати параметри типів, я (боязко) підійшов до Martin Odersky на конференції в 2006, та запронував стажування, щоб позбутись цього обмеження. Моя контриб'юція була сприйнята, що привнесло підтримку поліморфізм конструкторів типів в Scala 2.7 та вище. З тих пір я робив над більшістю інших частин компілятора. В 2012 я пішов з пост-докторської практики в лабораторії Martin на керівника команди Scala в Typesafe, по мірі того, як Scala, з версією 2.10, подорослішала від своїх прагматичних академічних коренів до надійної мови рівня корпорації.</p></div>
<div class="paragraph"><p>Scala 2.10 була поворотною точкою від швидко розвинених, багатих можливостями релізів, базованих на академічних дослідах, в напрямку фокусування на спрощенні та збільшенні прийняття адаптації підприємствами. Ми змістили нашу увагу на проблеми, які неможливо описати в дисертаціях, такі, як бінарна сумісність між головними релізами. Щоб збалансувати стабільність з нашим бажанням продовжувати розробку та покращення платформи Scala, ми робимо в напрямку меньшої головної бібліотеки, яку ми збираємось стабілізувати, при цьому розвиваючи платформу як ціле. Щоб зробити це можливим, мій перший проект в якості технічного керівника Scala був початок модулярізації стандартної бібліотеки Scala в 2.11.</p></div>
<div class="paragraph"><p>Щоб зменшити частоту змін, Typesafe також вирішила поперемінно змінювати бібліоттеку та компілятор. Ця редакція Програмування на Scala відноситься до Scala 2.12, що буде релізом компілятора, який матиме новий бек-енд та оптимізатор, щоб отримати більше від нових можливостей Java 8. Для взаємодії з Java, та насолодження тими ж перевагами від оптимізації JVM, Scala компілює функції в той самий байткод, що і компілятор Java 8. Подібно, трейти Scala тепер компілюються в інтерфейси Java з методами по замовчанню. Обоє схеми компіляції зменшують магію, яку мали виконувати старіші компілятори Scala, більш тісно наближаючи нас до платформи Java, при цьому покращуючи обоє, час компіляції та продуктивність часу виконання, з гладшою бінарною сумісністю!</p></div>
<div class="paragraph"><p>Це покращення до платформи Java 8 дуже захоалююче для Scala, та це дуже приємно бачити, що Java рівняється на тренд, який Scala встановлювала протягом дисятиріччя! Без жодного сумніву, що Scala провадить значно більш функціональний досвід програмування, з незмінністю по замовчанню, уніформним трактуванням виразів (навряд чи в цій книзі можливо побачити твердження return), співпадіння шаблонів, варіативність в місці визначення (варіативність в місці використання Java робить створення субтипів функції незграбним), і так далі! Кажучи прямо, існує дещо в функціональному програмуванні, ніж милий синтаксис для лямбди.</p></div>
<div class="paragraph"><p>В якості розпорядників мови, наша ціль є розробляти основу мови, так само, як зрощувати екосистему. Scala є успішною, оскільки вона має багато чудових бібліотек, видатні IDE та інструменти, та дружніх і завжди готових допомогти членів нашої спільноти. Я глибоко насолоджуюсь своєю першою декадою зі Scala — як реалізатор мови, це є великим збудженням і натхненням бачити стільки програмістів, що насолоджуються Scala в безлічі напрямків.</p></div>
<div class="paragraph"><p>Я люблю програмувати на Scala, і маю надію ви полюбите також. Від імені спільноти Scala вітаю вас!</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Adriaan Moors
San Francisco, CA
January 14, 2016</code></pre>
</div></div>
<div class="sect1">
<h2 id="__2">Подяки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато людей доклали до цієї книги, та до матеріалів, які вона розкриває. Ми вдячні всім їм.</p></div>
<div class="paragraph"><p>Scala сама по собі була колективним зусиллям багатьох людей. Розробці та реалізації версії 1.0 допомагали Philippe Altherr, Vincent Cremet, Gilles Dubochet, Burak Emir, Stéphane Micheloud, Nikolay Mihaylov, Michel Schinz, Erik Stenman та Matthias Zenger. Phil Bagwell, Antonio Cunei, Iulian Dragos, Gilles Dubochet, Miguel Garcia, Philipp Haller, Sean McDirmid, Ingo Maier, Donna Malayeri, Adriaan Moors, Hubert Plociniczak, Paul Phillips, Aleksandar Prokopec, Tiark Rompf, Lukas Rytz та Geoffrey Washburn приєднали зусилля для розробки другої та поточної версії мови та інструментів.</p></div>
<div class="paragraph"><p>Gilad Bracha, Nathan Bronson, Caoyuan, Aemon Cannon, Craig Chambers, Chris Conrad, Erik Ernst, Matthias Felleisen, Mark Harrah, Shriram Krishnamurti, Gary Leavens, David MacIver, Sebastian Maneth, Rickard Nilsson, Erik Meijer, Lalit Pant, David Pollak, Jon Pretty, Klaus Ostermann, Jorge Ortiz, Didier Rémy, Miles Sabin, Vijay Saraswat, Daniel Spiewak, James Strachan, Don Syme, Erik Torreborre, Mads Torgersen, Philip Wadler, Jamie Webb, John Williams, Kevin Wright та Jason Zaugg окреслили дизайн мови, щедро подоілившись своїми ідеями з нами в живих та надихаючих дискусіях, через контриб'юцію важливих частин коду до зусиль відкритого коду, так само, як і через коментарі до попередніх версій цього документу. Дописувачі в список розсилки Scala також надали дуже корисний зворотній зв'язок, що допоміг нам покращити мову та інструменти.</p></div>
<div class="paragraph"><p>George Berger працював наполегливо, щоб зробити процес побудови та веб присутність книги роблячими гладко. Як результат, цей проект був чудово вільний від технічних непередбачуваностей.</p></div>
<div class="paragraph"><p>Багато людей надали нам цінний зворотній зв'язок щодо ранішніх версій цього тексту. Подяки надходять до Eric Armstrong, George Berger, Alex Blewitt, Gilad Bracha, William Cook, Bruce Eckel, Stéphane Micheloud, Todd Millstein, David Pollak, Frank Sommers, Philip Wadler, and Matthias Zenger. Також дякуємо до групи Silicon Valley Patterns, за їх дуже корисний огляд: Dave Astels, Tracy Bialik, John Brewer, Andrew Chase, Bradford Cross, Raoul Duke, John P. Eurich, Steven Ganz, Phil Goodwin, Ralph Jocham, Yan-Fa Li, Tao Ma, Jeffery Miller, Suresh Pai, Russ Rufer, Dave W. Smith, Scott Turnquest, Walter Vannini, Darlene Wallach та Jonathan Andrew Wolter. Та нам приємно подякувати Dewayne
Johnson та Kim Leedy за їх допомогу з оформленням обкладинки, та Frank Sommers за його роботу з індексом.</p></div>
<div class="paragraph"><p>Нам також приємно поширити особливі подяки всім нашим читачам, що надали коментарі. Ваші коментарі дуже корисні для нас в окресленні цієї, навіть кращої книжки. Ми не можемо надрукувати імена всіх, хто надіслав коментарі. але ось імена тих читачів, які надіслали щонайменьше п'ять коментарів на протязі стадії eBook PrePrint®, через клацання на посиланні Suggest, впорядковані від найбільшого загального числа надісланих коментарів, та потім за алфавітом. Подякі до: David Biesack, Donn Stephan, Mats Henricson, Rob Dickens, Blair Zajac, Tony Sloane, Nigel Harrison, Javier Diaz Soto, William Heelan, Justin Forder, Gregor Purdy, Colin Perkins, Bjarte S. Karlsen, Ervin Varga, Eric
Willigers, Mark Hayes, Martin Elwin, Calum MacLean, Jonathan Wolter, Les Pruszynski, Seth Tisue, Andrei Formiga, Dmitry Grigoriev, George Berger, Howard Lovatt, John P. Eurich, Marius Scurtescu,Jeff Ervin, Jamie Webb, Kurt Zoglmann, Dean Wampler, Nikolaj Lindberg, Peter McLain, Arkadiusz Stryjski, Shanky Surana, Craig Bordelon, Alexandre Patry, Filip Moens, Fred Janon, Jeff Heon, Boris Lorbeer, Jim Menard, Tim Azzopardi, Thomas Jung, Walter Chang, Jeroen Dijkmeijer, Casey Bowman, Martin Smith, Richard Dallaway, Antony Stubbs, Lars Westergren, Maarten Hazewinkel, Matt Russell, Remigiusz Michalowski, Andrew Tolopko, Curtis Stanford, Joshua Cough, Zemian Deng, Christopher Rodrigues Macias, Juan Miguel Garcia Lopez, Michel Schinz, Peter Moore, Randolph Kahle, Vladimir Kelman, Daniel Gronau, Dirk Detering, Hiroaki Nakamura, Ole Hougaard, Bhaskar Maddala, David Bernard, Derek Mahar, George Kollias, Kristian Nordal, Normen Mueller, Rafael Ferreira, Binil
Thomas, John Nilsson, Jorge Ortiz, Marcus Schulte, Vadim Gerassimov, Cameron Taggart, Jon-Anders Teigen, Silvestre Zabala, Will McQueen та Sam Owen.</p></div>
<div class="paragraph"><p>Ми також бажаемо подякувати тим, хто надіслав коментарі та помилки після друку перших двох видань, включаючи Felix Siegrist, Lothar Meyer-Lerbs, Diethard Michaelis, Roshan Dawrani, Donn Stephan, William Uther, Francisco Reverbel, Jim Balter, and Freek de Bruijn, Ambrose Laing, Sekhar Prabhala, Levon Saldamli, Andrew Bursavich, Hjalmar Peters, Thomas Fehr, Alain O&#8217;Dea, Rob Dickens, Tim Taylor, Christian Sternagel, Michel Parisien, Joel Neely, Brian McKeon, Thomas Fehr, Joseph Elliott, Gabriel da Silva Ribeiro, Thomas Fehr, Pablo Ripolles, Douglas Gaylor, Kevin Squire, Harry-Anton Talvik, Christopher Simpkins, Martin Witmann-Funk, Jim Balter, Peter Foster, Craig Bordelon, Heinz-Peter Gumm, Peter Chapin, Kevin Wright, Ananthan Srinivasan, Omar Kilani, Donn Stephan, Guenther Waffler.
Lex would like to thank Aaron Abrams, Jason Adams, Henry and Emily Crutcher, Joey Gibson, Gunnar Hillert, Matthew Link, Toby Reyelts, Jason Snape, John та Melinda Weathers, та всім членам Atlanta Scala Enthusiasts за багато корисних дискусій щодо розробки мови, її матеатичних засадах, та як презентувати Scala працюючим інженерам.</p></div>
<div class="paragraph"><p>Спеціальна подяка для Dave Briccetti та Adriaan Moors за огляд третього видання, та до Marconi Lanna за не тільки огляд, але за надання мотивації для третього видання, надаючи розмову, озаглавлену "Що нового з часів Програмування на Scala."</p></div>
<div class="paragraph"><p>Bill має подякувати Gary Cornell, Greg Doench, Andy Hunt, Mike Leonard, Tyler Ortman, Bill
Pollock, Dave Thomas та Adam Wright за провадження розуміння та поради по друку книжки. Bill також дякує Dick Wall за взаємодію над курсом Escalate Stairway to Scala, що значною частиною базується на цій книжці. Наші багато років досвіду викладання Stairway to Scala допомогло зробити цю книжку краще. Нарешті, Bill має подякувати Darlene Gruendl та Samantha Woolf за їх допомогу в тому, щоб третє видання було закінчене.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__3">Вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця книжка є туторіалом по мові програмування Scala, написану людьми, напряму причетними до розробки Scala. Наша ціль полягає в тому, щоб читаючи цю книжку ви могли навчитись всьому, що треба, щоб бути продуктивним Scala програмістом. Всі приклади в цій книжці компілюються за допомогою Scala версії 2.11.7, за винятком тих, що відмічені 2.12, що компілюються за допомогою 2.12.0-M3.</p></div>
<div class="sect2">
<h3 id="_____">Кому слідує читати цю книжку</h3>
<div class="paragraph"><p>Головна цільова аудієнція для цієї книжки є програмісти, які бажають навчитись програмуванню на Scala. Якщо ви бажаєте робити ваш наступний проект на Scala, тоді ця книжка для вас. На додаток, книжка має бути цікавою для програмістів, що бажають розширити свої горизонти через навчання нових концепцій. Наприклад, якщо ви Java програміст, читання цієї книжки відкриє вас до багатьох концепцій з функціонального програмування, так само, як просунутих об'єктно-орієнтовних ідей. Ми віримо, що навчання  Scala, та стоячих за нею ідей, може допомогти стати кращим програмістом, загалом.</p></div>
<div class="paragraph"><p>Передбачається загальне знання програмування. Хоча Scala є гарною першою мовою програмування, це не книжка для навчання програмуванню.</p></div>
<div class="paragraph"><p>З іншого боку, ніякого спеціального знання мов програмування не потрібне. Навіть якщо більшість людей використовують Scala на платформі Java, ця книга не очікує, що ви знаєте щось про Java. Однак ми очікуємо, що багато читачів будуть знайомі з Java, так що часом порівнюємо Scala з Java, щоб допомогти таким читачам розуміти відмінності.</p></div>
</div>
<div class="sect2">
<h3 id="____">Як використовувати цю книгу</h3>
<div class="paragraph"><p>Оскільки головне призначення цієї книжки служити туторіалом, рекомендований спосіб читати цю книгу в порядку глав, зпочатку до кінця. Ми дуже намагались викладати одну тему за раз, та пояснюємо нові теми тільки в термінах тем, що ми вже розглянули. Таким чином, якщо ви пересунетесь в кінець, що скоріше підхопити щось, ви можете винайти, що це пояснено в термінах концепцій, що ви не зовсім розумієте. Доки ви читаєте глави по порядку, ми вважаємо, що ви знайдете досить прямолінійним отримати знання в Scala, по одному кроку за раз.</p></div>
<div class="paragraph"><p>Якщо ви бачите невідомий вам термін, будьте певні, що перевірили глосарій та індекс. Багато читачів будуть швидко переглядати частини книжки, і це непогано. Глосарій та індекс можуть допомогти вам надолужити, якщо ви проскочили щось дуже швидко.</p></div>
<div class="paragraph"><p>Після того, як ви прочитали книжку один раз, вона може також служити посиланням мови. Існує формальна специфікація мови Scala, але специфікація мови намагається бути точною, ціною читабельності. Хоча ця книга не покриває кожної деталі Scala, вона досить повна, та може служити як доступне посилання до мови, по мірі як ви ставатимете більш адаптованим в програмуванні Scala.</p></div>
</div>
<div class="sect2">
<h3 id="___scala">Як навчатись Scala</h3>
<div class="paragraph"><p>Ви можете багато чому навчитись про Scala, просто читаючи цю книжку від корки до корки. Однак, ви можете навчитись Scala швидше та більш глибоко, якщо зробите декілька додаткових речей.</p></div>
<div class="paragraph"><p>Зпершу, ви можете отримати вигоду від багатьох прикладів програм, включених в цю книжку. Набираючи їх самотужки є шляхом змісити ваші думки проходити через кожний рядок коду. Пробуючи варіації є шляхом зробити це більш веселим, та переконатись, що ви дійсно розумієте, як вони працюють.</p></div>
<div class="paragraph"><p>Друге, пристаньте до багатьох онлайн форумів. Таким чином ви та інші інтузіасти Scala можете допомагати один одному. Є багато списків розсилки, дискусійних форумів, чат кімнат, wiki, та декілька Scala-специфічних фідів статей. Витратьте деякий час для пошуку такого, що задовільняє вашим інформаційним потребам. Ви будете витрачати значно меньше часу за вирішенням простих проблем, так що ви зможете витрачати час на глибші, більш важливі питання.</p></div>
<div class="paragraph"><p>Нарешті, коли ви прочитаєте досить, оберіть собі власний програмний проект. Робіть над малою програмою від початку, або розробляйте додаток до більшої програми. Ви можете зайти тільки так далеко, читаючи.</p></div>
</div>
<div class="sect2">
<h3 id="__ebook">Можливості eBook</h3>
<div class="paragraph"><p>Ця книжка доступна в обох, паперовій формі та PDF eBook. eBook не просто електронна копія паперової версії книжки. Хоча вміст той самий, що і в паперовій версії, eBook була прискіпливо розроблена та оптимізована для читання на комп'ютерному екрані.</p></div>
<div class="paragraph"><p>Перша річ, що треба зауважити, це що більшість посилань в eBook і гіперпосиланнями. Якщо ви виберете главу, малюнок, або елемент глосарію, ваш PDF переглядач  повинене перенести вас прямо до обраного елементу, так що вам не знадобиться гортати, щоб знайти його.</p></div>
<div class="paragraph"><p>Додатково, знизу кожної сторінки в eBook є декілька навігаційних посилань. Посилання Обкладинка, Огляд та Вміст перенесуть вас на вступні сторінки книжки. Глосарій та Індекс посилаються на частини посилань книжки. Нарешті, посилання Обговорення перенесе вас до онлайн форуму, де ви обговорюєте питання з другими читачами, авторами та ширшою спільнотою Scala. Якщо ви знайдете помилку друку, або щось, що ви вважаєте має пояснюватись краще, будь ласка клацніть на посилання Зауваження, що перенесе вас до онлайн веб застосування, де ви можете надати зворотній зв'язок авторам.</p></div>
<div class="paragraph"><p>Хоча та сама сторінка з'являється в eBook як і в друкованій книжці, порожні сторінки видалені, та залишені сторінки перенумеровані. Сторінки пронумеровані по-різному, так що вам простіше визначати номери сторінок PDF при друці тільки частини eBook. Таким чином, сторінки в eBook є нумеровані саме так, як їх нумероватиме PDF переглядач.</p></div>
</div>
<div class="sect2">
<h3 id="__">Типографічні домовленості</h3>
<div class="paragraph"><p>Перший раз, коли визначається <em>термін</em>, він виділяється прописом. Малий приклад коду як  <code>x + 1</code>, записується інлайн моноширинним шрифтом. Більші приклади коду покладаються в моноширинні блоки запозичень, як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">hello</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли показується інтерактивна оболонка, відповіді від оболонки показуються легшим шрифтом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>scala&gt; <span class="m">3</span> + <span class="m">4</span>
res0: <span class="nv">Int</span> <span class="o">=</span> <span class="m">7</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Огляд вмісту</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Глава 1 "Маштабована мова", надає вам огляд дизайну Scala, разом з міркуваннями, історією, що стоять за нею.
</p>
</li>
<li>
<p>
Глава 2 "Перші кроки в Scala", показує вам, як робити декілька базових завдань програмування в Scala, не вдаючись в великі деталі щодо того, як воно робить. Ціль цієї глави є змусити ваші пальці почати друкувати та виконувати код Scala.
</p>
</li>
<li>
<p>
Глава 3 "Наступні кроки в Scala", показує вам декілька більш базових програмних завдань,  що будуть допомагати вам швидко набрати темп в Scala. Після завершення цієї глави, ви повинні бути в змозі почати використовувати Scala для простих скриптових задач.
</p>
</li>
<li>
<p>
Глава 4 "Класи та об'єкти", розпочинає глибинне покриття Scala з визначення його базових об'єктно-орієнтованих будівельних блоків та інструкцій щодо того, як компілювати та виконувати застосування Scala.
</p>
</li>
<li>
<p>
Глава 5 "Базові типи та операції", розкриває базові типи Scala, їх літерали, операції, що ви можете виконувати з ними, як роблять преоритети та асоційованість, та що таке збагачені обертки.
</p>
</li>
<li>
<p>
Глава 6 "Функціональні обертки", занурюється більш глибоко в об'єктно-орієнтовні можливості Scala, використовуючи функціональні (тобто незмінні) раціональні числа в якості приклада.
</p>
</li>
<li>
<p>
Глава 7 "Вбудовані керівні структури", показує вам, як використовувати вбудовані структури керування Scala: if, while, for, try, та match.
</p>
</li>
<li>
<p>
Глава 8 "Функції та замикання", провадить глибинне пояснення функцій, базових будівельних блоків функціональних мов.
</p>
</li>
<li>
<p>
Глава 9 "Керівні абстракції", показує, як розширювати базові керуючі структури Scala через визначення ваших власних керівних абстракцій.
</p>
</li>
<li>
<p>
Глава 10 "Композиція та наслідування", обговорює більше з підтримки Scala об'єктно-орієнтовного програмування. Теми не такі фундаментальні, як ті що в Главі 4, але вони часто постають на практиці.
</p>
</li>
<li>
<p>
Глава 11 "Ієрархія Scala", пояснює ієрархію наслідування Scala, та обговорює її універсальні методи та нижні типи.
</p>
</li>
<li>
<p>
Глава 12 "Трейти", розказує про механізм Scala для міксін композиції. Глава показує, як роблять трейти, описує загальні використання, та пояснює, як трейти покращують традиційне множинне наслідування.
</p>
</li>
<li>
<p>
Глава 13 "Пакунки та імпорти", обговорює проблеми програмування в широкому сенсі, включаючи пакунки вищого рівня, твердження імпорту, та модифікатори контроля доступа, як <code>protected</code> та <code>private</code>.
</p>
</li>
<li>
<p>
Глава 14 "Твердження та тести", показує механізм тверджень Scala, та надає тур по декількох інструментах для написання тестів в Scala, зокрема фокусуючись на ScalaTest.
</p>
</li>
<li>
<p>
Глава 15 "Кейс класи та співпадіння шаблонів", вводять конструкції-близьнюки, що підтримують вас при написанні регулярних, неінкапсульованих структур даних. Кейс класи та співпадіння шаблонів зокрема корисні для дерево-подібних рекурсивних даних.
</p>
</li>
<li>
<p>
Глава 16 "Робота зі списками", пояснює в деталях списки, що, можливо, найбільш загально уживані структури даних в програмах Scala.
</p>
</li>
<li>
<p>
Глава 17 "Робота з іншими колекціями", показує вам, як використовувати базові колекції Scala, такі як списки, масиси, кортежі, множини та мапи.
</p>
</li>
<li>
<p>
Глава 18 "Змінні об'єкти", пояснює змінні об'єкти, та синтаксис, що провадить Scala для їх вираження. Глава завершується практичним заняттям на симуляцію дискретних подій, що показує деякі змінні об'єкти в дії.
</p>
</li>
<li>
<p>
Глава 19 "Типова параметризація", пояснює деякі з прийомів для приховування інформації, введеної в Главі 13 з допомогою конкретного прикладу: розробкою класу для чисто функціональних черг. Глава будується до визначення варіантності типових параметрів, та як це взаємодіє з приховуванням інформації.
</p>
</li>
<li>
<p>
Глава 20 "Абстрактні члени", описує всі типи абстрактних членів, як підтримує Scala; не тільки методи, але також поля та типи, можуть бути декларовані як абстрактні.
</p>
</li>
<li>
<p>
Глава 21 "Неявні переткорення та параметри", розкриває дві конструкції, що можуть допомогти вам оминути нудних деталей джерельного коду, та дозволяючи компілятору надати їх замість цього.
</p>
</li>
<li>
<p>
Глава 22 "Реалізація списків", описує реалізацію класу List. Важливо розуміти, як списки роблять в Scala, і більше того, реалізація демонструє використання деяких можливостей Scala.
</p>
</li>
<li>
<p>
Глава 23 "Переосмислені вирази for", показує як вирази for транслюються на виклики map, flatMap, filter та foreach.
</p>
</li>
<li>
<p>
Глава 24 "Колекції поглиблено", Надає детальний тур по бібліотеці колекцій.
</p>
</li>
<li>
<p>
Глава 25 "Архитектура колекцій Scala", показує як побудована бібліотека колекцій, та як ви можете реалізувати свої власні колекції.
</p>
</li>
<li>
<p>
Глава 26 "Екстрактори", показує, як робити співпадіння шаблонів з довільними класами, не тільки з кейс класами.
</p>
</li>
<li>
<p>
Глава 27 "Анотації", показує, як робити з розширенням мови через анотації. Глава описує декілька стандартних анотацій, та показує, як робити ваші власні.
</p>
</li>
<li>
<p>
Глава 28 "Робота з XML", пояснює, як обробляти XML в Scala. Глава показує вам ідіоми генерації XML, його розбір, та обробку, коли він вже розібраний.
</p>
</li>
<li>
<p>
Глава 29 "Модулярне програмування з використанням об'єктів", показує, як ви можете використовувати об'єкти Scala як модульну систему.
</p>
</li>
<li>
<p>
Глава 30 "Еквівалентність об'єктів", вказує на деякі проблеми, які треба розглядати, коли пишете метод <code>equals</code>. Є декільки ловушок, що треба уникнути.
</p>
</li>
<li>
<p>
Глава 31 "Комбінація Scala та Java", обговорює проблеми, що постають, коли комбінуєте Scala та Java разом в одному проекті, та рекомендовані методи щодо їх подолання.
</p>
</li>
<li>
<p>
Глава 32 "Ф'ючерси та конкурентність", показує вам, як використовувати Scala Future. Хоча ви можете використовувати примітиви конкуренції платформи Java для Scala програм, ф'ючерси можуть допомогти вам уникнути мертвого блокування та стану гонок, що зачумлюють традиційний підхід "потоки та блокування" до конкуренції.
</p>
</li>
<li>
<p>
Глава 33 "Комбінаторний розібр", показує, як побудувати парсери з використанням бібліотеки Scala парсерних комбінаторів.
</p>
</li>
<li>
<p>
Глава 34 "Програмування користувацького інтерфейсу", надає швидкий тур бібліотеки Scala, що спрощує програмування GUI за допомогою Swing.
</p>
</li>
<li>
<p>
Глава 35 "Електронна таблиця SCells", зв'язує все разом, показуючи повне застосування електронної таблиці, написане на Scala.
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="__4">Ресурси</h3>
<div class="paragraph"><p>На <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>, головному веб ресурсі для Scala, ви знайдете останній реліз Scala та посилання на документацію та ресурси спільноти. Для більш стиснутої сторінки з посиланнями навідайтесь на сайт книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>. Щоб поспілкуватись з іншими читачами цієї книжки, перевірте форум Programming in Scala Forum,
за адресою: <a href="http://www.artima.com/forums/forum.jsp?forum=282">http://www.artima.com/forums/forum.jsp?forum=282</a>.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Джерельний код</h3>
<div class="paragraph"><p>Ви можете завантажити ZIP файл, що містить джерельний код цієї книги, що випущений пді відкритою ліцензією Apache 2.0, с зайта книжки: <a href="http://booksites.artima.com/programming_in_scala_3ed">http://booksites.artima.com/programming_in_scala_3ed</a>.</p></div>
</div>
<div class="sect2">
<h3 id="__5">Помилки</h3>
<div class="paragraph"><p>Хоча ця книжки була щільно переглянута та перевірена, помилки всеж-таки неодмінно будуть прослизати. Для (надіємось, короткого) списку помилок друку для цієї книжки навідайтесь на <a href="http://booksites.artima.com/programming_in_scala_3ed/errata">http://booksites.artima.com/programming_in_scala_3ed/errata</a>. Якщо ви знайшли помилку, будь ласка повідомьте про неї за носиланням нижче URL, так що ми виправимо її при наступному друці або виданні цієї книжки.
:ascii-ids:
:doctype: book
:source-highlighter: pygments</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__1">Глава 1</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___4">Маштабована мова</h1>
<div class="paragraph"><p>Ім'я Scala означає "scalable language", тобто маштабована мова. Мова названа так, оскільки вона була розроблена зростати разом з потребами своїх користувачів. Ви можете застосувати Scala до широкого диапазону програмних завдань, від написання невеликіх скриптів, до побудови великих систем.<span class="footnote"><br />[Scala вимовляється skah-lah.]<br /></span></p></div>
<div class="paragraph"><p>До Scala легко дістатись. Вона працює на стандартній Java платформі, та без проблем взаємодіє з усіма бібліотеками Java. Це досить гарна мова для напсання скриптів, що стягають разом Java компоненти. Але вона може застосувати свою потужність навіть більше для побудови великих систем та фреймворків реюзабельних компонент.</p></div>
<div class="paragraph"><p>Технічно Scala є сумішшю об'єктно-орієнтованих та функціональних програмних концепцій в статично типізованій мові. Зплав об'єктно-орієнтовного та функціонального програмування виявляється в багатьох різних аспектах Scala; воно, можливо, більш проникаюче, ніж в любій іншій широко уживаній мові. Два стилі програмування мають доповнюючі сильні сторони, коли доходить до маштабованості. Функціональні програмні конструкції Scala роблять простим будувати цікаві речі швидко, з простих частин. Її об'єктно-орієнтовні конструкції спрощують структурувати більші системи, та адаптувати їх до нових вимог. Комбінація двох стилів в Scala робить можливим виражати нові типи програмних шаблонів та компонентних абстракцій. Це також призводить до виразного та стислого стилю програмування. Та оскільки вона така піддатлива, програмування на Scala може бути дуже втішним.</p></div>
<div class="paragraph"><p>Ця початкова глава відповідає на запитання "чому Scala?". Вона дає високорівневий погляд на дизайн Scala та міркування позаду неї. Після читання глави ви повинні мати базове відчуття того, що таке є Scala, та які типи задач вона може допомогти виконати. Хоча ця книжка є туторіалом в Scala, ця глава насправді не є частиною туторіала. Якщо вам нетерпляче хочеться почати писати деякий Scala код, вам слідує перестрибнути далі до Глави 2.</p></div>
<div class="sect1">
<h2 id="_1_1______">1.1 Мова, що зростає разом з вами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Програми різного розміру схильні потребувати різних програмних конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця програма встановлює мапу з країн та їх столиць, модифікує мапу, додаючи нову прив'язку ("Japan" &#8594; "Tokyo"), та друкує столицю, що асоційована з країною France.<span class="footnote"><br />[Будь ласка, слідуйте за нами, якщо ви не розумієте всі деталі цієї програми. Вони будуть пояснені в наступних двох главах.]<br /></span> Нотація в цьому прикладі високорівнева, до діла, та не захаращена зайвими крапками з комою або анотаціями типів. Дійсно, відчувається що це сучасна "скриптова" мова, Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що має відношення до приклада вище, в тому, що всі вони підтримують конструкцію "асоціативної мапи" в синтаксисі мови.</p></div>
<div class="paragraph"><p>Асоциативні мапи дуже корисні, оскільки вони дозволяють утримувати програми чіткими та лаконічними, але іноді ви можете не погодитись з їх філософією "один розмір підходить всім", оскільки вам треба контролювати властивості мап, які ви використовуваєте в вашій програмі, в більше гарно-контрольований спосіб. Scala надає вам цей гарний контроль, якщо ви потребуєте його, оскільки мапи в Scala не є синтаксисом мови. Вони є бібліотечними абстракціями, які ви можете розширити та адаптувати.</p></div>
<div class="paragraph"><p>В програмі вище ви отримали реалізацію Map по замовчанню, але ви можете легко змінити це. Ви можете, наприклад, вказати окрему реалізацію, таку як HashMap або TreeMap, або визвати метод <code>par</code> що отримати <code>ParMap</code>, що виконує операції паралельно. Ви можете вказати значення по замовчанню для мапи, або ви можете переписати любий інший метод мапи, яку ви створюєте. В кожному випадку, ви можете використовувати той самий простий синтаксис доступу для мап, що і в прикладі вище.</p></div>
<div class="paragraph"><p>Цей приклад показує, що Scala дати вам обоє, зручність та гнучкість. Scala має набір зручних конструкцій, що допомагають вам стартовати швидко, та дозволяють вам програмувати в приємно стислому стилі. В той же час, ви маєте впевненість, що ви не переростете мову. Ви завжди можете підкроїти програму до ваших потреб, оскільки все базується на бібліотечних модулях, які ви можете обрати та адаптувати, якщо треба.</p></div>
<div class="sect2">
<h3 id="___">Вирощування нових типів</h3>
<div class="paragraph"><p>Eric Raymond ввів собор та базар як дві метафори софтверної розробки.<span class="footnote"><br />[Raymond, The Cathedral and the Bazaar. [Ray99]]<br /></span> Собор майже досконала будівля, що займає довгий час доки збудується. Коли вже побудований, він стоїть незмінний довгий час. На відміну від цього базар адаптується та розширюється кожного дня, людьми, що роблять на ньому. В роботі Raymond базар є метафорою розробки програм з відкритим кодом. Guy Steele зауважив в розмові про "зростаючу мову", що ту саму різницю можна застосувати до дизайна мови.<span class="footnote"><br />[Steele, Growing a language. [Ste99]]<br /></span> Scala є значно більше базаром, ніж собором, в сміслі, що вона розроблена бути розширеною та адаптованою людьми, що програмують на ній. Заміть провадити всі конструкції, що можуть будь-коли вам знадобитись в "досконало повній мові", Scala покладає в ваші руки інструменти для побудови таких конструкцій.</p></div>
<div class="paragraph"><p>Ось приклад. Багато застосувань потребують тип цілих, що може стати довільно великим без переповнення або "циклічного переносу" арифметичних операцій. Scala визначає такий тип в бібліотечному класі scala.BigInt. Ось визначення метода, що використовує цей тип, що обчислює факторіал переданого цілого значення:<span class="footnote"><br />[factorial(x), або в математичній нотації x!, є результатом обчислення 1 * 2 * &#8230; * x, де 0! визначене як 1.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInt</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInt</span> <span class="o">=</span>
<span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">x</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ми викличемо <code>factorial(30)</code>, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="mi">265252859812191058636308480000000</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt виглядає як вбудований тип, оскільки ви можете використовувати цілі літерали та оператори, як * та - зі значеннями цього типу. Але це все ще клас, що визначений в стандартній бібліотеці.<span class="footnote"><br />[Scala іде зі стандартною бібліотекою, дещо з якої буде показане в цій книжці. Для додаткової інформації ви можете звернутись до документації Scaladoc по бібліотеці, що доступна в дистрибутиві та онлайн <a href="http://www.scala-lang.org">http://www.scala-lang.org</a>.]<br /></span> Якщо клас був би відсутній, було б прямолінійним для кожного програміста Scala написати реалізацію, наприклад, через огортання Java класу java.math.BigInteger (фактично, саме так реалізований клас Scala).</p></div>
<div class="paragraph"><p>Звичайно, ви можете використовувати клас Java напряму. Але результат і близько не такий приємний, бо хоча Java дозволяє вам створювати нові типи, ці типи не дуже виглядають як природна підтримка мови:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.math.BigInteger</span>
<span class="k">def</span> <span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BigInteger</span><span class="o">)</span><span class="k">:</span> <span class="kt">BigInteger</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ZERO</span><span class="o">)</span>
    <span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span>
  <span class="k">else</span>
    <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="o">(</span><span class="n">factorial</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">subtract</span><span class="o">(</span><span class="nc">BigInteger</span><span class="o">.</span><span class="nc">ONE</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>BigInt є представником багатьох інших число-подібних типів - великих десятичних, комплексних чисел, раціональних чисел, довірчих інтервалів, поліноміалів - список продовжується. Деякі мови програмування реалізують деяки з ціх типів природно. Наприклад, Lisp, Haskell та Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але кожна мова, що намагається реалізувати всі з ціх абструкцій одночасно, просто стане дуже великою, щоб бути керованою. Що ще більше, навіть якщо б така мова могла б існувати, деякі застосування напевно могли б отримати переваги від інших число-подібних типів, що не були включені. Так що спроба запровадити все в одній мові маштабується не дуже добре. Замість цього Scala дозволяє користувачам вирощувати та адаптувати мову в напрямках, які ї потрібні, визначаючи прості-в-використанні бібліотеки, що виглядають як природна підтримка мови.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Вирощування нових керуючих структур</h3>
<div class="paragraph"><p>Попередній приклад демонструє, що Scala дозвляє вам додавати нові типи, що можуть бути такі ж зручні в використанні, що і вбудовані типи. Той же принцип розширення також стосується до керуючих структур. Цей різновид розширюваності ілюстрований Akka, Scala API до "актор-базованого" конкурентного програмування.</p></div>
<div class="paragraph"><p>По мірі того, як багатоядерні процесори будуть продовжувати розмножуватись в наступні роки, досягнення прийнятної продуктивності може підвищувати потребу, щоб ви використовували більше парлелизма в ваших програмах. Часто це буде означати переписування вашого коду, так, щоб розподілити обчислення між декількома конкурентними потоками. Нажаль, створення надійних багатопоточних застосувань доведено складна задача на практиці. Модель поточності Java побудована навколо загальної пам'яті та блокування, модель, яку часто складно промислити, особливо коли система зростає в розмірі та складності. Складно бути впевненим, що ви не маєте стану гонок або мертвого блокування, що десь причаїлись — дещо, що не проявилось під час тестування, але може проявитись під час використатння. Як можливо безпечніша альтернатива є архитектура передачі повідомлень, така, як підхід "акторів", використаний в мові програмування Erlang.</p></div>
<div class="paragraph"><p>Java іде з багатою, основаною на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, так само, як любе інше Java API. Однак існує Akka, що є додатковою бібліотекою Scala, яка реалізує модель акторів, подібних то таких в Erlang.</p></div>
<div class="paragraph"><p>Актори є абстракцією конкурентності, що може бути реалізвана поверху потоків. Вони комунікують через надсилання повідомлень один одному. Актор може виконувати дві базові операції, надсилання та отримання повідомлення. Операція <code>send</code>, позначена знаком наголосу(!), надсилає повідомлення актору. Ось приклад, в якому актор називається <code>recipient</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>recipient ! msg</code></pre>
</div></div>
<div class="paragraph"><p>Надсилання асинхронне; тобто, надсилаючий актор може продовжувати безпосередньо, без очікування щоб повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, в якому накопичуються повідомлення. Актор обробляє повідомлення, що надійшли в поштову скриньку через блок <code>receive</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Msg1</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg1</span>
  <span class="k">case</span> <span class="nc">Msg2</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="c1">// handle Msg2</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Блок <code>receive</code> складається з декількох <code>case</code>, кожний з яких опитує поштову скриньку за шаблоном повідомлення. Перше повідомлення в скриньці, що співпаде з любим <code>case</code>, буде обране, та для нього виконується відповідна дія. Як тільки скринька більше не містить повідомлень, актор призупиняється, та очікує подальших входящих повідомлень.</p></div>
<div class="paragraph"><p>Як приклад, ось простий актор Akka, що реалізує сервіс калькулятора контрольних сум:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ChecksumActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Data</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">byte</span>
    <span class="k">case</span> <span class="nc">GetChecksum</span><span class="o">(</span><span class="n">requester</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">checksum</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">requester</span> <span class="o">!</span> <span class="n">checksum</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зпочатку цей актор визначає локальну змінну на ім'я <code>sum</code> з початковим значенням нуль. Далі він визначає блок <code>receive</code>, що буде обробляти повідомлення. Якщо він отримає повідомлення Data, він додає збережений байт до змінної <code>sum</code>. Якщо отримано повідомлення GetChecksum, актор обчислює контрольну суму для поточного значення <code>sum</code>, та надсилає результат назад до запитувача, використовуючи надсилання повідомлення <code>requester ! sum</code>. Поле <code>requester</code> вбудоване в повідомлення GetChecksum; воно звичайно посилається актора, що зробив запит.</p></div>
<div class="paragraph"><p>Ми не очікуємо, що ви повністю розумієте приклад з актором на цей момент. Скоріше, що важливе щодо цього прикладу в плані маштабованості, це те, що ані блок <code>receive</code>, ані повідомлення <code>send</code> (!) не є вбудовані операції в Scala. Навіть вважаючи, що блок <code>receive</code> може виглядати та діяти дуже подібними до вбудованих керівних конструкцій, фактично це метод, визначений в бібліотеці акторів Akka. Подібно до цього, навіть вважаючи, що <em>!</em> виглядає як вбудований оператор, він також є тільки методом, визначеним в бібліотеці акторів Akka. Обоє з ціх конструкцій повністю незалежні від мови програмування Scala.</p></div>
<div class="paragraph"><p>Синтаксис блоку <code>receive</code> та <code>send</code> (!) вигладає в Scala здебільшого як вони виглядають в Erlang, але в Erlang ці конструкції вбудовані в мову. Akka також реалізує більшість з інших конкурентних програмних конструкцій Erlang, таких, як моніторинг схибивших акторів та тайм-аути. Кінець кінцем, модель акторів виявилась дуже приємним засобом для вираження конкурентних та розподілених обчислень. Навіть якщо вони визначені в біблиотеці, актори можуть відчуватись як інтегральна частина мови Scala.</p></div>
<div class="paragraph"><p>Цей приклад ілюструє, як ви можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Звичайно, вам знадобляться гарні архітектори та програмісти, щоб зробити це. Але вирішальна річ в тому, що це можливо — ви можете розробляти та реалізувати абстракції в Scala, що адресують радикально нові галузі застосування, та все ще відчувати це як природну підтримку мови при використанні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_2___scala_">1.2 Що робить Scala маштабованою?</h2>
<div class="sectionbody">
<div class="paragraph"><p>На маштабованість впливає багато факторів, в диапазоні від синтаксичних деталей до абстрактних конструкцій компонент. Однак якщо б нам доводилось назвати тільки один аспект Scala, що допомагає маштабованості, ми б обрали комбінацію об'єктно-орієнтованого та функціонально програмування (гаразд, ми змахлювали, насправді це два аспекти, але вони пов'язані).</p></div>
<div class="paragraph"><p>Scala іде далі, ніж всі інші гарно-відомі мови в справі зплавлення об'єкто-орієнтовного та функціонального програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції як дві окремі концепції, в Scala значення функції є об'єктом. Функціональні типи є класами, що можуть наслідуватись субкласами. Це може виглядати нічим іншим, ніж академічними тонкощами, але це має глибокі наслідки для маштабованості. Фактично, показана раніше концепція актора не могла б бути реалізованою без цієї уніфікації функцій та об'єктів. Цей розділ дає огляд шляху Scala по змішуванню об'єктно-орієнтовної та функціональної концепцій.</p></div>
<div class="sect2">
<h3 id="_scala____">Scala є об'єктно-орієнтовна</h3>
<div class="paragraph"><p>Об'єктно-орієнтоване програмування було назвичайно успішним. Починаючи з Simula в середині 60х та Smalltalk в 70х, воно зараз доступне в більшій кількості мов, ніж навпаки. В деяких галузях об'єкти повністю перебрали все на себе. Хоча немає точного визначення того, що означає об'єкт-орієнтовне, але ясно, що це щось щодо об'єктів, що апелює до програмістів.</p></div>
<div class="paragraph"><p>В принципі, мотивація для об'єктно-орієнтовного програмування дуже проста: всі, крім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, це покласти дані та операції в деяку форму контейнерів. Чудова ідея об'єктно-орієнтовного програмування це зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як і дані, та що вони самі по собі є значеннями, що можуть зберігатись в інших контейнерах, або передані як параметри до операцій. Такі контейнери називаються об'єктами. Alan Kay, винахідник Smalltalk, зауважував, що в такий спосіб найпростіший об'єкт має ті самі принципи конструкції, що і цілий компьп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом.<span class="footnote"><br />[Kay, "The Early History of Smalltalk." [Kay96]]<br /></span> Так що об'єкти мають багато чого докласти до маштабованості мови: та сама технологія застосовується до конструкції малих, так само як і до великих програм.</p></div>
<div class="paragraph"><p>Навіть якщо об'єктно-орієнтоване програмування було мейнстримом протягом довгого часу, є відносно мало мов, що послідували за Smalltalk в протисканні цього конструктивного принипу до його логічного висновку. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні значення в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтовного програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнюівати речі, та обмежувати маштабованість.</p></div>
<div class="paragraph"><p>Для контрасту Scala є об'єктно-орієнтовною мовою в чистій формі: кожне значення є об'єктом, та кожна операція є викликом метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви насправді викликаєте метод на ім'я + , визначений в класі Int. Ви можете визначити методи з оператор-подібними назвами, які потім клієнти вашого API використовують для використання в операторній нотації. Ось як розробник Akka API акторів дозволив вам використовувати вирази, такі як <code>requester ! sum</code>, показані в попередньому прикладі: ! є методом класу Actor.</p></div>
<div class="paragraph"><p>Scala є більш досвідченою, ніж багато інших мови, коли йдеться про композицію об'єктів. Прикладом є трейти Scala. Трейти подібні до інтерфейсів в Java, але вони також можуть мати реалізації методів, та навіть поля.<span class="footnote"><br />[Починаючи з Java 8, інтерфейси можуть мати реалізації методів по замовчанню, але вони не надають всі можливості трейтів Scala.]<br /></span> Об'єкти конструюються через композицію міксінів, що бере методи класу, та додає до них члени декількох трейтів. В цей спосіб різні аспекти класів можуть бути інкапсульовані в різні трейти. Це виглядає трохи схожим на множинне наслідування, але відрізняється, коли річ доходить до деталей. Це робить трейти більш "плагабельними", ніж класи. Зокрема, вони уникають класичних проблем "діамантового наслідування" множинних інтерфейсів, що виникає, коли деякий клас наслідується через декілька різних шляхів.</p></div>
</div>
<div class="sect2">
<h3 id="_scala__">Scala є функціональною</h3>
<div class="paragraph"><p>На додаток до того, що вона є чистою об'єктно-орієнтовною мовою, Scala також є повно-функціональною функціональною мовою. Ці ідеі функціонального програмування старіші ніж (електронні) комп'ютері. Їх основи були покладені в лямбда обчисленні Alonzo Church, що було розроблене в 1930х. Першою функціональною мовою був Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. Протягом довгого часу функціональне програмування було дещо на узбіччі — популярне в академічних колах, але не так широко використане в індустрії. Однак в останні роки намітилась зростаюча зацікавленість в функціональному програмуванні та технологіях.</p></div>
<div class="paragraph"><p>Функціональне програмування направляється двома головними ідеями. Перша ідея в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з тим самим статусом, що і, скажімо, ціле або рядок. Ви можете передати функції як аргументи в інші функції, повернути їх як результат з функції, або зберігати їх в змінних. Ви також можете визначити функцію всередині іншої функції, так само, як ви можете визначити ціле значення всередині функції. Та ви можете визначити функції без надання їм імен, скрапляючи ваш код функціональними літералами так просто, як ви можете записати цілий літерал, як 42.</p></div>
<div class="paragraph"><p>Функції, що є першокласними значеннями, провадять зручні засоби для абстрагування над операціями, та створення нових керівних структур. Це узагальнення функцій провадить чудову виразність, що часто призводить до дуже виразних та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, бібліотека тестування ScalaTest пропонує конструкцію <code>eventually</code>, що приймає функцію як аргумент. Це використовується приблизно так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">iterator</span>
<span class="n">eventually</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="n">shouldBe</span> <span class="mi">3</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Код всередині <code>eventually</code> — твердження, <code>it.next() shouldBe 3</code> — огорнуте в функцію, що передається без виконання до метода <code>eventually</code>. Для сконфігурованого проміжку часу, <code>eventually</code> буде виконувати функцію, доки буде виконуватись твердження.</p></div>
<div class="paragraph"><p>В більшості традиційних мов, для контрасту, функції не є значеннями. Мови, що є значення функцій, часто відсувають їх на другій план. Наприклад, указателі на функції в C та C++ не мають того самого статусу, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись тільки на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення в своєму оточенні. Також вони не дозволяють визначати неіменовані функціональні літерали.</p></div>
<div class="paragraph"><p>Друга головна ідея функціонального програмування в тому, що операції програми мають відзеркалювати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці.  Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масив символів. Символи в рядку можуть бути змінені індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку на кому, всередині того самого об'єкта рядка. В Java та Scala, з іншого боку, рядок є послідовність символі в математичному сенсі. Заміна символа в рядку, використовуючи вираз як s.replace(";","."), повертає новий об'єкт рядка, що є іншим від s. Інший шлях виразити те саме, це сказати, що рядкі незмінні в Java, тоді як вони змінні в Ruby. Так що з погляду тільки на рядки, Java є функціональною мовою, тоді як Ruby ні. Незмінні структури даних є один з наріжних каменів функціонального програмування. Бібліотеки Scala визначають значно більше незмінних типів даних, крім тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, тапли, мапи та множини.</p></div>
<div class="paragraph"><p>Інший шлях затвердити цю другу ідею функціонального програмування є те, що методам не слідує мати любі побічні ефекти. Вони мають комунікувати зі своїм оточенням тільки через прийняття аргументів, та повернення результатів. Наприклад, метод <code>replace</code> в класі Java String підходить під цей опис. Він приймає рядок та два символи, та видає новий рядок, де всі появлення одного символа замінюється на інший. Немає іншого ефекту виклику <code>replace</code>. Методи як <code>replace</code> називаються референційно прозорими, що означає, що для кожного взятого вводу виклик методу може бути замінений на свій результат, без впливу на семантику програми.</p></div>
<div class="paragraph"><p>Функціональні мови заохочують незмінні структури даних та референсно прозорі методи. Деякі функціональні мови навіть вимагають їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є назвою для програмування зі змінними даними та побічними ефектами. Але Scala загалом робить простим уникати імперативних конструкцій, коли ви бажаєте цього, бо існують гарні функціональні альтернативи.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_3__scala">1.3 Чому Scala?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Чи Scala для вас? Вам доведеться зрозуміти та прийняти рішення самостійно. Ми винайшли, що насправді багато причин, крім маштабованості, щоб програмувати на Scala. В цьому розділі будуть розглянуті чотири з найбільш важливих аспектів: сумісність, краткість, високорівневі абстракції та розвинена статична типізація.</p></div>
<div class="sect2">
<h3 id="_scala___2">Scala є сумісною</h3>
<div class="paragraph"><p>Scala не потребує, щоб ви зістрибували назад з платформи Java, щоб зробити крок вперед від мови Java. Вона дозволяє вам додати вартість до існуючого коду — щоб будувати на тому, що вже маєте, оскільки вона була розроблена для безшовної взаємодії з Java.<span class="footnote"><br />[Зпочатку була реалізація Scala, що робила на платформі .NET, але вона більше не активна. Останнім часом все більше популярною стає реалізація Scala, що робить на JavaScript, Scala.js.]<br /></span> Програми Scala компілюються на байткоди JVM. Її продуктивність часу виконання звичано співпадає з Java програмами. Код Scala може викликати методи Java, отримувати доступ до полів Java, наслідувати від Java класів, та реалізувати Java інтерфейси. Ніщо з цього не потребує спеціального синтаксису, явного визначення інтерфейсів, або зклеючого коду. Фактично, весь код Scala дуже тяжко використовує Java бібліотеки, часто без того, щоб програміст переймався цім фактом.</p></div>
<div class="paragraph"><p>Інший аспект повної взаємодії є те, що Scala потужно пере-використовує типи Java. Scala <code>Int</code> представлений як примітивне ціле Java типу <code>int</code>, <code>Float</code> представлені як <code>float</code>, <code>Boolean</code> як <code>boolean</code>, і так далі. Масиви Scala відображуються на масиві Java. Scala також пере-використовує багато зі стандартних бібліотечних типів Java. Наприклад, тип рядкового літерала "abc" в Scala є <code>java.lang.String</code>, та підійняті виключення мають бути субкласом <code>java.lang.Throwable</code>.</p></div>
<div class="paragraph"><p>Scala не тільки пере-використовує Java типи, але також "принаряджує" їх, щоб зробити їх кращими. Наприклад, методи підтримки рядків в Scala, як <code>toInt</code> або <code>toFloat</code>, що конвертують рядок на ціле або на число з плаваючою крапкою. Так що ви можете писати <code>str.toInt</code> замість <code>Integer.parseInt(str)</code>. Як це може бути досягнуте без руйнування сумісності? Клас Java String напевне не має метода <code>toInt</code>! Фактично, Scala має дуже загальне рішення для вирішення цього тертя між розширеним дизайном бібліотек, та взаємодією. Scala дозволяє вам вирішити неявні перетворення, що завжди застосовуються, коли типи не будуть звичайно співпадати, або коли обираються неіснуючі члени. В випадку вище, коли шукається метод <code>toInt</code> для рядка, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String на примірник класу Scala StringOps, що визначає такий член. Це перетворення буде потім неявно застосоване перед виконанням операції <code>toInt</code>. Код Scala також може викликатись з кода Java. Іноді це більш тонка матерія, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш розвинених можливостей Scala мають бути закодовані, перед тим, як іх можна буде відобразити на Java. Глава 31 пояснює деталі.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___3">Scala є стислою</h3>
<div class="paragraph"><p>Програми Scala мають схильність бути короткими. Програмісти на Scala повідомляють зменшення числа рядків до десяти раз, порівняно з Java. Це може бути екстремальним випадком. Більш консервативне очікування може бути таким: типова Scala програма має бути приблизно в половину довжини за числом рядків, до такої самої програми, написаної на Java. Меньше рядків коду означає не тільки менше друку, але також менше зусиль по читанню та розумінню програм, та менші можливості для дефектів. Існують різні фактори, що докладаються до цього зменшення рядків коду.</p></div>
<div class="paragraph"><p>Перше, синтаксис Scala уникає деяких шаблонів, що обтяжують Java програми. Наприклад, крапка з комою є опціональною в Scala, та звичано відкидається. Також є декілька інших площин, де синтаксис Scala менш шумлячий. Як приклад, порівняйте, як ви пишете класи та конструктори в Java та Scala. В Java клас з конструктором часто виглядає подібно до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// це Java</span>
<span class="kd">class</span> <span class="nc">MyClass</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MyClass</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">,</span> <span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala ви скоріше всього замість цього напишете таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код компілятор Scala спродукує клас, що має дві приватні змінні примірника, <code>Int</code> на ім'я <code>index</code> та <code>String</code> на ім'я <code>name</code>, та конструктор, що приймає первинні значення для ціх змінних в якості параметрів. Код цього конструктора буде ініціалізувати дві змінні примірника значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча Java версія.<span class="footnote"><br />[Єдина реальна різниця в тому, що змінні примірника, вироблені в випадку Scala, будуть фінальні. Ви навчитесь, як робити їх не-фінальними в Розділі 10.6.]<br /></span> Клас Scala швидше писати, протіше читати, та більш важливо - менше схильний до помилок, ніж Java клас.</p></div>
<div class="paragraph"><p>Вивід типів Scala є іншим фактором, що докладається до її стислості. Повторювана інформація інйормація про типи може бути відкинута, так що програми стають менш захащені та більш читабельні.</p></div>
<div class="paragraph"><p>Але, можливо, найбільш важливим ключем до компактного коду є код, що ви не маєте писати, бо він вже зроблений в бібліотеці за вас. Scala надає вам інструменти для визначення потужних бібліотек, що дають вам захопити та виділити загальну поведінку. Наприклад, різні аспекти класів бібліотеки можуть бути виділені в трейти, що можуть потім бути зміксовані разом в гнучкий спосіб. Або методи бібліотеки можуть бути параметризовані за допомогою операцій, що дозволяє вам визначати конструкції, які ефективно є вашими власними керівними структурами. Разом ці конструкції дозволяють визначення бібліотек, що одночасно високорівневі та гнучки в використанні.</p></div>
</div>
<div class="sect2">
<h3 id="_scala___4">Scala є високорівневою</h3>
<div class="paragraph"><p>Програмісти постійно борються зі складністю. Щоб програмувати продуктивно, ви маєте розуміти код, з яким ви робите. Надскладний код був причиною падіння багатьох софтверних проектів. Нажаль, важливі програми звичано мають складні вимоги. Такої складності неможливо уникнути; замість цього єю треба керувати.</p></div>
<div class="paragraph"><p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракції в інтерфейсах, що ви розробляєте і якими користуєтесь. Як приклад, уявіть, що ви маєте змінну <code>String name</code>, та ви бажаєте визначити, чи містить цей рядок символи в великому реєстрі. До Java 8 ви могли написати такий цикл:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// this is Java</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="o">++</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
         <span class="n">nameHasUpperCase</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
         <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як в Scala ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">nameHasUpperCase</span> <span class="k">=</span> <span class="n">name</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Код Java сприймає рядки як низьковірневі сутнсті, по яких можна крокувати символ за символом в циклі. Код Scala сприймає той самий рядок як високорівневу послідовність символів, до якої можливо робити запити за допомогою предикатів. Зрозуміло, що код Scala значно коротший, та — для тренованого ока — простіший для розуміння, ніж Java код. Так що код Scala менше заважує до загального бюджету складності. Він також дає вам менше можливостей робити помилки.</p></div>
<div class="paragraph"><p>Предикат _.isUpper є прикладом функціонального літералу в Scala.<span class="footnote"><br />[Функціональні літерали можуть бути названі предикатами, якщо тип їх результату Boolean.]<br /></span> Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи це символ верхнього реєстра.<span class="footnote"><br />[Це використання підкреслення як заповнювача для аргументів описане в Розділі 8.5.]<br /></span></p></div>
<div class="paragraph"><p>Java 8 вводить підтримку для лямбда та потоків, що дозволяє вам виконувати подібну операцію в Java. Ось як це може виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">boolean</span> <span class="n">nameHasUpperCase</span> <span class="o">=</span>
<span class="c1">// це Java 8</span>
<span class="n">name</span><span class="o">.</span><span class="na">chars</span><span class="o">().</span><span class="na">anyMatch</span><span class="o">(</span>
    <span class="o">(</span><span class="kt">int</span> <span class="n">ch</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">Character</span><span class="o">.</span><span class="na">isUpperCase</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span> <span class="n">ch</span><span class="o">)</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це велике покращення над ранішніми версіями Java, код Java 8 все ще більше балакучий, ніж еквівалентний код Scala. Ця додаткова "важкість" Java коду, так само, як довгі традиції циклів Java, можуть заохотити багатьох Java програмістів за браком нових методів, як <code>exists</code>, просто писати цикли, та жити з підвищеною складністю їх кода.</p></div>
<div class="paragraph"><p>З іншого боку, функціональні літерали в Scala насправді легковажні, так що вони використовуютсья часто. Коли ви знатимете Scala краще, ви будете знаходити більше і більше можливостей для визначення та використання ваших власних керівних абстракцій. Ви побачите, що це допомагає уникати дублікації коду, і, таким чином, утримують ваш код коротним та чистішим.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування Scala також пропонує високорівневі принципи розмірковувати про програмування. Ключова ідея в тому, що ці функції є референтно прозорими — застосування функції характеризується тільки її результатом. Таким чином ви можете вільно замінити застосування функції на праву сторону функції (тобто тіло, що слідує за знаком рівняння), не турбуючись щодо жодних побічних ефектів. Цей принцип надає багато корисних законів, які ви можете задіяти для кращого розуміння або для рефакторинга вашого коду. Як приклад, ще раз візьмемо метод <code>exists</code>, описаний вище. Цей метод має задовільняти наступному правилу: для кожної послідовності <code>s</code>, та для кожної пари предикатів <code>p</code> та <code>q</code> має виконуватись таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">q</span><span class="o">)</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">||</span> <span class="n">q</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, опитуючи ту саму послідовність двома предикатами p та q, та роблячи АБО з результатами є те саме, що перевірити один предикат, що одночасно перевіряє на p або q. Правило, подібне до цього, вочевідь корисне для написання та рефакторингу програм. Однак, якщо <code>exists</code> має побічні ефекти, загалом не буде коректно припускати існування такого закону, оскільки ліва частина виконує <code>exists</code> двічі для кожного елемента послідовності, тоді як права частина виконується тільки один раз для кожного елементу. Так що це є прикладом, коли чисто функціональний код призводить до додаткових правил, і корисний для розуміння та рефакторингу вашого коду.</p></div>
<div class="paragraph"><p>Стиль функціонального програмування також прибирає проблеми накладання, що трапляються в імперативному програмуванні. Накладання трапляється, коли декілька змінних посилаються на той самий об'єкт. Це підіймає деякі тернисті запитання та ускладнення. Наприклад, чи зміна поля <code>r.x</code> також впливатиме на <code>s.x</code>? Це відбуватиметься, якщо <code>r</code> та <code>s</code> посилаються на той самий об'єкт. На практиці дуже складно відслідити такі накладання. З іншого боку, незмінні правила можуть вільно поділятись, оскільки копія не відрізняється від загального посилання. Ця перевага є практично ключовою, коли ви пишете конкурентний код. (Ось чому Java має незмінні рядки).</p></div>
</div>
<div class="sect2">
<h3 id="_scala___5">Scala статично типізована</h3>
<div class="paragraph"><p>Статичні системи типів класифікують змінні та вирази відповідно до властивостей значень, що вони зберігають на обчислюють. Scala виділяється як мова з дуже розширеною статичною системою типів. Починаючи від системи типів вкладених класів, подібних до Java, вона дозволяє вам параметризувати типи за допомогою дженериків, комбінувати типи з використанням перетинів, та приховувати деталі типів з використанням абстрактних типів.<span class="footnote"><br />[Дженеріки обговорюються в Главі 19; перетини (тобто, A with B with C) в Главі 12; та абстрактні типи в Главі 20.]<br /></span> Це дає міцний фундамент для будівництва та компонування ваших власних типів, так що ви можете розробити інтерфейси, що одночасно безпечні, та гнучкі в використанні.</p></div>
<div class="paragraph"><p>Якщо вам подобаються динамічні мови, такі як Perl, Python, Ruby, або Groovy, ви можете винайти трохи дивним, що статична система типів Scala попала в перелік як одна з сильних сторін. Кінець кінцем, відсутність статичної системи типів наводиться як одна з головних переваг динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми над балакучими, заважають програмістам виражати себе так, як вони бажають, та роблять неможливим деякі шаблони динамічних модифікацій софтверних систем. Однак часто ці аргументи не ідуть проти самої ідеі статичних типів взагалі, але проти окремих систем типів, що сприймаються як дуже балакучі або негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись замітив: "Я не проти типів, але я не знаю жодної системи типів, що не є суцільною біллю, так що я все ще люблю динамічні типи".<span class="footnote"><br />[Kay, поштою щодо значення об'єктно-орієнтовного програмування. [Kay03]]<br /></span></p></div>
<div class="paragraph"><p>Ми надіємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільною біллю". Фактично, вона адресує дві звичайні турботи щодо статичної типізації: балакучість іникається через вивід типів, та гнучкість досягається через співпадіння шаблонів та декльіка нових шляхів писати та компонувати типи. Коли ці перешкоди прибрані з нашого шляху, класичні переваги статичних типів можуть бути краще помічені. Серед найбільш важливих з ціх переваг є перевіряємі властивості програмних абстракцій, безпечний рефакторинг, та краща документація.</p></div>
<div class="paragraph"><p><strong>Перевіряємі властивості.</strong> Статичні системи типів можуть забезпечити відсутність певних помилок часу виконання. Наприклад, вони можуть доказати такі властивості: <code>Boolean</code> не буде доданий до цілого; приватні змінні не отримують доступ поза меж класу; функції застосовуються до відповідного числа аргументів; тільки рядки будь-коли будуть додаватись до множини рядків.</p></div>
<div class="paragraph"><p>Інші відомі помилки не виявляються сьогоднішніми статичними системами типів. Наприклад, вони зазвичай не будуть не-терміновані функції, порушення меж масивів, або ділення на ноль. Вони також не детектують, що ваша програма не відповідає її специфікації (вважаємо що така специфікація є, саме так!). Статичні системи типів, мають бути звільнені, як не дуже корисні. Аргумент, що надається, що оскільки такі системи можуть виявляти тільки прості помилки, тоді як юніт тести провадять більш екстенсивне покриття, чому треба борсатись зі статичними типами взагалі? Ми впевнені, що ці аргументи позбавлені змісту. Хоча статичні системи типів напевне не можуть замінити юніт тести, вони можуть зменшити число потрібних юніт тестів, пілчкуючись про деякі властивості, для яких інакше знадобились би тести. Подібним чином, юніт тести не можуть замінити статичну типізацію. Кінець кінцем, як казав Edsger Dijkstra, тестування може тільки довести наявність присутності помилок, та ніколи їх відсутність.<span class="footnote"><br />[Dijkstra, "Notes on Structured Programming." [Dij70]]<br /></span> Так що гарантії, що надає статична типізація, може бути слабкою, але це реальні гарантії в формі, яку не може забезпечити ніяка кількість тестів.</p></div>
<div class="paragraph"><p><strong>Безпечний рефакторинг.</strong> Статичні системи типів провадять страховку, що дозволяє вам робити зміни в базі коду з високою мірою довіри. Розглянемо примірник рефакторингу, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто підігнати всі рядки, що видають помилку типу. Коли ви скінчите з цім, ви впевнені, що найшли всі місця, що треба змінити. Те саме вірно для багатьох інших випадків простого рефакторингу, як зміни імені методу, або переміщення методів з одного класу до іншого. В усіх ціх випадках перевірка статичного типу буде провадити досить акуратності, щоб нова система робила так само, як стара.</p></div>
<div class="paragraph"><p><strong>Документація.</strong> Статичні типи є документацією програми, що перевіряється компілятором на коректність. На відміну від звичайних коментарів, анотації типів ніколи не можуть застаріти (щонайменьше якощ файл коду, що містить їх, недавно проходив через компілятор). Більше того, компілятори і інтегровані середовища розробки (IDE) можуть використовувати анотації типів для провадження кращої контекстної підказки. Наприклад, IDE може відображувати всі члени, доступні для вибору, через визначення статичного типу виразу, на якому робиться вибір, та перегляд членів цього типу.</p></div>
<div class="paragraph"><p>Навіть хоча статичні типи загалом корисні для документації програми, вони можуть інколи бути надокучливі, коли вони захаращують програму. Типово, корисна документація - це те, що читачі програми не можуть просто вивести самі по собі. В визначенні метода як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>корисно знати, що аргумент має бути <code>String</code>. Або, з іншого боку, щонайменьше одна з двох анотацій в наступному прикладі є подразником:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
</pre></div></div></div>
<div class="paragraph"><p>Зрозуміло, що має бути достатньо сказати тільки один раз, що <code>x</code> є <code>HashMap</code> з <code>Int</code> в якості ключа, та <code>Strings</code> як значення; немає потреби повторювати ту саму фразу двічі. Scala має дуже складну систему виводу типів, що дозволяє вам оминати майже всю інформацію типів, що звичайно сприймається як надокучлива. В попередньому прикладі наступні дві менш дратливі альтернативи також будуть робити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>ВИвід типів в Scala може зайти досить далеко. Фактично, не є рідкістю для користувацького кода, взагалі не мати явних типів. Таким чином, програми Scala часто виглядають трохи як програми, написані на динамічно типізованій скриптоівій мові. Це вірно зокрема для кода клієнтськіх застосувань, що зліплюють разом попередньо написані бібліотечні компоненти. Це менш вірно для самих компонент бібліотек, оскільки вони часто вживають дуже складні типи, щоб забезпечити гнучкі шаблони застосування. Це просто природно. Кінець кінцем, сигнатури типів членів, що складають інтерфейс реюзабельного компонента, повинен бути наданий явно, оскільки вони складають основну частину контракту між компонентом та його клієнтами.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_1_4__scala">1.4 Корені Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Дизайн Scala бів під впливом багатьох мов програмування, та ідей в дослідженні програмних мов. Фактично, тільки декілька можливостей Scala чисто нові; більшість вже мали застосування в деякій формі в інших мовах. Інновація Scala в основному походить від того, як вона покладає ці конструкції разом. В цьому розділі ми перелічимо головні впливи на розробку Scala. Список не може бути вичерпним — існує дуже багато розумних ідей коло розробки мови програмування, щоб перелічити тут їх всі.</p></div>
<div class="paragraph"><p>На поверхневому рівні Scala адоптує значну частину синтаксиса Java та C#, що, в свою чергу, позичає більшість зі своїх синтаксичних домовленостей від C та C++. Вирази, твердження та блокі здебільшо як в Java, так само, як синтаксис класів, пакунків та імпортів.<span class="footnote"><br />[Головне відхидення від Java в плані синтаксису для анотацій типу, це "змінна: типу" замість "тип змінної" в Java. Постфіксний синтаксис типу в Scala копіює Pascal, Modula-2, або Eiffel. Головна причина для цього відхилення має відношення до виводу типів, що часто дозволяє вам оминути тип змінної або тип повернення метода. Використання синтаксису "змінна: типу" просте - тільки опустіть крапку з комою та тип. Але в C-style синтаксисі "тип змінної" ви не можете просто відкинути тип; більше намає маркера що почалась декларація. Вам знадобиться деяке альтернативне ключове слово, щоб бути заповнювачем для відсутнього типу (C# 3.0, що робить деякий вивід типів, використовує <code>var</code> для ціх цілей). Таке альтернативне ключове слово виглядає більш притягнутим, та менш регулярним, ніж підхід Scala.]<br /></span> Крім синтаксиса Scala адоптує багато інших елементів Java, такі як базові типи, її бібліотеки типів, та її модель виконання.</p></div>
<div class="paragraph"><p>Scala також заборгувала багатьом іншим мовам. Її уніформна об'єктна модель започаткована  Smalltalk, і згодом прийнята Ruby. Її ідея про універсальне вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, більш пізніше, в Beta та gbeta. Її принцип уніформного доступу для виклику методів та виборів полів надходить від Eiffel. Її підхід до функціонального програмування є дуже подібним до духу сім'ї мов ML, таких як SML, OCaml та F#, в якості видатних членів. Багато високорівневих функцій в стандартній бібліотеці Scala також присутні в ML або Haskell. Неявні параметри були мотивовані класами типів Haskell; вони досягли аналогічних результатів в більше класичной об'єктно-орієнтовному оточенні. Головна актор-базована бібліотека конкурентності, Akka, дуже надихалась Erlang.</p></div>
<div class="paragraph"><p>Scala не є першою мовою, що наголошує на маштабованості та розширюваності. Історичні корені розширюваної мови, що може перетинати різні області застосування, знаходяться в статті Peter Landin 1966го року,"The Next 700 Programming Languages."<span class="footnote"><br />[Landin, "The Next 700 Programming Languages." [Lan66]]<br /></span> (Мова, описана в цьому документі, Iswim, стоїть поряд з Lisp як один з першопроходців функціональних мов). Специфічна ідея трактувати інфіксний оператор як функцію можна прослідкувати до Iswim та Smalltalk. Інша важлива ідея є дозволити функціональні літерали (або блоки) в якості параметрів, що дозвоялє бібліотекам визначати керівні структури. Знову, це тягнеться назад до Iswim та Smalltalk. Smalltalk та Lisp обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх, домен-специфічних мов. C++ є іншою маштабованою мовою, що може бути адаптований та розширений через перевантаження операторів, та його систему шаблонів; порівняно зі Scala він побудований на ніжньому рівні, більш системно-орієнтовному ядрі. Scala також не є першою мовою, що інтегрує функціональне та об'єкт-орієнтовне програмування, хоча вона, можливо, зашла найбільш далеко в цьому напрямку. Інші мови, що інтегрували деякі елементи функціонального програмування в об'єкто-орієнтовне програмування (OOP) включають Ruby, Smalltalk та Python. На Java платформі, Pizza, Nice, Multi-Java — та сама Java 8  — мають розширене Java-подібне ядро з функціональними ідеями. Також існують здебільше функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F#, та PLT-Scheme.</p></div>
<div class="paragraph"><p>Scala також привнесла деякі інновації до поля мов програмування. Наприклад, її абстрактні типи провадять більше об'єктно-орієнтовної альтернативи до дженерік типів, її трейти дозволяють гнучкі збірки компонент, та її екстрактори провадять незалежний від представлення спосіб співпадіння шаблонів. Ці інновації були представлені в документах на конференціях з мов програмування в останні роки.<span class="footnote"><br />[Для додаткової інформації дивіться [Ode03], [Ode05], та [Emi07] в бібліографії.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_1_5_">1.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми дали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Напевне, Scala не є срібною кулею, що магічно зробить вас більш продуктивним. Щоб просуватись, вам знадобиться містецьки застосувати Scala, та це буде потребувати деякого навчання та практики. Якщо ви прийшли до Scala від Java, найбільш викличний аспект у вивченні Scala може включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книжки м'яко провести вас кривою навчання Scala, по кроку за раз. Ми вважаємо, що ви знайдете це корисним інтелектуальним досвідом, що розширить ваші горизонти, та змусить вас думати інакше щодо розробки програм. Надіємось, що ви також отримаєте задоволення та натхнення від програмуванн на Scala.</p></div>
<div class="paragraph"><p>В наступній главі ми почнемо з вами писати деякий Scala код.
:ascii-ids:
:doctype: book
:source-highlighter: pygments</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2_2">Глава 2</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala">Перші кроки в Scala</h1>
<div class="paragraph"><p>It&#8217;s time to write some Scala code. Before we start on the in-depth Scala tutorial, we put in two chapters that will give you the big picture of Scala, and most importantly, get you writing code. We encourage you to actually try out all the code examples presented in this chapter and the next as you go. The best way to start learning Scala is to program in it.</p></div>
<div class="paragraph"><p>To run the examples in this chapter, you should have a standard Scala installation. To get one, go to <a href="http://www.scala-lang.org/downloads">http://www.scala-lang.org/downloads</a> and follow the directions for your platform.You can also use a Scala plug-in for Eclipse, IntelliJ, or NetBeans. For the steps in this chapter, we&#8217;ll assume you&#8217;re using the Scala distribution from scala-lang.org.<span class="footnote"><br />[Ми тестували приклади в цій книзі на Scala версії 2.11.7.]<br /></span></p></div>
<div class="paragraph"><p>If you are a veteran programmer new to Scala, the next two chapters should give you enough understanding to enable you to start writing useful programs in Scala. If you are less experienced, some of the material may seem a bit mysterious to you. But don&#8217;t worry. To get you up to speed quickly, we had to leave out some details. Everything will be explained in a less "fire hose" fashion in later chapters. In addition, we inserted quite a few footnotes in these next two chapters to point you to later sections of the book where you&#8217;ll find more detailed explanations.</p></div>
<div class="sect1">
<h2 id="__1____scala">Крок 1. Навчаємось викорстовувати інтерпретатор Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>The easiest way to get started with Scala is by using the Scala interpreter, an interactive "shell" for writing Scala expressions and programs. The interpreter, which is called scala, will evaluate expressions you type and print the resulting value. You use it by typing scala at a command prompt:<span class="footnote"><br />[Якщо ви використовуєте Windows, вам буде треба друкувати команду scala у вікно "Command Prompt" DOS.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala
Welcome to Scala version 2.11.7
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>After you type an expression, such as 1 + 2, and hit enter:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; 1 + 2</code></pre>
</div></div>
<div class="paragraph"><p>The interpreter will print:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>res0: Int = 3</code></pre>
</div></div>
<div class="paragraph"><p>This line includes:
* an automatically generated or user-defined name to refer to the computed value (res0, which means result 0),
* a colon (:), followed by the type of the expression (Int),
* an equals sign (=),
* the value resulting from evaluating the expression (3).</p></div>
<div class="paragraph"><p>The type Int names the class Int in the package scala. Packages in Scala are similar to packages in Java: They partition the global namespace and provide a mechanism for information hiding.<span class="footnote"><br />[Якщо ви не знайомі з пакунками Java, ви можете думати про них, як про впроваджене повне ім'я класу. Оскільки Int є членом пакунку scala, "Int" є простим ім'ям класу, та "scala.Int" є його повним ім'ям. Деталі щодо пакунків пояснюються в Главі 13.]<br /></span> Values of class Int correspond to Java&#8217;s int values. More generally, all of Java&#8217;s primitive types have corresponding classes in the scala package. For example,scala.Boolean corresponds to Java&#8217;s boolean. scala.Float corresponds to Java&#8217;s float. And when you compile your Scala code to Java bytecodes, the Scala compiler will use Java&#8217;s primitive types where possible to give you the performance benefits of the primitive types.</p></div>
<div class="paragraph"><p>The resX identifier may be used in later lines. For instance, since res0 was set to 3 previously,res0 * 3 will be 9:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; res0 * 3
res1: Int = 9</code></pre>
</div></div>
<div class="paragraph"><p>To print the necessary, but not sufficient, Hello, world! greeting, type:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println("Hello, world!")
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>The println function prints the passed string to the standard output, similar toSystem.out.println in Java.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__2___">Крок 2. Визначаємо декілька змінних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala has two kinds of variables, vals and vars. A val is similar to a final variable in Java. Once initialized, a val can never be reassigned. A var, by contrast, is similar to a non-final variable in Java. A var can be reassigned throughout its lifetime. Here&#8217;s a val definition:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg = "Hello, world!"
msg: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>This statement introduces msg as a name for the string "Hello, world!". The type of msg isjava.lang.String, because Scala strings are implemented by Java&#8217;s String class.</p></div>
<div class="paragraph"><p>If you&#8217;re used to declaring variables in Java, you&#8217;ll notice one striking difference here: neitherjava.lang.String nor String appear anywhere in the val definition. This example illustrates type inference, Scala&#8217;s ability to figure out types you leave off. In this case, because you initializedmsg with a string literal, Scala inferred the type of msg to be String. When the Scala interpreter (or compiler) can infer types, it is often best to let it do so rather than fill the code with unnecessary, explicit type annotations. You can, however, specify a type explicitly if you wish, and sometimes you probably should. An explicit type annotation can both ensure the Scala compiler infers the type you intend, as well as serve as useful documentation for future readers of the code. In contrast to Java, where you specify a variable&#8217;s type before its name, in Scala you specify a variable&#8217;s type after its name, separated by a colon. For example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg2: java.lang.String = "Hello again, world!"msg2: String = Hello again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Or, since java.lang types are visible with their simple names in Scala programs, simply:<span class="footnote"><br />[Просте ім'я java.lang.String є String.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</code></pre>
</div></div>
<div class="paragraph"><p>Going back to the original msg, now that it is defined, you can use it as you&#8217;d expect, for example:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; println(msg)
Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>What you can&#8217;t do with msg, given that it is a val, not a var, is reassign it.<span class="footnote"><br />[Однак в інтерпретаторі ви можете визначити нове val з іменем, що вже використовувалось до цього. Цей механізм пояснено в Розділі 7.7.]<br /></span> For example, see how the interpreter complains when you attempt the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; msg = "Goodbye cruel world!"
&lt;console&gt;:8: error: reassignment to val
msg = "Goodbye cruel world!"
^</code></pre>
</div></div>
<div class="paragraph"><p>If reassignment is what you want, you&#8217;ll need to use a var, as in:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; var greeting = "Hello, world!"
greeting: String = Hello, world!</code></pre>
</div></div>
<div class="paragraph"><p>Since greeting is a var not a val, you can reassign it later. If you are feeling grouchy later, for example, you could change your greeting to:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; greeting = "Leave me alone, world!"
greeting: String = Leave me alone, world!</code></pre>
</div></div>
<div class="paragraph"><p>To enter something into the interpreter that spans multiple lines, just keep typing after the first line. If the code you typed so far is not complete, the interpreter will respond with a vertical bar on the next
line.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val multiLine =
|
"This is the next line."
multiLine: String = This is the next line.</code></pre>
</div></div>
<div class="paragraph"><p>If you realize you have typed something wrong, but the interpreter is still waiting for more input, you can escape by pressing enter twice:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; val oops =
|
|
You typed two blank lines.
Starting a new command.
scala&gt;</code></pre>
</div></div>
<div class="paragraph"><p>In the rest of the book, we&#8217;ll leave out the vertical bars to make the code easier to read (and easier to copy and paste from the PDF eBook into the interpreter).</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__3___">Крок 3. Визначаємо деякі функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Now that you&#8217;ve worked with Scala variables, you&#8217;ll probably want to write some functions. Here&#8217;s how you do that in Scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
}
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Function definitions start with def. The function&#8217;s name, in this case max, is followed by a comma- separated list of parameters in parentheses. A type annotation must follow every function parameter, preceded by a colon, because the Scala compiler (and interpreter, but from now on we&#8217;ll just say compiler) does not infer function parameter types. In this example, the function named max takes two parameters, x and y, both of type Int. After the close parenthesis of max&#8217;s parameter list you&#8217;ll find another ": Int" type annotation. This one defines the result type of the max function itself.<span class="footnote"><br />[В Java тип значення, що повертається з метода, є його типом повернення. В Scala та сама концепція називається типом результата.]<br /></span> Following the function&#8217;s result type is an equals sign and pair of curly braces that contain the body of the function. In this case, the body contains a single if expression, which selects either x or y, whichever is greater, as the result of the max function. As demonstrated here, Scala&#8217;s if expression can result in a value, similar to Java&#8217;s ternary operator. For example, the Scala expression "if (x &gt; y) x else y" behaves similarly to "(x &gt; y) ? x : y" in Java. The equals sign that precedes the body of a function hints that in the functional world view, a function defines an expression that results in a value. The basic structure of a function is illustrated in Figure 2.1.</p></div>
<div class="paragraph"><p>Figure 2.1 - The basic form of a function definition in Scala.</p></div>
<div class="paragraph"><p>Sometimes the Scala compiler will require you to specify the result type of a function. If the function is recursive,<span class="footnote"><br />[Функція називається рекурсивною, якщо вона викликає сама себе.]<br /></span> for example, you must explicitly specify the function&#8217;s result type. In the case of max, however, you may leave the result type off and the compiler will infer it.<span class="footnote"><br />[Тим не менш, часто є гарною ідеєю вказати тип результата функції явно, навіть коли компілятор не потребує цього. Така анотація типу може зробити код простішим до читання, оскільки читач на повинен вивчати тіло функції, щоб з'ясувати виведений тип результата.]<br /></span> Also, if a function consists of just one statement, you can optionally leave off the curly braces. Thus, you could alternatively write the max function like this:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def max(x: Int, y: Int) = if (x &gt; y) x else y
max: (x: Int, y: Int)Int</code></pre>
</div></div>
<div class="paragraph"><p>Once you have defined a function, you can call it by name, as in:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; max(3, 5)
res4: Int = 5</code></pre>
</div></div>
<div class="paragraph"><p>Here&#8217;s the definition of a function that takes no parameters and returns no interesting result:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</code></pre>
</div></div>
<div class="paragraph"><p>When you define the greet() function, the interpreter will respond with greet: ()Unit. "greet" is, of course, the name of the function. The empty parentheses indicate the function takes no parameters. And Unit is greet&#8217;s result type. A result type of Unit indicates the function returns no interesting value. Scala&#8217;s Unit type is similar to Java&#8217;s void type; in fact, every void-returning method in Java is mapped to a Unit-returning method in Scala. Methods with the result type of Unit, therefore, are only executed for their side effects. In the case of greet(), the side effect is a friendly greeting printed to the standard output.</p></div>
<div class="paragraph"><p>In the next step, you&#8217;ll place Scala code in a file and run it as a script. If you wish to exit the interpreter, you can do so by entering :quit or :q.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>scala&gt; :quit
$</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="__4___scala_">Крок 4. Пишемо деякі Scala скрипти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Although Scala is designed to help programmers build very large-scale systems, it also scalesdown
nicely to scripting. A script is just a sequence of statements in a file that will be executed sequentially.
Put this into a file named hello.scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>println("Hello, world, from a script!")</code></pre>
</div></div>
<div class="paragraph"><p>then run:<span class="footnote"><br />[Ви можете виконати скрипт без набирання "scala" під Unix та Windows, використовуючи синтаксис "pound-bang", що показаний в Додатку A.]<br /></span></p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala hello.scala</code></pre>
</div></div>
<div class="paragraph"><p>And you should get yet another greeting:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, world, from a script!</code></pre>
</div></div>
<div class="paragraph"><p>Command line arguments to a Scala script are available via a Scala array named args. In Scala, arrays are zero based, and you access an element by specifying an index in parentheses. So the first element in a Scala array named steps is steps(0), not steps[0], as in Java. To try this out, type the following into a new file named helloarg.scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>// Say hello to the first argument
println("Hello, " + args(0) + "!")</code></pre>
</div></div>
<div class="paragraph"><p>then run:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala helloarg.scala planet</code></pre>
</div></div>
<div class="paragraph"><p>In this command, "planet" is passed as a command line argument, which is accessed in the script as args(0). Thus, you should see:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello, planet!</code></pre>
</div></div>
<div class="paragraph"><p>Note that this script included a comment. The Scala compiler will ignore characters between// and the next end of line and any characters between /* and */. This example also showsStrings being concatenated with the + operator. This works as you&#8217;d expect. The expression"Hello, " + "world!" will result in the string "Hello, world!".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__5___while___if">Крок 5. Цикл з while; рішення з if</h2>
<div class="sectionbody">
<div class="paragraph"><p>To try out a while, type the following into a file named printargs.scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>var i = 0
while (i &lt; args.length) {
  println(args(i))
  i += 1
}</code></pre>
</div></div>
<div class="sect2">
<h3 id="_note">Note</h3>
<div class="paragraph"><p>Although the examples in this section help explain while loops, they do not demonstrate the best Scala style. In the next section, you&#8217;ll see better approaches that avoid iterating through arrays with indexes.</p></div>
<div class="paragraph"><p>This script starts with a variable definition, var i = 0. Type inference gives i the type scala.Int, because that is the type of its initial value, 0. The while construct on the next line causes theblock (the code between the curly braces) to be repeatedly executed until the boolean expression i &lt; args.length is false. args.length gives the length of the args array. The block contains two statements, each indented two spaces, the recommended indentation style for Scala. The first statement, println(args(i)), prints out the ith command line argument. The second statement, i <code>= 1, increments i by one. Note that Java&#8217;s + +i and i</code>+ don&#8217;t work in Scala. To increment in Scala, you need to say either i = i + 1 or i += 1. Run this script with the following command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala printargs.scala Scala is fun</code></pre>
</div></div>
<div class="paragraph"><p>And you should see:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala
is
fun</code></pre>
</div></div>
<div class="paragraph"><p>For even more fun, type the following code into a new file with the name echoargs.scala:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>var i = 0
while (i &lt; args.length) {
  if (i != 0)
    print(" ")
  print(args(i))
  i += 1
}
println()</code></pre>
</div></div>
<div class="paragraph"><p>In this version, you&#8217;ve replaced the println call with a print call, so that all the arguments will be printed out on the same line. To make this readable, you&#8217;ve inserted a single space before each argument except the first via the if (i != 0) construct. Since i != 0 will be false the first time through the while loop, no space will get printed before the initial argument. Lastly, you&#8217;ve added one more println to the end, to get a line return after printing out all the arguments. Your output will be very pretty indeed. If you run
this script with the following command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala echoargs.scala Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>You&#8217;ll get:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Scala is even more fun</code></pre>
</div></div>
<div class="paragraph"><p>Note that in Scala, as in Java, you must put the boolean expression for a while or an if in parentheses. (In other words, you can&#8217;t say in Scala things like if i &lt; 10 as you can in a language such as Ruby. You must say if (i &lt; 10) in Scala.) Another similarity to Java is that if a block has only one statement, you can optionally leave off the curly braces, as demonstrated by the if statement in echoargs.scala. And although you haven&#8217;t seen any of them, Scala does use semicolons to separate statements as in Java, except that in Scala the semicolons are very often optional, giving some welcome relief to your right little finger. If you had been in a more verbose mood, therefore, you could have written the echoargs.scala script as follows:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>var i = 0;
while (i &lt; args.length) {
  if (i != 0) {
    print(" ");
  }
  print(args(i));
  i += 1;
}
println();</code></pre>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__6____foreach__for">Крок 6. Ітеруємо за допомогою foreach та for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Although you may not have realized it, when you wrote the while loops in the previous step, you were programming in an imperative style. In the imperative style, which is the style you normally use with languages like Java, C++, and C, you give one imperative command at a time, iterate with loops, and often mutate state shared between different functions. Scala enables you to program imperatively, but as you get to know Scala better, you&#8217;ll likely often find yourself programming in a more functional style. In fact, one of the main aims of this book is to help you become as comfortable with the functional style as you are with imperative style.</p></div>
<div class="paragraph"><p>One of the main characteristics of a functional language is that functions are first class constructs, and that&#8217;s very true in Scala. For example, another (far more concise) way to print each command line
argument is:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach(arg =&gt; println(arg))</code></pre>
</div></div>
<div class="paragraph"><p>In this code, you call the foreach method on args and pass in a function. In this case, you&#8217;re passing in a function literal that takes one parameter named arg. The body of the function isprintln(arg). If you type the above code into a new file named pa.scala and execute with the command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala pa.scala Concise is nice</code></pre>
</div></div>
<div class="paragraph"><p>You should see:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Concise
is
nice</code></pre>
</div></div>
<div class="paragraph"><p>In the previous example, the Scala interpreter infers the type of arg to be String, since String is the element type of the array on which you&#8217;re calling foreach. If you&#8217;d prefer to be more explicit, you can mention the type name. But when you do, you&#8217;ll need to wrap the argument portion in parentheses (which is the normal form of the syntax anyway):</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach((arg: String) =&gt; println(arg))</code></pre>
</div></div>
<div class="paragraph"><p>Running this script has the same behavior as the previous one.</p></div>
<div class="paragraph"><p>If you&#8217;re in the mood for more conciseness instead of more explicitness, you can take advantage of a special shorthand in Scala. If a function literal consists of one statement that takes a single argument, you need not explicitly name and specify the argument.<span class="footnote"><br />[Це скорочення, що називається частково визначеною функцією, описане в Розділі 8.6.]<br /></span> Thus, the following code also works:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>args.foreach(println)</code></pre>
</div></div>
<div class="paragraph"><p>To summarize, the syntax for a function literal is a list of named parameters, in parentheses, a right arrow, and then the body of the function. This syntax is illustrated in Figure 2.2.</p></div>
<div class="paragraph"><p>Figure 2.2 - The syntax of a function literal in Scala.</p></div>
<div class="paragraph"><p>Now, by this point you may be wondering what happened to those trusty for loops you have been accustomed to using in imperative languages, such as Java or C. In an effort to guide you in a functional direction, only a functional relative of the imperative for (called a forexpression) is available in Scala. While you won&#8217;t see their full power and expressiveness until you reach (or peek ahead to) Section 7.3, we&#8217;ll give you a glimpse here. In a new file named forargs.scala, type the following:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for (arg &lt;- args)
  println(arg)</code></pre>
</div></div>
<div class="paragraph"><p>The parentheses after the "for" contain arg &#8592; args.<span class="footnote"><br />[Ви можете казати "в" для символа &#8592; . Ви будете читати for (arg &#8592; args), таким чином, як "для arg в args."]<br /></span> To the right of the &#8592; symbol is the familiar args array. To the left of &#8592; is "arg", the name of a val, not a var. (Because it is always aval, you just write "arg" by itself, not "val arg".) Although arg may seem to be a var, because it will get a new value on each iteration, it really is a val: arg can&#8217;t be reassigned inside the body of the for expression. Instead, for each element of the args array, a new arg val will be created and initialized to the element value, and the body of the for will be executed.</p></div>
<div class="paragraph"><p>If you run the forargs.scala script with the command:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala forargs.scala for arg in args</code></pre>
</div></div>
<div class="paragraph"><p>You&#8217;ll see:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>for
arg
in
args</code></pre>
</div></div>
<div class="paragraph"><p>Scala&#8217;s for expression can do much more than this, but this example is enough to get you started. We&#8217;ll show you more about for in Section 7.3 and Chapter 23.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__6">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>In this chapter, you learned some Scala basics and, hopefully, took advantage of the opportunity to write a bit of Scala code. In the next chapter, we&#8217;ll continue this introductory overview and get into more advanced topics.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 3.0<br />
Last updated
 2019-01-24 07:16:16 EET
</div>
</div>
</body>
</html>
