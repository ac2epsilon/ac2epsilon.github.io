<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__a">Додаток A</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__scala__unix__windows">Скрипти Scala на Unix та Windows</h1>
<div class="paragraph"><p>Якщо ви на деякому різновиді Unix, ви можете виконувати скрипти Scala як скрипт оболонки, поставивши нагорі файла директиву "ша банг". Наприклад, наберіть таке в файлі на ім'я <code>helloarg</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
<span class="nb">exec</span> scala <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
!#
// Скажи hello першому аргументу
println<span class="o">(</span><span class="s2">&quot;Hello, &quot;</span> + args<span class="o">(</span><span class="m">0</span><span class="o">)</span> + <span class="s2">&quot;!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше <code>#!/bin/sh</code> має бути на самому першому рядку в файлі. Коли ви встановите дозвіл на виконання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ chmod +x helloarg
</pre></div></div></div>
<div class="paragraph"><p>Ви можете виконувати Scala скрипт як скрипт оболонки просто сказавши:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./helloarg globe
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви на Windows, ви можете досягти того самого ефекту, назвавши файл <code>helloarg.bat</code>, та поклавши це нагорі вашого скрипта:
::#!
@echo off
call scala %0 %*
goto :eof
::!#</p></div>
<h1 id="_">Глосарій</h1>
<div class="paragraph"><p><em><strong>алгебраїчний тип даних</strong></em> Тип, визначений через провадження декількох альтетрнатив, кожна з яких іде зі своїм власним конструктором. Віз зазвичай іде зі способом декомпозиції типу через співпадіння шаблонів. Концепція знайдена в мовах специфікації та функціональних мовах програмування. Алгебраїчні типи даних можуть бути емульовані в Scala через кейс класи.</p></div>
<div class="paragraph"><p><em><strong>альтернатива</strong></em> Гілка виразу <code>match</code>. Вона має форму <code>case pattern =&gt; expression</code>. Інше ім'я для альтернативи є <em>випадок</em>.</p></div>
<div class="paragraph"><p><em><strong>анотація</strong></em> Анотація з'являється в джерельному коді, та прив'язана до деякої частини синтаксису. Анотації обробляються комп'ютером, так що ви можете використовувати їх для ефективного додавання розширень до Scala.</p></div>
<div class="paragraph"><p><em><strong>анонімний клас</strong></em> Анонімний клас є синтетичний субклас, згенерований компілятором Scala з виразу <code>new</code>, в якому за ім'ям класу або трейту ідуть фігурні дужки. Фігурні дужки містять тіло анонімного класу, що може бути порожнім. Однак якщо ім'я, на яке посилається <code>new</code>, посилається на трейт або клас, що містить абстрактні члени, це має бути зроблене суцільним в фігурних дужках, що визначають тіло анонімного субкласу.</p></div>
<div class="paragraph"><p><em><strong>анонімна функція</strong></em> Інша назва для функціонального літералу.</p></div>
<div class="paragraph"><p><em><strong>аргумент</strong></em> Коли викликається функція, аргумент передається для кожного параметра функції. Параметр є змінна, що посилається на аргумент. Аргумент є об'єктом, переданим під час виклику. На додаток, застосування можуть приймати аргументи (командного рядка), що виглядають як <code>Array[String]</code>, переданий до метода <code>main</code> об'єкта синглтона.</p></div>
<div class="paragraph"><p><em><strong>без посилань</strong></em> Дивіться <em>недоступний</em>.</p></div>
<div class="paragraph"><p><em><strong>безпараметерна функція</strong></em> Функція, що не приймає параметрів, та визначена без жодних порожніх дужок. Виклики безпараметерних функцій не може надавати дужки. Це підтримує принцип уніформного доступу, що дозволяє замінити <code>def</code> на <code>val</code>, без вимог до зміни клієнтського коду.</p></div>
<div class="paragraph"><p><em><strong>блок</strong></em> Один або більше виразів та декларацій, оточених фігурними дужками. Коли блок обчислюється, всі його вирази та декларації обробляються по порядку, та потім блок повертає значення останнього виразу або своє власне значення. Блоки загально використовуються як тіла функцій, для виразів, циклів <code>while</code>, та в усіх інишх місцях, де ви бажаєте згрупіювати декілька твердженя разом. Більш формально, блок це конструкція інкапсуляції, для якої ви можете бачити тільки побічні ефекти або значення результату. Фігурні дужки, в яких ви визначаєте клас або об'єкт, таким чином, не формують блок, оскільки поля та методи (що визначені в ціх фігурних дужках) видимі ззовні. Такі фігурні дужки формують <em>шаблон</em>.</p></div>
<div class="paragraph"><p><em><strong>варіантність</strong></em> Параметр типу класу або трейту може бути відмічений анотацією варіантності, як коваріантний (+) або контрваріантний (-). Так анотації варіантності вказують, як субтипізація робить для класів або трейтів. Наприклад, дженерік клас <code>List</code> є коваріантним по своєму парметру типа, так що <code>List[String]</code> є субтипом <code>List[Any]</code>. По замовчанню, тобто при відсутності анотацій + або -, тип параметрів є <em>неваріантним</em>.</p></div>
<div class="paragraph"><p><em><strong>вільна змінна</strong></em> <em>Вільна змінна</em> в виразі є змінна, що використовується в виразі, але не визначається в виразі. Наприклад, в виразі функціонального літерала <code>(x: Int) =&gt; (x, y)</code> використовуються обидві змінні, <code>x</code> та <code>y</code>, але тільки <code>y</code> є вільною змінною, оскільки вона не визначена всередині виразу.</p></div>
<div class="paragraph"><p><em><strong>видача</strong></em> Вираз може <em>видавати</em> результат. Ключове слово <code>yield</code> позначає результат для виразу <code>for</code>.</p></div>
<div class="paragraph"><p><em><strong>визначення</strong></em> <em>Визначити</em> дещо в програмі Scala означає надати ім'я та реалізацію. Ви можете визначити класи, трейти, об'єкти синглтони, поля, методи, локальні функції, локальні змінні, тощо. Оскільки визначення завжди включає деякий різновид реалізації, абстрактні члени <em>декларовані</em>, але не визначені.</p></div>
<div class="paragraph"><p><em><strong>виклик</strong></em> Ви можете викликати метод, функцію або замикання на аргументах, означаючи, що її тіло буде виконане з заданими аргументами.</p></div>
<div class="paragraph"><p><em><strong>вираз</strong></em> Любий фрагмент Scala коду, що дає результат. Ви також можете сказати, що вираз обчислюється до результату, або має результуюче <em>значення</em>.</p></div>
<div class="paragraph"><p><em><strong>вираз генератора</strong></em> <em>Вираз генератора</em> генерує послідовність значень в виразі <code>for</code>. Наприклад, в <code>for(i &lt;- 1 to 10)</code>, вираз генератора є <code>1 to 10</code>.</p></div>
<div class="paragraph"><p><em><strong>генератор</strong></em> <em>Генератор</em> визначає іменовану <code>val</code>, та присвоює їй набір значень в виразі <code>for</code>. Наприклад, в <code>for(i &lt;- 1 to 10)</code>, генератор є <code>i &lt;- 1 to 10</code>. Значення зправа від <code>&lt;-</code> є вираз генератора.</p></div>
<div class="paragraph"><p><em><strong>декларація</strong></em> Ви можете <em>декларувати</em> абстрактне поле, метод або тип, що надає сутності ім'я, але не реалізацію. Ключова різниця між декларацією та визначенням в тому, що визначення встановлює реалізацію для іменованої сутності, тоді як декларація - ні.</p></div>
<div class="paragraph"><p><em><strong>дженерік клас</strong></em> Клас, що приймає параметри типу. Наприклад, оскільки <code>scala.List</code> приймає параметр типу, <code>scala.List</code> є дженерік класом.</p></div>
<div class="paragraph"><p><em><strong>дженерік трейт</strong></em> Трейт, що приймає параметри типу. Наприклад, оскільки трейт <code>scala.collection.Set</code> приймає параметр типу, він є дженерік трейтом.</p></div>
<div class="paragraph"><p><em><strong>додатковий конструктор</strong></em> Додаткові конструктори визначаються в фігурних дужках визначення класа, що виглядає як визначення методів з ім'ям <code>this</code>, але без типу повернення.</p></div>
<div class="paragraph"><p><em><strong>допоміжна функція</strong></em> Функція, чиє призначення є провадити сервіс до одної або декількох функцій. Допоміжні функції часто реалізовані як локальні функції.</p></div>
<div class="paragraph"><p><em><strong>допоміжний метод</strong></em> Допоміжна функція, що є членом класу. Допоміжні методи часто є приватними.</p></div>
<div class="paragraph"><p><em><strong>еквівалентність</strong></em> Коли використовується без кваліфікації, еквівалентність є відношення, виражене <code>==</code>. Дивіться також <em>еквівалентність посилань</em>.</p></div>
<div class="paragraph"><p><em><strong>еквівалентність посилань</strong></em> Еквівалентність посилань означає, що два посилання ідентифікують той самий  Java об'єкт. Еквівалентність посилань може бути визначена тільки для типів посилань, через виклик <code>eq</code> на <code>AnyRef</code>. (В програмах Java еквівалентність посилань може бути визначена з використанням <code>==</code> на типах посилань Java.)</p></div>
<div class="paragraph"><p><em><strong>замикання</strong></em> Функціональний об'єкт, що захоплює вільні змінні, та, як кажуть, "замкнений" на змінних, видимих під час свого створення.</p></div>
<div class="paragraph"><p><em><strong>застосування</strong></em> Ви можете застосувати метод, функцію або замикання до аргументів, що означає, що ви викликаєте їх на ціх аргументах.</p></div>
<div class="paragraph"><p><em><strong>затінення</strong></em> Нова декларація локальної змінної затінює таку з тим же ім'ям в оточуючому полі зору.</p></div>
<div class="paragraph"><p><em><strong>захисник шаблону</strong></em> В виразі <code>match</code> це альтернатива, захисник шаблону може слідувати за шаблоном. Наприклад, в <code>case x if x % 2 == 0 =&gt; x + 1</code>, захисник шаблону є <code>if x % 2 == 0</code>. Випадок з захисником шаблону буде обраною тільки якщо співпадає шаблон, та захисник шаблону видає <code>true</code>.</p></div>
<div class="paragraph"><p><em><strong>змінна</strong></em> Іменована сутність, що посилається на об'єкт. Змінна є або <code>val</code>, або <code>var</code>. Обоє, <code>val</code> та <code>var</code> мають бути ініціалізовані при визначенні, але тільки <code>var</code> потім можуть бути переприсвоєні, щоб посилатись на інший об'єкт.</p></div>
<div class="paragraph"><p><em><strong>значення</strong></em> Результат любого обчислення або виразу в Scala є значення, та в Scala кожне значення є об'єктом. Термін "значення" в основному означає образ об'єкта в пам'яті (в купі JVM або в стеку).</p></div>
<div class="paragraph"><p><em><strong>імперативний стиль</strong></em> Імперативний стиль програмування підкреслює уважне ставлення до послідовності операцій, так, щоб їх ефект відбувався в вірному порядку. Стиль характеризується ітераціями в циклі, змінами даних на місці, та методами з побічними ефектами. Це домінуюча парадигма таких мов, як C, C++, C# та Java, та контрастує з <em>функціональним стилем</em>.</p></div>
<div class="paragraph"><p><em><strong>інваріант</strong></em> Інваріант використовується в два способи. Це може означати властивість, що завжди має бути <code>true</code>, коли структура даних гарно-сформована. Наприклад, це інваріант для впорядкованого бінарного дерева, що кожний вузол впорядкований перед своїм правим підвузлом, якщо той існує. Інваріант також іноді використовується як синонім до неваріантності: "клас <code>Array</code> є інваріантним по своєму параметру типу".</p></div>
<div class="paragraph"><p><em><strong>ініціалізація</strong></em> Коли змінна визначається в джерельному коді Scala, ви маєте ініціалізувати її значенням об'єкту.</p></div>
<div class="paragraph"><p><em><strong>карування</strong></em> Спосіб записати функцію з декількома списками параметрів. Наприклад, <code>def f(x: Int)(y: Int)</code> є карована функція з двома списками параметрів. Карована функція застосовується передачею декількох списків аргументів, як <code>f(3)(4)</code>. Однак, також можливо написати часткове застосування карованої функції, як <code>f(3)</code>.</p></div>
<div class="paragraph"><p><em><strong>клас</strong></em> Визначається ключовим словом <code>class</code>, клас може бути або абстрактним, або суцільним, та може бути параметризований типами та значеннями при створенні примірника. В виразі <code>new Array[String](2)</code> клас, примірник якого створюється, є <code>Array</code>, і тип значення, що утворюється, є <code>Array[String]</code>. Клас, що приймає параметри типів називається <em>конструктором типів</em>. Також можна сказати, що тип має свій клас: наприклад, клас типу <code>Array[String]</code> є <code>Array</code>.</p></div>
<div class="paragraph"><p><em><strong>клас компанйон</strong></em> Клас, що поділяє те саме ім'я з об'єктом синглтоном, визначеним в тому ж джерельному файлі. Клас є класом компанйоном синглтон об'єкта.</p></div>
<div class="paragraph"><p><em><strong>коваріантність</strong></em> <em>Коваріантна</em> анотація може бути застосована до параметру типу класа або трейта, через покладання знаку плюс (+) перед параметром типу. Клас або трейт потім утворює субтипи коваріантно — в тому самому напрямку — до анотованого параметром типу. Наприклад, <code>List</code> є коваріантним в своєму параметрі типу, так що <code>List[String]</code> є субтипом <code>List[Any]</code>.</p></div>
<div class="paragraph"><p><em><strong>конструктор типу</strong></em> Клас або трейт, що приймає параметри типу.</p></div>
<div class="paragraph"><p><em><strong>контрваріантність</strong></em> <em>Контрваріантна</em> анотація може бути застосована до параметру типу класу або трейту, через покладання знаку мінус (-) перед параметром типу. Клас або трейт потім утворює субтипи контрваріантно — в протилежному напрямку — до анотованого типом параметру. Наприклад, <code>Function1</code> є контрваріантною в своєму першому параметрі, так що <code>Function1[Any, Any]</code> є субтипом <code>Function1[String, Any]</code>.</p></div>
<div class="paragraph"><p><em><strong>літерал</strong></em> <code>1</code>, <code>"One"</code>, та <code>(x: Int) =&gt; x + 1</code> є прикладами літералів. Літерал є скороченням для опису об'єкта, коли скоровення в точності відображує структуру створюваного об'єкту.</p></div>
<div class="paragraph"><p><em><strong>локальна змінна</strong></em> Локальна змінна є <code>val</code> або <code>var</code> визначена в блоці. Хоча подібні до локальних змінних, параметри функцій не посилаються як на локальні змінні, але просто як на параметри або "змінні", без "локальні".</p></div>
<div class="paragraph"><p><em><strong>локальна функція</strong></em> Локальна функція є <code>def</code>, визначений в блоці. Для контрасту, <code>def</code>, визначена як слен класу, трейту або об'єкту синглтону називається методом.</p></div>
<div class="paragraph"><p><em><strong>мета-програмування</strong></em> Мета-програмування програмного забезпечення є програми, які на вході також мають програми. Компіляттори є мета-програмами, як і інструменти, як scaladoc. Програми мета-програмування потрібні для робити будь що за допомогою анотацій.</p></div>
<div class="paragraph"><p><em><strong>метод</strong></em> Метод є функція, що є членом днякого класу, трейту або об'єкта синглтона.</p></div>
<div class="paragraph"><p><em><strong>метод без параметрів</strong></em> Метод <em>без параметрів</em> є функція без параметрів, що є членом класу, трейта або об'єкта синглтона.</p></div>
<div class="paragraph"><p><em><strong>міксін</strong></em> Міксін є назвою трейта, коли він застосований в міксін композиції. Іншими словами, в <code>trait Hat</code>, <code>Hat</code> є просто трейтом, але в <code>new Cat extends AnyRef with Hat</code>, <code>Hat</code> може бути названий міксіном. Коли використовується як дієслово, "mix in" є двома словами. Наприклад, ви можете міксувати трейти в класи або інші трейти.</p></div>
<div class="paragraph"><p><em><strong>міксін композиція</strong></em> Процес міксування трейтів в класи або інші трейти. Міксін композиція відрізняється від традиційного множинного наслідування, в тому, що тип посилання <code>super</code> невідомий в точці визначення трейта, але скоріше визначається поновій кожного разу, коли трейт міксується в клас або інший трейт.</p></div>
<div class="paragraph"><p><em><strong>множинне визначення</strong></em> Той самий вираз може бути присвоєний в декількох визначеннях, якщо ви використовуєте синтаксис <code>val v1, v2, v3 = exp</code>.</p></div>
<div class="paragraph"><p><em><strong>модифікатор</strong></em> Ключове слово, що кваліфікує визначення класу, трейта, поля або метода, в деякий спосіб. Наприклад, модифікатор <code>private</code> вказує що клас, трейт, поле або метод буде визначений, як приватний.</p></div>
<div class="paragraph"><p><em><strong>напів-структуровані дані</strong></em> Дані XML є напів структурованими. Вони більш структуровані, ніж суцільно бінарний файл, або текстовий файл, але вони не мають повної структури, як структури даних в мовах програмування.</p></div>
<div class="paragraph"><p><em><strong>неваріантність</strong></em> Параметр типу класу або трейта по замовчанню є неваріантним. При цьому клас або трейт не утворює субтип при зміні параметрів. Наприклад, оскільки клас <code>Array</code> є неваріантним по своєму параметру типа, <code>Array[String]</code> не є ні субтипом, ані супертипом <code>Array[Any]</code>.</p></div>
<div class="paragraph"><p><em><strong>недосяжні значення</strong></em> На рівні Scala об'єкти можуть стати недосяжні, та в цій точці пам'ять, що вони займають, повертається в рантайм. Недосяжність не обов'язково означає <em>без посилань</em>. Типи посилань (примірники <code>AnyRef</code>) реалізовані як об'єкти, що розташовуються в купі JVM. Коли примірник типу посилання стає недосяжний, він дійсно стає без посилань, і стає предметом збирача сміття. Типи значень (примірники <code>AnyVal</code>) реалізовані одночасно як примітивні типи значень, або примірники типів огорток Java (таких як <code>java.lang.Integer</code>), що розташовуються в купі. Примірники типів значень можуть бути боксовані (перетворені з примітивних значень до об'єкту огортки) та розбоксовані (перетворені з об'єкта огортки на примітивне значення) на протязі життєвого циклу змінних, що посилаються на значення. Якщо примірник типу значення наразі представлено як об'єкт огортки в купі JVM, і він стає недосяжним, він також стає без посилань, та доступний для збору сміття. Але якщо тип значення наразі представлений як примітивне значення, та стає недосяжним, тоді він не втрачає посилань, оскільки він не існує як об'єкт в купі JVM, щонайменьше в цій точці часу. Рантайм може повернути пам'ять, зайняту недосяжними об'єктами, але якщо, наприклад, <code>Int</code>, реалізований під час виконання як примітив  Java <code>int</code>, що займає деяку пам'ять у фреймі стеку, тоді пам'ять для цього об'єкту "відновлюється", коли фрейм стеку виштовхується при завершенні метода. Пам'ять для типів посилань, такі як String, може бути відновлена збирачем сміття JVM, після того, як вони стали недосяжними.</p></div>
<div class="paragraph"><p><em><strong>незмінний</strong></em> Об'єкт є <em>незмінним</em>, якщо його значення не може бути зміненим після його створення в жодний спосіб, видимий для клієнтів. Об'єкти можуть бути або не бути змінними.</p></div>
<div class="paragraph"><p><em><strong>об'єкт компанйон</strong></em> Об'єкт синглтон, що поділяє те саме ім'я з класом, визначеним в тому самому джерельному файлі. Компанйон об'єкти та класи мають доступ до приватних членів один одного. На додаток, любі неявні перетворення, визначені в компанйон об'єкті, будуть в полі зору будь-де, де використовується клас.</p></div>
<div class="paragraph"><p><em><strong>об'єкт синглтон</strong></em> Об'єкт, визначений за допомогою ключового слова <code>object</code>. Кожний об'єкт синглтон має один, і тільки один примірник. Об'єкт синглтон, що поділяє ім'я з класом, та визначений в тому самому джерельному файлі, що і клас, є об'єктом компанйоном цього класу. Клас є його класом компанйоном. Об'єкт синглтон, що не має класа компанйона, є <em>окремим об'єктом</em>.</p></div>
<div class="paragraph"><p><em><strong>обмеження типу</strong></em> Деякі анотації є обмеженнями типу, що означає, що вони додають межі, або обмеження на значення, які включає тип. Наприклад, <code>@positive</code> може бути обмеженням типу на типі <code>Int</code>, обмежуючи тип  32-бітних цілих до додатніх значень. Обмеження тиаів не перевіряються стандартним компілятором Scala, та замість цього мають бути перевірені зовнішінім інструментом, або плагіном компілятора.</p></div>
<div class="paragraph"><p><em><strong>окремий об'єкт</strong></em> Об'єкт синглтон, що не має класа компанйона.</p></div>
<div class="paragraph"><p><em><strong>операція</strong></em> В Scala, кожна <em>операція</em> є викликом метода. Методи можуть бути викликані в операторній нотації, як <code>b + 2</code>, та в цій нотації <code>+</code> є оператором.</p></div>
<div class="paragraph"><p><em><strong>охоплення <code>for</code></strong></em> Інша назва для _виразу <code>for_</code>.</p></div>
<div class="paragraph"><p><em><strong>параметр</strong></em> Функції можуть мати нуль або більше параметрів. Кожний параметр має ім'я та тип. Різниця між параметрами та аргументами в тому, що аргументи посилаються на дійсні передані об'єкти, коли функція викликається. Параметри є змінними, що посилаються на ці передані аргументи.</p></div>
<div class="paragraph"><p><em><strong>параметр за-значенням</strong></em> Параметр, що <em>не</em> позначений <code>=&gt;</code> перед типом параметру, як в <code>(x: Int)</code>. Аргумент, що відповідає параметру за-значенням, обчислюється перед викликом метода. Параметри за-значенням відрізняються від параметрів <em>за-ім'ям</em>.</p></div>
<div class="paragraph"><p><em><strong>параметр за-ім'ям</strong></em> Парметр, що позначений <code>=&gt;</code> перед типом параметра, як в <code>(x: =&gt; Int)</code>. Аргумент, що відповідає параметру за ім'ям, обчислюється не перед викликом метода, але кожного разу, коли на параметр є посилання <em>за ім'ям</em> в методі. Якщо параметр не є параметром за-ім'ям, він є <em>за-значенням</em>.</p></div>
<div class="paragraph"><p><em><strong>параметр типу</strong></em> Параметр дженерік класу або дженерік методу, що має бути заповнений типом. Наприклад, клас <code>List</code> визначений як <code>class List[T] { ...</code>, та метод <code>identity</code>, член об'єкта <code>Predef</code>, визначений як <code>def identity[T](x:T) = x</code>. T в обох випадках є параметром типу.</p></div>
<div class="paragraph"><p><em><strong>параметричне поле</strong></em> Поле, визначене як параметр класу.</p></div>
<div class="paragraph"><p><em><strong>переприсвоєння</strong></em> Змінна може бути, або не бути переприсвоюваною. <code>var</code> повторно присвоюється, тоді як <code>val</code> - ні.</p></div>
<div class="paragraph"><p><em><strong>первинний конструктор</strong></em> Головний конструктор класу, що викликає конструктор суперкласу, якщо це потрібно, ініціалізує поля переданими значеннями, та виконує високорівневий код, визначений між фігурними дужками класу. Поля ініціалізовані тільки для значень параметрів, не переданих до конструктора суперкласів, за винятком таких, що не використовуються в тілі класу, і, таким чином, можуть бути "оптимізовані" геть.</p></div>
<div class="paragraph"><p><em><strong>першокласна функція</strong></em> Scala підтримує <em>першокласні функції</em>, що означає, що ви можете виразити функції в синтаксисі <em>функціональних літералів</em>, тобто, <code>(x: Int) =&gt; x + 1</code>, і ці функції можуть представлені об'єктами, що називаються <em>функціональними значеннями</em>.</p></div>
<div class="paragraph"><p><em><strong>підстановочний тип</strong></em> Підстановочний тип включає посилання на змінні типів, що наразі невідомі. Наприклад, <code>Array[_]</code> є підстановочним типом. Це масив, де елемент типу повністю невідомий.</p></div>
<div class="paragraph"><p><em><strong>повернення</strong></em> Функція в програмі Scala повертає значення. Ви можете назвати це значення результатом функції. Ви також можете сказати, що результатом функції є значення. Результат кожної функції в Scala є об'єкт.</p></div>
<div class="paragraph"><p><em><strong>повідомлення</strong></em> Актори комунікують один з одним через надсилання один одному повідомлень. Надсилання повідомлення не перериває те, що робить отримувач. Отримувач може зачекати, доки він скінчить свою поточну активність, та їх інваріанти будуть дотримуватись.</p></div>
<div class="paragraph"><p><em><strong>посилається</strong></em> Змінна в роблячій програмі Scala завжди посилається на деякий об'єкт. Навіть якщо змінній присвоєне <code>null</code>, вона концептуально посилається на об'єкт <code>Null</code>. Під час виконання об'єкт може бути реалізований як Java об'єкт або значення примітивного типу, але Scala дозволяє програмістам думати на вищому рівні абстракції щодо їх кода, як вони уявляють виконання. Також дивіться <em>посилання</em>.</p></div>
<div class="paragraph"><p><em><strong>посилання</strong></em> Посилання в абстракціях Java є вказівник, що унікально ідентифікує об'єкт, що знаходиться на купі JVM. Тип посилання змінних містить посилання на об'єкти, оскільки типи посилання (примірники <code>AnyRef</code>) реалізовані як Java об'єкти, що зберігаються на купі JVM. Для контрасту, змінні типу значення можуть іноді містити посилання (на боксований тип огортки), та іноді ні (коли об'єкт представлений як примітивне значення). Кажучи загалом, змінна Scala посилається на об'єкт. Термін "посилається" більш абстрактний, ніж "містить посилання". Якщо змінна є типу <code>scala.Int</code> наразі представлена як примітивне значення Java <code>int</code>, тоді змінна все ще посилається на об'єкт <code>Int</code>, але посилання не задіяне.</p></div>
<div class="paragraph"><p><em><strong>предикат</strong></em> Предикат є функцією з типом результату <code>Boolean</code>.</p></div>
<div class="paragraph"><p><em><strong>прив'язана змінна</strong></em> Прив'язана змінна в виразі є змінна, що є одночасно визначена та використана в виразі. Наприклад, в виразі функціонального літерала <code>(x: Int) =&gt; (x, y)</code>, використовуються обоє змінні, <code>x</code> та <code>y</code>, але тільки <code>x</code> прив'язана, оскільки вона визначається в виразі як <code>Int</code>, і є єдиним аргументом функції, визначеній цім виразом.</p></div>
<div class="paragraph"><p><em><strong>примірник</strong></em> Примірник, або примірник класу, є об'єктом, концепцією, що існує тільки під час виконання.</p></div>
<div class="paragraph"><p><em><strong>принцип уніформного доступу</strong></em> Принцип уніформного доступу стверджує, що змінні та функції без параметрів повинні отримувати доступ за однаковим синтаксисом. Scala підтримує цей принцип, не дозволяючи ставити дужки в місці виклику функцій без параметрів. Як результат, визначення функції без параметрів може бути змінена на <code>val</code>, або навпаки, без впливу на код клієнта.</p></div>
<div class="paragraph"><p><em><strong>присвоєння</strong></em> Ви можете присвоїти об'єкт до змінної. Після цього змінна буде посилатись на об'єкт.</p></div>
<div class="paragraph"><p><em><strong>прозорість посилання</strong></em> Властивість функцій, що незалежні від тимчасового контексту, та не мають побічних ефектів. Для певного вводу виклик прозорої до посилання функції може бути замінене не її результат, без зміни семантики програми.</p></div>
<div class="paragraph"><p><em><strong>процедура</strong></em>  <em>Процедура</em> є функція, результат якої <code>Unit</code>, і яка, таким чином, виконується виключно для її побічних ефектів.</p></div>
<div class="paragraph"><p><em><strong>прямий субклас</strong></em> Клас є <em>прямим субкласом</em> свого прямого суперкласу.</p></div>
<div class="paragraph"><p><em><strong>прямий суперклас</strong></em> Клас, від якого клас або трейт напрму походить, найближчий клас вище в його ієрархії наслідування. Якщо клас <code>Parent</code> споминається в опціональному твердженні <code>extends</code> класу <code>Child</code>, тоді <code>Parent</code> є прямим суперкласом <code>Child</code>. Якщо трейт вказується в твердженні <code>extends</code> <code>Child</code>, прямий суперклас трейту є прямим суперкласом <code>Child</code>. Якщо <code>Child</code> не має твердження <code>extends</code>, тоді <code>AnyRef</code> є прямим суперкласом <code>Child</code>. Якщо прямий суперклас класу приймає параметри типу, наприклад, <code>class Child extends Parent[String]</code>, прямий суперклас <code>Child</code>  все ще <code>Parent</code>, не <code>Parent[String]</code>. З іншого боку, <code>Parent[String]</code> буде прямим супертипом <code>Child</code>. Дивіться <em>супертип</em> щодо більшої дискусії про різницю між класами і типами.</p></div>
<div class="paragraph"><p><em><strong>рантайм</strong></em>  Середовище виконання Java Virtual Machine, або JVM, що виконує Scala програму. Рантайм охоплює обоє, віртуальну машину, як визначено в Java Virtual Machine Specification, та бібліотеки рантайму Java API і стандартного Scala API. Фраза <em>run time</em> (з проміжком між <code>run</code> та <code>time</code>) означає саме час, коли виконується програма, та контрастує з часом компіляції.</p></div>
<div class="paragraph"><p><em><strong>рантайм тип</strong></em> Тип об'єкта під час виконання. Для контрасту, <em>статичний тип</em> є типом виразу під час компіляції. Більшість типів рантайму просто звичайні типи, без параметрів типу. Наприклад, рантайм типу <code>"Hi"</code> є <code>String</code>, та рантайм тип <code>(x: Int) =&gt; x + 1</code> є <code>Function1</code>. Рантайм типи можуть бути перевірені за допомогою <code>isInstanceOf</code>.</p></div>
<div class="paragraph"><p><em><strong>результат</strong></em> Вираз в програмі Scala дає результат. Результат кожного виразу в Scala є об'єктом.</p></div>
<div class="paragraph"><p><em><strong>рекурсивність</strong></em> Функція є рекурсивною, якщо вона викликає сама себе.</p></div>
<div class="paragraph"><p><em><strong>селектор</strong></em> Значення, що буде порівнюватись в виразі <code>match</code>. Наприклад, в <code>s match { case _ =&gt; }</code>, селектор є <code>s</code>.</p></div>
<div class="paragraph"><p><em><strong>серіалізація</strong></em> Ви можете серіалізувати об'єкт в потік байтів, що потім може бути збережений або переданий по мережі. Ви можете пізніше де-серіалізувати потік байтів, навіть на іншому комп'ютері, та отримати об'єкт, що той самий, що і оригінальний серіалізований об'єкт.</p></div>
<div class="paragraph"><p><em><strong>сигнатура</strong></em> Сигнатура є скороченням від <em>сигнатури типів</em>.</p></div>
<div class="paragraph"><p><em><strong>сигнатура типу</strong></em> Сигнатура типу метода складається з імені, числа, порядку, та типів його параметрів, якщо такі є, та його результуючого типу. Тип сигнатури класу, трейта, або об'єкта синглтона складається з його імені, типу сигнатур всіх його членів та конструкторів, та його задекларованих відношень наслідування та міксінів.</p></div>
<div class="paragraph"><p><em><strong>синтетичний клас</strong></em> Синтетичний клас є згенерований автоматично компілятором, скоріше, ніж бути написаним руками програміста.</p></div>
<div class="paragraph"><p><em><strong>скрипт</strong></em> Файл, що містить високорівневі визначення та твердження, що може бути виконаний напряму за допомогою <code>scala</code>, без явної компіляції. Скрип має завершувати виразом, не визначенням.</p></div>
<div class="paragraph"><p><em><strong>статичний тип</strong></em> Дивіться <em>тип</em>.</p></div>
<div class="paragraph"><p><em><strong>створення примірнику</strong></em> Створити примірник класу означає створити новий об'єкт з класу, дія, що відбувається тільки під час виконання.</p></div>
<div class="paragraph"><p><em><strong>субклас</strong></em> Клас є субкласом для всіх своїх суперкласів та супертрейтів.</p></div>
<div class="paragraph"><p><em><strong>субтип</strong></em> Компілятор буде дозволяти любий з субтипів типу використовуваться як замінник, коли вимагається використання типу. Для класів та трейтів, що не приймають параметрів типу, відношення субтипів відзеркалює відношення субкласів. Наприклад, якщо клас <code>Cat</code> є субкласом абстрактного класу <code>Animal</code>, та жодний не приймає параметрів типу, тип <code>Cat</code> є субтипом <code>Animal</code>. Подібно до цього, якщо трейт <code>Apple</code> є субтрейтом трейту <code>Fruit</code>, та жодний не приймає параметрів, тип <code>Apple</code> є субтипом типу <code>Fruit</code>. Однак для класів та трейтів, що приймають параметри типу, в гру вступає варіантність. Наприклад, оскільки абстрактний клас <code>List</code> декларований коваріантним по своєму єдиному параметру типа (тобто, <code>List</code> декларований як <code>List[+A]</code>), <code>List[Cat]</code> є субтипом <code>List[Animal]</code>, та <code>List[Apple]</code> є субтипом <code>List[Fruit]</code>. Ці відношення субтипів існують навіть не зважаючи на те, що клас кожного з ціх типів є <code>List</code>. Для контрасту, оскільки <code>Set</code> не декларований як коваріантний по своєму параметру типа (тобто, <code>Set</code> декларований як <code>Set[A]</code> без знака плюс), <code>Set[Cat]</code> не є субтипом <code>Set[Animal]</code>. Субтип повинен коректно реалізувати контракти супертипів, так що тут застосовуюється Принцип Заміни Ліскова, але компілятор тільки перевіряє цю властивість на рівні перевірки типів.</p></div>
<div class="paragraph"><p><em><strong>субтрейт</strong></em> Трейт є субтрейтом для всіх своїх супертрейтів.</p></div>
<div class="paragraph"><p><em><strong>суперклас</strong></em> Суперкласу класу включають всі прямі суперкласи, прямі суперкласи ціх суперкласів, і так далі, аж до <code>Any</code>.</p></div>
<div class="paragraph"><p><em><strong>супертип</strong></em> Тип є супертипом всіх своїх субтипів.</p></div>
<div class="paragraph"><p><em><strong>супертрейт</strong></em> Супертрейти класу або трейтів, якщо такі є, включають всі трейти, напряму зміксовані в клас або трейт любого зі своїх суперкласів, плюс любі супертрейти ціх трейтів.</p></div>
<div class="paragraph"><p><em><strong>твердження</strong></em> Вираз, визначення або імпорт, тобто речі, що можуть іти в шаблоні або блоці в джерельному коді Scala.</p></div>
<div class="paragraph"><p><em><strong>тип</strong></em> Кожна змінна та вираз в програмі Scala має тип, що відомий під час компіляції. Тип обмежує можливі значення, на які може посилатись змінна, або яке може продукувати вираз під час виконання. Змінна або тип виразу також може посилатись на статичний тип, якщо треба відрізняти його від типу об'єкту під час виконання. Іншими словами, "тип" сам по собі означає статичний тип. Тип відрізняється від класу, бо клас, що приймає параметри типу, може конструювати багато типів. Наприклад, <code>List</code> є класом, але не типом. <code>List[T]</code> є типом з вільним параметром типу. <code>List[Int]</code> та <code>List[String]</code> також є типами (так звані заземлені типи, бо не мають вільних параметрів типів). Тип може мати "клас" або "трейт." Наприклад, клас типу <code>List[Int]</code> є <code>List</code>. Трейт типу <code>Set[String]</code> є <code>Set</code>.</p></div>
<div class="paragraph"><p><em><strong>тип значення</strong></em> Тип значення є любим субкласом <code>AnyVal</code>, такий як <code>Int</code>, <code>Double</code>, або <code>Unit</code>. Цей термін має значення на рівні джерельного коду Scala. Під час виконання примірники значень типів, що відповідають до примітивних типів Java, можуть бути реалізовані в термінах значень примітивних типів або примірників класів огорток, таких як <code>java.lang.Integer</code>. Під час життєвого циклу примірника рантайм може трансформувати тип між примітивним типом та огорткою (тобто, боксувати та розбоксувати змінну).</p></div>
<div class="paragraph"><p><em><strong>тип посилання</strong></em> Тип посилання є субкласом <code>AnyRef</code>. Примірники типу посилання під час виконання знаходяться в купі JVM.</p></div>
<div class="paragraph"><p><em><strong>тип результату</strong></em> Тип результату метода є тип значення, що є результатом виклику метода. (В Java, ця концепція називається <em>типом повернення</em>.)</p></div>
<div class="paragraph"><p><em><strong>тип <code>self</code></strong></em>  _Тип <code>self`_ трейта є удаваний тип `this</code>, отримувача, що буде використовуватись в цьому трейті. Любий суцільний клас, що міксує трейт, має переконатись, що цей тип відповідає до типу трейта <code>self</code>. Найбільш загальне використання типів <code>self</code> є для поділення великих класів на декілька трейтів, як описано в Главі 29.</p></div>
<div class="paragraph"><p><em><strong>трейт</strong></em> Трейт, що визначений за допомогою ключового слова <code>trait</code>, подібний до абстрактного класу, що не може приймати жодних значень параметрів, та може бути "заміксований" в класи або інші трейти через процес, відомий як міксін композиція. Коли клас міксується в клас або трейт, він називається міксіном. Трейт може бути параметризований одним або більше типами. Коли трейт параметризований типами, він створює тип. Наприклад, <code>Set</code> ґ трейтом, що приймає один параметр типу, тоді як <code>Set[Int]</code> є типом. Також кажуть, що <code>Set</code> є "трейтом типу" <code>Set[Int]</code>.</p></div>
<div class="paragraph"><p><em><strong>удосконалення типу</strong></em> Тип, сформований через надання базовому типу декількох членів в фігурних дужках. Члени в фігурних дужках удосконалюють типи, що присутні в базовому типі. Наприклад, тип "animal that eats grass" є <code>Animal { type SuitableFood = Grass }</code>.</p></div>
<div class="paragraph"><p><em><strong>фільтр, або вираз фільтру</strong></em> <code>if</code>, за яким слідує логічний виразв виразі <code>for</code>. В <code>for(i &lt;- 1 to 10; if i % 2 == 0)</code> фільтр є <code>if i % 2 == 0</code>. Значення зправа від <code>if</code> є виразом фільтра.</p></div>
<div class="paragraph"><p><em><strong>фільтруючий вираз</strong></em> Фільтруючий вираз, або вираз фільтру, є логічний вираз, що слідує за <code>if</code> в виразі <code>for</code>. В <code>for(i &lt;- 1 to 10; if i % 2 == 0)</code> вираз фільтру є "i % 2 == 0".</p></div>
<div class="paragraph"><p><em><strong>функціональне значення</strong></em> Об'єкт функції, що може бути викликаний так само, як люба інша функція. Клас функціонального значення розширює один з трейтів <code>FunctionN</code> (тобто, <code>Function0</code>, <code>Function1</code>) з пакунку <code>scala</code>, та and isusually expressed in source code via function literal syntax. A function value is "invoked" when its apply method is called. A function value that captures free variables is a <em>closure</em>.</p></div>
<div class="paragraph"><p><em><strong>функціональний літерал</strong></em> Функція без імені в джерельному коді Scala, задана за допомогою синтаксису функціонального літералу. Наприклад, <code>(x: Int, y: Int) =&gt; x + y</code>.</p></div>
<div class="paragraph"><p><em><strong>функція</strong></em> <em>Функція</em> може бути <em>викликана</em> зі списком аргументів, щоб спродукувати результат. Функція має список параметрів, тіло, та тип результата. Функції, що є членами класу, трейта або об'єкта синглтона, називаються <em>методами</em>. Функції, визначені в інших функціях, називаються <em>локальними функціями</em>. Функції, тип результата яких є <code>Unit</code> називаються <em>процедурами</em>. Анонімні функції в джерельному коді називаються <em>функціональними літералами</em>. Під час виконання функціональні літерали стають примірниками об'єктів, що називаються <em>функціональними значеннями</em>.</p></div>
<div class="paragraph"><p><em><strong>функціональний стиль</strong></em> <em>Функціональний стиль</em> програмування наголошує на функціях та обчисленні результатів, та не робить наголос на порядку, в якому трапляються оператори. Стиль характеризується передачею функціональних значень в циклічні методи, незмінними даними, методами без побічних ефектів. Це домінантна парадигма таких мов, як Haskell та Erlang, та контастує з <em>імперативним стилем</em>.</p></div>
<div class="paragraph"><p><em><strong>хвостова рекурсія</strong></em> Функція має хвостову рекурсію, якщо єдине місце, де вона викликає сама себе - це остання операція функції.</p></div>
<div class="paragraph"><p><em><strong>цільова типізація</strong></em> Цільова типізація є формою виводу типів, що приймає до уваги очікуваний тип. Наприклад, в <code>nums.filter((x) =&gt; x &gt; 0)</code>, компілятор Scala виводить тип <code>x</code> як тип елементів <code>nums</code>, оскільки метод <code>filter</code> викликає функцію на кожному елементі <code>nums</code>.</p></div>
<div class="paragraph"><p><em><strong>частково застосована функція</strong></em> Функція, що використовується в виразі, та в якій відсутні деякі з його аргументів. Наприклад, якщо функція <code>f</code> має тип <code>Int =&gt; Int =&gt; Int</code>, тоді <code>f</code> та <code>f(1)</code> є частково застосовані функції.</p></div>
<div class="paragraph"><p><em><strong>член</strong></em> Член це любий іменований елемент шаблона класу, трейта або об'єкта синглтона. Член може бути доступний через ім'я власника, крапку, та просте ім'я члену. Наприклад, високорівневі поля та методи, визначені в класі, є членами цього класу. Трейт, визначений в класі, є членом оточуючого класу. Тип, визначений за допомогою ключового слова <code>type</code> в класі, є членом цього класу. Клас є членом пакунку, в якому він визначений. Для контрасту, локальна змінна або локальна функція не є членом свого оточуючого блока.</p></div>
<div class="paragraph"><p><em><strong>шаблон класа</strong></em> Шаблон є тілом визначення класу, трейта, або об'єкта синглтона. Він визначає тип сигнатури, поведінки та початковий стан класу, трейта або об'єкта.</p></div>
<div class="paragraph"><p><em><strong>шаблон порівняння</strong></em> В виразі <code>match</code> альтернативі, шаблон слідує за кожним ключовим словом <code>case</code> та стоїть перед або захисником шаблона, або перед символом <code>=&gt;</code>.</p></div>
<div class="paragraph"><p><em><strong>шляхо-залежний тип</strong></em> Тип, як <code>swiss.cow.Food</code>. Частина <code>swiss.cow</code> є шляхом, що формує посилання на об'єкт. Значення типу чутлива до шляху, що ви використовуєте для доступа до нього. Наприклад, типи <code>swiss.cow.Food</code> та <code>fish.Food</code> є різними типами.</p></div>
<div class="paragraph"><p><em><strong>JVM</strong></em> JVM є Java Virtual Machine, або рантайм, середовище виконання, що містить програму, що виконується Scala програма.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-19 01:10:07 EET
</div>
</div>
</body>
</html>
