include::headers.adoc[]

Глава 9
-------

Абстракції керування
====================

В Главі 7 ми вказали, що Scala не має багато вбудованих абстракцій керування, оскільки вона надає вам можливість створювати ваші власні. В попередній главі ви навчились щодо функціональних значень. В цій главі ми покажемо вам, як застосовувати функціональні значення для створення нових абстракцій керування. По ходу справи ми вивчимо, що таке карування та параметри за ім'ям.

9.1 Зменьшення дублікації коду
------------------------------
Всі функції поділяються на загальні частини, що є ті самі за кожного виклику функції, та незагальні частини, що можуть змінюватись від одного виклику до іншого. Загальні частини знаходяться в тілі функції, тоді як незагальні частини мають бути надані через аргументи. Коли ви використовуєте функцію як аргумент, незагальна частина алгоритму сама є деяким іншим алгоритмом! За кожного виклику такої функції ви можете передати інше функціональне значення як аргумент, і викликана функція буде, за своїм вибором, викликати передане функціональне значення. Ці __функції вищих порядків__ — функції, що приймають функції як параметри, даватимуть вам додаткові можливості стиснути та спростити код.

Одна з вигод функцій вищого порядку в тому, що вони надають можливість створювати керівні абстракції, які дозволяють вам зменшити дублікацію кода. Наприклад, уявімо, що ви пишете переглядач файлів, і ви бажаєте впровадити API, що дозволяє користувачам шукати файли, які співпадають з деяким критерієм. Перше, ви додаєте можливість пошуку файлів, чиє ім'я закінчується на певний рядок. Це надасть можливість вашим користувачам шукати, наприклад, всі файли з розширенням `.scala`. Ви можете провадити таке API, визначивши публічний метод `filesEnding` в об'єкті синглтоні, ось так:
[source,scala]
----
object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles

  def filesEnding(query: String) =
    for (file <- filesHere; if file.getName.endsWith(query))
      yield file
}
----
Метод `filesEnding` отримує список з усіх файлів в поточній директорії, використовуючи приватний допоміжний метод `filesHere`, потім фільтрує їх на сонові того, чи ім'я кожного файлу завершується на вказаний користувачем суфікс. Зважаючи що `filesHere` є приватним, метод `filesEnding` є єдиним доступним методом в  `FileMatcher`, API, що ви провадите для своїх користувачів.

Докі все гарно, і немає коду, що повторюється. Однак пізніше ви вирішуєте дозволити людям шукати на основі любої частини імені файла. Це гарно, коли користувачі не пам'ятають, чи вони назвали файл `phb-important.doc`, `stupid-phb-report.doc`, `may2003salesdoc.phb`, або якось зовсім інакше; вони можуть тільки запам'ятати, що десь в імен з'являється `phb`. Ви повертаєтесь до роботи, і додаєте цю функцію до вашого `FileMatcher API`:
[source,scala]
----
def filesContaining(query: String) =
  for (file <- filesHere; if file.getName.contains(query))
    yield file
----
Ця функція робить так само, як `filesEnding`. Вона шукає `filesHere`, перевіряє ім'я, та повертає файл, якщо ім'я співпадає. Одна різниця в тому, що ця функція використовує `contains` замість `ofendsWith`. 

Пройшли місяці, і програма стала більш успішною. З часом ви отримуєте запит від декількох досвідчених користувачів, які бажають шукати на основі регулярних запитів. Ці недбалі хлопці мають величезні каталоги з тисячами файлів, і вони бажають робити такі речі, як шукати всі файли `pdf`, що мають десь в назві `"oopsla"`. Щоб підтримати їх, ви пишете цю функцію:
[source,scala]
----
def filesRegex(query: String) =
  for (file <- filesHere; if file.getName.matches(query))
    yield file
----
ДОсвідчені програмісти зауважать всі ці повторення, та поміркують, чи не можна все це винести в загальну допоміжну функцію. Однак, якщо зробити це в очевидний спосіб не буде робити. Ви, можливо, хотіли б зробити щось таке:
[source,scala]
----
def filesMatching(query: String, null) =
  for (file <- filesHere; if file.getName.null(query))
    yield file
----
Цей підхід буде робити в деяких динамічних мовах, але Scala не дозволяє зліплювати код разом під час виконання, як тут. Так що ви можете зробити?

Функціональні значення провадять відповідь. Хоча ви не можете передати по колу ім'я метода як значення, ви можете досягти того ж ефекту, передаючи по колу функціональне значення, що викликає метод за вас. В цьому випадку ви можете додати до метода параметр `matcher`, чиє єдине призначення є перевіряти ім'я файлу відносно деякого запиту:
[source,scala]
----
def filesMatching(query: String,
    matcher: (String, String) => Boolean) = {
  
  for (file <- filesHere; if matcher(file.getName, query))
    yield file
}
----
В цій версії метода, вираз `if` тепер використовує `matcher` для перевірки імені файла відносно запиту. Що в точності це перевіряє залежить від того, що вказане як `matcher`. Тепер погляньте на тип самого `matcher`. Це функція, і таким чином має `=>` в своєму типі. Ця функція приймає два рядкових аргумента, ім'я файлу та запит, та повертає логічне значення, так що тип цієї функції є `(String, String) => Boolean`.

Маючи цей новий допоміжний метод `filesMatching` ви можете спростити три пошукові методи, щоб вони викликати допоміжний метод, якому передається відповідна функція:
[source,scala]
----
def filesEnding(query: String) =
  filesMatching(query, _.endsWith(_))

def filesContaining(query: String) =
  filesMatching(query, _.contains(_))

def filesRegex(query: String) =
  filesMatching(query, _.matches(_))
----
Функціональні літерали, показані в цьому прикладі, використовують синтаксис замінників, введений в попередній главі, що, можливо, не є досі природним для вас. Так що ось роз'яснення як роблять замінники: функціональний літерал 
----
_.endsWith(_)
----
використаний в методі `filesEnding`, означає те саме, що і:
[source,scala]
----
(fileName: String, query: String) => fileName.endsWith(query)
----
Оскільки `filesMatching` приймає функцію, що потребує два аргумента `String`, вам не треба вказувати типи його аргументів; ви можете просто писати `(fileName, query) => fileName.endsWith(query)`. Оскільки параметри використовуються тільки по одному разу кожний в тілі функції (тобто, перший параметр, `fileName`, використовується першим в тілі, та другий параметр, `query`, використовується другим), ви можете використовувати синтаксис замінників: `_.endsWith(_)`. Перше підкреслення є замінником для першого параметру, імені файлу, та друге підкреслення замінником для другого параметру, рядка запиту.

Цей код вже спрощений, але насправді він може бути ще коротший. Зауважте, що щапит був переданий до `filesMatching`, але `filesMatching` нічого не робить з `query`, крім того, що передає назад, до функції `matcher`. Це пересилання туди і назад непотрібне, оскільки викликач вже знає `query`, з якого починати! Ви можете також видалити параметр `query` з `filesMatching` та `matcher`, тим самим спростивши код так, як показано в Лістингу 9.1.
[source,scala]
----
object FileMatcher {
  private def filesHere = (new java.io.File(".")).listFiles

  private def filesMatching(matcher: String => Boolean) =
    for (file <- filesHere; if matcher(file.getName))
      yield file

  def filesEnding(query: String) =
    filesMatching(_.endsWith(query))

  def filesContaining(query: String) =
    filesMatching(_.contains(query))

  def filesRegex(query: String) =
    filesMatching(_.matches(query))
}
----
Лістинг 9.1 - Використання замикань для зменьшення дублікації коду.

Цей приклад демонструє спосіб, в який першокласні функції можуть допомогти уникнути дублікації коду, коли б це було дуже складно зробити без них. Наприклад, в Java ви можете створити інтерфейс, що містить метод, що приймає `String` та повертає `Boolean`, потім створити та передати примірники анонімних внутрішніх класів, що реалізують цей інтерфейс до `filesMatching`. Хоча цей підхід буде видаляти дублікацію, якої ми бажаємо уникнути, він буде, в той самий час, стільки ж, або більше, нового коду. Таким чином, вигоди не вартують ціли, і ви можете так само гарно жити з дублікацією.

Більше того, цей приклад демонструє, як замикання можуть допомогти зменшити дублікацію коду. Функціональні літерали, використані в попередньому прикладі, такі як `_.endsWith(_)` та `_.contains(_)`, під час виконання утворюють примірники функціональних значень, що не є замиканнями, бо вони не захоплюють жодних вільних змінних. Обі змінні, використані в вирарзі, наприклад, `_.endsWith(_)`, представлені підкресленнями, що означає, що вони взяті з аргументів функції. Таким чином, `_.endsWith(_)` використовує дві прив'язані змінні, і жодних вільних змінних. Для контрасту, функціональний літерал `_.endsWith(query)`, використана в останньому прикладі, містить прив'язану змінну, аргумент, представлений підкресленням, та одну вільну змінну на ім'я `query`. Це так тільки через те, що Scala підтримує замикання, так що ви були в змозі видалити параметр `query` з `filesMatching` в самому останньому прикладі, тим самим ще більше скоротивши код.

9.2 Спрощення клієнтського кода
-------------------------------
Попередній приклад демонструє, що функції вищого порядку можуть допомогти зменьшити дублікацію кода, коли ви реалізуєте API. Але важливе використання функцій вищого порядку є покладання їх в саме API, щоб зробити клієнтський код більш стислим. Гарний приклад надається методами циклів спеціального призначення на типах колекцій Scala.footnote:[Ці методи циклів спеціального призначення визначені в трейті `Traversable`, що розширюється `List`, `Set`, та `Map`. Дивіться Главу 17 щодо дискусії.] Багато з них перелічені в Таблиці 3.1 в Главі 3, але поки ми поглянемо тільки на один приклад, щоб побачити, чому ці методи такі користні.

Розглянемо метод `exists`, що визначає, чи передане значення міститься в колекції. Звичайно, ви можете шукати елементи, маючи `var` ініціалізоване в `false`, в циклі переглядадти колекцію, перевіряючи кожний елемент, та встановити `var` в `true`, якщо ви знайдете те, що шукаєте. Ось метод, що використовує цей підхід для визначення, чи переданий `List` містить від'ємне число:
[source,scala]
----
def containsNeg(nums: List[Int]): Boolean = {
  var exists = false
  for (num <- nums)
    if (num < 0)
      exists = true
  exists
}
----
Якщо ви визначите цей метод в інтерпретаторі, ви зможете викликати його ось так:
[source,scala]
----
scala> containsNeg(List(1, 2, 3, 4))
res0: Boolean = false

scala> containsNeg(List(1, 2, -3, 4))
res1: Boolean = true
----
Однак більш стислий шлях визначити цей метод, це викликати функцію вищого порядку `exists` на переданому `List`, ось так:
[source,scala]
----
def containsNeg(nums: List[Int]) = nums.exists(_ < 0)
----
Ця версія `containsNeg` видає той самий резільтат, що і попередній:
[source,scala]
----
scala> containsNeg(Nil)
res2: Boolean = false

scala> containsNeg(List(0, -1, -2))
res3: Boolean = true
----
Метод `exists` представляє абстракцію керування. Це циклічна конструкція особливого призначення, запровадженна бібліотекою Scala, скоріше ніж вбудована в мову Scala, як `while` або `for`. В попередньому розділі функція вищого порядку, `filesMatching`, зменьшує дублікацію коду в реалізації об'єкта `FileMatcher`. Метод `exists` провадить подібну перевагу, але оскільки `exists` є публічним в API колекцій Scala, дублікація коду, який він зменшує, є клієнтський код цього API. Якщо б не існував `exists`, і ви б бажали написати метод `containsOdd` для перевірки, чи список містить непарні числа, ви б могли написати це так:
[source,scala]
----
def containsOdd(nums: List[Int]): Boolean = {
  var exists = false
  for (num <- nums)
    if (num % 2 == 1)
      exists = true
exists
}
----
Якщо ви порівняєте тіло `containsNeg` з таким в `containsOdd`, ви знайдете, що все повторюється, за винятком умови перевірки в виразі `if`. Використовуючи `exists`, замість ви можете записати таке:
[source,scala]
----
def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)
----
Тіло кода в цій версії знову ідентичне до тіла відповідного метода `containsNeg` (версія, що використовує `exists`), за винятком того, що відрізняється умова, по якій виконується пошук. Знову, кількість дублікованого коду є значно меньшим, оскільки вся циклічна інфраструктура виділена в самий метод `exists`. В стандартній бібліотеці Scala існує багато інших циклічних методів. Як і з `exists`, вони часто можуть скоротити ваш код, якщо ви розпізнаєте можливість використати їх.

9.3 Карування
-------------
В Главі 1 ми казали, що Scala дозволяє вам створювати нові абстракції керування, що "відчуваються як природна підтримка мови". Хоча приклади, що ви бачили досі, напевне є абстраціями керування, навряд що хтось помилково зплутає їх з природною підтримкою мови. Щоб зрозуміти, як створити абстракції керування, що відчуваються більш подібно до розширень мови, зпочатку вам треба зрозуміти прийом функціонального програмування, що називається _карування_. Карована функція застосовується до декількох списків аргументів, замість тільки одного. Лістинг 9.2 показує звичайну, некаровану функцію, що додає два `Int` параметри, `x` та `y`.
[source,scala]
----
scala> def plainOldSum(x: Int, y: Int) = x + y
plainOldSum: (x: Int, y: Int)Int

scala> plainOldSum(1, 2)
res4: Int = 3Listing 9.2 - Defining and invoking a "plain old" function.
----
На відміну, Лістинг 9.3 показує подібну функцію, що є карованою. Замість одного списку з двох `Int`, ви застосовуєте цю функцію до двох списків, по одному параметру `Int` кожний.
[source,scala]
----
scala> def curriedSum(x: Int)(y: Int) = x + y
curriedSum: (x: Int)(y: Int)Int

scala> curriedSum(1)(2)
res5: Int = 3
----
Лістинг 9.3 - Визначення та виклик карованої функції.

Що тут відбувається, це коли ви викликаєте `curriedSum`, насправді ви отримуєте два традиційні виклики функцій, пліч-о-пліч. Перший виклик функції приймає один параметр `Int` на ім'я `x`, та повертає значення функції для другої функції. Ця друга функція приймає `Int` параметр `y`. Ось функція на ім'я `first`, що діє в дусі, що мав би робити перший традиційний виклик функції `curriedSum`:
[source,scala]
----
scala> def first(x: Int) = (y: Int) => x + y
first: (x: Int)Int => Int
----
Застосовуючи першої функції до 1 — іншими словами, викликаючи першу функцію, та передаючі їй 1 — дає другу функцію:
[source,scala]
----
scala> val second = first(1)
second: Int => Int = <function1>
----
Застосовуючи другу функцію до 2 дає результат:
[source,scala]
----
scala> second(2)
res6: Int = 3
----
Ці функції, `first` та `second`, є просто ілюстраціями процесу карування. Вони напряму не пов'язані до функції `curriedSum`. Тим не менш, існує спосіб отримати дійсне посилання на "другу" функцію `curriedSum`. Ви можете використовувати нотацію замінників для використання `curriedSum` в частково застосованому функціональному виразі, таким чином:
[source,scala]
----
scala> val onePlus = curriedSum(1)_
onePlus: Int => Int = <function1>
----
Підкреслення в `curriedSum(1)_` є замінником для другого списку параметрів.footnote:[В попередній главі, коли нотація замінників була застосована в традиційному методі, як `println _`, ви маєте залишати проміжок між ім'ям та підкресленням. В цьому випадку ви не змушені робити це, оскільки хоча `println_` є легальним ідентифікатором в Scala, `curriedSum(1)_` - ні.] Результатом буде посилання на функцію, що, коли буде викликана, додає один до свого єдиного аргумента `Int`, та повертає результат:
[source,scala]
----
scala> onePlus(2)
res7: Int = 3
----
Та ось як ви отримуєте функцію, що додає два до свого єдиного аргументу `Int`:
[source,scala]
----
scala> val twoPlus = curriedSum(2)_
twoPlus: Int => Int = <function1>

scala> twoPlus(2)
res8: Int = 4
----
9.4 Написання нових керівних структур
-------------------------------------
В мові з першокласними функціями ви можете ефективно створити нові керівні структури, навіть якщо синтаксис мови фіксований. Все що вам треба зробити - це створити методи, що приймають функції як аргументи. Наприклад, ось керівна структура `twice`, що повторює операцію два рази, та повертає результат:
[source,scala]
----
scala> def twice(op: Double => Double, x: Double) = op(op(x))
twice: (op: Double => Double, x: Double)Double

scala> twice(_ + 1, 5)
res9: Double = 7.0
----
Тип `op` в цьому прикладі є `Double => Double`, що означає, що це функція, що приймає одне `Double` в якості аргументу, та повертає інше `Double`. Кожного разу, коли ви знайдете шаблон керування, повторюваний в декількох частинах вашого коду, вам слідує подувати про реалізацію його як нової керуючої структури. Раніше в цій главі ви бачили `filesMatching`, дуже спеціалізований керівний шаблон. Тепер розглянемо більш широко використовуваний шаблон кодування: відкрити ресурс, виконувати операції з ним, та потім зачинити ресурс. Ви можете захопити це в керівній абстракції, використовуючи метод, подібний до наступного:
[source,scala]
----
def withPrintWriter(file: File, op: PrintWriter => Unit) = {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}
----
Маючи такий метод, ви можете використати його таким чином:
[source,scala]
----
withPrintWriter(
  new File("date.txt"),
  writer => writer.println(new java.util.Date)
)
----
Перевага від використання цього метода в тому, що це `withPrintWriter`, а не код користувача, переконується, що в кінці файл буде зачинений . Так що неможливо забути зачинити файл. Цей прийом називається _шаблоном позичання_, оскікльи функція абстракції керування, така як `withPrintWriter`, відкриває ресурс, та "позичає" його функції. Наприклад, `withPrintWriter` в попередньому прикладі позичає `PrintWriter` функції `op`. Коли функція завершується, вона сигналить, що вона більше не потребує "запозичений" ресурс. Потім ресурс зачиняється в блоці `finally`, щоб переконатись, що він напевне зачинений, безвідносно від того, чи функція завершилась через нормальне повернення, або через закидання виключення.

Один зі шляхів, як ви можете зробити, щоб код клієнта виглядав як вбудована структура керування, це використовувати фігурні дужки замість дужок для оточення списку аргументів. В любому виклику метода в Scala, в якому ви передаєте рівно один аргумент, ви можете обрати використовувати фігурні дужки для оточення аргумента замість дужок. Наприклад, замість:
[source,scala]
----
scala> println("Hello, world!")
Hello, world!
----
ви можете записати:
[source,scala]
----
scala> println { "Hello, world!" }
Hello, world!
----
В другому прикладі ви використали фігурні дужки замість дужок, щоб оточити аргументи `println`. Однак цей прийом з фігурними дужками буде робить, тілкьи якщо ви передаєте один аргумент. Ось спроба порушити це правило:
[source,scala]
----
scala> val g = "Hello, world!"
g: String = Hello, world!

scala> g.substring { 7, 9 }
<console>:1: error: ';' expected but ',' found.
        g.substring { 7, 9 }
                       ^
----
Оскільки ви намагаєтесь передати два аргументи до `substring`, ви отримуєте помилку, коли ви намагаєтесь оточити ці аргументи фігурними дужками. Замість цього вам треба використовувати дужки:
[source,scala]
----
scala> g.substring(7, 9)
res12: String = wo
----
Призначення цієї здатності замінювати дужки на фігурні дужки для передачі одного аргумента, є дозволити програмісту клієнта писати функціональні літерали між фігурними дужками. Це може зробити виклик метода більш подібним до абстракції керування. Розгляньте визначений до цього метод `withPrintWriter` як приклад. В його самій останній формі `withPrintWriter` приймає два аргументи, так що ви не можете використовувати фігурні дужки.

Тим не менш, оскільки функція, передана в `withPrintWriter` є останнім аргументом в списку, ви можете виконати карування для підтягування першого аргументу, `File`, в окремий список аргументів. Це залишить функцію як окремий параметр в другому списку аргументів. Лістинг 9.4 показує, як вам треба перевизначити `withPrintWriter`.
[source,scala]
----
def withPrintWriter(file: File)(op: PrintWriter => Unit) = {
  val writer = new PrintWriter(file)
  try {
    op(writer)
  } finally {
    writer.close()
  }
}
----
Лістинг 9.4 - Використання шаблона позичання для запису в файл.

Нова версія відрізняється від старої тільки в тому, що тепер в нас два списки параметрів, з одним параметром в кожному, замість одного списку параметрів з двома параметрами. В показаній тут попередній версії `withPrintWriter` ви бачили `...File, op...`. Але в цій версії ви бачите `...File)(op...`. Беручи до уваги визначення вище, ви можете викликати метод з більш приємним синтаксисом:
[source,scala]
----
val file = new File("date.txt")

withPrintWriter(file) { writer =>
  writer.println(new java.util.Date)
}
----
В цьому прикладі перший список аргументів, що містить один аргумент `File`, записаний в оточенні дужок. Другий список аргументів, що містить один функціональний аргумент, оточений в фігурні дужки.

9.5 Параметри за ім'ям
----------------------
Метод `withPrintWriter`, показаний в попередньому розділі, відрізняється від вбудованих керівних структур мови, таких як `if` та `while`, тому що код між фігурними дужками приймає аргумент. Функція, передана до `withPrintWriter` потребує один аргумент типу PrintWriter. Цей аргумент показаний як `writer =>`:
[source,scala]
----
withPrintWriter(file) { writer =>
  writer.println(new java.util.Date)
}
----
Але що, якщо ви бажаєте реалізувати дещо більш подібне до `if` або `while`, де немає значення, що треба передати в код між фігурними дужками? Щоб допомогти в таких ситуаціях Scala провадить параметри за іменем.

В якості конкретного прикладу, уявімо ви бажаєте реалізувати конструкцію твердження `myAssert`. footnote:[Ми назвемо це `myAssert`, не `assert`, оскільки Scala провадить свій власний `assert`, що буде описане в Розділі 14.1.] Функція `myAssert` буде приймати функціональне значення на вході, та звірятись з флагом, щоб вирішити, що робити. Якщо флаг встановлений, `myAssert` буде викликати передану функцію, та перевіряти, чи вона повертає `true`. Якщо флаг не встановлений, `myAssert` буде тихо взагалі нічого не робити.

Без параметрів за ім'ям ви можете записати `myAssert` десь так:
[source,scala]
----
var assertionsEnabled = true
def myAssert(predicate: () => Boolean) =
  if (assertionsEnabled && !predicate())
    throw new AssertionError
----
Визначення гарне, але її використання трохи незручне:
[source,scala]
----
myAssert(() => 5 > 3)
----
Ви можете дійсно схилятись до відкидання пустого списку параметрів та символа `=>` в функціональному літералі, та записати код таким чином:
[source,scala]
----
myAssert(5 > 3) // Не буде робити, оскільки відсутнє () =>
----
Параметри за ім'ям існують саме для того, щоб це було можливо зробити. Щоб створити параметр за ім'ям, ви даєте параметру тип, що починається з `=>` замість `() =>`. Наприклад, ви можете змінити параметр предикату `myAssert` в параметр за ім'ям, змінивши його тип `() => Boolean` на `=> Boolean`. Лістинг 9.5 показує, як це має виглядати:
[source,scala]
----
def byNameAssert(predicate: => Boolean) =
  if (assertionsEnabled && !predicate)
    throw new AssertionError
----
Лістинг 9.5 - Використання параметра за ім'ям.

Тепер ви можете відкинути пустий параметр у властивості, що ви бажаєте перевірити. Результат в тому, що  `byNameAssert` виглядає точно як вбудована структура керування:
[source,scala]
----
byNameAssert(5 > 3)
----
Тип за ім'ям, в якому відкидається пустий список параметрів, `()`, дозволений тільки для параметрів. Немає такого, як змінна за ім'ям або поле за ім'ям. Тепер ви можете здивуватись, чому ви не можете просто написати  `myAssert`, використовуючи простий старий `Boolean` для типу його параметра, ось так:
[source,scala]
----
def boolAssert(predicate: Boolean) =
  if (assertionsEnabled && !predicate)
    throw new AssertionError
----
Звичайно, це формулювання також легальне, та код з використанням ціє версії `boolAssert` все ще буде виглядати точно як раніше:
[source,scala]
----
boolAssert(5 > 3)
----
Тим не менш, існує одна відмінінсть між ціма двома підходами, яку важливо зазначити. Оскільки тип параметру `boolAssert` є `Boolean`, вираз всередині дужок в `boolAssert(5 > 3)` обчислюється перед викликом до `boolAssert`. Вираз `5 > 3` дає `true`, що передається до `boolAssert`. Для контрасту, оскільки тип параметра предикату `byNameAssert` є `=> Boolean`, вираз в дужках в `byNameAssert(5 > 3)` не обчислюється перед викликом до `byNameAssert`. Замість цього буде створено функціональне значення, метод `apply` якого буде обчислювати `5 > 3`, та це функціональне значення буде передане в `byNameAssert`.

Таким чином, різниця між двома підходами в тому, що якщо твердження відключене, ви побачите тільки побічний ефект цього виразу, який може мати вираз в дужках для `boolAssert`, але не для `byNameAssert`. Наприклад, якщо твердження відключені, спроба перевірити `x / 0 == 0` буде видавати виключення в випадку `boolAssert`:
[source,scala]
----
scala> val x = 5
x: Int = 5

scala> var assertionsEnabled = false
assertionsEnabled: Boolean = false

scala> boolAssert(x / 0 == 0)
java.lang.ArithmeticException: / by zero
... 33 elided
----
Але спроба виконати той самий код в випадку `byNameAssert` не дає виключення:
[source,scala]
----
scala> byNameAssert(x / 0 == 0)
----
9.6 Висновок
------------
Ця глава показала вам, як багата функціональна підтримка в Scala використовується для побудови абстракцій керування. Ви можете використовувати функції в вашому коді для виділення загальних шаблонів керування, та ви можете отримати переваги функцій вищих порядків в бібліотеці Scala, щоб повторно використовувати шаблони керування, що є загальними поміж коду всіх програмістів. Ми також розглянули, як використовувати карування та параметри за ім'ям, так що ваші власні функції вищих порядків можуть бути використані зі стислим синтаксисом. 

В попередній та цій главі ви бачили досить багато інформації щодо функцій. Наступні декілька глав повертатимуть назад, до обговорення більш об'єктно-орієнтовних можливостей мови.
