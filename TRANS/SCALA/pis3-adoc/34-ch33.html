<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__33">Глава 33</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Парсинг комбінатора</h1>
<div class="paragraph"><p>Часом вам треба обробити малу мову особливого призначення. Наприклад, вам може бути треба прочитати файли конфігурації для вашої програми, і ви бажаєте зробити їх простішими до ручної модифікації, ніж XML. Альтернативно, можливо ви бажаєте підтримати вхідну мову в вашій програмі, таку як пошук термінів з логічними операторами (комп<em>ютер, знайди мені кіно "з &#8216;космічні кораблі</em> та без `любовні історії"&#8217;). Якою б не була причина, вам буде треба парсер. Вам треба спосіб конвертувати вхідну мову в деякі структури даних, які ваша програма може обробити.</p></div>
<div class="paragraph"><p>В основному у вас лише декілька варіантів. Один варіант є розгорнути ваш власний парсер (та лексічний аналізатор). Якщо ви не експерт, це буде складно. Якщо ви експерт, це все одно витратить час.</p></div>
<div class="paragraph"><p>Альтернативний вибір є використання генератора парсерів. Існує декілька таких генераторів. Деякі з краще відомих є Yacc та Bison для персерів, написаних на C, ANTLR для персерів, написаних на Java. Вам також, можливо, знадобиться генератор сканерів, такий, як Lex, Flex або JFlex, щоб йшли з ними. Це може бути кращим рішенням, за винятком пари незручностей. Вам треба вивчити нові інструменти, включаючи їх, іноді таємні, повідомлення про помилки. Вам також треба зрозуміти, як під'єднати вивід ціх інструментів до вашої програми. Це може обмежити вибір вашої мови програмування, та ускладнити ваш ланцюжок інструментів.</p></div>
<div class="paragraph"><p>Ця глава представляє третю альтернативу. Замість використання окремої специфічної мови генератора парсерів, ви будете використовувати використовувати внутрішню домен специфічну мову, або скорочено інутрішню DSL. Внутрішній DSL буде складатись з бібліотеки комбінаторів парсера — функцій та операторів, визначених в Scala, що будуть служити як будівельні блоки для парсерів. Ці будівельні блоки будуть відповідати один до одного з конструкціями контекст-вільної граматики, щоб зробити їх простішими для розуміння.</p></div>
<div class="paragraph"><p>Ця глава вводить тільки одну мовну можливість, що не було пояснена до цього: псевдоними <code>this</code> з Розділа 33.6. Однак, ця глава важко використовує деякі інші можливості, що були пояснені в попередніх главах. Крім інших: параметризовані типи, абстрактні типи, функції та об'єкти, перевантаження операторів, параметри за-ім'ям та неявні перетворення - всі відіграють важливі ролі. Ця глава показує, як ці мовні елементи можуть бути скомбіновані в розробці дуже високорівневої бібліотеки.</p></div>
<div class="paragraph"><p>Пояснені в цій главі концепції мають схильність бути більш просунутими, ніж в попередніх главах. Якщо ви маєте гарне підгрунтя в комп'юторній конструкції, ви отримаєте вигоду від цієї глави, оскільки вона допоможе розуміти речі краще в перспективі. Однак єдиною передумовою для розуміння цієї глави є лише ваше знання про регулярні вирази та контекст-вільні граматики. Якщо ви не знаєте, що це, матеріал цієї глави також може бути безпечно пропущений.</p></div>
<div class="sect1">
<h2 id="_33_1___">33.1 Приклад: арифметичні вирази</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми почнемо з приклада. Скажімо, ви бажаєте сконструювати парсер для арифметичних виразів, що складаються з чисел з плаваючою крапкою, дужок та двійникових операторів <code>+</code>, <code>-</code>, <code>*</code>, та <code>/</code>. Перший крок завжди є виписати граматику для мови, яку ми будемо розбирати. Ось граматика для арифметичних виразів:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  expr ::= term {"+" term | "-" term}.
  term ::= factor {"*" factor | "/" factor}.
  factor ::= floatingPointNumber | "(" expr ")".</code></pre>
</div></div>
<div class="paragraph"><p>Тут, <code>|</code> позначає альтернативні продукції, та <code>\{ ... \}</code> означає повторення (нуль або більше раз). Та хоча в даному прикладі це не використовується, <code>[ ... ]</code> означатиме опціональну присутність.</p></div>
<div class="paragraph"><p>Ця контекст-вільна граматика формально визначає мову арифметичних виразів. Кожний вираз (представлений <em>expr</em>) є <code>term</code>, за яким може іти послідовність операторів <code>+</code> або <code>-</code>, та подальші терми. Терм <em>term</em> є <em>factor</em>, за яким можливо іде послідовність операторів <code>*</code> або <code>/</code> та подальші фактори. Фактор є числовий літерал або вираз в дужках. Зауважте, що граматика завжди кодує відносні преоритети операторів. Наприклад, <code>*</code> прикріплюється сильніше, ніж <code>+</code>, оскільки операція <code>*</code> дає <code>term</code>, тоді як операція <code>+</code> дає <code>expr</code>, та <code>expr</code> можуть містити <code>term</code>, але <code>term</code> може містити <code>expr</code>, тільки якщо останній оточений в дужки.</p></div>
<div class="paragraph"><p>Тепер, коли ми маємо визначену граматику - що далі? Якщо ви використовуєте комбінаторний парсер Scala, ви вже в основному закінчили! Вам тільки потрібно виконати деякі систематичні текстові заміни, та огорнути парсер в клас, як показано в Лістингу 33.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>
<span class="k">class</span> <span class="nc">Arith</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">term</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">~</span><span class="n">term</span> <span class="o">|</span> <span class="s">&quot;-&quot;</span><span class="o">~</span><span class="n">term</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">factor</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">~</span><span class="n">factor</span> <span class="o">|</span> <span class="s">&quot;/&quot;</span><span class="o">~</span><span class="n">factor</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">floatingPointNumber</span> <span class="o">|</span> <span class="s">&quot;(&quot;</span><span class="o">~</span><span class="n">expr</span><span class="o">~</span><span class="s">&quot;)&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.1 - Парсер арифметичних виразів.</p></div>
<div class="paragraph"><p>Парсери для арифметичних виразів містяться в класі, що наслідує від трейту <code>JavaTokenParsers</code>. Цей трейт провадить базову механіку для написання парсера, і також провадить деякі примітивні парсери, що розпізнають деякі класи слів: ідентифікатори, рядокві літерали та числа. В прикладі на Лістингу 33.1 вам треба тільки парсер примітивів <code>floatingPointNumber</code>, що наслідується з цього трейту.</p></div>
<div class="paragraph"><p>Три визначення в класі <code>Arith</code> представляє продукування для арифметичних виразів. Як ви можете бачити, вони слідують дуже тісно контекст-вільній граматиці. Фактично, ви можете генерувати цю частину автоматично з контекстно-вільної граматики, через виконання декількох простих текстових замін:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Кожна продукція стає методом, так що вам треба поставити перед ними префікс <code>def</code>.
</p>
</li>
<li>
<p>
Тип результату кожного метода є <code>Parser[Any]</code>, так що вам треба змінити символ <code>::=</code> на <code>: Parser[Any] =</code>. Ви з'ясуєте пізніше в цій главі, що позначає <code>Parser[Any]</code>, а також як зробити його більш точним.
</p>
</li>
<li>
<p>
В цій граматиці послідовна композиція була неявною, але в програмі вона виражена явним оператором: <code>~</code>. Так що вам треба вставити <code>~</code> між кожними двома послідовними символами продукції. В прикладі на Лістингу 33.1 ми обрали не писати жодних проміжків коло оператора <code>~</code>. Таким чином, код парсера близько притримується до візуального вигляду граматики — він тільки замінює проміжки на символи <code>~</code>.
</p>
</li>
<li>
<p>
Повторення виражене як <code>rep( ... )</code> замість <code>{ ... }</code>. Аналогічно (хоча це не показано в прикладі), опції виражені як <code>opt( ... )</code> замість <code>[ ... ]</code>.
</p>
</li>
<li>
<p>
Крапка (<code>.</code>) в кінці кожної продукції випущена - однак ви можете ставити крапки з комою (<code>;</code>), якщо бажаєте.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Ось і все щодо цього. Результуючий клас <code>Arith</code> визначає три парсери, <code>expr</code>, <code>term</code> та <code>factor</code>, що можуть використовуватись для розбору арифметичних виразів та їх частин.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_2___">33.2 Виконання вашого парсера</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви можете спробувати ваш парсер за допомогою такої невеликої програми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">ParseExpr</span> <span class="k">extends</span> <span class="nc">Arith</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;input : &quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">parseAll</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Об'єкт <code>ParseExpr</code> визначає головний метод, що розбирає перший аргумент командного рядка, переданий до нього. Він друкує оригінальний вхідний аргумент, та потім друкує його розібрану версію. Парсинг виконується виразом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">parseAll</span><span class="o">(</span><span class="n">expr</span><span class="o">,</span> <span class="n">input</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз застосовує персер <code>expr</code> до отриманого вводу. Він очікує, що весь вхід співпадає, тобто немає символів, що ідуть за розбиваним виразом. Також існує метод <code>parse</code>, що дозволяє розбирати префікс вводу, залишаючи деякий залишок непрочитаним.</p></div>
<div class="paragraph"><p>Ви можете запустити арифметичний парсер за допомогою наступної команди:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">ParseExpr</span> <span class="s">&quot;2 * (3 + 7)&quot;</span>
<span class="n">input</span><span class="k">:</span> <span class="err">2</span> <span class="kt">*</span> <span class="o">(</span><span class="err">3</span> <span class="kt">+</span> <span class="err">7</span><span class="o">)</span>
<span class="err">[1</span><span class="kt">.</span><span class="err">12]</span> <span class="kt">parsed:</span> <span class="o">((</span><span class="err">2</span><span class="kt">~List</span><span class="o">((</span><span class="kt">*~</span><span class="o">(((</span><span class="kt">~</span><span class="o">((</span><span class="err">3</span><span class="kt">~List</span><span class="o">())</span><span class="kt">~List</span><span class="o">((</span><span class="kt">+</span>
<span class="kt">~</span><span class="o">(</span><span class="err">7</span><span class="kt">~List</span><span class="o">())))))</span><span class="kt">~</span><span class="o">)))))</span><span class="kt">~List</span><span class="o">())</span>
</pre></div></div></div>
<div class="paragraph"><p>Вивід каже вам, що парсер успішно проаналізував вхідний рядок до позиції <code>[1.12]</code>. Це означає, що перший рядок та дванадцята колонка - іншими словами весь наш вхідний рядок — був прочитаний. Доки не зважайте на результат після <code>parsed:</code>. Він не дуже корисний, і пізніше ви зрозумієте, як отримати більш специфічні результати парсера.</p></div>
<div class="paragraph"><p>Ви також можете спробувати ввести деякі вхідні рядки, що не є легальними виразами. Наприклад, ви можете написати вираз з однією зайвою дужкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">ParseExpr</span> <span class="s">&quot;2 * (3 + 7))&quot;</span>
<span class="n">input</span><span class="k">:</span> <span class="err">2</span> <span class="kt">*</span> <span class="o">(</span><span class="err">3</span> <span class="kt">+</span> <span class="err">7</span><span class="o">))</span>
<span class="o">[</span><span class="err">1</span><span class="kt">.</span><span class="err">12</span><span class="o">]</span> <span class="n">failure</span><span class="k">:</span> <span class="kt">`-&#39; expected but `</span><span class="o">)</span><span class="err">&#39;</span> <span class="n">found</span>

<span class="mi">2</span> <span class="o">*</span> <span class="o">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">7</span><span class="o">))</span>
           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут парсер <code>expr</code> розбирає все до фінальних замикаючих дужок, що не формує частину арифметичного виразу. Метод <code>parseAll</code> при цьому видає повідомлення про помилку, що каже, що очікувався оператор <code>-</code> в тій точки, де стоїть замикаюча дужка. Пізніше в цій главі ви зрозумієте, чому продукується саме таке повідомлення про помилку, та як покращити його.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_3____">33.3 Базовий парсер регулярних виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Парсер для арифметичних виразів використовує інший парсер на ім'я <code>floatingPointNumber</code>. Цей парсер, що був наслідуваний від супертрейта <code>Arith</code>, <code>JavaTokenParsers</code>, розпізнає числа з плаваючою крапкою в форматі Java. Але що ви робите, якщо вам треба розібрати числа в форматі, що трохі інші від Java? В цій ситуації ви можете використати парсер регулярних виразів.</p></div>
<div class="paragraph"><p>Ідея в тому, що ви можете використовувати любий регулярний вираз як парсер. Регулярний вираз розбирає всі рядки, що можуть співпасти. Його результат є розібраний рядок. Наприклад, регулярний вираз, показаний в Лістингу 33.2, описує Java ідентифікатори:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyParsers</span> <span class="k">extends</span> <span class="nc">RegexParsers</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">ident</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;[a-zA-Z_]\w*&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.2 - Парсер регулярних виразів для Java ідентифікаторів.</p></div>
<div class="paragraph"><p>Об'єкт <code>MyParsers</code> з Лістинга 33.2 наслідує від трейта <code>RegexParsers</code>, тоді як <code>Arith</code> наслідується від <code>JavaTokenParsers</code>. Комбінатори парсінгу Scala вибудовані в ієрархію трейтів, які всі містяться в пакунку <code>scala.util.parsing.combinator</code>. Трейт вищого рівня є <code>Parsers</code>, що визначає дуже загальний фреймворк парсингу для всіх сортів вводу. На рівень нижче трейт <code>RegexParsers</code>, що потребує, щов ввод був послідовністю символів, та провадить парсинг по регулярним виразам. Навіть більш спеціалізований є трейт <code>JavaTokenParsers</code>, що реалізує парсери для базових класів слів (або токенів), як вини визначені в Java.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_4___json">33.4 Інший приклад: JSON</h2>
<div class="sectionbody">
<div class="paragraph"><p>JSON, JavaScript Object Notation, є популярним форматом обміну даними. В цьому розділі ми покажемо, як написати парсер для нього. Ось граматика, що описує синтаксис JSON:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>value ::= obj | arr | stringLiteral |
          floatingPointNumber |
          "null" | "true" | "false".
obj ::= "{" [members] "}".
arr ::= "[" [values] "]".
members ::= member {"," member}.
member ::= stringLiteral ":" value.
values ::= value {"," value}.</code></pre>
</div></div>
<div class="paragraph"><p>Значення JSON є об'єкт, масив, рядок, число або одне з трьох зарезервованих слів: <code>null</code>, <code>true</code>, <code>false</code>. Об'єкт JSON є (можливо порожньою) послідовністю членів, розділених комами, та оточених дужками. Кожний член є парою ключ/значення, де початковий рядок та значення розділені двома крапками. Нарешті, масив JSON є послідовністю значень, розділених комами, та оточених прямокутними дужками. Як приклад, Лістинг 33.3 містить адресну книгу, відформатовану як об'єкт JSON.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nt">&quot;address book&quot;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;John Smith&quot;</span><span class="p">,</span>
    <span class="nt">&quot;address&quot;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&quot;street&quot;</span><span class="p">:</span> <span class="s2">&quot;10 Market Street&quot;</span><span class="p">,</span>
      <span class="nt">&quot;city&quot;</span> <span class="p">:</span> <span class="s2">&quot;San Francisco, CA&quot;</span><span class="p">,</span>
      <span class="nt">&quot;zip&quot;</span> <span class="p">:</span> <span class="mi">94111</span>
    <span class="p">},</span>
    <span class="nt">&quot;phone numbers&quot;</span><span class="p">:</span> <span class="p">[</span>
      <span class="s2">&quot;408 338-4238&quot;</span><span class="p">,</span>
      <span class="s2">&quot;408 111-6892&quot;</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.3 - Дані в форматі JSON.</p></div>
<div class="paragraph"><p>Парсинг таких даних є промолінійним, коли використовується комбінатори парсерів Scala. Повний парсер показаний на Лістингу 33.4. Цей парсер слідує тій самій структурі, що і парсер арифметичних виразів. Він знову є прямолінійним відображенням продукцій граматики JSON. Продукції використовують одне скорочення, що спрощує граматику: комбінатор <code>repsep</code> розбирає (можливо порожню) послідовність термів, що розділені наданим рядком роздільника. Наприклад, в прикладі в Лістингу 33.4, <code>repsep(member, ",")</code> розбирає розділену комами послідовність термів-членів. Крім цього продукції в парсері точно співпадають продукціям в граматиці, як було в випадку парсера арифметичних виразів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>

<span class="k">class</span> <span class="nc">JSON</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">value</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">obj</span> <span class="o">|</span> <span class="n">arr</span> <span class="o">|</span>
    <span class="n">stringLiteral</span> <span class="o">|</span>
    <span class="n">floatingPointNumber</span> <span class="o">|</span>
    <span class="s">&quot;null&quot;</span> <span class="o">|</span> <span class="s">&quot;true&quot;</span> <span class="o">|</span> <span class="s">&quot;false&quot;</span>
  <span class="k">def</span> <span class="n">obj</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;{&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;}&quot;</span>
  <span class="k">def</span> <span class="n">arr</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;[&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;]&quot;</span>
  <span class="k">def</span> <span class="n">member</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">stringLiteral</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.4 - Простий парсер JSON.</p></div>
<div class="paragraph"><p>Щоб спробувати JSON парсери ми трохі змінимо фреймворк, так щоб парсер оперував файлом, замість командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>

<span class="k">object</span> <span class="nc">ParseJSON</span> <span class="k">extends</span> <span class="nc">JSON</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">reader</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
    <span class="n">println</span><span class="o">(</span><span class="n">parseAll</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">reader</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>main</code> в цій програмі спочатку створює об'єкт <code>FileReader</code>. Потім він розбирає символи, що повертаються рідером, відповідно до продукції значень граматики JSON. Зауважте, що <code>parseAll</code> та <code>parse</code> існують в перевантажених варіантах: обоє можуть приймати послідовність символів, або альтернативно вхідний ридер як другий аргумент.</p></div>
<div class="paragraph"><p>Якщо <code>ParseJSON</code> впорається, ви повинні отримати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ scala ParseJSON address-book.json
<span class="o">[</span><span class="m">13</span>.4<span class="o">]</span> parsed: <span class="o">(({</span>~List<span class="o">(((</span><span class="s2">&quot;address book&quot;</span>~:<span class="o">)</span>~<span class="o">(({</span>~List<span class="o">(((</span>
<span class="s2">&quot;name&quot;</span>~:<span class="o">)</span>~<span class="s2">&quot;John Smith&quot;</span><span class="o">)</span>, <span class="o">((</span><span class="s2">&quot;address&quot;</span>~:<span class="o">)</span>~<span class="o">(({</span>~List<span class="o">(((</span>
<span class="s2">&quot;street&quot;</span>~:<span class="o">)</span>~<span class="s2">&quot;10 Market Street&quot;</span><span class="o">)</span>, <span class="o">((</span><span class="s2">&quot;city&quot;</span>~:<span class="o">)</span>~<span class="s2">&quot;San Francisco</span>
<span class="s2">,CA&quot;</span><span class="o">)</span>, <span class="o">((</span><span class="s2">&quot;zip&quot;</span>~:<span class="o">)</span>~94111<span class="o">)))</span>~<span class="o">}))</span>, <span class="o">((</span><span class="s2">&quot;phone numbers&quot;</span>~:<span class="o">)</span>~<span class="o">(([</span>~
List<span class="o">(</span><span class="s2">&quot;408 338-4238&quot;</span>, <span class="s2">&quot;408 111-6892&quot;</span><span class="o">))</span>~<span class="o">]))))</span>~<span class="o">}))))</span>~<span class="o">})</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_5__">33.5 Вивід парсера</h2>
<div class="sectionbody">
<div class="paragraph"><p>Програма <code>ParseJSON</code> успішно розібрала адресну книгу JSON. Однак вивід парсера виглядає странно. Це виглядає як послідовність, що складена зі шматків вводу, склеєні разом списками та комбінаціями <code>~</code>. Цей вивід не дуже корисний. Він менш читабельний для людей, ніж вхід, але він також дуже дезорганізований, щоб бути просто проаналізований комп'ютером. Прийшов час щось робити з цім.</p></div>
<div class="paragraph"><p>Щоб зрозуміти, що маємо робити, вам спочатку треба знати, що окремі парсери в фреймворці комбінатора повертають як результат (звичайно, якщо вони змогли розібрати вхідні дані). Ось правила:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Кожний парсер, написаний як рядок (як в <code>"{"</code> або <code>":"</code> або <code>"null"</code>) повертає сам розібраний рядок.
</p>
</li>
<li>
<p>
Парсери регулярних виразів, як <code>"""[a-zA-Z_]\w*""".r</code> також повертають самий розібраний рядок. Те саме дотримується для парсерів регулярних виразів, таких як <code>stringLiteral</code> або <code>floatingPointNumber</code>, що наслідуються від <code>JavaTokenParsers</code>.
</p>
</li>
<li>
<p>
Послідовна композиція <code>P~Q</code> повертає результат від обох, <code>P</code> та <code>Q</code>. Ці результати повертаються в вигляді примірника кейс класа , що також записується <code>~</code>. Так що якщо <code>P</code> повертає <code>"true"</code> та <code>Q</code> повертає <code>"?"</code>, тоді послідовна композиція <code>P~Q</code> повертає <code>~("true", "?")</code>, що друкується як <code>(true~?)</code>.
</p>
</li>
<li>
<p>
Альтернативна композиція <code>P | Q</code> повертає результат або <code>P</code> або <code>Q</code>, який буде успішний.
</p>
</li>
<li>
<p>
Повторення <code>rep(P)</code> або <code>repsep(P, separator)</code> повертає список з результатів всіх викликів <code>P</code>.
</p>
</li>
<li>
<p>
Опція <code>opt(P)</code> повертає примірник типу Scala <code>Option</code>. Віе повертає <code>Some(R)</code>, якщо <code>P</code> успішний з результатом <code>R</code>, та <code>None</code>, якщо <code>P</code> схибить.
</p>
</li>
</ol></div>
<div class="paragraph"><p>З ціма правилами ви тепер можете вивести, чому вивід парсера виглядає як виглядає в попередніх прикладах. Однак вивід все ще не дуже зручний. Може бути значно кращим відобразити JSON об'єкт на внутрішню репрезентацію Scala, що представлятиме значення  JSON об'єкту. Більш природна репрезентація може бути наступною:</p></div>
<div class="ulist"><ul>
<li>
<p>
JSON об'єкт представлений як мапа Scala типу <code>Map[String, Any]</code>. Кожний член представлений як прікріплення ключ/значення в мапі.
</p>
</li>
<li>
<p>
JSON масив представлений як Scala список типу <code>List[Any]</code>.
</p>
</li>
<li>
<p>
JSON рядок представлений як Scala <code>String</code>.
</p>
</li>
<li>
<p>
Числовий літерал JSON представлений як Scala <code>Double</code>.
</p>
</li>
<li>
<p>
Значення <code>true</code>, <code>false</code>, та <code>null</code> представлені як Scala значення з тими самими іменами.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Щоб спродукувати цю репрезентацію, вам треба задіяти ще один комбінатор для парсерів: <code>^^</code>. Оператор <code>^^</code> трансформує результат парсера. Вирази, що використовують цей оператор, мають форму <code>P ^^ f</code>, де <code>P</code> є парсер, а <code>f</code> є функція. <code>P ^^ f</code> парсить ті самі фрази, що і просто <code>P</code>. Коли <code>P</code> повертає той самий результат <code>R</code>, результатом <code>P ^^ f</code> буде <code>f(R)</code>. Як приклад, ось парсер, що розбирає число з плаваючою крапкою, та перетворює його в Scala значення типу <code>Double</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">floatingPointNumber</span> <span class="o">^^</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та ось парсер, що розбирає рядок <code>"true"</code>, та повертає логічне значенн Scala <code>true</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="s">&quot;true&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер побачимо більш просунуті трансформації. Ось нова версія парсера для JSON об'єктів, що повертає Scala <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span> <span class="c1">// Може бути покращене</span>
<span class="s">&quot;{&quot;</span><span class="o">~</span><span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)~</span><span class="s">&quot;}&quot;</span> <span class="o">^^</span>
<span class="o">{</span> <span class="k">case</span> <span class="s">&quot;{&quot;</span><span class="o">~</span><span class="n">ms</span><span class="o">~</span><span class="s">&quot;}&quot;</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="n">ms</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Пам'ятайте, що оператор <code>~</code> продукує як результат примірник кейс класу з тим самим ім'ям: <code>~</code>. Ось визначення цього класу — це внутрішній клас трейту <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">~</span><span class="o">[</span><span class="kt">+A</span>, <span class="kt">+B</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&quot;~&quot;</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="s">&quot;)&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ім'я класу навмисно таке саме, що і ім'я метода комбінатора послідовності, <code>~</code>. Таким чином, ви можете порівнювати результати парсера з шаблонами, що слідують тій самій структурі , що і самі парсери. Наприклад, шаблон <code>"{"~ms~"}"</code> співпадає з рядком результату <code>"{"</code>, що яким слідує змінна результату <code>ms</code>, за яким в свою чергу іде рядок результата <code>"}"</code>. Цей шаблон відповідає в точності до того, що повертає парсер зліва від  <code>'^^'</code>. В своїй знецукреній версії, де оператор <code>~</code> іде першим, той самий шаблон читається як <code>~(~("{", ms), "}")</code>, але це значно менш приємно.</p></div>
<div class="paragraph"><p>Призначення шаблона <code>"{"~ms~"}"</code> є очистити дужки, так щоб ми могли отримати список членів, отриманих від парсера <code>repsep(member, ",")</code>. В випадках, як це, також є альтернатива, що цникає створення непотрібного результату парсера, що зразу відкидається порівнянням шаблонів. Альтернативи використовує комбінатори <code>~&gt;</code> та <code>&lt;~</code>. Обоє виражають послідовні композиції, як <code>~</code>, але <code>~&gt;</code> зберігає тільки результат правого операнду, тоді як <code>&lt;~</code> зберігає тільки результат свого лівого операнду. Використовуючи ці комбінатори парсер об'єктів JSON може бути використаний більш послідовно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
  <span class="s">&quot;{&quot;</span><span class="o">~&gt;</span> <span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)</span> <span class="o">&lt;~</span><span class="s">&quot;}&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.5 показує повний парсер JSON, що повертає осмислений результат. Якщо ви виконаєте цей парсер на файлі <code>address-book.json</code>, ви отримаєте наступний результат (після додавання деяких нових рядків та відступів):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="nc">JSON1Test</span> <span class="n">address</span><span class="o">-</span><span class="n">book</span><span class="o">.</span><span class="n">json</span>
<span class="o">[</span><span class="err">14</span><span class="kt">.</span><span class="err">1</span><span class="o">]</span> <span class="n">parsed</span><span class="k">:</span> <span class="kt">Map</span><span class="o">(</span>
<span class="kt">address</span> <span class="kt">book</span> <span class="kt">-&gt;</span> <span class="kt">Map</span><span class="o">(</span>
<span class="kt">name</span> <span class="kt">-&gt;</span> <span class="kt">John</span> <span class="kt">Smith</span><span class="o">,</span>
<span class="kt">address</span> <span class="kt">-&gt;</span> <span class="kt">Map</span><span class="o">(</span>
<span class="kt">street</span> <span class="kt">-&gt;</span> <span class="err">10</span> <span class="kt">Market</span> <span class="kt">Street</span><span class="o">,</span>
<span class="kt">city</span> <span class="kt">-&gt;</span> <span class="kt">San</span> <span class="kt">Francisco</span><span class="o">,</span> <span class="kt">CA</span><span class="o">,</span>
<span class="n">zip</span> <span class="o">-&gt;</span> <span class="mi">94111</span><span class="o">),</span>
<span class="n">phone</span> <span class="n">numbers</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">408</span> <span class="mi">338</span><span class="o">-</span><span class="mi">4238</span><span class="o">,</span> <span class="mi">408</span> <span class="mi">111</span><span class="o">-</span><span class="mi">6892</span><span class="o">)</span>
<span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те що вам повинно знати для початку написання ваших власних парсерів. Як допомога в запам'ятовуванні, Таблиця 33.1 перелічує комбінатори парсерів, які ми нещодавно обговорювали.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.parsing.combinator._</span>

<span class="k">class</span> <span class="nc">JSON1</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
    <span class="s">&quot;{&quot;</span><span class="o">~&gt;</span> <span class="n">repsep</span><span class="o">(</span><span class="n">member</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)</span> <span class="o">&lt;~</span><span class="s">&quot;}&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="nc">Map</span><span class="o">()</span> <span class="o">++</span> <span class="k">_</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">arr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]]</span> <span class="k">=</span>
    <span class="s">&quot;[&quot;</span><span class="o">~&gt;</span> <span class="n">repsep</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">)</span> <span class="o">&lt;~</span><span class="s">&quot;]&quot;</span>

  <span class="k">def</span> <span class="n">member</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Any</span><span class="o">)]</span> <span class="k">=</span>
    <span class="n">stringLiteral</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">value</span> <span class="o">^^</span>
      <span class="o">{</span> <span class="k">case</span> <span class="n">name</span><span class="o">~</span><span class="s">&quot;:&quot;</span><span class="o">~</span><span class="n">value</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">value</span><span class="o">)</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span>
    <span class="n">obj</span>
  <span class="o">|</span> <span class="n">arr</span>
  <span class="o">|</span> <span class="n">stringLiteral</span>
  <span class="o">|</span> <span class="n">floatingPointNumber</span> <span class="o">^^</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
  <span class="o">|</span> <span class="s">&quot;null&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">null</span><span class="o">)</span>
  <span class="o">|</span> <span class="s">&quot;true&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">true</span><span class="o">)</span>
  <span class="o">|</span> <span class="s">&quot;false&quot;</span> <span class="o">^^</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.5 - Повний парсер JSON, що повертає осмислені результати.</p></div>
<div class="paragraph"><p>Таблиця 33.1 - Підсумок по парсерним комбінаторам</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">"&#8230;"</p></td>
<td align="left" valign="top"><p class="table">літерал</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">"&#8230;".r</p></td>
<td align="left" valign="top"><p class="table">регулярний вираз</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P~Q</p></td>
<td align="left" valign="top"><p class="table">послідовна композиція</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P &lt;<sub> Q, P </sub>&gt; Q</p></td>
<td align="left" valign="top"><p class="table">послідовна композиція, тільки вліво/вправо</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P | Q</p></td>
<td align="left" valign="top"><p class="table">альтернатива</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">opt(P)</p></td>
<td align="left" valign="top"><p class="table">опція</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">rep(P)</p></td>
<td align="left" valign="top"><p class="table">повторення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">repsep(P, Q)</p></td>
<td align="left" valign="top"><p class="table">переміжене повторення</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">P ^^</p></td>
<td align="left" valign="top"><p class="table">перетворення результату</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____">Вимкнення виводу крапки з комою</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зауважте, що тіло парсера значень в Лістингу 33.5 оточений в дужки. Це невеликий трюк, щоб дозволити вивід крапки з комою в виразах парсера. Ви бачили в Розділі 4.2, що Scala вважає присутність крапки з комою між любими двома рядками, що синтаксично можуть бути окремими твердженнями, за винятком коли перший рядок завершується на інфіксний оператор, або два рядка оточені в звичайні або прямокутні дужки. Тепер ви можете писати оператор <code>|</code> в кінці кожної альтернативи, замість початку наступного рядка, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">obj</span> <span class="o">|</span>
  <span class="n">arr</span> <span class="o">|</span>
  <span class="n">stringLiteral</span> <span class="o">|</span>
<span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку немає жодних дужок навколо тіла парсера значень, що могли бути потрібні. Однак деякі люди бажають бачити оператор <code>|</code> на початку другої альтернативи, ніж в кінці першої. Звичайно це призведе до небажаної крапки з комою між двома рядками, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="o">;</span>  <span class="c1">// крапка з комою вставлені явно</span>
<span class="o">|</span> <span class="n">arr</span>
</pre></div></div></div>
<div class="paragraph"><p>Крапка з комою змінили структуру коду, що призвело до збою компіляції. Покладаючи цілий вираз в дужки уникає крапок з комою, та робить компіляцію коду коректною.</p></div>
<div class="sect2">
<h3 id="______2">Символічні імена проти літено-цифрових</h3>
<div class="paragraph"><p>Багато з парсерних комбінатороів в Таблиці 33.1 використовують символічні імена. Це має одночасно переваги та недоліки. Один з мінусів є те, що символічні імена потребують час для вивчення. Користувачі, що незнайомі з бібліотекою парсерних комбінаторів Scala, можливо будуть містифіковані значенням <code>~</code>, <code>~&gt;</code> або <code>^^</code>. На боці плюсів - символічні імена короткі, та можуть бути обрані, щоб мати "правильні" преоритети та асоціативність. Наприклад, парсерні комбінатори <code>~</code>, <code>^^</code> та <code>|</code> обрані навмисне в зростаючому порядку преоритетів. Типова граматична продукція скомпонована з альтернатив, що мають частину парсингу, та частину трансформації. Частина парсингу типово містить декілька послідовних елементів, розділених операторами <code>~</code>. З обраними преоритетами для <code>~</code>, <code>^^</code> та <code>|</code> ви можете написати таку граматичну продукцію без потреби в дужках.</p></div>
<div class="paragraph"><p>Більше того, символічні оператори займають меньше візуальної нерухомості, ніж літерні. Це важливо для парсерів, оскільки це дозволяє вам концентруватись на граматиці, замість самих комбінаторів. Щоб побачити різницю, уявімо на момент, що послідовна композиція (<code>~</code>) мала б назву <code>andThen</code>, та альтернатива (<code>|</code>) мала б назву <code>orElse</code>. Парсери арифметичних виразів в Лістингу 33.1 виглядали б наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ArithHypothetical</span> <span class="k">extends</span> <span class="nc">JavaTokenParsers</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">expr</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>  <span class="k">=</span>
    <span class="n">term</span> <span class="n">andThen</span> <span class="n">rep</span><span class="o">((</span><span class="s">&quot;+&quot;</span> <span class="n">andThen</span> <span class="n">term</span><span class="o">)</span> <span class="n">orElse</span>
                     <span class="o">(</span><span class="s">&quot;-&quot;</span> <span class="n">andThen</span> <span class="n">term</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">term</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">factor</span> <span class="n">andThen</span> <span class="n">rep</span><span class="o">((</span><span class="s">&quot;*&quot;</span> <span class="n">andThen</span> <span class="n">factor</span><span class="o">)</span> <span class="n">orElse</span>
                       <span class="o">(</span><span class="s">&quot;/&quot;</span> <span class="n">andThen</span> <span class="n">factor</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">floatingPointNumber</span> <span class="n">orElse</span>
      <span class="o">(</span><span class="s">&quot;(&quot;</span> <span class="n">andThen</span> <span class="n">expr</span> <span class="n">andThen</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви помітили, що цей код став значно більш довшим, і що стало складно "побачити" граматику між всіма ціма операторами та дужками. З іншого боку, дехто новий до комбінаторного парсингу можливо зможе краще зрозуміти, яке призначення має цей код.</p></div>
</div>
<div class="sect2">
<h3 id="_______">Вибір між символічними та літерно-цифровими іменами</h3>
<div class="paragraph"><p>Як настанова для вибору між символічними та літерними іменами ми рекомендуємо наступне:</p></div>
<div class="ulist"><ul>
<li>
<p>
Використовуйте символічні імена в випадках, коли воні вже мають універсально встановлене значення. Наприклад, ніхто не буде рекомендувати писати <code>add</code> замість <code>+</code> для числового додавання.
</p>
</li>
<li>
<p>
В іншому випадку надайте перевагу літерним іменам, якщо ви бажаєте зробити ваш код розумілим для випадкових читачів.
</p>
</li>
<li>
<p>
Ви все ще можете обрати символічні імена для домен-специфічних бібліотек, якщо це дає ясні переваги в розумінні, та ви в жодному разі не очікуєте випадкових читачів без надійного підгрунтя в предметі, щоб вони безпосередньо розуміли код.
</p>
</li>
</ul></div>
<div class="paragraph"><p>В випадку парсерних комбінаторів ми дивимось на дуже високо-домен-специфічну мову, що випадкові читачі можуть мати проблеми з розумінням, навіть для літерних імен. Більше того, символічні імена дають ясну перевагу в виразності для експерта. Так що ми віримо, що їх застосування обгрунтоване в цьому застосуванні.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_33_6___">33.6 Реалізація парсерів комбінаторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередні розділи показали, що комбінаторні парсери Scala провадять зручні способи для конструювання ваших власних парсерів. Оскільки вони ніщо інше, ніж Scala бібліотека, вони без проблем пасують до ваших Scala програм. Так що це дуже просто скомбінувати парсер з деяким кодом, що обробляє отримані результати, або зачепити парсер так, щоб він отримував свій вхід з певного джерела (скажімо, файла, рядка або масива символів).</p></div>
<div class="paragraph"><p>Як це досягається? В решті цієї глави ви поглянете "за лаштунки" бібліотеки комбінаторного парсера. Ви побачите що таке є парсер, та як примітивні парсери та як реалізовані парсерні комбінатори, перелічені в попередніх розділах. Ви можете безпечно пропустити ці частини, якщо все, що ви хочете, це написати деякі прості комбінаторні парсери. З іншого боку, читання решти цієї глави може дати вам глибше розуміння комбінаторних парсерів зокрема, та принципів розробки комбінаторної домен-специфічної мови загалом.</p></div>
<div class="paragraph"><p>Ядро фреймворку комбінаторних парсерів міститься в трейті <code>scala.util.parsing.combinator.Parsers</code>. Цей трейт визначає тип <code>Parser</code>, так само, як всі фундаментальні комбінатори. Окрім випадків, коли явно вказано інше, визначення, пояснені в настурних двох розділах, містяться в цьому трейті. Тобто  очікується, що вони містяться в визначенні трейта, що починається таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.util.parsing.combinator</span>

<span class="k">trait</span> <span class="nc">Parsers</span> <span class="o">{</span>
<span class="o">...</span> <span class="c1">// код іде тут, якщо не вказане інше</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Parser</code> в основі є лише функцією від якогось типу до результату розбору. Як перше наближення тип може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="___2">Вхід парсера</h3>
<div class="paragraph"><p>Іноді парсер читає потік токенів замість сирої послідовності символів. Потім використовується окремий лексичний аналізатор для перетворення потоку символів на потік токенів. Тип парсерних входів визначається таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Input</span> <span class="o">=</span> <span class="nc">Reader</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас <code>Reader</code> походить з пакунка <code>scala.util.parsing.input</code>. Це подібно до <code>Stream</code>, але також відстежує позицію всіх елементів, що читає. Тип <code>Elem</code> представляє індивідуальні вхідні елементи. Це абстрактний член <code>type</code> трейта <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Elem</span>
</pre></div></div></div>
<div class="paragraph"><p>Це означає, що субкласи та субтрейти <code>Parsers</code> мають створити примірник класу <code>Elem</code> як тип вхідних елементів, що будуть розбиратись. Наприклад, <code>RegexParsers</code> та <code>JavaTokenParsers</code> фіксують <code>Elem</code> еквівалентним до <code>Char</code>. Але також можливо встановити <code>Elem</code> в якійсь інший тип, такий як тип токена, що повертається з окремого лексера.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Результати парсера</h3>
<div class="paragraph"><p>Парсер може або завершитись успішно, або схибити для деякого даного вхідного потоку. Відповідно клас <code>ParseResult</code> має два субкласа для представлення успіху та неуспіху:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">Success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">result</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Випадок <code>Success</code> несе результат, повернутий з парсера в своєму параметрі <code>result</code>. Тип результату парсера довільний; ось чому <code>ParseResult</code>, <code>Success</code> та <code>Parser</code> всі параметризовані параметром типу <code>T</code>. Параметр типу представляє різновид результатів, що повертається даним парсером. <code>Success</code> також приймає другий параметр, <code>in</code>, що посилається на вхід безпосередньо за частиною, що була спожита парсером. Це поле потрібне для зціплених парсерів, так що один парсер може оперувати після іншого. Зауважте, що це чисто функціональний підхід до парсингу. Вхід не читається як побічний ефект, але зберігається як потік. Парсер аналізує деяку частину вхідного потоку, та потім повертає залишкову частину в своєму результаті.</p></div>
<div class="paragraph"><p>Інший субклас <code>ParseResult</code> є <code>Failure</code>. Цей клас приймає як параметр повідомлення, що описує, чому парсер схибив. Як і <code>Success</code>, <code>Failure</code> також приймає залишок вхідного потоку як другий параметр. Це потрібно не для зціплення (парсер не може продовжуватись після збою), але для вказання повідомленню про помилку коректне місце у вхідному потоці.</p></div>
<div class="paragraph"><p>Зауважте, що результати парсера визначені коваріантними по параметру типа <code>T</code>. Тобто, скажімо, парсер, що повертає <code>String</code> як результат, сумісний з парсером, що повертає <code>AnyRef</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__code_parser_code">Клас <code>Parser</code></h3>
<div class="paragraph"><p>Попередня характеристика парсерів як функцій від вхідного потоку до результатів розбору була надспрощена. Попередні приклади показали, що парсери також реалізують методи, такі як <code>~</code>, для послідовної композиції двох парсерів, та <code>|</code> для їх альтернативної композиції. Та що в реальності <code>Parseris</code> є клас, що наслідує від функціонального типу <code>Input =&gt; ParseResult[T]</code>, та додатково  визначає ці методи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">(</span><span class="nc">Input</span> <span class="k">=&gt;</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
<span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
  <span class="c1">// Невказаний метод, що визначає поведінку парсера.</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span><span class="k">:</span> <span class="kt">ParseResult</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="o">~</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">|</span> <span class="o">...</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки парсери є (тобто наслідують від) функціями, вони мають визначати метод <code>apply</code>. Ви бачите абстрактний метод <code>apply</code> в класі <code>Parser</code>, але це тільки для документації, бо  такий самий метод в кожному випадку наслідується від батьківського типу <code>Input =&gt; ParseResult[T]</code> (згадайте, що цей тип є скороченням для <code>scala.Function1[Input, ParseResult[T]]</code>). Метод <code>apply</code> все ще має бути реалізований в індивідуальних парсерах, що наслідують від абстрактного класу <code>Parser</code>. Ці парсери будуть обговорюватись після наступного розділу, де розглядатимуться псевдоніми <code>this</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_this_code">Псевдоним для <code>this</code></h3>
<div class="paragraph"><p>Тіло класу <code>Parser</code> починається з цікавого виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">extends</span> <span class="o">...</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Таке твердження як <code>id =&gt;</code> безпосередньо після відкриваючої дужки шаблону класа  визначає ідентифікатор <code>id</code> як псевдонім для <code>this</code> в класі. Це те саме, якщо б ви написали:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">id</span> <span class="k">=</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>в тілі класу, за тим винятком, що компілятор Scala знає, що <code>id</code> є псевдонім для <code>this</code>. Наприклад, ви можете отримати доступ до об'єкт-приватного члена <code>m</code> класу з використанням або <code>id.m</code> або <code>this.m</code>; ці два вирази повністю еквівалентні. Перший вираз не буде компілюватись, якщо <code>id</code> був просто визначений як <code>val</code> з <code>this</code> в якості правої сторони, оскільки в уьому випадку компілятор Scala буде трактувати <code>id</code> як звичайний ідентифікатор.</p></div>
<div class="paragraph"><p>Ви бачили синтаксис, як цей, в Розділі 29.4, де він використовувся для отримання типу <code>self</code> для трейту. Псевдоніми можуть бути також гарним скороченням, коли вам треба отримати доступ до <code>this</code> зовнішнього класу. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span> <span class="n">outer</span> <span class="k">=&gt;</span>
  <span class="k">class</span> <span class="nc">Inner</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="nc">Outer</span><span class="o">.</span><span class="k">this</span> <span class="n">eq</span> <span class="n">outer</span><span class="o">)</span> <span class="c1">// друкує: true</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад визначає два вкладені класи, <code>Outer</code> та <code>Inner</code>. Всередині <code>Inner</code> на значення <code>this</code> класу <code>Outer</code> посилаються два рази, використовуючи різні вирази. Перший вираз показує Java спосіб робити речі: ви можете поставити префікс перез зарезервованим словом  <code>this</code> з ім'ям зовнішнього класу через крапку; такий вираз потім посилається на <code>this</code> зовнішнього класу. Другий вираз показує альтернативу, яку вам дає Scala. Через введення псевдоніма на ім'я <code>outer</code> для <code>this</code> в класі <code>Outer</code>, ви можете посилатись на псевдоним <code>this</code> напряму, також і у внутрішньому класі. Спосіб Scala більш стислий, та також може покращити ясність, якщо ви оберете гарне ім'я для псевдоніма. Ви побачите приклади цього там і тут.</p></div>
</div>
<div class="sect2">
<h3 id="___">Одно-токенові парсери</h3>
<div class="paragraph"><p>Трейт <code>Parsers</code> визначає загальний <code>elem</code> парсера, що може бути використаний для розбору любого окремого токену:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">elem</span><span class="o">(</span><span class="n">kind</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">first</span><span class="o">))</span> <span class="nc">Success</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">first</span><span class="o">,</span> <span class="n">in</span><span class="o">.</span><span class="n">rest</span><span class="o">)</span>
      <span class="k">else</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">kind</span> <span class="o">+</span> <span class="s">&quot; expected&quot;</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей парсер приймає два елементи: рядок <code>kind</code>, що описує різновид токена, що має бути розібраний, та предикат <code>p</code> на <code>Elem</code>, що вказує, чи елемент пасує до класу токенів, що розбираються.</p></div>
<div class="paragraph"><p>Коли застосовується парсер <code>elem(kind, p)</code> до деякого входу <code>in</code>, перший елемент вхідного потоку перевіряється предикатом <code>p</code>. Якщо він <code>true</code>, парсер успішний. Його результат є сам елемент, та його залишковий вхід є вхідний потік, що починається зразу за елементом, що був розібраний. З іншого боку, якщо <code>p</code> повертає <code>false</code>, парсер схибить з повідомленням про помилку, що буде вказувати, на який тип токена він очікував.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Послідовна композиція</h3>
<div class="paragraph"><p>Парсер <code>elem</code> споживає тільки один елемент. Щоб розібрати більш цікаві фрази, ви можете сціпити парсери разом з допомогою оператора послідовної композиції, <code>~</code>. Як ви бачили до цього, <code>P~Q</code> є парсер, що спочатку застосовує парсера <code>P</code> до даного вхідного рядка. Потім, якщо <code>P</code> успішний, застосовується парсер <code>Q</code> до входу, що залишився коли парсер <code>P</code> зробив свою роботу.</p></div>
<div class="paragraph"><p>Комбінатор <code>~</code> реалізований як метод класу <code>Parser</code>. Його визначення показано на Лістингу 33.6. Метод є членом класу <code>Parser</code>. Всередині цього класу <code>p</code> вказане через <code>p =&gt;</code> як псевдонім до <code>this</code>, так що <code>p</code> позначає лівий операнд (або отримувач) <code>~</code>. Його правий операнд представлений як параметр <code>q</code>. Тепер, якщо виконати <code>p~q</code> на деякому вході <code>in</code>, перший <code>p</code> виконається на <code>in</code>, і результат буде проаналізований в порівнянні шаблоінв. Якщо <code>p</code> успішний, <code>q</code> виконується на залишку входу <code>in1</code>. Якщо <code>q</code> також успішний, парсер повністю успішний. Його результатом є об'єкт <code>~</code>, що містить обоє результата, результат <code>p</code> (тобто, <code>x</code>), та результат <code>q</code> (тобто, <code>y</code>). З іншого боку, якщо або <code>p</code> або <code>q</code> схибить, результатом <code>p~q</code> буде об'єкт <code>Failure</code>, що пертає <code>p</code> або <code>q</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="err">...</span> <span class="o">{</span> <span class="n">p</span> <span class="k">=&gt;</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="o">~</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T~U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">q</span><span class="o">(</span><span class="n">in1</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">in2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="k">new</span> <span class="o">~(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">in2</span><span class="o">)</span>
        <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
      <span class="o">}</span>
    <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 33.6 - Метод комбінатор <code>~</code>.</p></div>
<div class="paragraph"><p>Результуючий тип <code>~</code> є парсер, що повертає примірник клейс класу <code>~</code> з елементами типів <code>T</code> та <code>U</code>. Тип виразу <code>T~U</code> є просто більш виразне скорочення для параметризованого типу <code>~[T, U]</code>. Загалом, Scala завжди інтерпретує двомісні операції типів, <code>A op B</code>, як параметризований тип <code>op[A, B]</code>. Це аналогічно до ситуації для шаблонів, коли двомісний шаблон <code>P op Q</code> також інтерпретується як застосування, тобто <code>op(P, Q)</code>.</p></div>
<div class="paragraph"><p>Інші два оператора послідовної композиції, <code>&lt;~</code> та <code>~&gt;</code>, можуть бути визначені як <code>~</code>, тільки з невеликим уточненням того, як обчислюється результат. Більш елегантний прийом, однак, є визначити їх в термінах <code>~</code>, наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">&lt;~</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">p</span><span class="o">~</span><span class="n">q</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span><span class="o">~</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span>

<span class="k">def</span> <span class="o">~&gt;</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">p</span><span class="o">~</span><span class="n">q</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span><span class="o">~</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___5">Композиція альтернативи</h3>
<div class="paragraph"><p>Альернативна композиція <code>P | Q</code> стосується або <code>P</code> або <code>Q</code> для наданого входу. Першим перевіряється <code>P</code>. Якщо <code>P</code> успішний, весь парсер успішний з результатом <code>P</code>. Інакше, якщо <code>P</code> схибив, тоді спробується <code>Q</code> на тому самому вході, що і <code>P</code>. Результат <code>Q</code> буде результатом всього парсера. Ось визначення <code>|</code> як методу класа <code>Parser</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">|</span> <span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s1</span> <span class="k">@</span> <span class="nc">Success</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s1</span>
    <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">q</span><span class="o">(</span><span class="n">in</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо <code>P</code> та <code>Q</code> обоє невдалі, тоді повідомлення про невдачу визначається <code>Q</code>. Цей тонкий вибір обговорюється пізніше, в Розділі 33.9.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Справи з рекурсією</h3>
<div class="paragraph"><p>Зауважте, що параметр <code>q</code> в методах <code>~</code> та <code>|</code> ідуть за ім'ям — перед їх типом стоїть <code>=&gt;</code>. Це означає, що справжній аргумент парсера буде обчислено тільки поли <code>q</code> буде потрібний, що буде лише в випадку після виконання <code>p</code>. Це робить можливим написання рекурсивних парсерів, як наступний, що розбирає число, оточене довільною кількістю дужок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">parens</span> <span class="k">=</span> <span class="n">floatingPointNumber</span> <span class="o">|</span> <span class="s">&quot;(&quot;</span><span class="o">~</span><span class="n">parens</span><span class="o">~</span><span class="s">&quot;)&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо б <code>|</code> та <code>~</code> сприймали параметри за значенням, це визначення безпосередньо би спричинило переповнення стеку без читання будь-чого, оскільки значення <code>parens</code> з'являється посередині правої сторони.</p></div>
</div>
<div class="sect2">
<h3 id="___6">Перетворення результату</h3>
<div class="paragraph"><p>Останній метод класу <code>Parser</code> конвертує результат парсера. Парсер <code>P ^^ f</code> успішний саме тоді, коли успішний P. В цьому випадку він повертає результат <code>P</code>, конвертований з використанням функції <code>f</code>. Ось реалізація цього метода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">^^</span> <span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">),</span> <span class="n">in1</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">failure</span> <span class="k">=&gt;</span> <span class="n">failure</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="o">}</span> <span class="c1">// кінець ParserParsers, що не читає жодного входу</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є два парсери, що не споживають вхідний потік: <code>success</code> та <code>failure</code>. Парсер <code>success(result)</code> завжди успішний з наданим результатом. Парсер <code>failure(msg)</code> завжди невдалий з повідомленням про помилку <code>msg</code>. Обоє реалізовані як методи трейта <code>Parsers</code>, зовнішнього трейта, що також містить клас <code>Parser</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">success</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Success</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="o">,</span> <span class="n">in</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Опція та повтор</h3>
<div class="paragraph"><p>Так само визначені в трейті <code>Parsers</code> є комбінатори опції та повтору: <code>opt</code>, <code>rep</code> та <code>repsep</code>. Вони всі реалізовані в термінах послідовної композиції, альтернативи та перетворення результату:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">opt</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">(</span>
  <span class="n">p</span> <span class="o">^^</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span>
  <span class="o">|</span> <span class="n">success</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
<span class="o">)</span>

<span class="k">def</span> <span class="n">rep</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">(</span>
  <span class="n">p</span><span class="o">~</span><span class="n">rep</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span><span class="o">~</span><span class="n">xs</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span> <span class="o">}</span>
  <span class="o">|</span> <span class="n">success</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="o">)</span>

<span class="k">def</span> <span class="n">repsep</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="n">q</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">])</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="o">(</span>
  <span class="n">p</span><span class="o">~</span><span class="n">rep</span><span class="o">(</span><span class="n">q</span><span class="o">~&gt;</span> <span class="n">p</span><span class="o">)</span> <span class="o">^^</span> <span class="o">{</span> <span class="k">case</span> <span class="n">r</span><span class="o">~</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="n">r</span> <span class="o">::</span> <span class="n">rs</span> <span class="o">}</span>
  <span class="o">|</span> <span class="n">success</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="o">)</span>

<span class="o">}</span> <span class="c1">// кінець Parsers</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_33_7_____">33.7 Рядкові літерали та регулярні вирази</h2>
<div class="sectionbody">
<div class="paragraph"><p>Парсери, що ви бачили до цього, використовують рядкові літерали та регулярні вирази щоб розбирати окремі слова. Підтримка для цього надходить від <code>RegexParsers</code>, субтрейта <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">RegexParsers</span> <span class="k">extends</span> <span class="nc">Parsers</span> <span class="o">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей трейт більш спеціалізований, ніж трейт <code>Parsers</code> в тому, що він робить тільки з входом, що є послідовністю символів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="nc">Char</span>
</pre></div></div></div>
<div class="paragraph"><p>Він визначає два методи, <code>literal</code> та <code>regex</code>, з наступними сигнатурами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">literal</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">regex</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">Regex</span><span class="o">)</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що обоє методи мають модифікатор <code>implicit</code>, так що вони автоматично застосовуються кожного разу, коли надається <code>String</code> або <code>Regex</code>, але очікується <code>Parser</code>. Ось чому ви можете писати рядкові літерали та регулярні вирази прямо в граматиці, без потреби огортати їх в один з ціх методів. Наприклад, парсер <code>"("~expr~")"</code> буде автоматично розширений до літерала <code>literal("(")~expr~literal(")")</code>.</p></div>
<div class="paragraph"><p>Трейт <code>RegexParsers</code> також приймає обробку проміжків між символами. Щоб зробити це, він викликає метод на ім'я <code>handleWhiteSpace</code> перед виконанням парсера <code>literal</code> або <code>regex</code>. Метод <code>handleWhiteSpace</code>  про пропускає найбільшу вхідну послідовність, що відповідає до регулярному виразу <code>whiteSpace</code>, що визначений по замовчанню таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">protected</span> <span class="k">val</span> <span class="n">whiteSpace</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;\s+&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="o">}</span> <span class="c1">// кінець RegexParsers</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте іншу трактовку проміжків, ви можете перевизначити <code>val whiteSpace</code>. Наприклад, якщо ви бажаєте, щоб проміжки взагалі не пропускались, ви можете перекрити <code>whiteSpace</code> порожнім регулярним виразом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyParsers</span> <span class="k">extends</span> <span class="nc">RegexParsers</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="n">whiteSpace</span> <span class="k">=</span> <span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_8___">33.8 Лексінг та парсинг</h2>
<div class="sectionbody">
<div class="paragraph"><p>Завдання синтаксичного аналізу часто розділяється на дві фази. Фаза лексера розпізнає окремі слова на вході, та класифікує їх в деякі класи токенів. Ця фаза також називається лексичним аналізом. За цім слідує фаза синтаксичного аналізу, що аналізує послідовності токенів. Синтаксичний аналіз також індоі називають парсингом, навіть хоча це не дуже точно, оскільки лексичний аналіз також можна віднести до проблеми розбору.</p></div>
<div class="paragraph"><p>Трейт <code>Parsers</code>, описаний в попередньому розділі, може бути задіяний на любій фазі, оскільки його вхідні елементи мають абстрактний тип <code>Elem</code>. Для лексичних аналізаторів <code>Elem</code> може бути втілений як <code>Char</code>, що означає, що будуть розібрані окремі символи, що складають слово. Синтаксичний аналізатор, в свою чергу, втілює <code>Elem</code> як тип токена, що повертає лексер.</p></div>
<div class="paragraph"><p>Парсерні комбінатори Scala провадять декілька допоміжних класів для лексичного та синтаксичного аналізу. Вони містяться в двох субпакунках, по одному для кожного різновиду аналізу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">parsing</span><span class="o">.</span><span class="n">combinator</span><span class="o">.</span><span class="n">lexical</span>
<span class="n">scala</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">parsing</span><span class="o">.</span><span class="n">combinator</span><span class="o">.</span><span class="n">syntactical</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте розділити ваш парсер на окремі лексер та синтаксичний аналізатор, ви повинні подивитись Scaladoc документацію щодо ціх пакунків. Але для простих парсерів підхід на основі регулярних виразів, показаний перед цім в цій главі, зазвичай є достатнім.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_9___">33.9 Повідомлення про помилки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Існує одна фінальна тема, що досі не розкрита: як парсер видає повідомлення про помилки? Повідомлення помилок для парсерів є дещо темним мистецтвом. Одна проблема в тому, що коли парсер відхиляє деякий вхід, він загалом має налічувати декільки багато різних помилок. Кожний альтернативний <code>parse</code> має схибити, і все це рекурсивно в кожній точці вибору. Який, зі звичайно численних збоїв, повинен бути виданий як повідомлення помилки користувачеві?</p></div>
<div class="paragraph"><p>Бібліотека парсингу Scala реалізує просту евристику: серед всіх невдач обирається та, що трапилась в останній позиції вводу. Іншими словами, парсер обирає найдовший префікс, що все ще валідний, та видає повідомлення помилки, що описує, чому розбір префіксу не може бути продовжений далі. Якщо декілька точок відмови вказують на ту саму позицію, обирається та, що була оброблена останньою. Наприклад, розглянемо виконання JSON парсера на помилковій адресній книзі, що починається з рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="err">John</span><span class="p">,</span>
</pre></div></div></div>
<div class="paragraph"><p>Найдовший легальний префікс для цієї фрази є <code>{ "name": `. Так що JSON буде відмічати слово `John</code> як помилку. Парсер JSON очікує значення в цій точці, але <code>John</code> є ідентифікатором, що не вважається за значення (скоріше всього автор документу забув оточити ім'я в лапки). Повідомлення про помилку, що видає парсер для цього документу буде:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">1.13</span><span class="p">]</span> <span class="err">failure:</span> <span class="s2">&quot;false&quot;</span> <span class="err">expected</span> <span class="err">but</span> <span class="err">identifier</span> <span class="err">John</span> <span class="err">found</span>
<span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="err">John</span><span class="p">,</span>
          <span class="err">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Частина про те, що очіаувалось <code>false</code> походить від факту, що <code>false</code> є останньою альтернативою продукції для значення в JSON граматиці. Так що це була остання невдача в цій точці. Користувачі, що знають JSON граматику в деталях, можуть реконструювати повідомлення помилки, але для неекспертів ця помилка, можливо, дивна, і також може бути оманливою. Краще повідомлення про помилку може бути сконструйоване через додавання точки збою "на всі випадки", як останньої альтернативи продукції значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">obj</span> <span class="o">|</span> <span class="n">arr</span> <span class="o">|</span> <span class="n">stringLit</span> <span class="o">|</span> <span class="n">floatingPointNumber</span> <span class="o">|</span> <span class="s">&quot;null&quot;</span> <span class="o">|</span>
  <span class="s">&quot;true&quot;</span> <span class="o">|</span> <span class="s">&quot;false&quot;</span> <span class="o">|</span> <span class="n">failure</span><span class="o">(</span><span class="s">&quot;illegal start of value&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це додавання не змінює набір входів, що приймаються як валідні документи. Що це робить, це покращує повідомлення про помилку, оскільки тепер явно доданий збій, що іде як остання альтернатива, і таким чином буде повідомлення від нього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mf">1.13</span><span class="p">]</span> <span class="err">failure:</span> <span class="err">illegal</span> <span class="err">start</span> <span class="err">of</span> <span class="err">value</span>
<span class="p">{</span> <span class="nt">&quot;name&quot;</span><span class="p">:</span> <span class="err">John</span><span class="p">,</span>
          <span class="err">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація схеми "останньої можливої" помилки використовує поле на ім'я <code>lastFailure</code> в трейті <code>Parsers</code>, щоб відмічати збій, що трапився в останній позиції входу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">lastFailure</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Failure</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Поле ініціалізоване як <code>None</code>. Воно оновлюється в конструкторі класу <code>Failure</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">ParseResult</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">lastFailure</span><span class="o">.</span><span class="n">isDefined</span> <span class="o">&amp;&amp;</span>
        <span class="n">lastFailure</span><span class="o">.</span><span class="n">get</span><span class="o">.</span><span class="n">in</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">in</span><span class="o">.</span><span class="n">pos</span><span class="o">)</span>
    <span class="n">lastFailure</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Поле читається методом <code>phrase</code>, що видає фінальну помилку, якщо парсер схибить. Ось реалізація <code>phrase</code> в трейті <code>Parsers</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">phrase</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Parser</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="n">lastFailure</span> <span class="k">=</span> <span class="nc">None</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">in</span><span class="k">:</span> <span class="kt">Input</span><span class="o">)</span> <span class="k">=</span> <span class="n">p</span><span class="o">(</span><span class="n">in</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">Success</span><span class="o">(</span><span class="n">out</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">in1</span><span class="o">.</span><span class="n">atEnd</span><span class="o">)</span> <span class="n">s</span>
      <span class="k">else</span> <span class="nc">Failure</span><span class="o">(</span><span class="s">&quot;end of input expected&quot;</span><span class="o">,</span> <span class="n">in1</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">f</span> <span class="k">:</span> <span class="kt">Failure</span> <span class="o">=&gt;</span>
      <span class="n">lastFailure</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>phrase</code> виконує свій аргумент, парсер <code>p</code>. Якщо <code>p</code> успішний з повністю спожитим вводом, повертається успішний результат <code>p</code>. Якщо <code>p</code> успішний, але вхід не прочитаний повністю, повертається збій з повідомленням "end of input expected". Якщо <code>p</code> схибить, повертається збій або помилка, що зберігається в <code>lastFailure</code>. Зауважте, що трактування <code>lastFailure</code> нефункціональне; воно оновлюється як побічний ефект конструктором <code>Failure</code> та самим методом <code>phrase</code>. Функціональна версія в тій самій схемі можлива, але це потребуватиме трактування значення <code>lastFailure</code> через кожний результат парсера, неважливо, був це <code>Success</code> або <code>Failure</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_10___ll_1">33.10 Бектрекінг проти LL(1)</h2>
<div class="sectionbody">
<div class="paragraph"><p>Парсерні комбінатори задіють бектрекінг для вибору між різними парсерами в альтернативі. В виразі <code>P | Q</code>, якщо <code>P</code> схибить, буде виконуватись <code>Q</code> на тому ж вводі, що і <code>P</code>. Це трапляється навіть якщо <code>P</code> розібрав деякі токени перед тим як схибити. В цьому випадку деякі токени були розібрані знову <code>Q</code>. Бектрекінг накладає тільки декілька обмежень на те, як фурмулювати граматику, так що це може бути розібрано. В основному вам просто треба уникати ліво-рекурсивних продукцій. Продукція, така як:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expr ::= expr "+" term | term.</code></pre>
</div></div>
<div class="paragraph"><p>буде завжди хибити, оскільки <code>expr</code> безпосередньо викликає себе, і таким чином ніколи не просувається далі.<span class="footnote"><br />[Існують способи уникнути переповнення стеку, навіть за наявності лівої рекурсії, але це потребує більш чистого фреймворку парсерних комбінаторів, який наразі не був реалізований.]<br /></span> З іншого боку, бектрекінг потенційно коштовний, оскільки той самий ввод може бути розібраний декілька раз. Розглянемо примірник продукції:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expr ::= term "+" expr | term.</code></pre>
</div></div>
<div class="paragraph"><p>What happens if the expr parser is applied to an input such as (1 + 2) * 3 which constitutes a legal term? The first alternative would be tried, and would fail when matching the + sign. Then the second alternative would be tried on the same term and this would succeed. In the end the term ended up being parsed twice.</p></div>
<div class="paragraph"><p>It is often possible to modify the grammar so that backtracking can be avoided. For instance, in the case of arithmetic expressions, either one of the following productions would work:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>expr ::= term ["+" expr].
expr ::= term \{"+" term\}.</code></pre>
</div></div>
<div class="paragraph"><p>Many languages admit so-called "LL(1)" grammars.<span class="footnote"><br />[Aho, et. al., Compilers: Principles, Techniques, and Tools. [Aho86]]<br /></span> When a combinator parser is formed from such a grammar, it will never backtrack, i.e., the input position will never be reset to an earlier value. For instance, the grammars for arithmetic expressions and JSON terms earlier in this chapter are both LL(1), so the backtracking capabilities of the parser combinator framework are never exercised for inputs from these languages.</p></div>
<div class="paragraph"><p>The combinator parsing framework allows you to express the expectation that a grammar is LL(1) explicitly, using a new operator <sub>!. This operator is like sequential composition </sub> but it will never backtrack to "un-read" input elements that have already been parsed. Using this operator, the productions in the arithmetic expression parser could alternatively be written as follows:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">expr</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">term</span> <span class="o">~!</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;+&quot;</span> <span class="o">~!</span> <span class="n">term</span> <span class="o">|</span> <span class="s">&quot;-&quot;</span> <span class="o">~!</span> <span class="n">term</span><span class="o">)</span>

<span class="k">def</span> <span class="n">term</span> <span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">factor</span> <span class="o">~!</span> <span class="n">rep</span><span class="o">(</span><span class="s">&quot;*&quot;</span> <span class="o">~!</span> <span class="n">factor</span> <span class="o">|</span> <span class="s">&quot;/&quot;</span> <span class="o">~!</span> <span class="n">factor</span><span class="o">)</span>

<span class="k">def</span> <span class="n">factor</span><span class="k">:</span> <span class="kt">Parser</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span>
  <span class="s">&quot;(&quot;</span> <span class="o">~!</span> <span class="n">expr</span> <span class="o">~!</span> <span class="s">&quot;)&quot;</span> <span class="o">|</span> <span class="n">floatingPointNumber</span>
</pre></div></div></div>
<div class="paragraph"><p>One advantage of an LL(1) parser is that it can use a simpler input technique. Input can be read sequentially, and input elements can be discarded once they are read. That&#8217;s another reason why LL(1) parsers are usually more efficient than backtracking parsers.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_33_11_">33.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>You have now seen all the essential elements of Scala&#8217;s combinator parsing framework. It&#8217;s surprisingly little code for something that&#8217;s genuinely useful. With the framework you can construct parsers for a large class of context-free grammars. The framework lets you get started quickly, but it is also customizable to new kinds of grammars and input methods. Being a Scala library, it integrates seamlessly with the rest of the language. So it&#8217;s easy to integrate a combinator parser in a larger Scala program.</p></div>
<div class="paragraph"><p>One downside of combinator parsers is that they are not very efficient, at least not when compared with parsers generated from special purpose tools such as Yacc or Bison. There are two reasons for this. First, the backtracking method used by combinator parsing is itself not very efficient. Depending on the grammar and the parse input, it might yield an exponential slow-down due to repeated backtracking.This can be fixed by making the grammar LL(1) and by using the committed sequential composition operator, ~!.</p></div>
<div class="paragraph"><p>The second problem affecting the performance of combinator parsers is that they mix parser construction and input analysis in the same set of operations. In effect, a parser is generated anew for each input that&#8217;s parsed.</p></div>
<div class="paragraph"><p>This problem can be overcome, but it requires a different implementation of the parser combinator framework. In an optimizing framework, a parser would no longer be represented as a function from inputs to parse results. Instead, it would be represented as a tree, where every construction step was represented as a case class. For instance, sequential composition could be represented by a case class Seq, alternative by Alt, and so on. The "outermost" parser method, phrase, could then take this symbolic representation of a parser and convert it to highly efficient parsing tables, using standard parser generator algorithms.</p></div>
<div class="paragraph"><p>What&#8217;s nice about all this is that from a user perspective nothing changes compared to plain combinator parsers. Users still write parsers in terms of ident, floatingPointNumber, ~, |, and so on. They need not be aware that these methods generate a symbolic representation of a parser instead of a parser function. Since the phrase combinator converts these representations into real parsers, everything works as before.</p></div>
<div class="paragraph"><p>The advantage of this scheme with respect to performance is two-fold. First, you can now factor out parser construction from input analysis. If you were to write:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">jsonParser</span> <span class="k">=</span> <span class="n">phrase</span><span class="o">(</span><span class="n">value</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>and then apply jsonParser to several different inputs, the jsonParser would be constructed only once, not every time an input is read.</p></div>
<div class="paragraph"><p>Second, the parser generation can use efficient parsing algorithms such as LALR(1).<span class="footnote"><br />[Aho, et. al., Compilers: Principles, Techniques, and Tools. [Aho86]]<br /></span> These algorithms usually lead to much faster parsers than parsers that operate with backtracking.</p></div>
<div class="paragraph"><p>At present, such an optimizing parser generator has not yet been written for Scala. But it would be perfectly possible to do so. If someone contributes such a generator, it will be easy to integrate into the standard Scala library. Even postulating that such a generator will exist at some point in the future, however, there are reasons for keeping the current parser combinator framework around. It is much easier to understand and to adapt than a parser generator, and the difference in speed would often not matter in practice, unless you want to parse very large inputs.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-25 04:33:34 EEST
</div>
</div>
</body>
</html>
