include::headers.adoc[]

Глава 25
--------

Архитектура колекцій Scala
==========================

Ця глава описує архитектуру фреймворка колекцій Scala в деталях. Продовжуючи тему Глави 24, ви знайдете більше щодо внутрішньої роботи фреймворка. Ви також навчитесь, як ця архитектура допомагає вам визначити ваші власні колекції в декількох рядках коду, при цьому використовуючи значну частину функціональності колекцій з фреймворку.

Глава 24 перелічує велику кількість операцій з колекціями, що існують одноманітно на великій кількості реалізацій колекцій. Реалізація кожної операції колекцій поновій для кожного типу колекцій може призвести до значного обсягу коду, більшість якого буде копіюваться з інших місць. Така дублікація коду може з часом призвести до неузгодженості, коли операція додається або модифікується в одній частині бібліотеки колекцій, але не інших. Принципова ціль розробки фреймворка нових колекцій було уникнути жодних дублікацій, визначення кожної операції в стількох небагатьох місцях, наскільки це можливо.footnote:[Ідеально все має бути визначено тільки в одному місці, але є декілька виключень, де речі мають бути перевизначені.] Підхід розробки полягав в визначенні більшость операцій в "шаблонах" колекцій, що можуть бути гнучко наслідувані від окремих базових класів та реалізацій. В цій главі ми дослідимо ці шаблони, та інші класи і трейти, що складають "будівельні блоки" фреймворка, так само, як принципи конструкції, які вони підтримують.

25.1 Будівельники
-----------------
Майже всі операції колекцій реалізовані в термінах проходів та будівельників. Перехідні обробляються методом `Traversable` `foreach`, та побудова новий колекцій обробляється примірниками класу `Builder`. Лістинг 25.1 представляє дещо скорочений конутр цього класу.
[source,scala]
----
package scala.collection.generic
class Builder[-Elem, +To] {
  def +=(elem: Elem): this.type
  def result(): To
  def clear()
  def mapResult[NewTo](f: To => NewTo): Builder[Elem, NewTo]
  = ...
}
----
Лістинг 25.1 - Контур класу `Builder`.

Ви можете додати елемент `x` до білдера `b` за допомогою `b += x`. Також є синтаксис для додавання більше одного елемента за раз: наприклад `b += (x, y)` та `b ++= xs` роблять як для буферів. (Фактично, буфери є підсиленими версіями будівельників). Метод  `result()` повертає колекцію з будівельника. Стан будівельника невизначений після отримання його результату, але він може бути скинутий в новий порожній стан з використанням `clear()`. Будівельники є дженеріками по обох, типі елементів `Elem`, та по `To`, типу колекції, яку він повертає.

Часто будівельник може посилатись на деякий інший будівельник для збирання елементів колекції, але потім трансформує результат іншого будівництва, щоб отримати інший тип. Це завдання спрощене методом `mapResult` в класі `Builder`. Уявімо, наприклад, що ви маєте буфер масиву `buf`. Буфери масивів є будівельниками для самих себе, так що отримання  `result()` буфера масива буде повертати той самий буфер. Якщо ви бажаєте використовувати цей буфер для продукування будівельника, що будує масиви, ви можете використати `mapResult`:
[source,scala]
----
scala> val buf = new ArrayBuffer[Int]
buf: scala.collection.mutable.ArrayBuffer[Int] = ArrayBuffer()

scala> val bldr = buf mapResult (_.toArray)
bldr: scala.collection.mutable.Builder[Int,Array[Int]]
    = ArrayBuffer()
----
Значення результату `bldr` є будівельник, що використовує буфер масивів `buf` для збирання елементів. Коли треба результат від `bldr` обчислюється результат `buf`, що дає сам буфер масива `buf`. Цей буфер потім відображується за допомогою `_.toArray` на масив. Так що кінцевий результат в тому, що `bldr` є будівельник для масивів.

25.2 Виділення загальних операцій
---------------------------------
Головними цілями дизайну бібліотеки колекцій є мати одночасно природні типи та максимальне поділення коду реалізації. Зокрема, колекції Scala слідують принципу "того самого результату": коли це можливо, метод трансформації для колекції буде видавати колекцію того самого типу. Наприклад, операція `filter` має видавати на кожному типу колекцій примірник того самого типу. Застосування `filter` до `List` повинно давати `List`; застосування його до `Map` має давати `Map`; і так далі. В залишку цього розділу ви побачите, як це досягається.

Швидкий шлях
------------
Матеріал в цьому розділу трохи плотніший ніж звичайно, та може потребувати часу для сприйняття. Якщо ви бажаєте рухатись вперед швидко, ви можете пропустити залишок цього розділу, та перейти до Розділу 25.3, де ви навчатиметесь на конкретних прикладах, як інтегрувати ваші власні класи колекцій в фреймворк.

Бібліотека колекцій Scala уникає дублікації коду, та досягає принциту "того самого результату" через використання дженерік будівельників та проходах по колекціях в так званих трейтах реалізації. Ці трейти названі з суфіксом `Like`; наприклад, `IndexedSeqLike` є трейтом реалізаціх для `IndexedSeq`, та подібно до цього, `TraversableLike` є трейтом реалізації для `Traversable`. Класи колекції, такі як `Traversable` або `IndexedSeq`, наслідують всі свої суцільні методи реалізації від ціх трейтів. Трейти реалізації мають два параметри типу, замість одного для нормальних колекцій. Вони параметризують не тільки тип елементів колекції, але також тип репрезентації колекції (тобто тип підлеглої колекції), такий як `Seq[I]` або `List[T]`.

Наприклад, ось заголовок трейта `TraversableLike`:
[source,scala]
----
trait TraversableLike[+Elem, +Repr] { ... }
----
Параметр типу `Elem` означає тип елемента перехідного, тоді як параметр типу `Repr` означає тип репрезентації. Немає обмежень на `Repr`. Зокрема, `Repr` може бути втілено в тип, що сам не є субтипом `Traversable`. Таким чином, класи за межами ієрархії колекцій, такі як `String` та `Array`, все ще можуть використовувати всі операції, визначені в трейті реалізації колекції.
[source,scala]
----
package scala.collection
trait TraversableLike[+Elem, +Repr] {
  def newBuilder: Builder[Elem, Repr] // відкладене
  def foreach[U](f: Elem => U)
// відкладене
            ...
  def filter(p: Elem => Boolean): Repr = {
    val b = newBuilder
    foreach { elem => if (p(elem)) b += elem }
    b.result
  }
}
----
Лістинг 25.2 - Реалізація `filter` в `TraversableLike`.

Беручи `filter` в якості приклада, ця операція визначається один раз для всіх класів колекцій в трейті `TraversableLike`. Нарис відповідного коду показаний в Лістингу 25.2. Трейт декларує два абстрактні методи, `newBuilder` та `foreach`, що реалізовані в суцільних класах колекцій. Операція `filter` реалізована в однаковий спосіб для всіх колекцій, використовуючи ці методи. Він зпочатку конструює нового будівельника для типу репрезентації `Repr`, використовуючи `newBuilder`. Потім він проходить по всіх елементах поточної колекції з використанням `foreach`. Якщо елемент `x` задовільняє наданому предикату `p` — тобто, `p(x)` є `true` — елемент додається через будівельника. Нарешті, елементи, що побудовані в будівельнику, повертаються як примірник типу колекції `Repr`, через виклик метода будівельника `result`.

Операція `map` на колекціях трохи більш складна. Наприклад, як `f` є функція від `String` до `Int`, і `xs` є `List[String]`, тоді `xs map f` має видавати `List[Int]`. Подібним чином, якщо `ys` є `Array[String]`, тоді `ys map f` повинно давате `Array[Int]`. Але як ви досягнете цього, без дублікації визначення метода `map` в списках та масивах?

Фреймворк `newBuilder`/`foreach`, показаний в Лістингу 25.2, недостатній для цього, оскільки він дозволяє створення нових примірників того самого типу колекцій, тоді як `map` потребує примірник того самого типу конструктора, але можливо з іншим типом елемента. Більше того, навіть конструктор результуючого типу функції як `map`, може залежати в нетрівіальний спосіб від типів інших аргументів. Ось приклад:
[source,scala]
----
scala> import collection.immutable.BitSet
import collection.immutable.BitSet

scala> val bits = BitSet(1, 2, 3)
bits: scala.collection.immutable.BitSet = BitSet(1, 2, 3)

scala> bits map (_ * 2)
res13: scala.collection.immutable.BitSet = BitSet(2, 4, 6)

scala> bits map (_.toFloat)
res14: scala.collection.immutable.Set[Float] =
  Set(1.0, 2.0, 3.0)
----
Якщо ви відобразите бітову множину через функцію подвоєння `_ * 2`, ви отримєте іншу бітову множину. Однак, якщо ви відобразите ту ж множину через функцію `(_.toFloat)`, результатом буде загальний `Set[Float]`. Звичайно, це не може бути бітова множина, бо бітові множини містять `Int`, не `Float`.

Зауважте, що тип результата `map` залежить від типу функції, що передається до нього. Якщо тип результата цього функціонального аргумента знову `Int`, результатом `map` буде `BitSet`. Але якщо тип результату функціонального аргументу є щось інше, результатом `map` є простий `Set`. Скоро ви з'ясуєте, як досягається ця гнучкість типів в Scala.

Проблема з `BitSet` не є ізольованим випадком. Ось дві інші взаємодії з інтерпретатором, що відображують функцію через `map`:
[source,scala]
----
scala> Map("a" -> 1, "b" -> 2) map { case (x, y) => (y, x) }
res3: scala.collection.immutable.Map[Int,java.lang.String] =
  Map(1 -> a, 2 -> b)

scala> Map("a" -> 1, "b" -> 2) map { case (x, y) => y }
res4: scala.collection.immutable.Iterable[Int] =
  List(1, 2)
----
Перша функція обмінює два аргументи пари ключ/значення. Результат відображення цієї функції є знову мапа, але тепер ідемо в іншому напрямку. Фактично, перший вираз дає інверсію оригінальної мапи, зважаючи, що це можливо зробити. Однак друга функція відображує пару ключ/значення на ціле, а саме на частину значення. В цьому випадку ми не можемо сформувати з результату `Map`, але ми все ще можемо сформувати `Iterable`, супертрейт `Map`.

Ви можете запитати, чому не обмежити `map` так, щоб він завжди повертав той самий тип колекції? Наприклад, на бітових множинах `map` міг би сприймати тільки функції `Int`-до-`Int`, та на мапах він міг би сприймати тільки функції пара-до-пари. Це обмеження не тільки небажане з об'єктно-орієнтовної точки зору, воно також нелегальне, бо це порушує принцип підстановки Ліскова: якщо `Map` є `Iterable`, кожна операція, що є легальною на `Iterable`, мусить бути легальною на `Map`.

Замість цього Scala вирішує цю проблему за допомогою перевантаження: не тої простої форми перевантаження, наслідуваної від Java (що не може бути достатньо гнучкою), але більш систематичної форми перевантаження, що провадиться через неявні параметри.
[source,scala]
----
def map[B, That](f: Elem => B)
  (implicit bf: CanBuildFrom[Repr, B, That]): That = {
    val b = bf(this)
    for (x <- this) b += f(x)
    b.result
}
----
Лістинг 25.3 - Реалізація `map` в `TraversableLike`.

Лістинг 25.3 показує трейт `TraversableLike` в частині реалізації `map`. Це досить подібно до реалізації `filter`, показаного в Лістингу 25.2. Принципова різниця в тому, що `filter` використовує метод `newBuilder`, що є абстрактним в класі `TraversableLike`, але `map` використовує фабрику будівельника, що передається як додатковий неявний параметр типу `CanBuildFrom`. 
[source,scala]
----
package scala.collection.generic
trait CanBuildFrom[-From, -Elem, +To] {
// Створює нового будівельника
  def apply(from: From): Builder[Elem, To]
}
----
Лістинг 25.4 - Трейт `CanBuildFrom`.

Лістинг 25.4 показує визначення трейта `CanBuildFrom`, що представляє фабрики будівельниуів. Він має три параметри типу: `Elem` вказує тип елемента колекції, що має бути побудована, `To` вказує на тип колекції, що будується, та `From` вказує тип, для якого застосовуєть ця фабрика будівельників. Через визначення правильних неявних визначень фабрик будівельника, ви можете викроїти вірну поведінку типів, як треба.

Візьмемо клас `BitSet` в якості приклада. Його об'єкт компанйон містить фабрику будівельника типу `CanBuildFrom[BitSet, Int, BitSet]`. Це означає, що коли робите з `BitSet`, ви можете сконструювати інший `BitSet`, маючи що тип колекції для побудови є `Int`. Якщо це не так, ви завжди можете відкотитись до різних інших неявних фабрик будівельника, на цей раз реалізованих в об'єкті компанйоні `mutable.Set`. Тип цієї, більш загальної, фабрики будівельника, де `A` є дженерік параметр типу, такий:
[source,scala]
----
CanBuildFrom[Set[_], A, Set[A]]
----
Це означає, що коли ви оперуєте з довільним `Set`, вираженим типом з підстановкою `Set[_]`, ви знову можете побудувати `Set`, неважливо, який є тип елементу `A`. Маючи ці два неявні примірника `CanBuildFrom`, ви можете покладатись на правила Scala щодо розрішення неявних, щоб обрати той варіант, що відповідає ситуації і є найбільш специфічним.

Так що неявне розрішення провадить коректні статичні типи для складних операцій з колекціями, як `map`. Але що до динамічних типів? Зокрема, скажімо, якщо ви маєте значення списку, що має `Iterable` як свій статичний тип, і ви відображуєте деяку функцію по цьому значенню:
[source,scala]
----
scala> val xs: Iterable[Int] = List(1, 2, 3)
xs: Iterable[Int] = List(1, 2, 3)

scala> val ys = xs map (x => x * x)
ys: Iterable[Int] = List(1, 4, 9)
----
Статичний тип `ys` вище є `Iterable`, як і очікувалось. Але його динамічний тип є (і має бути) `List`! Ця поведінка досягається ще одним перенаправленням. Метод `apply` в `CanBuildFrom` отримує колекцію джерела як аргумент. Більшість фабрик будівельника для дженеріків перехідних (фактично всі, за винятком фабрик будівельника для класів листів) пересилають виклик до метода `genericBuilder` колекції.

В свою чергу метод `genericBuilder` викликає будівельник, що належить до колекції, в якій він визначений. Так що Scala використовує неявне розрішення для визначення обмежень по типах `map`, та віртуально скеровує для обрання кращого динамічного типу, що відповідає цім обмеженням.

25.3 Інтеграція нових колекцій
------------------------------
Що треба зробити, якщо ви бажаєте інтегрувати новий клас колекції, так щоб ви могли отримати вигоди від всіх попередньо визначених операцій від правильних типів? В цьому розділі ми покажемо вам два приклада як це робиться.

Інтеграція послідовностей
~~~~~~~~~~~~~~~~~~~~~~~~~
Скажімо, ви бажаєте створити новий тип послідовності для спіралей РНК, що є послідовностями основ: A (аденін), T (тимін), G (гуанін) та U (урацил). Визначення для основ встановлюються просто, як показано на Лістингу 25.5.

Кожна база визначена як кейс об'єкт, що наслідує від загального абстрактного класу `Base`. Клас `Base` має об'єкт компанйон, що визначає дві функції, які пов'язують основи з цілими від 0 до 3. Ви можете побачити на прикладах два різні шляхи використовувати колекції для реалізації ціх функцій. Функція `toInt` реалізована як `Map` від значень  `Base` на цілі. Зворотня функція, `fromInt`, реалізована як масив. Це використовує факт, що обоє, мапи та масиви є функціями, оскільки вони наслідують від трейта `Function1`.

Наступне завдання визначити клас для спіралей РНК. Концептуально такий ланцюжок РНК є просто `Seq[Base]`. Однак ланцюжок РНК може стати досить довгим, так що має сенс докласти деякої роботи для компактної репрезентації. Оскільки основ тільки чотири, основа може бути ідентифікована чотирьма бітами, і ви можете зберігати шістнадцять основ в двобайтному значенні як ціле. Тоді ідея побудувати особливий клас `Seq[Base]`, що використовує цю запаковану репрезентацію.

Лістинг 25.6 представляє першу версію цього класу; пізніше вона буде покращена. Клас RNA1 має конструктор, що приймає масив з `Int` в якості першого елемента. Цей масив містить запаковані дані RNA з шістнадцятьма основами на один елемент, за винятком останнього елементу масива, що може бути заповнений частково. Другий аргумент, довжина, вказує загальну кількість основ в масиві (та в послідовності). Клас `RNA1` розширює `IndexedSeq[Base]`. Трейт `IndexedSeq`, що надходить з пакунка `scala.collection.immutable`, визначає два абстрактні методи, `length` та `apply`.
[source,scala]
----
abstract class Base
case object A extends Base
case object T extends Base
case object G extends Base
case object U extends Base 

object Base {
  val fromInt: Int => Base = Array(A, T, G, U)
  val toInt: Base => Int = Map(A -> 0, T -> 1, G -> 2, U -> 3)
}
----
Лістинг 25.5 - Основи РНК.

Ці методи мають бути реалізованими в суцільних субкласах. Клас `RNA1` реалізує `length` автоматично, через визначення параметрического поля (описане в Розділі 10.6) з саме таким ім'ям. Він реалізує метод індексації `apply` за допомогою кода, наданому в Лістингу 25.6. По суті `apply` зпочатку виділяє ціле значення з масиву `groups`, потім виділяє коректне двобітне число з цього цілого з використанням зсува (>>) та маски (&). Приватні константи `S`, `N` та `M` надходять від об'єкта компанйона `RNA1`. `S` вказує розмір кожного пакета (тобто, два); `N` задає число двобітних пакетів в цілому; нарешті, `M` є бітова маска, що ізолює молодші `S` біт в слові.

Зауважте, що конструктор класу `RNA1` є приватним. Це означає, що клієнти не можуть створювати послідовності `RNA1` через виклик `new`, що має сенс, оскільки приховує реалізацію послідовностей `RNA1` в термінах запакованих масивів від користувача. Якщо клієнти не можуть бачити, які деталі репрезентації послідовностей РНК, стає можливим змінити цю репрезентацію в любій точці в майбутньому, не впливаючи на клієнтській код.

Іншими словами, цей дизайн досягає гарного розділення інтерфейса РНК послідовностей, та його реалізації. Однак, якщо конструювання РНК послідовності за допомогою `new` неможливе, має бути якійсь інший шлях створювати нові РНК послідовності, або інакше цілий клас буде скоріше некорисним. Є дві альтернативи для створення РНК послідовності, обоє провадяться об'єктом компанйоном `RNA1`. Перший шлях є метод `fromSeq`, що конвертує надану послідовність основ (тобто значення типу `Seq[Base]`) в послідовність класу `RNA1`. Метод `fromSeq` робить це через пакування всіх основ, що містяться в послідовності аргументі в масив, потім викликаючи приватний конструктор RNA1 з цім масивом та довжиною оригінальної послідовності в якості аргументів. Це задіє використання факта, що приватний конструктор видимий до об'єкта компанйона класу.
[source,scala]
----
import collection.IndexedSeqLike
import collection.mutable.{Builder, ArrayBuffer}
import collection.generic.CanBuildFrom

final class RNA1 private (val groups: Array[Int],
    val length: Int) extends IndexedSeq[Base] {

  import RNA1._

  def apply(idx: Int): Base = {
    if (idx < 0 || length <= idx)
      throw new IndexOutOfBoundsException
    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)
  }
}

object RNA1 {
// Число біт для представлення групи
  private val S = 2

// Число груп, що містяться в Int
  private val N = 32 / S

// Бітова маска для ізоляції групи
  private val M = (1 << S) - 1

  def fromSeq(buf: Seq[Base]): RNA1 = {
    val groups = new Array[Int]((buf.length + N - 1) / N)
    for (i <- 0 until buf.length)
    groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)
    new RNA1(groups, buf.length)
  }
  
  def apply(bases: Base*) = fromSeq(bases)
}
----
Лістинг 25.6 - Перша версія класу РНК ланцюжків.

Другий спосіб створити значення `RNA1` є провадження метода `apply` в об'єкті `RNA1`. Він приймає змінне число аргументів `Base`, та просто пересилає їх як послідовність до `fromSeq`.

Ось обидві схеми створення в дії:
[source,scala]
----
scala> val xs = List(A, G, T, A)
xs: List[Product with Base] = List(A, G, T, A)

scala> RNA1.fromSeq(xs)
res1: RNA1 = RNA1(A, G, T, A)

scala> val rna1 = RNA1(A, U, G, G, T)
rna1: RNA1 = RNA1(A, U, G, G, T)
----

Адаптація типу результатів методів `RNA`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ось ще деякі інтеракції з абстракцією `RNA1`:
[source,scala]
----
scala> rna1.length
res2: Int = 5

scala> rna1.last
res3: Base = T

scala> rna1.take(3)
res4: IndexedSeq[Base] = Vector(A, U, G)
----
Перші два результати виглядають очікуваними, але останній результат отримання трьох елементів від `rna1`, можливо, ні. Фактично, ви бачите `IndexedSeq[Base]` як статичний тип результату, та `Vector` як динамічний тип значення результату. Ви можливо очікували замість цього отримати значення `RNA1`. Але це неможливо, оскільки все, що ми зробили в Лістингу 25.6, це зробили `RNA1` розширенням `IndexedSeq`. Клас `IndexedSeq`, з іншого боку, має метод `take`, що повертає `IndexedSeq`, і це реалізоване в термінах реалізації `IndexedSeq` по замовчанню, а саме `Vector`.

Тепер, коли ви зрозуміли, чому все відбувається як відбувається, наступне запитання має бути: що треба зробити, щоб змінити це? Один спосіб зробити це може бути перекрити метод `take` в класі `RNA1`, можливо так:
[source,scala]
----
def take(count: Int): RNA1 = RNA1.fromSeq(super.take(count))
----
Це зробить свою роботу для `take`. Але як щодо `drop`, або `filter`, або `init`? Фактично є більше п'ятидесяти методів на послідовностях, що знову повертають послідовність. Для сумісності всі вони мають бути перекриті. Це менше і менше виглядає як приваблива опція.

Нащастя, існує значно простіший спосіб досягти того самого ефекту. Клас `RNA` має наслідувати не тільки від `IndexedSeq`, але також від його трейта реалізації `IndexedSeqLike`. Це показане в Лістингу 25.7. Нова реалізація відрізняється від попередньої тільки в двох аспектах. Перше, клас `RNA2` тепер також розширяє `IndexedSeqLike[Base, RNA2]`. Трейт `IndexedSeqLike` реалізує всі суцільні методи `IndexedSeq` в розширюваний спосіб.

Наприклад, тип повернення методів як `take`, `drop`, `filter` або `init` є другим параметром типу, переданим до класу `IndexedSeqLike` (тобто, `RNA2` в Лістингу 25.7). Щоб зробити це, `IndexedSeqLike` базує себе на абстракції `newBuilder`, що створює будівельник правильного різновиду. Субкласи трейту `IndexedSeqLike` мають перекрити `newBuilder`, щоб повертати колекції свого власного типу. В класі `RNA2` метод  `newBuilder` повертає будівельника типу `Builder[Base, RNA2]`. Щоб сконструювати цього будівельника він спочатку створює `ArrayBuffer`, що сам є `Builder[Base, ArrayBuffer]`. Потім він трансформує будівельник `ArrayBuffer` через власний метод `mapResult` до будівельника `RNA2`. Метод `mapResult` очікує функцію трансформації від `ArrayBuffer` до `RNA2` в якості параметра. Функція є просто `RNA2.fromSeq`, що конвертує довільну базову послідовність на значення `RNA2` (згадайте, що буфер масива є різновид послідовності, так що до нього може бути застосований `RNA2.fromSeq`).
[source,scala]
----
final class RNA2 private (
  val groups: Array[Int],
  val length: Int
) extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA2] {

  import RNA2._

  override def newBuilder: Builder[Base, RNA2] =
    new ArrayBuffer[Base] mapResult fromSeq

  def apply(idx: Int): Base = // як раніше
}
----
Лістинг 25.7 - Клас ланцюжка РНК, друга версія.

Якщо ви забудете визначення `newBuilder`, ви отримаєте повідомлення про помилку, приблизно такого змісту:
[source,scala]
----
RNA2.scala:5: error: overriding method newBuilder in trait
TraversableLike of type => scala.collection.mutable.Builder[Base,RNA2];
  method newBuilder in trait GenericTraversableTemplate of type
  => scala.collection.mutable.Builder[Base,IndexedSeq[Base]] has
  incompatible type
class RNA2 private (val groups: Array[Int], val length: Int)
      ^
one error found
----
Повідомлення про помилку досить довге та заскладне, що відзеркалює плутаний шлях, яким бібліотеки колекцій складаються докупи. Краще проігнорувати інформацію щодо того, звідки походять методи, бо це випадок, коли це більше заважає, ніж допомагає. Що залишається, це те, що метод `newBuilder` з типом результата `Builder[Base, RNA2]` має бути визначений, але був знайдений лише метод `newBuilder` з типом результата `Builder[Base,IndexedSeq[Base]]`. Останній не перекриває попередній.

Перший метод, чий тип результата `Builder[Base, RNA2]`, є абстрактним методом, що був втілений в цьому типі в Лістингу 25.7, через передачу параметра типу до `IndexedSeqLike`. Другий метод, з типом результата `Builder[Base,IndexedSeq[Base]]`, є те, що провадиться наслідуваним класом `IndexedSeq`. Іншими словами, клас `RNA2` є невалідним без визначення `newBuilder` з першим типом результата.

З покращеною реалізацією класа `RNA` в Лістингу 25.7, методи як `take`, `drop` або `filter` роблять як очікується:
[source,scala]
----
scala> val rna2 = RNA2(A, U, G, G, T)
rna2: RNA2 = RNA2(A, U, G, G, T)

scala> rna2 take 3
res5: RNA2 = RNA2(A, U, G)

scala> rna2 filter (U !=)
res6: RNA2 = RNA2(A, G, G, T)
----

Справи з `map` та друзями
~~~~~~~~~~~~~~~~~~~~~~~~~
Існує інший клас методів, з якими ми досі не мали справи. Ці методи не завжди повертають колекцію точно того самого типу. Вони можуть повернути той самий різновид колекції, але з іншим типом елементів. Класичним прикладом є метод `map`. Якщо є `Seq[Int]`, та `f` є функція від `Int` до `String`, тоді `s.map(f)` буде повертати `Seq[String]`. Так що тип елементу змінюється від отримувача до результата, але різновид колекції залишається такий самий.

Існує декілька інших методів, що поводяться як `map`. Для деяких з них ви можете очікувати цього (як `flatMap`, `collect`), але від інших ні. Наприклад, метод додавання, `++`, також може повертати результат, тип якого відрізняється від його аргументів — додавання списку зі `String` до списку `Int` буде давати список з `Any`. Як ці методи мають бути адаптовані до ланцюжків `RNA`? В ідеалі ми очікуємо, що відображення від основи до основи на РНК має знову давати ланцюжок РНК:
[source,scala]
----
scala> val rna = RNA(A, U, G, G, T)
rna: RNA = RNA(A, U, G, G, T)

scala> rna map { case A => T case b => b }
res7: RNA = RNA(T, U, G, G, T)
----
Подібним чином, додавання двох ланцюжків за допомогою `++` має давати новий ланцюжор РНК:
[source,scala]
----
scala> rna ++ rna
res8: RNA = RNA(A, U, G, G, T, A, U, G, G, T)
----
З іншого боку, відображення основи на якійсь інший тип на РНК ланцюжку не може дати новий ланцюжок, оскільки нові елементи мають не той тип. Замість цього буде видана послідовність. В тому ж дусі, додавання елементів, що не є типу `Base` до ланцюжка дає загальну послідовність, але ніколи не може дати новий ланцюжок.
[source,scala]
----
scala> rna map Base.toInt
res2: IndexedSeq[Int] = Vector(0, 3, 2, 2, 1)

scala> rna ++ List("missing", "data")
res3: IndexedSeq[java.lang.Object] =
  Vector(A, U, G, G, T, missing, data)
----
Це те, що ми очікуємо в ідеальному випадку. Але це не те, що провадить клас `RNA2`, як він є в Лістингу 25.7. Фактично, якщо ви запустите перші два приклади вище з цім класом, ви отримаєте:
[source,scala]
----
scala> val rna2 = RNA2(A, U, G, G, T)
rna2: RNA2 = RNA2(A, U, G, G, T)

scala> rna2 map { case A => T case b => b }
res0: IndexedSeq[Base] = Vector(T, U, G, G, T)

scala> rna2 ++ rna2
res1: IndexedSeq[Base] = Vector(A, U, G, G, T, A, U, G, G, T)
----
Так що результат `map` та `++` ніколи не буде ланцюжком, навіть якщо тип елементів згенерованої колекції буде `Base`. Щоб побачити, як зробити краще, має сенс подивитись на сигнатуру метода `map` (або `++`, що має подібну сигнатуру). Оригінально метод `map` визначений в класі `scala.collection.TraversableLike` з наступною сигнатурою:
[source,scala]
----
def map[B, That](f: Elem => B)
  (implicit cbf: CanBuildFrom[Repr, B, That]): That
----
Тут `Elem` є типом елементів колекції, та `Repr` є типом самої колекції; тобто, другий параметр типу, що передається до класу реалізації, такий як `TraversableLike` та `IndexedSeqLike`. Метод `map` приймає два інші параметри типу, `B` та `That`.

Параметр `B` позначає тип результату функції відображення, що також є типом елементів нової колекції. `That` з'являється як тип мапи, так що він представляє тип нової колекції,що створюється.

Як визначається тип `That`? Він зв'язується з іншими типами через неявний параметр `cbf` за типом `CanBuildFrom[Repr, B, That]`. Ці неявні `CanBuildFrom` визначені індивідуальними класами колекцій. В основному неявне значення типу `CanBuildFrom[From, Elem, To]` каже: "Ось спосіб, маючи колекцію типу `From`, побудувати з елементів типу `Elem` колекцію типу `To`".
[source,scala]
----
final class RNA private (val groups: Array[Int], val length: Int)
  extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {

  import RNA._

// Обов'язкова реалізація `newBuilder` в `IndexedSeq`
  override protected[this] def newBuilder: Builder[Base, RNA] =
    RNA.newBuilder

// Обов'язкова реалізація `apply` в `IndexedSeq`
  def apply(idx: Int): Base = {
    if (idx < 0 || length <= idx)
      throw new IndexOutOfBoundsException
    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)  
  }

// Опціональна реалізація `foreach`, щоб зробити
// його більш ефективним.
  override def foreach[U](f: Base => U): Unit = {
    var i = 0
    var b = 0
    while (i < length) {
      b = if (i % N == 0) groups(i / N) else b >>> S
      f(Base.fromInt(b & M))
      i += 1
    }
  }
}
----
Лістинг 25.8 - Клас ланцюжків РНК, фінальна версія.

Тепер поведінка `map` та `++` на `RNA2` послідовностях стає яснішою. Немає `CanBuildFrominstance`, що створює `RNA2` послідовності, так що наступний найкращий доступний `CanBuildFrom` був знайдений в об'єкті компанйоні наслідуваного трейта `IndexedSeq`. Цей неявний примірник створює `IndexedSeqs`, і це те, що ви бачили, коли застосували `map` до `rna2`. Щоб виправити цей недолік, вам треба визначити неявний примірник `CanBuildFrom` в об'єкті компанйоні класу `RNA`. Цей примірник повинен мати тип `CanBuildFrom[RNA, Base, RNA]`. Таким чином, цей примірник стверджує, що маючи ланцюжок РНК і новий тип елементу `Base`, ви можете побудувати іншу колекцію, що знову буде ланцюжком. Лістинг 25.8 та Лістинг 25.9 показують деталі.
[source,scala]
----
object RNA {
  private val S = 2 // число біт в групі
  private val M = (1 << S) - 1 // бітова маска для ізоляції групи
  private val N = 32 / S // кількість груп в Int

  def fromSeq(buf: Seq[Base]): RNA = {
    val groups = new Array[Int]((buf.length + N - 1) / N)
    for (i <- 0 until buf.length)
      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)
    new RNA(groups, buf.length)
  }

  def apply(bases: Base*) = fromSeq(bases)
  
  def newBuilder: Builder[Base, RNA] =
    new ArrayBuffer mapResult fromSeq

  implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] =
    new CanBuildFrom[RNA, Base, RNA] {
      def apply(): Builder[Base, RNA] = newBuilder
      def apply(from: RNA): Builder[Base, RNA] = newBuilder
    }
}
----
Лістинг 25.9 - Об'єкт компанйон `RNA`, фінальна версія.

Порівняно з класом `RNA2` є дві важливі відмінності. Перше, реалізація `newBuilder` була переміщена з класу `RNA` до його об'єкта компанйона. Метод `newBuilder` в класі `RNA` просто пересилає до цього визначення. Друге, тепер в об'єкті `RNA` є неявне значення `CanBuildFrom`. Щоб створити такий об'єкт, вам треба визначити два методи `apply` в трейті `CanBuildFrom`. Обоє створять нового будівельника для колекції `RNA`, але в них різний список аргументів. Метод `apply()` просто створює нового будівельника правильного типу. Для контрасту метод `apply(from)` приймає оригінал колекції як аргумент. Це може бути корисним для адаптації динамічного типу повернення будівельника, щоб він був той самий, що і динамічний тип отримувача. В випадку з `RNA` це не має зіграти роль, оскільки  RNA є фінальним класом, так що кожний отримувач статичного типу `RNA` також матиме `RNA` в якості динамічного типу. Ось чому `apply(from)` також просто викликає `newBuilder`, ігноруючи аргумент.

Ось так. Клас `RNA` в Лістингу 25.8 реалізує всі методи колекцій на їх природний типах. Його реалізація потребує малої частки протоколу. В основному ви маєте знати, де покласти фабрики `newBuilder` та неявні `canBuildFrom`. З іншого боку, з відносно невеликим кодом ви отримали велику кількість автоматично визначених методів. Також, якщо ви не маєте намірів робити для ваших колекцій масові операції, як `take`, `drop`, `map` або `++`, ви можете обрати не робити додаткову `length`, та зупинитись на реалізації, показаній в Лістингу 25.6.

Дискусія досі оберталась коло найменьшої кількості визначень, потрібних для визначення нових послідовностей, з методами, що підкорюються певним типам. Але на практиці ви можете також захотіти додати нову функціональність до ваших послідовностей, або перекрити існуючі методи для кращої ефективності. Прикладом цього є перекритий метод `foreach` в класі `RNA`. `foreach` є важливим методом сам по собі, оскільки він реалізує цикли по колекціях. Більше того, багато інших методів колекцій реалізовані в термінах `foreach`. Так що має сенс інвестувати деякі зусилля в оптимізацію реалізації цього метода.

Стандартна реалізація `foreach` в `IndexedSeq` буде просто обирати кожний `i`-тий елемент колекції, використовуючи `apply`, де `i` в диапазоні від 0 до довжини колекції мінус один. Так що стандартна реалізація вибирає елемент та розпаковує з нього основу кожного разу для кожного елемента в `RNA`. Перекриваюче `foreach` в класі RNA є розумнішим ніж це. Для кожного обраного елементу масива він безпосередньо застосовує надану функцію до всіх основ, що містяться в елементі. Так що зусилля для виборки з масива та розпаковки біт дуже зменшено.

Інтегрування нових множин та мап
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Другий приклад, який ви вивчете, це як інтегрувати в фреймворк колекцій новий різновид мапи. Ідея полягає в реалізації змінної мапи зі `String` як типом ключа, через "Patricia дерева".footnote:[Morrison, "PATRICIA — Practical Algorithm To Retrieve Information Coded in Alphanumeric" [Mor68\]] Термін Patricia є скороченням для "Practical Algorithm to Retrieve Information Coded in Alphanumeric". Ідея в зберіганні множини або мапи як дерева,де послідовні символи в ключі пошуку визначають унікальне наступне дерево.

Наприклад, дерево Patricia зберігає п'ять рядків, `"abc"`, `"abd"`, `"al"`, `"all"`, `"xy"`, та може виглядати як дерево на Малюнку 25.1. Щоб знайти вузол, відповідний рядку `"abc"` в цьому дереві, просто слідуйте піддереву з міткою `"a"`, звідти ідіть до піддерева з міткою `"b"`, щоб нарешті досягти субдерева з міткою `"c"`. Якщо дерево Patricia використовується як мапа, значення, що асоційоване з ключем, зберігається в вузлах, що можуть бути досяжними по ключу. Якщо це множина, ви просто зберігаєте маркер, який каже що вузол присутній в множині.
[source,scala]
----
import collection._

class PrefixMap[T]
  extends mutable.Map[String, T]
    with mutable.MapLike[String, T, PrefixMap[T]] {
    var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty
    var value: Option[T] = None

    def get(s: String): Option[T] =
      if (s.isEmpty) value
      else suffixes get (s(0)) flatMap (_.get(s substring 1))

    def withPrefix(s: String): PrefixMap[T] =
      if (s.isEmpty) this
      else {
        val leading = s(0)
        suffixes get leading match {
          case None =>
            suffixes = suffixes + (leading -> empty)
          case _ =>
        }
        suffixes(leading) withPrefix (s substring 1)
      }

  override def update(s: String, elem: T) =
    withPrefix(s).value = Some(elem)

  override def remove(s: String): Option[T] =
    if (s.isEmpty) { val prev = value; value = None; prev }
    else suffixes get (s(0)) flatMap (_.remove(s substring 1))

  def iterator: Iterator[(String, T)] =
    (for (v <- value.iterator) yield ("", v)) ++
    (for ((chr, m) <- suffixes.iterator;
          (s, v) <- m.iterator) yield (chr +: s, v))

  def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }

  def -= (s: String): this.type = { remove(s); this }

  override def empty = new PrefixMap[T]
}
----
Лістинг 25.10 - Реалізація префіксної мапи за допомогою Patricia дерев.

Малюнок 25.1 - Приклад дерева Patricia.

Patricia дерева підтримують дуже ефективні пошуки та оновлення. Інша гарна можливість в тому, що вони підтримують виборку субколекцій по заданому префіксу. Наприклад, в дереві на Малюнку 25.1 ви можете отримати субколекцію по всім ключам, що починаються на `"a"`, просто слідуя посиланню `"a"` від кореня дерева.

Базуючись на ціх ідеях ми тепер будемо проходити з вами по реалізації мапи, що реалізована як дерево Patricia. Ми назвали мапу `PrefixMap`, що означає, що вона підтримує метод `withPrefix`, що обирає субмапу з усіх ключів, що мають наданий префікс.

Спочатку ми визначимо префіксну мапу з ключами, показану на Малюнку 25.1:
[source,scala]
----
scala> val m = PrefixMap("abc" -> 0, "abd" -> 1, "al" -> 2,
"all" -> 3, "xy" -> 4)
m: PrefixMap[Int] = Map((abc,0), (abd,1), (al,2), (all,3),
(xy,4))
----
Коли викликається `withPrefix` на `m`, це даватиме іншу префіксну мапу:
[source,scala]
----
scala> m withPrefix "a"
res14: PrefixMap[Int] = Map((bc,0), (bd,1), (l,2), (ll,3))
----
Лістинг 25.10 показує визначення `PrefixMap`. Цей клас параметризований типом асоційованого значення `T`, та розширює `mutable.Map[String, T]` та `mutable.MapLike[String, T, PrefixMap[T]]`. Ви вже бачили цей шаблон для послідовностей в прикладі з РНК ланцюжками. Тепер, коли є наслідування класу реалізації, такого як `MapLike`, це служить для отримання правильного класу результату для таких трансформацій, як `filter`.

Вузол префіксної мапи має два змінних поля: `suffixes` та `value`. Поле `value` містить додаткове значення, що асоційоване з вузлом. Воно ініціалізоване як `None`. Поле `suffixes` містить тмапу від префіксів до значень `PrefixMap`. Воно ініціалізоване як порожня мапа. Ви можете запитати, чому ми обрали незмінну мапу як тип реалізації для `suffixes`? Чи не була б змінна мапа більш стандартною, оскільки `PrefixMap` вцілому також змінна? Відповідь в тому, що незмінні мапи, що містять тільки декілька елементів, є дуже ефективними одночасно, по простору і часу виконання.

Наприклад, мапи, що містять меньше ніж 5 елементів, представлені як один об'єкт. Для контрасту, як описано в Розділі 17.2, стандартна змінна мапа є `HashMap`, що типово займає близько 80 байт, навіть якщо вона порожня. Так що якщо мали колекції є типовими, краще обирати незмінні замість змінних. В випадку дерев Patricia ми очікуємо, що більшість вузлів, за винятком тих, що будуть з самого верху дерева, будуть містити лише декільки наступних. Так що зберігання ціх наступних в незмінній мапі, вірогідно, буде більш ефективним.

Тепер подивимось на перший метод, що має бути реалізований для мапи: `get`. Алгоритм наступний: щоб отримати значення, асоційоване з порожнім рядком в префіксній мапі, просто оберіть опціональне значення, що зберігається в корені дерева. Інакше, якщо рядок не порожній, спробуйте вибрати субмапу, що відповідає першому символу в рядку. Якщо це дає мапу, продовжуйте через пошук залишку ключового рядка після його першого символа в цій мапі. Якщо вибірка схибить, ключ не зберігається в мапі, так що повертаємо `None`. Комбінована вибірка через опціональне значення елегантно виражене через `flatMap`. Коли застосовується до опціонального значення `ov` та замикання `f`, що в свою чергу повертає опціональне значення, `ov flatMap f` буде успішним, якщо обоє, `ov` та `f` повертає визначене значення. Інакше `ov flatMap f` буде повертати `None`.

Наступні два методи, що треба реалізувати для змінної мапи, є `+=` та `-=`. В реалізації на Лістингу 25.10 вони визначені в термінах двох інших методів: `update` та `remove`. Метод `remove` дуже подібний до метода `get`, за тим винятком, що перед поверненням асоційованого значення, поле, що містить це значення, встановлюється в `None`. Метод `update` спочатку викликає `withPrefix` для навігації до вузла дерева, що потребує оновлення, та потім встановлює поле цього вузла в надане значення. Метод `withPrefix` навігує по дереву, створюючи субмапи за необхідності, якщо деякий префікс з символів ще не міститься як шлях в дереві.

Останній абстрактний метод, що треба реалізувати для змінної мапи є `iterator`. Цей метод має продукувати ітератор, що отримує всі пари ключ/значення, що зберігаються в мапі. Для кожної префіксної мапи цей ітератор складається з наступних частин: перше, якщо мапа містить визначене значення, `Some(x)`, в полі `value` в своєму корені, потім `("", x)` є першим елементом, що повертається від ітератора. Більше того, ітератор має пройти по всіх ітераторах всіх субмап, що містяться в полі `suffixes`, але він має додавати символ перед кожним рядком, що повертається ціма ітераторами. Більш точно, якщо `m` є субмапою, що досяжна з кореня через символ `chr`, та `(s, v)` є елементом, що повертає `m.iterator`, тоді кореневий ітератор буде повертати `(chr +: s, v)`.

Ця логіка реалізована досить стисло, як конкатенація двох виразів в реалізації метода  `iterator` з Лістингу 25.10. Перший `for` вираз ітерує по `value.iterator`. Це використовує факт, що значення `Option` визначають метод `iterator`, що або не повертає елементів, якщо опціональне значення `None`, або рівно один елемент `x`, якщо значення опціїif є `Some(x)`.
[source,scala]
----
import scala.collection.mutable.{Builder, MapBuilder}
import scala.collection.generic.CanBuildFrom

object PrefixMap {
  def empty[T] = new PrefixMap[T]

  def apply[T](kvs: (String, T)*): PrefixMap[T] = {
    val m: PrefixMap[T] = empty
    for (kv <- kvs) m += kv
    m
  }

  def newBuilder[T]: Builder[(String, T), PrefixMap[T]] =
    new MapBuilder[String, T, PrefixMap[T]](empty)

  implicit def canBuildFrom[T]
    : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] =
      new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {
        def apply(from: PrefixMap[_]) = newBuilder[T]
        def apply() = newBuilder[T]
      }
}
----
Лістинг 25.11 - Об'єкт компанйон для префіксної мапи.

Зауважте, що немає метода `newBuilder`, визначеного в `PrefixMap`. В ньому немає потреби, оскільки мапи та множини ідуть з будівельниками по замовчанню, що є примірниками класу  `MapBuilder`. Для змінної мапи будівельник по замовчанню починає з порожньої мапи, та потім додає послідовні елементи, використовуючи метод мапи `+=`.

Змінні множини поводяться таким же чином. Будівельники по замовчанню для незмінних мап та множин використовують неруйнівний метод додавання елементу `+`, замість метода `+=`. Однак у всіх ціх випадках, щоб побудувати правильний різновид множини або мапи вам треба почати з порожньої множини або мапи цього виду. Це провадиться методом `empty`, що є останнім метедом, визначеним в `PrefixMap`. В Лістингу 25.10 цей метод просто повертає свіжу `PrefixMap`.

Тепер ми перейдемо до об'єкта компанйона `PrefixMap`, що показаний на Лістингу 25.11. Фактично, не є винятково необхідним визначати цей об'єкт, бо клас `PrefixMap` може гарно встояти як він є. Головне призначення об'єкта `PrefixMap` є визначити деякі зручні методи фабрик. Він також визначає неявне значення `CanBuildFrom`, щоб покращити роботу типізації.

Два зручні методи - це `empty` та `apply`. Ті самі методи присутні для всіх інших колекцій в фреймворці колекцій Scala, так що має сенс визначити тут їх, також. З ціма двома методами ви можете записати літерали `PrefixMap`, як ви робите це для всіх інших колекцій:
[source,scala]
----
scala> PrefixMap("hello" -> 5, "hi" -> 2)
res0: PrefixMap[Int] = Map((hello,5), (hi,2))

scala> PrefixMap.empty[String]
res2: PrefixMap[String] = Map()
----
Інший член в об'єкті `PrefixMap` є неявний примірник `CanBuildFrom`. Він має те саме призначення, що і визначення `CanBuildFrom` в останньому розділі: щоб дозволити таким методам, як `map`, повертати найкращий можливий тип. Наприклад, розглянемо функцію одображення для пар ключ/значення `PrefixMap`. Доки ця функція продукує пари з рядків та якогось іншого типу, результуюча колекція знову буде `PrefixMap`. Ось приклад:
[source,scala]
----
scala> res0 map { case (k, v) => (k + "!", "x" * v) }
res8: PrefixMap[String] = Map((hello!,xxxxx), (hi!,xx))
----
Аргумент наданої функції приймає пари ключ/значення префіксної мапи `res0`, та продукує пари рядків. Результатом `map` буде `PrefixMap`, на цей раз з типом значень `String` замість `Int`. Без неявного `canBuildFrom` в `PrefixMap`, результат буде загальна змінна мапа, не префіксна мапа.

Підсумок
~~~~~~~~
Якщо ви бажаєте повністю інтегрувати новий клас колекції в фреймворк, вам треба звернути увагу на такі питання:

1. Вирішити, чи колекція повиння бути змінною чи незмінною.

2. Обрати вірний базовий трейт для колекції.

3. Наслідувати від правильного трейта реалізації, щоб реалізовати більшість операцій колекцій.

4. Якщо ви бажаєте, щоб `map` та подібні операції повертали примірники вашого класа колекції, запровадьте неявний `CanBuildFrom` в об'єкті компанйоні вашого класу. 

Висновок
--------
Тепер ви бачили, як побудовані колекції Scala, та як ви можете будувати нові різновиди колекцій. Завдяки багатій підтримці абстракцій в Scala, кожний новий тип колекцій може мати велику кількість методів, без потреби кожного разу знову реалізувати їх.
