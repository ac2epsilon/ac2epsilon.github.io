include::headers.adoc[]

Глава 22
--------

Реалізація списків
==================

Списки стали повсюдними в цій книзі. Клас `List`, можливо, є найбільш загально уживаний тип структурованих даних в Scala. Глава 16 показала вам, як використовувати списки. Ця глава "зриває покривадла", та трохи пояснює щодо того, як списки реалізовані в Scala.

Знаючи внутрішню роботу класу `List` корисне з деяких причин. Ви набудете кращу ідею щодо відносної ефективності операцій списків, що допоможе вам писати швидкий та компактний код з використанням списків. Ви також набудете інструментарій з прийомів, що ви можете застосувати в розробці ваших власних бібліотек. Нарешті, клас `List` є витонченим застосуванням системи типів Scala загалом, та зокрема її узагальнених концепцій. Так що вивчання класу `List` поглибить ваше знання ціх областях.

22.1 Клас List, принципово
-------------------------- 
`List` не є "вбудований" як конструкція мови в Scala; списки визначені як абстрактний клас `List` в пакунку `scala`, що іде з двома субкласами, `::` та `Nil`. В цій главі ми презентуємо швидкий тур по класу `List`. Цей розділ представляє дещо спрощене пояснення цього класу, порівняно з його справжньою реалізацією в стандартній бібліотеці Scala, що розкривається в Розділі 22.3.
[source,scala]
----
package scala
abstract class List[+T] {
----
List є абстрактним класом, так що ви не можете визначити елементи через виклик порожнього конструктора `List`. Наприклад, вираз `new List` буде нелегальним. Клас має параметр типу `T`. Знак `+` перед цім параметром типу вказує, що списки є коваріантними, як обговорюється в Главі 19.

Малюнок 22.1 - Ієрархія класів для списків Scala.

Завдяки цій властивості ви можете присвоїти значення типу `List[Int]` до змінної типу `List[Any]`:
[source,scala]
----
scala> val xs = List(1, 2, 3)
xs: List[Int] = List(1, 2, 3)

scala> var ys: List[Any] = xs
ys: List[Any] = List(1, 2, 3)
----
Всі операції списків можуть бути виражені в термінах трьох базових методів:
[source,scala]
----
def isEmpty: Boolean
def head: T
def tail: List[T]
----
Ці три методи всі абстрактні в класі `List`. Вони визначені в субоб'єкті `Nil` і субкласі `::`. Ієрархія для `List` показана на Малюнку 22.1.

Об'єкт `Nil`
~~~~~~~~~~~~~~
Об'єкт `Nil` визначає порожній список. Його визначення показане в Лістингу 22.1. Об'єкт `Nil` наслідує від типу `List[Nothing]`. Завдяки коваріантності це означає, що `Nil` сумісний з кожним примірником типу `List`.
[source,scala]
----
case object Nil extends List[Nothing] {
  override def isEmpty = true
  def head: Nothing =
    throw new NoSuchElementException("head of empty list")
  def tail: List[Nothing] =
    throw new NoSuchElementException("tail of empty list")
}
----
Лістинг 22.1 - Визначення об'єкта синглтона `Nil`.

Три абстрактні метода класу `List` реалізовані в об'єкті `Nil` в прямолінійний спосіб: метод `isEmpty` повертає `true`, та методи `head` та `tail` обоє закидають виключення. Зауважте, що закидання виключення не тільки має сенс, але практично є єдиною можливою річчю, що можна робити для `head`: оскільки `Nil` є `List` з `Nothing`, тип результату `head` має бути `Nothing`. Оскільки немає значення цього типу, це означає, що `head` не може повернути звичайне значення. Він має повертатись ненормально, через закидання виключення.footnote:[Щоб бути точним, типи також дозволяють `head` назавжди пійти в безкінечний цикл, замість закидання виключення, але це очевидно не те, що ми бажаємо.]

Клас `::`
~~~~~~~
Клас `::`, вимовляється `"cons"` скорочено від `"construct"`, представляє непорожній список. Він названий в такий спосіб, щоб підтримувати співпадіння шаблонів з інфіксним `::`. Ви вже бачили в Розділі 16.5, що кожна інфіксна операція в шаблоні трактується як застосування конструктора інфіксного оператора до його аргументів. Так що шаблон `x :: xs` трактується як `::(x, xs)`, де `::` є кейс класом.

Ось визначення класу `::`:
[source,scala]
----
final case class ::[T](hd: T, tl: List[T]) extends List[T] {
  def head = hd
  def tail = tl
  override def isEmpty: Boolean = false
}
----
Реалізація класу `::` є прямолінійним. Він приймає два параметри, `hd` та `tl`, які представляють голову та хвіст списку, що має бути створений. Визначення методів `head` та `tail` просто повертають відповідний параметр. Фактично, цей шаблон може бути скорочений, дозволяючи параметрам напряму реалізувати методи `head` та `tail` суперкласу `List`, як в наступному еквівалентному, але коротшому визначенні класу `::`:
[source,scala]
----
final case class ::[T](head: T, tail: List[T])
    extends List[T] {

  override def isEmpty: Boolean = false
}
----
Це робить, бо кожний параметр кейс класу неявно також є полем класу (це як декларація параметру, перед яким стоїть `val`). Згадайте з Розділу 20.3, що Scala дозволяє вам реалізовати абстрактний безпараметрний метод, як `head` або `tail`, за допомогою поля. Так що код вище напряму використовує параметри `head` та `tail` як реалізації абстрактних методів `head` та `tail`, що були наслідувані від класу `List`.

Ще декілька методів
~~~~~~~~~~~~~~~~~~~
Всі інші методи `List` можуть бути записані з використанням троьх базових методів. Наприклад:
[source,scala]
----
def length: Int =
  if (isEmpty) 0 else 1 + tail.length
----
або:
[source,scala]
----
def drop(n: Int): List[T] =
  if (isEmpty) Nil
  else if (n <= 0) this
  else tail.drop(n - 1)
----
або:
[source,scala]
----
def map[U](f: T => U): List[U] =
  if (isEmpty) Nil
  else f(head) :: tail.map(f)
----
Конструювання List
~~~~~~~~~~~~~~~~~~
Методи конструювання списків, `::` та `:::`, є особливими. Оскільки вони закінчуються на двокрапку, вони прикріплені до свого правого операнду. Тобто, операція, така як `x :: xs` розглядається як виклик метода `xs.::(x)`, не `x.::(xs)`. Фактично, `x.::(xs)` не мало б сенсу, оскільки `x` має тип елементу списку, що може бути довільним, так що ми не можемо очікувати, що цей тип має метод `::`.

З цієї причини метод `::` має приймати значення елементу та видавати новий список. Який тип має бути в значень елементів? Ви можете спокуситись і сказати, що він має бути такий самий, що і тип елементів списку, але фактично це більш обмежливе, ніж треба.

Щоб бачити чого, розглянемо таку ієрархію класів:
[source,scala]
----
abstract class Fruit
class Apple extends Fruit
class Orange extends Fruit
----
Лістинг 22.2 показує, що трапляється, коли ви конструююте списки фруктів:
[source,scala]
----
scala> val apples = new Apple :: Nil
apples: List[Apple] = List(Apple@e885c6a)

scala> val fruits = new Orange :: apples
fruits: List[Fruit] = List(Orange@3f51b349, Apple@e885c6a)
----
Лістинг 22.2 - Підставлення елементу супертипа до списку субтипа.

Значення `apples` трактується як `List` з `Apples`, як і очікувалось. Але визначення `fruits` показує, що все ще можливо додати елемент іншого типу до цього списку. Тип елементу отриманого списку буде `Fruit`, що є більш точним загальним супертипом елементів оригінального списку (`Apple`), і типу доданого елементу (`Orange`). Ця гнучкість отримана через визначення метода `::` (`cons`), як показано в Лістингу 22.3:
[source,scala]
----
def ::[U >: T](x: U): List[U] = new scala.::(x, this)
----
Лістинг 22.3 - Визначення метода `::` (`cons`) в класі `List`.

Зауважте, що метод сам по собі поліморфний — він приймає параметр типу на ім'я U. Більше того, `U` обмежений в `[U >: T]`, щоб він був супертипом типу елемента списку `T`. Елемент, що додається, має бути типу `U`, і результатом буде `List[U]`.

С формулюванням `::`, показаним на Лістингу 22.3, ви можете перевірити, як визначення `fruits`, показана в Лістингу 22.2 робить с точки зору типів: в цьому визначенні параметр типу `U` в `::` виступає як примірник `Fruit`. Обмеження нижньої межі для `U` задовільняється, оскільки список `apples` має тип `List[Apple]`, і `Fruit` є супертипом для `Apple`. Аргументом `::` є `new Orange`, що відповідає типу `Fruit`. Таким чином, застосування метода є типо-коректним, з типом результату `List[Fruit]`. Малюнок 22.2 ілюструє структуру списків, що отримуються від виконання коду, показаного в Лістингу 22.2.

Малюнок 22.2 - Структура списків Scala, показаного в Лістингу 22.2.

Фактично, поліморфне визначення `::` з нижньою межею `T` не тільки зручне, але також потрібне щоб зробить визначення класу `List` типо-коректним. Це так, тому що `List` визначений як коваріантний.

Уявімо на мить, що ми визначили `::` таким чином:
[source,scala]
----
// Розумовий експеримент (що не буде робити)
def ::(x: T): List[T] = new scala.::(x, this)
----
Ви бачили в Главі 19, що параметри метода рахуються як контрваріантні позиції, так що тип елементів списку `T` є контрваріантної позицією в визначенні вище. Але тоді `List` не може бути декларований як коваріантний по `T`. Таким чином, нижня межа, `[U >: T]`, убиває двох зайців з одного пострілу: вона прибирає проблему типізації, та призводить до того, що метод `::` стає більш гнучким в використанні. Метод конкатенації `:::` визначений в подібний до `::` спосіб, як показано в Лістингу 22.4.
[source,scala]
----
def :::[U >: T](prefix: List[U]): List[U] =
  if (prefix.isEmpty) this
  else prefix.head :: prefix.tail ::: this
----
Лістинг 22.4 - Визначення метода `:::` в класі `List`.

Як і `cons`, конкатенація є поліморфною. Тип результату "поширений" як треба, щоб включати типи всіх елементів списку. Знову зауважте, що порядок аргументів переставлений в інфіксній операції та явному виклику метода. Оскільки обоє, `:::` та `::`, завершуються на дві крапки, вони обоє прив'язуються до правої сторони, та обоє право асоціативні. Наприклад, частина `else` визначення `:::`, показаний в Лістингу 22.4, містить інфіксні операції обох, `::` та `:::`.

Ці інфіксні операції можуть бути розширені до еквівалентних методів, що викликаються таким чином:
[source,scala]
----
prefix.head :: prefix.tail ::: this
  дорівнює (оскільки :: та ::: право асоциативні)

prefix.head :: (prefix.tail ::: this)
  дорівнює (оскільки :: прикріплюється зправа)

(prefix.tail ::: this).::(prefix.head)
  дорівнює (оскількі ::: прикріплюється зправа)

this.:::(prefix.tail).::(prefix.head)
----
22.2 Клас ListBuffer
--------------------
Типовий шаблон доступа до списків є рекурсивний. Наприклад, для інкрементації кожного елемента без використовування мапи, ви можете записати:
[source,scala]
----
def incAll(xs: List[Int]): List[Int] = xs match {
  case List() => List()
  case x :: xs1 => x + 1 :: incAll(xs1)
}
----
Один з недоліків цього програмного шаблону є те, що вона не має хвостової рекурсії. Зауважте, що рекурсивний виклик до `incAll` вище, відбувається в операції `::`. Таким чином, кожний рекурсивний виклик потребує новий фрейм стеку.

На сьогоднішніх віртуальних машинах це означає, що ви не можете застосувати `incAll` до списків з більше ніж `30000` або `50000` елементів. Це шкода. Як ви пишете версію `incAll`, що може робити зі списками довільного розміру (доки дозволяє місткість купи)?

Один з підходів є використання циклу:
[source,scala]
----
for (x <- xs) // ??
----
Але що має піти в тілі циклу? Зауважте, що тут `incAll` конструює список через перед-ставлення елементів до результату рекрсивного виклику, цикл потребує додавати нові елементи до кінця результуючого списку. Дуже неефективна можливість є використання `:::`, оператора додавання списку:
[source,scala]
----
var result = List[Int]() // дуже неефективний підхід
for (x <- xs) result = result ::: List(x + 1)
result
----
Це жахливо неефективне. Оскільки `:::` займає час, пропорційний до довжини його першого операнда, повна операція займає час, пропорційний до квадрату довжини списку. Зрозуміло, що це неприйнятне.

Кращою альтернативою є використання спискового буфера. Списковий буфер дозволяє вам акумулювати елементи в списку. Щоб зробити це, ви використовуєте операцію, таку як `buf += elem`, що додає елемент `elem` в кінець спискового буфера `buf`. Коли ви скінчите додавати елементи, ви можете перетворити буфер на список, використовуючи операцію `toList`.

`ListBuffer` є класом в пакунку `scala.collection.mutable`. Щоб використовувати тільки просте ім'я, ви можете імпортувати `ListBuffer` з його пакунку:
[source,scala]
----
import scala.collection.mutable.ListBuffer
----
Використовуючи списковий буфер, тіло `incAll` тепер може бути записане таким чином:
[source,scala]
----
val buf = new ListBuffer[Int]
for (x <- xs) buf += x + 1
buf.toList
----
Це дуже ефективний спосіб будувати списки. Фактично, реалізація спискового буфера організована таким чином, що обоє операції, додавання (`+=`) та `toList` займають (дуже короткий) сталий час.

22.3 Клас List на практиці
--------------------------
Реалізація спискових методів, надане в Розділі 22.1, є стислі та зрозумілі, але потерпають від деяких проблем переповнення, як не-хвосто-рекурсивна реалізація `incAll`. Таким чином, більшість методів в реальних реалізаціях класу `List` уникають рекурсії, та замість цього використовують цикли з списковими буферами. Наприклад, Лістинг 22.5 показує справжню реалізацію `map` в класі `List`:
[source,scala]
----
final override def map[U](f: T => U): List[U] = {
  val b = new ListBuffer[U]
  var these = this
  while (!these.isEmpty) {
    b += f(these.head)
    these = these.tail
  }
  b.toList
}
----
Лістинг 22.5 - Визначення метода `map` в класі `List`.

Ця переглянута реалізація проходить по списку за допомогою простого циклу, що є дуже ефективним. Реалізація з хвостовою рекурсією може мати подібну ефективність, але загальна рекурсивна реалізація буде повільніша та менш маштабована. Але що до операції `b.toList` в кінці? Яка її складність? Фактично, виклик метода `toList` забирає тільки невелику кількість циклів, що не залежить від довжини списку.

Щоб зрозуміти чому, накиньте другий погляд на клас `::`, що конструює непорожні списки. На практиці цей клас не повністю відповідає до його ідеалізованого визначення, попередньо наданому в Розділі 22.1. Справжнє визначення показане на Лістингу 22.6. Як ви можете бачити, є одна особливість: аргумент `tl` є `var`! Це означає, що можливо модифікувати хвіст списку після того, як цей список побудований. Однак, оскільки змінна `tl` має модифікатор `private[scala]`, він може бути доступний тільки в пакунку `scala`. Клієнтський код за межами цього пакунка ніколи не може ані читати, ні писати `tl`.
[source,scala]
----
final case class ::[U](hd: U,
    private[scala] var tl: List[U]) extends List[U] {
  def head = hd
  def tail = tl
  override def isEmpty: Boolean = false
}
----
Лістинг 22.6 - Визначення субкласа `::` в `List`.

Оскільки клас `ListBuffer` міститься в субпакунку пакунка `scala`, `scala.collection.mutable`, `ListBuffer` може отримувати доступ до поля `tl` клітинки `cons`. Фактично, елементи спискового буфера представлени як список, та додавання нових елементів включає модифікацію поля `tl` останньої клітинки `::` цього списку. Ось початок класу `ListBuffer`:
[source,scala]
----
package scala.collection.immutable
final class ListBuffer[T] extends Buffer[T] {
  private var start: List[T] = Nil
  private var last0: ::[T] = _
  private var exported: Boolean = false
...
----
Ви бачите три приватні поля, що характерізують `ListBuffer`:

`start`     вказує на список з усіх елементів, що зберігаються в буфері
`last0`     вказує на останню клітину `::` в цьому списку 
`exported`  вказує, чи буфер був перетворений на список за допомогою `toList`

Операція `toList` дуже проста:
[source,scala]
----
override def toList: List[T] = {
  exported = !start.isEmpty
  start
}
----
Він повертає список елементів, на який посилається `start`, а також встановлює `true`, якщо цей список непорожній. Так що `toList` дуже ефективний, оскільки він не копіює список, що зберігається в `ListBuffer`. Але що відбувається, якщо список продовжує далі розширятись після операції `toList`? Звичайно, коли список повертається з `toList`, він має бути незмінним. Однак, додавання елемента `last0` буде модифікувати список, на який посилається `start`.

Щоб підтримувати коректність операцій спискового буфера, вам треба робити замість цього на новому списку. Це досягається першим рядком в реалізації операції `+=`:
[source,scala]
----
override def += (x: T) = {
  if (exported) copy()
  if (start.isEmpty) {
    last0 = new scala.::(x, Nil)
    start = last0
  } else {
    val last1 = last0
    last0 = new scala.::(x, Nil)
    last1.tl = last0
  }
}
----
Ви бачите, що `+=` копіює список, на який вказує `start`, якщо `exported` є `true`. Так що, кінець кінцем, нічого не дається надурно. Якщо ви бажаєте перейти від списків, що можуть розширятись з кінця, до незмінних списків, тоді це потребуватиме деякого копіювання. Однак реалізація `ListBuffer` є такою, що копіювання необхідне тільки для спискових буферів, що продовжують розширюватись після того, як вони були перетворені на списки. Цей випадок досить рідкий на практиці. Більшість випадків використання для спискових буферів додають елементи послідовно, і потім роблять одну операцію `toList` в кінці. В таких випадках копіювання непотрібне.

22.4 Функціональність назовні
-----------------------------
В попередньому розділі ми показали ключові елементи реалізації Scala класів `List` та `ListBuffer`. Ви побачили, що списки повністю функціональні "назовні", але мають імперативну реалізацію з використанням спискових буферів "всередині". Це типова стратегія в Scala програмуванні — спроба комбінувати чистоту з ефективністю, через уважне розмежування впливу нечистих операцій.

Але ви можете спитати, чому треба наполягати на чистоті? Чому просто не відкрити визначення списків, зробивши поле `tail`, а можливо і поле `head`, змінними? Недолік такого підходу в тому, що таким чином ви зробите програми значно більш крихкими. Зауважте, що конструювання списків за допомогою `::` повторно використовує `tail` конструйованого списку.

Так що коли ви пишете:
[source,scala]
----
val ys = 1 :: xs
val zs = 2 :: xs
----
хвости списків `ys` та `zs` поділяються; вони вказують на ту саму структуру даних. Це основа для ефективності; якщо список `xs` копіювався б кожного разу, коли ви додаєте новий елемент до нього, це було б значно повільніше. Оскільки спільне використання є поширеним, зміна елементів списку, якщо б це було можливо, було б досить небезпечним. Наприклад, беручи код вище, якщо ви бажали б вкоротити список `ys` до двох перших елементів, і записали б це так:
[source,scala]
----
ys.drop(2).tail = Nil // цього не можна робити в Scala!
----
ви б також вкоротили списки `zs` та `xs` в якості побічного ефекту.

Зрозуміло, що було б досить складно відстежити, що було змінено. Ось чому Scala обирає поширене поділення даних, та заборону на зміну списків. Клас `ListBuffer` все ще дозволяє вам будувати списки імперативно та інкрементально, якщо побажаєте. Але оскільки спискові буфери не є списками, типи, що містять змінні буфери та незмінні списки, тримаються окремо.

Дизайн Scala `List` та `ListBuffer` досить подібні до того, що зроблене в Java з парою класів, `String` та `StringBuffer`. Це не випадковість. В обох ситуаціях розробники бажали підтримувати чисті незмінні структури даних, але також провадити ефективний спосіб сконструювати ці структури інкрементально. Для Java і Scala рядків, `StringBuffer` (або в Java 5 `StringBuilder`) провадять шлях конструювання рядка інкрементально. Для списків Scala ви маєте вибір: ви можете або конструювати списки інкрементально, через додавання елементів до початку списку з використанням `::`, або ви використовуєте списковий буфер для додавання елементів в кінець. Який має перевагу залежить від ситуації. Звичайно, `::` гарно проявляє себе в рекурсивних алгоритмах, в стилі поділяй-та-володій. Спискові буфери часто використовуються в більш традиційному стилі на основі циклів.

22.5 Висновок
-------------
В цій главі ви бачили, як в Scala реалізовані списки. `List` є однією з найбільш тяжко використовуваних структур в Scala, і він має доопрацьовану реалізацію. Два субкласи `List`, `Nil` та `::`, обоє є кейс класами. Однак замість рекурсії по цій структурі, багато основних методів реалізовані з використанням `ListBuffer`. `ListBuffer`, в свою чергу, ретельно реалізований, так, щоб він міг ефективно будувати списки без розміщення додаткової пам'яті. Він зовні функціональний, але внутрішньо використовує змінність для прискорення загального випадку, коли буфер відкидаєть після виклику `toList`. Після вивчення всього цього, тепер ви знаєте класи списків ззовні та зсередини, і також ви вивчили один або два трюки реалізації.
 