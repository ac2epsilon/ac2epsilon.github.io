include::headers.adoc[]

Глава 16
--------

Робота зі списками
==================

Списки, можливо, є найбільш загально уживана структура даних в Scala програмах. Ця глава пояснює списки в деталях. Ми будемо презентувати багато загальних операцій, що можуть бути виконані на списках. Ми будемо також покривати деякі важливі принципи дизайну для програм, що роблять зі списками.

16.1 Спискові літерали
----------------------
Ви вже бачили списки в попередніх главах, так що ви знаєте, що список містить елементи  `'a'`, `'b'`, та `'c'` записується як `List('a', 'b', 'c')`. Ось деякі інші приклади:
[source,scala]
----
val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val diag3 =
  List(
    List(1, 0, 0),
    List(0, 1, 0),
    List(0, 0, 1)
  )
val empty = List()
----
Списки досить подібні до масивів, але є дві важливі відмінності. Перше, списки є незмінними, елементи списку не можуть бути змінені через присвоєння. Друге, списки мають рекурсивну структуру (тобто,  _зв'язаний список_),footnote:[Для графічного представлення структури `List`, дивіться Малюнок 22.2.], тоді як масиви пласкі.

16.2 Тип List
-------------
Як і масиви, списки є гомогенними: елементи списків всі мають той самий тип. Тип списку, що мають елементи типу `T`, записується `List[T]`. Наприклад, ось ті самі чотири списки з доданими явними списками:
[source,scala]
----
val fruit: List[String] = List("apples", "oranges", "pears")
val nums: List[Int] = List(1, 2, 3, 4)
val diag3: List[List[Int]] =
  List(
    List(1, 0, 0),
    List(0, 1, 0),
    List(0, 0, 1) 
  )
val empty: List[Nothing] = List()
----
Тип списку в Scala є ковариантним. Це означає, що для кожної пари типів `S` та `T`, якщо `S` є субтипом `T`, тоді `List[S]` є субтипом `List[T]`. Наприклад, `List[String]` є субтипом `List[Object]`. Це природно, оскільки кожний список рядків може також розглядатись і як список об'єктів.footnote:[Глава 19 дає більше деталей щодо коваріантності та інших типів варіантності.]

Зауважте, що порожній список має тип `List[Nothing]`. Ви бачили в Розділі 11.3, що `Nothing` є нижнім типом в ієрархії класів Scala. Це субтип кожного іншого типу Scala. Оскільки списки коваріантні, з цього слідує, що `List[Nothing]` є субтипом `List[T]` для любого типу `T`. Так що об'єкт порожнього списку, що має тип `List[Nothing]`, може також розглядатись як об'єкт кожного іншого типу списка в формі `List[T]`. Ось чому дозволяється писати код, подібний до наступного:
[source,scala]
----
// List() також є типом List[String]!
val xs: List[String] = List()
----
16.3 Конструювання списків
--------------------------
Всі списки побудовані з двох фундаментальних будівельних блоків, `Nil` та `::` (вимовляється `cons`). `Nil` представляє порожній список. Інфіксний оператор `::` виражає розширення списку зпереду. Тобто, `x :: xs` представляє список, чий перший елемент є `x`, за яким слідує (елементи) список `xs`. Так що попередній список значень також може бути визначений наступним чином:
[source,scala]
----
val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3 = (1 :: (0 :: (0 :: Nil))) ::
            (0 :: (1 :: (0 :: Nil))) ::
            (0 :: (0 :: (1 :: Nil))) :: Nil
val empty = Nil
----
Фактично, попередні визначення `fruit`, `nums`, `diag3`, та `empty` в термінах `List(...)` є тільки огортками, що розширюють ці визначення. Наприклад, `List(1, 2, 3)` створює `list1 :: (2 :: (3 :: Nil))`.

Оскільки вона завершується на дві крапки, операція `::` асоціюється зправа: `A :: B :: C` інтерпретується як `A :: (B :: C)`. Таким чином, ви можете відкинути дужки в попередніх визначеннях. Наприклад:
[source,scala]
----
val nums = 1 :: 2 :: 3 :: 4 :: Nil
----
еквівалентне до попереднього визначення `nums`.

16.4 Базові операції зі списками
--------------------------------
Всі операції зі списками можуть бути визначені в термінах наступних трьох:

`head` повертає перший елемент списку

`tail` повератає список, що складається з усіх елементів списку, крім першого

`isEmpty` повертає `true`, якщо список порожній

Ці операції визначені як методи класу `List`. Деякі приклади показані в Таблиці 16.1. Методи `head` та `tail` визначені тільки для не-порожніх списків. Коли вибираються для порожніх списків, вони закидають виключення:
[source,scala]
----
scala> Nil.head
java.util.NoSuchElementException: head of empty list
----
Як приклад того, як списки можуть оброблятись, розглянемо сортування елементів списку, що є числами, в порядку зростання. Один простий спосіб зробити це - сортування вставкою, що робить наступним чином: для сортування непорожнього списку `x :: xs`, сортується залишок `xs`, та перший елемент `x` вставляється в правильну позицію результата. Виражене як код Scala, алгоритм сортування вставкою виглядає так:
[source,scala]
----
def isort(xs: List[Int]): List[Int] =
  if (xs.isEmpty) Nil
  else insert(xs.head, isort(xs.tail))

def insert(x: Int, xs: List[Int]): List[Int] =
  if (xs.isEmpty || x <= xs.head) x :: xs
  else xs.head :: insert(x, xs.tail)
----
[caption="Таблиця 16.1 "]
.Базові операції списків
[cols="1,1",options="header"]
|===
^| Що таке ^| Що робить
|`empty.isEmpty`|повертає `true`
|`fruit.isEmpty`|повертає `false`
|`fruit.head`|повертає `"apples"`
|`fruit.tail.head`|повертає `"oranges"` 
|`diag3.head`|повертає `List(1, 0, 0)`
|===
16.5 Шаблони списків
--------------------
Списки також можуть бути розділені на частини з використанням порівнянь шаблонів. Шаблони списків відповідають один до однго з виразами списків. Ви можете або порівняти всі елементи списку з використанням шаблону в формі `List(...)`, або ви розбиваєте список на частини, використовуючи шаблон, скомпонований з оператора `::` та константи `Nil`.

Ось різновид першого типу шаблонів:
[source,scala]
----
scala> val List(a, b, c) = fruit
a: String = apples
b: String = oranges
c: String = pears
----
Шаблон `List(a, b, c)` співпадає зі списками довжини 3, та прив'язує три елементи до змінних шаблону, `a`, `b`, та `c`. Якщо ви не знаєте число елементів в списку заздалегідь, тоді краще замість цього порівнювати за допомогою `::`. Наприклад, шаблон `a :: b :: rest` співпадає зі списками довжини 2 або більше:

Щодо порівняння шаблонів списків
--------------------------------
Якщо ви розглядаєте можливі форми шаблонів, пояснених в Главі 15, ви можете винайти, що ні `List(...)` ані `::` не вигладають, як підходящі різновиди шаблонів, визначених там. Фактично, `List(...)` є примірником визначеного в бібліотеці шаблону екстрактора. Такі шаблони будуть обговорюватись в Главі 26. Шаблон `cons` `x :: xs` є особливим випадком шаблону інфіксної операції. Як вираз, інфіксна операція еквівалентна до виклику метода. Для шаблонів правила інші: в якості шаблона інфіксна операція, така, як `p op q` еквівалентна до `op(p, q)`. Тобто, інфіксний оператор `op` трактується як шаблон конструктора. Зокрема, шаблон `cons`, такий як `x :: xs`, трактується як `::(x, xs)`.

Це підказує, що має бути клас на ім'я `::`, що відповідає до конструктора шаблону. Звісно, такий клас існує — його ім'я `scala.::`, та це саме той клас, що будує непорожні списки. Так що `::` існує двічі в Scala, один раз як ім'я, класу в пакунку `scala`, і знову як метод в класі `List`. Ефект метода `::` є продукувати примірник класу `scala.::`. Ви знайдете більше деталей щодо того, як реалізований клас `List`, в Главі 22.
[source,scala]
----
scala> val a :: b :: rest = fruit
a: String = apples
b: String = oranges
rest: List[String] = List(pears)
----
Розбиття списків на частити за допомогою шаблонів є альтернативою до їх поділення за допомогою базових методів `head`, `tail`, та `isEmpty`. Наприклад, ось знову сортування вставкою, на цей раз написана за допомогою порівняння шаблонів:
[source,scala]
----
def isort(xs: List[Int]): List[Int] = xs match {
  case List() => List()
  case x :: xs1 => insert(x, isort(xs1))
}

def insert(x: Int, xs: List[Int]): List[Int] = xs match {
  case List() => List(x)
  case y :: ys => if (x <= y) x :: xs
                  else y :: insert(x, ys)
}
----
Часто порівняння шаблонів зі списками ясніше, ніж їх декомпозиція за допомогою методів, так що порівняння шаблонів має стати частиною вашого інструментарія обробки списків.

Це все що вам треба знати щодо списків в Scala, щоб використовувати їх коректно. Однак існує велика кількість методів, що захоплюють загальні шаблони операцій зі списками. Ці методи роблять програми обробки списків більш стислими, та часто яснішими. Наступні два розділи представляють найбільш важливі методи, визначені в класі `List`.

16.6 Методи першого порядка на класі List
-----------------------------------------
Цей розділ пояснює більшість методів першого порядка, визначених в класі `List`. Метод є першого порядку, якщо він не приймає жодних функцій як аргументів. Ми будемо також вводити деякі рекомендовані прийоми, щоб структурувати програми, що оперують на списках, використовуючи для цього два приклада.

Конкатенація двох списків
~~~~~~~~~~~~~~~~~~~~~~~~~
Операція, подібна до `::` є конкатенація списків, що записується як `:::`. На відміну від `::`, `:::` приймає два списка як операнди. Результатом `xs ::: ys` є новий список, що містить всі елементи `xs`,за яким слідують всі елементи `ys`.

Ось деякі приклади:
[source,scala]
----
scala> List(1, 2) ::: List(3, 4, 5)
res0: List[Int] = List(1, 2, 3, 4, 5)

scala> List() ::: List(1, 2, 3)
res1: List[Int] = List(1, 2, 3)

scala> List(1, 2, 3) ::: List(4)
res2: List[Int] = List(1, 2, 3, 4)
----
Як і `cons`, конкатенація списків асоціюється зправа. Такий вираз:
[source,scala]
----
xs ::: ys ::: zs
----
інтерпретується так:
[source,scala]
----
xs ::: (ys ::: zs)
----
Принцип "Розділяй та володій"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Конкатенація (`:::`) реалізована як метод в класі `List`. Також можливо реалізувати конкатенацію "вручну", використовуючи порівняння шаблонів для списків. Є повчальним спробувати зробити це самостійно, оскільки це показує загальний шлях реалізації алгоритмів з використанням списків. Перше, ми домовимось щодо сигнатури для метода конкатенації, який ми назвемо `append`. Щоб не дуже змішувати все докупи, будемо вважати, що `append` визначений за межами класу `List`, так що він прийматиме два списки, що будуть канкатеновані, як параметри. Ці два списки мають домовитись щодо типу їх елементів, але цей тип може бути довільним. Це може бути виражене через надання `append` параметру типа,footnote:[Параметр типу буде пояснений більш детально в Главі 19.], що представляє тип елемента двох вхідних списків:
[source,scala]
----
def append[T](xs: List[T], ys: List[T]): List[T]
----
Щоб розробити реалізацію `append`, слід пам'ятати принцип розробки "поділяй та володій" для програм з рекурсивними структурами даних, як списки. Багато алгоритмів над списками спочатку розділяють вхідний список на простіші випадки, використовуючи порівняння шаблонів. Це частина _роздліляй_ цього принципу. Потім вони конструюють результат для кожного `case`. Якщо результат є непорожній список, деякі з його частин можуть бути сконструйовані через рекурсивні виклики того самого алгоритму. Це частина _володій_ принципу.

Щоб застосувати цей принцип до реалізації метода `append`, перше запитання, що треба запитати, це який зі списків порівнювати. Це трохи тривіальніше в випадку `append`, ніж для багатьох інших методів, оскікльи є два вибори. Однак, наступна фаза "володіння" каже вам, що вам треба сконструювати список, що складається з усіх елементів обох вхідних списків. Оскільки списки сконструйовані з кінця в напрямку початку, `ys` може залишатись як є, тоді як `xs` буде треба розбити на частини на поставити перед `ys`. Таким чином, має сенс сконцентруватись на `xs`, як джерелі для порівняння шаблонів. Найбільш загальне порівняння шаблонів зі списками є просте розрізнення порожніх та непорожніх списків. Так що це дає наступний контур метода `append`:
[source,scala]
----
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List() => ???
    case x :: xs1 => ???
  }
----
Все що залишається, це заповнити два місця, відмічені `???`.footnote:[Метод `???`, що закидає `scala.NotImplementedError`, та має тип результата `Nothing`, може бути використаний як тимчасова реалізація впродовж розробки.] Перше таке місце є альтернатива, де вхідний список `xs` порожній. В цьому випадку конкатенація видає другий список:
[source,scala]
----
case List() => ys
----
Друге місце, залишене відкритим, є альтернатива, де вхідний список `xs` складається з деякого заголовка `x`, за яким слідує хвіст `xs1`. В цьому випадку результат також є непорожнім списком. Щоб сконструювати непорожній список, вам треба знати, якими має бути голова та хвіст цього списку. Ви знаєте, що перший елемент результуючого списку є `x`. Як щодо залишку елементів, вони можуть бути обчислені через додавання другого списку, `ys`, до залишку першого списку, `xs1`.

Це завершує дизайн, та дає таке:
[source,scala]
----
def append[T](xs: List[T], ys: List[T]): List[T] =
  xs match {
    case List() => ys
    case x :: xs1 => x :: append(xs1, ys)
  }
----
Обчислення другої альтернативи ілюструє частину "володій" принципа розділення та заволодіння: думайте спочатку, який контур бажаного виходу має бути, потім обчислюйте індивідуальні частини цього контура, використовуючи рекурсивні виклики алгоритма, коли це доцільно. Нарешті, сконструюйте вихід з ціх частин.

Отримання довжини списку: `length`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Метод `length` обчислює довжину списка.
[source,scala]
----
scala> List(1, 2, 3).length
res3: Int = 3
----
На списках, на відміну від масивів, `length` є відносно коштовною операцією. Він змушує подорожувати по цілому списку, щоб знайти кінець, і, таким чином, займає час, пропорційний до числу елементів в списку. Ось чому не є гарною ідеєю замінити тест, такий як `xs.isEmpty` на `xs.length == 0`. Результат двох тестів еквівалентний, але другий повільніший, зокрема якщо список `xs` довгий.

Доступ до кінця списку: `init` та `last`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ви вже знаєте базові операції, `head` та `tail`, що, відповідно, вибирає перший елемент списку, та залишок списку, крім першого елементу. Вони обоє мають операцію двійника: `last` повертає останній елемент (непорожнього) списку, тоді як `init` повертає список, що складається з усіх елементів, крім останнього:
[source,scala]
----
scala> val abcde = List('a', 'b', 'c', 'd', 'e')
abcde: List[Char] = List(a, b, c, d, e)

scala> abcde.last
res4: Char = e

scala> abcde.init
res5: List[Char] = List(a, b, c, d)
----
Як `head` та `tail`, ці методи закидають виключення, коли застосовуються до порожніх списків:
[source,scala]
----
scala> List().init
java.lang.UnsupportedOperationException: Nil.init
at scala.List.init(List.scala:544)
at ...

scala> List().last
java.util.NoSuchElementException: Nil.last
at scala.List.last(List.scala:563)at ...
----
На відміну від `head` та `tail`, які обоє виконуються за сталий час, `init` та `last` подорожують по цілому списку, щоб отримати свій результат. Як результат, вони займають час, пропорційний до довжини списку.

Є гарною ідеєю організувати ваші дані так, щоб більшість доступів приходились на початок списку, скоріше, ніж на останній елемент.

Реверс списку: `reverse`
~~~~~~~~~~~~~~~~~~~~~~~~
Якщо в деякій точці обчислень алгоритм вимагає частого доступу до кінця списку, іноді буває кращим спочатку реверсувати список, та потім робити з результатом. Ось як це робиться:
[source,scala]
----
scala> abcde.reverse
res6: List[Char] = List(e, d, c, b, a)
----
Як всі інші операції зі списками, `reverse` створює новий список, скоріше ніж змінювати той, з яким робить. Оскільки списки незмінні, така заміна все одно не була б можливою. Щоб перевірити це, перевірте, що оригінальне значення `abcde` незмінне після операції `reverse`:
[source,scala]
----
scala> abcde
res7: List[Char] = List(a, b, c, d, e)
----
Операції `reverse`, `init` та `last` задовільняють деяким законам, що може бути використане для міркувань щодо обчислень та для спрощення програм.

1. `reverse` є інверсією самого себе:
[source,scala]
----
xs.reverse.reverse _equals_ xs
----

2. `reverse` перетворює `init` на `tail`, та `last` на `head`, за винятком того, що елементи реверсовані:
[source,scala]
----
xs.reverse.init _equals_ xs.tail.reverse
xs.reverse.tail _equals_ xs.init.reverse
xs.reverse.head _equals_ xs.last
xs.reverse.last _equals_ xs.head
----
Реверс може бути реалізований з використанням конкатенації (`:::`), як наступний метод, `rev`:
[source,scala]
----
def rev[T](xs: List[T]): List[T] = xs match {
  case List() => xs
  case x :: xs1 => rev(xs1) ::: List(x)
}
----
Однак, цей метод менш ефективний, ніж дехто може сподіватись. Щоб вивчити складність `rev`, вважаючи, що список `xs` має довжину `n`. Зауважте, що існує `n` рекурсивних викликів до `rev`. Кожний виклик, крім останнього, включає конкатенацію списків. Конкатенація списків, `xs ::: ys`, займає час, пропорційний до довжини свого першого аргументу, `xs`. Таким чином, загальна складність `rev` є:
[source,scala]
----
n + (n - 1) + ... + 1 = (1 + n) * n / 2
----
Іншими словами, складність `rev` є квадратичною до довжини свого вхідного аргументу. Це невтішно, порівнюючи до реверсу змінного зв'язанного списку, що має лінійну складність. Однак поточна реалізація `rev` не є кращою можливою реалізацією. В прикладі, що починається тут, ви побачите, як прискорити її.

Префікси та суфікси: `drop`, `take`, `splitAt`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операції `drop` та `take` узагальнують `tail` та `init` в тому, що вони повертають довільні префікси або суфікси списку. Вираз `xs take n` повертає перші `n` елементів списку `xs`. Якщо `n` більше, ніж `xs.length`, повертається цілий список `xs`. Операція `xs drop n` повертає всі елементи списку `xs`, за винятком перших `n`. Якщо `n` більше, ніж `xs.length`, повертається порожній список.

Операція `splitAt` розділяє список по наданому індексу, повертаючи пару з двох списків.footnote:[Як зазначалось в Розділі 10.12, термін пара є неформальним ім'ям для `Tuple2`.] Вона визначається рівністю:
[source,scala]
----
xs splitAt n _equals_ (xs take n, xs drop n)
----
Однак `splitAt` уникає подвійної подорожі по списку `xs`. Ось деякі приклади ціх трьох методів:
[source,scala]
----
scala> abcde take 2
res8: List[Char] = List(a, b)

scala> abcde drop 2
res9: List[Char] = List(c, d, e)

scala> abcde splitAt 2
res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))
----
Вибір елементів: `apply` та `indices`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Вибір довільних елементів підтримується через метод `apply`; однак це менш поширена операція для списків, ніж для масивів.
[source,scala]
----
scala> abcde apply 2 // рідкість в Scala
res11: Char = c
----
Як і для інших типів, `apply` вставляється неявно, коли об'єкт з'являється в функціональній позиції в виклику метода. Так що рядок вище може бути скорочено:
[source,scala]
----
scala> abcde(2) // рідкість в Scala
res12: Char = c
----
Одна з причин, чому вибір довільного елемента є менш популярним для списків, ніж для масивів, в тому, що `xs(n)` займає час, пропорційний до індексу `n`. Фактично, `apply` просто визначена через комбінацію `drop` та `head`:
[source,scala]
----
xs apply n _equals_ (xs drop n).head
----
Це визначення також робить зрозумілим, що індекси списків знаходяться в диапазоні від 0 до довжини списку мінус один, так само, як для масивів. Метод `indices` повертає список, що складається з усіх валідних індексів для даного списку:
[source,scala]
----
scala> abcde.indices
res13: scala.collection.immutable.Range= Range(0, 1, 2, 3, 4)
----
Зплющення списка списків: `flatten`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Метод `flatten` приймає список списків, та зплющує його до одного списку:
[source,scala]
----
scala> List(List(1, 2), List(3), List(), List(4, 5)).flatten
res14: List[Int] = List(1, 2, 3, 4, 5)

scala> fruit.map(_.toCharArray).flatten
res15: List[Char] = List(a, p, p, l, e, s, o, r, a, n, g, e,
s, p, e, a, r, s)
----
Він може бути застосований тільки до списків, всі елементи яких є списками. Спроба зплющити любі інші списки буде давати помилку компіляції:
[source,scala]
----
scala> List(1, 2, 3).flatten
<console>:8: error: No implicit view available from Int =>
scala.collection.GenTraversableOnce[B].
List(1, 2, 3).flatten
^
----
Стиснення списків: `zip` та `unzip`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операція `zip` приймає два списки, та формує список пар:
[source,scala]
----
scala> abcde.indices zip abcde
res17: scala.collection.immutable.IndexedSeq[(Int, Char)] =
    Vector((0,a), (1,b), (2,c), (3,d), (4,e))
----
Якщо два списки мають різні довжини, любий неспівпавший елемент відкидається:
[source,scala]
----
scala> val zipped = abcde zip List(1, 2, 3)
zipped: List[(Char, Int)] = List((a,1), (b,2), (c,3))
----
Корисний особливий випадок є `zip` списку з його індексом. Це робиться більш ефективно за допомогою метода `zipWithIndex`, що парує кожний елемент списку з позицією, де він з'являється в списку.
[source,scala]
----
scala> abcde.zipWithIndex
res18: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3),
    (e,4))
----
Любий список таплів також може бути змінений назад, та таплу списків, використовуючи метод `unzip`:
[source,scala]
----
scala> zipped.unzip
res19: (List[Char], List[Int])
  = (List(a, b, c),List(1, 2, 3))
----  
Методи `zip` та `unzip` провадять один шлях для обробки декількох списків разом. Дивіться Розділ 16.9 для більш стислого шляху робити це.

Відображення списків: `toString` та `mkString`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операція `toString` повертає канонічну рядкову репрезентацію списку:
[source,scala]
----
scala> abcde.toString
res20: String = List(a, b, c, d, e)
----
Якщо ви бажаєте іншу репрезентацію, ви можете використати метод `mkString`. Операція `xs mkString (pre, sep, post)` включає чотири операнди: список `xs`, що буде відображений, рядок `prefix`, що буде відображений перед усіма елементами, рядок роздільника `sep`, що буде відображений між послідовними елементами, та рядок `postfix`, що буде відображений в кінці.

Результатом операції є рядок:
[source,scala]
----
pre + xs(0) + sep + ...+ sep + xs(xs.length - 1) + post
----
Метод `mkString` має два перевантажені варіанти, що дозволяють вам відкинути деякі або всі його пргументи. Перший вариант приймає тільки рядок роздільника:
[source,scala]
----
xs mkString sep _equals_ xs mkString ("", sep, "")
----
Другий варіант дозволяє вам оминути всі аргументи:
[source,scala]
----
xs.mkString _equals_ xs mkString ""
----
Ось деякі приклади:
[source,scala]
----
scala> abcde mkString ("[", ",", "]")
res21: String = [a,b,c,d,e]

scala> abcde mkString ""
res22: String = abcde

scala> abcde.mkString
res23: String = abcde

scala> abcde mkString ("List(", ", ", ")")
res24: String = List(a, b, c, d, e)
----
Також є варіанти методів `mkString`, названі `addString`, що додають сконструйований рядок до об'єкту `StringBuilder`,footnote:[Це клас `scala.StringBuilder`, не `java.lang.StringBuilder`.], скоріше ніж повертати результат:
[source,scala]
----
scala> val buf = new StringBuilder
buf: StringBuilder =

scala> abcde addString (buf, "(", ";", ")")
res25: StringBuilder = (a;b;c;d;e)
----
Методи `mkString` та `addString` наслідуються від супертрейта `List`, трейта `Traversable`, так що вони також застосовуються до всіх інших колекцій.

Перетворення списків: `iterator`, `toArray`, `copyToArray`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Щоб перетворити дані між пласким світом масиву, та рекурсивним світом списків, ви можете використовувати метод `toArray` в класі `List`, та `toList` в класі `Array`:
[source,scala]
----
scala> val arr = abcde.toArray
arr: Array[Char] = Array(a, b, c, d, e)

scala> arr.toList
res26: List[Char] = List(a, b, c, d, e)
----
Також є метод `copyToArray`, що копіює список елементів в послідовні позиції в деякому масиві призначення. Операція:
[source,scala]
----
xs copyToArray (arr, start)
----
копіює всі елементи списку `xs` до масива `arr`, починаючи з позиції `start`. Ви маєте переконатись, що масив призначення `arr` досить довгий, щоб містити список повністю. Ось приклад:
[source,scala]
----
scala> val arr2 = new Array[Int](10)
arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

scala> List(1, 2, 3) copyToArray (arr2, 3)

scala> arr2
res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)
----
Нарешті, якщо вам треба отримати доступ до елементів списку через ітератор, ви можете використовувати метод `iterator`:
[source,scala]
----
scala> val it = abcde.iterator
it: Iterator[Char] = non-empty iterator

scala> it.next
res29: Char = a

scala> it.next
res30: Char = b
----
Приклад: сортування злиттям
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Сортування вставкою, презентоване раніше, є стислим для написання, але не дуже ефективним. Його середня складність пропорційна квадрату довжини вхідного списку. Більш ефективний алгоритм є сортування злиттям.

Швидкий шлях
------------
Цей приклад провадить іншу ілюстрацію принципу розділяй та володій, карування, а також корисну дискусію по алгоритмічній складності. Якщо ви бажаєте рухатись трохи швидше при першому проходженні цієї книги, ви можете безпечно пропустити Розділ 16.7.

Сортування злиттям робить наступним чином: зпершу, якщо список має нуль або один елемент, він вже впорядкований, так що список може бути повернений без змін. Інши списки поділяються на два суб-списки, кожний містить близько половини елементів оригінального списку. Кожний субсписок впорядковується рекурсивним викликом, та отримані два відсортовані списки поєднуються операцією злиття.

Для загальної реалізації сортування злиттям ви бажаєте залишити відкритим тип елементів списку, що будуть сортуватись, та функцію, що буде використана для порівняння елементів. Ви отримаєте функцію максімальної загальності, передавши ці два елементи як параметри. Це призводить до реалізації, показаній в Лістингу 16.1.
[source,scala]
----
def msort[T](less: (T, T) => Boolean)
    (xs: List[T]): List[T] = {

  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) => ys
      case (_, Nil) => xs
      case (x :: xs1, y :: ys1) =>
        if (less(x, y)) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }

  val n = xs.length / 2
  if (n == 0) xs
  else {
    val (ys, zs) = xs splitAt n
    merge(msort(less)(ys), msort(less)(zs))
  }
}
----
Лістинг 16.1 - Функція сортування злиттям для List.

Складність `msort` має порядок (_n log(n)_), де `n` є довжина вхідного списку. Щоб побачити чому, зауважте, що розділення списку на два та злиття двох відсортованих списків, кожне займає час, пропорційний до довжини списків-аргументів. Кожний рекурсивний виклик зменшує навпіл число елементів на вході, так що відбудеться  близько `log(n)` послідовних рекурсивних викликів, доки буде досягнуто базового випадку зі списками довжиною 1. Однак для довших списків кожний виклик відгалужує два інші виклики. Додаючи все разом, ми отримаємо, що на кожному рівні викликів _log(n)_ кожний елемент оригінальних списків прийме участь в одній операції розділення, та в одній операції злиття.

Таким чином, кожний рівень викликів має загальну вартість, пропорційну до `n`. Оскільки загалом _log(n)_ рівнів виклику, ми отримаємо загальну вартість, пропорційну до _n log(n)_. Ця вартість не залежить від початкового розподілення елементів в списку, так що найгірша вартість є такою самою, що і середня вартість. Ця властивість робить сортування злиттям привабливим алгоритмом для сортування списків.

Ось приклад того, як використовується `msort`:
[source,scala]
----
scala> msort((x: Int, y: Int) => x < y)(List(5, 7, 1, 3))
res31: List[Int] = List(1, 3, 5, 7)
----
Функція `msort` є класичним прикладом концепції карування, обговореної в Розділі 9.3. Карування робить простим спеціалізувати функцію для певних функцій порівняння. Ось приклад:
[source,scala]
----
scala> val intSort = msort((x: Int, y: Int) => x < y) _
intSort: List[Int] => List[Int] = <function1>
----
Змінна `intSort` посилається на функцію, що приймає список цілих, та сортує їх в числовому порядку. Як описане в Розділі 8.6, підкреслення стоїть замість відсутнього списку аргументів. В цьому випадку відсутній аргумент це список, що має бути впорядкований. Як інший приклад, ось як ви можете визначити функцію, що сортує  список цілих в зворотньому числовому порядку:
[source,scala]
----
scala> val reverseIntSort = msort((x: Int, y: Int) => x > y) _
reverseIntSort: (List[Int]) => List[Int] = <function>
----
Оскільки ви вже провадите функцію порівняння через карування, тепер вам треба провадити список для сортування, коли ви викликаєте функції `intSort` або `reverseIntSort`. Ось деякі приклади:
[source,scala]
----
scala> val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
mixedInts: List[Int] = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)

scala> intSort(mixedInts)
res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

scala> reverseIntSort(mixedInts)
res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
----
16.7 Методи вищих порядків класу List
-------------------------------------
Багато операцій зі списками мають подібну структуру. Декілька шаблонів з'являються раз за разом. Деякі приклади: трансформація кожного елементу списка в деякий спосіб, перевірка, чи властивість дотримується для всіх елементів в списку, виділення зі списку елементів, що задовільняють певному критерію, або комбінування елементів списку з використанням деякого оператора. В Java такі шаблони будуть зазвичай виражені ідіоматичними комбінаціями циклів `for` або `while`. В Scala вони можуть бути виражені більш стисло та напряму, використовуючи оператори вищих порядків,footnote:[Під операторами вищих порядків ми розуміємо функції вищих порядків, використані в операторній нотації. Як зазначено в Розділі 9.1, функція є "вищого порядку", якщо вона сприймає одну або більше інших функцій в якості параметрів.] що реалізовані як методи в класі `List`. Ці оператори вищого порядку обговорюються в цьому розділі.

Відзеркалення списків: `map`, `flatMap`, `foreach`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операція `xs map f` бере як операнди список `xs` типу `List[T]`, та функцію `f` типу `T => U`. Вона повертає список, що утворюється застосуванням функції `f` до кожного елементу в `xs`. Наприклад:
[source,scala]
----
scala> List(1, 2, 3) map (_ + 1)
res32: List[Int] = List(2, 3, 4)

scala> val words = List("the", "quick", "brown", "fox")
words: List[String] = List(the, quick, brown, fox)

scala> words map (_.length)
res33: List[Int] = List(3, 5, 5, 3)

scala> words map (_.toList.reverse.mkString)
res34: List[String] = List(eht, kciuq, nworb, xof)
----
Оператор `flatMap` подібний до `map`, але він приймає функцію, що повертає список елементів в якості свого правого операнда. Він застосовує функцію до кожного елемена списку, та повертає конкатенацію всіх результатів функції. Різниця між `map` та `flatMap` проілюстрована в наступному прикладі:
[source,scala]
----
scala> words map (_.toList)
res35: List[List[Char]] = List(List(t, h, e), List(q, u, i,
c, k), List(b, r, o, w, n), List(f, o, x))

scala> words flatMap (_.toList)
res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w,
n, f, o, x)
----
Ви бачите, що коли `map` повертає список зі списків, `flatMap` повертає єдиний список, в якому всі елементи списку конкатеновані.

Відмінність та взаємодія між `map` та `flatMap` також продемонстрована в наступному виразі, що конструює список з усіх пар `(i, j)`, таких що `1 ≤ j < i < 5`:
[source,scala]
----
scala> List.range(1, 5) flatMap (
  i => List.range(1, i) map (j => (i, j))
)
res37: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),
(4,2), (4,3))
----
`List.range` є допоміжний метод, що створює список з усіх цілих в деякому диапазоні. Він використовується двічи в цьому прикладі: один раз для генерації списку цілих від `1` (включно) до `5` (виключно), та другий раз для генерації списку цілих від `1` до `i`, для кожного значення `i`, взятого з першого списку. `map` в цьому виразі генерує список таплів `(i, j)`, де `j < i`. Зовнішній `flatMap` в цьому прикладі генерую цей список для кожного `i` між `1` та `5`, та потім конкатенує всі результати. Альтернативно, той самий список може бути сконструйований за допомогою виразу `for`:
[source,scala]
----
for (i <- List.range(1, 5); j <- List.range(1, i)) yield (i, j)
----
Ви вивчите більше щодо взаємодії між виразами `for` та операціями списків в Главі 23.

Третя `map`-подібна операція є `foreach`. Однак на відміну від `map` та `flatMap`, `foreach` приймає процедуру (функцію, тип якої `Unit`) в якості правого операнда. Він просто застосовує процедуру до кожного елементу списку. Результат самої операції знову `Unit`; список результатів не збирається. Як приклад, ось стислий спосіб підсумувати всі числа в списку:
[source,scala]
----
scala> var sum = 0
sum: Int = 0

scala> List(1, 2, 3, 4, 5) foreach (sum += _)

scala> sum
res39: Int = 15
----
=== Фільтрування списків: `filter`, `partition`, `find`, `takeWhile`, `dropWhile`, `span`

Операця `xs filter p` приймає як операнди список `xs` типу `List[T]`, та функцію предикат `pof` типу `T => Boolean`. Вона видає список всіх елементів `x` в `xs`, для яких `p(x)` є `true`. Наприклад:
[source,scala]
----
scala> List(1, 2, 3, 4, 5) filter (_ % 2 == 0)
res40: List[Int] = List(2, 4)

scala> words filter (_.length == 3)
res41: List[String] = List(the, fox)
----
Метод `partition` подібна до `filter`, але повертає пару списків. Один список містить всі елементи, для яких предикат є `true`, доки інший містить всі елементи, для яких предикат є `false`. Це визначено через еквівалентність:
[source,scala]
----
xs partition p _equals_ (xs filter p, xs filter (!p(_)))
----
Ось приклад:
[source,scala]
----
scala> List(1, 2, 3, 4, 5) partition (_ % 2 == 0)
res42: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))
----
Метод `find` також подібний до `filter`, але він повертає перший елемент, що задовільняє наданому предикату, скоріше ніж всі такі елементи. Операція `xs find p` приймає список `xs` та предикат `ep` як операнди. Він повертає опціональне значення. Якщо існує елемент `x` в `xs`, для якого `p(x)` є `true`, повертається `Some(x)`. Інакше `p` є `false` для всіх елементів, та повертається `None`. Ось деякі приклади:
[source,scala]
----
scala> List(1, 2, 3, 4, 5) find (_ % 2 == 0)
res43: Option[Int] = Some(2)

scala> List(1, 2, 3, 4, 5) find (_ <= 0)
res44: Option[Int] = None
----
Оператори `takeWhile` та `dropWhile` також приймають предикат як свій правий операнд. Операція `xs takeWhile p` бере найдовший префікс списку `xs`, такий що для кожного елементу в префіксі задовільняється `p`. Аналогічно, операція `xs dropWhile p` видаляє найдовший префікс зі списку `xs`, такий, що для кожного елементу в префіксі задовільняється `p`. Ось деякі приклади:
[source,scala]
----
scala> List(1, 2, 3, -4, 5) takeWhile (_ > 0)
res45: List[Int] = List(1, 2, 3)

scala> words dropWhile (_ startsWith "t")
res46: List[String] = List(quick, brown, fox)
----
Метод `span` комбінує `takeWhile` та `dropWhile` в одній операції, так само, як `splitAt` комбінує `take` та `drop`. Він повертає пару з двох списків, визначених еквівалентістю:
[source,scala]
----
xs span p _equals_ (xs takeWhile p, xs dropWhile p)
----
Як і `splitAt`, `span` уникає подвійного подорожування списком `xs`:
[source,scala]
----
scala> List(1, 2, 3, -4, 5) span (_ > 0)
res47: (List[Int], List[Int]) = (List(1, 2, 3),List(-4, 5))
----
Предикати на списках: `forall` та `exists`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операція `xs forall p` приймає як аргументи список `xs` та предикат `p`. Її результат є `true`, якщо всі елементи в списку задовільняють `p`. Відповідно, операція `xs exists p` повертає `true`, якщо існує елемент в `xs`, що задовільняє предикату `p`. Наприклад, щоб з'ясувати, чи матриця, представлена як список списків, має рядок з тільки нульовими елементами:
[source,scala]
----
scala> def hasZeroRow(m: List[List[Int]]) =
m exists (row => row forall (_ == 0))
hasZeroRow: (m: List[List[Int]])Boolean

scala> hasZeroRow(diag3)
res48: Boolean = false
----
Згортання списків: `/:` та `:\`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Інший загальний різновид операцій комбінують елементи списку за допомогою деякого оператору. Наприклад:
[source,scala]
----
sum(List(a, b, c)) _equals_ 0 + a + b + c
----
Це спеціальний примірник операції згортання:
[source,scala]
----
scala> def sum(xs: List[Int]): Int = (0 /: xs) (_ + _)
sum: (xs: List[Int])Int
----
Подібно до цього:
[source,scala]
----
product(List(a, b, c)) _equals_ 1 * a * b * c
----
є особливим примірником цього оператора:
[source,scala]
----
scala> def product(xs: List[Int]): Int = (1 /: xs) (_ * _)
product: (xs: List[Int])Int
----
Операція лівого згортання `(z /: xs) (op)` включає три об'єкти: початкове значення `z`, список `xs`, та двомісну операцію `op`. Результат згортання є `op`, застосований між послідовними елементами списку з префіксом `z`.

Наприклад:
[source,scala]
----
(z /: List(a, b, c)) (op) _equals_ op(op(op(z, a), b), c)
----
Або графічно:

Ось інший приклад, що ілючтрує, як використовується `/:`. Щоб конкатенувати всі слова в списку рядків з проміжками між ними та напочатку, ви можете записати таке:
[source,scala]
----
scala> ("" /: words) (_ + " " + _)
res49: String = " the quick brown fox"
----
Це дає зайвий проміжок на початку. Щоб видалити цей проміжок ви можете використати невелику варіацію:
[source,scala]
----
scala> (words.head /: words.tail) (_ + " " + _)
res50: String = the quick brown fox
----
Оператор `/:` продукує ліво-сторонні дерева операцій (його синтаксис з косою, що підіймається по ходу має бути відображенням цього). Оператор має `:\` як аналог, що продукує право-сторонні дерева. Наприклад:
[source,scala]
----
(List(a, b, c) :\ z) (op) _equals_ op(a, op(b, op(c, z)))
----
Або графічно:

Оператор `:\` промовляється як праве згортання. Він включає ті самі три операнди що і ліве згортання, але перші два ідуть в зворотньому порядку: перший операнд є список для згортання, другий є початковим значенням.

Для асоціативних операцій праве і ліве згортання еквівалентні, але може бути різниця в ефективності. Для приклада розгляньте операцію, відповідну до метода `flatten`, що конкатенує всі елементи в списку списків. Це може бути реалізоване за допомогою або лівого, або правого згортання:
[source,scala]
----
def flattenLeft[T](xss: List[List[T]]) =
  (List[T]() /: xss) (_ ::: _)

def flattenRight[T](xss: List[List[T]]) =
  (xss :~List[T]()) (_ ::: _)
----
Оскікльи конкатенація списку `xs ::: ys` займає час, пропорційний до свого першого елемента `xs`, реалізація в термінах правого згортання в `flattenRight` більш ефективна, ніж реалізація лівого згортання в `flattenLeft`. Проблема в тому, що `flattenLeft(xss)` копіює перший елемент списку `xss.head` `n-1` разів, де `n` є довжина списку `xss`.

Зауважте, що обоє версії `flatten` потребують анотацію типу на порожніх списках, що є початковим значенням згортання. Це через обмеженість виводу типів в Scala, що відмовляється виводити коректний тип списків автоматично. Якщо ви приберете анотацію, ви отримаєте наступне:
[source,scala]
----
scala> def flattenRight[T](xss: List[List[T]]) =
           (xss :~List()) (_ ::: _)
<console>:8: error: type mismatch;
found   : List[T]
required: List[Nothing]
           (xss :~List()) (_ ::: _)
                              ^
----
Щоб з'ясувати, чому вивід типів не здолав ситуацію, вам треба знати щодо типів методів `fold`, та як вони реалізовані. Більше про це в Розділі 16.10. Нарешті, хоча оператори `/:` та `:\` мають перевагу в тому, що напрямок косої нагадує графічне зображення відповідних ліво- та право-сторонніх дерев, та асоциативність символа двокрапки покладає початкове значення в ту саму позицію в виразі, що і в дереві, дехто може винайти результуючий код недостатньо інтуітивним. Якщо вам подобається, ви можете використовувати замість цього методи `foldLeft` та `foldRight`, що також визначені в класі `List`.

Приклад: реверс `List` з використанням `fold`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Раніше в цій главі ви бачили реалізацію метода `reverse`, названу `rev`, чий час виконання був квадратичним відносно довжини списку, який він обертав. Ось інша реалізація реверсу, що має лінійну ціну. Ідея полягає в використанні лівого згортання, базуючись на наступній схемі:
[source,scala]
----
def reverseLeft[T](xs: List[T]) = (startvalue /: xs)(operation)
----
Що залишилось, це заповнити частини _startvalue_ та _operation_. Фактично, ви можете спробувати вгадати ці частини з деяких простих прикладів. Щоб вивести коректне значення для `startvalue`, ви можете почати з найменьшим можливим списком, `List()`, та рахувати так:
[source,scala]
----
List() _equals_ (за властивостями reverseLeft) 

reverseLeft(List()) _equals_ (за шаблоном reverseLeft)

(startvalue /: List())(operation) _equals_ (за визначенням /:)

startvalue
----
Таким чином, _startvalue_ має бути `List()`. Щоб вивести другий операнд, ви можете взяти наступний найменььший список як приклад. Ви вже знаєте, що_startvalue_ є List(), так що ви можете рахувати так:
[source,scala]
----
List(x) _equals_ (за властивостями  reverseLeft)

reverseLeft(List(x)) _equals_ (за шаблоном reverseLeft, з startvalue = List())

(List() /: List(x)) (operation) _equals_ (за визначенням /:)

operation(List(), x)
----
Таким чином, _operation_ `(List(), x)` еквівалентне `List(x)`, що також може бути записане як `x :: List()`. Це підказує взяти за операцію оператор `::` з переставленими операндами. (Ця операція іноді називається `snoc`, з посиланням на `::`, що називається `cons`.) Ми підходимо до наступної реалізації для `reverseLeft`:
[source,scala]
----
def reverseLeft[T](xs: List[T]) =
  (List[T]() /: xs) {(ys, y) => y :: ys}
----
І знову, анотація типу в `List[T]()` є необхідною, щоб вивід типів почав робити. Якщо ви аналізуєте складність `reverseLeft`, ви винайдете, що він застосовує операцію сталого часу (`snoc`) `n` раз, де `n` є довжиною списка аргумента. Таким чином, складність `reverseLeft` є лінійною.

Сортування списків: `sortWith`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Операція `xs sortWith before`, де `xs` є списком, а `before` функцією, що може використовуватись для порівняння двох елементів, сортує елементи списку `xs`. Вираз `x before y` повинен повертати `true`, якщо `x` повинен іти перед `y` в бажаному впорядкуванні. Наприклад:
[source,scala]
----
scala> List(1, -3, 4, 2, 6) sortWith (_ < _)
res51: List[Int] = List(-3, 1, 2, 4, 6)

scala> words sortWith (_.length > _.length)
res52: List[String] = List(quick, brown, the, fox)
----
Зауважте, що `sortWith` виконує сортування злиттям, подібне до алгоритму `msort`, показаному в останньому розділі. Але `sortWith` є методом класу `List`, тоді як `msort` визначений за межами списків.

16.8 Методи об'єкта List
------------------------
Досі всі операції, що ви бачили в цій главі, реалізовані як методи класу `List`, так що ви викликаєте їх на окремих об'єктах списків. Також є декілька методів в глобально досяжному об'єкті `scala.List`, що є об'єктом компанйоном класу `List`. Деякі з ціх операцій є методами фабрик, що створюють списки. Інші є операціями, що роблять зі списками деякої специфічної форми. Обоє типи методів будуть представлені в цьому розділі.

Створення списків зі своїх елементів: `List.apply`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ви вже бачили при нагоді літерали списків, такі як `List(1, 2, 3)`. Немає нічого особливого щодо їх синтаксису. Літерал як `List(1, 2, 3)` є простим застосуванням об'єкта `List` до елементів `1, 2, 3`. Тобто, це еквівалентно до `List.apply(1, 2, 3)`:
[source,scala]
----
scala> List.apply(1, 2, 3)
res53: List[Int] = List(1, 2, 3)
----
Створення диапазона цілих: `List.range`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Метод `range`, що ви мимохідь бачили раніше в дискусії про `map` та `flatmap`, створює список, що відповідає диапазону чисел. Його найпростіша форма є `List.range(from, until)`, що створює список з усіх чисел, що починається з `from`, та іде до `until` мінус один. Так що кінцеве значення, `until`, не формує частину диапазону.

Також існує версія `range`, що приймає значення `step` як третій параметр. Ця операція буде давати списко елементів, що відстоять один від одного на відстані `step`. Значення `step` може бути додатнім або від'ємним:
[source,scala]
----
scala> List.range(1, 5)
res54: List[Int] = List(1, 2, 3, 4)

scala> List.range(1, 9, 2)
res55: List[Int] = List(1, 3, 5, 7)

scala> List.range(9, 1, -3)
res56: List[Int] = List(9, 6, 3)
----
Створення уніформних списків: `List.fill`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Метод `fill` створює список, що складається з нуля або більше копій того самого елемента. Він приймає два параметри: довжину створюваного списку, та елемент, що треба повторити. Кожний параметр наданий як окремий список:
[source,scala]
----
scala> List.fill(5)('a')
res57: List[Char] = List(a, a, a, a, a)

scala> List.fill(3)("hello")
res58: List[String] = List(hello, hello, hello)
----
Якщо в `fill` надати більше ніж два аргументи, тоді він бути створювати багато-вимірні списки. Тобто він буде створювати списки списків, спискі списків списків, і так далі. Додаткові аргументи ідуть в першому списку аргументів.
[source,scala]
----
scala> List.fill(2, 3)('b')
res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))
----
Функція табуляції: `List.tabulate`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Метод `tabulate` створює список, чиї елементи обчислені згідно наданої функції. Її аргументи такі самі, як для `List.fill`: перший аргумент `list`надає розмірність створюваного списку, та другий описує елементи списку. Єдина відміність в тому, що замість фіксованих елементів вони обчислюються функцією:
[source,scala]
----
scala> val squares = List.tabulate(5)(n => n * n)
squares: List[Int] = List(0, 1, 4, 9, 16)

scala> val multiplication = List.tabulate(5,5)(_ * _)
multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
    List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
    List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))
----
Конкатенація декількох списків: `List.concat`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Метод `concat` конкатенує елементи декількох списків. Списки, що будуть конкатеновані, надаються як прямі аргументи до `concat`:
[source,scala]
----
scala> List.concat(List('a', 'b'), List('c'))
res60: List[Char] = List(a, b, c)

scala> List.concat(List(), List('b'), List('c'))
res61: List[Char] = List(b, c)

scala> List.concat()
res62: List[Nothing] = List()
----
16.9 Обробка декількох списків разом
------------------------------------
Метод `zipped` на таплах узагальнює декілька загальних операцій для роботи з декількома списками замість одного. Одна така операція є `map`. Метод `map` для двох з'єднаних списків відображує пари елементів, скоріше ніж окремі елементи. Одна пара для перших елементів кожного списку, інша пара для другого елементу кожного списку, і так далі — так багато пар, що і довжина списків. Ось приклад його використання:
[source,scala]
----
scala> (List(10, 20), List(3, 4, 5)).zipped.map(_ * _)
res63: List[Int] = List(30, 80)
----
Зауважте, що третій елемент другого списку відкидається. Метод `zipped` поєднує тільки стільки елементів, скільки з'являється в усіх списках одночасно. Любі додаткові елементи в кінці відкидаються.

Існують також `zipped` аналоги для `exists` та `forall`. Вони подібні до версій з одним списком для ціх методів, за винятком, що вони оперують на елементах з декількох списків замість одного:
[source,scala]
----
scala> (List("abc", "de"), List(3, 2)).zipped.
        forall(_.length == _)
res64: Boolean = true

scala> (List("abc", "de"), List(3, 2)).zipped.
        exists(_.length != _)
res65: Boolean = false
----
Швидкий шлях
------------
В настуному (і заключному) розділі цієї глави ми зробимо огляд алгоритму виводу типів Scala. Якщо ви не зацікавлені в таких деталях прямо зараз, ви можете пропустити цілий розділ, та перейти прямо до підсумків.

16.10 Розуміння алгоритма виводу типів Scala
--------------------------------------------
Одна відмінність між попереднім використанням `sortWith` та `msort` стосується допустимих синтаксичних форм функції порівняння.

Порівняйте:
[source,scala]
----
scala> msort((x: Char, y: Char) => x > y)(abcde)
res66: List[Char] = List(e, d, c, b, a)
----
з:
[source,scala]
----
scala> abcde sortWith (_ > _)
res67: List[Char] = List(e, d, c, b, a)
----
Два виразу еквівалентні, але перший використовує довшу форму функції порівняння, з іменованими параметрами та явними типами. Другий використовує стислу форму, `(_ > _)`, де іменовані параметри замінені на підкреслення. Звичайно, ви також можете використовувати першу, довшу форму порівняння в `sortWith`.

Однак коротша форма не може бути використана з `msort`.
[source,scala]
----
scala> msort(_ > _)(abcde)
<console>:12: error: missing parameter type for expanded
function ((x$1, x$2) => x$1.$greater(x$2))
      msort(_ > _)(abcde)
            ^
----
Щоб зрозуміти чому, вам треба знати деякі деталі алгоритму виводу типів в Scala. Виведення типів в Scala базується на потоці. В застосуванні методу `m(args)`, вивід типів спершу перевіряє, чи метод `m` має відомий тип. Якщо це так, цей тип використовується для виведення очікуваних типів аргументів. Наприклад, в `abcde.sortWith(_ > _)`, тип `abcde` є `List[Char]`. Таким чином,  `sortWith` відомий як метод, що приймає аргумент типу `(Char, Char) => Boolean`, та продукує результат типу `List[Char]`. Оскільки параметри типу аргументів функції відомі, їх не треба записувати явно. Маючи те, що відомо про `sortWith`, вивід може здогадатись, що `(_ > _)` має розширюватись до `((x: Char, y: Char) => x > y)`, що `x` та `y` є деякими довільними новими іменами.

Тепер розглянемо другий випадок, `msort(_ > _)(abcde)`. Тип `msort` є карований, поліморфний тип методу, що приймає аргумент типу `(T, T) => Boolean` до функції від `List[T]` до `List[T]`, де `T` є досі невідомий тип. Метод `msort` потребує бути створений з параметром типу, перед тим як він може бути застосований до його аргументів.

Оскільки точний тип примірника `msort` в застосуванні досі не відома, він не може бути використаний для виведення типу його першого аргументу. Вивід типу змінює свою стратегію в цьому випадку; він спочатку перевіряє аргументи методу, щоб визначити відповідний тип примірника метода. Однак, коли він отримує завдання перевірити тип скороченого функціонального літерала, `(_ > _)`, він схибить, бо він не має інформації щодо типів неявних функціональних параметрів, що вказані як підкреслення.

Один спосіб розв'язати проблему є передати явний параметр типу до `msort`, як тут:
[source,scala]
----
scala> msort[Char](_ > _)(abcde)
res68: List[Char] = List(e, d, c, b, a)
----
Оскікльи коректний тип примірника `msort` тепер відомий, він може бути використаний для вивідення типу аргументів. Інше можливе рішення є переписати метод `msort`, так що його параметри були переставлені місцями:
[source,scala]
----
def msortSwapped[T](xs: List[T])(less:
    (T, T) => Boolean): List[T] = {
// така сама реалізація, що і msort,
// але з переставленими аргументами
}
----
Тепер вивід типу буде успішний:
[source,scala]
----
scala> msortSwapped(abcde)(_ > _)
res69: List[Char] = List(e, d, c, b, a)
----
Що тут трапилось, це те, що вивід використав відомий тип першого параметра, `abcde`, для визначення параметру типа `msortSwapped`. Як тільки точний тип `msortSwapped` став відомий, він, в свою чергу, може бути використаний для виведення типу другого параметру, `(_ > _)`.

Загалом, коли завданням є вивід параметру типу для поліморфного методу, вивід типу консультується з типами всіх значень аргументів в першому списку параметрів, але не з аргументами за його межами. Оскільки `msortSwapped` є карований метод з двома списками параметрів, не має потреби перевіряти другий аргумент (тобто, функціональне значення) для визначення параметру типа метода.

Ця схема виведення підказує наступний принцип розробки бібліотеки: коли розробляється поліморфний метод, що приймає не-функціональні аргументи, та функціональний аргумент, поставьте функціональний аргумент останнім окремо, у власному карованому списку аргументів. В такий спосіб, коректний тип примірника метода може бути виведений з не-функціональних аргументів, і цей тип може, в свою чергу, бути використаний для перевірки типу функціонального аргументу. Загальний ефект в тому, що користувачі метода будуть в змозі надавати менше інформації типу, та писати літерали в більш компактний спосіб.

Тепер перейдемо до більш складного випадку операції `fold`. Чому треба задавати явний параметр типу в такому виразі, як тіло метода `flattenRight`, показаного нижче?
[source,scala]
----
(xss :~List[T]()) (_ ::: _)
----
Тип операції правого згортання поліморфний по двох змінних. Візьмемо вираз:
[source,scala]
----
(xs :~z) (op)
----
Тип `xs` має бути списком деякого довільного типу `A`, скажімо,  `xs: List[A]`. Початкове значення `z` може бути деякого іншого типу `B`. Операція `op` після цього приймає два аргументи типів `A` та `B`, та повертає результат типу `B`, тобто, `op: (A, B) => B`. Оскільки тип `z` не пов'язаний до типу списка `xs`, вивід типу не має контекстної інформації для `z`.

Тепер розглянемо вираз в помилковій версії `flattenRight`, також показаній тут:
[source,scala]
----
(xss :~List()) (_ ::: _) // це не буде компілюватись
----
Початкове значення `z` в цьому `fold` є порожнім списком, `List()`, так що без додаткової інформації про тип, його тип виводиться як  `List[Nothing]`. Таким чином, вивід буде виводити, що тип `B` в `fold` є `List[Nothing]`. Таким чином, операція `(_ ::: _)` у `fold`, як очікується, має бути такого типу:
[source,scala]
----
(List[T], List[Nothing]) => List[Nothing]
----
Це, очевидно, є можливим типом для операції, такої як `fold`, але це не дуже корисний тип! Він каже, що операція завжди приймає порожній список в якості другого аргументу, та завжди продукує порожній список як результат.

Іншими словами, вивід типів стабілізується дуже рано для типу `List()`; він мав би дочекатись, доки він не побачить тип операції `op`. Так що (інакше дуже корисне) правило брати до уваги тільки перший розділ аргументів в застосуванні карованого метода для визначення типу метода, тут є коренем проблеми. З іншого боку, якщо це правило пом'якшити, вивід все ще не зможе надати тип для `op`, оскільки типи його параметрів не надані. Таким чином, це ситуація Catch-22, що може бути розрішена тільки через явну анотацію типу з боку програміста.

Цей приклад підкреслює деякі обмеження локальної, базованої на потоці, схеми виводу типів в Scala. Вона не присутня в більш глобальному стилі виводу типів Hindley-Milner, що використовується в функціональних мовах, як ML або Haskell. Однак локальний вивід типів Scala значно краще поводиться з об'єктно-орієнтовними субтипами, ніж стиль Hindley-Milner. На щастя, обмеження виявляють себе тільки в граничних випадках, та звичайно просто лагодяться додаванням явних анотацій типів.

Додавання анотацій типу також є корисною технікою зневадження, коли ви здивовані повідомленнями помилок типів, пов'язаних з поліморфними методами. Якщо ви невпевнені, що спричинило певну помилку типу, просто додайте аргументи типу або інші анотації типів, яка за вашою думкою коректна. Після цього ви будете в змозі швидко подивитись, в чому полягала реальна проблема.

16.11 Висновок
--------------
Тепер ви бачили багато шляхів роботи зі списками. Ви бачили базові операції, як `head` та `tail`, операції першого порядку, як `reverse`, операції вищого порядку, як `map`, та допоміжні методи в об'єкті `List`. По мірі цього ви трохи вивчили щодо того, як робить вивід типів Scala.

Списки є реальною робочою конячкою в Scala, так що ви отримаєте перевагу, якщо будете знати, як використовувати її. З цієї причини ця глава глибоко занурюється в те, як використовувати списки. Однак списки є тільки одним різновидом колекцій, що підтримує Scala. наступна глава є широкою, скоріше ніж глибокою, та показує вам, як використовувати різноманітні типи колекцій в Scala.
