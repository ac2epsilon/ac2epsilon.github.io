<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__17">Глава 17</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____">Робота з іншими колекціями</h1>
<div class="paragraph"><p>Scala має багату бібліотеку колекцій. Ця глава дає вам тур по найбільш загально уживаних типах колекцій та операціях, показуючи тільки частини, які ви будете використовувати найбільш часто. Глава 24 провадить більш повний тур по тому, що доступно, та Глава 25 покаже, як конструкції композиції Scala використовуються для провадження такого багатого API.</p></div>
<div class="sect1">
<h2 id="_17_1_">17.1 Послідовності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Типи послідовностей дозволяють вам робити з групами даних, впорядкованих один за одним. Оскільки елементи впорядковані, ви можете запросити перший елемент, другий елемент, 103й елемент, і так далі. В цій главі ми дамо вам короткий тур по найбільш важливим послідовностям.</p></div>
<div class="sect2">
<h3 id="_">Списки</h3>
<div class="paragraph"><p>Можливо, найбільш важливий тип послідовністі, про який треба знати, це клас <code>List</code>, незмінний пов'язаний список, описаний в деталях в попередній главі. Списки підтримують швидке додавання та видалення елементів з початку списку, але вони не провадять швидкого доступу до довільних індексів, оскільки реалізація має лінійно ітерувати вздовж всього списку.</p></div>
<div class="paragraph"><p>Ця комбінація можливостей може виглядати дивною, але вони б'ють в яблучко, та гарно роблять з багатьма алгоритмами. Швидке додавання та видалення перших елементів означає, що порівняння шаблонів також робить гарно, як описано в Главі 15. Незмінність списків допомагає вам розробляти коректні, ефективні алгоритми, тому що вам ніколи не треба робити копії зі списків.</p></div>
<div class="paragraph"><p>Ось короткий приклад, що показує, як ініціалізувати список, та отримати доступ до його голови та хвоста:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">colors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">,</span> <span class="s">&quot;blue&quot;</span><span class="o">,</span> <span class="s">&quot;green&quot;</span><span class="o">)</span>
<span class="n">colors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">colors</span><span class="o">.</span><span class="n">head</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">red</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">colors</span><span class="o">.</span><span class="n">tail</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб нагадати собі про списки, дивіться Крок 8 в Главі 3. Ви можете знайти деталі використання списків в Главі 16. Списки також обговорюються в Главі 22, що провадить погляд на те, як списки реалізовані в Scala.</p></div>
</div>
<div class="sect2">
<h3 id="__2">Масиви</h3>
<div class="paragraph"><p>Масиви дозволяють вам зберігати послідовність елементів, та ефективно отримувати доступ до елемента в довільній позиції, або отримуючи, або оновлюючі елемент, рахуючи від нульового індексу. Ось як ви створюєте масив, розмір якого ви знаєте, але для якого ви досі не знаєте значень елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fiveInts</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">5</span><span class="o">)</span>
<span class="n">fiveInts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як ви ініціалізуєте масив, коли ви знаєте значення елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fiveToOne</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">fiveToOne</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви мають доступ в Scala, розташовуючи індекс в дужки, не в прямокутні дужки, як в Java. Ось приклад обох, доступу та зміни елемента масива:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fiveInts</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">fiveToOne</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fiveInts</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Масиви Scala представлені в той самий спосіб, що і масиви Java. Так що ви можете без проблем використовувати існуючі методи Java, що повертають масиви.<span class="footnote"><br />[Різниця в варіантності масивів Scala та Java — тобто, коли <code>Array[String]</code> є субтипом <code>Array[AnyRef]</code> — це буде розглядатись в Розділі 19.3.]<br /></span></p></div>
<div class="paragraph"><p>Ви мали бачити масиви в дії багато раз в попередніх главах. Основи в Кроці в Главі 3. Декіклька прикладів ітерування по елементах масивів за допомогою вираза <code>for</code> показані в Розділі 7.3. Масиви також яскраво фігурують в бібліотеці двомірних розташувань в Главі 10.</p></div>
</div>
<div class="sect2">
<h3 id="__">Буфери списків</h3>
<div class="paragraph"><p>Клас <code>List</code> провадить швидкий доступ до голови списку, але не до кінця. Таким чином, коли вам треба побудувати список через додавання в кінець, розгляньте побудування списку навпаки, додаючи елементи до начала. Коли ви скінчите, викличте <code>reverse</code>, щоб отримати елементи в порядку, що вам потрібен.</p></div>
<div class="paragraph"><p>Інша альтернатива, що уникає операції <code>reverse</code>, це використання <code>ListBuffer</code>. <code>ListBuffer</code> є змінним об'єктом (що міститься в пакунку <code>scala.collection.mutable</code>), що може допомогти вам побудувати списки більш ефективно, коли вам треба дописувати в кінець. <code>ListBuffer</code> провадить сталий час виконання операцій додавання з обох кінців. Ви додаєте елементи за допомогою оператора <code>+=</code>, та ставите на початок за допомогою оператора <code>+=:</code>. Коли ви завершуєте побудову, ви можете отримати <code>List</code> через виклик <code>toList</code> на <code>ListBuffer</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">+=:</span> <span class="n">buf</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша причина використовувати <code>ListBuffer</code> замість <code>List</code> є запобігання потенційному переповненню стека. Якщо ви можете будувати список в бажаному порядку, додаючи спереду, але потрібний рекурсивний алгоритм не має хвостової рекурсії, замість цього ви можете використовувати вираз <code>for</code> або цикл <code>while</code> разом з <code>ListBuffer</code>. Ви побачите, як `ListBuffer`буде використаний в цей спосіб в Розділі 22.2.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Буфери масивів</h3>
<div class="paragraph"><p>An ArrayBuffer is like an array, except that you can additionally add and remove elements from the
beginning and end of the sequence. All Array operations are available, though they are a little slower
due to a layer of wrapping in the implementation. The new addition and removal operations are
constant time on average, but occasionally require linear time due to the implementation needing to
allocate a new array to hold the buffer&#8217;s contents.
To use an ArrayBuffer, you must first import it from the mutable collections package:
scala&gt; import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.ArrayBuffer
When you create an ArrayBuffer, you must specify a type parameter, but you don&#8217;t need to specify a
length. The ArrayBuffer will adjust the allocated space automatically as needed:
scala&gt; val buf = new ArrayBuffer[Int]()
buf: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer()
You can append to an ArrayBuffer using the <code>= method:
scala&gt; buf += 12
res9: buf.type = ArrayBuffer(12)
scala&gt; buf += 15
res10: buf.type = ArrayBuffer(12, 15)
scala&gt; buf
res11: scala.collection.mutable.ArrayBuffer[Int] =
ArrayBuffer(12, 15)
All the normal array methods are available. For example, you can ask an ArrayBuffer its length or you
can retrieve an element by its index:
scala&gt; buf.length
res12: Int = 2
scala&gt; buf(0)
res13: Int = 12
Strings (via StringOps)
One other sequence to be aware of is StringOps, which implements many sequence methods.
Because Predef has an implicit conversion from String to StringOps, you can treat any string like a
sequence. Here&#8217;s an example:scala&gt; def hasUpperCase(s: String) = s.exists(_.isUpper)
hasUpperCase: (s: String)Boolean
scala&gt; hasUpperCase("Robert Frost")
res14: Boolean = true
scala&gt; hasUpperCase("e e cummings")
res15: Boolean = false
In this example, the exists method is invoked on the string named s in the hasUpperCase method body.
Because no method named "exists" is declared in class String itself, the Scala compiler will implicitly
convert s to StringOps, which has the method. The exists method treats the string as a sequence of
characters, and will return true if any of the characters are upper case.<span class="footnote"><br />[The code given here of Chapter 1 presents a similar example.]<br /></span>
17.2 SETS AND MAPS
You have already seen the basics of sets and maps in previous chapters, starting with Step 10in Chapter
3. In this section, we&#8217;ll offer more insight into their use and show you a few more examples.
As mentioned previously, the Scala collections library offers both mutable and immutable versions of
sets and maps. The hierarchy for sets is shown in Figure 3.2 here, and the hierarchy for maps is shown
in Figure 3.3 here. As these diagrams show, the simple namesSet and Map are used by three traits each,
residing in different packages.
By default when you write "Set" or "Map" you get an immutable object. If you want the mutable
variant, you need to do an explicit import. Scala gives you easier access to the immutable variants, as a
gentle encouragement to prefer them over their mutable counterparts. The easy access is provided via
the Predef object, which is implicitly imported into every Scala source file. Listing 17.1 shows the
relevant definitions:
object Predef {
type Map[A, +B] = collection.immutable.Map[A, B]
type Set[A] = collection.immutable.Set[A]
val Map = collection.immutable.Map
val Set = collection.immutable.Set

}
Listing 17.1 - Default map and set definitions in Predef.
The "type" keyword is used in Predef to define Set and Map as aliases for the longer fully qualified
names of the immutable set and map traits.<span class="footnote"><br />[The type keyword will be explained in more detail in Section 20.6.]<br /></span> The vals named Set and Map are initialized to refer to
the singleton objects for the immutable Set and Map. So Map is the same asPredef.Map, which is
defined to be the same as scala.collection.immutable.Map. This holds both for the Map type
and Map object.
If you want to use both mutable and immutable sets or maps in the same source file, one approach is to
import the name of the package that contains the mutable variants:
scala&gt; import scala.collection.mutable
import scala.collection.mutableYou can continue to refer to the immutable set as Set, as before, but can now refer to the mutable set
as mutable.Set. Here&#8217;s an example:
scala&gt; val mutaSet = mutable.Set(1, 2, 3)
mutaSet: scala.collection.mutable.Set[Int] = Set(1, 2, 3)
Using sets
The key characteristic of sets is that they will ensure that at most one of each object, as determined
by ==, will be contained in the set at any one time. As an example, we&#8217;ll use a set to count the number
of different words in a string.
The split method on String can separate a string into words, if you specify spaces and punctuation as
word separators. The regular expression "[ !,.]</code>" will suffice: It indicates the string should be split at
each place that one or more space and/or punctuation characters exist.
scala&gt; val text = "See Spot run. Run, Spot. Run!"
text: String = See Spot run. Run, Spot. Run!
scala&gt; val wordsArray = text.split("<code><span class="!">")
wordsArray: Array[String]
= Array(See, Spot, run, Run, Spot, Run)
To count the distinct words, you can convert them to the same case and then add them to a set. Because
sets exclude duplicates, each distinct word will appear exactly one time in the set.
First, you can create an empty set using the empty method provided on the Set companion objects:
scala&gt; val words = mutable.Set.empty[String]
words: scala.collection.mutable.Set[String] = Set()
Then, just iterate through the words with a for expression, convert each word to lower case, and add it
to the mutable set with the += operator:
scala&gt; for (word &#8592; wordsArray)
words += word.toLowerCase
scala&gt; words
res17: scala.collection.mutable.Set[String] =
Set(see, run, spot)
Thus, the text contained exactly three distinct words: spot, run, and see. The most commonly used
methods on both mutable and immutable sets are shown in Table 17.1.
Common operations for sets
What it is
val nums = Set(1, 2, 3)
nums + 5
nums - 3
nums <code> List(5, 6)
What it does
Creates an immutable set (nums.toString returnsSet(1, 2, 3))
Adds an element (returns Set(1, 2, 3, 5))
Removes an element (returns Set(1, 2))
Adds multiple elements (returns Set(1, 2, 3, 5, 6))nums&#8201;&#8212;&#8201;List(1, 2)
nums &amp; Set(1, 3, 5, 7)
nums.size
nums.contains(3)
import scala.collection.mutable
val words =
mutable.Set.empty[String]
words += "the"
words -= "the"
words </code>= List("do", "re", "mi")
words --= List("do", "re")
words.clear
Removes multiple elements (returns Set(3))
Takes the intersection of two sets (returns Set(1, 3))
Returns the size of the set (returns 3)
Checks for inclusion (returns true)
Makes the mutable collections easy to access
Creates an empty, mutable set (words.toString returnsSet())
Adds an element (words.toString returns Set(the))
Removes an element, if it exists (words.toStringreturns Set())
Adds multiple elements (words.toString returnsSet(do, re, mi))
Removes multiple elements (words.toString returnsSet(mi))
Removes all elements (words.toString returns Set())
Using maps
Maps let you associate a value with each element of a set. Using a map looks similar to using an array,
except instead of indexing with integers counting from 0, you can use any kind of key. If you import
the mutable package name, you can create an empty mutable map like this:
scala&gt; val map = mutable.Map.empty[String, Int]
map: scala.collection.mutable.Map[String,Int] = Map()
Note that when you create a map, you must specify two types. The first type is for the keys of the map,
the second for the values. In this case, the keys are strings and the values are integers. Setting entries in
a map looks similar to setting entries in an array:
scala&gt; map("hello") = 1
scala&gt; map("there") = 2
scala&gt; map
res20: scala.collection.mutable.Map[String,Int] =
Map(hello &#8594; 1, there &#8594; 2)
Likewise, reading a map is similar to reading an array:
scala&gt; map("hello")
res21: Int = 1
Putting it all together, here is a method that counts the number of times each word occurs in a string:
scala&gt; def countWords(text: String) = {
val counts = mutable.Map.empty[String, Int]
for (rawWord &#8592; text.split("[ ,!.]</span></code>")) {
val word = rawWord.toLowerCase
val oldCount =
if (counts.contains(word)) counts(word)
else 0
counts <code>= (word &#8594; (oldCount + 1))
}
counts
}countWords: (text:
String)scala.collection.mutable.Map[String,Int]
scala&gt; countWords("See Spot run! Run, Spot. Run!")
res22: scala.collection.mutable.Map[String,Int] =
Map(spot &#8594; 2, see &#8594; 1, run &#8594; 3)
Given these counts, you can see that this text talks a lot about running, but not so much about seeing.
The way this code works is that a mutable map, named counts, maps each word to the number of times
it occurs in the text. For each word in the text, the word&#8217;s old count is looked up, that count is
incremented by one, and the new count is saved back into counts. Note the use ofcontains to check
whether a word has been seen yet or not. If counts.contains(word) is not true, then the word has not yet
been seen and zero is used for the count.
Many of the most commonly used methods on both mutable and immutable maps are shown in Table
17.2.
Common operations for maps
What it is
val nums = Map("i" &#8594; 1, "ii" &#8594;
2)
nums + ("vi" &#8594; 6)
nums - "ii"
nums <code> List("iii" &#8594; 3, "v" &#8594; 5)
nums&#8201;&#8212;&#8201;List("i", "ii")
nums.size
nums.contains("ii")
nums("ii")
nums.keys
nums.keySet
nums.values
nums.isEmpty
import scala.collection.mutable
val words =
mutable.Map.empty[String, Int]
words += ("one" &#8594; 1)
words -= "one"
words </code>= List("one" &#8594; 1,
"two" &#8594; 2, "three" &#8594; 3)
words --= List("one", "two")
What it does
Creates an immutable map (nums.toString returnsMap(i &#8594; 1, ii -
&gt; 2))
Adds an entry (returns Map(i &#8594; 1, ii &#8594; 2, vi &#8594; 6))
Removes an entry (returns Map(i &#8594; 1))
Adds multiple entries (returns Map(i &#8594; 1, ii &#8594; 2, iii &#8594; 3, v &#8594; 5))
Removes multiple entries (returns Map())
Returns the size of the map (returns 2)
Checks for inclusion (returns true)
Retrieves the value at a specified key (returns 2)
Returns the keys (returns an Iterable over the strings"i" and "ii")
Returns the keys as a set (returns Set(i, ii))
Returns the values (returns an Iterable over the integers 1 and 2)
Indicates whether the map is empty (returns false)
Makes the mutable collections easy to access
Creates an empty, mutable map
Adds a map entry from "one" to 1 (words.toStringreturns Map(one -
&gt; 1))
Removes a map entry, if it exists (words.toStringreturns Map())
Adds multiple map entries (words.toString returnsMap(one -
&gt; 1, two &#8594; 2, three &#8594; 3))
Removes multiple objects (words.toString returnsMap(three &#8594; 3))Default sets and maps
For most uses, the implementations of mutable and immutable sets and maps provided
bythe Set(), scala.collection.mutable.Map(), etc., factories will likely be sufficient. The
implementations provided by these factories use a fast lookup algorithm, usually involving a hash table,
so they can quickly decide whether or not an object is in the collection.
The scala.collection.mutable.Set() factory method, for example, returns
ascala.collection.mutable.HashSet, which uses a hash table internally. Similarly,
thescala.collection.mutable.Map() factory returns a scala.collection.mutable.HashMap.
The story for immutable sets and maps is a bit more involved. The class returned by
thescala.collection.immutable.Set() factory method, for example, depends on how many elements you
pass to it, as shown in Table 17.3. For sets with fewer than five elements, a special class devoted
exclusively to sets of each particular size is used to maximize performance. Once you request a set that
has five or more elements in it, however, the factory method will return an implementation that uses
hash tries.
Similarly, the scala.collection.immutable.Map() factory method will return a different class depending
on how many key-value pairs you pass to it, as shown in Table 17.4. As with sets, for immutable maps
with fewer than five elements, a special class devoted exclusively to maps of each particular size is
used to maximize performance. Once a map has five or more key-value pairs in it, however, an
immutable HashMap is used.
The default immutable implementation classes shown in Tables 17.3 and 17.4 work together to give
you maximum performance. For example, if you add an element to an EmptySet, it will return a Set1.
If you add an element to that Set1, it will return a Set2. If you then remove an element from the Set2,
you&#8217;ll get another Set1.
Table 17.3 - Default immutable set implementations
Number of elements
0
1
2
3
4
5 or more
Implementation
scala.collection.immutable.EmptySet
scala.collection.immutable.Set1
scala.collection.immutable.Set2
scala.collection.immutable.Set3
scala.collection.immutable.Set4
scala.collection.immutable.HashSet
Table 17.4 - Default immutable map implementations
Number of elements
0
1
2
3
4
Implementation
scala.collection.immutable.EmptyMap
scala.collection.immutable.Map1
scala.collection.immutable.Map2
scala.collection.immutable.Map3
scala.collection.immutable.Map45 or more
scala.collection.immutable.HashMap
Sorted sets and maps
On occasion you may need a set or map whose iterator returns elements in a particular order. For this
purpose, the Scala collections library provides traits SortedSet and SortedMap. These traits are
implemented by classes TreeSet and TreeMap, which use a red-black tree to keep elements (in the case
of TreeSet) or keys (in the case of TreeMap) in order. The order is determined by the Ordered trait,
which the element type of the set, or key type of the map, must either mix in or be implicitly
convertible to. These classes only come in immutable variants. Here are some TreeSet examples:
scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet
scala&gt; val ts = TreeSet(9, 3, 1, 8, 0, 2, 7, 4, 6, 5)
ts: scala.collection.immutable.TreeSet[Int] =
TreeSet(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
scala&gt; val cs = TreeSet(<em>f</em>, <em>u</em>, <em>n</em>)
cs: scala.collection.immutable.TreeSet[Char] =
TreeSet(f, n, u)
And here are a few TreeMap examples:
scala&gt; import scala.collection.immutable.TreeMap
import scala.collection.immutable.TreeMap
scala&gt; var tm = TreeMap(3 &#8594; <em>x</em>, 1 &#8594; <em>x</em>, 4 &#8594; <em>x</em>)
tm: scala.collection.immutable.TreeMap[Int,Char] =
Map(1 &#8594; x, 3 &#8594; x, 4 &#8594; x)
scala&gt; tm += (2 &#8594; <em>x</em>)
scala&gt; tm
res30: scala.collection.immutable.TreeMap[Int,Char] =
Map(1 &#8594; x, 2 &#8594; x, 3 &#8594; x, 4 &#8594; x)
17.3 SELECTING MUTABLE VERSUS IMMUTABLE COLLECTIONS
For some problems, mutable collections work better, while for others, immutable collections work
better. When in doubt, it is better to start with an immutable collection and change it later, if you need
to, because immutable collections can be easier to reason about than mutable ones.
Also, it can be worthwhile to go the opposite way sometimes. If you find some code that uses mutable
collections becoming complicated and hard to reason about, consider whether it would help to change
some of the collections to immutable alternatives. In particular, if you find yourself worrying about
making copies of mutable collections in just the right places, or thinking a lot about who "owns" or
"contains" a mutable collection, consider switching some of the collections to their immutable
counterparts.
Besides being potentially easier to reason about, immutable collections can usually be stored more
compactly than mutable ones if the number of elements stored in the collection is small. For instance anempty mutable map in its default representation of HashMap takes up about 80 bytes, and about 16
more are added for each entry that&#8217;s added to it. An empty immutable Map is a single object that&#8217;s
shared between all references, so referring to it essentially costs just a single pointer field.
What&#8217;s more, the Scala collections library currently stores immutable maps and sets with up to four
entries in a single object, which typically takes up between 16 and 40 bytes, depending on the number
of entries stored in the collection.<span class="footnote"><br />[The "single object" is an instance of Set1 through Set4, or Map1 through Map4, as shown inTables 17.3 and 17.4.]<br /></span> So for small maps and sets, the immutable versions are much
more compact than the mutable ones. Given that many collections are small, switching them to be
immutable can bring important space savings and performance advantages.
To make it easier to switch from immutable to mutable collections, and vice versa, Scala provides some
syntactic sugar. Even though immutable sets and maps do not support a true</code>= method, Scala gives a
useful alternate interpretation to <code>=. Whenever you write a += b, and adoes not support a method
named +=, Scala will try interpreting it as a = a + b.
For example, immutable sets do not support a += operator:
scala&gt; val people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[String] =
Set(Nancy, Jane)
scala&gt; people += "Bob"
&lt;console&gt;:14: error: value += is not a member of
scala.collection.immutable.Set[String]
people += "Bob"
<sup>
However, if you declare people as a var, instead of a val, then the collection can be "updated" with
a += operation, even though it is immutable. First, a new collection will be created, and
then people will be reassigned to refer to the new collection:
scala&gt; var people = Set("Nancy", "Jane")
people: scala.collection.immutable.Set[String] =
Set(Nancy, Jane)
scala&gt; people += "Bob"
scala&gt; people
res34: scala.collection.immutable.Set[String] =
Set(Nancy, Jane, Bob)
After this series of statements, the people variable refers to a new immutable set, which contains the
added string, "Bob". The same idea applies to any method ending in =, not just the</code>= method. Here&#8217;s
the same syntax used with the -= operator, which removes an element from a set, and the <code>= operator,
which adds a collection of elements to a set:
scala&gt; people -= "Jane"
scala&gt; people </code>= List("Tom", "Harry")
scala&gt; people
res37: scala.collection.immutable.Set[String] =Set(Nancy, Bob, Tom, Harry)
To see how this is useful, consider again the following Map example from Section 1.1:
var capital = Map("US" &#8594; "Washington", "France" &#8594; "Paris")
capital <code>= ("Japan" &#8594; "Tokyo")
println(capital("France"))
This code uses immutable collections. If you want to try using mutable collections instead, all that is
necessary is to import the mutable version of Map, thus overriding the default import of the
immutable Map:
import scala.collection.mutable.Map // only change needed!
var capital = Map("US" &#8594; "Washington", "France" &#8594; "Paris")
capital += ("Japan" &#8594; "Tokyo")
println(capital("France"))
Not all examples are quite that easy to convert, but the special treatment of methods ending in an
equals sign will often reduce the amount of code that needs changing.
By the way, this syntactic treatment works on any kind of value, not just collections. For example, here
it is being used on floating-point numbers:
scala&gt; var roughlyPi = 3.0
roughlyPi: Double = 3.0
scala&gt; roughlyPi += 0.1
scala&gt; roughlyPi += 0.04
scala&gt; roughlyPi
res40: Double = 3.14
The effect of this expansion is similar to Java&#8217;s assignment operators (</code>=, -=, *=, etc.), but it is more
general because every operator ending in = can be converted.
17.4 INITIALIZING COLLECTIONS
As you&#8217;ve seen previously, the most common way to create and initialize a collection is to pass the
initial elements to a factory method on the companion object of your chosen collection. You just place
the elements in parentheses after the companion object name, and the Scala compiler will transform
that to an invocation of an apply method on that companion object:
scala&gt; List(1, 2, 3)
res41: List[Int] = List(1, 2, 3)
scala&gt; Set(<em>a</em>, <em>b</em>, <em>c</em>)
res42: scala.collection.immutable.Set[Char] = Set(a, b, c)
scala&gt; import scala.collection.mutable
import scala.collection.mutable
scala&gt; mutable.Map("hi" &#8594; 2, "there" &#8594; 5)res43: scala.collection.mutable.Map[String,Int] =
Map(hi &#8594; 2, there &#8594; 5)
scala&gt; Array(1.0, 2.0, 3.0)
res44: Array[Double] = Array(1.0, 2.0, 3.0)
Although most often you can let the Scala compiler infer the element type of a collection from the
elements passed to its factory method, sometimes you may want to create a collection but specify a
different type from the one the compiler would choose. This is especially an issue with mutable
collections. Here&#8217;s an example:
scala&gt; import scala.collection.mutable
import scala.collection.mutable
scala&gt; val stuff = mutable.Set(42)
stuff: scala.collection.mutable.Set[Int] = Set(42)
scala&gt; stuff <code>= "abracadabra"
&lt;console&gt;:16: error: type mismatch;
found
: String("abracadabra")
required: Int
stuff += "abracadabra"
</sup>
The problem here is that stuff was given an element type of Int. If you want it to have an element type
of Any, you need to say so explicitly by putting the element type in square brackets, like this:
scala&gt; val stuff = mutable.Set[Any](42)
stuff: scala.collection.mutable.Set[Any] = Set(42)
Another special situation is if you want to initialize a collection with another collection. For example,
imagine you have a list, but you want a TreeSet containing the elements in the list. Here&#8217;s the list:
scala&gt; val colors = List("blue", "yellow", "red", "green")
colors: List[String] = List(blue, yellow, red, green)
You cannot pass the colors list to the factory method for TreeSet:
scala&gt; import scala.collection.immutable.TreeSet
import scala.collection.immutable.TreeSet
scala&gt; val treeSet = TreeSet(colors)
&lt;console&gt;:16: error: No implicit Ordering defined for
List[String].
val treeSet = TreeSet(colors)
^
Instead, you&#8217;ll need to create an empty TreeSet[String] and add to it the elements of the list with
the TreeSet&#8217;s <code> operator:
scala&gt; val treeSet = TreeSet[String]() </code> colors
treeSet: scala.collection.immutable.TreeSet[String] =
TreeSet(blue, green, red, yellow)Converting to array or list
If you need to initialize a list or array with another collection, on the other hand, it is quite
straightforward. As you&#8217;ve seen previously, to initialize a new list with another collection, simply
invoke toList on that collection:
scala&gt; treeSet.toList
res50: List[String] = List(blue, green, red, yellow)
Or, if you need an array, invoke toArray:
scala&gt; treeSet.toArray
res51: Array[String] = Array(blue, green, red, yellow)
Note that although the original colors list was not sorted, the elements in the list produced by
invoking toList on the TreeSet are in alphabetical order. When you invoke toList or toArray on a
collection, the order of the elements in the resulting list or array will be the same as the order of
elements produced by an iterator obtained by invoking elements on that collection. Because
a TreeSet[String]'s iterator will produce strings in alphabetical order, those strings will appear in
alphabetical order in the list resulting from invoking toList on that TreeSet.
Keep in mind, however, that conversion to lists or arrays usually requires copying all of the elements of
the collection, and thus may be slow for large collections. Sometimes you need to do it, though, due to
an existing API. Further, many collections only have a few elements anyway, in which case there is
only a small speed penalty.
Converting between mutable and immutable sets and maps
Another situation that arises occasionally is the need to convert a mutable set or map to an immutable
one, or vice versa. To accomplish this, you can use the technique shown on the previous page to
initialize a TreeSet with the elements of a list. Create a collection of the new type using
the empty method and then add the new elements using either <code> or </code>=, whichever is appropriate for
the target collection type. Here&#8217;s how you&#8217;d convert the immutable TreeSetfrom the previous example
to a mutable set, and back again to an immutable one:
scala&gt; import scala.collection.mutable
import scala.collection.mutable
scala&gt; treeSet
res52: scala.collection.immutable.TreeSet[String] =
TreeSet(blue, green, red, yellow)
scala&gt; val mutaSet = mutable.Set.empty <code>= treeSet
mutaSet: scala.collection.mutable.Set[String] =
Set(red, blue, green, yellow)
scala&gt; val immutaSet = Set.empty </code> mutaSet
immutaSet: scala.collection.immutable.Set[String] =
Set(red, blue, green, yellow)
You can use the same technique to convert between mutable and immutable maps:scala&gt; val muta = mutable.Map("i" &#8594; 1, "ii" &#8594; 2)
muta: scala.collection.mutable.Map[String,Int] =
Map(ii &#8594; 2,i &#8594; 1)
scala&gt; val immu = Map.empty +</code> muta
immu: scala.collection.immutable.Map[String,Int] =
Map(ii &#8594; 2, i &#8594; 1)
17.5 TUPLES
As described in Step 9 in Chapter 3, a tuple combines a fixed number of items together so that they can
be passed around as a whole. Unlike an array or list, a tuple can hold objects with different types. Here
is an example of a tuple holding an integer, a string, and the console:
(1, "hello", Console)
Tuples save you the tedium of defining simplistic data-heavy classes. Even though defining a class is
already easy, it does require a certain minimum effort, which sometimes serves no purpose. Tuples save
you the effort of choosing a name for the class, choosing a scope to define the class in, and choosing
names for the members of the class. If your class simply holds an integer and a string, there is no clarity
added by defining a class namedAnIntegerAndAString.
Because tuples can combine objects of different types, tuples do not inherit from Traversable. If you
find yourself wanting to group exactly one integer and exactly one string, then you want a tuple, not
a List or Array.
A common application of tuples is returning multiple values from a method. For example, here is a
method that finds the longest word in a collection and also returns its index:
def longestWord(words: Array[String]) = {
var word = words(0)
var idx = 0
for (i &#8592; 1 until words.length)
if (words(i).length &gt; word.length) {
word = words(i)
idx = i
}
(word, idx)
}
Here is an example use of the method:
scala&gt; val longest =
longestWord("The quick brown fox".split(" "))
longest: (String, Int) = (quick,1)
The longestWord function here computes two items: word, the longest word in the array, and idx, the
index of that word. To keep things simple, the function assumes there is at least one word in the list,
and it breaks ties by choosing the word that comes earlier in the list. Once the function has chosen
which word and index to return, it returns both of them together using the tuple syntax (word, idx).To access elements of a tuple, you can use method _1 to access the first element, _2 to access the
second, and so on:
scala&gt; longest._1
res53: String = quick
scala&gt; longest._2
res54: Int = 1
Additionally, you can assign each element of the tuple to its own variable,<span class="footnote"><br />[This syntax is actually a special case of pattern matching, as described in detail in Section 15.7.]<br /></span> like this:
scala&gt; val (word, idx) = longest
word: String = quick
idx: Int = 1
scala&gt; word
res55: String = quick
By the way, if you leave off the parentheses you get a different result:
scala&gt; val word, idx = longest
word: (String, Int) = (quick,1)
idx: (String, Int) = (quick,1)
This syntax gives multiple definitions of the same expression. Each variable is initialized with its own
evaluation of the expression on the right-hand side. That the expression evaluates to a tuple in this case
does not matter. Both variables are initialized to the tuple in its entirety. SeeChapter 18 for some
examples where multiple definitions are convenient.
As a note of warning, tuples are almost too easy to use. Tuples are great when you combine data that
has no meaning beyond "an A and a B." However, whenever the combination has some meaning, or
you want to add some methods to the combination, it is better to go ahead and create a class. For
example, do not use a 3-tuple for the combination of a month, a day, and a year. Make a Date class. It
makes your intentions explicit, which both clears up the code for human readers and gives the compiler
and language opportunities to help you catch mistakes.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_6_">17.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>This chapter has given an overview of the Scala collections library and the most important classes and
traits in it. With this foundation you should be able to work effectively with Scala collections, and
know where to look in Scaladoc when you need more information. For more detailed information about
Scala collections, look ahead to Chapter 24 and Chapter 25. For now, in the next chapter, we&#8217;ll turn our
attention from the Scala library back to the language and discuss Scala&#8217;s support for mutable objects.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-27 04:02:16 EET
</div>
</div>
</body>
</html>
