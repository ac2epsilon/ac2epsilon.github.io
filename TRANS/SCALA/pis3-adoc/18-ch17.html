<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__17">Глава 17</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____">Робота з іншими колекціями</h1>
<div class="paragraph"><p>Scala має багату бібліотеку колекцій. Ця глава дає вам тур по найбільш загально уживаних типах колекцій та операціях, показуючи тільки частини, які ви будете використовувати найбільш часто. Глава 24 провадить більш повний тур по тому, що доступно, та Глава 25 покаже, як конструкції композиції Scala використовуються для провадження такого багатого API.</p></div>
<div class="sect1">
<h2 id="_17_1_">17.1 Послідовності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Типи послідовностей дозволяють вам робити з групами даних, впорядкованих один за одним. Оскільки елементи впорядковані, ви можете запросити перший елемент, другий елемент, 103й елемент, і так далі. В цій главі ми дамо вам короткий тур по найбільш важливим послідовностям.</p></div>
<div class="sect2">
<h3 id="_">Списки</h3>
<div class="paragraph"><p>Можливо, найбільш важливий тип послідовністі, про який треба знати, це клас <code>List</code>, незмінний пов'язаний список, описаний в деталях в попередній главі. Списки підтримують швидке додавання та видалення елементів з початку списку, але вони не провадять швидкого доступу до довільних індексів, оскільки реалізація має лінійно ітерувати вздовж всього списку.</p></div>
<div class="paragraph"><p>Ця комбінація можливостей може виглядати дивною, але вони б'ють в яблучко, та гарно роблять з багатьма алгоритмами. Швидке додавання та видалення перших елементів означає, що порівняння шаблонів також робить гарно, як описано в Главі 15. Незмінність списків допомагає вам розробляти коректні, ефективні алгоритми, тому що вам ніколи не треба робити копії зі списків.</p></div>
<div class="paragraph"><p>Ось короткий приклад, що показує, як ініціалізувати список, та отримати доступ до його голови та хвоста:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">colors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;red&quot;</span><span class="o">,</span> <span class="s">&quot;blue&quot;</span><span class="o">,</span> <span class="s">&quot;green&quot;</span><span class="o">)</span>
<span class="n">colors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">colors</span><span class="o">.</span><span class="n">head</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">red</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">colors</span><span class="o">.</span><span class="n">tail</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб нагадати собі про списки, дивіться Крок 8 в Главі 3. Ви можете знайти деталі використання списків в Главі 16. Списки також обговорюються в Главі 22, що провадить погляд на те, як списки реалізовані в Scala.</p></div>
</div>
<div class="sect2">
<h3 id="__2">Масиви</h3>
<div class="paragraph"><p>Масиви дозволяють вам зберігати послідовність елементів, та ефективно отримувати доступ до елемента в довільній позиції, або отримуючи, або оновлюючі елемент, рахуючи від нульового індексу. Ось як ви створюєте масив, розмір якого ви знаєте, але для якого ви досі не знаєте значень елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fiveInts</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">5</span><span class="o">)</span>
<span class="n">fiveInts</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як ви ініціалізуєте масив, коли ви знаєте значення елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fiveToOne</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">fiveToOne</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви мають доступ в Scala, розташовуючи індекс в дужки, не в прямокутні дужки, як в Java. Ось приклад обох, доступу та зміни елемента масива:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fiveInts</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">fiveToOne</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fiveInts</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Масиви Scala представлені в той самий спосіб, що і масиви Java. Так що ви можете без проблем використовувати існуючі методи Java, що повертають масиви.<span class="footnote"><br />[Різниця в варіантності масивів Scala та Java — тобто, коли <code>Array[String]</code> є субтипом <code>Array[AnyRef]</code> — це буде розглядатись в Розділі 19.3.]<br /></span></p></div>
<div class="paragraph"><p>Ви мали бачити масиви в дії багато раз в попередніх главах. Основи в Кроці в Главі 3. Декіклька прикладів ітерування по елементах масивів за допомогою вираза <code>for</code> показані в Розділі 7.3. Масиви також яскраво фігурують в бібліотеці двомірних розташувань в Главі 10.</p></div>
</div>
<div class="sect2">
<h3 id="__">Буфери списків</h3>
<div class="paragraph"><p>Клас <code>List</code> провадить швидкий доступ до голови списку, але не до кінця. Таким чином, коли вам треба побудувати список через додавання в кінець, розгляньте побудування списку навпаки, додаючи елементи до начала. Коли ви скінчите, викличте <code>reverse</code>, щоб отримати елементи в порядку, що вам потрібен.</p></div>
<div class="paragraph"><p>Інша альтернатива, що уникає операції <code>reverse</code>, це використання <code>ListBuffer</code>. <code>ListBuffer</code> є змінним об'єктом (що міститься в пакунку <code>scala.collection.mutable</code>), що може допомогти вам побудувати списки більш ефективно, коли вам треба дописувати в кінець. <code>ListBuffer</code> провадить сталий час виконання операцій додавання з обох кінців. Ви додаєте елементи за допомогою оператора <code>+=</code>, та ставите на початок за допомогою оператора <code>+=:</code>. Коли ви завершуєте побудову, ви можете отримати <code>List</code> через виклик <code>toList</code> на <code>ListBuffer</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">+=:</span> <span class="n">buf</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ListBuffer</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша причина використовувати <code>ListBuffer</code> замість <code>List</code> є запобігання потенційному переповненню стека. Якщо ви можете будувати список в бажаному порядку, додаючи спереду, але потрібний рекурсивний алгоритм не має хвостової рекурсії, замість цього ви можете використовувати вираз <code>for</code> або цикл <code>while</code> разом з <code>ListBuffer</code>. Ви побачите, як <code>ListBuffer</code> буде використаний в цей спосіб в Розділі 22.2.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Буфери масивів</h3>
<div class="paragraph"><p><code>ArrayBuffer</code> подібний до масиву, за виключенням того, що ви можете додавати елементи з початку та з кінця послідовності. Доступні всі операції з масивами <code>Array</code>, хоча вони трохі повільніші, через прошарок обгортки в реалізації. Нові операції додавання та видалення мають сталий час в середньому, але часом потребують лінійного часу, бо реалізація потребує розміщувати новий масив, щоб зберігати вміст буфера.</p></div>
<div class="paragraph"><p>Щоб використовувати <code>ArrayBuffer</code>, ви маєте спочатку імпортувати його з пакунку змінних колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви створюєте <code>ArrayBuffer</code>, ви маєте вказати параметр типу, але ви не маєте вказувати довжину. <code>ArrayBuffer</code> буде підлаштовувати розміщений простір автоматично, по мірі необхідності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додавати до <code>ArrayBuffer</code> з використанням метода <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">12</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span> <span class="o">+=</span> <span class="mi">15</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">buf.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">12</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Доступні всі методи нормальних масивів. Наприклад, ви можете запитати в <code>ArrayBuffer</code> його довжину, або ви можете отримати елемент по його індексу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">buf</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_stringops_code">Рядки (через <code>StringOps</code>)</h3>
<div class="paragraph"><p>Ще одна послідовність, про яку треба знати, це <code>StringOps</code>, що реалізує багато методів послідовностей. Оскільки <code>Predef</code> має неявне перетворення від <code>String</code> до <code>StringOps</code>, ви можете трактувати любий рядок як послідовність. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">hasUpperCase</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>
<span class="n">hasUpperCase</span><span class="k">:</span> <span class="o">(</span><span class="kt">s:</span> <span class="kt">String</span><span class="o">)</span><span class="kt">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasUpperCase</span><span class="o">(</span><span class="s">&quot;Robert Frost&quot;</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasUpperCase</span><span class="o">(</span><span class="s">&quot;e e cummings&quot;</span><span class="o">)</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі метод <code>exists</code> викликається на рядку на ім'я <code>s</code> в тілі методу <code>hasUpperCase</code>. Оскільки в самому класі String немає декларованого метода на ім'я <code>exists</code>, компілятор Scala буде неявно конвертувати <code>s</code> до <code>StringOps</code>, що має такий метод. Метод <code>exists</code> трактує рядок як послідовність символів, та буде повертати <code>true</code>, якщо любий з символів в верхньому реєстрі:[Код, наданий в Главі 1, презентує подібний приклад.]</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_2___">17.2 Множини та мапи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви вже бачили основи множин та мап в попередніх главах, починаючи з Кроку 10 в Главі 3. В цьому розділі ми маємо намір краще зрозуміти їх використання, та покажемо вам ще декілька прикладів.</p></div>
<div class="paragraph"><p>Як вже зазначалось, бібліотека колекцій Scala пропонує обоє, змінні та незмінні версії множин та мап. Ієрархія для множин показана на Малюнку 3.2, і ієрархія для мап на Малюнку 3.3. Як показують ці діаграми, прості імена <code>Set</code> та <code>Map</code> використовуються трьома трейтами кожний, що знаходяться в різних пакунках.</p></div>
<div class="paragraph"><p>По замовчанню, коли ви пишете <code>Set</code> або <code>Map</code>, ви отримаєте незмінний об'єкт. Якщо ви бажаєте змінний варіант, вам треба зробити явний імпорт. Scala дає вам простіший доступ до незмінних варіантів, як м'яке заохочення обирати їх, ніж їх змінні двійники. Простий доступ провадиться через об'єкт <code>Predef</code>, що неявно імпортується в кожний джерельний файл Scala. Лістинг 17.1 показує відповідні визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">+B</span><span class="o">]</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">val</span> <span class="nc">Map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span>
  <span class="k">val</span> <span class="nc">Set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 17.1 - Визначення по замовчанню для мап на множин в <code>Predef</code>.</p></div>
<div class="paragraph"><p>Ключове слово <code>type</code> використовується в <code>Predef</code> для визначення <code>Set</code> та <code>Map</code>, як псевдонимів для довших, повністю кваліфікованих імен незмінних трейтів множин та мап.<span class="footnote"><br />[Ключове слово <code>type</code> буде пояснено більш детально в Розділі 20.6.]<br /></span> Змінні <code>val</code> на ім'я  <code>Set</code> та <code>Map</code> ініціалізовані для посилань на об'єкти синглтони для незмінних <code>Set</code> та <code>Map</code>. Так що <code>Map</code> те саме, що <code>Predef.Map</code>, що визначений бути тим самий, що і <code>scala.collection.immutable.Map</code>. Це дотримується так само для типу <code>Map</code>, та об'єкта <code>Map</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте використовувати обоє, змінні та незмінні множини та мапи в тому самому джерельному файлі, один підхід є імпортувати ім'я пакунку, що містить змінні варіанти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете продовжувати посилатись на незмінні множини як <code>Set</code>, як і раніше, але тепер можете посилатись на змінну множину як на <code>mutable.Set</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mutaSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">mutaSet</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="___3">Використання множин</h3>
<div class="paragraph"><p>Ключева характеристика множин в тому, що вони будуть гарантувати щонайбільше одне входження об'єкту, в терміних <code>==</code>, що буде міститись в множині в кожний момент часу. Як приклад, ми будемо використовувати множину для підрахунку кількості різних слів в рядку.</p></div>
<div class="paragraph"><p>Метод <code>split</code> на <code>String</code> може розділити рядок на слова, якщо ви вкажете проміжки та символи пунктуації в якості роздільників слів. Регулярний вираз <code>"[ !,.]+"</code> буде достатнім: він вказує, що рядок має бути розділений в кожному місці, де є один або більше проміжків та/або символів пунктуації.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="s">&quot;See Spot run. Run, Spot. Run!&quot;</span>
<span class="n">text</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">See</span> <span class="nc">Spot</span> <span class="n">run</span><span class="o">.</span> <span class="nc">Run</span><span class="o">,</span> <span class="nc">Spot</span><span class="o">.</span> <span class="nc">Run</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wordsArray</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;[ !,.]+&quot;</span><span class="o">)</span>
<span class="n">wordsArray</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="nc">See</span><span class="o">,</span> <span class="nc">Spot</span><span class="o">,</span> <span class="n">run</span><span class="o">,</span> <span class="nc">Run</span><span class="o">,</span> <span class="nc">Spot</span><span class="o">,</span> <span class="nc">Run</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб підрахувати різні слова, ви можете конвертувати їх в однаковий реєстр, та додати їх до множини. Оскільки множини виключають дублікати, кожне окреме слово буде з'являтись в множині рівно один раз.</p></div>
<div class="paragraph"><p>Перше, ви можете створити порожню множину, використовуючи порожній метод, впроваджений об'єктом компанйоном <code>Set</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">words</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім просто ітеруєте по словах за допомогою <code>for</code> виразу, конвертуєте кожне слово в нижній реєстр, та додаваєте його до змінної множини оператором <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">word</span> <span class="k">&lt;-</span> <span class="n">wordsArray</span><span class="o">)</span>
<span class="n">words</span> <span class="o">+=</span> <span class="n">word</span><span class="o">.</span><span class="n">toLowerCase</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Set</span><span class="o">(</span><span class="n">see</span><span class="o">,</span> <span class="n">run</span><span class="o">,</span> <span class="n">spot</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, текст містив рівно три відмінні слова: <code>spot</code>, <code>run</code>, та <code>see</code>. Найбільш загально використовувані методи для обох, змінних та незмінних множин, показані в Таблиці 17.1.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.1 Базові операції для множин</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>val nums = Set(1, 2, 3)</code></p></td>
<td align="left" valign="top"><p class="table">Створює незмінну множину (<code>nums.toString returnsSet(1, 2, 3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums + 5</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент (повертає <code>Set(1, 2, 3, 5)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums - 3</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент (повертає <code>Set(1, 2)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums ++ List(5, 6)</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементві (повертає <code>Set(1, 2, 3, 5, 6)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums -- List(1, 2)</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька елементів (повертає <code>Set(3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums &amp; Set(1, 3, 5, 7)</code></p></td>
<td align="left" valign="top"><p class="table">Робить перетин двох множин (повертає <code>Set(1, 3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.size</code></p></td>
<td align="left" valign="top"><p class="table">Повертає розмір множини (повертає <code>3</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.contains(3)</code></p></td>
<td align="left" valign="top"><p class="table">Перевіряє входження (повертає <code>true</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>import scala.collection.mutable</code></p></td>
<td align="left" valign="top"><p class="table">Робить змінні колекції простими для доступу</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>val words = mutable.Set.empty[String]</code></p></td>
<td align="left" valign="top"><p class="table">Створює порожню змінну множину (<code>words.toString</code> повертає <code>Set()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words += "the"</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент (<code>words.toString</code> повертає <code>Set(the)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words -= "the"</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент, якщо він існує (<code>words.toString</code> повертає <code>Set()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words ++= List("do", "re", "mi")</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементів (<code>words.toString</code> повертає <code>Set(do, re, mi)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words --= List("do", "re")</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька елементів (<code>words.toString</code> повертає <code>Set(mi)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words.clear</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє всі елементи (<code>words.toString</code> повертає <code>Set()</code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="___4">Використання мап</h3>
<div class="paragraph"><p>Мапи дозволяють асоціювати значення з кожним елементом множини. Використання мапи виглядає подібним до використання масива, за винятком того, що замість індексування цілими числами, рахуючи від <code>0</code>, ви можете використовувати любий різновид ключів. Якщо ви імпортуєте ім'я зі змінного пакунку, ви можете створити порожню змінну мапу, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="n">map</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що коли ви створюєте мапу, ви маєте задати два типи. Перший тип для ключів мапи, та другий для значень. В цьому випадку ключі є рядками, та значення є цілими. Встановлення значень для мапи виглядає подібно для встановлення елементів в масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="s">&quot;there&quot;</span><span class="o">)</span> <span class="k">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">hello</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">there</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, читання мапи подібне до читання масиву:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">map</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Складаючи все це разом, ось метод, що підраховує число раз, скільки разів кожне слово страпляється в рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">countWords</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">counts</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>
          <span class="k">for</span> <span class="o">(</span><span class="n">rawWord</span> <span class="k">&lt;-</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;[ ,!.]+&quot;</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">val</span> <span class="n">word</span> <span class="k">=</span> <span class="n">rawWord</span><span class="o">.</span><span class="n">toLowerCase</span>
            <span class="k">val</span> <span class="n">oldCount</span> <span class="k">=</span>
              <span class="k">if</span> <span class="o">(</span><span class="n">counts</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="n">counts</span><span class="o">(</span><span class="n">word</span><span class="o">)</span>
              <span class="k">else</span> <span class="mi">0</span>
            <span class="n">counts</span> <span class="o">+=</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">oldCount</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
          <span class="o">}</span>
          <span class="n">counts</span>
        <span class="o">}</span>

<span class="n">countWords</span><span class="k">:</span> <span class="o">(</span><span class="kt">text:</span>
<span class="kt">String</span><span class="o">)</span><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">countWords</span><span class="o">(</span><span class="s">&quot;See Spot run! Run, Spot. Run!&quot;</span><span class="o">)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">spot</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">see</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">run</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці підрахунки, ви можете бачити, що цей текст каже більше про біг, та меньше про бачення.</p></div>
<div class="paragraph"><p>Спосіб, як робить цей код, в тому, що змінна мапа на ім'я <code>counts</code> відзеркалює кожне слово на кількість раз, скількі воно трапляється в тексті. Для кожного слова в тексті спочатку шукається старий лічильник, що збільшується на одиницю, та потім зберігається назад в <code>counts</code>. Зауважте використання <code>contains</code> для перевірки, чи слово вже відоме, чи ні. Якщо <code>counts.contains(word)</code> не є <code>true</code>, тоді слово ще невідоме, та для лічильника використовується нуль.</p></div>
<div class="paragraph"><p>Багато з загально уживаних методів, на обох, змінних та незмінних мап, показані в Таблиці Table 17.2.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.2 Загальні операції для мап</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>val nums = Map("i" -&gt; 1, "ii" -&gt; 2)</code></p></td>
<td align="left" valign="top"><p class="table">Створює незмінну мапу (<code>nums.toString</code> повертає <code>Map(i -&gt; 1, ii -
&gt; 2))</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums + ("vi" -&gt; 6)</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент (повертає <code>Map(i -&gt; 1, ii -&gt; 2, vi -&gt; 6)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums - "ii"</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент (повертає <code>Map(i -&gt; 1)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums ++ List("iii" -&gt; 3, "v" -&gt; 5)</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементів (повертає <code>Map(i -&gt; 1, ii -&gt; 2, iii -&gt; 3, v -&gt; 5)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums -- List("i", "ii")</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька елементів (повертає <code>Map()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.size</code></p></td>
<td align="left" valign="top"><p class="table">Повертає розмір мапи (повертає <code>2</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.contains("ii")</code></p></td>
<td align="left" valign="top"><p class="table">Перевіряє входження (повертає <code>true</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums("ii")</code></p></td>
<td align="left" valign="top"><p class="table">Отримує значення вказаного ключа (повертає <code>2</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.keys</code></p></td>
<td align="left" valign="top"><p class="table">Повертає ключі (повертає <code>Iterable</code> по рядках <code>"i"</code> та <code>"ii"</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.keySet</code></p></td>
<td align="left" valign="top"><p class="table">Повертає ключі як множину (повертає <code>Set(i, ii)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.values</code></p></td>
<td align="left" valign="top"><p class="table">Повертає значення (повертає <code>Iterable</code> по цілим <code>1</code> та <code>2</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>nums.isEmpty</code></p></td>
<td align="left" valign="top"><p class="table">Визначає, чи мапа порожня (повертає <code>false</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>import scala.collection.mutable</code></p></td>
<td align="left" valign="top"><p class="table">Спрощує досутп до змінних колекцій</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>val words = mutable.Map.empty[String, Int]</code></p></td>
<td align="left" valign="top"><p class="table">Створює порожню змінну мапу</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words += ("one" -&gt; 1)</code></p></td>
<td align="left" valign="top"><p class="table">Додає елемент мапи з <code>"one"</code> до <code>1</code> (<code>words.toString</code> повертає <code>Map(one -&gt; 1)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words -= "one"</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє елемент мапи, якщо він існує (<code>words.toString</code> повертає <code>Map()</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words ++= List("one" -&gt; 1, "two" -&gt; 2, "three" -&gt; 3)</code></p></td>
<td align="left" valign="top"><p class="table">Додає декілька елементів мапи (<code>words.toString</code> повертає <code>Map(one -
&gt; 1, two -&gt; 2, three -&gt; 3)</code>)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>words --= List("one", "two")</code></p></td>
<td align="left" valign="top"><p class="table">Видаляє декілька об'єктів (<code>words.toString</code> повертає <code>Map(three -&gt; 3)</code>)</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_____">Множини та мапи по замовчанню</h3>
<div class="paragraph"><p>Для більшості застосувань реалізації змінних та незмінних множин та мап, запроваджені фабриками <code>Set()</code>, <code>scala.collection.mutable.Map()</code>, тощо, скоріше будуть достатніми. Реалізації, проваджені ціми фабриками, використовують алгоритм швидкого пошуку, який звичайно задіє хеш таблицю, так що вони можуть швико вирішити, є або ні об'єкт в колекції.</p></div>
<div class="paragraph"><p>Наприклад, метод фабрики <code>scala.collection.mutable.Set()</code> повертає  <code>scala.collection.mutable.HashSet</code>, що внутрішньо використовує хеш таблицю. Подібно, фабрика <code>scala.collection.mutable.Map()</code> повертає <code>scala.collection.mutable.HashMap</code>.</p></div>
<div class="paragraph"><p>Історія для незмінних множин та мап трохи складніша. Наприклад, клас, що повертається методом фабрики <code>scala.collection.immutable.Set()</code>, залежить від того, як багато елементів ви передасте йому, як показано в Таблиці 17.3. Для множин, меньших за п'ять елементів, існують окремі класи, ексклюзивно призначені для множин кожного окремого розміру, що використовуються для максимальної продуктивності. Однак, коли ви запитуєте множину, що має п'ять або більше елементів, метод фабрики буде повертати реалізацію, що використовує хеш дерева.</p></div>
<div class="paragraph"><p>Подібно до цього, метод фабрики <code>scala.collection.immutable.Map()</code> буде повертати інший клас, в залежності від того, як багато пар ключ-значення ви передасте йому, як показано в Таблиці 17.4. Так само, як з множинами, для незмінних мап з меньше ніж п'ятьма елементами виділяється окремий клас, ексклюзивно призначений для мап окремого розміру, що використовується для максимальної продуктивності. Однак, коли мапа має п'ять або більше пар ключ-значення, буде використаний незмінний <code>HashMap</code>.</p></div>
<div class="paragraph"><p>Реалізація незмінних класів по замовчанню, показаних в Таблиці 17.3 та 17.4, роблять разом для надання вам максимальної продуктивності. Наприклад, якщо ви додасте елемент до <code>EmptySet</code>, він поверне <code>Set1</code>. Якщо ви додасте елемент до <code>Set1</code>, він буде повертати <code>Set2</code>. Якщо ви потім видалите елемент з <code>Set2</code>, ви отримаєте новий <code>Set1</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.3 Реалізації незмінних множин по замовчанню</caption>
<col width="14%" />
<col width="85%" />
<thead>
<tr>
<th align="center" valign="top">Число елементів </th>
<th align="center" valign="top">Реалізація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.EmptySet</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set1</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set2</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set3</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Set4</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">&gt;=5</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.HashSet</code></p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 17.4 Реалізації незмінних мап по замовчанню</caption>
<col width="14%" />
<col width="85%" />
<thead>
<tr>
<th align="center" valign="top">Число елементів </th>
<th align="center" valign="top">Реалізація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center" valign="top"><p class="table">0</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.EmptyMap</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map1</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map2</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map3</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.Map4</code></p></td>
</tr>
<tr>
<td align="center" valign="top"><p class="table">&gt;=5</p></td>
<td align="left" valign="top"><p class="table"><code>scala.collection.immutable.HashMap</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_____2">Впорядковані множини та мапи</h3>
<div class="paragraph"><p>Часом вам може знадобитись множина або мапа, чий ітератор повертає елементи в певному порядку. Для ціх цілей бібліотека колекцій Scala провадить трейти <code>SortedSet</code> та <code>SortedMap</code>. Ці трейти реалізовані класами <code>TreeSet</code> та <code>TreeMap</code>, що викорисотвують дерева <em>червоне-чорне</em> для зберігання елементів (в випадку <code>TreeSet</code>) або ключів (в випадку <code>TreeMap</code>) впорядкованими. Порядок визначається трейтом <code>Ordered</code>, що або зміксований в тип множини чи тип ключа мапи, або має до нього неявне перетворення. Ці класи мають тільки незмінні варіанти. Ось деякі приклади <code>TreeSet</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ts</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">ts</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cs</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="sc">&#39;f&#39;</span><span class="o">,</span> <span class="sc">&#39;u&#39;</span><span class="o">,</span> <span class="sc">&#39;n&#39;</span><span class="o">)</span>
<span class="n">cs</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та ось декілька прикладів <code>TreeMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.immutable.TreeMap</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeMap</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">tm</span> <span class="k">=</span> <span class="nc">TreeMap</span><span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">)</span>
<span class="n">tm</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">tm</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="sc">&#39;x&#39;</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">tm</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeMap</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Char</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_3______">17.3 Вибір між змінними та незмінними колекціями</h2>
<div class="sectionbody">
<div class="paragraph"><p>Для деяких пробелем змінні колекції роблять краще, тоді як для інших незмінні колекції роблять краще. Коли є сумніви, краще почати з незмінної колекції, та потім змінити її, якщо буде потреба, оскількі незмінні колекції легші для розуміння, ніж змінні.</p></div>
<div class="paragraph"><p>Також може бути вартим іноді іти в зворотньому напрямку. Якщо ви знайдете якійсь код, що використовує змінні колекції, та стає складним для розуміння, поміркуйте, чи не допоможе зміна деяких з колекцій на незмінні альтернативи. Зокрема, якщо ви турбуєтесь щодо створення копій змінних колекцій тільки в вірних місцях, або думаєте про те, хто "володіє" або "містить" змінну колекцію, розгляньте перехід деяких колекцій на їх незмінних двійників.</p></div>
<div class="paragraph"><p>Крім того, що про них легше розмірковувати, незмінні колекції можуть зазвичай зберігатись більш компактно, ніж змінні, якщо кількість елементів, що зберігається в колекції, невелика. Наприклад, примірник порожньої змінної мапи в її представленні за замовчанням  <code>HashMap</code>, займає приблизно 80 байт, та на 16 ще додаються для кожного елемента, що додається. Порожня незмінна <code>Map</code> є єдиним об'єктом, що поділяється між всіма посиланнями, так що посилання на неї коштує рівно стільки, скільки саме поле вказівника.</p></div>
<div class="paragraph"><p>Ще більше, бібліотека колекцій Scala наразі зберігає незмінні мапи до чотирьох елементів як єдиний об'єкт, що типово займає від 16 до 40 байтів, в залежності від числа елементів, що зберігаються в колекції.<span class="footnote"><br />["Єдиний об'єкт" є примірник <code>Set1</code> до <code>Set4</code>, або <code>Map1</code> до <code>Map4</code>, як показано в Таблиці 17.3 та 17.4.]<br /></span> Так що для малих мап та множин незмінні версії значно більш компактні, ніж змінні. Беручи до уваги, що багато колекцій є малими, перехід на незмінні варіанти може привнести важливі збереження простору та переваги продуктивності.</p></div>
<div class="paragraph"><p>Щоб спростити перехід від незмінних до змінних колекцій, та навпаки, Scala провадить деякий синтаксичний цукор. Навіть зважаючи, що незмінні множини та мапи не підтримують дійсний метод <code>+=</code>, Scala дає корисну альтернативну інтерпретацію до <code>+=</code>. Кожного разу, коли ви пишете <code>a += b</code>, і <code>a</code> не підтримує метод з ім'ям <code>+=</code>, Scala спробує інтерпретувати це як <code>a = a + b</code>.</p></div>
<div class="paragraph"><p>Наприклад, незмінні множини не підтримують оператор <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Nancy&quot;</span><span class="o">,</span> <span class="s">&quot;Jane&quot;</span><span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Jane</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">+=</span> <span class="s">&quot;Bob&quot;</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">+=</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
              <span class="n">people</span> <span class="o">+=</span> <span class="s">&quot;Bob&quot;</span>
                     <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак, якщо ви декларуєте <code>people</code> як <code>var</code>, замість <code>val</code>, тоді колекція може бути "оновлена" за допомогою оператора <code>+=</code>, навіть якщо вона незмінна. Спочатку буде створена нова колекція, та потім <code>people</code> буде переприсвоєне, щоб посилатись на нову колекцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Nancy&quot;</span><span class="o">,</span> <span class="s">&quot;Jane&quot;</span><span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Jane</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">+=</span> <span class="s">&quot;Bob&quot;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Jane</span><span class="o">,</span> <span class="nc">Bob</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Після цієї серії тверджень, змінна <code>people</code> посилається на нову незмінну множину, що містить доданий рядок, <code>"Bob"</code>. Та сама ідея застосовується до любого метода, що завершується на <code>=</code>, не тільки до метода <code>+=</code>. Ось той самий синтаксис, використаний з оператором <code>-=</code>, що видаляє елемент з множини, та до оператора <code>++=</code>, що додає колекцію елементів до множини:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">-=</span> <span class="s">&quot;Jane&quot;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;Tom&quot;</span><span class="o">,</span> <span class="s">&quot;Harry&quot;</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">people</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="nc">Nancy</span><span class="o">,</span> <span class="nc">Bob</span><span class="o">,</span> <span class="nc">Tom</span><span class="o">,</span> <span class="nc">Harry</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб подивитись, як це може бути корисне, знову розглянемо наступний приклад <code>Map</code> з Розділу 1.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код використовує незмінні колекції. Якщо ви бажаєте спробувати використання змінних колекцій замість цього, все що треба, це імпортувати змінну версію <code>Map</code>, таким чином перекриваючи імпорт по замовчанню незмінної <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.Map</span> <span class="c1">// єдина потрібна зміна!</span>
<span class="k">var</span> <span class="n">capital</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;US&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Washington&quot;</span><span class="o">,</span> <span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">)</span>
<span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">&quot;France&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Не всі приклади так само прості для конвертації, але особлива трактовка методів, що закінчується на знак рівності, часто зменшує кількість коду, що потребує змін.</p></div>
<div class="paragraph"><p>До ручі, цей синтаксичний підхід робить з любим типом значення, не тільки для колекцій. Наприклад, ось як він робить, використаний для чисел з плаваючою крапкою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">roughlyPi</span> <span class="k">=</span> <span class="mf">3.0</span>
<span class="n">roughlyPi</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">roughlyPi</span> <span class="o">+=</span> <span class="mf">0.1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">roughlyPi</span> <span class="o">+=</span> <span class="mf">0.04</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">roughlyPi</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.14</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект цього розширення подібний до операторів присвоєння Java (<code>+=</code>, <code>-=</code>, <code>*=</code>, тощо), але він більш загальний, бо кожний оператор, що закінчується на <code>=</code>, може бути конвертований.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_17_4__">17.4 Ініціалізація колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви вже бачили до цього, найбільш загальний спосіб створити та ініціалізувати колекцію є передати початкові елементи до метода фабрики на об'єкті компанйоні обраної колекції. Ви просто покладаєте елементи в дужки після імені об'єкта компанйона, та компілятор Scala буде трансформувати його на виклик метода <code>apply</code> на цьому об'єкті компанйоні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Set</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="sc">&#39;c&#39;</span><span class="o">)</span>
<span class="n">res42</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;hi&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">&quot;there&quot;</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">hi</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">there</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Array</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча більш часто ви можете дозволити компілятору Scala виводити тип елементів колекції від елементів, що ви передаєте до його методу фабрики, іноді ви можете бажати створити колекцію, але вказати інший тип, ніж той, що буде обирати компілятор. Це особливо важливо для змінних колекцій. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stuff</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">stuff</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stuff</span> <span class="o">+=</span> <span class="s">&quot;abracadabra&quot;</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">abracadabra</span><span class="err">&quot;</span><span class="o">)</span>
<span class="kt">required:</span> <span class="kt">Int</span>
            <span class="n">stuff</span> <span class="o">+=</span> <span class="s">&quot;abracadabra&quot;</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут проблема в тому, що <code>stuff</code> отримав тип елементу <code>Int</code>. Якщо ви бажаєте, щоб тип елементу був <code>Any</code>, вам треба сказати це явно, поклавши тип елементу в прямокутні дужки, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stuff</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">Any</span><span class="o">](</span><span class="mi">42</span><span class="o">)</span>
<span class="n">stuff</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша особлива ситуація виникає, коли ви бажаєте ініціалізувати колекцію за допомогою іншої колекції. Наприклад, уявімо, що ви маєте список, але ви бажаєте мати <code>TreeSet</code>, що містить елементи з цього списку. Ось список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">colors</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;blue&quot;</span><span class="o">,</span> <span class="s">&quot;yellow&quot;</span><span class="o">,</span> <span class="s">&quot;red&quot;</span><span class="o">,</span> <span class="s">&quot;green&quot;</span><span class="o">)</span>
<span class="n">colors</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">yellow</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">green</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не можете передати список <code>colors</code> до метода фабрики для <code>TreeSet</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">treeSet</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="n">colors</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">implicit</span> <span class="kt">Ordering</span> <span class="kt">defined</span> <span class="kt">for</span>
<span class="nc">List</span><span class="o">[</span><span class="kt">String</span><span class="o">].</span>
       <span class="k">val</span> <span class="n">treeSet</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="n">colors</span><span class="o">)</span>
                            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього вам треба створити порожній <code>TreeSet[String]</code>, та додати до нього елементи списку за допомогою оператора <code>TreeSet</code> <code>++</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">treeSet</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]()</span> <span class="o">++</span> <span class="n">colors</span>
<span class="n">treeSet</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="______2">Конвертація до масиву або списку</h3>
<div class="paragraph"><p>З іншого боку, якщо вам треба ініціалізувати список або масив з іншої колекції, це досить прямолінійно. Як ви бачили до цього, щоб ініціалізувати новий список з іншої колекції, просто виконайте на цій колекції метод <code>toList</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">treeSet</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або, якщо вам треба масив, викличте <code>toArray</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">treeSet</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що хоча оригінальний список <code>colors</code> не був впорядкований, елементи в списку, спродукованому через виклик <code>toList</code> на <code>TreeSet</code>, ідуть в алфавітному порядку. Коли ви викликаєте <code>toList</code> або <code>toArray</code> на колекції, порядок елементів в отриманому списку або масиві буде той самий, що і порядок елементів, спродукований ітератором, отриманим через виклик <code>elements</code> на цій колекції. Оскільки ітератор <code>TreeSet[String]</code> буде продукувати рядкі в алфавітному порядку, ці рядкі будуть з'являтись в алфавітному порядку в списку, отриманому від визову <code>toList</code> на цьому <code>TreeSet</code>.</p></div>
<div class="paragraph"><p>Однак майте на увазі, що перетворення між списками та масивами звичайно потребує копіювання всіх елементів в колекції, і, таким чином, можуть бути повільними для великих колекцій. Хоча іноді вам треба зробити це через існуюче API. Більше того, багато колекцій мають лише декілька елементів, і в цьому випадку існує лише мала втрата швидкості.</p></div>
</div>
<div class="sect2">
<h3 id="________">Перетворення між змінними та незмінними множинами або мапами</h3>
<div class="paragraph"><p>Інша ситуація, що часом постає, є потреба конвертувати змінну множину або мапу до незмінної, або <em>vice versa</em>. Щоб досягти цього, ви можете використати прийом, показаний на попередній сторінці, для ініціалізації <code>TreeSet</code> елементами списку. Створіть колекцію нового типу, використовуючи метод <code>empty</code>, та потім додайте нові елементи, використовуючи або <code>++</code>, або <code>++=</code>, що відповідає до типу цільової колекції. Ось як ви конвертуєте незмінний <code>TreeSet</code> з попереднього прикладу до змінної множини, та назад до незмінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">treeSet</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">scala.collection.immutable.TreeSet</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">TreeSet</span><span class="o">(</span><span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">red</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mutaSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">++=</span> <span class="n">treeSet</span>
<span class="n">mutaSet</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">immutaSet</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">++</span> <span class="n">mutaSet</span>
<span class="n">immutaSet</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span><span class="n">red</span><span class="o">,</span> <span class="n">blue</span><span class="o">,</span> <span class="n">green</span><span class="o">,</span> <span class="n">yellow</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете використовувати той самий прийом для конвертації змінних та незмінних мап:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">muta</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;i&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;ii&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">muta</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">ii</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">immu</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span> <span class="o">++</span> <span class="n">muta</span>
<span class="n">immu</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Map</span><span class="o">(</span><span class="n">ii</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_17_5_">17.5 Тапли</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як описане в Кроці 9 в Главі 3, типл комбінує фіксоване число елементів разом, так що вони можуть бути передані будь-куди як ціле. На відміну від масиву або списка, тапл може зберігати об'єкти різних типів. Ось приклад тапла, що містить ціле, рядок та консоль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;hello&quot;</span><span class="o">,</span> <span class="nc">Console</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тапли вберігають вам від нудьги визначати прості класи даних. Навіть зважаючи, що визначення класу вже просте, воно все ще потребує мінімальних зусиль, що іноді на до чого. Тапли вберігають вас від зусиль обирати ім'я файлу, обирати поле видимості, в якому треба визначити клас, та обрати імена для членів класу. Якщо ваш клас просто містить ціле та рядок, не додасться ясності, якщо ви визначите клас на ім'я <code>AnIntegerAndAString</code>.</p></div>
<div class="paragraph"><p>Оскільки тапли можуть комбінувати об'єкти різних типів, тапли не наслідують від <code>Traversable</code>. Якщо ви бажаєте згруаувати рівно одне ціле і один рядок, тоді вам треба тапл, не <code>List</code> або <code>Array</code>.</p></div>
<div class="paragraph"><p>Загальне застосування таплів є повернення декількох значень з метода. Наприклад, ось метод, що знаходить найдовше слово в колекції, що також повертає індекс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">longestWord</span><span class="o">(</span><span class="n">words</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">word</span> <span class="k">=</span> <span class="n">words</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">var</span> <span class="n">idx</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="n">words</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">words</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">word</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">word</span> <span class="k">=</span> <span class="n">words</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="n">idx</span> <span class="k">=</span> <span class="n">i</span>
  <span class="o">}</span>
  <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">idx</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад, що використовує цей метод:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">longest</span> <span class="k">=</span>
         <span class="n">longestWord</span><span class="o">(</span><span class="s">&quot;The quick brown fox&quot;</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span>
<span class="n">longest</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">quick</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>longestWord</code> обчислює два елементи: <code>word</code>, найдовше слово в масиві, та <code>idx</code>, індекс цього слова. Щоб утримувати речі простими, функція вважає, що в списку є хоча б одне слово, і він вирішує спірні питання, обираючи слово, що іде раніше в списку. Коли функція обирає, яке слово та індекс повертати, вона повертає обоє з них разом, використовуючи синтаксис тапла <code>(word, idx)</code>. Щоб отримати доступ до елементів в таплі, ви можете використати метод <code>_1</code> для доступу до першого елементу, <code>_2</code> для доступу до другого, і так далі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">longest</span><span class="o">.</span><span class="n">_1</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">quick</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">longest</span><span class="o">.</span><span class="n">_2</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Додатково, ви можете присвоїти кожний елемент тапла до власної змінної,<span class="footnote"><br />[Насправді, цей синтаксис є особливим випадком порівняння шаблонів, як описано в деталях в Розділі 15.7.]<br /></span> ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">idx</span><span class="o">)</span> <span class="k">=</span> <span class="n">longest</span>
<span class="n">word</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">quick</span>
<span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">word</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">quick</span>
</pre></div></div></div>
<div class="paragraph"><p>Доречі, якщо ви відкинете дужки, ви отримаєте інший варіант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">word</span><span class="o">,</span> <span class="n">idx</span> <span class="k">=</span> <span class="n">longest</span>
<span class="n">word</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">quick</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
<span class="n">idx</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">quick</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей синтаксис дає <em>множинні визначення</em> того самого виразу. Кожна змінна ініціалізована власним обчисленням виразу в правій стороні. Те, що в даному випадку цей вираз обчислюється до тапла, не має значення. Обоє змінні ініціалізуються таплом, як цілим. Дивіться Главу 18 для деяких прикладів, де множинні визначення є зручними.</p></div>
<div class="paragraph"><p>В якості попередження, тапли загалом дуже прості в використанні. Тапли чудові, коли ви комбінуєте дані, що не мають значення, крім "якесь A та якесь B." Однак, коли комбінація має якесь значення, або ви бажаєте додати якісь методи до комбінації, краще піти далі, та створити клас. Наприклад, не використовуйте 3-місний тапл для комбінації місяця, дня та року. Створіть клас <code>Date</code>. Це зробить ваші наміри явними, що одночасно прояснює код для людей, та дає компілятору та мові можливість допомогти вам відловлювати помилки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_17_6_">17.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава надала огляд бібліотеки колекцій Scala, та найбільш важливі класи та трейти в ній. З цією основою ви маєте бути в змозі робити ефективно зі Scala колекціями, та знати, куди дивитись в Scaladoc, якщо вам треба більше інформації. Для більш детальної інформації щодо Scala колекцій, дивіться далі, в Главі 24 та Главі 25. До того часу, в наступній главі ми перенесемо нашу увагу від бібліотеки Scala назад на мову, та обговоримо підтримку Scala для змінних об'єктів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-28 04:03:37 EET
</div>
</div>
</body>
</html>
