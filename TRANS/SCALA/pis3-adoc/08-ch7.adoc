include::headers.adoc[]

Глава 7
-------

Вбудовані керівні структури
===========================

Scala має тілько декілька вбудованих керівних структур. Все що є тільки: `if`, `while`, `for`, `try`, `match`, та виклики функцій. Причина, з якої Scala має їх так мало, включає функціональні літерали з моменту свого створення. Замість накопичення в своєму синтаксисі однієї за одною високорівневих керівних структір, Scala накопичує їх в бібліотеках. (Глава 9 покаже в точності, як це зроблене.) Ця глава покаже ті декілька керівних структур, що є вбудованими.

Одна річ, що ви помітите, це що майже всі керівні структури в Scala призводять до деякого результату. Цей підхід взятий від функціональних мов, де програми розглядаються як обчислення значення, так що компоненти програми також повинні обчислювати значення. Ви також можете розглядати цей підхід як логічний висновок з тренду, що вже присутній в імперативних мовах. В імперативних мовах виклики функцій можуть повертати значення, навіть коли викликана функція так само гарно може просто оновити значення вихідної змінної, переданої як аргумент. На додаток, імперативні мови часто мають тримісний оператор (такий як оператор `?:` в C, C++ та Java), що ефективно поводиться як `if`, але результатом є значення. Scala адаптує цю модель тримісного оператора, але називає його `if`. Іншими словами,в Scala `if` може повертати значення. Потім Scala продовжує цей тренд, маючи `for`, `try` та `match`, що також повертають значення.

Програмісти можуть використовувати ці значення для спрощення свого коду, так само, якби вони використовували значення повернуті з функцій. Без цієї можливості програміст має створювати тимчасові змінні, тільки щоб зберігати результати, що обчислюються всередині керівної структури. Видалення ціх змінних робить код  трохи простішим, та він також запобігає багатьом вадам, коли ви встановлюєте змінну в одній гілці, але забуваєте встановити в іншому.

Загалом, базові керівні структури Scala, мінімальні як вони є, провадяться всі основи з імперативних мов. Більше того, вони дозволяють скоротити ваш код, узгоджена маючі значення результату. Щоб показати, як це робить, давайте подивимось на базові керівні структури Scala. 

7.1 Вирази 'if'
--------------- 
В Scala `if` робить так само, як і в багатьох інших мовах. Він перевіряє умову, і потім виконує одну з двох гілок коду, в залежності чи умова виконується. Ось загальний приклад, написаний в імперативному стилі: 
[source,scala]
----
var filename = "default.txt"
if (!args.isEmpty)
  filename = args(0)
----
Цей код декларує змінну `filename`, та ініціалізує її значенням по замовчанню. Потім він виконує вираз `if`, щоб перевірити, чи програмі були надані якісь аргументи. Якщо це так, значення змінної змінюється, щоб вона містила значення, вказане в списку аргументів. Якщо аргументи не надані, змінна залішається встановленою в значення по замовчанню.

Цей код може бути записаний краще, оскільки, як зазначалось в Кроці 3 в Главі 2, в Scala `if` є виразом, що повертає значення. Лістинг 7.1 показує, як ви можете досягти того самого ефекту, що і в попередньому прикладі, без використання жодних `var`:
[source,scala]
----
val filename =
if (!args.isEmpty) args(0)
  else "default.txt"
----
Лістинг 7.1 - Ідіома Scala для умовної ініціалізації.

На цей раз `if` має дві гілки. Якщо аргументи не порожні, буде обраний перший елемент, `args(0)`; інакше буде обране значення по замовчанню. Вираз `if` має результат в вигляді обраного значення, і змінна `filename` ініціалізується цім значенням. Цей код трохи коротший, але його справжня перевага в тому, що він використовує `val` замість `var`. Використання `val` є функціональним стилем, і це допомагає вам майже в той спосіб, що і використання фінальних змінних в Java. Це каже читачам коду, що змінна ніколи не буде змінюватись, вберігаючи їх від сканування всього коду в полі зору змінної, дивлячись, чи вона не змінилась.

Друга перевага використовувати `val` замість `var` в тому, що вони краще підтримують розуміння рівнянь. Введене значення еквівалентне до виразу, що обчислює його, припускаючи, що вираз не має побічних ефектів. Таким чином, кожного разу, коли ви збираєтесь записати ім'я змінної, замість нього ви можете записати вираз. Наприклад, замість `println(filename)`, ви можете просто записати це:
[source,scala]
----
println(if (!args.isEmpty) args(0) else "default.txt")
----
Вибір за вами. Ви можете записати це любим способом. Використання `vals` допомагає вам безпечно робити цей тип рефакторингу, по мірі того, як ваш код буде розвиватись з часом. Шукайте можливості використовувати `val`. Вони можуть зробити ваш код більш простим для читання, та простішим для рефакторингу.

7.2 Цикли while
---------------
Scala's while loop behaves as in other languages. It has a condition and a body, and the body is executed over and over as long as the condition holds true. Listing 7.2 shows an example:
[source,scala]
----
def gcdLoop(x: Long, y: Long): Long = {
  var a = x
  var b = y
  while (a != 0) {
    val temp = a
    a = b % a
    b = temp
  }
  b
}
-----
Лістинг 7.2 - Обчислення найбільшого загального дільника за допомогою цикла `while`.

Scala також має цикл `do-while`. Він робить як цикл `while`, за винятком того, що він перевіряє умову після тіла циклу, а не до. Лістинг 7.3 показує скрипт Scala, що використовує `do-while` для відлуння рядків, введених в стандартний вивід, докі не буде введений порожній рядок:
[source,scala]
----
var line = ""
do {
  line = readLine()
  println("Read: " + line)
} while (line != "")
----
Лістинг 7.3 - Читання зі стандартного вводу за допомогою do-while.

Конструкції `while` та `do-while` називаються "циклами", а не виразами, оскільки вони не продукують цікавого значення. Тип результата є `Unit`. Існує одне значення цього (та загалом тільки одне) типу `Unit`. Воно називається юніт значенням, та записується `()`. Існування `()` є тим, як Scala `Unit` відрізняється від Java `void`. Спробуйте це в інтерпретаторі:
[source,scala]
----
scala> def greet() = { println("hi") }
greet: ()Unit

scala> () == greet()
hi
res0: Boolean = true
----
Оскільки перед тілом немає знаку рівняння, `greet` визначене як процедура з типом результата `Unit`. Таким чином, `greet` повертає юніт значення `()`. Це підтверджується в наступному рядку: порівнюючи результат `greet` на рівність з юніт значенням `()`, що дає `true`. 

Одна інша конструкція, що має результат в вигляді юніт значення, що релевантне тут, є переприсвоєння до `vars`. Наприклад, коли ви намагаєтесь читати рядки в Scala, використовуючи наступну ідіому Java, цикл `while` (та C і C++), ви потрапите в небезпеку:
[source,scala]
----
var line = ""
while ((line = readLine()) != "") // Це не робить!
  println("Read: " + line)
----
Коли ви компілюєте цей код, Scala надасть вам попередження, що порівняння значень типів `Unit` та `String` з використанням `!=` буде завжди давати `true`. Тоді як в Java присвоєння скінчиться присвоєнням значення (в цьому випадку рядка зі стандартного вводу), в Scala присвоєння завжди зкінчиться юніт значенням, `()`. Таким чином, значення присвоєння `line = readLine()` завжди буде `()`, та ніколи не буде `""`. Як результат, умова цього цикла `while` ніколи не буде `false`, і, таким чином, цикл ніколи не завершиться.

Оскікльки цикл `while` не призводить до значення, він часто відсутній в чисто функціональних мовах. Такі мови мають вирази, а не цикли. Тим не менш, Scala включає цикл `while`, оскільки деякі імперативні рішення можуть бути більш читабельні, особливо для програмістів з переважно імперативним досвідом. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує процес докі деяка умова не зміниться, цикл `while` може виразити це напряму, тоді як функціональна альтернатива, що вірогідно використовуватиме рекурсію, може бути менш очевидною для деяких читачів коду.

Наприклад, Лістинг 7.4 показує альтернативний шлях визначити найбільший загальний дільник двох чисел.footnote:[Функція gcd, показана в Лістингу 7.4, використовує той самий підхід, що використовується в подібно-названій функції, спершу показаній в Лістингу 6.3, щоб обчислювати найбільший загальний дільник для класу Rational. Головна різниця в тому, що замість Int, gcd з Лістингу 7.4 робить з Long.] Беручи деякі два значення для `x` та `y`, функція `gcd`, показана в Лістингу 7.4 буде повертати той самий результат, що і `gcdLoop` функція, показана в Лістингу 7.2. Різниця між ціма двома підходами а тому, що `gcdLoop` написана в імперативному стилі, використовуючи `var` та цикл `while`, тоді як `gcd` написане в більш функціональному стилі, що включає рекурсію (`gcd` викликає себе), та не потребує `var`.
[source,scala]
----
def gcd(x: Long, y: Long): Long =
  if (y == 0) x else gcd(y, x % y)
----
Лістинг 7.4 - Обчислення найбільшого загального дільника за допомогою рекурсії.

Загалом, ми рекомендуємо вас кидати виклик циклам `while` в вашому коді, так само, як ви кидаєте виклик `var`. Фактично, цикли `while` та `var` часто ідуть рука об руку. Оскільки цикли `while` не видають результату, щоб призвести до якіхось змін в вашій програмі, цикл  `while` буде звичайно оновлювати `var` або виконувати I/O. Ви можете бачити це в дії в `gcdLoop`, показаному раніше. По мірі того, як цикл `while` робить свою справу, він оновлює `var` `a` та `b`. Таким чином, ми радимо вам бути трохи підозрілим щодо циклів `while` в вашому коді. Якщо немає гарного обгрунтування для окремого використання циклів `while` або `do-while`, спробуйте знайти спосіб зробити те саме без них.

7.3 Вирази for
--------------
Вираз `for` в Scala є швейцарським розкладним ножем ітерації. Він дозволяє комбінувати декілька простих інструментів в різний спосіб, щоб виразити широку різноманітність ітерацій. Прості використання дозволяють вирішувати загальні завдання, такі, як ітерація по послідовності цілих. Більш розвинені вирази можуть ітерувати по декількох колекціях різних типів, фільтрувати елементи на основі довільних умов, та продукувати нові колекції.

Ітерації по колекціях
~~~~~~~~~~~~~~~~~~~~~
Простіша річ, що ви можете зробити за допомогою `for` це ітерувати по всіх елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що друкує всі файли в поточній директорії. I/O виконується з використанням Java API. Зпочатку ми створюємо `java.io.File` на поточній директорії,".", та викликаємо його метод `listFiles`. Цей метод повертає масив з об'єктів `File`, по одному для кожної директорії та файлу, що містяться в поточній директорії. Ми зберігаємо отриманий масив в змінній `filesHere`.
[source,scala]
----
val filesHere = (new java.io.File(".")).listFiles

for (file <- filesHere)
  println(file)
----
Лістинг 7.5 - Перелічує файли в поточній директорії за допомогою вираза `for`.

За допомогою синтаксиса `file <- filesHere`, що називається _генератором_, ми ітеруємо по елементах `filesHere`. В кожній ітерації ініціалізується нова `val` на ім'я `file` зі значенням елемента. Компілятор виводить тип `file` як `File`, оскільки `filesHere` має тип `Array[File]`. Для кожної ітерації буде виконане тіло вираза, `println(file)`. Оскільки в `File` метод `toString` видає ім'я файла або директорії, будуть роздруковані імена всіх файлів та директорій в поточній директорі.

Синтаксис виразу `for` робить для любого типу колекції, не тільки для масивів.footnote:[Щоб бути точним, вираз зправа від символа `<-` в виразі for може бути любого типу, що має певні методи (в цьому випадку foreach) з відповідними сигнатурами. Деталі щодо того, як компілятор Scala обробляє вирази `for` описані в Главі 23.] Один зручний особливий випадок є тип `Range`, що ви похопцем бачили в Таблиці 5.4. Ви можете створити `Range` з використанням синтаксису як `1 to 5`, та можете ітерувати по ньому за допомогою `for`. Ось простий приклад:
[source,scala]
----
scala> for (i <- 1 to 4)
  println("Iteration " + i)
Iteration 1
Iteration 2
Iteration 3
Iteration 4
----
Якщо ви не бажаєте включати верхню межу диапазона в значення, по яких піде ітерація використовуйте `until` замість `to`:
[source,scala]
----
scala> for (i <- 1 until 4)
  println("Iteration " + i)
Iteration 1
Iteration 2
Iteration 3
----
Ітерація по цілим, як ця, є загальною в Scala, але не так сильно, як в інших мовах. В інших мовах ви можете використати цю можливість для ітерації по масиву, ось так:
[source,scala]
----
// Не загальне в Scala...
for (i <- 0 to filesHere.length - 1)
  println(filesHere(i))
----
Цей вираз `for` вводить змінну `i`, встановлює її по черзі в коже ціле між `0` та `filesHere.length - 1`, та виконує тіло виразу для кожного встановленого `i`. Для кожного встановленого `i`, `i`тий елемент `filesHere` отримується та обробляється.

Причина, з якої цей тип ітерації менш загальний в Scala в тому, що ви можете ітерувати по колекції напряму. Коли ви робите це, ваш код стає коротшим, та ви обходите багато "помилкових помилок", що можуть виникати, коли ви ітеруєте по масивах. Маєте ви почати з 0 або 1? Маєте ви додавати -1, +1, або нічого до фінального значення? На такі запитання легко відповісти, але також легко відповісти помилково. Безпечніше взагалі повністю уникати таких запитань.

Фільтрація
~~~~~~~~~~
Іноді ви не бажаєте ітерувати по повній колекції; ви бажаєте відфільтрувати її до деякої підмножини. Ви можете зробити це за допомогою вираза `for` через додавання фільтра, твердження `if` всередині дужок `for`. Наприклад, код, показаний в Лістингу 7.6, перелічує тільки ті файли в поточній директорії, чиї імена закінчуються на `.scala`:
[source,scala]
----
val filesHere = (new java.io.File(".")).listFiles
for (file <- filesHere if file.getName.endsWith(".scala"))
  println(file)
----
Лістинг 7.6 - Пошук файлів `.scala` використовуючи `for` з фільтром.

Ви можете альтернативно досягти тієї самої цілі за допомогою цього коду:
[source,scala]
----
for (file <- filesHere)
  if (file.getName.endsWith(".scala"))
println(file)
----
Цей код дає той самий вихід, що і попередній код, та, можливо, виглядає більш знайомим для програмістів з імперативним підгрунтям. Однак імперативна форма є тільки цибулиною, оскільки цей часний вираз `for` викликається тільки для побічного ефекту друкування, і має результатом юніт значення `()`. Як буде показано далі в цьому розділі, вираз `for` названий "виразом", оскільки він може давати в результаті цікаве значення, колекцію, тип якої визначається твердженням `<-` виразу `for`.

Ви можете включити більше фільтрів, якщо ви бажаєте. Просто продовжуйте додавати фільтри `if`. Наприклад, щоб бути екстра захищеним, код в Лістингу 7.7 друкує тільки файли, але не директорії. Він робить це через додавання фільтрів, що перевіряють метод `isFile` для файлів.
[source,scala]
----
for (
  file <- filesHere
    if file.isFile
  if file.getName.endsWith(".scala")
) 
println(file)
----
Лістинг 7.7 - Використання декількох фільтрів в виразі `for`.

Вкладена ітерація
~~~~~~~~~~~~~~~~~
Якщо ви додасте декілька тверджень `<-`, ви отримаєте вкладені "цикли". Наприклад, вираз `for`, показаний в Лістингу 7.8 має два вкладених цикли. Зовнішній цикл ітерує по `filesHere`, та внутрішній ітерує по `fileLines(file)` для кожного файлу, що закінчується на `.scala`.
[source,scala]
----
def fileLines(file: java.io.File) =
  scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
  for (
    file <- filesHere
    if file.getName.endsWith(".scala");
    line <- fileLines(file)
    if line.trim.matches(pattern)
  ) println(file + ": " + line.trim)
grep(".*gcd.*")
----
Лістинг 7.8 - Використання декількох генераторів в виразі `for`.

Якщо ви бажаєте, ви можете використовувати фігурні дужки замість звичайних дужок щоб оточити генератори та фільтри. Одна з переваг використання фігурних дужок в тому, що ви можете відкинути деякі з крапок з комою, що потрібні вам, коли ви використовуєте дужки, бо, як пояснено в Розділі 4.2, компілятор Scala не буде виводити коми з крапками, коли знаходиться в дужках.

Серед-поточні прикріплення змінних
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зауважте, що в попередньому коді повторюється вираз `line.trim`. Це нетривіальне обчислення, так що ви можете побажати обчислити його тільки один раз. Ви можете зробити це, прикріпивши результат до нової змінної, використовуючи знак рівності (=). Прикріплена змінна буде створена, та використовується як звичайна `val`, тільки без ключового слова `val`. Лістинг 7.9 показує приклад.
[source,scala]
----
def grep(pattern: String) = for {
  file <- filesHere
  if file.getName.endsWith(".scala")
  line <- fileLines(file)
  trimmed = line.trim
  if trimmed.matches(pattern)
} println(file + ": " + trimmed)
grep(".*gcd.*")
----
Лістинг 7.9 - Серед-поточне присвоєння в виразі `for`.

В Лістингу 7.9 змінна на ім'я `trimmed` вводиться посеред виразу `for`. Ця змінна ініціалізована результатом `line.trim`. Потім залишок виразу використовує її в двох місцях, один раз в `if`, та ще раз в `println`.

Продукування нової колекції
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Хоча доки всі приклади тільки оперували з ітерованими значеннями, та потім забували їх, ви також можете генерувати значення, що буде запам'ятовуватись на кожній ітерації. Щоб зробити це, ви ставите перед тілом виразу `for` ключове слово `yield`. Наприклад, ось функція, що ідентифікує файли `.scala`, та зберігає їх в масиві:
[source,scala]
----
def scalaFiles =
  for {
    file <- filesHere
    if file.getName.endsWith(".scala")
} yield file
----
Кожний раз, коли виконується тіло виразу, воно продукує одне значення, в цьому разі просто `file`. Коли вираз `for` завершується, результат буде включати всі з отриманих значень, що міститимуться в одній колекції. Тип отриманої колекції базується на типі колекцій, оброблених в твердженнях ітерації. В цьому випадку результат буде  `Array[File]`, оскільки `filesHere` є масивом, і тип отриманого виразу є `File`.

Будьте уважні, поміж всього, коли ви розташовуєте ключове слово `yield`. Синтаксис виразу `for-yield` виглядає так:
[source,scala]
----
for clauses yield body
----
`yield` іде перед всім тілом. Навіть якщо тіло є блок, оточений фігурними дужками, покладіть `yield` перед першою фігурною дужкою, не перед останнім виразом в блоці. Уникайте спокуси писати речі, подібні до цього:
[source,scala]
----
for (file <- filesHere if file.getName.endsWith(".scala")) {
  yield file // Синтаксична помилка!
}
----
Наприклад, вираз `for`, показаний в Лістингу 7.10 спочатку трансформує `Array[File]` на ім'я `filesHere`, що містить всі файли в поточній директорії, до такого, що містить тільки файли `.scala`. Для кожного з них він генерує `Iterator[String]`, результат метода `fileLines`, чиє визначення показане в Лістингу 7.8. `Iterator` пропонує методи `next` та `hasNext`, що дозволяють вам ітерувати по колекції елементів. Цей внутрішній ітератор трансформується в інший ітератор ` Iterator[String]`, який містить тільки обрізані рядки, що містять субрядок `"for"`. Нарешті, для кожного з них, видається ціла довжина. Результатом цього виразу `for` є `Array[Int]`, що містить довжини.
[source,scala]
----
val forLineLengths =
  for {
    file <- filesHere
    if file.getName.endsWith(".scala")
    line <- fileLines(file)
    trimmed = line.trim
    if trimmed.matches(".*for.*")
  } yield trimmed.length
----
Лістинг 7.10 - Трансформування `Array[File]` на `Array[Int]` з допомогою `for`.

В цій точці ви бачили всі головні функції виразів Scala `for`, але ми пройшли по них дуже швидко. Більш докладне покриття виразів `for` надається в Главі 23.

7.4 Обробка виключень за допомогою виразів try
----------------------------------------------
Виключення Scala поводяться як в багатьох інших мовах. Замість повернення значення в в нормальний спосіб, метод може завершитись викликом виключення. Викликач метода може або перехопити та обробити це виключення, або він може сам по собі завершитись, що спричинить поширення виключення до викликача викликача. Виключення розповсюджується в такий спосіб, розкручуючи стек викликів, доки метод не обробить його, або доки не залишиться методів.

Виклик виключень
~~~~~~~~~~~~~~~~
Виклик виключення в Scala виглядає так само, як і в Java. Ви створюєте об'єкт виключення, та потім закидаєте його ключовим словом `throw`:
[source,scala]
----
throw new IllegalArgumentException
----
Хоча це може виглядати трохи парадоксальним, в Scala `throw` є виразом, що має тип результа. Ось приклад, коли тип результата має значення:
[source,scala]
----
val half =
  if (n % 2 == 0)
    n / 2
  else
    throw new RuntimeException("n must be even")
----
Що тут трапиться, коли `n` є парним - `half` буде ініціалізоване до половини `n`. Якщо воно не парне, буде викликане виключення перед тим, як `half` взагалі зможе бути ініціалізоване. Через це, безпечно трактувати закидання виключення як взагалі будь-який тип. Любий контекст, що намагатиметься використовувати повернення з `throw`, ніколи не зможе цього зробити, так що не слід чекати ніякої шкоди.

Технічно `throw` виключення має тип `Nothing`. Ви можете використовувати `throw` як вираз, навіть якщо він ніколи нічого не обчислює. Цей невеликий шматок технічної гімнастики може виглядати збоченим, але часто корисний в випадках, як попередній приклад. Одна з гілок `if` обчислює значення, тоді як інша закидає виключення, та обчислює `Nothing`. Тип цілого виразу `if` після цього є типом тієї гілки, що щось обчислює. Тип `Nothing` дискутується далі в Розділі 11.3.

Перехоплення виключень
~~~~~~~~~~~~~~~~~~~~~~
Ви перехоплюєте виключення, використовуючи синтаксис, показаний в Лістингу 7.11 Синтаксис для тверджень `catch` був обраний за його узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння шаблонів, потужна можливість, коротко описана в цій главі, та в більших деталях в Главі 15.
[source,scala]
----
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException
try {
  val f = new FileReader("input.txt")
// Використовуємо та зачиняємо файл
} catch {
  case ex: FileNotFoundException => // Обробляємо відсутній файл
  case ex: IOException => // Обробляємо помилки I/O
}
----
Лістинг 7.11 - Твердження `try-catch` clause in Scala.

Поведінка цього виразу `try-catch` така сама, як і інших мов з виключенями. Тіло виконується, та якщо виникає виключення, кожне твердження `catch` викликається по черзі. В цьому прикладі, якщо виникає включення типу `FileNotFoundException`, буде виконане перше твердження. Якщо тип виключення `IOException`, виконується друге твердження. Якщо виключення не одного з ціх типів, `try-catch` завершиться, та виключення розповсюдиться далі.

NOTE: Одна різниця, що ви швидко зауважите, в тому, що на відміну від Java, Scala не вимагає від вас перехоплювати перевірені виключення, або декларувати їх в твердженні `throws`. Ви можете декларувати `throws`, якщо бажатєте, за допомогою анотації `@throws`, але це не вимагається. Дивіться Розділ 31.2 для додаткової інформації щодо `@throws`.

Твердження finally
~~~~~~~~~~~~~~~~~~
Ви можете огорнути вираз за допомогою твердження `finally`, якщо ви бажаєте виконати деякий код, не важливо як скінчиться вираз. Наприклад, ви можете побажати переконатись, що відкритий файл буде закритий, навіть якщо метод завершується виникненням виключення. Лістинг 7.12 показує приклад.footnote:[Хоча ви маєте завжди оточувати твердження case в catch в дужки, try та finally не потребують дужок, якщо вони містять тільки один вираз. Наприклад, ви можете написати: try t() catch { case e: Exception => ... } finally f().]
[source,scala]
----
import java.io.FileReader
val file = new FileReader("input.txt")
try {
// Використовуємо файл
} finally {
  file.close() // Переконуємось що зачинили файл
}
----
Лістинг 7.12 - Твердження `try-finally` в Scala.

NOTE: Лістинг 7.12 показує ідиоматичний спосіб переконатись, що об'єкт не-з-пам'яті, такий як файл, сокет або з'єднання з базою даних, є зачинений. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок `try`, в якому ви використовуєте ресурс. Нарешті, ви зачиняєте ресурс в блоці `finally`. Ця ідіома є тою самою в Scala, як в Java; альтернативно, в Scala ви можете задіяти прийом з назвою _шаблон позичання_, щоб досягти цієї цілі більш стисло. Шаблон позичання буде описаний в Розділі 9.4.

Отримання значення
~~~~~~~~~~~~~~~~~~
Як і з багатьма іншими керівними структурами Scala, `try-catch-finally` повертає значення. Наприклад, Лістинг 7.13 показує, як ви можете спробувати розібрати URL, але використати значення по замовчанню, якщо URL погано сформований. Результатом є те, що полишає твердження `try`, якщо не виникло виключення, або відповідний код `catch`, якщо виключення виникло і було перехоплене. Якщо виключення було закинуте, але не перехоплене, вираз взагалі не має результату. Значення, обчислене в твердженні `finally`, якщо таке є, відкидається. Звичайно в `finally` робиться деякий різновид очищення, такий як закриття файлів. Звичайно, вони не мають змінювати значення, обчислене в головному тілі або блоці `catch` твердження `try`.
[source,scala]
----
import java.net.URL
import java.net.MalformedURLException
def urlFor(path: String) =
  try {
    new URL(path)
  } catch {
    case e: MalformedURLException =>
      new URL("http://www.scala-lang.org")
  }
----
Лістинг 7.13 - Твердження `catch`, що надає значення.

Якщо ви знайомі з Java, вам зрозуміло, що поведінка Scala відрізняється від Java `try-finally` тільки в тій частині, що остання не повертає значення. Як і в Java, якщо твердження `finally` включає явне твердження `return`, або закидає виключення, значення повернення або виключення буде "анулювати" любі попередні значення, що походять з блоку `try` або з одного з його тверджень `catch`. Наприклад, маючи таке, скоріше надумане, визначення функції:
[source,scala]
----
def f(): Int = try return 1 finally return 2
----
виклик f() дає 2. Для контрасту, маючи:
[source,scala]
----
def g(): Int = try 1 finally 2
----
виклик g() дає 1. Обоє з ціх функцій показують поведінку, що може здивувати багатьох програмістів, так що зазвичай краще уникати повернення значень з твердження `finally`. Кращий спосіб думати про блок `finally`, як про спосіб переконатись, що відбувся деякий побічний ефект, такий як зачинення відкритого файлу.

7.5 Вирази match
----------------
В Scala вираз `match` дозволяють вам обрати з декількох альтернатив, так само, як твердження `switch` в інших мовах. Загалом, вираз `match` дозволяє вам зробити вибір, використовуючі довільні шаблони, що будуть описані в Главі 15. Загальна форма може почекати. Доки розглянемо тільки використання `match` для обрання між декількома альтернативами.

Як приклад, скрипт в Лістингу 7.14 читає назву їжі зі списку аргументів, та друкує додаток до цієї їжі. Цей вираз `match` перевіряє `firstArg`, що була встановлена в перший аргумент зі списку аргументів. Якщо рядок є `"salt"`, друкується `"pepper"`, та якщо рядок `"chips"`, друкується `"salsa"`, і так далі. Випадок по замовчанню вказаний підкресленням (`_`), підстановочним символом, що часто використовується в Scala як заміщувач для повністю невідомого значення.
[source,scala]
----
val firstArg = if (args.length > 0) args(0) else ""
firstArg match {
  case `"salt"` => println("pepper")
  case "chips" => println("salsa")
  case "eggs" => println("bacon")
  case _ => println("huh?")
}
----
Лістинг 7.14 - Вираз `match` з побічними ефектами.

Існує декілька важливих відмінностей від твердження Java `switch`. Одна в тому, що любий різновид констант, так само як і інших речей, може використовуватись в `case` в Scala, не тільки цілі типи, enum, та константи рядків в твердженнях Java `case`. В Лістингу 7.14 альтернативами є рядки. Інша відмінність в тому, що нема переривань `break` в кінці кожної альтернативи. Замість цього, `break` є неявним, і немає провалювання від однієї альтернативи до іншої. Загальний випадок — відсутність провалювання — стає коротший, та уникається джерело помилок, оскільки програмісти більше не провалюватимуться випадково.

Однак найбільш значуща різниця з Java `switch` може полягати в тому, що вирази `match` повертають значення. В попередньому прикладі кожна з альтернатив в виразі `match` друкує значення. Також гарно буде робити повернення значення, ніж його друк, як показано в Лістингу  7.15. Значення, що є результатом цього виразу `match`, зберігається в змінній `friend`. Крім того, що код став коротший (в любому випадку за числом токенів), код тепер розрізняє дві різні турботи: спочатку він обирає їжу, та потім друкує її.
[source,scala]
----
val firstArg = if (!args.isEmpty) args(0) else ""
val friend =
  firstArg match { 
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    case _ => "huh?"
  }
println(friend)
----
Лістинг 7.15 - Вираз `match`, що продукує значення.

7.6 Життя без break та continue
-------------------------------
Ви, можливо, помітили, що ми не споминули `break` або `continue`. Scala полишила ці дві команди, оскільки вони не дуже гарно перетинаються з функціональними літералами, можливістю, описаною в наступній главі. Ясно, що значить `continue` означає в циклі `while`,але що воно може значити в функціональному літералі? Хоча Scala підтримує обоє, імперативний та функціональний стилі програмування, в цьому випадку вона трохи схиляється до функціонального програмування, в обмін на спрощення мови. Однак не турбуйтесь. Існує багато шляхів програмувати без `break` та `continue`, та якщо ви отримаєте переваги функціональних літералів, ці альтернативи можуть часто бути коротші, ніж оригінальний код.

Найпростіший підхід є замінити кожний `continue` на `if`, та кожний `break` на логічну змінну. Логічна змінна вказує, чи оточуючий цикл має продовжуватись. Наприклад, уявімо, що ви шукаєте в списку аргументів рядок, що закінчується на `".scala"` але не починається на дефіс. В Java ви можете — якщо ви великий прихильник циклів `while`, `break` та `continue` — написати наступне:
[source,java]
----
int i = 0;
// Це Java
boolean foundIt = false;
while (i < args.length) {
    if (args[i].startsWith("-")) {
        i = i + 1;
        continue;
    }
    if (args[i].endsWith(".scala")) {
        foundIt = true;
        break;
    }
    i = i + 1;
}
----
Щоб перекласти цей Java код прямо на Scala, замість робити `if` та потім `continue`, ви можете написати `if`, що оточує весь залишок цикла `while`. Щоб позбавитись `break`, ви можете звичайно додати логічну змінну, що вказує, чи варто продовжувати, але в цьому випадку ми можемо повторно використати `foundIt`. Викорисистовуючи обоє з ціх трюків, код приходить до вигляду, як показано на Лістингу 7.16.
[source,scala]
----
var i = 0
var foundIt = false

while (i < args.length && !foundIt) {
  if (!args(i).startsWith("-")) {
    if (args(i).endsWith(".scala"))
      foundIt = true
  }
  i = i + 1
}
----
Лістинг 7.16 - Цикл без `break` або `continue`.

Цей Scala код в Лістингу 7.16 досить подібний до оригінального Java коду. Всі базові частини все ще тут, і в тому ж порядку. Є дві переприсвоювані змінні та цикл `while`. В циклі є перевірка, що `i` менше ніж `args.length`, перевірка на `"-"`, та перевірка на `".scala"`.

Якщо ви бажаєте позбутись `var` в Лістингу 7.16, один підхід, що ви можете спробувати, це переписати цикл як рекурсивну функцію. Ви можете, наприклад, визначити функцію `searchFrom`, що приймає ціле на вході, шукає з цього місця, та потім повертає індекс потрібного аргументу. Використовуючи цей прийом, код буде виглядати, як показано в Лістингу 7.17:
[source,scala]
----
def searchFrom(i: Int): Int =
  if (i >= args.length) -1
  else if (args(i).startsWith("-")) searchFrom(i + 1)
  else if (args(i).endsWith(".scala")) i
  else searchFrom(i + 1)
val i = searchFrom(0)
----
Лістинг 7.17 - Рекурсивна альтернатива до циклів з `var`.

Версія в Лістингу 7.17 дає змістовне ім'я тому, що робить функція, та вона використовує рекурсію для заміни циклу. Кожне `continue` замінюється рекурсивним викликом з аргументом `i + 1`, що ефективно просуває до наступного аргументу. Багато людей знаходять, що цей стиль програмування простіший для розуміння, як тільки вони переходять до використання рекурсії.

NOTE: Компілятор Scala насправді не видасть рекурсивну функцію для коду, показаному на Лістингу 7.17. Оскільки всі рекурсівні виклики в позиції хвостового-виклику, компілятор буде генерувати код, подібний до циклу `while`. Кожний рекурсивний виклик буде реалізований як стрибок в зворотньому напрямку на початок функції. Оптимізація хвостового виклику обговорюється в Розділі 8.9.

If after all this discussion you still feel the need to use break, there's help in Scala's standard library. Class Breaks in package scala.util.control offers a break method, which can be used to exit an enclosing block that's marked with breakable. Here is an example how this library-supplied break method could be applied:
[source,scala]
----
import scala.util.control.Breaks._
import java.io._

val in = new BufferedReader(new InputStreamReader(System.in))

breakable {
  while (true) {
    println("? ")
    if (in.readLine() == "") break
  }
}
----
This will repeatedly read non-empty lines from the standard input. Once the user enters an empty line, control flow exits from the enclosing breakable, and with it the while loop.The Breaks class implements break by throwing an exception that is caught by an enclosing application of the breakable method. Therefore, the call to break does not need to be in the same method as the call to breakable.

7.7 Поле зору змінної
---------------------
Now that you've seen Scala's built-in control structures, we'll use them in this section to explain how scoping works in Scala.

Швидкий шлях для Java програмістів
----------------------------------
If you're a Java programmer, you'll find that Scala's scoping rules are almost identical to Java's. One difference between Java and Scala is that Scala allows you to define variables of the same name in nested scopes. So if you're a Java programmer, you may wish to at least skim this section.

Variable declarations in Scala programs have a scope that defines where you can use the name. The most common example of scoping is that curly braces generally introduce a newscope, so anything defined inside curly braces leaves scope after the final closing brace.footnote:[There are a few exceptions to this rule because in Scala you can sometimes use curly braces in place of parentheses. One example of this kind of curly-brace use is the alternativefor expression syntax described in Section 7.3.] As an illustration, consider the function shown in Listing 7.18.
[source,scala]
----
def printMultiTable() = {

  var i = 1
// в полі зору тільки i
  while (i <= 10) {
    var j = 1
// в полі зору i та j
    while (j <= 10) {
      val prod = (i * j).toString
// в полі зору  i, j, prod
      var k = prod.length
// в полі зору i, j, prod, k
      while (k < 4) {
        print(" ")
        k += 1
      }
    }
    print(prod)
    j += 1
 // в полі зору i та j; prod та k вийшли
  }
  println()
  i += 1
// в полі зору все ще i; j, prod, k вийшли
}
----
Listing 7.18 - Variable scoping when printing a multiplication table.

The printMultiTable function shown in Listing 7.18 prints out a multiplication table.footnote:[The printMultiTable function shown in Listing 7.18 is written in an imperative style. We'll refactor it into a functional style in the next section.] The first statement of this function introduces a variable named i and initializes it to the integer 1. You can then use the name i for the remainder of the function.

The next statement in printMultiTable is a while loop:
[source,scala]
----
while (i <= 10) {
var j = 1
...
}
----
You can use i here because it is still in scope. In the first statement inside that while loop, you introduce another variable, this time named j, and again initialize it to 1. Because the variablej was defined inside the open curly brace of the while loop, it can be used only within thatwhile loop. If you were to attempt to do something with j after the closing curly brace of thiswhile loop, after the comment that says j, prod, and k are out of scope, your program would not compile.

All variables defined in this example—i, j, prod, and k—are local variables. Such variables are "local" to the function in which they are defined. Each time a function is invoked, a new set of its local variables is used.

Once a variable is defined, you can't define a new variable with the same name in the same scope. For example, the following script with two variables named a in the same scope would not compile:
[source,scala]
----
val a = 1
val a = 2 // Не компілюється
println(a)
----
You can, on the other hand, define a variable in an inner scope that has the same name as a variable in an outer scope. The following script would compile and run:
[source,scala]
----
val a = 1;
{
  val a = 2 // Чудово компілюється
  println(a)
}
println(a)
----
When executed, the script shown previously would print 2 then 1, because the a defined inside the curly braces is a different variable, which is in scope only until the closing curly brace.footnote:[By the way, the semicolon is required in this case after the first definition of a because Scala's semicolon inference mechanism will not place one there.] One difference to note between Scala and Java is that Java will not let you create a variable in an inner scope that has the same name as a variable in an outer scope. In a Scala program, an inner variable is said to shadow a like-named outer variable, because the outer variable becomes invisible in the inner scope.

You might have already noticed something that looks like shadowing in the interpreter:
[source,scala]
----
scala> val a = 1
a: Int = 1

scala> val a = 2
a: Int = 2

scala> println(a)
2
----
In the interpreter, you can reuse variable names to your heart's content. Among other things, this allows you to change your mind if you made a mistake when you defined a variable the first time in the interpreter. You can do this because conceptually the interpreter creates a new nested scope for each new statement you type in. Thus, you could visualize the previous interpreted code like this:
[source,scala]
----
val a = 1;
{
  val a = 2;
  {
    println(a)
  }
}
----
This code will compile and run as a Scala script, and like the code typed into the interpreter, will print 2. Keep in mind that such code can be very confusing to readers, because variable names adopt new meanings in nested scopes. It is usually better to choose a new, meaningful variable name rather than to shadow an outer variable.

7.8 Рефакторинг коду в імперативному стилі
------------------------------------------
To help you gain insight into the functional style, in this section we'll refactor the imperative approach to printing a multiplication table shown in Listing 7.18. Our functional alternative is shown in Listing 7.19.
[source,scala]
----
// Returns a row as a sequence
def makeRowSeq(row: Int) =
  for (col <- 1 to 10) yield {
    val prod = (row * col).toString
    val padding = " " * (4 - prod.length)
    padding + prod
  }

// Returns a row as a string
def makeRow(row: Int) = makeRowSeq(row).mkString

// Returns table as a string with one row per line
def multiTable() = {
  val tableSeq = // a sequence of row strings
    for (row <- 1 to 10)
      yield makeRow(row)
  }

  tableSeq.mkString("\n")Listing 
}
----
7.19 - A functional way to create a multiplication table.

The imperative style reveals itself in Listing 7.18 in two ways. First, invoking printMultiTablehas a side effect: printing a multiplication table to the standard output. In Listing 7.19, we refactored the function so that it returns the multiplication table as a string. Since the function no longer prints, we renamed it multiTable. As mentioned previously, one advantage of side-effect-free functions is they are easier to unit test. To test printMultiTable, you would need to somehow redefine print and println so you could check the output for correctness. You could test multiTable more easily by checking its string result.

The other telltale sign of the imperative style in printMultiTable is its while loop and vars. By contrast, the multiTable function uses vals, for expressions, helper functions, and calls tomkString.

We factored out the two helper functions, makeRow and makeRowSeq, to make the code easier to read. Function makeRowSeq uses a for expression whose generator iterates through column numbers 1 through 10. The body of this for calculates the product of row and column, determines the padding needed for the product, and yields the result of concatenating the padding and product strings. The result of the for expression will be a sequence (some subclass of scala.Seq) containing these yielded strings as elements. The other helper function,makeRow, simply invokes mkString on the result returned by makeRowSeq. mkString will concatenate the strings in the sequence and return them as one string.

The multiTable method first initializes tableSeq with the result of a for expression whose generator iterates through row numbers 1 to 10, and for each calls makeRow to get the string for that row. This string is yielded; thus the result of this for expression will be a sequence of row strings. The only remaining task is to convert the sequence of strings into a single string. The call to mkString accomplishes this, and because we pass "\n", we get an end of line character inserted between each string. If you pass the string returned by multiTable to println, you'll see the same output that's produced by calling printMultiTable.

1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
3 6 9 12 15 18 21 24 27 30
4 8 12 16 20 24 28 32 36 40
5 10 15 20 25 30 35 40 45 50
6 12 18 24 30 36 42 48 54 60
7 14 21 28 35 42 49 56 63 70
8 16 24 32 40 48 56 64 72 80
9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100

7.9 Висновок
------------
Вбудовані керівні структури Scala є мінімальними, але вони роблять свою справу. Вони роблять подібно до своїх імперативних еквівалентів, але оскільки вони схильні повертати значення, вони також підтримують функціональний стиль. Що також важливо, вони уважні щодо того, що вони оминають, таким чином лишаючи простір для однієї з найбільш потужних можливостей Scala, функціональних літералів, що будуть описані в наступній главі.
