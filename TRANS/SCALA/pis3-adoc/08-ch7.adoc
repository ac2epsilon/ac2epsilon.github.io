include::headers.adoc[]

Глава 7
-------

Вбудовані керівні структури
===========================

Scala має тільки декілька вбудованих керівних структур. Все, що є, це тільки: `if`, `while`, `for`, `try`, `match`, та виклики функцій. Причина, з якої Scala має їх так мало, в тому, що вона включає функціональні літерали з моменту свого створення. Замість накопичення в своєму синтаксисі однієї за одною високорівневих керівних структір, Scala накопичує їх в бібліотеках. (Глава 9 покаже в точності, як це зроблене.) Ця глава покаже ті декілька керівних структур, що є вбудованими.

Одна річ, що ви помітите, це що майже всі керівні структури в Scala призводять до деякого результату. Цей підхід взятий від функціональних мов, де програми розглядаються як обчислення значення, так що компоненти програми також повинні обчислювати значення. Ви також можете розглядати цей підхід як логічний висновок з тренду, що вже присутній в імперативних мовах. В імперативних мовах виклики функцій можуть повертати значення, навіть коли викликана функція так само гарно може просто оновити значення вихідної змінної, переданої як аргумент. На додаток, імперативні мови часто мають тримісний оператор (такий як оператор `?:` в C, C++ та Java), що ефективно поводиться як `if`, але результатом є значення. Scala адаптує цю модель тримісного оператора, але називає його `if`. Іншими словами,в Scala `if` може повертати значення. Потім Scala продовжує цей тренд, маючи `for`, `try` та `match`, що також повертають значення.

Програмісти можуть використовувати ці значення для спрощення свого коду, так само, якби вони використовували значення повернуті з функцій. Без цієї можливості програміст має створювати тимчасові змінні, тільки щоб зберігати результати, що обчислюються всередині керівної структури. Видалення ціх змінних робить код  трохи простішим, та він також запобігає багатьом вадам, коли ви встановлюєте змінну в одній гілці, але забуваєте встановити в іншому.

Загалом, базові керівні структури Scala, мінімальні як вони є, провадяться всі основи з імперативних мов. Більше того, вони дозволяють скоротити ваш код, узгоджена маючі значення результату. Щоб показати, як це робить, давайте подивимось на базові керівні структури Scala. 

7.1 Вирази 'if'
--------------- 
В Scala `if` робить так само, як і в багатьох інших мовах. Він перевіряє умову, і потім виконує одну з двох гілок коду, в залежності чи умова виконується. Ось загальний приклад, написаний в імперативному стилі: 
[source,scala]
----
var filename = "default.txt"
if (!args.isEmpty)
  filename = args(0)
----
Цей код декларує змінну `filename`, та ініціалізує її значенням по замовчанню. Потім він виконує вираз `if`, щоб перевірити, чи програмі були надані якісь аргументи. Якщо це так, значення змінної змінюється, щоб вона містила значення, вказане в списку аргументів. Якщо аргументи не надані, змінна залішається встановленою в значення по замовчанню.

Цей код може бути записаний краще, оскільки, як зазначалось в Кроці 3 в Главі 2, в Scala `if` є виразом, що повертає значення. Лістинг 7.1 показує, як ви можете досягти того самого ефекту, що і в попередньому прикладі, без використання жодних `var`:
[source,scala]
----
val filename =
if (!args.isEmpty) args(0)
  else "default.txt"
----
Лістинг 7.1 - Ідіома Scala для умовної ініціалізації.

На цей раз `if` має дві гілки. Якщо аргументи не порожні, буде обраний перший елемент, `args(0)`; інакше буде обране значення по замовчанню. Вираз `if` має результат в вигляді обраного значення, і змінна `filename` ініціалізується цім значенням. Цей код трохи коротший, але його справжня перевага в тому, що він використовує `val` замість `var`. Використання `val` є функціональним стилем, і це допомагає вам майже в той спосіб, що і використання фінальних змінних в Java. Це каже читачам коду, що змінна ніколи не буде змінюватись, вберігаючи їх від сканування всього коду в полі зору змінної, дивлячись, чи вона не змінилась.

Друга перевага використовувати `val` замість `var` в тому, що вони краще підтримують розуміння рівнянь. Введене значення еквівалентне до виразу, що обчислює його, припускаючи, що вираз не має побічних ефектів. Таким чином, кожного разу, коли ви збираєтесь записати ім'я змінної, замість нього ви можете записати вираз. Наприклад, замість `println(filename)`, ви можете просто записати це:
[source,scala]
----
println(if (!args.isEmpty) args(0) else "default.txt")
----
Вибір за вами. Ви можете записати це любим способом. Використання `vals` допомагає вам безпечно робити цей тип рефакторингу, по мірі того, як ваш код буде розвиватись з часом. Шукайте можливості використовувати `val`. Вони можуть зробити ваш код більш простим для читання, та простішим для рефакторингу.

7.2 Цикли while
---------------
Scala's while loop behaves as in other languages. It has a condition and a body, and the body is executed over and over as long as the condition holds true. Listing 7.2 shows an example:
[source,scala]
----
def gcdLoop(x: Long, y: Long): Long = {
  var a = x
  var b = y
  while (a != 0) {
    val temp = a
    a = b % a
    b = temp
  }
  b
}
-----
Лістинг 7.2 - Обчислення найбільшого загального дільника за допомогою цикла `while`.

Scala також має цикл `do-while`. Він робить як цикл `while`, за винятком того, що він перевіряє умову після тіла циклу, а не до. Лістинг 7.3 показує скрипт Scala, що використовує `do-while` для відлуння рядків, введених в стандартний вивід, докі не буде введений порожній рядок:
[source,scala]
----
var line = ""
do {
  line = readLine()
  println("Read: " + line)
} while (line != "")
----
Лістинг 7.3 - Читання зі стандартного вводу за допомогою do-while.

Конструкції `while` та `do-while` називаються "циклами", а не виразами, оскільки вони не продукують цікавого значення. Тип результата є `Unit`. Існує одне значення цього (та загалом тільки одне) типу `Unit`. Воно називається юніт значенням, та записується `()`. Існування `()` є тим, як Scala `Unit` відрізняється від Java `void`. Спробуйте це в інтерпретаторі:
[source,scala]
----
scala> def greet() = { println("hi") }
greet: ()Unit

scala> () == greet()
hi
res0: Boolean = true
----
Оскільки перед тілом немає знаку рівняння, `greet` визначене як процедура з типом результата `Unit`. Таким чином, `greet` повертає юніт значення `()`. Це підтверджується в наступному рядку: порівнюючи результат `greet` на рівність з юніт значенням `()`, що дає `true`. 

Одна інша конструкція, що має результат в вигляді юніт значення, що релевантне тут, є переприсвоєння до `vars`. Наприклад, коли ви намагаєтесь читати рядки в Scala, використовуючи наступну ідіому Java, цикл `while` (та C і C++), ви потрапите в небезпеку:
[source,scala]
----
var line = ""
while ((line = readLine()) != "") // Це не робить!
  println("Read: " + line)
----
Коли ви компілюєте цей код, Scala надасть вам попередження, що порівняння значень типів `Unit` та `String` з використанням `!=` буде завжди давати `true`. Тоді як в Java присвоєння скінчиться присвоєнням значення (в цьому випадку рядка зі стандартного вводу), в Scala присвоєння завжди зкінчиться юніт значенням, `()`. Таким чином, значення присвоєння `line = readLine()` завжди буде `()`, та ніколи не буде `""`. Як результат, умова цього цикла `while` ніколи не буде `false`, і, таким чином, цикл ніколи не завершиться.

Оскікльки цикл `while` не призводить до значення, він часто відсутній в чисто функціональних мовах. Такі мови мають вирази, а не цикли. Тим не менш, Scala включає цикл `while`, оскільки деякі імперативні рішення можуть бути більш читабельні, особливо для програмістів з переважно імперативним досвідом. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує процес докі деяка умова не зміниться, цикл `while` може виразити це напряму, тоді як функціональна альтернатива, що вірогідно використовуватиме рекурсію, може бути менш очевидною для деяких читачів коду.

Наприклад, Лістинг 7.4 показує альтернативний шлях визначити найбільший загальний дільник двох чисел.footnote:[Функція gcd, показана в Лістингу 7.4, використовує той самий підхід, що використовується в подібно-названій функції, спершу показаній в Лістингу 6.3, щоб обчислювати найбільший загальний дільник для класу Rational. Головна різниця в тому, що замість Int, gcd з Лістингу 7.4 робить з Long.] Беручи деякі два значення для `x` та `y`, функція `gcd`, показана в Лістингу 7.4 буде повертати той самий результат, що і `gcdLoop` функція, показана в Лістингу 7.2. Різниця між ціма двома підходами а тому, що `gcdLoop` написана в імперативному стилі, використовуючи `var` та цикл `while`, тоді як `gcd` написане в більш функціональному стилі, що включає рекурсію (`gcd` викликає себе), та не потребує `var`.
[source,scala]
----
def gcd(x: Long, y: Long): Long =
  if (y == 0) x else gcd(y, x % y)
----
Лістинг 7.4 - Обчислення найбільшого загального дільника за допомогою рекурсії.

Загалом, ми рекомендуємо вас кидати виклик циклам `while` в вашому коді, так само, як ви кидаєте виклик `var`. Фактично, цикли `while` та `var` часто ідуть рука об руку. Оскільки цикли `while` не видають результату, щоб призвести до якіхось змін в вашій програмі, цикл  `while` буде звичайно оновлювати `var` або виконувати I/O. Ви можете бачити це в дії в `gcdLoop`, показаному раніше. По мірі того, як цикл `while` робить свою справу, він оновлює `var` `a` та `b`. Таким чином, ми радимо вам бути трохи підозрілим щодо циклів `while` в вашому коді. Якщо немає гарного обгрунтування для окремого використання циклів `while` або `do-while`, спробуйте знайти спосіб зробити те саме без них.

7.3 Вирази for
--------------
Вираз `for` в Scala є швейцарським розкладним ножем ітерації. Він дозволяє комбінувати декілька простих інструментів в різний спосіб, щоб виразити широку різноманітність ітерацій. Прості використання дозволяють вирішувати загальні завдання, такі, як ітерація по послідовності цілих. Більш розвинені вирази можуть ітерувати по декількох колекціях різних типів, фільтрувати елементи на основі довільних умов, та продукувати нові колекції.

Ітерації по колекціях
~~~~~~~~~~~~~~~~~~~~~
Простіша річ, що ви можете зробити за допомогою `for` це ітерувати по всіх елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що друкує всі файли в поточній директорії. I/O виконується з використанням Java API. Зпочатку ми створюємо `java.io.File` на поточній директорії,".", та викликаємо його метод `listFiles`. Цей метод повертає масив з об'єктів `File`, по одному для кожної директорії та файлу, що містяться в поточній директорії. Ми зберігаємо отриманий масив в змінній `filesHere`.
[source,scala]
----
val filesHere = (new java.io.File(".")).listFiles

for (file <- filesHere)
  println(file)
----
Лістинг 7.5 - Перелічує файли в поточній директорії за допомогою вираза `for`.

За допомогою синтаксиса `file <- filesHere`, що називається _генератором_, ми ітеруємо по елементах `filesHere`. В кожній ітерації ініціалізується нова `val` на ім'я `file` зі значенням елемента. Компілятор виводить тип `file` як `File`, оскільки `filesHere` має тип `Array[File]`. Для кожної ітерації буде виконане тіло вираза, `println(file)`. Оскільки в `File` метод `toString` видає ім'я файла або директорії, будуть роздруковані імена всіх файлів та директорій в поточній директорі.

Синтаксис виразу `for` робить для любого типу колекції, не тільки для масивів.footnote:[Щоб бути точним, вираз зправа від символа `<-` в виразі for може бути любого типу, що має певні методи (в цьому випадку foreach) з відповідними сигнатурами. Деталі щодо того, як компілятор Scala обробляє вирази `for` описані в Главі 23.] Один зручний особливий випадок є тип `Range`, що ви похопцем бачили в Таблиці 5.4. Ви можете створити `Range` з використанням синтаксису як `1 to 5`, та можете ітерувати по ньому за допомогою `for`. Ось простий приклад:
[source,scala]
----
scala> for (i <- 1 to 4)
  println("Iteration " + i)
Iteration 1
Iteration 2
Iteration 3
Iteration 4
----
Якщо ви не бажаєте включати верхню межу диапазона в значення, по яких піде ітерація використовуйте `until` замість `to`:
[source,scala]
----
scala> for (i <- 1 until 4)
  println("Iteration " + i)
Iteration 1
Iteration 2
Iteration 3
----
Ітерація по цілим, як ця, є загальною в Scala, але не так сильно, як в інших мовах. В інших мовах ви можете використати цю можливість для ітерації по масиву, ось так:
[source,scala]
----
// Не загальне в Scala...
for (i <- 0 to filesHere.length - 1)
  println(filesHere(i))
----
Цей вираз `for` вводить змінну `i`, встановлює її по черзі в коже ціле між `0` та `filesHere.length - 1`, та виконує тіло виразу для кожного встановленого `i`. Для кожного встановленого `i`, `i`тий елемент `filesHere` отримується та обробляється.

Причина, з якої цей тип ітерації менш загальний в Scala в тому, що ви можете ітерувати по колекції напряму. Коли ви робите це, ваш код стає коротшим, та ви обходите багато "помилкових помилок", що можуть виникати, коли ви ітеруєте по масивах. Маєте ви почати з 0 або 1? Маєте ви додавати -1, +1, або нічого до фінального значення? На такі запитання легко відповісти, але також легко відповісти помилково. Безпечніше взагалі повністю уникати таких запитань.

Фільтрація
~~~~~~~~~~
Іноді ви не бажаєте ітерувати по повній колекції; ви бажаєте відфільтрувати її до деякої підмножини. Ви можете зробити це за допомогою вираза `for` через додавання фільтра, твердження `if` всередині дужок `for`. Наприклад, код, показаний в Лістингу 7.6, перелічує тільки ті файли в поточній директорії, чиї імена закінчуються на `.scala`:
[source,scala]
----
val filesHere = (new java.io.File(".")).listFiles
for (file <- filesHere if file.getName.endsWith(".scala"))
  println(file)
----
Лістинг 7.6 - Пошук файлів `.scala` використовуючи `for` з фільтром.

Ви можете альтернативно досягти тієї самої цілі за допомогою цього коду:
[source,scala]
----
for (file <- filesHere)
  if (file.getName.endsWith(".scala"))
println(file)
----
Цей код дає той самий вихід, що і попередній код, та, можливо, виглядає більш знайомим для програмістів з імперативним підгрунтям. Однак імперативна форма є тільки цибулиною, оскільки цей часний вираз `for` викликається тільки для побічного ефекту друкування, і має результатом юніт значення `()`. Як буде показано далі в цьому розділі, вираз `for` названий "виразом", оскільки він може давати в результаті цікаве значення, колекцію, тип якої визначається твердженням `<-` виразу `for`.

Ви можете включити більше фільтрів, якщо ви бажаєте. Просто продовжуйте додавати фільтри `if`. Наприклад, щоб бути екстра захищеним, код в Лістингу 7.7 друкує тільки файли, але не директорії. Він робить це через додавання фільтрів, що перевіряють метод `isFile` для файлів.
[source,scala]
----
for (
  file <- filesHere
    if file.isFile
  if file.getName.endsWith(".scala")
) 
println(file)
----
Лістинг 7.7 - Використання декількох фільтрів в виразі `for`.

Вкладена ітерація
~~~~~~~~~~~~~~~~~
Якщо ви додасте декілька тверджень `<-`, ви отримаєте вкладені "цикли". Наприклад, вираз `for`, показаний в Лістингу 7.8 має два вкладених цикли. Зовнішній цикл ітерує по `filesHere`, та внутрішній ітерує по `fileLines(file)` для кожного файлу, що закінчується на `.scala`.
[source,scala]
----
def fileLines(file: java.io.File) =
  scala.io.Source.fromFile(file).getLines().toList
def grep(pattern: String) =
  for (
    file <- filesHere
    if file.getName.endsWith(".scala");
    line <- fileLines(file)
    if line.trim.matches(pattern)
  ) println(file + ": " + line.trim)
grep(".*gcd.*")
----
Лістинг 7.8 - Використання декількох генераторів в виразі `for`.

Якщо ви бажаєте, ви можете використовувати фігурні дужки замість звичайних дужок щоб оточити генератори та фільтри. Одна з переваг використання фігурних дужок в тому, що ви можете відкинути деякі з крапок з комою, що потрібні вам, коли ви використовуєте дужки, бо, як пояснено в Розділі 4.2, компілятор Scala не буде виводити коми з крапками, коли знаходиться в дужках.

Серед-поточні прикріплення змінних
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Зауважте, що в попередньому коді повторюється вираз `line.trim`. Це нетривіальне обчислення, так що ви можете побажати обчислити його тільки один раз. Ви можете зробити це, прикріпивши результат до нової змінної, використовуючи знак рівності (=). Прикріплена змінна буде створена, та використовується як звичайна `val`, тільки без ключового слова `val`. Лістинг 7.9 показує приклад.
[source,scala]
----
def grep(pattern: String) = for {
  file <- filesHere
  if file.getName.endsWith(".scala")
  line <- fileLines(file)
  trimmed = line.trim
  if trimmed.matches(pattern)
} println(file + ": " + trimmed)
grep(".*gcd.*")
----
Лістинг 7.9 - Серед-поточне присвоєння в виразі `for`.

В Лістингу 7.9 змінна на ім'я `trimmed` вводиться посеред виразу `for`. Ця змінна ініціалізована результатом `line.trim`. Потім залишок виразу використовує її в двох місцях, один раз в `if`, та ще раз в `println`.

Продукування нової колекції
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Хоча доки всі приклади тільки оперували з ітерованими значеннями, та потім забували їх, ви також можете генерувати значення, що буде запам'ятовуватись на кожній ітерації. Щоб зробити це, ви ставите перед тілом виразу `for` ключове слово `yield`. Наприклад, ось функція, що ідентифікує файли `.scala`, та зберігає їх в масиві:
[source,scala]
----
def scalaFiles =
  for {
    file <- filesHere
    if file.getName.endsWith(".scala")
} yield file
----
Кожний раз, коли виконується тіло виразу, воно продукує одне значення, в цьому разі просто `file`. Коли вираз `for` завершується, результат буде включати всі з отриманих значень, що міститимуться в одній колекції. Тип отриманої колекції базується на типі колекцій, оброблених в твердженнях ітерації. В цьому випадку результат буде  `Array[File]`, оскільки `filesHere` є масивом, і тип отриманого виразу є `File`.

Будьте уважні, поміж всього, коли ви розташовуєте ключове слово `yield`. Синтаксис виразу `for-yield` виглядає так:
[source,scala]
----
for clauses yield body
----
`yield` іде перед всім тілом. Навіть якщо тіло є блок, оточений фігурними дужками, покладіть `yield` перед першою фігурною дужкою, не перед останнім виразом в блоці. Уникайте спокуси писати речі, подібні до цього:
[source,scala]
----
for (file <- filesHere if file.getName.endsWith(".scala")) {
  yield file // Синтаксична помилка!
}
----
Наприклад, вираз `for`, показаний в Лістингу 7.10 спочатку трансформує `Array[File]` на ім'я `filesHere`, що містить всі файли в поточній директорії, до такого, що містить тільки файли `.scala`. Для кожного з них він генерує `Iterator[String]`, результат метода `fileLines`, чиє визначення показане в Лістингу 7.8. `Iterator` пропонує методи `next` та `hasNext`, що дозволяють вам ітерувати по колекції елементів. Цей внутрішній ітератор трансформується в інший ітератор ` Iterator[String]`, який містить тільки обрізані рядки, що містять субрядок `"for"`. Нарешті, для кожного з них, видається ціла довжина. Результатом цього виразу `for` є `Array[Int]`, що містить довжини.
[source,scala]
----
val forLineLengths =
  for {
    file <- filesHere
    if file.getName.endsWith(".scala")
    line <- fileLines(file)
    trimmed = line.trim
    if trimmed.matches(".*for.*")
  } yield trimmed.length
----
Лістинг 7.10 - Трансформування `Array[File]` на `Array[Int]` з допомогою `for`.

В цій точці ви бачили всі головні функції виразів Scala `for`, але ми пройшли по них дуже швидко. Більш докладне покриття виразів `for` надається в Главі 23.

7.4 Обробка виключень за допомогою виразів try
----------------------------------------------
Виключення Scala поводяться як в багатьох інших мовах. Замість повернення значення в в нормальний спосіб, метод може завершитись викликом виключення. Викликач метода може або перехопити та обробити це виключення, або він може сам по собі завершитись, що спричинить поширення виключення до викликача викликача. Виключення розповсюджується в такий спосіб, розкручуючи стек викликів, доки метод не обробить його, або доки не залишиться методів.

Виклик виключень
~~~~~~~~~~~~~~~~
Виклик виключення в Scala виглядає так само, як і в Java. Ви створюєте об'єкт виключення, та потім закидаєте його ключовим словом `throw`:
[source,scala]
----
throw new IllegalArgumentException
----
Хоча це може виглядати трохи парадоксальним, в Scala `throw` є виразом, що має тип результа. Ось приклад, коли тип результата має значення:
[source,scala]
----
val half =
  if (n % 2 == 0)
    n / 2
  else
    throw new RuntimeException("n must be even")
----
Що тут трапиться, коли `n` є парним - `half` буде ініціалізоване до половини `n`. Якщо воно не парне, буде викликане виключення перед тим, як `half` взагалі зможе бути ініціалізоване. Через це, безпечно трактувати закидання виключення як взагалі будь-який тип. Любий контекст, що намагатиметься використовувати повернення з `throw`, ніколи не зможе цього зробити, так що не слід чекати ніякої шкоди.

Технічно `throw` виключення має тип `Nothing`. Ви можете використовувати `throw` як вираз, навіть якщо він ніколи нічого не обчислює. Цей невеликий шматок технічної гімнастики може виглядати збоченим, але часто корисний в випадках, як попередній приклад. Одна з гілок `if` обчислює значення, тоді як інша закидає виключення, та обчислює `Nothing`. Тип цілого виразу `if` після цього є типом тієї гілки, що щось обчислює. Тип `Nothing` дискутується далі в Розділі 11.3.

Перехоплення виключень
~~~~~~~~~~~~~~~~~~~~~~
Ви перехоплюєте виключення, використовуючи синтаксис, показаний в Лістингу 7.11 Синтаксис для тверджень `catch` був обраний за його узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння шаблонів, потужна можливість, коротко описана в цій главі, та в більших деталях в Главі 15.
[source,scala]
----
import java.io.FileReader
import java.io.FileNotFoundException
import java.io.IOException
try {
  val f = new FileReader("input.txt")
// Використовуємо та зачиняємо файл
} catch {
  case ex: FileNotFoundException => // Обробляємо відсутній файл
  case ex: IOException => // Обробляємо помилки I/O
}
----
Лістинг 7.11 - Твердження `try-catch` clause in Scala.

Поведінка цього виразу `try-catch` така сама, як і інших мов з виключенями. Тіло виконується, та якщо виникає виключення, кожне твердження `catch` викликається по черзі. В цьому прикладі, якщо виникає включення типу `FileNotFoundException`, буде виконане перше твердження. Якщо тип виключення `IOException`, виконується друге твердження. Якщо виключення не одного з ціх типів, `try-catch` завершиться, та виключення розповсюдиться далі.

NOTE: Одна різниця, що ви швидко зауважите, в тому, що на відміну від Java, Scala не вимагає від вас перехоплювати перевірені виключення, або декларувати їх в твердженні `throws`. Ви можете декларувати `throws`, якщо бажатєте, за допомогою анотації `@throws`, але це не вимагається. Дивіться Розділ 31.2 для додаткової інформації щодо `@throws`.

Твердження finally
~~~~~~~~~~~~~~~~~~
Ви можете огорнути вираз за допомогою твердження `finally`, якщо ви бажаєте виконати деякий код, не важливо як скінчиться вираз. Наприклад, ви можете побажати переконатись, що відкритий файл буде закритий, навіть якщо метод завершується виникненням виключення. Лістинг 7.12 показує приклад.footnote:[Хоча ви маєте завжди оточувати твердження case в catch в дужки, try та finally не потребують дужок, якщо вони містять тільки один вираз. Наприклад, ви можете написати: try t() catch { case e: Exception => ... } finally f().]
[source,scala]
----
import java.io.FileReader
val file = new FileReader("input.txt")
try {
// Використовуємо файл
} finally {
  file.close() // Переконуємось що зачинили файл
}
----
Лістинг 7.12 - Твердження `try-finally` в Scala.

NOTE: Лістинг 7.12 показує ідиоматичний спосіб переконатись, що об'єкт не-з-пам'яті, такий як файл, сокет або з'єднання з базою даних, є зачинений. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок `try`, в якому ви використовуєте ресурс. Нарешті, ви зачиняєте ресурс в блоці `finally`. Ця ідіома є тою самою в Scala, як в Java; альтернативно, в Scala ви можете задіяти прийом з назвою _шаблон позичання_, щоб досягти цієї цілі більш стисло. Шаблон позичання буде описаний в Розділі 9.4.

Отримання значення
~~~~~~~~~~~~~~~~~~
Як і з багатьма іншими керівними структурами Scala, `try-catch-finally` повертає значення. Наприклад, Лістинг 7.13 показує, як ви можете спробувати розібрати URL, але використати значення по замовчанню, якщо URL погано сформований. Результатом є те, що полишає твердження `try`, якщо не виникло виключення, або відповідний код `catch`, якщо виключення виникло і було перехоплене. Якщо виключення було закинуте, але не перехоплене, вираз взагалі не має результату. Значення, обчислене в твердженні `finally`, якщо таке є, відкидається. Звичайно в `finally` робиться деякий різновид очищення, такий як закриття файлів. Звичайно, вони не мають змінювати значення, обчислене в головному тілі або блоці `catch` твердження `try`.
[source,scala]
----
import java.net.URL
import java.net.MalformedURLException
def urlFor(path: String) =
  try {
    new URL(path)
  } catch {
    case e: MalformedURLException =>
      new URL("http://www.scala-lang.org")
  }
----
Лістинг 7.13 - Твердження `catch`, що надає значення.

Якщо ви знайомі з Java, вам зрозуміло, що поведінка Scala відрізняється від Java `try-finally` тільки в тій частині, що остання не повертає значення. Як і в Java, якщо твердження `finally` включає явне твердження `return`, або закидає виключення, значення повернення або виключення буде "анулювати" любі попередні значення, що походять з блоку `try` або з одного з його тверджень `catch`. Наприклад, маючи таке, скоріше надумане, визначення функції:
[source,scala]
----
def f(): Int = try return 1 finally return 2
----
виклик f() дає 2. Для контрасту, маючи:
[source,scala]
----
def g(): Int = try 1 finally 2
----
виклик g() дає 1. Обоє з ціх функцій показують поведінку, що може здивувати багатьох програмістів, так що зазвичай краще уникати повернення значень з твердження `finally`. Кращий спосіб думати про блок `finally`, як про спосіб переконатись, що відбувся деякий побічний ефект, такий як зачинення відкритого файлу.

7.5 Вирази match
----------------
В Scala вираз `match` дозволяють вам обрати з декількох альтернатив, так само, як твердження `switch` в інших мовах. Загалом, вираз `match` дозволяє вам зробити вибір, використовуючі довільні шаблони, що будуть описані в Главі 15. Загальна форма може почекати. Доки розглянемо тільки використання `match` для обрання між декількома альтернативами.

Як приклад, скрипт в Лістингу 7.14 читає назву їжі зі списку аргументів, та друкує додаток до цієї їжі. Цей вираз `match` перевіряє `firstArg`, що була встановлена в перший аргумент зі списку аргументів. Якщо рядок є `"salt"`, друкується `"pepper"`, та якщо рядок `"chips"`, друкується `"salsa"`, і так далі. Випадок по замовчанню вказаний підкресленням (`_`), підстановочним символом, що часто використовується в Scala як заміщувач для повністю невідомого значення.
[source,scala]
----
val firstArg = if (args.length > 0) args(0) else ""
firstArg match {
  case `"salt"` => println("pepper")
  case "chips" => println("salsa")
  case "eggs" => println("bacon")
  case _ => println("huh?")
}
----
Лістинг 7.14 - Вираз `match` з побічними ефектами.

Існує декілька важливих відмінностей від твердження Java `switch`. Одна в тому, що любий різновид констант, так само як і інших речей, може використовуватись в `case` в Scala, не тільки цілі типи, enum, та константи рядків в твердженнях Java `case`. В Лістингу 7.14 альтернативами є рядки. Інша відмінність в тому, що нема переривань `break` в кінці кожної альтернативи. Замість цього, `break` є неявним, і немає провалювання від однієї альтернативи до іншої. Загальний випадок — відсутність провалювання — стає коротший, та уникається джерело помилок, оскільки програмісти більше не провалюватимуться випадково.

Однак найбільш значуща різниця з Java `switch` може полягати в тому, що вирази `match` повертають значення. В попередньому прикладі кожна з альтернатив в виразі `match` друкує значення. Також гарно буде робити повернення значення, ніж його друк, як показано в Лістингу  7.15. Значення, що є результатом цього виразу `match`, зберігається в змінній `friend`. Крім того, що код став коротший (в любому випадку за числом токенів), код тепер розрізняє дві різні турботи: спочатку він обирає їжу, та потім друкує її.
[source,scala]
----
val firstArg = if (!args.isEmpty) args(0) else ""
val friend =
  firstArg match { 
    case "salt" => "pepper"
    case "chips" => "salsa"
    case "eggs" => "bacon"
    case _ => "huh?"
  }
println(friend)
----
Лістинг 7.15 - Вираз `match`, що продукує значення.

7.6 Життя без break та continue
-------------------------------
Ви, можливо, помітили, що ми не споминули `break` або `continue`. Scala полишила ці дві команди, оскільки вони не дуже гарно перетинаються з функціональними літералами, можливістю, описаною в наступній главі. Ясно, що значить `continue` означає в циклі `while`,але що воно може значити в функціональному літералі? Хоча Scala підтримує обоє, імперативний та функціональний стилі програмування, в цьому випадку вона трохи схиляється до функціонального програмування, в обмін на спрощення мови. Однак не турбуйтесь. Існує багато шляхів програмувати без `break` та `continue`, та якщо ви отримаєте переваги функціональних літералів, ці альтернативи можуть часто бути коротші, ніж оригінальний код.

Найпростіший підхід є замінити кожний `continue` на `if`, та кожний `break` на логічну змінну. Логічна змінна вказує, чи оточуючий цикл має продовжуватись. Наприклад, уявімо, що ви шукаєте в списку аргументів рядок, що закінчується на `".scala"` але не починається на дефіс. В Java ви можете — якщо ви великий прихильник циклів `while`, `break` та `continue` — написати наступне:
[source,java]
----
int i = 0;
// Це Java
boolean foundIt = false;
while (i < args.length) {
    if (args[i].startsWith("-")) {
        i = i + 1;
        continue;
    }
    if (args[i].endsWith(".scala")) {
        foundIt = true;
        break;
    }
    i = i + 1;
}
----
Щоб перекласти цей Java код прямо на Scala, замість робити `if` та потім `continue`, ви можете написати `if`, що оточує весь залишок цикла `while`. Щоб позбавитись `break`, ви можете звичайно додати логічну змінну, що вказує, чи варто продовжувати, але в цьому випадку ми можемо повторно використати `foundIt`. Викорисистовуючи обоє з ціх трюків, код приходить до вигляду, як показано на Лістингу 7.16.
[source,scala]
----
var i = 0
var foundIt = false

while (i < args.length && !foundIt) {
  if (!args(i).startsWith("-")) {
    if (args(i).endsWith(".scala"))
      foundIt = true
  }
  i = i + 1
}
----
Лістинг 7.16 - Цикл без `break` або `continue`.

Цей Scala код в Лістингу 7.16 досить подібний до оригінального Java коду. Всі базові частини все ще тут, і в тому ж порядку. Є дві переприсвоювані змінні та цикл `while`. В циклі є перевірка, що `i` менше ніж `args.length`, перевірка на `"-"`, та перевірка на `".scala"`.

Якщо ви бажаєте позбутись `var` в Лістингу 7.16, один підхід, що ви можете спробувати, це переписати цикл як рекурсивну функцію. Ви можете, наприклад, визначити функцію `searchFrom`, що приймає ціле на вході, шукає з цього місця, та потім повертає індекс потрібного аргументу. Використовуючи цей прийом, код буде виглядати, як показано в Лістингу 7.17:
[source,scala]
----
def searchFrom(i: Int): Int =
  if (i >= args.length) -1
  else if (args(i).startsWith("-")) searchFrom(i + 1)
  else if (args(i).endsWith(".scala")) i
  else searchFrom(i + 1)
val i = searchFrom(0)
----
Лістинг 7.17 - Рекурсивна альтернатива до циклів з `var`.

Версія в Лістингу 7.17 дає змістовне ім'я тому, що робить функція, та вона використовує рекурсію для заміни циклу. Кожне `continue` замінюється рекурсивним викликом з аргументом `i + 1`, що ефективно просуває до наступного аргументу. Багато людей знаходять, що цей стиль програмування простіший для розуміння, як тільки вони переходять до використання рекурсії.

NOTE: Компілятор Scala насправді не видасть рекурсивну функцію для коду, показаному на Лістингу 7.17. Оскільки всі рекурсівні виклики в позиції хвостового-виклику, компілятор буде генерувати код, подібний до циклу `while`. Кожний рекурсивний виклик буде реалізований як стрибок в зворотньому напрямку на початок функції. Оптимізація хвостового виклику обговорюється в Розділі 8.9.

Якщо після всієї цієї дискусії ви все ще потребуєте використовувати `break`, існує допомого з боку стандартної бібліотеки Scala. Клас `Breaks` в пакунку `scala.util.control` пропонує метод `break`, що може бути використаний для виходу з оточуючого блоку, що відмічений як `breakable`. Ось приклад, як може бути застосований цей наданий бібліотекою метод `break`:
[source,scala]
----
import scala.util.control.Breaks._
import java.io._

val in = new BufferedReader(new InputStreamReader(System.in))

breakable {
  while (true) {
    println("? ")
    if (in.readLine() == "") break
  }
}
----
Це буде читати непусті рядки зі стандартного входу. Коли користувач введе порожній рядок, керування потоком вийде з оточуючого  `breakable`, і разом з цім з циклу `while`. Клас `Breaks` реалізує  `break` через закидання виключення, що перехоплюється оточуючим застосуванням метода `breakable`. Таким чином, виклик до `break` не обов'язково повинен бути в тому самому методі, що викликає `breakable`.

7.7 Поле зору змінної
---------------------
Тепер, коли ви бачили вбудовані керівні структури Scala, ми будемо використовувати їх в цьому розділі для пояснення, як поле зору робить в Scala.

Швидкий шлях для Java програмістів
----------------------------------
Якщо ви Java програміст, ви знайдете, що правила поля зору в Scala майже ідентичні до Java. Одна різниця між Java та Scala в тому, що  Scala дозволяє вам визначати змінні з тим самим ім'ям у вкладених блоках. Так що якщо ви Java програміст, ви маєте щанайменьше передивитись цей розділ.

Декларації змінинх в Scala програмах мають поле зору, яке визначає, де ви можете використовувати ім'я. Найбільш загальни приклад поля зору полягаеє в тому, що фігурні дужки загалом вводять нове поле зору, так що будь-що, визначене в фігурних дужках виходить з поля зору після закриваючої фігурної дужки.footnote:[Є декілька виключень з цього правила, оскільки в Scala ви іноді використовуєте фігурні дужки замість дужок. Один приклад цього різновиду використання фігурних дужок альтернативний синтаксис виразу `for`, описаний в Розділі 7.3.] Як ілюстрацію розгліянемо функцію, показану в Лістингу  7.18.
[source,scala]
----
def printMultiTable() = {

  var i = 1
// в полі зору тільки i
  while (i <= 10) {
    var j = 1
// в полі зору i та j
    while (j <= 10) {
      val prod = (i * j).toString
// в полі зору  i, j, prod
      var k = prod.length
// в полі зору i, j, prod, k
      while (k < 4) {
        print(" ")
        k += 1
      }
    }
    print(prod)
    j += 1
 // в полі зору i та j; prod та k вийшли
  }
  println()
  i += 1
// в полі зору все ще i; j, prod, k вийшли
}
----
Лістинг 7.18 - Поле зору змінних при друкуванні таблиці множення.

Функція `printMultiTable`, показана в Лістингу 7.18, друкує таблицю множення.footnote:[Функція `printMultiTable`, показана в Лістингу 7.18 написана в імперативному стилі. Ми зробимо її рефактор в функціональному стилі в наступному розділі.] Перше твердження цієї функції вводить змінну на ім'я `i`, та ініціалізує її цілим `1`. Потім ви можете використовувати ім'я `i` в залишку функції.

Наступне твердження в `printMultiTable` є цикл `while`:
[source,scala]
----
while (i <= 10) {
var j = 1
...
}
----
Ви можете використовутати тут `i` також, бо вона все ще в полі зору. В першому твердженні в циклі `while` ви вводите іншу змінну, не цей раз з назвою `j`, та знову ініціалізуємо її в `1`. Оскільки змінна `j` була визначена в відкритих фігурних дужках циклу `while`, вона може бути вкористана тільки в циклі `while`. Якщо ви спробуєте зробити щось з `j` після зачинення фігурних дужок цикла `while`, після коментаря, що каже, що `j`, `prod`, та `k` за полем зору, ваша програма не буде компілюватись.

Всі змінні, визначені в цьому прикладі — `i`, `j`, `prod`, `k` — є локальними змінними. Такі змінні "локальні" для функції, в якій вони визначені. Кожного разу, коли функція викликається, використовується новий набір локальних змінних.

Коли змінна визначена, ви не можете визначити нову змінну з тим самим ім'ям в тому ж самому полі зору. Наприклад, наступний скрипт з двома змінними на ім'я `a` в тому ж полі зору не буде компілюватись:
[source,scala]
----
val a = 1
val a = 2 // Не компілюється
println(a)
----
З іншого боку ви можете визначити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. Наступний скрипт буде компілюватись та виконуватись:
[source,scala]
----
val a = 1;
{
  val a = 2 // Чудово компілюється
  println(a)
}
println(a)
----
При виконанні показаний перед цім скрипт буде друкувати 2, та потім 1, оскільки `a` визначене в фігурних дужках, є іншою змінною, яка в полі зору доки не будуть закриті фігурні дужки.footnote:[Доречі, в цьому випадку крапка з комою є необхідними після першого визначення `a`, оскільки механізм виводу крапки з комою Scala не буде ставити її в цьому випадку.] Одна різниця між Scala та Java в тому, що Java не дозволить вам створити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. В програмі Scala внутрішня змінна, як кажуть, _затінює_ змінну з таким же ім'ям, оскільки зовнішня змінна стає невидимою у внутрішньому полі зору.

Ви могли вже зазначити в інтерпретаторі дещо, що виглядає як затінення, :
[source,scala]
----
scala> val a = 1
a: Int = 1

scala> val a = 2
a: Int = 2

scala> println(a)
2
----
В інтерпретаторі ви можете повторно використовувати імена змінних за покликом вашого серця. Поміж інших речей, це дозволяє вам змінити вашу думку, якщо ви зробили помилку, коли перший раз визначали змінну в інтерпретаторі. Ви можете робити це, бо інтерпретатор відкриває нове вкладене поле зору для кожного нового твердження, яке ви набираєте. Таким чином, ви можете віалізувати попередній інтерпретований код так:
[source,scala]
----
val a = 1;
{
  val a = 2;
  {
    println(a)
  }
}
----
Цей код буде компілюватись та виконуватись як Scala скрипт, та, як і код, набраний в інтерпретаторі, буде друкувати 2. Майте на увазі, що такий код буде дуже бентежливий для читачів, оскільки імена змінних приймають нові значення у вкладених полях зору. Зазвичай краще створити нове, осмислене ім'я, ніж затінювати зовнішню змінну.

7.8 Рефакторинг коду в імперативному стилі
------------------------------------------
Щоб допомогти вам отримати уявлення про функціональний стиль, в цьому розділі ми зробимо рефакторинг імперативного підходу до друку таблиці множеннчя, показаного в Лістингу 7.18. Наша функціональна альтернатива показана на Лістингу 7.19.
[source,scala]
----
// Повертає рядок як послідовність
def makeRowSeq(row: Int) =
  for (col <- 1 to 10) yield {
    val prod = (row * col).toString
    val padding = " " * (4 - prod.length)
    padding + prod
  }

// Повертає рядок як рядок
def makeRow(row: Int) = makeRowSeq(row).mkString

// Повертає таблицю як рядок
def multiTable() = {
  val tableSeq = // послідовність сирих рядків
    for (row <- 1 to 10)
      yield makeRow(row)
  }

  tableSeq.mkString("\n")Listing 
}
----
7.19 - Функціональний спосіб створити таблицю множення.

Імперативний стиль виявляє себе в Лістинуг 7.18 в два способи. Перше, виклик `printMultiTable` має побічний ефект: друк таблиці множення на стандартний вивід. В Лістингу 7.19 ми зробили рефакторинг функції, так що вона повертає таблицю множення як рядок. Оскільки функція більше не друкує, ми переіменували її на `multiTable`. Як зазначалось до цього, одна з переваг функцій, вільних від побічних ефектів, в тому, що їх легче тестувати. Щоб протестувати `printMultiTable`, вам знадобиться якось перевизначити `print` та `println`, так що ви зможете перевірити вивід на коректність. Ви можете тестувати `multiTable` більш просто, перевіряючи рядок її результата.

Інший промовистий знак імперативного стилю в `printMultiTable` є її цикл `while` та `var`. Для контрасту, функція `multiTable` використовує `val`, вирази `for`, допоміжні функції та виклики до `mkString`.

Ми виділили дві допоміжні функції, `makeRow` та `makeRowSeq`, щоб спростити читанян кода. Функція `makeRowSeq` використовує вираз `for`, чий генератор ітерує по номерах стовпчиків від 1 до 10. Тіло цього `for` обчислює добуток рядка та стовпчика, визначає відступ для результату, та видає результат конкатенації рядків відступу та добутку. Результатом виразу `for` буде послідовність (деякий субклас `scala.Seq`), до міститиме ці отримані рядки як елементи. Інша допоміжна функція, `makeRow`, просто викликає `mkString` на результаті, повернутому `makeRowSeq`. `mkString` буде конкатенувати рядки в послідовності, та поверне їх як один рядок.

Метод `multiTable` зпочатку ініціалізує `tableSeq` результатом виразу `for`, чий генератор ітерує по номерах рядків від 1 до 10, та для кожного викликає `makeRow`, щоб отримати рядок. Цей рядок отримається через `yield`; так що результатом виразу буде послідовність рядків. Єдине завдання, що залишилось, це конвертувати рядки в один рядок. Це робить виклик `mkString`, та оскільки ми передаємо `"\n"`, ми отримуємо символ нового рядка між кожним рядком. Якщо ви передасте рядок, повернутий `multiTable`, до `println`, ви побачите той самий вивід, що продукує і виклик `printMultiTable`.

 1  2  3  4  5  6  7  8  9 10
 2  4  6  8 10 12 14 16 18 20
 3  6  9 12 15 18 21 24 27 30
 4  8 12 16 20 24 28 32 36 40
 5 10 15 20 25 30 35 40 45 50
 6 12 18 24 30 36 42 48 54 60
 7 14 21 28 35 42 49 56 63 70
 8 16 24 32 40 48 56 64 72 80
 9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100

7.9 Висновок
------------
Вбудовані керівні структури Scala є мінімальними, але вони роблять свою справу. Вони роблять подібно до своїх імперативних еквівалентів, але оскільки вони схильні повертати значення, вони також підтримують функціональний стиль. Що також важливо, вони уважні щодо того, що вони оминають, таким чином лишаючи простір для однієї з найбільш потужних можливостей Scala, функціональних літералів, що будуть описані в наступній главі.
