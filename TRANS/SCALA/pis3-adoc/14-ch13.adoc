include::headers.adoc[]

Глава 13
--------

Пакунки та імпорти
==================

Коли ви робите над програмою, особливо над великою, є важливим мінімізувати зчеплення — міру, в якій різні частини програми попокладаються одна на одну.Низьке зчеплення зменьшує ризик що малі, виглядаючі невинними зміни в одній частині програми, будуть мати руйнівні наслідки для іншої частини. Одним з шляхів зменшити зчеплення є писати в модулярному стилі. Ви поділяєте програму на декілька меньших модулів, кожна з яких має інутнішнє та зовнішнє. Коли робите всередині модуля, його реалізації, вам треба координуватись тільки з програмістами, що роблять тільки з тим самим модулем. Тільки коли ви маєте змінити зовнішність модуля, його інтерфейси, потрібно скоординувати дії з розробниками, що роблять з іншими модулями.

Ця глава показує декілька конструкцій, що допомагають вам програмувати в модульному стилі. Він показує, як покласти речі в пакунок, зробити імена видимі через імпорт, та контролювати видимість через модифікатори доступу. Конструкції подібні по духу до конструкцій Java, але є деякі відмінності, звичайно щоб зробити речі дещо узгодженими, так що має сенс прочитати цю главу, навіть якщо ви вже знаєте Java.

13.1 Покладання коду в пакунки
------------------------------
Код Scala розташовується в глобальній ієрархії пакунків Java. Приклад коду, що ви бачили дотепер в цій книзі, знаходився в безіменному пакунку. Ви можете покласти код в іменовані пакунки в Scala в два способи. Перше, ви можете покласти вміст цілого файлу в пакунок, поставивши твердження `package` зверху файла, як показано в Лістингу 13.1.
[source,scala]
----
package bobsrockets.navigation
class Navigator
----
Лістинг 13.1 - Покладання вмісту цілого файла в пакунок.

Твердження `package` в Лістингу 13.1 покладає клас `Navigator` в пакунок на ім'я `bobsrockets.navigation`. Імовірно, це програмне забезпечення навігації, розроблене Bob's Rockets, Inc.

NOTE: Оскільки код Scala є частиною екосистеми Java, рекомендовано слідувати домовленості Java щодо реверсно-доменного іменування для пакунків Scala, які ви випускаєте на публіку. Таким чином, краще ім'я для пакунку `Navigator` може бути `com.bobsrockets.navigation`. Однак в цій главі ми полишимо частку `com.`, щоб зробити приклади простіші до розуміння.

Інший спосіб покласи код в пакунок в Scala більш подібний на простори імен C#. Ви ставите за твердженням `package` розділ в фігурних дужках, що містить визначення, які підуть до пакунка. Цей синтаксис називається пакуванням. Пакування, показане в Лістингу 13.2, має той самий ефект, що і код в Лістингу 13.1:
[source,scala]
----
package bobsrockets.navigation {
  class Navigator
}
----
Лістинг 13.2 - Довга форма для простої декларації пакунку.

Для такого простого прикладу ви можете також використовувати синтаксичний цукор, показаний в Лістингу 13.1. Однак, одне використання більш загальної нотації є мати різні частині файлу в різних пакунках. Наприклад, ви можете вставити тести класа в той самий файл, що і оригінальний код, але покласти тести в окремі пакунки, як показано в Лістингу 13.3.
[source,scala]
----
package bobsrockets {
  package navigation {
// В пакунку bobsrockets.navigation
    class Navigator
    
    package tests {
      // В пакунку bobsrockets.navigation.tests
      class NavigatorSuite
    }
  }
}
----
Лістинг 13.3 - Декілька пакунків в тому самому файлі.
[source,scala]
----
package bobsrockets {
  package navigation {
    class Navigator {
// Не треба казати bobsrockets.navigation.StarMap
      val map = new StarMap
    }
    class StarMap
  }
  class Ship {
// Не треба казати bobsrockets.navigation.Navigator
    val nav = new navigation.Navigator
  }  
package fleets {
  class Fleet {
// Не треба казати bobsrockets.Ship
    def addShip() = { new Ship }
  }
}

----
Лістинг 13.4 - Скорочений доступ до класів та пакунків.

[source,scala]
----
package bobsrockets {
  class Ship
}
package bobsrockets.fleets {
  class Fleet {
// Doesn't compile! Ship is not in scope.
    def addShip() = { new Ship }
  }
}
----
Лістинг 13.5 - Символи в оточуючих пакунках не доступні автоматично.

[source,scala]
----
// В файлі launch.scala
package launch {
  class Booster3
}

// В файлі bobsrockets.scala
package bobsrockets {
  package navigation {
    package launch {
      class Booster1
    }
    class MissionControl {
      val booster1 = new launch.Booster1
      val booster2 = new bobsrockets.launch.Booster2
      val booster3 = new _root_.launch.Booster3
    }
  }
  package launch {
    class Booster2
  }
}
----  
Лістинг 13.6 - Доступ до прихованих імен пакунків.

13.2 Стислий доступ до пов'язаного коду
---------------------------------------
Коли код поділений на ієрархію пакунків, це не тільки допомагає людям переглядати код. Це також каже компілятору, що код в тому самому пакунку пов'язаний в деякий спосіб один з одним. Scala отримує перевагу від цієї пов'язаності, дозволяючі короткі, некваліфіковані імена при доступу до кода, що знаходиться в тому самому пакунку.

Лістинг 13.4 надає три прості приклади. Перше, як ви можете очікувати, клас може бути доступний зі свого власного пакунку без потреби вказання префіксу. Ось чому `new StarMap` компілюється. Клас `StarMap` знаходиться в тому самому пакунку, `bobsrockets.navigation`, що і вираз `new`, що отримує доступ, так що ім'я пакунка не треба ставити в якості префікса.

Друге, сам пакунок може бути доступний зі свого містячого пакунку без потреби в префіксі. В Лістингу 13.4 подивіться, як створюється примірник класу `Navigator`. Вираз `new` з'являється в пакунку `bobsrockets`, що містить пакунок `bobsrockets.navigation`. Таким чином, він може отримати доступ до пакунку `bobsrockets.navigation` через просту навігацію.

Третє, коли використовуються синтаксис пакування з фігурними дужками, всі імена, доступні в полі зору за межами пакування також доступні всередині його. Приклад в Лістингу 13.4 є спосіб, як `addShip()` створює новий `Ship`. Метод визначений в двох пакунках: зовнішній для `bobsrockets`, та внутрішній для `bobsrockets.fleets`. Оскільки `Ship` доступний в зовнішньому пакуванні, на нього можна посилатись всередині `addShip()`.

Зауважте, що цей різновид доступу можливий тільки якщо ви явно вкладете пакування. Якщо ви пристанете на один пакунок на файл, тоді, як в Java, єдині доступні імена будуть ті, що визначені в поточному пакунку. В Лістингу 13.5 пакування `bobsrockets.fleets` було пересунуте на вищий рівень. Оскільки воно більше не оточене в пакуванні для `bobsrockets`,імена з `bobsrockets` не є безпосередньо в полі зору. Як результат, `new Ship` дає помилку компіляції. Якщо вкладання пакунків з фігурними дужками незручно зсуває ваш код вправо, ви можете також використовувати декілька тверджень `package` без дужок.footnote:[Цей стиль декількох тверджень `package` без дужок називається зціпленими твердженнями `package`.] Наприклад, код нижче також визначає клас `Fleet` в двох вкладених пакунках, `bobrockets` та `fleets`, саме як ви бачили в Лістингу 13.4:
[source,scala]
----
package bobsrockets
package fleets
class Fleet {
// Не треба казати bobsrockets.Ship
  def addShip() = { new Ship }
}
----
Один заключний трюк, про який важливо знати. Іноді ви закінчуєте кодування в дуже захащеному полі зору, де імена пакунків затіняють один одне. В Лістингу 13.6 поле зору класу `MissionControl` включає три окремі пакунки на ім'я `launch`! Існує один `launch` в `bobsrockets.navigation`, один в `bobsrockets`, та один на вищому рівні. Як ви будете посилатись на кожний з `Booster1`, `Booster2` та `Booster3`?

Доступ до першого найпростіший. Посилання на `launch` само по собі перенесе вас до пакунку `bobsrockets.navigation.launch`, оскільки він в пакунку `launch`, визначеному в найближчому оточуючому полі зору. Таки чином ви можете посилатись на перший клас прискорювача просто як на `launch.Booster1`. Посилання на другий також не дуже заплутаний. Ви можете написати `bobrockets.launch.Booster2`, і буде зрозуміло, на який саме ви посилаєтесь. Це залишає питання третього класу прискорювача: як ви отримаєте доступ до `Booster3`, зважаючи, що вкладений пакунок `launch` затінює високорівневі об'єкти?


Щоб допомогти в цій ситуації Scala провадить пакунок на ім'я `_root_`, який знаходиться за межами любого пакунку, що може написати користувач. Підходячи з іншого боку, кожний високорівневий пакунок, що ви можете написати, розглядається як член пакунку `_root_`. Наприклад, обоє, `launch` та `bobsrockets` з Лістингу 13.6 є членами пакунку `_root_`. Як результат, `_root_.launch` дає вам пакунок самого вищого рівня, та `_root_.launch.Booster3` позначає самий зовнішній клас прискорювача.

13.3 Імпорти
------------
В Scala пакунки та їх члени можуть бути імпортовані з використанням твердження `import`. Імпортовані елементи потім можуть бути досяжні через просте ім'я, як `File`, на протилежність до вимоги кваліфікованого імені, як `java.io.File`. Наприклад, розглянемо код, показаний в Лістингу 13.7.
[source,scala]
----
package bobsdelights
abstract class Fruit(
  val name: String,
  val color: String
)

object Fruits {
  object Apple extends Fruit("apple", "red")
  object Orange extends Fruit("orange", "orange")
  object Pear extends Fruit("pear", "yellowish")
  val menu = List(Apple, Orange, Pear)
}
----
Лістинг 13.7 - Улюблені фрукти Боба, готові до імпорту.

Твердження `import` робить члени пакунку або об'єкта доступними за саме своїми іменами, без потреби ставити префікс з імені пакунку або об'єкта. Ось деякі прості приклади:
[source,scala]
----
// простий довтуп до Fruit
import bobsdelights.Fruit

// простий довтуп до всіх членів з bobsdelights
import bobsdelights._

// простий довтуп до всіх членів Fruits
import bobsdelights.Fruits._
----
Перший з ціх відповідає до імпорту поодинокого класу Java, та другий до імпорту Java на-потребу. Одна різниця в тому, що в Scala імпорти на-потребу записуються з кінцевим підкресленням (`_`) замість зірочки (`*`). (Кінец кінцем, `*` є валідним ідентифікатором в Scala!) Третє твердження `import` вище відповідає до Java імпорту статичних полів класа.

Ці три імпорту дають вам смак того, що можуть робити імпорти, але імпорти в Scala насправді значно більш загальні. Для початку, імпорти в Scala можуть з'являтись будь-де, не тільки на початку одиниці компіляції. Також вони можуть посилатись на довільні значення. Наприклад, є можливим імпорт, показаний в Лістингу 13.8:
[source,scala]
----
def showFruit(fruit: Fruit) = {
  import fruit._
  println(name + "s are " + color)
}
----
Лістинг 13.8 - Імпортування членів звичайного (не синглтон) об'єкта.

Метод `showFruit` імпортує все члени свого параметру `fruit`, що є типу `Fruit`. Наступне твердження `println` може посилатись на ім'я і колір напряму. Ці два посилання еквівалентні до `fruit.name` та `fruit.color`. Цей синтаксис є зокрема корисним, коли ви використовуєте об'єкти як модулі, що буде описане в Главі 29.

Гнучкі імпорти в Scala
----------------------
Твердження імпорту в Scala трохи більш гнучкі, ніж в Java. Є три принципові відмінності. В Scala імпорти:

* можуть з'являтись будь-де
* можуть посилатись на об'єкти (синглтони або звичайні), на додаток до пакунків
* дозволяють вам переіменувати та приховати деякі з імпортованих членів

Інший спосіб, в який імпорти Scala є гнучкими, є те, що вони можуть імпортувати самі пакунки, не тільки члени не-пакунки. Це просто природно, якщо ви думаєте про вкладені пакунки, які вкладені в їх оточуючих пакунках. Наприклад, в Лістингу 13.9  пакунок `java.util.regex` є імпортований. Це робить `regex` корисним як просте ім'я. Щоб отримати доступ до об'єкта синглтона `Pattern` з пакунку `java.util.regex`, ви можете просто сказати `regex.Pattern`, як показано в Лістингу 13.9:
[source,scala]
----
import java.util.regex
class AStarB {
// Доступ до java.util.regex.Pattern
  val pat = regex.Pattern.compile("a*b")
}
----
Лістинг 13.9 - Імпортування імені пакунку.

Імпорти в Scala також можуть переіменовувати та приховувати члени. Це робиться через селектор імпорту, оточений в фігурні дужки, що слідує за об'єктом, з якого імпортуються члени. Ось декілька прикладів:
[source,scala]
----
import Fruits.{Apple, Orange}
----
Ці імпорти прості члени `Apple` та `Orange` з об'єкта `Fruits`.
[source,scala]
----
import Fruits.{Apple => McIntosh, Orange}
----
Це імпортує два члени, `Apple` та `Orange` з об'єкта `Fruits`. Однак, об'єкт `Apple` переіменований на `McIntosh`, так що цей об'єкт доступний як `Fruits.Apple` або `McIntosh`. Твердження переіменування завжди має форму `<оригінальне-ім'я> => <нове-ім'я>`.
[source,scala]
----
import java.sql.{Date => SDate}
----
Це імпортує клас дати SQL як `SDate`, так що ви можете одночасно імпортувати звичайний клас дати Java, просто як `Date`.
[source,scala]
----
import java.{sql => S}
----
Це імпортує пакунок `java.sql` як `S`, так що ви можете писати речі як `S.Date`.
[source,scala]
----
import Fruits.{_}
----
Це імпортує всі члени з об'єкта `Fruits`. Це означає ту саму річ, що і `import Fruits._`.
[source,scala]
----
import Fruits.{Apple => McIntosh, _}
----
Це імпортує всі члени з об'єкта `Fruits`, але параіменовує `Apple` на `McIntosh`.
[source,scala]
----
import Fruits.{Pear => _, _}
----
Це імпортує всі члени з `Fruits`, за винятком `Pear`. Твердження в формі `<оригінальне-ім'я> => _` виключає `<оригінальне-ім'я>` з імен, що імпортовані. В певному сенсі переіменування дечого на `_` означає одночасне його приховування. Це корисне для уникнення неоднозначностей. Скажімо, ви маєте два пакунки, `Fruits` та `Notebooks`, що обоє визначають клас `Apple`. Якщо ви бажаєте отриати лише ноутбук на ім'я `Apple`, але не фрукт, ви все ще можете використовувати обоє імпорти на-потребу, ось так:
[source,scala]
----
import Notebooks._
import Fruits.{Apple => _, _}
----
Це буде імпортувати всі `Notebooks` та всі `Fruits`, за винятком `Apple`.

Ці приклади демонструють значну гнучкість, що пропонує Scala, коли доходить до імпорту членів вибірково, або навіть під іншими іменами. В підсумку, селектор імпорту може складатись з наступного:

* Просте ім'я `x`. Це включає `x` в набір імпортованих імен.
* Твердження переіменування `x => y`. Це робить член на ім'я `x` відомим під ім'ям `y`.
* Твердження приховування `x => _`. Це виключає `x` з набору імпортованих імен.
* Спіймати-всі `_`. Це імпортує всі члени, за винятком членів, зазначених в попередньому твердженні. Якщо надається символ спіймати-все, він має іти останнім в списку селекторів імпорту.

Простіші твердження імпорту, показані на початку цього розділу, можуть розглядатись як особливі скорочення тверджень імпорту з твердженням селектора. Наприклад, `import p._` еквівалентне до `import p.{_}`, та `import p.n` еквівалентне до `import p.{n}`.

13.4 Неявні імпорти
-------------------
Scala додає імпорти неявно до кожної програми. В основі, це виглядає так, якби три твердження імпорту були додані нагорі кожного джерельного файлу з розширенням `.scala`:
[source,scala]
----
import java.lang._  // все в пакунку java.lang
import scala._      // все в пакунку scala
import Predef._     // все в об'єкті Predef
----
Пакунок `java.lang` містить стандартні класи Java. Вони завжди неявно імпортовані в джерельні файли Scala.footnote:[Scala також в оригіналі мала реалізацію на .NET, де замість цього був імпортований простір імен `System`, .NET аналог пакунку `java.lang`.] Оскільки `java.lang` імпортований неявно, ви можете писати, наприклад, `Thread`  замість `java.lang.Thread`.

Як ви вже безсумнівно здогадались, пакунок `scala` містить стандартну бібліотеку Scala, з багатьма загальними класами та об'єктами. Оскільки `scala` імпортована неявно, ви можете писати, наприклад, `List` замість `scala.List`.

Об'єкт `Predef` містить визначення типів, методів та неявних перетворень, що загально використовуються в програмах Scala. Наприклад, завдяки неявно імпортованому `Predef`, ви можете писати `assert` замість `Predef.assert`.

Ці три твердження `import` розглядаються трохи особливо, в тому, що пізніші імпорти затінюють ранішні. Наприклад, клас `StringBuilder` визначений одночасно в пакунку `scala`, та, починаючи з Java версії 1.5, також в пакунку `java.lang`. оскільки імпорт `scala` затінює імпорт `java.lang`, просте ім'я `StringBuilder` буде посилатись на  `scala.StringBuilder`, не на `java.lang.StringBuilder`.

13.5 Модифікатори доступу
-------------------------
Члени пакунків, класів або об'єктів, можуть бути помічені можифікаторами доступу `private` та `protected`. Ці модифікатори обмежують доступ до членів для окремих регіонів коду. Трактування Scala модифікаторів доступу приблизно слідує Java, але існують деякі важливі відмінності, що пояснюються в цьому розділі.

Приватні члени
~~~~~~~~~~~~~~
Приватні члени в Scala розглядаються подібно до Java. Член, відмічений `private` є видимі тільки всередині класу або об'єкту, що містить визначення члена. В Scala це правило стосується тільки внутрішніх класів. Ця трактовка більш узгоджена, але відрізняється від Java. Розглянемо приклад, показаний в Лістингу 13.10.
[source,scala]
----
class Outer {
  class Inner {
    private def f() = { println("f") }
    class InnerMost {
      f() // OK
    }
  }
  (new Inner).f() // помилка: f недоступна
}
----
Лістинг 13.10 - Як приватний доступ відрізняється в Scala та Java.

В Scala доступ до `(new Inner).f()` є нелегальним, оскільки `f` декларована приватною в `Inner`, та доступ відбувається не зсередини класу `Inner`. Для контрасту, перший доступ до `f` в класі `InnerMost` є OK, оскільки цей доступ міститься в тілі класу `Inner`. Java буде дозволяти обоє доступи, оскільки вона дозволяє зовнішнім класам мати доступ до приватних членів інутрішніх класів.

Захищені члени
~~~~~~~~~~~~~~
Доступи до захищених членів в Scala також трохи більш обмежувані, ніж в Java. В Scala захицений член доступний тільки з субкласів класа, в якому він визначений. В Java такий доступ також можливий з інших класів в тому ж пакунку. В Scala існує інший метод досягти такого самого ефекту,footnote:[Використовуючи кваліфікатори, описані в "Поле зору захищеності".] так що `protected` можна залишити як є. Приклад, показаний в Лістингу 13.11, ілюструє захищений доступ.
[source,scala]
----
package p {
  class Super {
    protected def f() = { println("f") }
  }
  class Sub extends Super {
    f()
  }
  class Other {
    (new Super).f() // error: f is not accessible
  }
}
----
Лістинг 13.11 - Як захищений доступ відрізняється в Scala та Java.

В Лістингу 13.11 доступ до `f` в класі `Sub` є OK, оскільки `f` декларована як `protected` в `Super`, та `Subis` є субкласом `Super`. По контрасту, доступ до `f` в `Other` не дозволений, оскільки `Other` не наслідує від `Super`. В Java останній доступ також буде дозволений, бо `Other` в тому ж пакунку, що і `Sub`.

Публічні члени
~~~~~~~~~~~~~~
Scala не має явного модифікатора для публічних членів: любий член, не відмічений `private` або `protected` є публічним. Публічні методи можуть бути доступні будь-де.
[source,scala]
----
package bobsrockets

package navigation {
  private[bobsrockets] class Navigator {
    protected[navigation] def useStarChart() = {}
    class LegOfJourney {
      private[Navigator] val distance = 100
    }
    private[this] var speed = 200
  }
}
package launch {
  import navigation._
  object Vehicle {
    private[launch] val guide = new Navigator
  }
}
----
Лістинг 13.12 - Гнучка видимість захищеності з модифікаторами доступа.

Поле зору захищеності
~~~~~~~~~~~~~~~~~~~~~
Модифікатори доступу в Scala можуть бути доповнені за допомогою кваліфакаторів. Модифікатор в форматі `private[X]` або `protected[X]` означає, що доступ приватний або захищений "в межах" `X`, де `X` позначає деякий оточуючий пакунок, клас або об'єкт синглтон.

Кваліфіковані модифікатори доступу надають вам гарний контроль над видимістю. Зокрема, вони дозволяють вам виражати варіанти досяжності Java, такі як приватний в пакунку, захищений в пакунку, або приватний в межах зовнішнього класу, що напряму не виражається простими модифікаторами в Scala. Але вони також дозволяють вам виражати правила доступності, що не можуть бути виражені в Java.

Лістинг 13.12 представляє приклад з багатьма вжитими кваліфікаторами доступа. І цьому лістингу клас `Navigator` помічений як `private[bobsrockets]`. Це означає, що цей клас видимий у всіх класах та об'єктах, що містяться в пакунку `bobsrockets`. Зокрема, досутп до `Navigator` в об'єкті `Vehicle` дозволений, оскільки `Vehicle` міститься в пакунку `launch`, що міститься в `bobsrockets`. З іншого боку, весь код за межами пакунку `bobsrockets` не має доступу до класу `Navigator`.

Цей прийом досить корисний в великих проектах, що обіймають декілька пакунків. Він дозволяє визначати речі, що видимі в декількох суб-пакунках, але залишаються приховані для клієнтів, зовнішніх відносно вашого проекту. Той самий прийом неможливий в Java. Там, коли визначення залишає межі свого безпосереднього пакунку, він стає видимий для загального світу.

Зазвичай, кваліфікатор `private` може також бути безпосередньо оточуючим пакунком. Прикладом є модифікатор доступу `guide` в об'єкті `Vehicle` з Лістингу 13.12. Такий модифікатор доступу еквівалентний до пакунок-приватного доступу в Java.

[caption="Таблиця 13.1 "]
.Ефекти приватних кваліфікаторів на LegOfJourney.distance
[cols="1,5"]
|===
| немає модифікатора доступу   | публічний доступ
| private[bobsrockets] | доступ в зовнішньому пакунку
| private[navigation]  | те саме, що видимість в пакунку в Java
| private[Navigator]   | те саме, що `private` в Java
| private[LegOfJourney]| те саме, що `private` в Scala
| private[this]        | доступ тільки в тому самому об'єкті
|===

Всі кваліфікатори також можуть бути застосовані до `protected`, з тим же значенням, що і `private`. Тобто, модифікатор `protected[X]` в класі `C` дозволяє доступ до відміченого визначення в усіх субкласах `C`, та також з оточуючому пакунку, класі, або об'єкті `X`. Наприклад, метод `useStarChart` в Лістингу 13.12 доступний в усіх субкласах `Navigator`, а також у всьому коді, що міститься в оточуючому пакунку `navigation`. Таким чином це в точності відповідає значенню `protected` в Java.

Кваліфікатори `private` також можуть посилатись на оточуючий клас або об'єкт. Наприклад, змінна `distance` в класі `LegOfJourney` з Лістингу 13.12 помічений як `private[Navigator]`, так що він видимий будь-де в класі `Navigator`. Це надає ті самі можливості доступу, що приватні члени внутрішніх класів в Java. Модифікатор `private[C]`, де `C` є зовнішінй оточуючий клас, є те саме, що простий `private` в Java.

Нарешті, Scala також має модифікатор доступу, що навіть більш обмежуючий, ніж `private`. Визначення, помічене `private[this]`, доступне тільки з того самого об'єкту, що містить визначення. Таке визначення називається об'єкт-приватне. Наприклад, визначення `speedin` в класі `Navigator` з Лістингу 13.12 є об'єкт-приватним. Це означає, що любий доступ має не тільки бути в класі `Navigator`, він має бути зроблений саме з того самого примірника `Navigator`. таким чином, доступ до `speed` та `this.speed` будуть легальними в межах `Navigator`.

Наступний доступ, однак, не буде дозволено, навіть якщо він з'являється в класі  `Navigator`:
[source,scala]
----
val other = new Navigator
other.speed // цей рядок не буде компілюватись
----
Помітка члена як `private[this]` є гарантією, що він не буде видимий з інших об'єктів того самого класу. Це може бути корисно для документації. Це також інколи дозволяє вам писати більш загальні анотації варіантності (дивіться Розділ 19.7 щодо деталей).

Щоб підсумувати, Таблиця 13.1 перелічує ефекти від приватних кваліфікаторів. Кожний рядок показує кваліфікований приватний модифікатор, і що він буде означати, якщо такий модифікатор буде приєднаний до змінної `distance`, декларованої в класі `LegOfJourney` в Лістингу 13.12.

Видимість та об'єкт компанйон
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
В Java статичні члени та члени примірників належать до того самого класу, так що модифікатори доступу застосовуються до них одноманітно. Ви вже мали бачити, що в Scala немає статичних членів; замість ви можете створити об'єкт компанйон, що містить члени, що існують в одній копії. Наприклад, в Лістингу 13.13 об'єкт `Rocket` є компанйоном класу `Rocket`.
[source,scala]
----
class Rocket {
  import Rocket.fuel
  private def canGoHomeAgain = fuel > 20
}

object Rocket {
  private def fuel = 10
  def chooseStrategy(rocket: Rocket) = {
    if (rocket.canGoHomeAgain)
      goHome()
    else
      pickAStar()
  }
  def goHome() = {}
  def pickAStar() = {}
}
----
Лістинг 13.13 - Доступ до приватних членів класу компанйона та об'єктів.

Правила доступу Scala надають привелей об'єктам компанйонам та класам, коли ідеться про приватний або захищений доступ. Клас поділяє всі свої права доступу зі своїм об'єктом компанйоном, та навпаки. Зокрема, об'єкт може отримувати доступ до всіх приватних членів свого класу компанйона, так само, як клас може отримувати доступ до приватних членів об'єкта компанйона.

Наприклад, клас `Rocket` з Лістингу 13.13 може отримати доступ до метода `fuel`, що декларований приватним в об'єкті `Rocket`. Аналогічно, об'єкт `Rocket` може отримати доступ до приватного метода `canGoHomeAgain` в класі `Rocket`.

Одне виключення, де подібність між Scala та Java ламається, стосується захищених статичних членів. Захицені статичні члени в Java класі `C` може бути доступним у всіх субкласах `C`. Для контрасту, захищений член в об'єкті компанйоні не має сенсу, оскікльи об'єкт синглтон не має жодних субкласів.

13.6 Об'єкти пакунків
---------------------
Доки єдиний код, що ми бачили доданим до пакунків, були класи, трейти та окремі об'єкти. Це найбільш загальні визначення, що розташовуються на верхньому рівні пакунка. Але Scala не обмежує вас лише цім — любий різновид визначення, що ви можете покласти в клас, також може бути на вищому рівні пакунка. Якщо ви маєте деякий допоміжний метод, що ви хочете помістити в поле зору цілого пакунку, дійте, та покладіть його прямо на верхній рівень пакунка.

Щоб зробити це, покладіть визначення в об'єкті пакунка. Кожному пакунку дозволяється мати один об'єкт пакунку. Любі визначення, покладені в об'єкт пакунку, розглядаються як члени самого пакунку.

Приклад показаний в Лістингу 13.14. Файл `package.scala` утримує об'єкт пакунку для пакунку `bobsdelights`. Синтаксично об'єкт пакунку виглядає більш подібно до пакуванян в фігурних дужках, показаних раніше в цій главі. Одна різниця в тому, що він включає ключеве слово `object`. Це об'єкт пакунку, не пакунок. Вміст фігурних дужок може включати любі визначення за вашим бажанням. В цьому випадку об'єкт пакунку включає допоміжний метод `showFruit` з Лістингу 13.8.

Маючи це визначення, любий інший код в любому пакунку може імпортувати метод, так само, як він може імпортувати клас. Наприклад, Лістинг 13.14 також показує окремий об'єкт `PrintMenu`, що розміщений в окремому пакунку. `PrintMenu` може імпортувати допоміжний метод `showFruit` в той самий спосіб, як він може імпортувати клас `Fruit`.
[source,scala]
----
// В файлі bobsdelights/package.scala
package object bobsdelights {
  def showFruit(fruit: Fruit) = {
    import fruit._
    println(name + "s are " + color)
  }
}

// В файлі PrintMenu.scala
package printmenu
import bobsdelights.Fruits
import bobsdelights.showFruit

object PrintMenu {
  def main(args: Array[String]) = {
    for (fruit <- Fruits.menu) {
      showFruit(fruit)
    }
  }
}
----
Лістинг 13.14 - Об'єкт пакунку.

Заглядаючи наперед, існують інші використання об'єктів пакунку для різновидів визначень, які ви ще не бачили. Об'єкти пакунку часто використовуються для пакет-поширених псевдонимів типів (Глава 20) та неявних перетворень (Глава 21). Пакунок `scala` вищого рівня має об'єкт пакунка, та його визначення доступні для всього Scala кода.

Об'єкти пакунка компілюються до файлів класів на ім'я `package.class`, що розміщені в директорії пакунку, які вони доповнюють. Це корисно для утримання тієї ж домовленості для джерельних файлів. Так що ви типово можете покласти джерельний файл об'єкту пакунка `bobsdelights` з Лістингу 13.14 в файл на ім'я `package.scala`, що розташований в директорії `bobsdelights`.

13.7 Висновок
-------------
В цій главі ви бачили базові конструкції для поділу вашого коду на пакунки. Це дає вам простий та корисний різновид модульності, так що ви можете робити з дуже великим тілом кода, без того, щоб різні частини коду налазили один на одний. Система Scala є за духом така сама, що і пакунки Java, але існують деякі відмінності, де Scala обирає бути більш узгодженою або більш загальною.

Заглядаючи наперед, Глава 29 описує більш гнучку модульну систему, ніж поділення на пакунки. На додаток до надання вам поділу коду на на декілька просторів імен, цей підхід дозволяє модулям бути параметризованими, та наслідувать один від одного. В наступній главі ми звернемо нашу увагу на твердження та юніт тести.
