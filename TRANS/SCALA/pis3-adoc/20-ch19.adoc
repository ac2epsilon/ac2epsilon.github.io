include::headers.adoc[]

Глава 19
--------

Параметризація типів
====================

В цій главі ми пояснимо деталі параметризації типів в Scala. По ходу ми продемонструємо деякі з прийомів приховування інформації, з якою ви ознайомились в Главі 13 через використання суцільного прикладу: розробки класу для повністю функціональних черг. Ми презентуємо параметризацію типів та приховування разом, оскільки приховування інформації може використовуватись для більш загальної параметризації типів з анотаціями варіантності.

Типова параметризація дозволяє вам писати загальні класи та трейти. Наприклад, множини є загальними та приймають параметр типу: вони визначені як `Set[T]`. Як результат, любий окремий примірник множини може бути `Set[String]`, `Set[Int]`, тощо, але він має бути множиною чогось. На відміну від Java, що дозволяє сирі типи, Scala вимагає, щоб ви вказували параметри типів. Варіантність визначає відношення наслідування для параметризованих типів, наприклад, такі як: чи є `Set[String]` субтипом `Set[AnyRef]`.

Глава містить три частини. Перша частина розробляє структуру даних для повністю функціональних черг. Друга частина розробляє техніку для приховування деталей внутрішньої репрезентації цієї структури. Заключна частина пояснює варіантність, та як вона взаємодіє з приховуваннями інформації.

19.1 Функціональні черги
------------------------
Функціональна черга є структурою даних з трьома операціями:

`head` повертає перший елемент черги
  
`tail` повертає чергу без першого елемента

`enqueue` повертає нову чергу з наданим елементом
          доданим в кінець

На відміну від змінної черги, функціональна черга не змінює вміст коли додається елемент. Замість цього повертається нова черга, що містить цей елемент. Ціль цієї глави - створити клас, що буде мати ім'я `Queue`, що робить таким чином:
[source,scala]
----
scala> val q = Queue(1, 2, 3)
q: Queue[Int] = Queue(1, 2, 3)

scala> val q1 = q enqueue 4
q1: Queue[Int] = Queue(1, 2, 3, 4)

scala> q
res0: Queue[Int] = Queue(1, 2, 3)
----
Якщо `Queue` мав би змінну реалізацію, операція `enqueue` в другому рядку мала б впливати на вміст `q`; фактично, після цієї операції обидві черги, результат `q1` та оригінальна черга `q`, мали б містити послідовність `1, 2, 3, 4`. Але для функціональної черги додане значення можна побачити тільки в результаті `q1`, та не в черзі `q`, на якій виконується операція.

Чисто функціональні черги також мають деяку подібність до списків. Обоє є так званими повністю стійкими структурами даних, коли старі версії залишаються доступні, навіть після розширення або модифікації. Вони підтримують операції `head` та `tail`. Але коли список звичайно розширюється зпереду, використовуючи операцію `::`, черга розширюється з кінця, використовуючи `enqueue`.

Як це може бути реалізовано ефективно? Ідеально, функціональна (незмінна) черга не повинна мати фундаментально вище навантаження, ніж імперативна (змінна). Тобто, всі три операції, `head`, `tail`, `enqueue`, повинні виконуватись за сталий час. Один простий підхід реалізувати функціональну чергу, що буде використовувати список як тип репрезентації.

Тоді `head` та `tail` будуть просто транслюватись в такі ж операції на списках, тоді як `enqueue` має бути конкатенацією.

Це буде давати таку реалізацію:
[source,scala]
----
class SlowAppendQueue[T](elems: List[T]) { // неефективне
  def head = elems.head
  def tail = new SlowAppendQueue(elems.tail)
  def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
}
----
Проблема з цією реалізацією знаходиться в операції `enqueue`. Вона займає час, пропорційну до числа елементів, що зберігаються в черзі. Якщо ви бажаєте додавати елементи за сталий час, ви також можете спробувати обернути порядок елементів в представленому списку, так щоб останній елемент, що додається, був би першим в списку. Це може привести до наступної реалізації:
[source,scala]
----
class SlowHeadQueue[T](smele: List[T]) { // неефективне
// smele це обернене elems
  def head = smele.last
  def tail = new SlowHeadQueue(smele.init)
  def enqueue(x: T) = new SlowHeadQueue(x :: smele)
}
----
Тепер `enqueue` займає сталий час, але `head` та `tail` - ні. Тепер вони витрачають час, пропорційний до кількості елементів, що зберігаються в черзі.

Дивлячись на ці два приклади, виглядає непростим запропонувати реалізацію, що має сталий час для всіх трьох операцій. Фактично, виглядає сумнівним, щоб це взагалі було можливим! Однак комбінуючи дві операції ви можете підійти дуже близько. Ідея є представити чергу як два списки, названі `leading` та `trailing`. Список `leading` містить елементи, ближчі до початку, тоді як список `trailing` містить елементи, ближчі до кінця черги в оберненому порядку. Вміст цілої черги в кожну мить є рівним `leading ::: trailing.reverse`.

Тепер, щоб додати елемент, ви просто робите йому `cons` до списку `trailing`, використовуючи оператор `::`, так що `enqueue` має сталий час. Це означає, що спочатку, коли порожня черга конструююється з послідовних операцій `enqueue`, список `trailing` буде зростати, тоді як список `leading` буде залишатись порожньою. Потім, перед першою операцією `head` або `tail`, що буде виконана для порожнього списку `leading`, цілий список `trailing` копіюється до `leading` з реверсом порядку елементів. Це робиться операцією, що називається `mirror`. Лістинг 19.1 показує реалізацію черги, що використовує цей підхід.
[source,scala]
----
class Queue[T](
  private val leading: List[T],
  private val trailing: List[T]
) {
  private def mirror =
    if (leading.isEmpty)
      new Queue(trailing.reverse, Nil)
    else
      this

  def head = mirror.leading.head

  def tail = {
    val q = mirror
    new Queue(q.leading.tail, q.trailing)
  }

  def enqueue(x: T) =
    new Queue(leading, x :: trailing)
}
----
Лістинг 19.1 - Базова функціональна черга.

Яка складність цієї реалізації черги? Операція `mirror` може займати час, пропорційну до кількості елементів в списку, але тільки якщо список `leading` порожній. Він повертається безпосередьньо, якщо `leading` непорожній. Оскільки `head` та `tail` викликають `mirror`, їх складність також може бути лінійною до розміру черги, також. Однак чим більшою стає черга, тим рідше викликається `mirror`.

Дійсно, припустімо є черга довжиною `n` з порожнім списком `leading`. Тоді `mirror` має реверс-копіювати список довжини `n`. Однак наступного разу `mirror` буде мати виконати будь яку роботу, коли список `leading` буде знову порожній, що буде після `n` операцій `tail`. Це означає, що ви можете "заряджати" кожну з ціх `n` операцій `tail` один раз на `n` від складності `mirror`, що означає сталу кількість роботи. Зважаючи, що операції `head`, `tail`, та `enqueue` з'являються з тою самою частотою, амортизована складність, таким чином, є константою для кожної операції. Так що функціональні черги асимптотично такі ж само ефективні, як і змінні.

Тепер, ось декілька застережень, що треба додати до ціх аргументів. Перше, дискусія була тільки про асимптотичну поведінку. Друге, аргументація покладалась на факт, що `head`, `tail` та `enqueue` викликаються з майже такою ж частотою. Якщо `head` викликана значно частіше, ніж інші дві операції, наш аргумент не діє, бо кожний виклик `head` може включати коштовну реорганізацію списку в `mirror`. Друге застереження можна оминути; можливо розробити функціональні черги, так щоб для послідовних операцій `head` тільки перша могла потребувати реорганізації. Ви з'ясуєте в кінці цієї глави, як це робиться.

19.2 Приховування інформації
----------------------------
Реалізація `Queue`, показана в Лістингу 19.1 тепер досить гарна, в відношенні ефективності. Однак ви можете заперечити, що ця ефективність сплачена викриттям непотрібних деталей реалізації. Конструктор, що є глобально доступним, приймає два списки як параметри, один з яких реверсований — навряд чи інтуітивна репрезентація черги. Що потрібно, це шлях приховати цей конструктор від клієнтського коду. В цьому розділі ми покажемо деякі шляхи досягти цього в Scala.

Приватні конструктори та методи фабрик
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
В Java ви можете приховати конструктор, зробивши його приватним. В Scala первинний конструктор не має явного визначення; він визначений явно через параметри та тіло класу. Тим не менше, все ще можливо приховати первинний конструктор, через додавання модифікатора `private` перед списком параметрів класу, як показано в Лістингу 19.2:
[source,scala]
----
class Queue[T] private (
  private val leading: List[T],
  private val trailing: List[T]
)
----
Лістинг 19.2 - Приховування первинного конструктора через створення його приватним.

Модифікатор `private` між ім'ям класу та його параметрами вказує, що конструктор `Queue` є приватним: до нього можна отримати доступ тільки з самого класу, та його об'єкта компанйона. Ім'я класу `Queue` все ще публічне, так що ви можете використовувати його як тип, але ви не можете викликати конструктор:
[source,scala]
----
scala> new Queue(List(1, 2), List(3))
<console>:9: error: constructor Queue in class Queue cannot
be accessed in object $iw
              new Queue(List(1, 2), List(3))
              ^
----              
Тепер, коли цей приватний конструктор класу `Queue` не може бути викликаний з клієнтського коду, виникає потреба в деякому іншому способі створювати нові черги. Одна можливість є добавити додатковий конструктор, ось так:
[source,scala]
----
def this() = this(Nil, Nil)
----
Додатковий конструктор, показаний в попередньому прикладі, будує порожню чергу. Як покращення, додатковий конструктор може приймати список початкових елементів черги:
[source,scala]
----
def this(elems: T*) = this(elems.toList, Nil)
----
Нагадаємо, що `T*` є нотацією для повторюваних параметрів, як описано в Розділі 8.8.

Інша можливість є додати метод фабрики, що будує чергу з такої послідовності початкових елементів. Милий спосіб зробити це є визначення об'єкта `Queue`, що має те саме ім'я, що і клас, що визначається, та містить метод `apply`, як показано в Лістингу 19.3:
[source,scala]
----
object Queue {
// конструює чергу з початковими елементами xs
  def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
}
----
Лістинг 19.3 - Метод фабрика `apply` в об'єкті компанйоні.

Через покладання цього об'єкту в той самий джерельний файл, що і клас `Queue`, ви робите об'єкт об'єктом компанйоном цього класу. Ви бачили в Розділі 13.5, що об'єкт компанйон має ті самі права доступу, що і його клас. Завдяки цьому метод `apply` в об'єкті `Queue` може створити новий об'єкт `Queue`, навіть якщо конструктор класу `Queue` є приватним.

Зауважте, що оскільки метод фабрики названий `apply`, клієнти можуть створювати черги за допомогою виразів, таких як `Queue(1, 2, 3)`. Цей вираз розширюється до `Queue.apply(1, 2, 3)`, оскільки `Queue` є об'єктом, а не функцією. Як результат, `Queue` виглядає для клієнтів так, якби це був глобально визначений метод фабрики. В реальності Scala не має глобально видимих методів; кожний метод має бути розміщений в об'єкті або класі. Однак використовуючи методи, названі `apply`, всередині глобальних об'єктів, ви можете підтримати шаблони використання, що виглядають як виклики глобальних методів.
[source,scala]
----
trait Queue[T] {
  def head: T
  def tail: Queue[T]
  def enqueue(x: T): Queue[T]
}

object Queue {

  def apply[T](xs: T*): Queue[T] =
    new QueueImpl[T](xs.toList, Nil)

  private class QueueImpl[T](
    private val leading: List[T],
    private val trailing: List[T]
  ) extends Queue[T] {

    def mirror =
      if (leading.isEmpty)
        new QueueImpl(trailing.reverse, Nil)
      else
        this

    def head: T = mirror.leading.head

    def tail: QueueImpl[T] = {
      val q = mirror
      new QueueImpl(q.leading.tail, q.trailing)
    }

    def enqueue(x: T) =
      new QueueImpl(leading, x :: trailing)
  }
}
----
Лістинг 19.4 - Абстракції типів для функціональних черг.

Альтернатива: приватні класи
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Приватні конструктори та приватні члени є одним способом приховати ініціалізацію та репрезентацію класу. Інший, більш радикальний шлях є приховати сам клас, та імпортувати тільки трейт, що розкриває публічний інтерфейс класу. Код в Лістингу 19.4 реаліщзує цей дизайн. Це трейт `Queue`, який декларує методи `head`, `tail`, та `enqueue`. Всі три методи реалізовані як субклас `QueueImpl`, що по собі є приватним інутрішнім класом об'єкта `Queue`. Це виставляє клієнтам ту саму інформацію, що і раніше, але використовуючи іншу технологію. Замість приховування індивідуальних конструкторів та методів, ця версія приховує цілий клас реалізації.

19.3 Анотації варіантності
--------------------------
`Queue`, як визначено в Лістингу 19.4, є трейтом, але не типом. `Queue` не є типом, бо він приймає параметр типу.

Як результат, ви не можете створити змінні типу `Queue`:
[source,scala]
----
scala> def doesNotCompile(q: Queue) = {}
<console>:8: error: class Queue takes type parameters
        def doesNotCompile(q: Queue) = {}
        ^
----
Замість цього, трейт `Queue` дозволяє вам вказати параметризовані типи, такі як `Queue[String]`, `Queue[Int]`, або `Queue[AnyRef]`:
[source,scala]
----
scala> def doesCompile(q: Queue[AnyRef]) = {}
doesCompile: (q: Queue[AnyRef])Unit
----
Таким чином, `Queue` є трейтом, та `Queue[String]` є типом. `Queue` також називають конструктором типу, оскільки ви можете конструювати тип за допомогою нього, вказавши тип параметра. (Це аналогічно до конструювання примірника об'єкта за допомогою старого доброго конструктора, вказавши значення параметра). Конструктор типа `Queue` "генерує" сімейство типів, що включає `Queue[Int]`, `Queue[String]`, та `Queue[AnyRef]`.

Також ви можете сказати, що `Queue` є _дженерік_ трейтом. (Класи та трейти, що приймають параметри типів, є "дженеріками", але типи, що вони генерують, є "параметризованими", не дженеріками). Термін "дженерік" означає, що ви визначаєте багато специфічних типів за допомогою одного загально написаного класу або трейту. Наприклад, трейт `Queue` в Лістингу 19.4 визначає дженерік чергу. `Queue[Int]` та `Queue[String]`, тощо, будуть специфічними чергами.

Комбінація параметрів типів та субтипізація виставляє деякі цікаві питання. Наприклад, чи існують якісь особливі відношення субтипізації між членами сімейства типів, згенерованих `Queue[T]`? Біль точно, чи має `Queue[String]` розглядатись як субтип `Queue[AnyRef]`? Або більш загально, якщо `S` є субтипом типу `T`, тоді чи має `Queue[S]` розглядатись як субтип `Queue[T]`? Якщо так, ви можете сказати, що трейт `Queue` є коваріантним (або "гнучким") по його параметру типу `T`. Або, оскікльи він має тільки один параметр типу, ви можете просто сказати, що `Queue` є коваріантними. Коваріантність `Queue` може означати, наприклад, що ви можете передати `Queue[String]` до метода `doesCompile`, показаного перед цім, що приймає значення параметра типу `Queue[AnyRef]`. 

Інтуітивно, все це виглядає OK, оскільки черга `String` виглядає як особливий випадок черги `AnyRefs`. Однак в Scala дженерік типи мають по замовчанню неваріантне (або "жорстку") субтипізацію. Тобто, з `Queue`, визначеним в Лістингу 19.4, черги з разними типами елементів ніколи не будуть в відношенні субтипізації. `Queue[String]` не буде корисним як `Queue[AnyRef]`. Однак, ви можете вимагати коваріантної (гнучкої) субтипізації черг, через зміну першого рядка цього визначення класу `Queue` таким чином:
[source,scala]
----
trait Queue[+T] { ... }
----
Вказуючи префікс `+` перед формальним параметром типу, вказує, що субтипізація коваріантна (гнучка) в цьому параметрі. Через додавання цього одного символа, ви кажете Scala, що ви бажаєте, щоб `Queue[String]`, наприклад, розглядався як субтип `Queue[AnyRef]`. Компілятор буде перевіряти, що `Queue` визначений в спосіб, що така субтипізація має місце.

Крім `+`, також є і префікс `-`, що вказує контрваріантну субтипізацію. Якщо б `Queue` було визначено таким чином:
[source,scala]
----
trait Queue[-T] { ... }
----
тоді, якщо `T` є субтипом типу `S`, це буде означати, що `Queue[S]` є субтипом `Queue[T]` (що в випадку черги буде досить несподівано!). Чи є параметр типу коваріантним, контрваріантним або неваріантним, все це називається варіантністю параметра. Символи `+` та `-`, що ви можете покладати коло параметрів типу, називаються анотаціями варіантності.

В чисто функціональному світі багато типів є природно коваріантними (гнучкими). Однак ситуація змінюється, коли ми вводимо змінні дані. Щоб зрозуміти чому, розглянемо простий тип одно-елементних клітин, що можуть бути прочитані та записані, показаний в Лістингу 19.5.
[source,scala]
----
class Cell[T](init: T) {
  private[this] var current = init
  def get = current
  def set(x: T) = { current = x }
}
----
Лістинг 19.5 - Неваріантний (жорсткий) клас `Cell`.

Тип `Cell` в Лістингу 19.5 деклароване як неваріантне (жорстке). Для цілей доказу, уявімо на момент, що замість цього `Cell` був декларований коваріантним, тобто, він був деларований як клас `Cell[+T]` — і в такому вигляді переданий компілятору Scala. (Він не буде, і ми скоро пояснимо чому). Тоді ви можете сконструювати наступну проблематичну послідовність тверджень:
[source,scala]
----
val c1 = new Cell[String]("abc")
val c2: Cell[Any] = c1
c2.set(1)
val s: String = c1.get
----
Взяті окремо, кожний з ціх чотирьох рядків виглядають OK. Перший рядок створює клітину рядків, та зберігає її в `val` на ім'я `c1`. Другий рядок визначає новий `val`, `c2`, типу `Cell[Any]`, що ініціалізований `c1`. Це OK, оскільки `Cells` вважається контрваріантним. Третій рядок встановлює значення клітинки `c2` в `1`. Це також OK, оскільки присвоєне значення `1` є примірником типу елемента `c2`, `Any`. Нарешті, останній рядок присвоює значення елементу `c1` в рядок. Тут також нічого дивного, бо обоє сторін однакового типу. Вле взяті разом, ці чотири рядка закінчуються присвоєнням цілого `1` до рядка `s`. Це, очевидно, порушення значення типу.

Яка операція винна в рантайм збої? Це, напевне, другий, що використовує коваріантну субтипізацію. Ініш твердження дуже прості та фундаментальні. Таким чином, `Cell` зі `String` також є `Cell` з `Any`, оскільки є такі речі, які ви можете робити з `Cell` з `Any`, які ви не можете робити з `Cell` з `String`. Наприклад, ви не можете використовувати `set` з аргументом `Int` на `Cell` зі `String`.

Фактично, коли ви передаєте коваріанту версію `Cell` до компілятора `Scala`, ви будете отримувати помилку часу компілятора:
[source,scala]
----
Cell.scala:7: error: covariant type T occurs in
contravariant position in type T of value x
    def set(x: T) = current = x
               ^
----               
Варіантність та масиви
~~~~~~~~~~~~~~~~~~~~~~
Цікаво порівняти цю поведінку з масивами в Java. В принципі масиви такі ж, як клітини, за винятком того, що вони можуть мати більше одного елементу. Тим не менш, масиви розглядаються як коваріантні в Java. Ви можете спробувати приклад, аналогічний до взаємодії з клітиною, описаний тут для Java масивів:
[source,java]
----
// це Java
String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);
String s = a1[0];
----
Якщо ви спробуєте цей приклад, ви знайдете, що це буде компілюватись. Але виконання програми буде викликати виключення `ArrayStore`, що буде закинуте, коли `a2[0]` присвоюється до `Integer`:
[source,scala]
----
Exception in thread "main" java.lang.ArrayStoreException:
java.lang.Integer
        at JavaArrays.main(JavaArrays.java:8)
----
Що тут відбувається, це те, що Java зберігає тип елементу під час виконання. Потім, кожний раз, коли елемент масиву оновлюється, значення нового елементу перевіряється на збережений тип. Якщо це не примірник цього типу, буде закинуте виключення `ArrayStore`.

Ви можете запитати, чому Java прийняла цей дизайн, що виглядає одночасно небезпечним та коштовним. Коли йому задавали це питання, James Gosling, головний винахідник мови Java, відповідав, що вони бажали мати прості засоби для загального трактування масивів. Наприклад, вони бажали бути в змозі записати метод для сортування всіх елементів в масиві, використовуючи сигнатуру, подібну до наступної, що приймає массив з `Object`:
[source,scala]
----
void sort(Object[] a, Comparator cmp) { ... }
----
Коваріантність масивів була необхідною, так щоб масиви довільного типу посилання могли бути передані до метода `sort`. Звичайно, з появою Java дженериків такий метод `sort` тепер може бути написаний з параметром типу, так що коваріантність масивів більше не потрібна. Однак з причин сумісності вона дозволена в Java до цього дня.

Scala намагається бути чистішою, ніж Java, не розглядаючи масиви як коваріантні. Ось що ми отримаємо, якщо перенесемо перші два рядкі приклада масива в Scala:
[source,scala]
----
scala> val a1 = Array("abc")
a1: Array[String] = Array(abc)

scala> val a2: Array[Any] = a1
<console>:8: error: type mismatch;
 found   : Array[String]
 required: Array[Any]
        val a2: Array[Any] = a1
                             ^
----
Що тут відбувається, це те, що Scala розглядає масиви як неваріантні (жорсткі), так що `Array[String]` не розглядається як сумісний з `Array[Any]`. Однак, іноді є необхідним взаємодіяти зі старими методами в Java, що використовують масив `Object`, як спосіб емуляції дженерік масивів. Наприклад, ви можете побажати викликати метод `sort`, як описаний до цього, з масивом `String` в якості аргумента. Щоб зробити це можливим, Scala дозволяє вам привести масив `T` до масива любого супертипу T:
[source,scala]
----
scala> val a2: Array[Object] =
          a1.asInstanceOf[Array[Object]]
a2: Array[Object] = Array(abc)
----
Кастинг завжди легальний під час компіляції, та він буде завжди успішним під час виконання, тому що модель рантайма JVM трактує масиви як коваріантні, так само, як сама мова Java. Але після цього ви можете отримати виключення `ArrayStore`, знову так само, як це відбувається в Java.

19.4 Перевірка анотацій варіантності
------------------------------------
Тепер, коли ви бачили деякі приклади, де варіантність не має сенсу, ви можете поцікавитись, які визначення класу треба відсторонити, та які можуть бути прийнятними. Досі всі порушення сенсу типізації включали деяке переприсвоюване поле або елемент масиву. Чисто функціональна реалізація черги, з іншого боку, виглядає як гарний варіант на коваріантність. Однак наступний приклад показує, що ви можете "зінженерити" безглузду ситуацію, навіть якщо немає жодних переприсвоюваних полів.

Щоб налаштувати приклад, будемо вважати, що черги, визначені в Лістингу 19.4, коваріантними. Потім створимо субклас черги, що спеціалізує тип елементу як `Int`, та перекриває метод `enqueue`:
[source,scala]
----
class StrangeIntQueue extends Queue[Int] {
  override def enqueue(x: Int) = {
    println(math.sqrt(x))
    super.enqueue(x)
  }
}
----
Метод `enqueue` з `StrangeIntQueue` роздруковує квадратний корінь свого (цілого) аргументу, перед виконанням власне додавання.

Тепер ми можемо написати контрприклад в два рядки:
[source,scala]
----
val x: Queue[Any] = new StrangeIntQueue
x.enqueue("abc")
----
Перший з ціх двох рядків валідний, бо `StrangeIntQueue` є субкласом `Queue[Int]`, і, зважаючи на коваріантність черг, `Queue[Int]` є субтипом `Queue[Any]`. Другий рядок є валідним, оскільки ви можете додати `String` до `Queue[Any]`. Однак, взяті разом, ці два рядка мають ефект застосування квадратного кореня до рядка, що не має сенсу.

Зрозуміло, що це не тільки змінні поля, що робить коваріантні типи безглуздими. Проблема більш загальна. З'ясовується, що як тільки дженерік параметр типу з'являється як тип параметру метода, клас або трейт, що містить це, не може бути коваріантним по цьому параметру типу.

Для черг метод `enqueue` порушує цю умову:
[source,scala]
----
class Queue[+T] {
  def enqueue(x: T) =
...
}
----
Виконуючи модифікований клас черги, як вище, через компілятор Scala, буде давати:
[source,scala]
----
Queues.scala:11: error: covariant type T occurs in
contravariant position in type T of value x
  def enqueue(x: T) =
             ^
----
Переприсвоювані поля є особливим випадком правила, що не дозволяє параметрам типу,анотованим з допомогою `+`, бути використаними як паратаметри типів в методах. Як зазначалось в Розділі 18.2, переприсвоюване поле, `var x: T`, трактується в Scala як метод геттер `def x: T`, та метод сеттер, `def x_=(y: T)`. Як ви можете бачити, метод сеттера має параметр типа поля `T`. Так що цей тип не може бути коваріантним.

Швидкий шлях
------------
В залишку цього розділу ми опишемо механізм, завдяки якому компілятор Scala перевіряє анотації варіантності. Якщо вам доки досить деталей, ви можете безпечно перейти до Розділу 19.5. Найбільш важлива річ, що треба зрозуміти, це що компілятор Scala буде перевіряти кожну анотацію варіантності, яку ви покладете до параметрів типу. Наприклад, якщо ви спробуєте декларувати параметр типу як коваріантний (через додавання `+`), але це призведе до потенційних помилок під час виконання, ваша програма не буде компілюватись.

Щоб перевірити коректність анотацій варіантності, компілятор Scala класифікує всі позиції в тілі класу або трейта як позитівні, негативні, або нейтральні. "Позиція" є люба локація в тілі класу або трейта (відтепер будемо казати просто "клас"), де може використовуватись параметр типу. Наприклад, кожний параметр значення метода є позицією, оскільки значення параметру метода має тип. Таким чином, параметр типу може опинитись в цій позиції.

Компілятор перевіряє кожне використання кожного з параметрів типу класа. Параметри типів, анотовані за допомогою `+`, можуть використовуватись в позитивних позиціях, тоді як параметри типів, анотовані за допомогою `-`, можуть бути використані тільки в негативних позиціях. Параметр типу, що не має анотації варіантності, може бути використаний в любій позиції, і, таким чином, є одним різновидом параметрів типу, що може використовуватись в нейтральних позиціях тіла класу.

Щоб класифікувати позиції, компілятор починає з декларації параметру типу, та потім рухається всередину, через глибокі вкладені рівні. Позиції на верхньому рівні декларації класу класифікуються як позитивні. По замовчанню, позиції на глибших вкладених рівнях класифікуються так само, що і на оточуючих рівнях, але є декілька виключень, де класифікація змінюється. Параметри значень методів є позиції, де класифікація обертається відносно кваліфікації за межами метода, де позитивна класифікація стає негативно, негативна позитивною, та обертання нейтральної класифікації буде знову нейтральна.

Крім позицій параметрів значень методів, поточна класифікація обертається на параметрах типів методу. Класифікація іноді обертається в позиції аргумента типу для типу, як в `Arg` в `C[Arg]`, в залежності від варіантності відповідного параметру типу. Якщо параметр типу типу `C` анотований з `+`, тоді класифікація залишається та сама. Якщо параметр типу `C` анотований з  `-`, тоді поточна класифікація обертається. Якщо параметр типу `C` не має анотацій варіантності, тоді поточна класифікація змінюється до нейтральної.

Як дещо надуманий приклад, розглянемо наступне визначення класу, де декілька позицій анотовані за допомогою своєї класифікації, `^+` (для позитивної) або `^-` (для негативної):
[source,scala]
----
abstract class Cat[-T, +U] {
  def meow[W^-](volume: T^-, listener: Cat[U^+, T^-]^-)
    : Cat[Cat[U^+, T^-]^-, U^+]^+
}
----
Позиції параметру типу, `W`, та двох параметрів значень, `volume` та `listener`, є всі негативними. Дивлячись на результат `meow`, позиція першого аргумента `Cat[U, T]` є негативною, бо перший параметр типу `Cat`, `T`, анотований за допомогою `-`. Тип `U` в цьому аргументі знову в позитивній позиції (два обертання), Тоді як тип `T` в цьому аргументі все ще в негативній позиції. Ви бачите з цієї дискусії, що відстежувати позиції варіантності досить складно.

Ось чому буде приємною новина, що компілятор Scala робить це за вас.

Коли класифікація обчислена, компілятор перевіряє кожний параметр типу, що він використовується тільки в позиціях, де він відповідно класифікаваний. В цьому випадку `T` використовується тільки в негативних позиціях, та `U` тільки в позитивних позиціях. Так що клас `Cat` є типово коректним.

19.5 Нижня межа
---------------
Повертаючись до класу `Queue`. Ви бачили, що попереднє визначення `Queue[T]`, показане в Лістингу 19.4, не може бути зроблене коваріантним по `T`, оскільки `T` з'являється як параметр типу метода `enqueue`, і це негативна позиція.

На щастя, є шлях роблокувати ситуацію: ви можете узагальнити `enqueue`, зробивши його поліморфним (тобто, надавши самому методу `enqueue` параметр типу), та використавши нижню межу для його параметру типу. Лістинг 19.6 показує нове формулювання `Queue`, що реалізує цю ідею.
[source,scala]
----
class Queue[+T] (private val leading: List[T],
    private val trailing: List[T] ) {
  def enqueue[U >: T](x: U) =
    new Queue[U](leading, x :: trailing) // ...
}
----
Лістинг 19.6 - Параметр типу з нижньою межею.

Нове визначення надає `enqueue` параметр типу `U`, та за допомогою синтаксиса `U >: T` визначає `T` як нижню межу для `U`. Як результат, від `U` вимагається бути субтипом  `T`.footnote:[Відношення субтипу та супертипу є рефлексивними, що означає, що тип є одночасно супертипом та субтипом себе. Навіть якщо `T` є нижньою межею для `U`, ви все ще можете передати в `enqueue` `T`.] Параметр `enqueue` тепер є типу `U`, замість `T`, та повернене значення метода тепер `Queue[U]`, замість `Queue[T]`.

Наприклад, уявімо, що є клас `Fruit` з двома субкласами, `Apple` та `Orange`. З новим визначенням класу `Queue` можливо додати `Orange` до `Queue[Apple]`. Результатом буде `Queue[Fruit]`.

Це модифіковане визначення `enqueue` типово коректне. Інтуітивно, якщо `T` є більш специфічним типом, ніж очікується (наприклад, `Apple` замість `Fruit`), виклик до `enqueue` все одно буде робити, оскільки `U` (`Fruit`) буде все ще супертипом типу `T` (`Apple`).footnote:[Технічно, те що відбувається, це обернення для нижньої межі. Параметр типу `U` є в негативній позиції (1 обернення), тоді як нижня межа (`>: T`) в позитивній позиції (2 обернення).]

Нове визначення `enqueue` є, можливо, кращим, ніж старе, оскільки воне більш загальне. На відміну від старої версії, нове визначення дозволяє вам додати довільний супертип `U` типу елемента черги `T`. Після цього результатом буде `Queue[U]`. Разом з коваріантністю черги, це дає правильний різновід гнучкості для моделювання черг з різними типами елементів в природний спосіб.

Це показує, що анотації варіантності та ніжні межі гарно грають разом. Вони є гарним прикладом типо-рушійної розробки, де типи інтерфейсів направляють її детальний дизайн та реалізацію. В випадку черг, можливо, ви не будете розмірковувати щодо покращеної реалізації `enqueue` з нижньою межею. Але ви можете вирішити зробити чергу коваріантною, в якому випадку компілятор буде вказувати на помилку варіантностів в `enqueue`. Корегування помилки варіантності через додавання нижньої межі робить `enqueue` більш загальним, та черги загалом більш корисними.

Це дослідження також є головною причиною того, що Scala обирає варіантність на стороні декларації, замість варіантності на боці використання, як це відбувається в замінниках Java. З варіантністю на боці використання, ви наодинці при розробці свого класу. Це буде клієнт класу, той, що покладатиме підстановку, і якщо він зробить щось не так, деякі важливі методи примірників будуть більше незастосовні. Варіантність залишається хитрою справою, користувачі часто розміють її невірно, та вони ідуть геть, думаючи, що підстановки та дженеріки дуже ускладнені. З варіантністю на боці визначення ви викладаєте ваші наміри компілятору, та компілятор двічи перевірить, що методи, які ви бажаєте, будуть доступними.

19.6 Контрваріантність
----------------------
Докі в цій главі всі приклади, що ви бачили, були або коваріантними, або неваріантними. Але також є випадки, коли є природною контрваріантність. Наприклад, розглянемо трейт вихідного каналу, показаний на Лістингу 19.7:
[source,scala]
----
trait OutputChannel[-T] {
  def write(x: T)
}
----
Лістинг 19.7 - Контрваріантний вихідний канал.

Тут `OutputChannel` визначений бути контрваріантним по `T`. Так що, скажімо, вихідний канал `AnyRefs` є субтипом вихідного каналу `Strings`. Хоча це може виглядати неінтуітивним, насправді це має сенс. Щоб побачити чому, розглянемо, що ви можете робити з `OutputChannel[String]`. Одна підтримувана операція є запис `String` в канал. Та сама операція може також бути виконана на `OutputChannel[AnyRef]`. Так що безпечно підставити `OutputChannel[AnyRef]` замість `OutputChannel[String]`. Для контрасту, може бути небезпечним підставити `OutputChannel[String]` там, де потрібен `OutputChannel[AnyRef]`. Кінець кінцем, ви можете надіслати любий об'єкт до `OutputChannel[AnyRef]`, в той час, коли `OutputChannel[String]` потребує щоб всі записані елементи були рядками.

Ці міркування вказують на загальний принцип в розробці системи типів: безпечно вважати, що тип `T` є субтипом типу `U`, якщо ви можете підставити значення `T` там, де вимагається значення типу `U`. Це називається принципом підстановки Ліскова. Принцип стверджує, що тоді `T` підтримує ті самі операції, що і `U`, та всі операції `T` потребують меньше, та провадять більше, ніж відповідні операції `U`. В цьому випадку з вихідними каналами, `OutputChannel[AnyRef]` може бути субтипом `OutputChannel[String]`, оскільки обоє підтримують ту саму операцію `write`, та ця операція потребує меньше в `OutputChannel[AnyRef]`, ніж в `OutputChannel[String]`. "Меньше" означає, що від аргумента вимагається тільки бути `AnyRef` в першому випадку, тоді як він має бути  `String` в другому випадку.

Іноді коваріантність та контрваріантність змішані в одному типі. Яскравий приклад є функціональні трейти Scala. Наприклад, коли ви пишете функціональний тип `A => B`, Scala розширює це до `Function1[A, B]`. Визначення `Function1` в стандартній бібліотеці використовує одночасно коваріантність та контрваріантність: трейт `Function1` є контрваріантним по функціональному типу аргумента `S`, та коваріантним по типу результату `T`, як показано в Лістингу 19.8. Це задовільняє принципу підстановки Ліскова, оскільки аргументи є іноді тим, що вимагається, тоді як результат іноді те, що було запроваджено.
[source,scala]
----
trait Function1[-S, +T] {
  def apply(x: S): T
}
----
Лістинг 19.8 - Коваріантність та контрваріантність `Function1s`.

Як приклад, розглянемо застосування, показане в Лістингу 19.9. Тут клас `Publication` містить одно параметричне поле, `title`, типу `String`. Клас `Book` розширює `Publication`, та пересилає його параметр `title` в конструктор свого суперкласу. Об'єкт синглтон `Library` визначає набір книжок, та метод `printBookList`, що приймає функцію на ім'я `info`, типу `typeBook => AnyRef`. Іншими словами, тип єдиного параметра `printBookList` є функцією, що приймає один аргумент `Book`, та повертає `AnyRef`. Застосування `Customer` визначає метод `getTitle`, що приймає `Publication` як свій єдиний параметр, та повертає `String`, заголовок переданого `Publication`.
[source,scala]
----
class Publication(val title: String)
class Book(title: String) extends Publication(title)

object Library {
  val books: Set[Book] =
    Set(
      new Book("Programming in Scala"),
      new Book("Walden")
    )

  def printBookList(info: Book => AnyRef) = {
    for (book <- books) println(info(book))
  }
}

object Customer extends App {
  def getTitle(p: Publication): String = p.title
  Library.printBookList(getTitle)
}
----
Лістинг 19.9 - Демонстрація варіантності параметру типу функції.

Тепер поглянемо на останній рядок `Customer`. Цей рядок викликає метод `Library`  `printBookList`, та передає `getTitle`, оточений в функціональне значення:
[source,scala]
----
Library.printBookList(getTitle)
----
Цей рядок коду проходить перевірку типів, навіть якщо `String`, тип результату функції, є субтипом `AnyRef`, типу результата параметра `info` метода `printBookList`. Цей код проходить компілятор, оскільки типи результата функції декларований як коваріантний (`+T` в Лістингу 19.8). Якщо ви подивитесь в тіло `printBookList`, ви можете отримати проблиск, чому це має сенс.

Метод `printBookList` ітерує по своєму списку книжок, та викликає передану функцію для кожної книжки. Він передає результат `AnyRef`, що повертає `info`, до `println`, що викликає на ньому `toString`, та друкує результат. Ця активність буде робити зі `String` так само, як і інші субкласи `AnyRef`, що саме і означає коваріантність результату функції.

Тепер розглянемо тип параметру функції, коли він передається до метода `printBookList`. Хоча тип параметра `printBookList` декларований як `Book`, `getTitle`, яку ми передаємо туди, приймає `Publication`, супертип `Book`. Причина, чому це робить, полягає в тому, що оскільки тип параметра `printBookList` є `Book`, в тілі метода `printBookList` буде дозволено передати `Book` в функцію. І оскількі тип параметра `getTitle` є `Publication`, тіло цієї функції буде в змозі отримати доступ тільки до свого параметра, `p`, члени якого декларовані в класі `Publication`. Оскільки любий метод, декларований в `Publication` також доступний в субкласі `Book`, все повинно робити, що є саме те, що означає контрваріантність функціонального параметру. Ви можете бачити все це графічно на Малюнку 19.1.

Код в Лістингу 19.9 компілюється, оскільки `Publication => String` є субтипом `Book => AnyRef`, як показано в центрі Малюнка 19.1. Оскільки тип результата `Function1` є визначеним як коваріантний, відношення наслідування двох типів результату, показані справа діаграми, є в тому самому напрямку, що той у двох функцій, показаних в центрі. По контрасту, оскільки тип параметра `Function1` визначений як контрваріантний, відношення наслідування двох типів параметрів, показаних зліва від діаграми, ідуть в зворотньому напрямку, ніж ті для двох функцій.

Малюнок 19.1 - Коваріантність і контрваріантність в параметрах типів функції.
[source,scala]
----
class Queue[+T] private (
  private[this] var leading: List[T],
  private[this] var trailing: List[T]
) {

  private def mirror() =
    if (leading.isEmpty) {
      while (!trailing.isEmpty) {
        leading = trailing.head :: leading
        trailing = trailing.tail
      }
    }

  def head: T = {
    mirror()
    leading.head
  }

  def tail: Queue[T] = {
    mirror()
    new Queue(leading.tail, trailing)
  }
  
  def enqueue[U >: T](x: U) =
    new Queue[U](leading, x :: trailing)
}
----
Лістинг 19.10 - Оптимізована функціональна черга.

19.7 Приватні дані об'єкта
--------------------------
Клас `Queue`, яку ми бачили до цього, має проблему в тому, що операція `mirror` буде постійно копіювати список `trailing` в `leading`, якщо `head` буде викликатись декілька разів поспіль для списку, коли `leading` є порожнім. Марного копіювання можна уникнути, додаючи деякі розсудливі побічні ефекти. Лістинг 19.10 презентує нову реалізацію `Queue`, що виконує щонайбільше одне коригування `trailing` до `leading` для кожної послідовності операцій `head`.

Що тут відмінне з точки зору попередньої версії, є те, що тепер `leading` та `trailing` є переприсвоювані змінні, і `mirror` виконує реверсивну копію від `trailing` до `leading` як побічний ефект на поточній черзі, замість повернення нової черги. Цей побічний ефект чисто внутрішній відносно до реалізації операцій `Queue`; оскільки `leading` та `trailing` є приватними змінними, ефект не є видимий для клієнтів `Queue`. Так що за термінологією, встановленою в Главі 18, нова версія `Queue` все ще визначає чисто функціональні об'єкти, не зважаючи на факт, що вони тепер містять переприсвоювані поля.

Ви можете поцікавитись, чи цей код пройде перевірку типів Scala. Кінець кінцем, тепер черги містять два переприсвоювані поля коваріантного параметру типу `T`. Чи це не порушення правил варіантності? Це було б так, за винятком тої деталі, що `leading` та `trailing` мають модифікатор `private[this]`, і, таким чином декларовані як приватні до об'єкта.

Як зазначалось в Розділі 13.5, приватні до об'єкта члени можуть отримувати доступ тільки з того самого об'єкта, де вони визначені. З'ясовується, що доступ до змінних з того самого об'єкта, в якому вони визначені, не викликають проблем з варіантністю. Інтуітивне пояснення в тому, що щоб сконструювати випадок, коли варіантність призведе до помилки типів, вам треба мати посилання на містячий об'єкт, що має статично слабший тип, ніж тип об'єкта, з яким об'єкт був визначений. Але для доступу до об'єкт приватних значень це неможливо.

Перевірка варіантності в Scala містить особливий випадок для об'єкт приватних визначень. Такі визначення оминаються при перевірці, що параметр типу з анотаціями `+` або `-` з'являється лише в позиціях, що мають ту саму класифікацію варіантності. Таким чином, код в Лістингу 19.10 компілюється без помилок. З іншого боку, якщо ви приберете кваліфікатор `[this]` для двох  модифікаторів `private`, ви побачите дві помилки типу:
[source,scala]
----
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter leading_=
class Queue[+T] private (private var leading: List[T],
                                     ^
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter trailing_=
                        private var trailing: List[T]) {
                                    ^
----                                    
19.8 Верхня межа
----------------
В Лістингу 16.1 ми показали функцію сортування злиттям для списків, що приймає функцію порівняння як перший аргумент, і список для сортування в якості другого, каровані аргументи. Інший шлях, як ви можете організувати таку функцію сортування, це змусити тип списку зміксувати трейт `Ordered`. Як зазначалось в Розділі 12.4, через міксування `Ordered` в клас, та реалізуючи єдиний абстрактний метод `Ordered`, `compare`, ви дозволяєте клієнтам порівнювати примірники цього класу за допомогою `<`, `>`, `<=`, та `>=`. Наприклад, Лістинг 19.11 показує `Ordered`, що зміксовано в клас `Person`.

Як результат ви можете порівнювати двох людей, ось так:
[source,scala]
----
scala> val robert = new Person("Robert", "Jones")
robert: Person = Robert Jones

scala> val sally = new Person("Sally", "Smith")
sally: Person = Sally Smith

scala> robert < sally
res0: Boolean = true

class Person(val firstName: String, val lastName: String)
    extends Ordered[Person] {

  def compare(that: Person) = {
    val lastNameComparison =
      lastName.compareToIgnoreCase(that.lastName)
    if (lastNameComparison != 0)
      lastNameComparison
    else
      firstName.compareToIgnoreCase(that.firstName)
  }

  override def toString = firstName + " " + lastName
}
----
Лістинг 19.11 - Клас `Person`, міксує трейт `Ordered`.
[source,scala]
----
def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) => ys
      case (_, Nil) => xs
      case (x :: xs1, y :: ys1) =>
        if (x < y) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
  val n = xs.length / 2
  if (n == 0) xs
  else {
    val (ys, zs) = xs splitAt n
    merge(orderedMergeSort(ys), orderedMergeSort(zs))
  }
}
----
Лістинг 19.12 - Функція сортування злиттям з верхньою межею.

Щоб змусити тип списку, що передається в нову функцію сортування, міксувати `Ordered`, вам треба встановити верхню межу. Верхня межа вказується подібно до нижньої межі, за винятком того, що замість символа `>:`, що використовується для нижньої межі, ви використовуєте символ `<:`, як показано в Лістингу 19.12.

З синтаксисом `T <: Ordered[T]` ви вказуєте, що параметр типу, `T`, має верхню межу,`Ordered[T]`. Це означає, що тип елемента списка, переданого до `orderedMergeSort`, має бути субтипом від `Ordered`. Таким чином, ви можете передати `List[Person]` до `orderedMergeSort`, оскільки `Person` зміксований з `Ordered`.

Наприклад, розглянемо цей список:
[source,scala]
----
scala> val people = List(
          new Person("Larry", "Wall"),
          new Person("Anders", "Hejlsberg"),
          new Person("Guido", "van Rossum"),
          new Person("Alan", "Kay"),
          new Person("Yukihiro", "Matsumoto")
       )
people: List[Person] = List(Larry Wall, Anders Hejlsberg,
  Guido van Rossum, Alan Kay, Yukihiro Matsumoto)
----  
Оскільки тип елемента цього списка, `Person`, міксується (і таким чином є його субтипом) `Ordered[People]`, ви можете передати список до `orderedMergeSort`:
[source,scala]
----
scala> val sortedPeople = orderedMergeSort(people)
sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
  Yukihiro Matsumoto, Guido van Rossum, Larry Wall)
----
Тепер, хоча функція сортування, показана в Лістингу 19.12, служить як корисна ілюстрація верхньої межі, насправді це не найбільш загальний шлях в Scala для розробки функції сортування, що набуває вигод від трейту `Ordered`.

Наприклад, ви не можете використовувати функцію `orderedMergeSort` для сортування списку цілих, оскільки клас `Int` не є субтипом `Ordered[Int]`:
[source,scala]
----
scala> val wontCompile = orderedMergeSort(List(3, 2, 1))
<console>:5: error: inferred type arguments [Int] do
   not conform to method orderedMergeSort's type
      parameter bounds [T <: Ordered[T]]
        val wontCompile = orderedMergeSort(List(3, 2, 1))
                          ^
----  
В Розділі 21.6 ми побачимо, як використовувати неявні параметри та обмеження контекстів, щоб досягти більш загального рішення.

19.9 Висновок
-------------
В цій главі ви бачили декілька прийомів для приховування інформації: приватні конструктори, методи фабрик, абстракції типів та об'єкт приватні члени. Ви також навчились, як задавати варіантність типів, та що це накладає на реалізацію класів. Нарешті, ви бачили два прийоми, що допоможуть в отриманні гнучких анотацій варіантності: нижні межі для параметрів типу методів, та анотації `private[this]` для локальних полів та методів.
