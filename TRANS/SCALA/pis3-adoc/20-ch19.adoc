include::headers.adoc[]

Глава 19
--------

Параметризація типів
====================

В цій главі ми пояснимо деталі параметризації типів в Scala. По ходу ми продемонструємо деякі з прийомів приховування інформації, з якою ви ознайомились в Главі 13 через використання суцільного прикладу: розробки класу для повністю функціональних черг. Ми презентуємо параметризацію типів та приховування разом, оскільки приховування інформації може використовуватись для більш загальної параметризації типів з анотаціями варіантності.

Типова параметризація дозволяє вам писати загальні класи та трейти. Наприклад, множини є загальними та приймають параметр типу: вони визначені як `Set[T]`. Як результат, любий окремий примірник множини може бути `Set[String]`, `Set[Int]`, тощо, але він має бути множиною чогось. На відміну від Java, що дозволяє сирі типи, Scala вимагає, щоб ви вказували параметри типів. Варіантність визначає відношення наслідування для параметризованих типів, наприклад, такі як: чи є `Set[String]` субтипом `Set[AnyRef]`.

Глава містить три частини. Перша частина розробляє структуру даних для повністю функціональних черг. Друга частина розробляє техніку для приховування деталей внутрішньої репрезентації цієї структури. Заключна частина пояснює варіантність, та як вона взаємодіє з приховуваннями інформації.

19.1 Функціональні черги
------------------------
Функціональна черга є структурою даних з трьома операціями:

`head` повертає перший елемент черги
  
`tail` повертає чергу без першого елемента

`enqueue` повертає нову чергу з наданим елементом
          доданим в кінець

На відміну від змінної черги, функціональна черга не змінює вміст коли додається елемент. Замість цього повертається нова черга, що містить цей елемент. Ціль цієї глави - створити клас, що буде мати ім'я `Queue`, що робить таким чином:
[source,scala]
----
scala> val q = Queue(1, 2, 3)
q: Queue[Int] = Queue(1, 2, 3)

scala> val q1 = q enqueue 4
q1: Queue[Int] = Queue(1, 2, 3, 4)

scala> q
res0: Queue[Int] = Queue(1, 2, 3)
----
Якщо `Queue` мав би змінну реалізацію, операція `enqueue` в другому рядку мала б впливати на вміст `q`; фактично, після цієї операції обидві черги, результат `q1` та оригінальна черга `q`, мали б містити послідовність `1, 2, 3, 4`. Але для функціональної черги додане значення можна побачити тільки в результаті `q1`, та не в черзі `q`, на якій виконується операція.

Чисто функціональні черги також мають деяку подібність до списків. Обоє є так званими повністю стійкими структурами даних, коли старі версії залишаються доступні, навіть після розширення або модифікації. Вони підтримують операції `head` та `tail`. Але коли список звичайно розширюється зпереду, використовуючи операцію `::`, черга розширюється з кінця, використовуючи `enqueue`.

Як це може бути реалізовано ефективно? Ідеально, функціональна (незмінна) черга не повинна мати фундаментально вище навантаження, ніж імперативна (змінна). Тобто, всі три операції, `head`, `tail`, `enqueue`, повинні виконуватись за сталий час. Один простий підхід реалізувати функціональну чергу, що буде використовувати список як тип репрезентації.

Тоді `head` та `tail` будуть просто транслюватись в такі ж операції на списках, тоді як `enqueue` має бути конкатенацією.

Це буде давати таку реалізацію:
[source,scala]
----
class SlowAppendQueue[T](elems: List[T]) { // неефективне
  def head = elems.head
  def tail = new SlowAppendQueue(elems.tail)
  def enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
}
----
Проблема з цією реалізацією знаходиться в операції `enqueue`. Вона займає час, пропорційну до числа елементів, що зберігаються в черзі. Якщо ви бажаєте додавати елементи за сталий час, ви також можете спробувати обернути порядок елементів в представленому списку, так щоб останній елемент, що додається, був би першим в списку. Це може привести до наступної реалізації:
[source,scala]
----
class SlowHeadQueue[T](smele: List[T]) { // неефективне
// smele це обернене elems
  def head = smele.last
  def tail = new SlowHeadQueue(smele.init)
  def enqueue(x: T) = new SlowHeadQueue(x :: smele)
}
----
Тепер `enqueue` займає сталий час, але `head` та `tail` - ні. Тепер вони витрачають час, пропорційний до кількості елементів, що зберігаються в черзі.

Дивлячись на ці два приклади, виглядає непростим запропонувати реалізацію, що має сталий час для всіх трьох операцій. Фактично, виглядає сумнівним, щоб це взагалі було можливим! Однак комбінуючи дві операції ви можете підійти дуже близько. Ідея є представити чергу як два списки, названі `leading` та `trailing`. Список `leading` містить елементи, ближчі до початку, тоді як список `trailing` містить елементи, ближчі до кінця черги в оберненому порядку. Вміст цілої черги в кожну мить є рівним `leading ::: trailing.reverse`.

Тепер, щоб додати елемент, ви просто робите йому `cons` до списку `trailing`, використовуючи оператор `::`, так що `enqueue` має сталий час. Це означає, що спочатку, коли порожня черга конструююється з послідовних операцій `enqueue`, список `trailing` буде зростати, тоді як список `leading` буде залишатись порожньою. Потім, перед першою операцією `head` або `tail`, що буде виконана для порожнього списку `leading`, цілий список `trailing` копіюється до `leading` з реверсом порядку елементів. Це робиться операцією, що називається `mirror`. Лістинг 19.1 показує реалізацію черги, що використовує цей підхід.
[source,scala]
----
class Queue[T](
  private val leading: List[T],
  private val trailing: List[T]
) {
  private def mirror =
    if (leading.isEmpty)
      new Queue(trailing.reverse, Nil)
    else
      this

  def head = mirror.leading.head

  def tail = {
    val q = mirror
    new Queue(q.leading.tail, q.trailing)
  }

  def enqueue(x: T) =
    new Queue(leading, x :: trailing)
}
----
Лістинг 19.1 - Базова функціональна черга.

Яка складність цієї реалізації черги? Операція `mirror` може займати час, пропорційну до кількості елементів в списку, але тільки якщо список `leading` порожній. Він повертається безпосередьньо, якщо `leading` непорожній. Оскільки `head` та `tail` викликають `mirror`, їх складність також може бути лінійною до розміру черги, також. Однак чим більшою стає черга, тим рідше викликається `mirror`.

Дійсно, припустімо є черга довжиною `n` з порожнім списком `leading`. Тоді `mirror` має реверс-копіювати список довжини `n`. Однак наступного разу `mirror` буде мати виконати будь яку роботу, коли список `leading` буде знову порожній, що буде після `n` операцій `tail`. Це означає, що ви можете "заряджати" кожну з ціх `n` операцій `tail` один раз на `n` від складності `mirror`, що означає сталу кількість роботи. Зважаючи, що операції `head`, `tail`, та `enqueue` з'являються з тою самою частотою, амортизована складність, таким чином, є константою для кожної операції. Так що функціональні черги асимптотично такі ж само ефективні, як і змінні.

Тепер, ось декілька застережень, що треба додати до ціх аргументів. Перше, дискусія була тільки про асимптотичну поведінку. Друге, аргументація покладалась на факт, що `head`, `tail` та `enqueue` викликаються з майже такою ж частотою. Якщо `head` викликана значно частіше, ніж інші дві операції, наш аргумент не діє, бо кожний виклик `head` може включати коштовну реорганізацію списку в `mirror`. Друге застереження можна оминути; можливо розробити функціональні черги, так щоб для послідовних операцій `head` тільки перша могла потребувати реорганізації. Ви з'ясуєте в кінці цієї глави, як це робиться.

19.2 Приховування інформації
----------------------------
Реалізація `Queue`, показана в Лістингу 19.1 тепер досить гарна, в відношенні ефективності. Однак ви можете заперечити, що ця ефективність сплачена викриттям непотрібних деталей реалізації. Конструктор, що є глобально доступним, приймає два списки як параметри, один з яких реверсований — навряд чи інтуітивна репрезентація черги. Що потрібно, це шлях приховати цей конструктор від клієнтського коду. В цьому розділі ми покажемо деякі шляхи досягти цього в Scala.

Приватні конструктори та методи фабрик
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
В Java ви можете приховати конструктор, зробивши його приватним. В Scala первинний конструктор не має явного визначення; він визначений явно через параметри та тіло класу. Тим не менше, все ще можливо приховати первинний конструктор, через додавання модифікатора `private` перед списком параметрів класу, як показано в Лістингу 19.2:
[source,scala]
----
class Queue[T] private (
  private val leading: List[T],
  private val trailing: List[T]
)
----
Лістинг 19.2 - Приховування первинного конструктора через створення його приватним.

The private modifier between the class name and its parameters indicates that the constructor of Queue is private: it can be accessed only from within the class itself and its companion object. The class name Queue is still public, so you can use it as a type, but you cannot call its constructor:
[source,scala]
----
scala> new Queue(List(1, 2), List(3))
<console>:9: error: constructor Queue in class Queue cannot
be accessed in object $iw
              new Queue(List(1, 2), List(3))
              ^
----              
Now that the primary constructor of class Queue can no longer be called from client code, there needs to be some other way to create new queues. One possibility is to add an auxiliary constructor, like this:
[source,scala]
----
def this() = this(Nil, Nil)
----
The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the auxiliary constructor could take a list of initial queue elements:
[source,scala]
----
def this(elems: T*) = this(elems.toList, Nil)
----
Recall that T* is the notation for repeated parameters, as described in Section 8.8.

Another possibility is to add a factory method that builds a queue from such a sequence of initial elements. A neat way to do this is to define an object Queue that has the same name as the class being defined and contains an apply method, as shown in Лістинг 19.3:
[source,scala]
----
object Queue {
// constructs a queue with initial elements `xs'
  def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
}
----
Лістинг 19.3 - Метод фабрика `apply` в об'єкті компанйоні.

By placing this object in the same source file as class Queue, you make the object a companion object of the class. You saw in Section 13.5 that a companion object has the same access rights as its class. Because of this, the apply method in object Queue can create a new Queue object, even though the constructor of class Queue is private.

Note that, because the factory method is called apply, clients can create queues with an expression such as Queue(1, 2, 3). This expression expands to Queue.apply(1, 2, 3) since Queue is an object instead of a function. As a result, Queue looks to clients as if it was a globally defined factory method. In reality, Scala has no globally visible methods; every method must be contained in an object or a class. However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods.
[source,scala]
----
trait Queue[T] {
  def head: T
  def tail: Queue[T]
  def enqueue(x: T): Queue[T]
}

object Queue {

  def apply[T](xs: T*): Queue[T] =
    new QueueImpl[T](xs.toList, Nil)

  private class QueueImpl[T](
    private val leading: List[T],
    private val trailing: List[T]
  ) extends Queue[T] {

    def mirror =
      if (leading.isEmpty)
        new QueueImpl(trailing.reverse, Nil)
      else
        this

    def head: T = mirror.leading.head

    def tail: QueueImpl[T] = {
      val q = mirror
      new QueueImpl(q.leading.tail, q.trailing)
    }

    def enqueue(x: T) =
      new QueueImpl(leading, x :: trailing)
  }
}
----
Лістинг 19.4 - Абстракції типів для функціональних черг.

Альтернатива: приватні класи
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Private constructors and private members are one way to hide the initialization and representation of a class. Another more radical way is to hide the class itself and only export a trait that reveals the public interface of the class. The code in Лістинг 19.4 implements this design. There's a trait Queue, whichdeclares the methods head, tail, and enqueue. All three methods are implemented in a subclass QueueImpl, which is itself a private inner class of objectQueue. This exposes to clients the same information as before, but using a different technique. Instead of hiding individual constructors and methods, this version hides the whole implementation class.

19.3 Анотації варіантності
--------------------------
Queue, as defined in Лістинг 19.4, is a trait, but not a type. Queue is not a type because it takes a type parameter.

As a result, you cannot create variables of type Queue:
[source,scala]
----
scala> def doesNotCompile(q: Queue) = {}
<console>:8: error: class Queue takes type parameters
        def doesNotCompile(q: Queue) = {}
        ^
----
Instead, trait Queue enables you to specify parameterized types, such as Queue[String],Queue[Int], or Queue[AnyRef]:
[source,scala]
----
scala> def doesCompile(q: Queue[AnyRef]) = {}
doesCompile: (q: Queue[AnyRef])Unit
----
Thus, Queue is a trait and Queue[String] is a type. Queue is also called a type constructor because you can construct a type with it by specifying a type parameter. (This is analogous to constructing an object instance with a plain-old constructor by specifying a value parameter.) The type constructor Queue "generates" a family of types, which includes Queue[Int],Queue[String], and Queue[AnyRef].

You can also say that Queue is a _generic_ trait. (Classes and traits that take type parameters are "generic," but the types they generate are "parameterized," not generic.) The term "generic" means that you are defining many specific types with one generically written class or trait. For example, trait Queue in Лістинг 19.4 defines a generic queue. Queue[Int] and Queue[String],etc., would be the specific queues.

The combination of type parameters and subtyping poses some interesting questions. For example, are there any special subtyping relationships between members of the family of types generated by Queue[T]? More specifically, should a Queue[String] be considered a subtype of Queue[AnyRef]? Or more generally, if S is a subtype of type T, then should Queue[S] be considered a subtype of Queue[T]? If so, you could say that trait Queue is covariant (or "flexible") in its type parameter T. Or, since it just has one type parameter, you could say simply that Queues are covariant. Covariant Queues would mean, for example, that you could pass a Queue[String] to the doesCompile method shown previously, which takes a value parameter of type Queue[AnyRef]. 

Intuitively, all this seems OK, since a queue of Strings looks like a special case of a queue ofAnyRefs. In Scala, however, generic types have by default nonvariant (or "rigid") subtyping. That is, with Queue defined as in Лістинг 19.4, queues with different element types would never be in a subtyperelationship. A Queue[String] would not be usable as a Queue[AnyRef]. However, you can demand covariant (flexible) subtyping of queues by changing the first line of the definition of class Queue like this:
[source,scala]
----
trait Queue[+T] { ... }
----
Prefixing a formal type parameter with a + indicates that subtyping is covariant (flexible) in that parameter. By adding this single character, you are telling Scala that you wantQueue[String], for example, to be considered a subtype of Queue[AnyRef]. The compiler will check that Queue is defined in a way that this subtyping is sound.

Besides +, there is also a prefix -, which indicates contravariant subtyping. If Queue were defined like this:
[source,scala]
----
trait Queue[-T] { ... }
----
then if T is a subtype of type S, this would imply that Queue[S] is a subtype of Queue[T] (which in the case of queues would be rather surprising!). Whether a type parameter is covariant, contravariant, or nonvariant is called the parameter's variance. The + and - symbols you can place next to type parameters are called variance annotations.

In a purely functional world, many types are naturally covariant (flexible). However, the situation changes once you introduce mutable data. To find out why, consider the simple type of one-element cells that can be read or written, shown in Лістинг 19.5.
[source,scala]
----
class Cell[T](init: T) {
  private[this] var current = init
  def get = current
  def set(x: T) = { current = x }
}
----
Лістинг 19.5 - A nonvariant (rigid) Cell class.

The Cell type of Лістинг 19.5 is declared nonvariant (rigid). For the sake of argument, assume for a moment that Cell was declared covariant instead—i.e., it was declared class Cell[+T]—and that this passed the Scala compiler. (It doesn't, and we'll explain why shortly.) Then you could construct the following problematic statement sequence:
[source,scala]
----
val c1 = new Cell[String]("abc")
val c2: Cell[Any] = c1
c2.set(1)
val s: String = c1.get
----
Seen by itself, each of these four lines looks OK. The first line creates a cell of strings and stores it in a val named c1. The second line defines a new val, c2, of type Cell[Any], which initialized with c1. This is OK since Cells are assumed to be covariant. The third line sets the value of cell c2 to 1. This is also OK because the assigned value 1 is an instance of c2's element type Any. Finally, the last line assigns the element value of c1 into a string. Nothing strange here, as both the sides are of the sametype. But taken together, these four lines end up assigning the integer 1 to the string s. This is clearly a violation of type soundness.

Which operation is to blame for the runtime fault? It must be the second one, which uses covariant subtyping. The other statements are too simple and fundamental. Thus, a Cell ofString is not also a Cell of Any, because there are things you can do with a Cell of Any that you cannot do with a Cell of String. You cannot use set with an Int argument on a Cell of String, for example.

In fact, were you to pass the covariant version of Cell to the Scala compiler, you would get a compile- time error:
[source,scala]
----
Cell.scala:7: error: covariant type T occurs in
contravariant position in type T of value x
    def set(x: T) = current = x
               ^
----               
Варіантність та масиви
~~~~~~~~~~~~~~~~~~~~~~
It's interesting to compare this behavior with arrays in Java. In principle, arrays are just like cells except that they can have more than one element. Nevertheless, arrays are treated as covariant in Java. You can try an example analogous to the cell interaction described here with Java arrays:
[source,java]
----
// ще Java
String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);
String s = a1[0];
----
If you try out this example, you will find that it compiles. But executing the program will cause an ArrayStore exception to be thrown when a2[0] is assigned to an Integer:
[source,scala]
----
Exception in thread "main" java.lang.ArrayStoreException:
java.lang.Integer
        at JavaArrays.main(JavaArrays.java:8)
----
What happens here is that Java stores the element type of the array at runtime. Then, every time an array element is updated, the new element value is checked against the stored type. If it is not an instance of that type, an ArrayStore exception is thrown.

You might ask why Java adopted this design, which seems both unsafe and expensive. When asked this question, James Gosling, the principal inventor of the Java language, answered that they wanted to have a simple means to treat arrays generically. For instance, they wanted to be able to write a method to sort all elements of an array, using a signature like the following that takes an array of Object:
[source,scala]
----
void sort(Object[] a, Comparator cmp) { ... }
----
Covariance of arrays was needed so that arrays of arbitrary reference types could be passed to this sort method. Of course, with the arrival of Java generics, such a sort method can now be writtenwith a type parameter, so the covariance of arrays is no longer necessary. For compatibility reasons, though, it has persisted in Java to this day.

Scala tries to be purer than Java in not treating arrays as covariant. Here's what you get if you translate the first two lines of the array example to Scala:
[source,scala]
----
scala> val a1 = Array("abc")
a1: Array[String] = Array(abc)

scala> val a2: Array[Any] = a1
<console>:8: error: type mismatch;
 found   : Array[String]
 required: Array[Any]
        val a2: Array[Any] = a1
                             ^
----
What happened here is that Scala treats arrays as nonvariant (rigid), so an Array[String] is not considered to conform to an Array[Any]. However, sometimes it is necessary to interact with legacy methods in Java that use an Object array as a means to emulate a generic array. For instance, you might want to call a sort method like the one described previously with an array of Strings as argument. To make this possible, Scala lets you cast an array of Ts to an array of any supertype of T:
[source,scala]
----
scala> val a2: Array[Object] =
          a1.asInstanceOf[Array[Object]]
a2: Array[Object] = Array(abc)
----
The cast is always legal at compile-time, and it will always succeed at run-time because the JVM's underlying run-time model treats arrays as covariant, just as Java the language does. But you might get ArrayStore exceptions afterwards, again just as you would in Java.

19.4 Перевірка анотацій варіантності
------------------------------------
Now that you have seen some examples where variance is unsound, you may be wondering which kind of class definitions need to be rejected and which can be accepted. So far, all violations of type soundness involved some reassignable field or array element. The purely functional implementation of queues, on the other hand, looks like a good candidate for covariance. However, the following example shows that you can "engineer" an unsound situation even if there is no reassignable field.

To set up the example, assume that queues as defined in Лістинг 19.4 are covariant. Then, create a subclass of queues that specializes the element type to Int and overrides the enqueuemethod:
[source,scala]
----
class StrangeIntQueue extends Queue[Int] {
  override def enqueue(x: Int) = {
    println(math.sqrt(x))
    super.enqueue(x)
  }
}
----
The enqueue method in StrangeIntQueue prints out the square root of its (integer) argument before doing the append proper.

Now, you can write a counterexample in two lines:
[source,scala]
----
val x: Queue[Any] = new StrangeIntQueue
x.enqueue("abc")
----
The first of these two lines is valid because StrangeIntQueue is a subclass of Queue[Int] and, assuming covariance of queues, Queue[Int] is a subtype of Queue[Any]. The second line is valid because you can append a String to a Queue[Any]. However, taken together, these two lines have the effect of applying a square root method to a string, which makes no sense.

Clearly it's not just mutable fields that make covariant types unsound. The problem is more general. It turns out that as soon as a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter.

For queues, the enqueue method violates this condition:
[source,scala]
----
class Queue[+T] {
  def enqueue(x: T) =
...
}
----
Running a modified queue class like the one above through a Scala compiler would yield:
[source,scala]
----
Queues.scala:11: error: covariant type T occurs in
contravariant position in type T of value x
  def enqueue(x: T) =
             ^
----
Reassignable fields are a special case of the rule that disallows type parameters annotated with + from being used as method parameter types. As mentioned in Section 18.2, a reassignable field, "var x: T", is treated in Scala as a getter method, "def x: T", and a setter method, "def x_=(y: T)". As you can see, the setter method has a parameter of the field's type T. So that type may not be covariant.

Швидкий шлях
============
In the rest of this section, we'll describe the mechanism by which the Scala compiler checks variance annotations. If you're not interested in such detail right now, you can safely skip toSection 19.5. The most important thing to understand is that the Scala compiler will check any variance annotations you place on type parameters. For example, if you try to declare a type parameter to be covariant (by adding a +), but that could lead to potential runtime errors, your program won't compile.

To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or trait body as positive, negative or neutral. A "position" is any location in the class or trait (but from now on we'll just write "class") body where a type parameter may be used. For example, every method value parameter is a position because a method value parameter has a type. Therefore a type parameter could appear in that position.

The compiler checks each use of each of the class's type parameters. Type parameters annotated with + may only be used in positive positions, while type parameters annotated with - may only be usedin negative positions. A type parameter with no variance annotation may be used in any position, and is, therefore, the only kind of type parameter that can be used in neutral positions of the class body.

To classify the positions, the compiler starts from the declaration of a type parameter and then moves inward through deeper nesting levels. Positions at the top level of the declaring class are classified as positive. By default, positions at deeper nesting levels are classified the same as that at enclosing levels, but there are a handful of exceptions where the classification changes. Method value parameter positions are classified to the flipped classification relative to positions outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and the flip of a neutral classification is still neutral.

Besides method value parameter positions, the current classification is also flipped at the type parameters of methods. A classification is sometimes flipped at the type argument position of a type, such as the Arg in C[Arg], depending on the variance of the corresponding type parameter. If C's type parameter is annotated with a + then the classification stays the same. If C's type parameter is annotated with a -, then the current classification is flipped. IfC's type parameter has no variance annotation then the current classification is changed to neutral.

As a somewhat contrived example, consider the following class definition, where several positions are annotated with their classifications, ^+ (for positive) or ^- (for negative):
[source,scala]
----
abstract class Cat[-T, +U] {
  def meow[W^-](volume: T^-, listener: Cat[U^+, T^-]^-)
    : Cat[Cat[U^+, T^-]^-, U^+]^+
}
----
The positions of the type parameter, W, and the two value parameters, volume and listener, are all negative. Looking at the result type of meow, the position of the first Cat[U, T] argument is negative because Cat's first type parameter, T, is annotated with a -. The type U inside this argument is again in positive position (two flips), whereas the type T inside that argument is still in negative position. You see from this discussion that it's quite hard to keep track of variance positions.

That's why it's a welcome relief that the Scala compiler does this job for you.

Once the classifications are computed, the compiler checks that each type parameter is only used in positions that are classified appropriately. In this case, T is only used in negative positions, and U is only used in positive positions. So class Cat is type correct.

19.5 Нижня межа
===============
Back to the Queue class. You saw that the previous definition of Queue[T] shown in Лістинг 19.4cannot be made covariant in T because T appears as a type of a parameter of the enqueuemethod, and that's a negative position.

Fortunately, there's a way to get unstuck: you can generalize enqueue by making it polymorphic (i.e., giving the enqueue method itself a type parameter) and using a lower bound for its type parameter. Лістинг 19.6 shows a new formulation of Queue that implements this idea.
[source,scala]
----
class Queue[+T] (private val leading: List[T],
    private val trailing: List[T] ) {
  def enqueue[U >: T](x: U) =
    new Queue[U](leading, x :: trailing) // ...
}
----
Лістинг 19.6 - Параметр типу з нижньою межею.

The new definition gives enqueue a type parameter U, and with the syntax, "U >: T", defines T as the lower bound for U. As a result, U is required to be a supertype of T.footnote:[Supertype and subtype relationships are reflexive, which means a type is both a supertype and a subtype of itself. Even though T is a lower bound for U, you could still pass in a T toenqueue.] The parameter toenqueue is now of type U instead of type T, and the return value of the method is now Queue[U]instead of Queue[T].

For example, suppose there is a class Fruit with two subclasses, Apple and Orange. With the new definition of class Queue, it is possible to append an Orange to a Queue[Apple]. The result will be aQueue[Fruit].

This revised definition of enqueue is type correct. Intuitively, if T is a more specific type than expected (for example, Apple instead of Fruit), a call to enqueue will still work because U (Fruit) will still be a supertype of T (Apple).footnote:[Technically, what happens is a flip occurs for lower bounds. The type parameter U is in a negative position (1 flip), while the lower bound (>: T) is in a positive position (2 flips).]

The new definition of enqueue is arguably better than the old, because it is more general. Unlike the old version, the new definition allows you to append an arbitrary supertype U of the queue element type T. The result is then a Queue[U]. Together with queue covariance, this gives the right kind of flexibility for modeling queues of different element types in a natural way.

This shows that variance annotations and lower bounds play well together. They are a good example of type-driven design, where the types of an interface guide its detailed design and implementation. In the case of queues, it's likely you would not have thought of the refined implementation of enqueue with a lower bound. But you might have decided to make queues covariant, in which case, the compiler would have pointed out the variance error for enqueue. Correcting the variance error by adding a lower bound makes enqueue more general and queues as a whole more usable.

This observation is also the main reason that Scala prefers declaration-site variance over use-site variance as it is found in Java's wildcards. With use-site variance, you are on your own designing a class. It will be the clients of the class that need to put in the wildcards, and if they get it wrong, some important instance methods will no longer be applicable. Variance being a tricky business, users usually get it wrong, and they come away thinking that wildcards and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available.

19.6 Контрваріантність
----------------------
So far in this chapter, all examples you've seen were either covariant or nonvariant. But there are also cases where contravariance is natural. For instance, consider the trait of output channels shown in Лістинг 19.7:
[source,scala]
----
trait OutputChannel[-T] {
  def write(x: T)
}
----
Лістинг 19.7 - Контрваріантний вихідний канал.

Here, OutputChannel is defined to be contravariant in T. So an output channel of AnyRefs, say, is a subtype of an output channel of Strings. Although it may seem non-intuitive, it actually makes sense. To see why, consider what you can do with an OutputChannel[String]. The only supported operation is writing a String to it. The same operation can also be done on anOutputChannel[AnyRef]. So it is safe to substitute an OutputChannel[AnyRef] for anOutputChannel[String]. By contrast, it would not be safe to substitute an OutputChannel[String]where an OutputChannel[AnyRef] is required. After all, you can send any object to anOutputChannel[AnyRef], whereas an OutputChannel[String] requires that the written values are all strings.

This reasoning points to a general principle in type system design: It is safe to assume that a type T is a subtype of a type U if you can substitute a value of type T wherever a value of type Uis required. This is called the Liskov Substitution Principle. The principle holds if T supports the same operations as U, and all of T's operations require less and provide more than the corresponding operations in U. In the case of output channels, an OutputChannel[AnyRef] can be a subtype of an OutputChannel[String] because the two support the same write operation, and this operation requires less in OutputChannel[AnyRef] than in OutputChannel[String]. "Less" means the argument is only required to be an AnyRef in the first case, whereas it is required to be a Stringin the second case.

Sometimes covariance and contravariance are mixed in the same type. A prominent example is Scala's function traits. For instance, whenever you write the function type A => B, Scala expands this to Function1[A, B]. The definition of Function1 in the standard library uses both covariance and contravariance: the Function1 trait is contravariant in the function argument type S and covariant in the result type T, as shown in Лістинг 19.8. This satisfies the Liskov Substitution Principle because arguments are something that's required, whereas results are something that's provided.
[source,scala]
----
trait Function1[-S, +T] {
  def apply(x: S): T
}
----
Лістинг 19.8 - Коваріантність та контрваріантність `Function1s`.

As an example, consider the application shown in Лістинг 19.9. Here, class Publicationcontains one parametric field, title, of type String. Class Book extends Publication and forwards its string title parameter to the constructor of its superclass. The Library singleton object defines a set of books and a method printBookList, which takes a function, named info, of typeBook => AnyRef. In other words, the type of the lone parameter to printBookList is a function that takes one Book argument and returns an AnyRef. The Customer application defines a method,getTitle, which takes a Publication as its lone parameter and returns a String, the title of the passed Publication.
[source,scala]
----
class Publication(val title: String)
class Book(title: String) extends Publication(title)

object Library {
  val books: Set[Book] =
    Set(
      new Book("Programming in Scala"),
      new Book("Walden")
    )

  def printBookList(info: Book => AnyRef) = {
    for (book <- books) println(info(book))
  }
}

object Customer extends App {
  def getTitle(p: Publication): String = p.title
  Library.printBookList(getTitle)
}
----
Лістинг 19.9 - Демонстрація варіантності параметру типу функції.

Now take a look at the last line in Customer. This line invokes Library's printBookList method and passes getTitle, wrapped in a function value:
[source,scala]
----
Library.printBookList(getTitle)
----
This line of code type checks even though String, the function's result type, is a subtype ofAnyRef, the result type of printBookList's info parameter. This code passes the compiler because function result types are declared to be covariant (the +T in Лістинг 19.8). If you look inside the body of printBookList, you can get a glimpse of why this makes sense.

The printBookList method iterates through its book list and invokes the passed function on each book. It passes the AnyRef result returned by info to println, which invokes toString on it and prints the result. This activity will work with String as well as any other subclass of AnyRef, which is what covariance of function result types means.

Now consider the parameter type of the function being passed to the printBookList method. Although printBookList's parameter type is declared as Book, the getTitle we're passing in takes a Publication, a supertype of Book. The reason this works is that since printBookList's parameter type is Book, the body of the printBookList method will only be allowed to pass a Book into the function. And because getTitle's parameter type is Publication, the body of that function will only be able to access on its parameter, p, members that are declared in class Publication. Because any method declared in Publication is also available on its subclass Book, everything should work, which is what contravariance of function parameter types means. You can see all this graphically in Figure 19.1.

The code in Лістинг 19.9 compiles because Publication => String is a subtype of Book => AnyRef, as shown in the center of the Figure 19.1. Because the result type of a Function1 is defined as covariant, the inheritance relationship of the two result types, shown at the right of the diagram, is in the same direction as that of the two functions shown in the center. By contrast, because the parameter type of a Function1 is defined as contravariant, the inheritance relationship of the two parameter types, shown at the left of the diagram, is in the opposite direction as that of the two functions.

Figure 19.1 - Covariance and contravariance in function type parameters.
[source,scala]
----
class Queue[+T] private (
  private[this] var leading: List[T],
  private[this] var trailing: List[T]
) {

  private def mirror() =
    if (leading.isEmpty) {
      while (!trailing.isEmpty) {
        leading = trailing.head :: leading
        trailing = trailing.tail
      }
    }

  def head: T = {
    mirror()
    leading.head
  }

  def tail: Queue[T] = {
    mirror()
    new Queue(leading.tail, trailing)
  }
  
  def enqueue[U >: T](x: U) =
    new Queue[U](leading, x :: trailing)
}
----
Лістинг 19.10 - Оптимізована An optimized functional queue.

19.7 Приватні дані об'єкта
--------------------------
The Queue class seen so far has a problem in that the mirror operation will repeatedly copy thetrailing into the leading list if head is called several times in a row on a list where leading is empty. The wasteful copying could be avoided by adding some judicious side effects. Лістинг 19.10 presents a new implementation of Queue, which performs at most one trailing to leadingadjustment for any sequence of head operations.

What's different with respect to the previous version is that now leading and trailing are reassignable variables, and mirror performs the reverse copy from trailing to leading as a side effect on the current queue instead of returning a new queue. This side effect is purely internal to the implementation of the Queue operation; since leading and trailing are private variables, the effect is not visible to clients of Queue. So by the terminology established inChapter 18, the new version of Queue still defines purely functional objects, in spite of the fact that they now contain reassignable fields.

You might wonder whether this code passes the Scala type checker. After all, queues now contain two reassignable fields of the covariant parameter type T. Is this not a violation of the variance rules? It would be indeed, except for the detail that leading and trailing have aprivate[this] modifier, and are thus declared to be object private.

As mentioned in Section 13.5, object private members can be accessed only from within the object in which they are defined. It turns out that accesses to variables from the same object in which they are defined do not cause problems with variance. The intuitive explanation is that, in order to construct a case where variance would lead to type errors, you need to have a reference to a containing object that has a statically weaker type than the type the object was defined with. For accesses to object private values, however, this is impossible.

Scala's variance checking rules contain a special case for object private definitions. Such definitions are omitted when it is checked that a type parameter with either a + or -annotation occurs only in positions that have the same variance classification. Therefore, the code in Лістинг 19.10 compiles without error. On the other hand, if you had left out the [this]qualifiers from the two private modifiers, you would see two type errors:
[source,scala]
----
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter leading_=
class Queue[+T] private (private var leading: List[T],
                                     ^
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter trailing_=
                        private var trailing: List[T]) {
                                    ^
----                                    
19.8 Верхня межа
----------------
In Listing 16.1 here, we showed a merge sort function for lists that took a comparison function as a first argument and a list to sort as a second, curried argument. Another way you might want to organize such a sort function is by requiring the type of the list to mix in theOrdered trait. As mentioned in Section 12.4, by mixing Ordered into a class and implementingOrdered's one abstract method, compare, you enable clients to compare instances of that class with <, >, <=, and >=. For example, Listing 19.11 shows Ordered being mixed into a Person class.

As a result, you can compare two people like this:
[source,scala]
----
scala> val robert = new Person("Robert", "Jones")
robert: Person = Robert Jones

scala> val sally = new Person("Sally", "Smith")
sally: Person = Sally Smith

scala> robert < sally
res0: Boolean = true

class Person(val firstName: String, val lastName: String)
    extends Ordered[Person] {

  def compare(that: Person) = {
    val lastNameComparison =
      lastName.compareToIgnoreCase(that.lastName)
    if (lastNameComparison != 0)
      lastNameComparison
    else
      firstName.compareToIgnoreCase(that.firstName)
  }

  override def toString = firstName + " " + lastName
}
----
Лістинг 19.11 - Клас `Person`, міксує трейт `Ordered`.
[source,scala]
----
def orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {
  def merge(xs: List[T], ys: List[T]): List[T] =
    (xs, ys) match {
      case (Nil, _) => ys
      case (_, Nil) => xs
      case (x :: xs1, y :: ys1) =>
        if (x < y) x :: merge(xs1, ys)
        else y :: merge(xs, ys1)
    }
  val n = xs.length / 2
  if (n == 0) xs
  else {
    val (ys, zs) = xs splitAt n
    merge(orderedMergeSort(ys), orderedMergeSort(zs))
  }
}
----
Лістинг 19.12 - Функція сортування злиттям з верхньою межею.

To require that the type of the list passed to your new sort function mixes in Ordered, you need to use an upper bound. An upper bound is specified similar to a lower bound, except instead of the >: symbol used for lower bounds, you use a <: symbol, as shown in Лістинг 19.12.

With the "T <: Ordered[T]" syntax, you indicate that the type parameter, T, has an upper bound,Ordered[T]. This means that the element type of the list passed to orderedMergeSort must be a subtype of Ordered. Thus, you could pass a List[Person] to orderedMergeSort because Person mixes in Ordered.

For example, consider this list:
[source,scala]
----
scala> val people = List(
          new Person("Larry", "Wall"),
          new Person("Anders", "Hejlsberg"),
          new Person("Guido", "van Rossum"),
          new Person("Alan", "Kay"),
          new Person("Yukihiro", "Matsumoto")
       )
people: List[Person] = List(Larry Wall, Anders Hejlsberg,
  Guido van Rossum, Alan Kay, Yukihiro Matsumoto)
----  
Because the element type of this list, Person, mixes in (and is therefore a subtype of)Ordered[People], you can pass the list to orderedMergeSort:
[source,scala]
----
scala> val sortedPeople = orderedMergeSort(people)
sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
  Yukihiro Matsumoto, Guido van Rossum, Larry Wall)
----
Now, although the sort function shown in Лістинг 19.12 serves as a useful illustration of upper bounds, it isn't actually the most general way in Scala to design a sort function that takes advantage of the Ordered trait.

For example, you couldn't use the orderedMergeSort function to sort a list of integers, because class Int is not a subtype of Ordered[Int]:
[source,scala]
----
scala> val wontCompile = orderedMergeSort(List(3, 2, 1))
<console>:5: error: inferred type arguments [Int] do
   not conform to method orderedMergeSort's type
      parameter bounds [T <: Ordered[T]]
        val wontCompile = orderedMergeSort(List(3, 2, 1))
                          ^
----  
In Section 21.6, we'll show you how to use implicit parameters and context bounds to achieve a more general solution.

19.9 Висновок
-------------
In this chapter you saw several techniques for information hiding: private constructors, factory methods, type abstraction, and object private members. You also learned how to specify data type variance and what it implies for class implementation. Finally, you saw two techniques which help in obtaining flexible variance annotations: lower bounds for method type parameters and private[this] annotations for local fields and methods.
