<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__3">Глава 3</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____scala">Наступні кроки в Scala</h1>
<div class="paragraph"><p>Ця глава продовжує вступ до Scala з попередньої глави. В цій главі ми введемо декілька більш складних можливостей. Коли ви скінчите цю главу, ви будете мати досить знань, щоб почати писати корисні скрипти на Scala. Як і з попередньою главою, ми рекомендуємо вам спробувати ці приклади, по мірі проходження. Кращий спосіб отримати відчуття Scala є почати писати Scala код.</p></div>
<div class="sect1">
<h2 id="__7_____">Крок 7. Параметризація масивів за допомогою типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala ви можете створити примірники об'єктів або примірники класів, використовуючи <code>new</code>. Коли ви створюєте примірник об'єкту в Scala, ви можете параметризувати його за допомогою значень або типів. Параметризація означає "конфігурація" примірника, коли ви створюєте його. Ви параметризуєте примірник значеннями, через передачу об'єктів до конструктора в дужках. Наприклад, наступний код Scala створює нового <code>java.math.BigInteger</code>, та параметризує його значенням "12345":</p></div>
<div class="listingblock">
<div class="content">
<pre><code>val big = new java.math.BigInteger("12345")</code></pre>
</div></div>
<div class="paragraph"><p>Ви параметризуєте примірник типами, коли вказуєте один або більше типів в прямокутних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі <code>greetStrings</code> є значенням типу <code>Array[String]</code>("масив рядків"), що ініціалізований довжиною 3 через його параметризацію значенням 3 в першому рядку кода. Якщо ви запустите код з Лістинга 3.1 як скрипт, ви побачите ще одне привітання <code>Hello, world!</code>. Зауважте, що коли ви параметризуєте примірник обома, типом та значенням, тип іде першим в своїх прямокутних дужках, за якими іде значення в дужках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.1 - Параметризація масива за допомогою типа.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Хоча код в Лістингу 3.1 демонструє важливі концепції, він не показує рекомендований спосіб створювання та ініціалізації масивів в Scala. Ви побачите кращий спосіб в Лістингу 3.2 далі.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо ви знаходитесь в більш явному настрої, ви можете вказати тип <code>greetStrings</code> явно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи до уваги вивід типів Scala, цей рядок кода семантично еквівалнтний до першого дійсного рядка Лістинга 3.1. Але ця форма демонструє, що хоча частина параметризації типа (імена типів в прямокутних дужках) формує частину типу примірника, частина параметризації значенням (значення в дужках) - ні. Тип <code>greetStrings</code> є <code>Array[String]</code>, не Array[String](3).</p></div>
<div class="paragraph"><p>Наступні три рядка кода з Лістинга 3.1 ініціалізують кожний елемент масиву <code>greetStrings</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">greetStrings</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;Hello&quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;, &quot;</span>
<span class="n">greetStrings</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;world!\n&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як зазначалось раніше, масиви в Scala отримують доступ покладанням індексу в дужках, не прямокутних дужках, як в Java. Таким чином нульовий елемент масива є <code>isgreetStrings(0)</code>, та не <code>greetStrings[0]</code>.</p></div>
<div class="paragraph"><p>Ці три рядка кода ілюструють важливу концепцію для розуміння того, як Scala розглядає визначення <code>val</code>. Коли ви визначаєте змінну за допомогою <code>val</code>, змінна не може бути переприсвоєна, але об'єкт, на який вона посилається, потенційно все ще може бути змінений. Як в цьому випадку, ви не можете переприсвоїти <code>greetStrings</code> на інший масив; <code>greetStrings</code> буде завжди вказувати на той самий примірник <code>Array[String]</code>, яким він був ініціалізований. Але ви можете змінити елементи цього <code>Array[String]</code> з часом, так що сам масив є змінним.</p></div>
<div class="paragraph"><p>Два заключні рядка в Лістингу 3.1 містять вираз <code>for</code>, що друкує кожний елемент <code>greetStringsarray</code> по черзі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший рядок коду в цьому виразі <code>for</code> ілюструє інше загальне правило Scala: якщо метод приймає тільки один параметр, ви можете викликати його без крапки або дужок. В цбому прикладі <code>to</code> насправді є методом, що приймає один аргумент Int. Код <code>0 to 2</code> трансформується в виклик метода <code>(0).to(2)</code>. <span class="footnote"><br />[Цей метод to насправді повертає не масив, але інший різновид послідовності, що містить значення 0, 1 та 2, по якому ітерує for. Послідовності та інші колекції будуть описані в Главі 17.]<br /></span> Зауважте, що цей синтаксис робить, тільки якщо ви явно вказуєте отримувача виклику метода. Ви не можете написати <code>println 10</code>, але ви можете написати <code>Console println 10</code>.</p></div>
<div class="paragraph"><p>Scala технічно не має перевантаження операторів, оскільки вона насправді не має операторів в традиційному сенсі. Замість цього, такі символи, як +, -, * та / можуть бути використані в іменах методів. Таким чином, коли ви друкуєте <code>1 + 2</code> в Scala інтерпретаторі на Кроці 1, ви насправді викликаєте метод з назвою <code>+</code> на <code>Int</code> об'єкті <code>1</code>, передаючи <code>2</code> як параметр. Як ілюстровано на Малюнку 3.1, ви можете альтернативно записати <code>1 + 2</code>, використовуючи традиційний синтаксис виклику метода, <code>(1).+(2)</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.1 - В Scala всі операції є викликами методів.</p></div>
<div class="paragraph"><p>Інша важлива ідея, ілюстрована цім прикладом, це надати вам розуміння того, чому масиви надають доступ через дужки в Scala. Scala має меньше особливих випадків, ніж Java. Масиви є простими примірниками класів, як любі інші класи в Scala. Коли ви застосовуєте дужки, що оточують одне або більше значень до змінної, Scala буде трансформувати код в виклик методу з назвою <code>apply</code> на цій змінній. Так що <code>greetStrings(i)</code> перетвориться на <code>greetStrings.apply(i)</code>. Таким чином, доступ до елемент масива в Scala є простим викликом метода, як любий інший. Цей принцип не ообмежуєть до масивів: любе застосування об'єктів до деяких аргументів в дужках буде трпнсформоване в виклик метода <code>apply</code>. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкта дійсно визначає метод <code>apply</code>. Так що це не особливий випадок; це загальне правило.</p></div>
<div class="paragraph"><p>Подібним чином, коли робиться просвоєння до змінної, до якої застовані дужки з одним або більше аргументом, компілятор буде трансформувати це в виклик метода <code>update</code>, що приймає аргументи в дужках, а такж об'єкт з правого боку від знака рівності. Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings(0) = "Hello"</code></pre>
</div></div>
<div class="paragraph"><p>буде трансформовано на:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>greetStrings.update(0, "Hello")</code></pre>
</div></div>
<div class="paragraph"><p>Таким чином, наступне симантично еквівалентне до коду з лістинга 3.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">greetStrings</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">3</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="s">&quot;Hello&quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">&quot;, &quot;</span><span class="o">)</span>
<span class="n">greetStrings</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">&quot;world!\n&quot;</span><span class="o">)</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mf">0.</span><span class="n">to</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">print</span><span class="o">(</span><span class="n">greetStrings</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala досягає концептуальної простоти, трактуючи все, від масивів та виразів, як об'єкти з методами. Ви не маєте пам'ятати особливі випадки, такі, як розбіжності в Java між примітивами та їх відповідними огортаючими типами, або між масивами та звичайними об'єктаи. Більше того, ця одноманітність не накладає значних витрат продуктивності. Компілятор Scala використовує в скомпільованому коді масиви Java, примітивні типи, та природну арифметику, де це можливо.</p></div>
<div class="paragraph"><p>Хоча приклади, що ви бачили на цей момент в цьому кроці, компілюються та виконуються досить гано, Scala провадить більш стислий спосіб для створення та ініціалізації масивів, який в будете звичайно використовувати (Лістинг 3.2). Цей код створює новий масив довжиною три, ініціалізований переданими рядками, <code>"zero"</code>, <code>"one"</code>, <code>"two"</code>. Компілятор виводить тип масива, як <code>Array[String]</code>, оскільки ви передали йому рядки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.2 - Створення та ініціалізація масиву.</p></div>
<div class="paragraph"><p>Що ви насправді робите в Лістингу 3.2, це виклик методу фабрики, під назвою <code>apply</code>, що створює та повертає новий масив. Цей метод <code>apply</code> приймає змінне число аргументів,<span class="footnote"><br />[Список аргументів змінної довжини, або повторювані параметри, описані в Розділі 8.8.]<br /></span> та визначений на об'єкті компанйоні Array. Ви навчитесь більше щодо об'єктов компанйонів в Розділі 4.3. Якщо ви Java програміт, ви можете думати про це, як про виклик статичного методу на ім'я <code>apply</code> на класі <code>Array</code>. Більш балакучий шлях викликати той самий метод <code>apply</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">numNames2</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="__8__">Крок 8. Використання списків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна з виликих ідей функціонального стилю програмування є методи, що не мають побічних ефектів. Єдиною дією метода повинне бути обчислення та повернення значення. Деякі переваги, що будуть отримані коли ви приймете цей підхід, в тому, що методи стають менш  заплутаними, і таким чином, більш надійні та використовувані. Інша перевага (в статично типізованій мові) в тому, що все, що входить і виходить з метода перевіряється контролем типів, так що логічні помилки більш вірогідно проявлять себе як помилки типів. Застосування цієї функціональної філософії до світу об'єктів означає зробити об'єкти незмінними.</p></div>
<div class="paragraph"><p>Як ви бачили, масиви Scala є змінними послідовностями об'єктів, що всі поділяють той самий тип. Наприклад, <code>Array[String]</code> містить тільки рядки. Хоча ви не можете змінити довжину масива, після того, як був створений екземпляр, ви можете змінити значення його елементів. Таким чином, масиви є змінні об'єкти.</p></div>
<div class="paragraph"><p>Для незмінних послідовностей об'єктів, що поділяють той самий тип, ви можете використати клас Scala <code>List</code>. Так само, як і з масивами, <code>List[String]</code> містить тільки рядки. Список Scala <code>List</code>, <code>scala.List</code>, відрізняється від типу Java <code>java.util.List</code> в тому, що списки Scala <code>List</code> завжди незмінні (тоді як списки Java <code>List</code> можуть бути змінні). Більш загально, Scala <code>List</code> розроблений дозволити функціональний стиль програмування. Створити список просто, та Лістинг 3.3 показує як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.3 - Створення та ініціалізація списку.</p></div>
<div class="paragraph"><p>Код в Лістингу 3.3 встановлює нову <code>val</code> на ім'я <code>oneTwoThree</code>, ініціалізовану як <code>new List[Int]</code> з цілими елементами 1, 2 та 3.<span class="footnote"><br />[Вам не треба казати new List, оскільки "List.apply()" визначений як метод фабрика на об'єкті компанйоні scala.List. Ви будете читати більше про об'єкти компанйони в Розділі 4.3.]<br /></span> Оскільки <code>List</code> незмінні, вони поводяться трохи подібно до рядків в Java: коли ви викликаєте метод на списку, з імені якого випливає, що список буде змінений, він замість цього створює та повертає нове значення. Наприклад, <code>List</code> має метод на ім'я <code>:::</code> для конкатенації списків. Ось як ви використовуєте його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwo</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">threeFour</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThreeFour</span> <span class="k">=</span> <span class="n">oneTwo</span> <span class="o">:::</span> <span class="n">threeFour</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwo</span> <span class="o">+</span> <span class="s">&quot; and &quot;</span> <span class="o">+</span> <span class="n">threeFour</span> <span class="o">+</span> <span class="s">&quot; were not mutated.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;Thus, &quot;</span> <span class="o">+</span> <span class="n">oneTwoThreeFour</span> <span class="o">+</span> <span class="s">&quot; is a new list.&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви виконаєте цей скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</code></pre>
</div></div>
<div class="paragraph"><p>Можливо найбільш загальний оператор, якім ви будете користатись зі списками, є <code>::</code>, що вимовляється як "cons". Cons ставить новий елемент до початку існуючого списку, та повертає отриманий список. Наприклад, якщо ви викличете цей скрипт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">twoThree</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">twoThree</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>List(1, 2, 3)</code></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">В виразі 1 <code>::</code> twoThree, <code>::</code> є методом свого правого операну, списку <code>twoThree</code>. Ви можете запідозрити, що щось не так з асоціативністю метода <code>::</code>, але насправді є просте правило, що треба пам'ятати: якщо метод використовується в операторній нотації, такі, як <code>a * b</code>, метод викликається на лівому операнді, як <code>a.*(b)</code> — за винятком, коли метод закінчується на двокрапку. Якщо ім'я метода закінчується на двокрапку, метод викликається на правому операнді. Таким чином, в 1 <code>::</code> twoThree, метод <code>::</code> викликається на <code>twoThree</code>, передаючи 1: <code>twoThree.::(1)</code>. Асоціативність операторів буде детально дискутована в Розділі 5.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Приймаючи, що скороченим шляхом вказати порожній список є <code>Nil</code>, одним з методів ініціалізувати нові списки є поєднання разом елементів за допомогою оператора <code>cons</code>, з Nil в якості останнього елемента. Причина, з якої вам треба Nil в кінці полягає в тому, що <code>::</code> визначене для класа List. Якщо ви намагатиметесь просто сказати 1 <code>::</code> 2 <code>::</code> 3, це не буде компілюватись, оскільки 3 є Int, що не має метода <code>::</code>. Наприклад, наступний скрипт буде продукувати той самий вихід, що і попередній, <code>List(1, 2, 3)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">oneTwoThree</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">println</span><span class="o">(</span><span class="n">oneTwoThree</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala List напакований корисними методами, багато з яких показані в Таблиці 3.1. Повна потужність списків буде розкрита в Главі 16.</p></div>
<div class="sect2">
<h3 id="_____">Чому не додавати до списків?</h3>
<div class="paragraph"><p>Клас List пропонує операцію <code>append</code> — вона записується як <code>:+</code> та пояснена в Главі  24 — але ця операція рідко використовується, оскільки час, що займає додати до списку зростає лінійно з розміром списку, тоді як постановка в початок за допомогою <code>::</code> займає сталий час. Якщо ви бажаєте побудувати список ефективно через додавання елементів, ви можете додавати їх в початок, то коли все буде зроблене зробити реверс (обертання) списку. Або ви можете використовувати <code>ListBuffer</code>, змінний список, що пропонує операцію <code>append</code>, та потім, коли все зроблено, викликати <code>toList</code>. <code>ListBuffer</code> буде описаний в Розділі  22.2.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця: Деякі методи та використання List</caption>
<col width="33%" />
<col width="66%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке        </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span> <span class="n">або</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Порожній List</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;Cool&quot;</span><span class="o">,</span> <span class="s">&quot;tools&quot;</span><span class="o">,</span> <span class="s">&quot;rule&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Cool", "tools", "rule"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">thrill</span> <span class="k">=</span> <span class="s">&quot;Will&quot;</span> <span class="o">::</span> <span class="s">&quot;fill&quot;</span> <span class="o">::</span> <span class="s">&quot;until&quot;</span> <span class="o">::</span> <span class="nc">Nil</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Створює новий List[String] з трьома значеннями, "Will", "fill", "until"</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;d&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Конкатенує два списки (повертає новий List[String] зі значеннями "a", "b", "c", "d")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає елемент з індексом 2 (від нуля) списку thethrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">count</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Рахує число число рядків-елементів в thrill, чия довжина 4 (повертає 2)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без перших двох елементів (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">dropRight</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill без двох правих елементів (повертає List("Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">==</span> <span class="s">&quot;until&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Визначає, чи існує елемент-рядок в thrill, що має значення "until" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів thrill, по порядку, що мають довжину 4 (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">forall</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;l&quot;</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи всі елементи в списку thrill закінчуються на літеру "l" (повертає true)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">print</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Виконує твердження print на кожному рядку в списку thrill (друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">print</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Те саме що і попередньє, але стисліше (також друкує "Willfilluntil")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">head</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає перший елемент в списку thrill (повертає "Will")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">init</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає з усіх, крім останнього, елементів в списку thrill (повертає List("Will", "fill"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">isEmpty</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Вказує, чи є список thrill (повертає false)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">last</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає останній елемент в списку thrill (повертає "until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає число елементів в списку thrill (повертає 3)</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;y&quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, отриманий від додавання "y" до кожного елемента-рядка в списку thrill (повертаєList ("Willy", "filly", "untily"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;, &quot;</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Робить рядок з усіх елементів списку (повертає "Will, fill, until")</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">filterNot</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список з усіх елементів списку thrill, по порядку, крім тих, що мають довжину 4 (повертає List("until"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">reverse</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що складається з усіх елеменітв списку thrill в зворотньому порядку (повертає List("until", "fill", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">sort</span><span class="o">((</span><span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">toLower</span><span class="o">)</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список, що містить всі елементи thrill в алфавітному порядку по першій літері, переведеній в нижній реєстр (повертає List("fill", "until", "Will"))</p></td>
</tr>
<tr>
<td align="left" valign="top"><div><div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">thrill</span><span class="o">.</span><span class="n">tail</span>
</pre></div></div></div></div></td>
<td align="left" valign="top"><p class="table">Повертає список thrill мінус перший елемент (повертає List("fill", "until"))</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__9__">Крок 9. Використання таплів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Інший корисний контейнерний об'єкт є тапл. Як списки, тапли є нехмінними, але на відміну від списків, тапли можуть містити різні типи елементів. Коли список може бути List[Int] або aList[String], тапл може містити обоє, ціле та рядок, одночасно. Тапли дуже корисні, наприклад, коли ви повертаєте декілька об'єктів з метода. В той час, коли в Java ви будете часто створювати JavaBean-подібний клас, що міститиме декілька повертаємих значень, в Scala ви можете просто повернути тапл. Та це просто: щоб ініціалізувати тапл, що містить деякий об'єкти, просто покладіть об'єкти в дужки, розділені комами. Як тільки ви маєте примірник таплу, ви можете отримати доступ до його індивідуальних об'єктів через крапку, підкреслення, та 1-базований індекс елементів. Приклад показаний на Лістингу 3.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">pair</span> <span class="k">=</span> <span class="o">(</span><span class="mi">99</span><span class="o">,</span> <span class="s">&quot;Luftballons&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">pair</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.4 - Creating and using a tuple.</p></div>
<div class="paragraph"><p>В першому рядку Лістинга 3.4 ви створюєте новий тапл, що містить ціле 99 як перший елемент, та рядок "Luftballons" як другий елемент. Scala виводить тип тапла як <code>Tuple2[Int, String]</code>, та надає цей тип до змінної <code>pair</code>, також. В другому рядку ви отримуєте доступ до поля _1, що буде продукувати перший елемент, <code>99</code>. "." в другому рядку є та сама крапка, яку ви використовуєте для доступу до поля або для виклику метода. В цьому випадку ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте скрипт, ви побачите:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>99
Luftballons</code></pre>
</div></div>
<div class="paragraph"><p>Справжній тип тапла залежить від числа елементів, яке він містить, та від типів ціх елементів. Таким чином, тип <code>(99, "Luftballons")</code> є <code>Tuple2[Int, String]</code>. Тип <code>('u', 'r', "the", 1, 4, "me")</code> є <code>Tuple6[Char, Char, String, Int, Int, String]</code>.<span class="footnote"><br />[Хоча концептуально ви можете створити тапли любої довжини, наразі бібліотека Scala визначає їх до Tuple22.]<br /></span></p></div>
<div class="sect2">
<h3 id="____">Доступ до елементів тапла</h3>
<div class="paragraph"><p>Ви можете здивуватись, чому ви не можете отримати доступ до елементів тапла як до елементів списку, наприклад, як <code>pair(0)</code>. Причина є в тому, що для списка метод <code>apply</code> завжди повертає той самий тип, але кожний елемент тапла може бути різного типу: _1 може мати одит тип результату, _2 інший, і так далі. Ці числа _N базуються не одиниці, замість нуля, оскільки починати з 1 є традицією, встановленою іншими мовами зі статичними типизованими таплами, як Haskell та ML.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__10____">Крок 10. Використання множин та мап</h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки Scala націлена допомогти вам отриати переваги від обох, функціонального та імперативного стилів, її бібліотеки колекцій наголошують на різниці між змінними та незмінними колекціями. Наприклад, масиви завжди змінні; списки завжди незмінні. Scala також провадить змінні та незмінні альтернативи для множин та мап, але використовує ті ж самі прості імена для обої версій. Для множин та мап Scala моделює змінність в ієрархії класів.</p></div>
<div class="paragraph"><p>Наприклад, Scala API містить базовий трейт для множин, де трейт схожий на Java інтерфейс. (Ви знайдете більше щодо трейтів в Главі 12). Потім Scala провадить два субтрейти, один для змінних множин, та інший для незмінних множин.</p></div>
<div class="paragraph"><p>Як ви можете бачити на Малюнку 3.2, ці три трейти всі поділяють те саме просте ім'я, <code>Set</code>. Однак їх повністю кваліфіковані імена відрізняються, оскільки кожний знаходиться в окремому пакунку. Конкретні класи множин в Scala API, такі як класи <code>HashSet</code>, показані на Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java ви "реалізуєте" інтерфейси, в Scala ви "розширюєте" або "міксуєте" трейти). Таким чином, якщо ви бажаєте використати HashSet, ви маєте обрати між змінним та незмінним варіаціями, в залежності від ваших потреб. Спосіб по замовчанню створити множину показаний на Лістингу 3.5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">jetSet</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Boeing&quot;</span><span class="o">,</span> <span class="s">&quot;Airbus&quot;</span><span class="o">)</span>
<span class="n">jetSet</span> <span class="o">+=</span> <span class="s">&quot;Lear&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">jetSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;Cessna&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.5 - Створення, ініціалізація та використання незмінної множини.</p></div>
<div class="paragraph"><p>Малюнок 3.2 - Ієрархія класів для множин Scala.</p></div>
<div class="paragraph"><p>В першому рядук кода в Лістингу 3.5 ви визначаєте нову <code>var</code> на ім'я <code>jetSet</code>, та ініціалізуєте її незмінною множиною, що має два рядка, "Boeing" та "Airbus". Як показує приклад, ви можете створити множини в Scala подібно до того, як ви створюєте списки та масиви: через виклик метода фабрики з назвою <code>apply</code> на об'єкті компанйоні Set. В Лістингу 3.5 ви визиваєте <code>apply</code> на об'єкті компанйоні для  <code>scala.collection.immutable.Set</code>, що повертає примірник по замовчанню, незмінний <code>Set</code>. Компілятор Scala виводить тип <code>jetSet</code> як незмінний <code>Set[String]</code>.</p></div>
<div class="paragraph"><p>Щоб додати новий елемент до множини ви застосовуєте виклик + на множині, передаючи новий елемент. На обох, змінній та незмінній множині метод + буде створювати та поверне нову множину з доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною. Хоча змінні множини пропонують справжній метод <code>+=</code>, незмінні множини ні.</p></div>
<div class="paragraph"><p>В цьому випадку другий рядок коду, <code>jetSet += "Lear</code>, в основному є скороченням для:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">jetSet</span> <span class="k">=</span> <span class="n">jetSet</span> <span class="o">+</span> <span class="s">&quot;Lear&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, в другому рядку Лістингу 3.5 ви переприсвоююте <code>jetSet var</code> новою множиною, що містить "Boeing", "Airbus", та "Lear". Нарешіт, в останньому рядку Лістингу 3.5 іде друк того, чи містить або ні множина рядок "Cessna". (Як ви і очікували, друкується false).</p></div>
<div class="paragraph"><p>Якщо ви бажаєте змінну множину, вам треба використовувати імпорт, як показано в Лістингу 3.6:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">movieSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="s">&quot;Hitch&quot;</span><span class="o">,</span> <span class="s">&quot;Poltergeist&quot;</span><span class="o">)</span>
<span class="n">movieSet</span> <span class="o">+=</span> <span class="s">&quot;Shrek&quot;</span>
<span class="n">println</span><span class="o">(</span><span class="n">movieSet</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.6 - Створення, ініціалізація та використання змінної множини.</p></div>
<div class="paragraph"><p>В першому рядку Лістингу 3.6 ви імпортуєте <code>Set</code>. Як і з Java, твердження <code>import</code> дозволяє вам використовувати просте ім'я, таке як  <code>Set</code>, замість довшого, повністю кваліфікованого імені. Як результат, коли ви кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі <code>scala.collection.mutable.Set</code>. В цьому рядку ви ініціалізуєте <code>movieSet</code> новою змінною, що містить рядки "Hitch" та "Poltergeist". Наступний рядок додає "Shrek" до змінної множини, викликаючи метод <code>+=</code> до множини, передаючи йому рядок "Shrek". Як зазначалось раніше, <code>+=</code> насправді є методом, визначеним на змінній множині. За вашим бажанням, замість <code>writingmovieSet += "Shrek"</code>, ви можете написати <code>movieSet.+=("Shrek")</code>.<span class="footnote"><br />[Оскільки множина в Лістингу 3.6 змінна, немає потреби переприсвоювати movieSet, ось чому вона може бути встановлена в val. До контрасту, використання += з незмінною множиною в Лістингу 3.5 потребує переприсвоєння jetSet, ось чому воно має бути var.]<br /></span></p></div>
<div class="paragraph"><p>Хоча реалізація множин по замовчанню, спродукована змінною та незмінною методами фабриками <code>Set</code>, буде достатньою в багатьох ситуаціях, часом ви можете побажати явно задати клас. Нащастя, синтаксис є подібним. Просто імпортуйте потрібний вам клас, та використовуйте метод фабрику на його об'єкті компанйоні. Наприклад, якщо вам треба незмінний <code>HashSet</code>, ви можете зробити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.immutable.HashSet</span>
<span class="k">val</span> <span class="n">hashSet</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="s">&quot;Tomatoes&quot;</span><span class="o">,</span> <span class="s">&quot;Chilies&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">hashSet</span> <span class="o">+</span> <span class="s">&quot;Coriander&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший корисний клас колекції в Scala є <code>Map</code>. Як і з множинами, Scala провадить змінну та незмінну версії <code>Map</code>, використовуючи ієрархію класів. Як ви можете побачити на Малюнку 3.3, ієрархія класів для мап виглядає мажйе так, як така для множин. Існує базовий трейт <code>Map</code> в пакунку <code>packagescala.collection</code>, і два субтрейти Maps: змінний Map в <code>scala.collection.mutable</code> та незмінний в <code>scala.collection.immutable</code>.</p></div>
<div class="paragraph"><p>Малюнок 3.3 - Ієрархія класів для Scala мап.</p></div>
<div class="paragraph"><p>Реалізації Map, такі як <code>HashMaps</code>, показані в ієрархії на Малюнку 3.3, розширюють або змінний, або незмінний трейт. Ви можете створити та ініціалізувати мапи, використовуючи метди фабрики, подібні до таких для масивів, списків та множин.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">treasureMap</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]()</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;Go to island.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;Find big X on ground.&quot;</span><span class="o">)</span>
<span class="n">treasureMap</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;Dig.&quot;</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">treasureMap</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.7 - Створення, ініціалізація та використання змінної мапи.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 3.7 показує змінну мапу в дії. On the first line of Лістинг 3.7, you import the mutable Map. You then define a val named treasureMap, and initialize it with an empty mutable Map that has integer keys and string values. The map is empty because you pass nothing to the factory method (the parentheses in "Map[Int, String]()" are empty).<span class="footnote"><br />[Явна параметризація типу, "[Int, String]", є необхідною в Лістингу 3.7, оскільки без любих значень, переданих в метод фабрику компілятор не здатний вивести тип параметрів мапи. Для контрасту, компілятор може вивести тип параметрів зі значень, переданих до фабрики мапи, показаної в Лістингу 3.8, так що явних параметрів типу не треба.]<br /></span> На наступних трьох рядках ви додаєте до мапи пари ключ/значення, використовуючи методи <code>-&gt;</code> та <code>+=</code>. Як вже було проілюстровано, компілятор Scala трансформує двомісні вирази операцій, як <code>1 -&gt; "Go to island."</code> на <code>(1).-&gt;("Go to island.")</code>. Таким чином, коли ви кажете <code>1 -&gt; "Go to island."</code>, ви насправді викликаєте метод на ім'я <code>-&gt;</code> на цілому зі значенням <code>1</code>, передаючи йому рядок зі значенням "Go to island." Цей метод <code>-&gt;</code>, який ви можете викликати на об'єкті в програмі Scala, повертає дво-елементний тапл, що містить ключ та значення.<span class="footnote"><br />[Механізм Scala, що дозволяє вам викликати  &#8594; на любому об'єкті, неявне перетворення, буде розкрите в Главі 21.]<br /></span> Потім ви можете передати тапл до метода <code>+=</code> об'єкта мапи, на який посилається <code>treasureMap</code>. Нарешті, останній рядок друкує значення, що відповідає ключу 2 treasureMap.</p></div>
<div class="paragraph"><p>Якщо ви виконаєте цей код, він надрукує:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Find big X on ground.</code></pre>
</div></div>
<div class="paragraph"><p>Якщо ви обираєте незмінну мапу, імпорт непотрібний, бо незмінна є мапою по замовчанню. Приклад показаний в Лістингу 3.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">romanNumeral</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
  <span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;I&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;II&quot;</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;III&quot;</span><span class="o">,</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="s">&quot;IV&quot;</span><span class="o">,</span> <span class="mi">5</span> <span class="o">-&gt;</span> <span class="s">&quot;V&quot;</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">romanNumeral</span><span class="o">(</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.8 - Створення, ініціалізація та використання незмінної мапи.</p></div>
<div class="paragraph"><p>Зважаючи на те, що тут немає імпортів, ви можете сказати, що <code>Map</code> в першому рядку Лістинга 3.8 ви отримаєте замовчання, <code>scala.collection.immutable.Map</code>. Ви передаєте п'ять таплів ключ/значення до метода фабрики мапи, що повертає незмінну <code>Map</code>, яка містить передані пари ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__11____">Крок 11. Вчимсоь розпізнавати функціональний стиль</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Главі 1, Scala дозволяє вам програмувати в імперативному стилі, але заохочує вас адоптувати більш функціональний стиль. Якщо ви прийшли в Scala з імперативного бекграунда, наприклад, якщо ви Java програміст, одним з головних викликів, з яким ви стикаєтесь при вивченні Scala є зрозуміти, як програмувати в функціональному стилі. Ми розуміємо, що цей стиль зпочатку може бути незвичним, але в цій книзі ми намагаємось направляти вас в цьому переході. Це буде потребувати деякої роботи з вашого боку, і ми закликаємо докласти зусиль. Якщо ви прийшли з імперативного бекграунду, ми віримо, що вивчення програмування в функціональному стилі не тільки зробить вам кращим програмістом Scala, але також розширить ваші горизонти, та зробить кращим програмістом взагалі.</p></div>
<div class="paragraph"><p>Перший крок це розпізнати різницю між двома стилями в коді. Один промовистий знак - це якщо код містить любі <code>var</code>, вірогідно що він в імперативному стилі. Якщо код взагалі не містить — тобто, він містить тільки <code>val</code> — вірогідно він в функціональному стилі. Таким чином, одним шляхом рухатись в функціональному стилі є спробувати програмувати без <code>var</code>.</p></div>
<div class="paragraph"><p>Якщо ви походите з імперативного бекграунда, як Java, C++ або C#, ви можете думати про <code>var</code> як про звичану змінну, та про <code>val</code> як про спеціальний різновид змінних. З іншого боку, якщо ви походите з функціонального бекграунда, як Haskell, OCaml або Erlang, ви можете думати про <code>val</code> як про звичану змінну, та <code>var</code> як спробу святотацтва. Однак перспектива Scala полягає в тому, що <code>val</code> та <code>var`є просто два різні інструменти в вашому наборі, обоє корисні, та жодний не є втілення зла. Scala заохочує вас вивчати щодо `val</code>, але кінець кінцем отримати кращий інструмент, що знадобиться для вашої роботи. Однак навіть якщо ви згодні з цією збалансованою філософією, ви все одно можете на початку знайти складним, як позбавитись від <code>var</code> в своєму коді.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо наступний цикл <code>while</code>, адаптований з Глави 2, що використовує <code>var</code>, та є, таким чином, в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трансформувати цей шматок коду в більш функціональний стиль, поклавши край <code>var</code>, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>або так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="n">args</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей приклад ілюструє одну перевагу від програмування з меншою кількістю <code>var</code>. Рефактований (більш функціональний) код є чистіший, більш стислий, та менш схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з якої Scala заохочує до функціонального стилю, в тому, що він може допомогти вам писати більш зрозумілий, менш схильний до помилок код.</p></div>
<div class="paragraph"><p>Але ви можете пійти навіть далі. Рефакторений метод <code>printArgs</code> не є повністю функціональним, бо він має побічні ефекти — в цьому випадку цей побічний ефект є друк у стандартний вихідний потік. Промовистий знак що функція має побічні ефекти, це коли тип її результата Unit. Якщо функція не повертає жодного цікавого значення, що і означає тип результата Unit, єдиним шляхом, яким функція може зробити зміни в світі, че через деякий різновид побічного ефекту. Більше функціональний підхід може бути в визначенні метода, що форматує передані <code>args</code> для друку, але тільки повертає форматований рядок, як показано в Лістингу 3.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">args</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.9 - A function without side effects or vars.</p></div>
<div class="paragraph"><p>Тепер ви дійсно функціональні: немає ні побічних ефектів, ні <code>var</code> в полі зору. Метод <code>mkString</code>, який ви можете викликати на любій ітерабельній колекції (включаючи масиви, списки, множини та мапи), повкртає рядок, що складається з викликів <code>toString</code> на кожному елементі, розділені переданим рядком. Таким чином, якщо аргументи складаються з трьох аргументів, "zero", "one", "two", <code>formatArgs</code> буде повертати <code>"zero\none\ntwo"</code>. Звичайно, ця функція насправді не друкує нічого назовні, як робив метод <code>printArgs</code>, але ви можете просто передати його результат до <code>println</code>, щоб досягти цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="n">formatArgs</span><span class="o">(</span><span class="n">args</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожна корисна програма, вірогідно, буде мати побічні ефекти в деякій формі; інакше, буде неможливо провадити значення до зовнішнього світу. Схильність до методів без побічних ефектів заохочує вас розробляти програми, де код з побічними ефектами мінімізований. Одна з переваг цього підходу в тому, щоце може допомогти вашим програмам простіше тестуватись.</p></div>
<div class="paragraph"><p>Наприклад, щоб протестувати любий з трьох методів <code>printArgs</code>, показаних раніше в цьому розділі, вам треба перевизначити <code>println</code>, перехопити переданий йому вивід, та переконатись, що там те, що ви очікуєте. Для контрасту, ви можете тестувати функцію <code>formatArgs</code>, просто перевіряючи її результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">formatArgs</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;zero&quot;</span><span class="o">,</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
<span class="n">assert</span><span class="o">(</span><span class="n">res</span> <span class="o">==</span> <span class="s">&quot;zero\none\ntwo&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод Scala <code>assert</code> перевіряє переданий їй <code>Boolean</code>, та якщо воно <code>false</code>, підіймає <code>AssertionError</code>. Якщо передане <code>Boolean</code> є <code>true</code>, <code>assert</code> просто повертає керування. Ви навчитесь більше щодо тверджень в тестах в Главі 14.</p></div>
<div class="paragraph"><p>Кажучи це, майте на увазі, що ні <code>var</code>, ні побічні ефекти не є природним злом. Scala не є чисто функціональною мовою, що змушує вас програмувати все в функціональному стилі. Scala є гібридною, імперативно/функціональною мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще підходить до вирішуваної проблеми, і в таких випадках вам не треба боятись використовувати його. Однак щоб допомогти вам навчитись, як програмувати без <code>var</code>, ми покажемо вам багато специфічних прикладів коду з <code>var</code>, та як трансформувати ці <code>val</code> в Главі 7.</p></div>
<div class="sect2">
<h3 id="____scala_">Збалансоване ставлення для Scala програмістів</h3>
<div class="paragraph"><p>Схиляйтесь до <code>val</code>, незмінних об'єктів та методів без побічних ефектів. Спочатку розпочніть з них. Використовуйте <code>var</code>, змінні об'єкти та методи з побочними ефектами, коли ви маєте специфічні потреби, та обгрунтування для них.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__12____">Крок 12. Читання рядків з файла</h2>
<div class="sectionbody">
<div class="paragraph"><p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробки рядків в файлі. В цьому розділі ви побудуєте скрипт, що читає рядки з файла, та друкує їх, проставляючи напочату кількість символів в кожному рядку. Перша версія показана в Лістингу 3.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">())</span>
    <span class="n">println</span><span class="o">(</span><span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.10 - Читання рядків з файла.</p></div>
<div class="paragraph"><p>Цей скрипт починається з імпорту класу на ім'я <code>Source</code> з пакунка  <code>scala.io</code>. Потім він перевіряє, щоб побачити, що в командному рядку був вказаний хоча б один аргумент. Якщо так, перший аргумент інтерпретується як ім'я файла, що треба відкрити та обробити. Вираз <code>Source.fromFile(args(0))</code> намагається відкрити вказаний файл, та повертає об'єкт <code>Source</code>, на якому ви викликаєте <code>getLines</code>. Метод <code>getLines</code> повертає <code>Iterator[String]</code>, що провадить по одному рядку на кожній ітерації, відкидаючи символ кінця рядка. Вираз <code>for</code> ітерує по цім рядках, та друкує для кожноого довжину рядка, проміжок, та сам рядок. Якщо в командному рядку не надано жодного аргументу, фінальне твердження <code>else</code> буде друкувати повідомлення в стандартний потік помилок. Якщо ви покладете цей код в файл на ім'я <code>countchars1.scala</code>, та викличете його для самого себе командою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ scala countchars1.scala countchars1.scala</code></pre>
</div></div>
<div class="paragraph"><p>Ви маєте побачити:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51 for (line &lt;- Source.fromFile(args(0)).getLines())
37 println(line.length + " " + line)
1 }
4 else
46 Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Хоча скрипт в своїй поточній формі друкує потрібну інформацію, ви можете побажати підрівняти числа, вирівняти вправо, та додати символ роздільника, так щоб вивід виглядав так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>22 | import scala.io.Source
 0 |
22 | if (args.length &gt; 0) {
 0 |
51 |   for (line &lt;- Source.fromFile(args(0)).getLines())
37 |     println(line.length + " " + line)
 1 | }
 4 | else
46 |   Console.err.println("Please enter filename")</code></pre>
</div></div>
<div class="paragraph"><p>Щоб досягти цього, ви можете ітерувати по рядках двічі. На першому проході ви будете визначати максимальну довжину, достатню для любого підрахунку символів. На другому проході ви друкуєте вивід, використовуючи максимальну ширину, що обчислена раніше. Оскільки ви будете ітерувати по рядках двічі, ми можете також присвоїти їх до змінної:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
</pre></div></div></div>
<div class="paragraph"><p>Заключний <code>toList</code> потрібне, бо метод <code>getLines</code> повертає ітератор. Коли ви проходите через ітератор, він вже витрачений. Трансформуючи його в список через виклик <code>toList</code>, ви отримаєте здатність ітерувати так багато раз, як вам треба, ціною зберігання всіх рядків з файла, одночасно. Таким чином, змінна <code>lines</code> посилається на список рядків, що складають вміст файла, вказаного в командному рядку. Далі, оскільки ми будемо обчислювати ширину довжини кожного рядка двічі, по разу для кожної ітерації, ви можете виділити цей вираз в невелику функцію, що обчислює скільки символів в ширину буде займати довжина рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>З такою функцією ви можете обчислювати максимальну ширину таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span>
  <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">maxWidth</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ви ітеруєте по кожному рядку за допомогою вираза <code>for</code>, обчислює символьну ширину довжини рядка, і якщо вона довша ніж поточний максимум, присвоюється до <code>maxWidth</code>, <code>var</code>, що була ініціалізована як 0. (Метод <code>max</code>, який ви можете викликати на Int, повертає більше зі значень, того, на якому вона викликана, та переданого як параметр). Альтернативно, якщо ви обираєте знайти максимум без <code>var</code>, ви можете спочатку знайти довший рядок, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
  <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>reduceLeft</code> застосовує передану функцію до перших двох елементів в <code>lines</code>, потім застосовує її до результату першої операції та наступного елементу в <code>lines</code>, і так далі, по всьому списку. На кожному такому застосуванні результат буде довшим рядком, знайденим до цього моменту, оскільки передана функція, <code>(a, b) =&gt; if (a.length &gt; b.length) a else b</code>, повертає довший з переданих рядків. <code>reduceLeft</code> буде повертати результат останнього застосування функції, що в цьому випадку буде найдовшим рядком-елементом, що міститься в <code>lines</code>.</p></div>
<div class="paragraph"><p>Маючи цей результат, ви можете обчислити максимальну ширину, передаючи найдовший рядок в <code>towidthOfLength</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що лишається, це надрукувати рядки з відповідним форматуванням. Ви можете зробити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
<span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
<span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
<span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому виразі ви ще раз ітеруєте по рядках. Для кожного рядка ви спочатку обчислюєте число проміжків, потрібних перед довжиною рядка, та присвоюєте його до <code>numSpaces</code>. Потім ви створюєте рядок, що містить <code>numSpaces</code> проміжків за допомогою вираза <code>" " * numSpaces</code>. Нарешті ви друкуєте інформацію з бажаним форматуванням. Повний скрипт виглядає як показано на Лістингу 3.11:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.io.Source</span>
<span class="k">def</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">length</span>
<span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
  <span class="k">val</span> <span class="n">longestLine</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">reduceLeft</span><span class="o">(</span>
    <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
  <span class="o">)</span>
  <span class="k">val</span> <span class="n">maxWidth</span> <span class="k">=</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">longestLine</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">line</span> <span class="k">&lt;-</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">numSpaces</span> <span class="k">=</span> <span class="n">maxWidth</span> <span class="o">-</span> <span class="n">widthOfLength</span><span class="o">(</span><span class="n">line</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="n">numSpaces</span>
    <span class="n">println</span><span class="o">(</span><span class="n">padding</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="s">&quot; | &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">else</span>
  <span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;Please enter filename&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 3.11 - Друкування форматованого підрахунку символів для рядків в файлі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зі знанням, що ви отримали в цій главі, ви повинні бути здатні почати використовувати Scala для малих завдань, особливо скриптів. В подальших главах ми будемо занурюватись далі в ці теми, та введемо інші теми, що не які тут не було натяку.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-26 00:03:35 EET
</div>
</div>
</body>
</html>
