<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__23">Глава 23</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____code_for_code">Ще раз про вирази <code>for</code></h1>
<div class="paragraph"><p>Глава 16 продемонструвала, що функції вищих порядків, такі як <code>map</code>, <code>flatMap</code>, та <code>filter</code>, провадять потужні конструкції для роботи зі списками. Але іноді рівень абстракції, що потребують ці функції, робить програми трохи складними для розуміння.</p></div>
<div class="paragraph"><p>Ось приклад. Скажімо, ви отримали список людей, кожний визначений як примірник класу  <code>Person</code>. Клас <code>Person</code> має поля, де вказані ім'я, стать, та перелік дітей.</p></div>
<div class="paragraph"><p>Ось визначення класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                         <span class="n">isMale</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
                         <span class="n">children</span><span class="k">:</span> <span class="kt">Person*</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад декількох записів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lara</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Lara&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bob</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
<span class="k">val</span> <span class="n">julie</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Julie&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">)</span>
<span class="k">val</span> <span class="n">persons</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">,</span> <span class="n">julie</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, скажімо, ми бажаємо знайти всі пари імен матерів та їх дітей в цьому списку. Використовуючи <code>map</code>, <code>flatMap</code> та <code>filter</code> ви можете зформулювати наступний запит:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">filter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
            <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трохи оптимізувати цей приклад, використавши виклик <code>withFilter</code> замість <code>filter</code>. Це дозволить уникнути створення проміжної структури даних для жінок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці запити роблять свою роботу, але вони не дуже тривіальні для написання та розуміння. Чи є простіший спосіб? Фактично, так. Згадайте вирази <code>for</code> в Розділі 7.3? Використовуючи вирази <code>for</code>, той самий приклад може бути записаний наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">;</span> <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="n">children</span><span class="o">)</span>
      <span class="k">yield</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Результат цього виразу точно такий самий, що і результат попереднього виразу. Більше того, більшість читачів коду вірогідно знайде, що вирази <code>for</code> значно ясніші, ніж попередні запити, що використовують функції вищих порядків, <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>.</p></div>
<div class="paragraph"><p>Однак, останні два запити не настільки різноманітні, як може виглядати. Фактично, з'ясовується, що компілятор Scala буде транслювати другий запит в перший. Більш загально, всі вирази <code>for</code>, що видають результат, транслюються компілятором в комбінації викликів методів вищого порядку, <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Всі <code>for</code> цикли без <code>yield</code> транслюються в меньший набір функцій вищого порядку: тільки <code>withFilter</code> та <code>foreach</code>.</p></div>
<div class="paragraph"><p>В цій главі ви з'ясуєте для початку щодо точних правил написання виразів. Після цього ви побачите, як вони можуть зробити комбінаторні проблеми простішими для вирішення. Нарешті, ви вивчите, як транслюються <code>for</code> вирази, і як результат, <code>for</code> вирази можуть допомогти вам "виростити" мову Scala в нових доменах застосування.</p></div>
<div class="sect1">
<h2 id="_23_1__code_for_code">23.1 Вирази <code>for</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Загалом, <code>for</code> вираз має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span> <span class="n">seq</span> <span class="o">)</span> <span class="k">yield</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>seq</code> є послідовність генераторів, визначень та фільтрів, розділені крапкою з комою між послідовними елементами. Приклад для <code>for</code> виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">))</span>
<span class="k">yield</span> <span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей <code>for</code> вираз містить один генератор, одне визначення та один фільтр. Як зазначалось в Розділі 7.3, ви також можете оточити послідовність в фігурні дужки замість звичайних. Тоді крапки з комою стають опціональними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">{</span>
  <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span>           <span class="c1">// генератор</span>
  <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>             <span class="c1">// визначення</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">)</span> <span class="c1">// фільтр</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p>Генератор має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>expr</code> типово повертає список, навіть якщо, як ви побачите пізніше, це може бути узагальнено. Шаблон <code>pat</code> співпадає один-до-одного з усіма елементами цього списку. Якщо співпадіння успішне, змінні в шаблоні прив'язуються до відповідних частин елементу, в той самий спосіб, як описане в Главі 15. Але якщо співпадіння схибить, виключення <code>MatchError</code> не виникне. Замість цього елемент просто відкидається з ітерації.</p></div>
<div class="paragraph"><p>В самому загальному випадку шаблон <code>pat</code> є тільки змінна <code>x</code>, як в <code>x &lt;- expr</code>. В цьому випадку змінна <code>x</code> просто ітерує по всіх елементах, що повертає <code>expr</code>.</p></div>
<div class="paragraph"><p>Визначення має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="k">=</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення прив'язує шаблон <code>pat</code> до значення <code>expr</code>, так що це має той самий ефект, що і визначення <code>val</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний випадок знову коли шаблон є простою змінною <code>x</code> (тобто, <code>x = expr</code>). Це визначає <code>x</code> як ім'я для значення <code>expr</code>.</p></div>
<div class="paragraph"><p>Фільтр має таку форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>expr</code> є вираз типу <code>Boolean</code>. Фільтр відкидає з ітерації всі елементи, для яких <code>expr</code> повертає <code>false</code>.</p></div>
<div class="paragraph"><p>Кожний <code>for</code> вираз починається з генератора. Якщо є декілька генераторів в виразі <code>for</code>, пізніші генератори змінюються більш швидко, ніж ранішні. Ви можете просто це перевірити за допомогою наступного простого тесту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
        <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span><span class="n">one</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">two</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">one</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">two</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_2__n_">23.2 Проблема N ферзів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Особливо придатною областю застосування <code>for</code> виразів є комбінаторні головоломки. Прикладом такої головоломки є проблема 8-ми ферзів: маючи стандартну шахову дошку, розмістити вісім ферзів, так, щоб жодний не шахував іншого (ферзь шахує іншу фігуру, якщо стоїть на тому самому рядку, лінії або диагоналі). Щоб знайти рішення цієї проблеми, насправді легше узагальнити її для шахових дошок довільного розміру. Таким чином, проблема є розмістити N ферзів на шахівниці з <code>N x N</code> клітин, де розмір <code>N</code> довільний. Ми почнемо нумерування клітин з одного, так що верхня-ліва клітина на дошці <code>N x N</code> має координати <code>(1, 1)</code>, та нижня-права клітина має координати <code>(N, N)</code>.</p></div>
<div class="paragraph"><p>Щоб вирішити проблему <code>N</code> ферзів, зауважте, що вам треба розмістити ферзя на кожному рядку. Так що ви можете ставити ферзів в послідовних рядках, кожний раз перевіряючи, що новий розміщений ферзь не шахується жодним іншим ферзем, що вже на дошці. По ходу цього пошуку, може статись, що ферзь, який треба поставити на рядок <code>k</code>, шахується у всіх полях цього рядка з ферзями на рядках від <code>1</code> до <code>k-1</code>. В цьому випадку вам треба перервати цю частину пошуку, щоб продовжити з іншою конфігурацією ферзів в стовпчиках від <code>1</code> до <code>k-1</code>.</p></div>
<div class="paragraph"><p>Імперативне рішення цієї проблеми буде ставити ферзів один по одному, рухаючи їх по дошці. Але це виглядає складним запропонувати схему, що насправді спробує всі можливості. Більш функціональний підхід представляє рішення напряму, як значення. Рішення складається зі списку координат, по одній для кожного ферзя на дошці. Однак занотуйте, що повне рішення не може бути знайдене за один крок. Рішення має бути побудоване поступово, через захоплення послідовних рядків ферзями.</p></div>
<div class="paragraph"><p>Це підказує рекурсивний алгоритм. Уявімо, що ви вже згенерували всі рішення, розмістивши  <code>k</code> ферзів на дошці розміром <code>N x N</code>, до <code>k</code> меньше ніж <code>N</code>. Кожне таке рішення може бути презентовано як список довжиною <code>k</code> координат <code>(row, column)</code>, де обидва, <code>row</code> та <code>column</code> є числами в диапазоні від <code>1</code> до <code>N</code>. Зручно розглядати ці часткові списки рішень як стеки, де координати ферзя на рядку <code>k</code> ідуть першими в списку, за яким ідуть координати ферзя в рядку <code>k-1</code>, і так далі. Знизу стека є координати ферзя, розміщеного на першому рядку дошки. Всі рішення разом представлені як список списків, з одним елементом для кожного ферзя.</p></div>
<div class="paragraph"><p>Тепер, щоб поставити наступного ферзя в рядок <code>k+1</code>, згенеруйте всі можливі розширення кожного попереднього рішення ще на одного ферзя. Це дає інший список рішень, на цей раз довжини <code>k+1</code>. Продовжуйте процес доки ви не отримаєте всі рішення розміру шахівниці N.</p></div>
<div class="paragraph"><p>Ця алгоритмична ідея втілена в функціональне <code>placeQueens</code> нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">queens</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
    <span class="k">else</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">queens</span> <span class="k">&lt;-</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
        <span class="n">column</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
        <span class="n">queen</span> <span class="k">=</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
        <span class="k">if</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">queens</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">queen</span> <span class="o">::</span> <span class="n">queens</span>

  <span class="n">placeQueens</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зовнішня функція <code>queens</code> в програмі вище просто викликає <code>placeQueens</code> з розміром дошки <code>n</code> в якості аргумента. Завдання функції <code>placeQueens(k)</code> є генерація всіх часткових рішень довжини <code>k</code> в списку. Кожний елемент списку є одним рішенням, представлений списком довжини <code>k</code>. Так що <code>placeQueens</code> повертає список списків.</p></div>
<div class="paragraph"><p>Якщо параметр <code>k</code> до <code>placeQueens</code> є <code>0</code>, це означає, що треба згенерувати всі рішення, розмістивши нуль ферзів на нулі рядків. Існує тільки одне таке рішення: не розташовувати ферзів взагалі. Це рішення представлене порожнім списком. Так що якщо <code>k</code> є нуль,<code>placeQueens</code> повертає <code>List(List())</code>, список складається з єдиного елемента, що є порожнім списком. Зауважте, що це доволі відрізняється від порожнього списку <code>List()</code>.</p></div>
<div class="paragraph"><p>Якщо <code>placeQueens</code> повертає <code>List()</code>, це означає відсутність рішень, замість єдиного рішення, що складається з відсутності розміщених ферзів.</p></div>
<div class="paragraph"><p>В іншому випадку, коли <code>k</code> не нуль, вся робота <code>placeQueens</code> виконується в <code>for</code> виразі. Перший генератор цього <code>for</code> виразу ітерує по всіх рішеннях, розміщуючи <code>k - 1</code> ферзів на дошці. Другий генератор ітерує по всіх можливих стовпчиках, на яких може бути розміщений  <code>k</code>-тий ферзь. Третя частина <code>for</code> виразу визначає новітньо розглянуту позицію ферзя, що буде парою з рядка <code>k</code> та кожного стовпчика. Четверта частина виразу <code>for</code> є фільтром, що перевіряє за допомогою <code>isSafe</code>, чи новий ферзь є вільний від шаху всіма існуючими ферзями (визначення <code>isSafe</code> буде розглянута трохи пізніше).</p></div>
<div class="paragraph"><p>Якщо новий ферзь не має шахів від жодного з інших ферзів,
він може формувати частину часткового рішення, так що <code>placeQueens</code> генерує нове рішення за допомогою <code>queen :: queens</code>. Якщо новий ферзь не вільний від шаху, фільтр повертає <code>false</code>, так що рішення не генерується.</p></div>
<div class="paragraph"><p>Один фрагмент, що залишився, це метод <code>isSafe</code>, що використовується для перевірки, чи даний ферзь шахується любим іншим елементом в списку ферзів. Ось його визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=</span>
  <span class="n">queens</span> <span class="n">forall</span> <span class="o">(</span><span class="n">q</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">inCheck</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">q</span><span class="o">))</span>

<span class="k">def</span> <span class="n">inCheck</span><span class="o">(</span><span class="n">q1</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">q2</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span> <span class="o">||</span> <span class="c1">// той самий рядок</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span> <span class="o">||</span> <span class="c1">// той самий стовпчик</span>
  <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span><span class="o">).</span><span class="n">abs</span> <span class="o">==</span> <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">abs</span> <span class="c1">// на диагоналі</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>isSafe</code> виражає, що ферзь безпечний у відношенні до інших ферзів, якщо він не шахується іншим ферзем. Метод <code>inCheck</code> виражає, що ферзі <code>q1</code> та <code>q2</code> взаємно шахуються. Він повертає <code>true</code> в одному з трьох випадків:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Якщо два ферзя мають ту саму координату рядка,
</p>
</li>
<li>
<p>
Якщо два ферзя мають ту саму координату стовбчика,
</p>
</li>
<li>
<p>
Якщо два ферзя на тій самій диагоналі (тобто, різниця між рядками і різниця між стовпчиками ті самі).
</p>
</li>
</ol></div>
<div class="paragraph"><p>Перший випадок, коли два ферзя мають ту саму координату, не може трапитись в застосуванні, бо <code>placeQueens</code> вже потурбувався про розіщення кожного ферзя на окремому рядку. Так що ви можете видалити цю перевірку без зміни функціональності програми.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_3____code_for_code_">23.3 Запити за допомогою <code>for</code> виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Нотація <code>for</code> в основному еквівалентна до загальних операцій мови запитів бази даних. Наприклад, скажімо, ви отримали базу даних на ім'я <code>books</code>, що представлена як спикок нижок, де кожна книжка <code>Book</code> визначена наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось малий приклад бази даних, представленої як список в пам'яті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Structure and Interpretation of Computer Programs&quot;</span><span class="o">,</span>
      <span class="s">&quot;Abelson, Harold&quot;</span><span class="o">,</span> <span class="s">&quot;Sussman, Gerald J.&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Principles of Compiler Design&quot;</span><span class="o">,</span>
      <span class="s">&quot;Aho, Alfred&quot;</span><span class="o">,</span> <span class="s">&quot;Ullman, Jeffrey&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Programming in Modula-2&quot;</span><span class="o">,</span>
      <span class="s">&quot;Wirth, Niklaus&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Elements of ML Programming&quot;</span><span class="o">,</span>
      <span class="s">&quot;Ullman, Jeffrey&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;The Java Language Specification&quot;</span><span class="o">,</span> <span class="s">&quot;Gosling, James&quot;</span><span class="o">,</span>
      <span class="s">&quot;Joy, Bill&quot;</span><span class="o">,</span> <span class="s">&quot;Steele, Guy&quot;</span><span class="o">,</span> <span class="s">&quot;Bracha, Gilad&quot;</span>
    <span class="o">)</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб знайти назви всіх книжок, в яких останнє ім'я автора починається з <code>"Gosling"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">b</span><span class="o">.</span><span class="n">authors</span>
            <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">&quot;Gosling&quot;</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">The</span> <span class="nc">Java</span> <span class="nc">Language</span> <span class="nc">Specification</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або щоб знайти назви всіх книжок, що мають рядок <code>"Program"</code> в своїй назаві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">title</span> <span class="n">indexOf</span> <span class="s">&quot;Program&quot;</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Structure</span> <span class="n">and</span> <span class="nc">Interpretation</span> <span class="n">of</span>
  <span class="nc">Computer</span> <span class="nc">Programs</span><span class="o">,</span> <span class="nc">Programming</span> <span class="n">in</span> <span class="nc">Modula</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Elements</span> <span class="n">of</span> <span class="nc">ML</span>
    <span class="nc">Programming</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або щоб знайти в базі даних імена всіх авторів, що написали щонайменьше дві книжки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
           <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">a1</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">,</span> <span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Останнє рішення все ще недосконале, оскільки автори будуть з'являтись декілька разів в списку результатів. Вам все ще треба видалити дублікати авторів з отриманих списків. Це можливо досягти з наступною функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">removeDuplicates</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">xs</span>
         <span class="k">else</span>
           <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
             <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="n">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
           <span class="o">)</span>
       <span class="o">}</span>
<span class="n">removeDuplicates</span><span class="k">:</span> <span class="err">[</span><span class="kt">A</span><span class="err">]</span><span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">res6</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Варто відзначити, що останній вираз в методі <code>removeDuplicates</code> може бути виражений еквівалентно з використанням виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span>
<span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_4__code_for_code_">23.4 Трансляція <code>for</code> виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кожний <code>for</code> вираз може бути виражений в термінах трьох функцій вищого порядку: <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Цей розділ описує схему трансляції, що також використовується компілятором Scala.</p></div>
<div class="sect2">
<h3 id="__code_for_code____">Трансляція <code>for</code> виразів з одним генератором</h3>
<div class="paragraph"><p>Перше, уявімо ви маєте простий вираз <code>for</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>де <code>x</code> є змінною. Такий вираз транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_______">Трансляція <code>for</code> виразів, що починаються з генератора та фільтра</h3>
<div class="paragraph"><p>Тепер розглянемо <code>for</code> вираз, що комбінує лідируючий генератор з деякими іншими елементами.</p></div>
<div class="paragraph"><p>Вираз <code>for</code> наступної форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">))</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця трансляція дає наступний вираз <code>for</code>, що на один елемент коротший, ніж оригінал, бо елемент <code>if</code> трансформується в застосування <code>withFilter</code> на першому виразі генератора. Трансформація потім продовжується з цім другим виразом, так що в кінці ми отримаємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Така сама схема трансляції також застосовується, якщо після фільтра ідуть інші елементи. Якщо <code>seq</code> є довільною послідовністю генераторів, визначень та фільтрів, тоді:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="n">withFilter</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім трансляція продовжується з другим виразом, що знову коротший на один елемент, ніж оригінальний.</p></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_____">Трансляція <code>for</code> виразів починаючи з двох генераторів</h3>
<div class="paragraph"><p>Наступний випадок обробляє <code>for</code> вирази, що починаються з двох генераторів, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову, будемо вважати, що <code>seq</code> є довільною послідовністю генераторів, визначень та фільтрів. Фактично, <code>seq</code> може також бути порожнім, і в такому випадку після <code>expr_2</code> крапка з комою непотрібні. Схема трансляції залишається такою самою в кожному випадку. Вираз <code>for</code> вище транслюється до застосування <code>flatMap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>На цей раз існує інший вираз <code>for</code> в функціональному значенні, переданого до <code>flatMap</code>. Цей вираз <code>for</code> (що знову на елемент простіший, ніж оригінал) в свою чергу транслюється за тими самими правилами. Три схеми трансляції, надані перед цім, достатні для транслювання всіх виразів, що містять тільки генератори та фільтри, та де генератори прив'язують тільки прості змінні. Візьмемо, наприклад, запит: "Знайти всіх авторів, що опубліковали щонайменьше дві книги", з Розділу 23.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
  <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">a1</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей запит транслюється до наступної комбінації <code>map</code>/<code>flatMap</code>/<code>filter</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">books</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b1</span> <span class="k">=&gt;</span>
  <span class="n">books</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">authors</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">a1</span> <span class="k">=&gt;</span>
      <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span>
        <span class="n">a1</span><span class="o">))))</span>
</pre></div></div></div>
<div class="paragraph"><p>Представлена дотепер схама трансляції ще не обробляє генератори, які прикріплюють цілі шаблони, замість простих змінних. Вона також досі не покриває визначення. Ці два аспекта будуть пояснені в наступних двох підсекціях.</p></div>
</div>
<div class="sect2">
<h3 id="____">Трансляція шаблонів в генераторах</h3>
<div class="paragraph"><p>Схема трансляції стає більш складна, якщо ліва сторона генератора є шаблоном <code>pat</code>, іншим, ніж проста змінна. Випадок, коли вираз <code>for</code> зв'язує тапл змінних, є все ще простим для обробки. В цьому випадку діє майже та сама схема, що застосовується для окремих змінних.</p></div>
<div class="paragraph"><p><code>for</code> вираз такої форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">((</span><span class="kc">null</span><span class="o">,</span> <span class="o">...,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="o">...,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">expr_2</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це стає трохи складнішим, якщо ліва сторона генератора є довільним шаблоном <code>pat</code>, замість окремої змінної або тапла.</p></div>
<div class="paragraph"><p>В цьому випадку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span> <span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">expr_2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто згенеровані елементи зпочатку фільтруються, і тільки ті, що співпадають з <code>pat</code>, відзеркалюються. Таким чином гарантовано, що генератор зі співпадінням шаблонів, ніколи не закидатиме <code>MatchError</code>.</p></div>
<div class="paragraph"><p>Тут схема трактує тільки випадок, коли вираз <code>for</code> містить один генератор співпадіння шаблону. Аналогічні правила також застосовуються, якщо вираз <code>for</code> містить інші герератори, фільтри та визначення. Оскільки ці додаткові правила не додають багато нового розуміння, вони виключені тут з дискусії. Якщо ви зацікавлені, ви можете пошукати їх в <em>Scala Language Specification</em> [Ode11].</p></div>
</div>
<div class="sect2">
<h3 id="__">Трансляція визначень</h3>
<div class="paragraph"><p>Остання відсутня ситуація, це коли <code>for</code> вираз містить вбудовані визначення. Ось типовий випадок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="kc">null</span> <span class="k">=</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову вважатимемо, що <code>seq</code> є (можливо порожньою) послідовністю генераторів, визначень та фільтрів. Цей вираз транслюється до такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">((</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">expr_2</span><span class="o">);</span> <span class="n">seq</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите, це <code>expr_2</code> обчислюється кожного разу, коли генерується нове значення <code>x</code>. Це пере-обчислення потрібне, оскільки <code>expr_2</code> може посилатись на <code>x</code>, так що має пере-обчислюватись для зміни значень <code>x</code>. Для вас, як для програміста, висносок в тому, що це, можливо, не є гарною ідеєю мати вбудовані визначення в <code>for</code> виразах, що не посилються на значення, прив'язані деяким попереднім генератором, оскільки пере-обчислення таких виразів буде марним. Наприклад, замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>звичайно краще записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_">Транслювання <code>for</code> циклів</h3>
<div class="paragraph"><p>Попередні субсекції показали, як транслюються <code>for</code> вирази, що містять <code>yield</code>. Як щодо циклів, що просто виконують побічні ефекти без повернення будь-чого? Їх трансляція подібна, але простіша ніж для <code>for</code> виразів. В принципі, коли попередня схема трансляції вкористовували <code>map</code> або <code>flatMap</code> в трансляції, схема трансляції для <code>for</code> циклів використовує тільки <code>foreach</code>.</p></div>
<div class="paragraph"><p>Наприклад, вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p>транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшим прикладом є вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">;</span> <span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_3</span><span class="o">)</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз транслюється до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span>
<span class="n">expr_3</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, наступний вираз підсумовує всі елементи матриці, що представлена як список списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">xs</span> <span class="k">&lt;-</span> <span class="n">xss</span><span class="o">;</span> <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей цикл танслюється в два вкладених застосувань <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">xss</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">xs</span> <span class="k">=&gt;</span>
    <span class="n">xs</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_23_5____">23.5 Заходячи з іншого боку</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній розділ показав, що вирази <code>for</code> можуть бути трансльовані в застосування функцій вищого порядку: <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Фактично, однаково ви можете іти іншим шляхом: кожне застосування <code>map</code>, <code>flatMap</code>, або <code>filter</code> може бути представлене як <code>for</code> вираз.</p></div>
<div class="paragraph"><p>Ось реалізації трьох методів в термінах <code>for</code> виразів. Методи, що містяться в об'єкті <code>Demo</code> для відмінносі їх від стандартних операцій з <code>List</code>. Щоб бути конкретним, всі три функції приймають <code>List</code> як параметр, але схема трансляції робить так само гарно і з іншими типами колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="k">yield</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>

  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="k">if</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Не дивно, що трансляція <code>for</code> виразу, використана в тілі <code>Demo.map</code>, буде продукувати виклик до <code>map</code> в класі <code>List</code>. Подібним чином, <code>Demo.flatMap</code> та <code>Demo.filter</code> транслюються до <code>flatMap</code> та <code>withFilter</code> в класі <code>List</code>. Так що ця мала демонстрація показує, що <code>for</code> вирази еквівалентні по своїй виразності до застосування трьох функцій: <code>map</code>, <code>flatMap</code>, <code>withFilter</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_6__code_for_code">23.6 Узагальнюючи <code>for</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки трансляція <code>for</code> виразів покладається тільки на присутність методів <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>, можливо застосувати <code>for</code> нотацію до широкого класу типів даних.</p></div>
<div class="paragraph"><p>Ви вже бачили <code>for</code> вирази на списках та масивах. Вони підтримуються, тому що списки, так само, як масиви, визначають операції <code>map</code>, <code>flatMap</code> та <code>withFilter</code>. Оскільки вони визначають також метод <code>foreach</code>, також можливі цикли <code>for</code> по ціх типах даних.</p></div>
<div class="paragraph"><p>Окрім списків та масивів, існує багато інших типів в стандартній бібліотеці Scala, які підтримують ті самі чотири методи, і, таким чином, дозволяють <code>for</code> вирази. Прикладами є диапазони, ітератори, потокі, і всі реалізації множин. Також чудово можливо для ваших власних типів даних підтримувати <code>for</code> вирази, через визначення потрібних методів. Для підтримки повного диапазону <code>for</code> виразів та <code>for</code> циклів, вам треба визначити <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, та <code>foreach</code> як методи вашого типу даних. Але також можливо визначити підмножину ціх методів, і таким чином підтримати підмножину всіх можливих <code>for</code> виразів або циклів.</p></div>
<div class="paragraph"><p>Ось точні правила:
* Якщо ваш тип визначає <code>map</code>, він дозволяє <code>for</code> виразам складатись з одного генератора.
* Якщо він визначає <code>flatMap</code> разом з <code>map</code>, це дозволяє <code>for</code> виразам складатись з декількох генераторів.
* Якщо він визначає <code>foreach</code>, він дозволяє цикли <code>for</code> (обоє, з одним та декількома генераторами).
* Якщо він визначає <code>withFilter</code>, він дозволяє вирази фільтрів, що починаються з <code>if</code> в <code>for</code> виразах.</p></div>
<div class="paragraph"><p>Трансляція <code>for</code> виразів відбувається перед перевіркою типів. Це дозволяє максимальну гнучкість, оскільки єдиною вимогою є те, щоб результат розширення <code>for</code> виразу проходив перевірку типів. Scala не визначає правил типів для самих <code>for</code> виразів, та не потребує, щоб методи <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, або <code>foreach</code> мали любу окрему сигнатуру типів.</p></div>
<div class="paragraph"><p>Тим не менше, існує типове налаштування, що захоплює найбільш загальні наміри методів вищого порядку, до яких тринслюється <code>for</code> вираз. Скажімо, ви маєте параметризований клас <code>C</code>, що типово буде стояти за деяким типом колекції. Тоді досить природно обрати наступні сигнатури типу для <code>map</code>, <code>flatMap</code>, <code>withFilter</code>, та <code>foreach</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тобто, функція <code>map</code> приймає функцію від типу елементу колекції <code>A</code> до якось іншого типу <code>B</code>. Він продукує нову колекцію того ж типу, що і <code>C</code>, але з <code>B</code> в якості типу елементів. Метод <code>flatMap</code> приймає функцію <code>f</code> від <code>A</code> до деякої <code>C</code>-колекції з <code>B</code>, та продукує <code>C</code>-колекцію з <code>B</code>. Метод <code>withFilter</code> приймає функцію предикат від типу елементів колекції <code>A</code> до <code>Boolean</code>. Він продукує колекцію того самого типу, на якому він викликаний. Нарешті, метод <code>foreach</code> приймає функцію від <code>A</code> до <code>Unit</code>, та продукує результат <code>Unit</code>:</p></div>
<div class="paragraph"><p>В класі <code>C</code> вище, метод <code>withFilter</code> продукує нову колекцію того самого класу. Це означає, що кожний виклик <code>withFilter</code> створює новий об'єкт <code>C</code>, так само, як має робити фільтр. Тепер, в трансляції <code>for</code> виразів, любі виклики до <code>withFilter</code> завжди закінчаться викликом до одного з трьох інших методів. Таким чином, об'єкт, створений <code>withFilter</code> буде розібраний по частинах одним з інших методів безпосередньо після цього. Якщо об'єкти класу <code>C</code> великі (подумайте про великі послідовності), ви можете побажати уникнути створення такого проміжного об'єкту. Стандартним прийомом є дозволити <code>withFilter</code> повертати на об'єкт <code>C</code>, але тільки об'єкт огортку, що "пам'ятає", що елементи треба відсортувати перед подальшою обробкою.</p></div>
<div class="paragraph"><p>Концентруючись на трьох перших функціях класу <code>C</code> слід зауважити наступні факти. В функціональному програмуванні існує загальна концепція з назвою <em>монада</em>, що може пояснювати велике число типів з обчисленнями, від колекцій до обчислень зі станом та I/O, обчислення зворотнього виводу та транзакції, як для прикладу. Ви можете формулювати функції <code>map</code>, <code>flatMap</code>, та <code>withFilter</code> на монаді, та, якщо ви зробите це, вони в підсумку матимуть точно вказані тут типи.</p></div>
<div class="paragraph"><p>Більше того, ви можете характеризувати кожну монаду через <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>, плюс "юніт" конструктор, що продукує монаду зі значення елемента. В об'єктно-орієнтовній мові цей "юніт" є простим конструктором примірника, або методом фабрики. Таким чином на <code>map</code>, <code>flatMap</code>, та <code>withFilter</code> можна дивитись як на об'єктно-орієнтовну версію функціональної концепції монади. Оскільки <code>for</code> вирази еквівалентні до застосувань ціх трьох методів, вони можуть розглядатись як синтаксис для монад.</p></div>
<div class="paragraph"><p>Все це натякає, що концепція <code>for</code> виразів більш загальна, ніж проста ітерація по колекції, і це дійсно так. Наприклад, <code>for</code> вирази також відіграють важливу роль в асинхронному I/O, або як альтернативна нотація для опціональних значень. Шукайте в бібліотеках Scala де зустрічаються <code>map</code>, <code>flatMap</code>, та <code>withFilter</code> — коли вони присутні, <code>for</code> вирази запропонують себе самі, як стислий спосіб маніпуляції елементами цього типу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_7_">23.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви отримали можливість заглянути з лаштунки виразів <code>for</code> та циклів <code>for</code>. Ви вивчили, що вони транслюються в застосування стандартного набору методів вищого порядку. Як результат, ви побачили, що <code>for</code> вирази насправді значно більш загальні, ніж прості ітерації по колекціях, і що ви можете розробляти ваші власні класи для їх підтримки.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-23 12:50:32 EET
</div>
</div>
</body>
</html>

