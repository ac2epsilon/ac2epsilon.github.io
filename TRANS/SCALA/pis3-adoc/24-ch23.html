<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__23">Глава 23</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____code_for_code">Ще раз про вирази <code>for</code></h1>
<div class="paragraph"><p>Глава 16 продемонструвала, що функції вищих порядків, такі як <code>map</code>, <code>flatMap</code>, та <code>filter</code>, провадять потужні конструкції для роботи зі списками. Але іноді рівень абстракції, що потребують ці функції, робить програми трохи складними для розуміння.</p></div>
<div class="paragraph"><p>Ось приклад. Скажімо, ви отримали список людей, кожний визначений як примірник класу  <code>Person</code>. Клас <code>Person</code> має поля, де вказані ім'я, стать, та перелік дітей.</p></div>
<div class="paragraph"><p>Ось визначення класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
                         <span class="n">isMale</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">,</span>
                         <span class="n">children</span><span class="k">:</span> <span class="kt">Person*</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад декількох записів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lara</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Lara&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>
<span class="k">val</span> <span class="n">bob</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
<span class="k">val</span> <span class="n">julie</span> <span class="k">=</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Julie&quot;</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">)</span>
<span class="k">val</span> <span class="n">persons</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">lara</span><span class="o">,</span> <span class="n">bob</span><span class="o">,</span> <span class="n">julie</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, скажімо, ми бажаємо знайти всі пари імен матерів та їх дітей в цьому списку. Використовуючи <code>map</code>, <code>flatMap</code> та <code>filter</code> ви можете зформулювати наступний запит:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">filter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
            <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете трохи оптимізувати цей приклад, використавши виклик <code>withFilter</code> замість <code>filter</code>. Це дозволить уникнути створення проміжної структури даних для жінок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">children</span> <span class="n">map</span> <span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">))))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці запити роблять свою роботу, але вони не дуже тривіальні для написання та розуміння. Чи є простіший спосіб? Фактично, так. Згадайте вирази <code>for</code> в Розділі 7.3? Використовуючи вирази <code>for</code>, той самий приклад може бути записаний наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="k">if</span> <span class="o">!</span><span class="n">p</span><span class="o">.</span><span class="n">isMale</span><span class="o">;</span> <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">p</span><span class="o">.</span><span class="n">children</span><span class="o">)</span>
      <span class="k">yield</span> <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Lara</span><span class="o">),</span>
    <span class="o">(</span><span class="nc">Julie</span><span class="o">,</span><span class="nc">Bob</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Результат цього виразу точно такий самий, що і результат попереднього виразу. Більше того, більшість читачів коду вірогідно знайде, що вирази <code>for</code> значно ясніші, ніж попередні запити, що використовують функції вищих порядків, <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>.</p></div>
<div class="paragraph"><p>Однак, останні два запити не настільки різноманітні, як може виглядати. Фактично, з'ясовується, що компілятор Scala буде транслювати другий запит в перший. Більш загально, всі вирази <code>for</code>, що видають результат, транслюються компілятором в комбінації викликів методів вищого порядку, <code>map</code>, <code>flatMap</code>, та <code>withFilter</code>. Всі <code>for</code> цикли без <code>yield</code> транслюються в меньший набір функцій вищого порядку: тільки <code>withFilter</code> та <code>foreach</code>.</p></div>
<div class="paragraph"><p>В цій главі ви з'ясуєте для початку щодо точних правил написання виразів. Після цього ви побачите, як вони можуть зробити комбінаторні проблеми простішими для вирішення. Нарешті, ви вивчите, як транслюються <code>for</code> вирази, і як результат, <code>for</code> вирази можуть допомогти вам "виростити" мову Scala в нових доменах застосування.</p></div>
<div class="sect1">
<h2 id="_23_1__code_for_code">23.1 Вирази <code>for</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Загалом, <code>for</code> вираз має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span> <span class="n">seq</span> <span class="o">)</span> <span class="k">yield</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>seq</code> є послідовність генераторів, визначень та фільтрів, розділені крапкою з комою між послідовними елементами. Приклад для <code>for</code> виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">))</span>
<span class="k">yield</span> <span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей <code>for</code> вираз містить один генератор, одне визначення та один фільтр. Як зазначалось в Розділі 7.3, ви також можете оточити послідовність в фігурні дужки замість звичайних. Тоді крапки з комою стають опціональними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">{</span>
  <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span>           <span class="c1">// генератор</span>
  <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>             <span class="c1">// визначення</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">&quot;To&quot;</span><span class="o">)</span> <span class="c1">// фільтр</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p>Генератор має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>expr</code> типово повертає список, навіть якщо, як ви побачите пізніше, це може бути узагальнено. Шаблон <code>pat</code> співпадає один-до-одного з усіма елементами цього списку. Якщо співпадіння успішне, змінні в шаблоні прив'язуються до відповідних частин елементу, в той самий спосіб, як описане в Главі 15. Але якщо співпадіння схибить, виключення <code>MatchError</code> не виникне. Замість цього елемент просто відкидається з ітерації.</p></div>
<div class="paragraph"><p>В самому загальному випадку шаблон <code>pat</code> є тільки змінна <code>x</code>, як в <code>x &lt;- expr</code>. В цьому випадку змінна <code>x</code> просто ітерує по всіх елементах, що повертає <code>expr</code>.</p></div>
<div class="paragraph"><p>Визначення має форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pat</span> <span class="k">=</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення прив'язує шаблон <code>pat</code> до значення <code>expr</code>, так що це має той самий ефект, що і визначення <code>val</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний випадок знову коли шаблон є простою змінною <code>x</code> (тобто, <code>x = expr</code>). Це визначає <code>x</code> як ім'я для значення <code>expr</code>.</p></div>
<div class="paragraph"><p>Фільтр має таку форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>expr</code> є вираз типу <code>Boolean</code>. Фільтр відкидає з ітерації всі елементи, для яких <code>expr</code> повертає <code>false</code>.</p></div>
<div class="paragraph"><p>Кожний <code>for</code> вираз починається з генератора. Якщо є декілька генераторів в виразі <code>for</code>, пізніші генератори змінюються більш швидко, ніж ранішні. Ви можете просто це перевірити за допомогою наступного простого тесту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">))</span>
        <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span><span class="n">one</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">two</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">one</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">two</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_2__n_">23.2 Проблема N ферзів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Особливо придатною областю застосування <code>for</code> виразів є комбінаторні головоломки. Прикладом такої головоломки є проблема 8-ми ферзів: маючи стандартну шахову дошку, розмістити вісім ферзів, так, щоб жодний не шахував іншого (ферзь шахує іншу фігуру, якщо стоїть на тому самому рядку, лінії або диагоналі). Щоб знайти рішення цієї проблеми, насправді легше узагальнити її для шахових дошок довільного розміру. Таким чином, проблема є розмістити N ферзів на шахівниці з <code>N x N</code> клітин, де розмір <code>N</code> довільний. Ми почнемо нумерування клітин з одного, так що верхня-ліва клітина на дошці <code>N x N</code> має координати <code>(1, 1)</code>, та нижня-права клітина має координати <code>(N, N)</code>.</p></div>
<div class="paragraph"><p>Щоб вирішити проблему <code>N</code> ферзів, зауважте, що вам треба розмістити ферзя на кожному рядку. Так що ви можете ставити ферзів в послідовних рядках, кожний раз перевіряючи, що новий розміщений ферзь не шахується жодним іншим ферзем, що вже на дошці. По ходу цього пошуку, може статись, що ферзь, який треба поставити на рядок <code>k</code>, шахується у всіх полях цього рядка з ферзями на рядках від <code>1</code> до <code>k-1</code>. В цьому випадку вам треба перервати цю частину пошуку, щоб продовжити з іншою конфігурацією ферзів в стовпчиках від <code>1</code> до <code>k-1</code>.</p></div>
<div class="paragraph"><p>Імперативне рішення цієї проблеми буде ставити ферзів один по одному, рухаючи їх по дошці. Але це виглядає складним запропонувати схему, що насправді спробує всі можливості. Більш функціональний підхід представляє рішення напряму, як значення. Рішення складається зі списку координат, по одній для кожного ферзя на дошці. Однак занотуйте, що повне рішення не може бути знайдене за один крок. Рішення має бути побудоване поступово, через захоплення послідовних рядків ферзями.</p></div>
<div class="paragraph"><p>Це підказує рекурсивний алгоритм. Уявімо, що ви вже згенерували всі рішення, розмістивши  <code>k</code> ферзів на дошці розміром <code>N x N</code>, до <code>k</code> меньше ніж <code>N</code>. Кожне таке рішення може бути презентовано як список довжиною <code>k</code> координат <code>(row, column)</code>, де обидва, <code>row</code> та <code>column</code> є числами в диапазоні від <code>1</code> до <code>N</code>. Зручно розглядати ці часткові списки рішень як стеки, де координати ферзя на рядку <code>k</code> ідуть першими в списку, за яким ідуть координати ферзя в рядку <code>k-1</code>, і так далі. Знизу стека є координати ферзя, розміщеного на першому рядку дошки. Всі рішення разом представлені як список списків, з одним елементом для кожного ферзя.</p></div>
<div class="paragraph"><p>Тепер, щоб поставити наступного ферзя в рядок <code>k+1</code>, згенеруйте всі можливі розширення кожного попереднього рішення ще на одного ферзя. Це дає інший список рішень, на цей раз довжини <code>k+1</code>. Продовжуйте процес доки ви не отримаєте всі рішення розміру шахівниці N.</p></div>
<div class="paragraph"><p>Ця алгоритмична ідея втілена в функціональне <code>placeQueens</code> нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">queens</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
    <span class="k">else</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">queens</span> <span class="k">&lt;-</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
        <span class="n">column</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
        <span class="n">queen</span> <span class="k">=</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
        <span class="k">if</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">queens</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">queen</span> <span class="o">::</span> <span class="n">queens</span>

  <span class="n">placeQueens</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зовнішня функція <code>queens</code> в програмі вище просто викликає <code>placeQueens</code> з розміром дошки <code>n</code> в якості аргумента. Завдання функції <code>placeQueens(k)</code> є генерація всіх часткових рішень довжини <code>k</code> в списку. Кожний елемент списку є одним рішенням, представлений списком довжини <code>k</code>. Так що <code>placeQueens</code> повертає список списків.</p></div>
<div class="paragraph"><p>Якщо параметр <code>k</code> до <code>placeQueens</code> є <code>0</code>, це означає, що треба згенерувати всі рішення, розмістивши нуль ферзів на нулі рядків. Існує тільки одне таке рішення: не розташовувати ферзів взагалі. Це рішення представлене порожнім списком. Так що якщо <code>k</code> є нуль,<code>placeQueens</code> повертає <code>List(List())</code>, список складається з єдиного елемента, що є порожнім списком. Зауважте, що це доволі відрізняється від порожнього списку <code>List()</code>.</p></div>
<div class="paragraph"><p>Якщо <code>placeQueens</code> повертає <code>List()</code>, це означає відсутність рішень, замість єдиного рішення, що складається з відсутності розміщених ферзів.</p></div>
<div class="paragraph"><p>В іншому випадку, коли <code>k</code> не нуль, вся робота <code>placeQueens</code> виконується в <code>for</code> виразі. Перший генератор цього <code>for</code> виразу ітерує по всіх рішеннях, розміщуючи <code>k - 1</code> ферзів на дошці. Другий генератор ітерує по всіх можливих стовпчиках, на яких може бути розміщений  <code>k</code>-тий ферзь. Третя частина <code>for</code> виразу визначає новітньо розглянуту позицію ферзя, що буде парою з рядка <code>k</code> та кожного стовпчика. Четверта частина виразу <code>for</code> є фільтром, що перевіряє за допомогою <code>isSafe</code>, чи новий ферзь є вільний від шаху всіма існуючими ферзями (визначення <code>isSafe</code> буде розглянута трохи пізніше).</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Якщо новий ферзь не має шахів від жодного з інших ферзів, він може формувати частину часткового рішення, так що <code>placeQueens</code> генерує нове рішення за допомогою `queen 
</dt>
<dd>
<p>
queens`. Якщо новий ферзь не вільний від шаху, фільтр повертає <code>false</code>, так що рішення не генерується.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Один фрагмент, що залишився, це метод <code>isSafe</code>, що використовується для перевірки, чи даний ферзь шахується любим іншим елементом в списку ферзів. Ось його визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=</span>
  <span class="n">queens</span> <span class="n">forall</span> <span class="o">(</span><span class="n">q</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">inCheck</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">q</span><span class="o">))</span>

<span class="k">def</span> <span class="n">inCheck</span><span class="o">(</span><span class="n">q1</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">q2</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span> <span class="o">||</span> <span class="c1">// той самий рядок</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span> <span class="o">||</span> <span class="c1">// той самий стовпчик</span>
  <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span><span class="o">).</span><span class="n">abs</span> <span class="o">==</span> <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">abs</span> <span class="c1">// на диагоналі</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>isSafe</code> виражає, що ферзь безпечний у відношенні до інших ферзів, якщо він не шахується іншим ферзем. Метод <code>inCheck</code> виражає, що ферзі <code>q1</code> та <code>q2</code> взаємно шахуються. Він повертає <code>true</code> в одному з трьох випадків:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Якщо два ферзя мають ту саму координату рядка,
</p>
</li>
<li>
<p>
Якщо два ферзя мають ту саму координату стовбчика,
</p>
</li>
<li>
<p>
Якщо два ферзя на тій самій диагоналі (тобто, різниця між рядками і різниця між стовпчиками ті самі).
</p>
</li>
</ol></div>
<div class="paragraph"><p>Перший випадок, коли два ферзя мають ту саму координату, не може трапитись в застосуванні, бо <code>placeQueens</code> вже потурбувався про розіщення кожного ферзя на окремому рядку. Так що ви можете видалити цю перевірку без зміни функціональності програми.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_3____code_for_code_">23.3 Запити за допомогою <code>for</code> виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>The for notation is essentially equivalent to common operations of database query languages. For instance, say you are given a database named books, represented as a list of books, whereBook is defined as follows:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Here is a small example database represented as an in-memory list:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Structure and Interpretation of Computer Programs&quot;</span><span class="o">,</span>
      <span class="s">&quot;Abelson, Harold&quot;</span><span class="o">,</span> <span class="s">&quot;Sussman, Gerald J.&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Principles of Compiler Design&quot;</span><span class="o">,</span>
      <span class="s">&quot;Aho, Alfred&quot;</span><span class="o">,</span> <span class="s">&quot;Ullman, Jeffrey&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Programming in Modula-2&quot;</span><span class="o">,</span>
      <span class="s">&quot;Wirth, Niklaus&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;Elements of ML Programming&quot;</span><span class="o">,</span>
      <span class="s">&quot;Ullman, Jeffrey&quot;</span>
    <span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">&quot;The Java Language Specification&quot;</span><span class="o">,</span> <span class="s">&quot;Gosling, James&quot;</span><span class="o">,</span>
      <span class="s">&quot;Joy, Bill&quot;</span><span class="o">,</span> <span class="s">&quot;Steele, Guy&quot;</span><span class="o">,</span> <span class="s">&quot;Bracha, Gilad&quot;</span>
    <span class="o">)</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>To find the titles of all books whose author&#8217;s last name is "Gosling":</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">b</span><span class="o">.</span><span class="n">authors</span>
            <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">&quot;Gosling&quot;</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">The</span> <span class="nc">Java</span> <span class="nc">Language</span> <span class="nc">Specification</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Or to find the titles of all books that have the string "Program" in their title:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">title</span> <span class="n">indexOf</span> <span class="s">&quot;Program&quot;</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Structure</span> <span class="n">and</span> <span class="nc">Interpretation</span> <span class="n">of</span>
  <span class="nc">Computer</span> <span class="nc">Programs</span><span class="o">,</span> <span class="nc">Programming</span> <span class="n">in</span> <span class="nc">Modula</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="nc">Elements</span> <span class="n">of</span> <span class="nc">ML</span>
    <span class="nc">Programming</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Or to find the names of all authors who have written at least two books in the database:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
           <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
       <span class="k">yield</span> <span class="n">a1</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">,</span> <span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The last solution is still not perfect because authors will appear several times in the list of results. You still need to remove duplicate authors from result lists. This can be achieved with the following function:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">removeDuplicates</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">xs</span>
         <span class="k">else</span>
           <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
             <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="n">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
           <span class="o">)</span>
       <span class="o">}</span>
<span class="n">removeDuplicates</span><span class="k">:</span> <span class="err">[</span><span class="kt">A</span><span class="err">]</span><span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">removeDuplicates</span><span class="o">(</span><span class="n">res6</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Ullman</span><span class="o">,</span> <span class="nc">Jeffrey</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>It&#8217;s worth noting that the last expression in method removeDuplicates can be equivalently expressed using a for expression:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span>
<span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_4__code_for_code_">23.4 Трансляція <code>for</code> виразів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Every for expression can be expressed in terms of the three higher-order functions map,flatMap, and withFilter. This section describes the translation scheme, which is also used by the Scala compiler.</p></div>
<div class="sect2">
<h3 id="__code_for_code___">Трансляція <code>for</code> виразів одним генератором</h3>
<div class="paragraph"><p>First, assume you have a simple for expression:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>where x is a variable. Such an expression is translated to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_for_code______">Трансляція <code>for</code> виразів починаючи з генератора та фільтра</h3>
<div class="paragraph"><p>Now, consider for expressions that combine a leading generator with some other elements.</p></div>
<div class="paragraph"><p>Afor expression of the form:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>is translated to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">))</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>This translation gives another for expression that is shorter by one element than the original, because an if element is transformed into an application of withFilter on the first generator expression. The translation then continues with this second expression, so in the end you obtain:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The same translation scheme also applies if there are further elements following the filter. Ifseq is an arbitrary sequence of generators, definitions, and filters, then:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>is translated to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span> <span class="n">withFilter</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Then translation continues with the second expression, which is again shorter by one element than the original one.</p></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_____">Трансляція <code>for</code> виразів починаючи з двох генераторів</h3>
<div class="paragraph"><p>The next case handles for expressions that start with two generators, as in:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Again, assume that seq is an arbitrary sequence of generators, definitions, and filters. In fact,seq might also be empty, and in that case there would not be a semicolon after expr_2. The translation scheme stays the same in each case. The for expression above is translated to an application of flatMap:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>This time, there is another for expression in the function value passed to flatMap. That forexpression (which is again simpler by one element than the original) is in turn translated with the same rules. The three translation schemes given so far are sufficient to translate all for expressions that contain just generators and filters, and where generators bind only simple variables. Take, for instance, the query, "find all authors who have published at least two books," from Section 23.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
  <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">a1</span>
</pre></div></div></div>
<div class="paragraph"><p>This query translates to the following map/flatMap/filter combination:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">books</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b1</span> <span class="k">=&gt;</span>
  <span class="n">books</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">authors</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">a1</span> <span class="k">=&gt;</span>
      <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span>
        <span class="n">a1</span><span class="o">))))</span>
</pre></div></div></div>
<div class="paragraph"><p>The translation scheme presented so far does not yet handle generators that bind whole patterns instead of simple variables. It also does not yet cover definitions. These two aspects will be explained in the next two sub-sections.</p></div>
</div>
<div class="sect2">
<h3 id="____">Трансляція шаблонів в генераторах</h3>
<div class="paragraph"><p>The translation scheme becomes more complicated if the left hand side of generator is a pattern, pat, other than a simple variable. The case where the for expression binds a tuple of variables is still relatively easy to handle. In that case, almost the same scheme as for single variables applies.</p></div>
<div class="paragraph"><p>A for expression of the form:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">((</span><span class="kc">null</span><span class="o">,</span> <span class="o">...,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>translates to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="o">...,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">expr_2</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Things become a bit more involved if the left hand side of the generator is an arbitrary pattern pat instead of a single variable or a tuple.</p></div>
<div class="paragraph"><p>In this case:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_2</span>
</pre></div></div></div>
<div class="paragraph"><p>translates to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span> <span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">expr_2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>That is, the generated items are first filtered and only those that match pat are mapped. Therefore, it&#8217;s guaranteed that a pattern-matching generator will never throw a MatchError.</p></div>
<div class="paragraph"><p>The scheme here only treated the case where the for expression contains a single pattern-matching generator. Analogous rules apply if the for expression contains other generators, filters or definitions. Because these additional rules don&#8217;t add much new insight, they are omitted from discussion here. If you are interested, you can look them up in the Scala Language Specification [Ode11].</p></div>
</div>
<div class="sect2">
<h3 id="__">Трансляція визначень</h3>
<div class="paragraph"><p>The last missing situation is where a for expression contains embedded definitions. Here&#8217;s a typical case:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="kc">null</span> <span class="k">=</span> <span class="n">expr_2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>Assume again that seq is a (possibly empty) sequence of generators, definitions, and filters. This expression is translated to this one:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">((</span><span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="n">expr_2</span><span class="o">);</span> <span class="n">seq</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">expr_3</span>
</pre></div></div></div>
<div class="paragraph"><p>So you see that expr_2 is evaluated each time there is a new x value being generated. This re-evaluation is necessary because expr_2 might refer to x and so needs to be re-evaluated for changing values of x. For you as a programmer, the conclusion is that it&#8217;s probably not a good idea to have definitions embedded in for expressions that do not refer to variables bound by some preceding generator, because re-evaluating such expressions would be wasteful. For instance, instead of:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>it&#8217;s usually better to write:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_for_code_">Транслювання <code>for</code> циклів</h3>
<div class="paragraph"><p>The previous subsections showed how for expressions that contain a yield are translated.What about for loops that simply perform a side effect without returning anything? Their translation is similar, but simpler than for expressions. In principle, wherever the previous translation scheme used a map or a flatMap in the translation, the translation scheme for forloops uses just a foreach.</p></div>
<div class="paragraph"><p>For instance, the expression:for (null &#8592; expr_1) body translates to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>A larger example is the expression:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_1</span><span class="o">;</span> <span class="k">if</span> <span class="n">expr_2</span><span class="o">;</span> <span class="kc">null</span> <span class="k">&lt;-</span> <span class="n">expr_3</span><span class="o">)</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p>This expression translates to:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr_1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">expr_2</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span>
<span class="n">expr_3</span> <span class="n">foreach</span> <span class="o">(</span><span class="kc">null</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>For example, the following expression sums up all elements of a matrix represented as a list of lists:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">xs</span> <span class="k">&lt;-</span> <span class="n">xss</span><span class="o">;</span> <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>This loop is translated into two nested foreach applications:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">xss</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">xs</span> <span class="k">=&gt;</span>
    <span class="n">xs</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_23_5____">23.5 Заходячи з іншого боку</h2>
<div class="sectionbody">
<div class="paragraph"><p>The previous section showed that for expressions can be translated into applications of the higher-order functions map, flatMap, and withFilter. In fact, you could equally go the other way: Every application of a map, flatMap, or filter can be represented as a for expression.</p></div>
<div class="paragraph"><p>Here are implementations of the three methods in terms of for expressions. The methods are contained in an object Demo to distinguish them from the standard operations on Lists. To be concrete, the three functions all take a List as parameter, but the translation scheme would work just as well with other collection types:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="k">yield</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>

  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="k">if</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Not surprisingly, the translation of the for expression used in the body of Demo.map will produce a call to map in class List. Similarly, Demo.flatMap and Demo.filter translate to flatMap andwithFilter in class List. So this little demonstration shows that for expressions really are equivalent in their expressiveness to applications of the three functions map, flatMap, andwithFilter.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_6__code_for_code">23.6 Узагальнюючи <code>for</code></h2>
<div class="sectionbody">
<div class="paragraph"><p>Because the translation of for expressions only relies on the presence of methods map, flatMap, and withFilter, it is possible to apply the for notation to a large class of data types.</p></div>
<div class="paragraph"><p>You have already seen for expressions over lists and arrays. These are supported because lists, as well as arrays, define operations map, flatMap, and withFilter. Because they define aforeach method as well, for loops over these data types are also possible.</p></div>
<div class="paragraph"><p>Besides lists and arrays, there are many other types in the Scala standard library that support the same four methods and therefore allow for expressions. Examples are ranges, iterators, streams, and all implementations of sets. It&#8217;s also perfectly possible for your own data types to support for expressions by defining the necessary methods. To support the full range of forexpressions and for loops, you need to define map, flatMap, withFilter, and foreach as methods of your data type. But it&#8217;s also possible to define a subset of these methods, and thereby support a subset of all possible for expressions or loops.</p></div>
<div class="paragraph"><p>Here are the precise rules:
* If your type defines just map, it allows for expressions consisting of a single generator.
* If it defines flatMap as well as map, it allows for expressions consisting of several generators.
* If it defines foreach, it allows for loops (both with single and multiple generators).
* If it defines withFilter, it allows for filter expressions starting with an if in the for expression.</p></div>
<div class="paragraph"><p>The translation of for expressions happens before type checking. This allows for maximum flexibility because the only requirement is that the result of expanding a for expression type checks. Scala defines no typing rules for the for expressions themselves, and does not require that methods map, flatMap, withFilter, or foreach have any particular type signatures.</p></div>
<div class="paragraph"><p>Nevertheless, there is a typical setup that captures the most common intention of the higher order methods to which for expressions translate. Say you have a parameterized class, C, which typically would stand for some sort of collection. Then it&#8217;s quite natural to pick the following type signatures for map, flatMap, withFilter, and foreach:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>That is, the map function takes a function from the collection&#8217;s element type A to some other type B. It produces a new collection of the same kind C, but with B as the element type. TheflatMap method takes a function f from A to some C-collection of Bs and produces a C-collection of Bs. The withFilter method takes a predicate function from the collection&#8217;s element type A toBoolean. It produces a collection of the same type as the one on which it is invoked. Finally, theforeach method takes a function from A to Unit and produces a Unit result:</p></div>
<div class="paragraph"><p>In class C above, the withFilter method produces a new collection of the same class. That means that every invocation of withFilter creates a new C object, just the same as filter would work. Now, in the translation of for expressions, any calls to withFilter are always followed by calls to one of the other three methods. Therefore, the object created by withFilter will be taken apart by one of the other methods immediately afterwards. If objects of class C are large (think long sequences), you might want to avoid the creation of such an intermediate object. A standard technique is to let withFilter return not a C object but just a wrapper object that "remembers" that elements need to be filtered before being processed further.</p></div>
<div class="paragraph"><p>Concentrating on just the first three functions of class C, the following facts are noteworthy. In functional programming, there&#8217;s a general concept called a monad, which can explain a large number of types with computations, ranging from collections, to computations with state and I/O, backtracking computations, and transactions, to name a few. You can formulate functions map, flatMap, and withFilter on a monad, and, if you do, they end up having exactly the types given here.</p></div>
<div class="paragraph"><p>Furthermore, you can characterize every monad by map, flatMap, and withFilter, plus a "unit" constructor that produces a monad from an element value. In an object-oriented language, this "unit" constructor is simply an instance constructor or a factory method. Therefore, map,flatMap, and withFilter can be seen as an object-oriented version of the functional concept of monad. Because for expressions are equivalent to applications of these three methods, they can be seen as syntax for monads.</p></div>
<div class="paragraph"><p>All this suggests that the concept of for expression is more general than just iteration over a collection, and indeed it is. For instance, for expressions also play an important role in asynchronous I/O, or as an alternative notation for optional values. Watch out in the Scala libraries for occurrences of map, flatMap, and withFilter—when they are present, for expressions suggest themselves as a concise way of manipulating elements of the type.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_23_7_">23.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви отримали можливість заглянути з лаштунки виразів <code>for</code> та циклів <code>for</code>. Ви вивчили, що вони транслюються в застосування стандартного набору методів вищого порядку. Як результат, ви побачили, що <code>for</code> вирази насправді значно більш загальні, ніж прості ітерації по колекціях, і що ви можете розробляти ваші власні класи для їх підтримки.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-15 13:22:18 EET
</div>
</div>
</body>
</html>
