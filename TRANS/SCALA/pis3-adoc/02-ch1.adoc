:ascii-ids:
:doctype: book
:source-highlighter: pygments

Глава 1
-------

Маштабована мова
================
Ім'я Scala означає "scalable language", тобто маштабована мова. Мова названа так, оскільки вона була розроблена зростати разом з потребами своїх користувачів. Ви можете застосувати Scala до широкого диапазону програмних завдань, від написання невеликіх скриптів, до побудови великих систем.footnote:[Scala вимовляється skah-lah.]

До Scala легко дістатись. Вона працює на стандартній Java платформі, та без проблем взаємодіє з усіма бібліотеками Java. Це досить гарна мова для напсання скриптів, що стягають разом Java компоненти. Але вона може застосувати свою потужність навіть більше для побудови великих систем та фреймворків реюзабельних компонент.

Технічно Scala є сумішшю об'єктно-орієнтованих та функціональних програмних концепцій в статично типізованій мові. Зплав об'єктно-орієнтовного та функціонального програмування виявляється в багатьох різних аспектах Scala; воно, можливо, більш проникаюче, ніж в любій іншій широко уживаній мові. Два стилі програмування мають доповнюючі сильні сторони, коли доходить до маштабованості. Функціональні програмні конструкції Scala роблять простим будувати цікаві речі швидко, з простих частин. Її об'єктно-орієнтовні конструкції спрощують структурувати більші системи, та адаптувати їх до нових вимог. Комбінація двох стилів в Scala робить можливим виражати нові типи програмних шаблонів та компонентних абстракцій. Це також призводить до виразного та стислого стилю програмування. Та оскільки вона така піддатлива, програмування на Scala може бути дуже втішним.

Ця початкова глава відповідає на запитання "чому Scala?". Вона дає високорівневий погляд на дизайн Scala та міркування позаду неї. Після читання глави ви повинні мати базове відчуття того, що таке є Scala, та які типи задач вона може допомогти виконати. Хоча ця книжка є туторіалом в Scala, ця глава насправді не є частиною туторіала. Якщо вам нетерпляче хочеться почати писати деякий Scala код, вам слідує перестрибнути далі до Глави 2.

1.1 Мова, що зростає разом з вами
---------------------------------
Програми різного розміру схильні потребувати різних програмних конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:
[source,scala]
----
var capital = Map("US" -> "Washington", "France" -> "Paris")
capital += ("Japan" -> "Tokyo")
println(capital("France"))
----
Ця програма встановлює мапу з країн та їх столиць, модифікує мапу, додаючи нову прив'язку ("Japan" -> "Tokyo"), та друкує столицю, що асоційована з країною France.footnote:[Будь ласка, слідуйте за нами, якщо ви не розумієте всі деталі цієї програми. Вони будуть пояснені в наступних двох главах.] Нотація в цьому прикладі високорівнева, до діла, та не захаращена зайвими крапками з комою або анотаціями типів. Дійсно, відчувається що це сучасна "скриптова" мова, Perl, Python, або Ruby. Одна загальна характеристика ціх мов, що має відношення до приклада вище, в тому, що всі вони підтримують конструкцію "асоціативної мапи" в синтаксисі мови.

Асоциативні мапи дуже корисні, оскільки вони дозволяють утримувати програми чіткими та лаконічними, але іноді ви можете не погодитись з їх філософією "один розмір підходить всім", оскільки вам треба контролювати властивості мап, які ви використовуваєте в вашій програмі, в більше гарно-контрольований спосіб. Scala надає вам цей гарний контроль, якщо ви потребуєте його, оскільки мапи в Scala не є синтаксисом мови. Вони є бібліотечними абстракціями, які ви можете розширити та адаптувати.

В програмі вище ви отримали реалізацію Map по замовчанню, але ви можете легко змінити це. Ви можете, наприклад, вказати окрему реалізацію, таку як HashMap або TreeMap, або визвати метод `par` що отримати `ParMap`, що виконує операції паралельно. Ви можете вказати значення по замовчанню для мапи, або ви можете переписати любий інший метод мапи, яку ви створюєте. В кожному випадку, ви можете використовувати той самий простий синтаксис доступу для мап, що і в прикладі вище.

Цей приклад показує, що Scala дати вам обоє, зручність та гнучкість. Scala має набір зручних конструкцій, що допомагають вам стартовати швидко, та дозволяють вам програмувати в приємно стислому стилі. В той же час, ви маєте впевненість, що ви не переростете мову. Ви завжди можете підкроїти програму до ваших потреб, оскільки все базується на бібліотечних модулях, які ви можете обрати та адаптувати, якщо треба.

Вирощування нових типів
~~~~~~~~~~~~~~~~~~~~~~~

Eric Raymond ввів собор та базар як дві метафори софтверної розробки.footnote:[Raymond, The Cathedral and the Bazaar. [Ray99\]] Собор майже досконала будівля, що займає довгий час доки збудується. Коли вже побудований, він стоїть незмінний довгий час. На відміну від цього базар адаптується та розширюється кожного дня, людьми, що роблять на ньому. В роботі Raymond базар є метафорою розробки програм з відкритим кодом. Guy Steele зауважив в розмові про "зростаючу мову", що ту саму різницю можна застосувати до дизайна мови.footnote:[Steele, Growing a language. [Ste99\]] Scala є значно більше базаром, ніж собором, в сміслі, що вона розроблена бути розширеною та адаптованою людьми, що програмують на ній. Заміть провадити всі конструкції, що можуть будь-коли вам знадобитись в "досконало повній мові", Scala покладає в ваші руки інструменти для побудови таких конструкцій. 

Ось приклад. Багато застосувань потребують тип цілих, що може стати довільно великим без переповнення або "циклічного переносу" арифметичних операцій. Scala визначає такий тип в бібліотечному класі scala.BigInt. Ось визначення метода, що використовує цей тип, що обчислює факторіал переданого цілого значення:footnote:[factorial(x), або в математичній нотації x!, є результатом обчислення 1 * 2 * ... * x, де 0! визначене як 1.]
[source,scala]
----
def factorial(x: BigInt): BigInt =
if (x == 0) 1 else x * factorial(x - 1)
----
Тепер, якщо ми викличемо `factorial(30)`, ви отримаєте:
[source,scala]
----
265252859812191058636308480000000
----
BigInt виглядає як вбудований тип, оскільки ви можете використовувати цілі літерали та оператори, як * та - зі значеннями цього типу. Але це все ще клас, що визначений в стандартній бібліотеці.footnote:[Scala іде зі стандартною бібліотекою, дещо з якої буде показане в цій книжці. Для додаткової інформації ви можете звернутись до документації Scaladoc по бібліотеці, що доступна в дистрибутиві та онлайн http://www.scala-lang.org.] Якщо клас був би відсутній, було б прямолінійним для кожного програміста Scala написати реалізацію, наприклад, через огортання Java класу java.math.BigInteger (фактично, саме так реалізований клас Scala).

Звичайно, ви можете використовувати клас Java напряму. Але результат і близько не такий приємний, бо хоча Java дозволяє вам створювати нові типи, ці типи не дуже виглядають як природна підтримка мови:
[source,scala]
----
import java.math.BigInteger
def factorial(x: BigInteger): BigInteger =
  if (x == BigInteger.ZERO)
    BigInteger.ONE
  else
    x.multiply(factorial(x.subtract(BigInteger.ONE)))
----
BigInt є представником багатьох інших число-подібних типів - великих десятичних, комплексних чисел, раціональних чисел, довірчих інтервалів, поліноміалів - список продовжується. Деякі мови програмування реалізують деяки з ціх типів природно. Наприклад, Lisp, Haskell та Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але кожна мова, що намагається реалізувати всі з ціх абструкцій одночасно, просто стане дуже великою, щоб бути керованою. Що ще більше, навіть якщо б така мова могла б існувати, деякі застосування напевно могли б отримати переваги від інших число-подібних типів, що не були включені. Так що спроба запровадити все в одній мові маштабується не дуже добре. Замість цього Scala дозволяє користувачам вирощувати та адаптувати мову в напрямках, які ї потрібні, визначаючи прості-в-використанні бібліотеки, що виглядають як природна підтримка мови.

Вирощування нових керуючих структур
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Попередній приклад демонструє, що Scala дозвляє вам додавати нові типи, що можуть бути такі ж зручні в використанні, що і вбудовані типи. Той же принцип розширення також стосується до керуючих структур. Цей різновид розширюваності ілюстрований Akka, Scala API до "актор-базованого" конкурентного програмування.

По мірі того, як багатоядерні процесори будуть продовжувати розмножуватись в наступні роки, досягнення прийнятної продуктивності може підвищувати потребу, щоб ви використовували більше парлелизма в ваших програмах. Часто це буде означати переписування вашого коду, так, щоб розподілити обчислення між декількома конкурентними потоками. Нажаль, створення надійних багатопоточних застосувань доведено складна задача на практиці. Модель поточності Java побудована навколо загальної пам'яті та блокування, модель, яку часто складно промислити, особливо коли система зростає в розмірі та складності. Складно бути впевненим, що ви не маєте стану гонок або мертвого блокування, що десь причаїлись — дещо, що не проявилось під час тестування, але може проявитись під час використатння. Як можливо безпечніша альтернатива є архитектура передачі повідомлень, така, як підхід "акторів", використаний в мові програмування Erlang.

Java іде з багатою, основаною на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, так само, як любе інше Java API. Однак існує Akka, що є додатковою бібліотекою Scala, яка реалізує модель акторів, подібних то таких в Erlang.

Актори є абстракцією конкурентності, що може бути реалізвана поверху потоків. Вони комунікують через надсилання повідомлень один одному. Актор може виконувати дві базові операції, надсилання та отримання повідомлення. Операція `send`, позначена знаком наголосу(!), надсилає повідомлення актору. Ось приклад, в якому актор називається `recipient`:
[source.scala]
----
recipient ! msg
----
Надсилання асинхронне; тобто, надсилаючий актор може продовжувати безпосередньо, без очікування щоб повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, в якому накопичуються повідомлення. Актор обробляє повідомлення, що надійшли в поштову скриньку через блок `receive`:
[source,scala]
----
def receive = {
  case Msg1 => ... // handle Msg1
  case Msg2 => ... // handle Msg2
// ...
}
----
Блок `receive` складається з декількох `case`, кожний з яких опитує поштову скриньку за шаблоном повідомлення. Перше повідомлення в скриньці, що співпаде з любим `case`, буде обране, та для нього виконується відповідна дія. Як тільки скринька більше не містить повідомлень, актор призупиняється, та очікує подальших входящих повідомлень.

Як приклад, ось простий актор Akka, що реалізує сервіс калькулятора контрольних сум:
[source,scala]
----
class ChecksumActor extends Actor {
  var sum = 0
  def receive = {
    case Data(byte) => sum += byte
    case GetChecksum(requester) =>
      val checksum = ~(sum & 0xFF) + 1
      requester ! checksum
  }
}
----
Зпочатку цей актор визначає локальну змінну на ім'я `sum` з початковим значенням нуль. Далі він визначає блок `receive`, що буде обробляти повідомлення. Якщо він отримає повідомлення Data, він додає збережений байт до змінної `sum`. Якщо отримано повідомлення GetChecksum, актор обчислює контрольну суму для поточного значення `sum`, та надсилає результат назад до запитувача, використовуючи надсилання повідомлення `requester ! sum`. Поле `requester` вбудоване в повідомлення GetChecksum; воно звичайно посилається актора, що зробив запит.

Ми не очікуємо, що ви повністю розумієте приклад з актором на цей момент. Скоріше, що важливе щодо цього прикладу в плані маштабованості, це те, що ані блок `receive`, ані повідомлення `send` (!) не є вбудовані операції в Scala. Навіть вважаючи, що блок `receive` може виглядати та діяти дуже подібними до вбудованих керівних конструкцій, фактично це метод, визначений в бібліотеці акторів Akka. Подібно до цього, навіть вважаючи, що '!' виглядає як вбудований оператор, він також є тільки методом, визначеним в бібліотеці акторів Akka. Обоє з ціх конструкцій повністю незалежні від мови програмування Scala.

Синтаксис блоку `receive` та `send` (!) вигладає в Scala здебільшого як вони виглядають в Erlang, але в Erlang ці конструкції вбудовані в мову. Akka також реалізує більшість з інших конкурентних програмних конструкцій Erlang, таких, як моніторинг схибивших акторів та тайм-аути. Кінець кінцем, модель акторів виявилась дуже приємним засобом для вираження конкурентних та розподілених обчислень. Навіть якщо вони визначені в біблиотеці, актори можуть відчуватись як інтегральна частина мови Scala.

Цей приклад ілюструє, як ви можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Звичайно, вам знадобляться гарні архітектори та програмісти, щоб зробити це. Але вирішальна річ в тому, що це можливо — ви можете розробляти та реалізувати абстракції в Scala, що адресують радикально нові галузі застосування, та все ще відчувати це як природну підтримку мови при використанні.

1.2 Що робить Scala маштабованою?
---------------------------------
На маштабованість впливає багато факторів, в диапазоні від синтаксичних деталей до абстрактних конструкцій компонент. Однак якщо б нам доводилось назвати тільки один аспект Scala, що допомагає маштабованості, ми б обрали комбінацію об'єктно-орієнтованого та функціонально програмування (гаразд, ми змахлювали, насправді це два аспекти, але вони пов'язані).

Scala іде далі, ніж всі інші гарно-відомі мови в справі зплавлення об'єкто-орієнтовного та функціонального програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції як дві окремі концепції, в Scala значення функції є об'єктом. Функціональні типи є класами, що можуть наслідуватись субкласами. Це може виглядати нічим іншим, ніж академічними тонкощами, але це має глибокі наслідки для маштабованості. Фактично, показана раніше концепція актора не могла б бути реалізованою без цієї уніфікації функцій та об'єктів. Цей розділ дає огляд шляху Scala по змішуванню об'єктно-орієнтовної та функціональної концепцій.

Scala є об'єктно-орієнтовна
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Об'єктно-орієнтоване програмування було назвичайно успішним. Починаючи з Simula в середині 60х та Smalltalk в 70х, воно зараз доступне в більшій кількості мов, ніж навпаки. В деяких галузях об'єкти повністю перебрали все на себе. Хоча немає точного визначення того, що означає об'єкт-орієнтовне, але ясно, що це щось щодо об'єктів, що апелює до програмістів.

В принципі, мотивація для об'єктно-орієнтовного програмування дуже проста: всі, крім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, це покласти дані та операції в деяку форму контейнерів. Чудова ідея об'єктно-орієнтовного програмування це зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як і дані, та що вони самі по собі є значеннями, що можуть зберігатись в інших контейнерах, або передані як параметри до операцій. Такі контейнери називаються об'єктами. Alan Kay, винахідник Smalltalk, зауважував, що в такий спосіб найпростіший об'єкт має ті самі принципи конструкції, що і цілий компьп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом.footnote:[Kay, "The Early History of Smalltalk." [Kay96\]] Так що об'єкти мають багато чого докласти до маштабованості мови: та сама технологія застосовується до конструкції малих, так само як і до великих програм.

Навіть якщо об'єктно-орієнтоване програмування було мейнстримом протягом довгого часу, є відносно мало мов, що послідували за Smalltalk в протисканні цього конструктивного принипу до його логічного висновку. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні значення в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтовного програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнюівати речі, та обмежувати маштабованість.

Для контрасту Scala є об'єктно-орієнтовною мовою в чистій формі: кожне значення є об'єктом, та кожна операція є викликом метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви насправді викликаєте метод на ім'я + , визначений в класі Int. Ви можете визначити методи з оператор-подібними назвами, які потім клієнти вашого API використовують для використання в операторній нотації. Ось як розробник Akka API акторів дозволив вам використовувати вирази, такі як `requester ! sum`, показані в попередньому прикладі: ! є методом класу Actor.

Scala є більш досвідченою, ніж багато інших мови, коли йдеться про композицію об'єктів. Прикладом є трейти Scala. Трейти подібні до інтерфейсів в Java, але вони також можуть мати реалізації методів, та навіть поля.footnote:[Починаючи з Java 8, інтерфейси можуть мати реалізації методів по замовчанню, але вони не надають всі можливості трейтів Scala.] Об'єкти конструюються через композицію міксінів, що бере методи класу, та додає до них члени декількох трейтів. В цей спосіб різні аспекти класів можуть бути інкапсульовані в різні трейти. Це виглядає трохи схожим на множинне наслідування, але відрізняється, коли річ доходить до деталей. Це робить трейти більш "плагабельними", ніж класи. Зокрема, вони уникають класичних проблем "діамантового наслідування" множинних інтерфейсів, що виникає, коли деякий клас наслідується через декілька різних шляхів.

Scala є функціональною
~~~~~~~~~~~~~~~~~~~~~~
На додаток до того, що вона є чистою об'єктно-орієнтовною мовою, Scala також є повно-функціональною функціональною мовою. Ці ідеі функціонального програмування старіші ніж (електронні) комп'ютері. Їх основи були покладені в лямбда обчисленні Alonzo Church, що було розроблене в 1930х. Першою функціональною мовою був Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. Протягом довгого часу функціональне програмування було дещо на узбіччі — популярне в академічних колах, але не так широко використане в індустрії. Однак в останні роки намітилась зростаюча зацікавленість в функціональному програмуванні та технологіях.

Функціональне програмування направляється двома головними ідеями. Перша ідея в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з тим самим статусом, що і, скажімо, ціле або рядок. Ви можете передати функції як аргументи в інші функції, повернути їх як результат з функції, або зберігати їх в змінних. Ви також можете визначити функцію всередині іншої функції, так само, як ви можете визначити ціле значення всередині функції. Та ви можете визначити функції без надання їм імен, скрапляючи ваш код функціональними літералами так просто, як ви можете записати цілий літерал, як 42.

Функції, що є першокласними значеннями, провадять зручні засоби для абстрагування над операціями, та створення нових керівних структур. Це узагальнення функцій провадить чудову виразність, що часто призводить до дуже виразних та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, бібліотека тестування ScalaTest пропонує конструкцію `eventually`, що приймає функцію як аргумент. Це використовується приблизно так:
[source,scala]
----
val xs = 1 to 3
val it = xs.iterator
eventually { it.next() shouldBe 3 }
----
Код всередині `eventually` — твердження, `it.next() shouldBe 3` — огорнуте в функцію, що передається без виконання до метода `eventually`. Для сконфігурованого проміжку часу, `eventually` буде виконувати функцію, доки буде виконуватись твердження.

В більшості традиційних мов, для контрасту, функції не є значеннями. Мови, де є значення функцій, часто відсувають їх на другій план. Наприклад, вказівники на функції в C та C++ не мають того самого статусу, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись тільки на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення в своєму оточенні. Також вони не дозволяють визначати неіменовані функціональні літерали.

Друга головна ідея функціонального програмування в тому, що операції програми мають відзеркалювати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці.  Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масив символів. Символи в рядку можуть бути змінені індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку на кому, всередині того самого об'єкта рядка. В Java та Scala, з іншого боку, рядок є послідовність символі в математичному сенсі. Заміна символа в рядку, використовуючи вираз як s.replace(";","."), повертає новий об'єкт рядка, що є іншим від s. Інший шлях виразити те саме, це сказати, що рядкі незмінні в Java, тоді як вони змінні в Ruby. Так що з погляду тільки на рядки, Java є функціональною мовою, тоді як Ruby ні. Незмінні структури даних є один з наріжних каменів функціонального програмування. Бібліотеки Scala визначають значно більше незмінних типів даних, крім тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, тапли, мапи та множини.

Інший шлях затвердити цю другу ідею функціонального програмування є те, що методам не слідує мати любі побічні ефекти. Вони мають комунікувати зі своїм оточенням тільки через прийняття аргументів, та повернення результатів. Наприклад, метод `replace` в класі Java String підходить під цей опис. Він приймає рядок та два символи, та видає новий рядок, де всі появлення одного символа замінюється на інший. Немає іншого ефекту виклику `replace`. Методи як `replace` називаються референційно прозорими, що означає, що для кожного взятого вводу виклик методу може бути замінений на свій результат, без впливу на семантику програми.

Функціональні мови заохочують незмінні структури даних та референсно прозорі методи. Деякі функціональні мови навіть вимагають їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є назвою для програмування зі змінними даними та побічними ефектами. Але Scala загалом робить простим уникати імперативних конструкцій, коли ви бажаєте цього, бо існують гарні функціональні альтернативи.

1.3 Чому Scala?
---------------
Чи Scala для вас? Вам доведеться зрозуміти та прийняти рішення самостійно. Ми винайшли, що насправді багато причин, крім маштабованості, щоб програмувати на Scala. В цьому розділі будуть розглянуті чотири з найбільш важливих аспектів: сумісність, краткість, високорівневі абстракції та розвинена статична типізація.

Scala є сумісною
~~~~~~~~~~~~~~~~
Scala не потребує, щоб ви зістрибували назад з платформи Java, щоб зробити крок вперед від мови Java. Вона дозволяє вам додати вартість до існуючого коду — щоб будувати на тому, що вже маєте, оскільки вона була розроблена для безшовної взаємодії з Java.footnote:[Зпочатку була реалізація Scala, що робила на платформі .NET, але вона більше не активна. Останнім часом все більше популярною стає реалізація Scala, що робить на JavaScript, Scala.js.] Програми Scala компілюються на байткоди JVM. Її продуктивність часу виконання звичано співпадає з Java програмами. Код Scala може викликати методи Java, отримувати доступ до полів Java, наслідувати від Java класів, та реалізувати Java інтерфейси. Ніщо з цього не потребує спеціального синтаксису, явного визначення інтерфейсів, або зклеючого коду. Фактично, весь код Scala дуже тяжко використовує Java бібліотеки, часто без того, щоб програміст переймався цім фактом.

Інший аспект повної взаємодії є те, що Scala потужно пере-використовує типи Java. Scala `Int` представлений як примітивне ціле Java типу `int`, `Float` представлені як `float`, `Boolean` як `boolean`, і так далі. Масиви Scala відображуються на масиві Java. Scala також пере-використовує багато зі стандартних бібліотечних типів Java. Наприклад, тип рядкового літерала "abc" в Scala є `java.lang.String`, та підійняті виключення мають бути субкласом `java.lang.Throwable`.

Scala не тільки пере-використовує Java типи, але також "принаряджує" їх, щоб зробити їх кращими. Наприклад, методи підтримки рядків в Scala, як `toInt` або `toFloat`, що конвертують рядок на ціле або на число з плаваючою крапкою. Так що ви можете писати `str.toInt` замість `Integer.parseInt(str)`. Як це може бути досягнуте без руйнування сумісності? Клас Java String напевне не має метода `toInt`! Фактично, Scala має дуже загальне рішення для вирішення цього тертя між розширеним дизайном бібліотек, та взаємодією. Scala дозволяє вам вирішити неявні перетворення, що завжди застосовуються, коли типи не будуть звичайно співпадати, або коли обираються неіснуючі члени. В випадку вище, коли шукається метод `toInt` для рядка, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String на примірник класу Scala StringOps, що визначає такий член. Це перетворення буде потім неявно застосоване перед виконанням операції `toInt`. Код Scala також може викликатись з кода Java. Іноді це більш тонка матерія, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш розвинених можливостей Scala мають бути закодовані, перед тим, як іх можна буде відобразити на Java. Глава 31 пояснює деталі.

Scala є стислою
~~~~~~~~~~~~~~~
Програми Scala мають схильність бути короткими. Програмісти на Scala повідомляють зменшення числа рядків до десяти раз, порівняно з Java. Це може бути екстремальним випадком. Більш консервативне очікування може бути таким: типова Scala програма має бути приблизно в половину довжини за числом рядків, до такої самої програми, написаної на Java. Меньше рядків коду означає не тільки менше друку, але також менше зусиль по читанню та розумінню програм, та менші можливості для дефектів. Існують різні фактори, що докладаються до цього зменшення рядків коду.

Перше, синтаксис Scala уникає деяких шаблонів, що обтяжують Java програми. Наприклад, крапка з комою є опціональною в Scala, та звичано відкидається. Також є декілька інших площин, де синтаксис Scala менш шумлячий. Як приклад, порівняйте, як ви пишете класи та конструктори в Java та Scala. В Java клас з конструктором часто виглядає подібно до такого:
[source,java]
----
// це Java
class MyClass {
    private int index;
    private String name;
    public MyClass(int index, String name) {
        this.index = index;
        this.name = name;
    }
}
----
В Scala ви скоріше всього замість цього напишете таке:
[source,scala]
----
class MyClass(index: Int, name: String)
----
Маючи цей код компілятор Scala спродукує клас, що має дві приватні змінні примірника, `Int` на ім'я `index` та `String` на ім'я `name`, та конструктор, що приймає первинні значення для ціх змінних в якості параметрів. Код цього конструктора буде ініціалізувати дві змінні примірника значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча Java версія.footnote:[Єдина реальна різниця в тому, що змінні примірника, вироблені в випадку Scala, будуть фінальні. Ви навчитесь, як робити їх не-фінальними в Розділі 10.6.] Клас Scala швидше писати, протіше читати, та більш важливо - менше схильний до помилок, ніж Java клас.

Вивід типів Scala є іншим фактором, що докладається до її стислості. Повторювана інформація інйормація про типи може бути відкинута, так що програми стають менш захащені та більш читабельні.

Але, можливо, найбільш важливим ключем до компактного коду є код, що ви не маєте писати, бо він вже зроблений в бібліотеці за вас. Scala надає вам інструменти для визначення потужних бібліотек, що дають вам захопити та виділити загальну поведінку. Наприклад, різні аспекти класів бібліотеки можуть бути виділені в трейти, що можуть потім бути зміксовані разом в гнучкий спосіб. Або методи бібліотеки можуть бути параметризовані за допомогою операцій, що дозволяє вам визначати конструкції, які ефективно є вашими власними керівними структурами. Разом ці конструкції дозволяють визначення бібліотек, що одночасно високорівневі та гнучки в використанні.

Scala є високорівневою
~~~~~~~~~~~~~~~~~~~~~~
Програмісти постійно борються зі складністю. Щоб програмувати продуктивно, ви маєте розуміти код, з яким ви робите. Надскладний код був причиною падіння багатьох софтверних проектів. Нажаль, важливі програми звичано мають складні вимоги. Такої складності неможливо уникнути; замість цього єю треба керувати.

Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракції в інтерфейсах, що ви розробляєте і якими користуєтесь. Як приклад, уявіть, що ви маєте змінну `String name`, та ви бажаєте визначити, чи містить цей рядок символи в великому реєстрі. До Java 8 ви могли написати такий цикл:
[source,java]
----
boolean nameHasUpperCase = false; // this is Java
    for (int i = 0; i < name.length(); ++i) {
    if (Character.isUpperCase(name.charAt(i))) {
         nameHasUpperCase = true;
         break;
    }
}
----
Тоді як в Scala ви можете записати таке:
[source,scala]
----
val nameHasUpperCase = name.exists(_.isUpper)
----
Код Java сприймає рядки як низьковірневі сутнсті, по яких можна крокувати символ за символом в циклі. Код Scala сприймає той самий рядок як високорівневу послідовність символів, до якої можливо робити запити за допомогою предикатів. Зрозуміло, що код Scala значно коротший, та — для тренованого ока — простіший для розуміння, ніж Java код. Так що код Scala менше заважує до загального бюджету складності. Він також дає вам менше можливостей робити помилки.

Предикат _.isUpper є прикладом функціонального літералу в Scala.footnote:[Функціональні літерали можуть бути названі предикатами, якщо тип їх результату Boolean.] Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи це символ верхнього реєстра.footnote:[Це використання підкреслення як заповнювача для аргументів описане в Розділі 8.5.]

Java 8 вводить підтримку для лямбда та потоків, що дозволяє вам виконувати подібну операцію в Java. Ось як це може виглядати:
[source,java]
----
boolean nameHasUpperCase =
// це Java 8
name.chars().anyMatch(
    (int ch) -> Character.isUpperCase((char) ch)
);
----
Хоча це велике покращення над ранішніми версіями Java, код Java 8 все ще більше балакучий, ніж еквівалентний код Scala. Ця додаткова "важкість" Java коду, так само, як довгі традиції циклів Java, можуть заохотити багатьох Java програмістів за браком нових методів, як `exists`, просто писати цикли, та жити з підвищеною складністю їх кода.

З іншого боку, функціональні літерали в Scala насправді легковажні, так що вони використовуютсья часто. Коли ви знатимете Scala краще, ви будете знаходити більше і більше можливостей для визначення та використання ваших власних керівних абстракцій. Ви побачите, що це допомагає уникати дублікації коду, і, таким чином, утримують ваш код коротним та чистішим.

Стиль функціонального програмування Scala також пропонує високорівневі принципи розмірковувати про програмування. Ключова ідея в тому, що ці функції є референтно прозорими — застосування функції характеризується тільки її результатом. Таким чином ви можете вільно замінити застосування функції на праву сторону функції (тобто тіло, що слідує за знаком рівняння), не турбуючись щодо жодних побічних ефектів. Цей принцип надає багато корисних законів, які ви можете задіяти для кращого розуміння або для рефакторинга вашого коду. Як приклад, ще раз візьмемо метод `exists`, описаний вище. Цей метод має задовільняти наступному правилу: для кожної послідовності `s`, та для кожної пари предикатів `p` та `q` має виконуватись таке:
[source,scala]
----
s.exists(p) || s.exists(q) == s.exists(x => p(x) || q(x))
----
Тобто, опитуючи ту саму послідовність двома предикатами p та q, та роблячи АБО з результатами є те саме, що перевірити один предикат, що одночасно перевіряє на p або q. Правило, подібне до цього, вочевідь корисне для написання та рефакторингу програм. Однак, якщо `exists` має побічні ефекти, загалом не буде коректно припускати існування такого закону, оскільки ліва частина виконує `exists` двічі для кожного елемента послідовності, тоді як права частина виконується тільки один раз для кожного елементу. Так що це є прикладом, коли чисто функціональний код призводить до додаткових правил, і корисний для розуміння та рефакторингу вашого коду.

Стиль функціонального програмування також прибирає проблеми накладання, що трапляються в імперативному програмуванні. Накладання трапляється, коли декілька змінних посилаються на той самий об'єкт. Це підіймає деякі тернисті запитання та ускладнення. Наприклад, чи зміна поля `r.x` також впливатиме на `s.x`? Це відбуватиметься, якщо `r` та `s` посилаються на той самий об'єкт. На практиці дуже складно відслідити такі накладання. З іншого боку, незмінні правила можуть вільно поділятись, оскільки копія не відрізняється від загального посилання. Ця перевага є практично ключовою, коли ви пишете конкурентний код. (Ось чому Java має незмінні рядки).

Scala статично типізована
~~~~~~~~~~~~~~~~~~~~~~~~~
Статичні системи типів класифікують змінні та вирази відповідно до властивостей значень, що вони зберігають на обчислюють. Scala виділяється як мова з дуже розширеною статичною системою типів. Починаючи від системи типів вкладених класів, подібних до Java, вона дозволяє вам параметризувати типи за допомогою дженериків, комбінувати типи з використанням перетинів, та приховувати деталі типів з використанням абстрактних типів.footnote:[Дженеріки обговорюються в Главі 19; перетини (тобто, A with B with C) в Главі 12; та абстрактні типи в Главі 20.] Це дає міцний фундамент для будівництва та компонування ваших власних типів, так що ви можете розробити інтерфейси, що одночасно безпечні, та гнучкі в використанні.

Якщо вам подобаються динамічні мови, такі як Perl, Python, Ruby, або Groovy, ви можете винайти трохи дивним, що статична система типів Scala попала в перелік як одна з сильних сторін. Кінець кінцем, відсутність статичної системи типів наводиться як одна з головних переваг динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми над балакучими, заважають програмістам виражати себе так, як вони бажають, та роблять неможливим деякі шаблони динамічних модифікацій софтверних систем. Однак часто ці аргументи не ідуть проти самої ідеі статичних типів взагалі, але проти окремих систем типів, що сприймаються як дуже балакучі або негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись замітив: "Я не проти типів, але я не знаю жодної системи типів, що не є суцільною біллю, так що я все ще люблю динамічні типи".footnote:[Kay, поштою щодо значення об'єктно-орієнтовного програмування. [Kay03\]]

Ми надіємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільною біллю". Фактично, вона адресує дві звичайні турботи щодо статичної типізації: балакучість іникається через вивід типів, та гнучкість досягається через співпадіння шаблонів та декльіка нових шляхів писати та компонувати типи. Коли ці перешкоди прибрані з нашого шляху, класичні переваги статичних типів можуть бути краще помічені. Серед найбільш важливих з ціх переваг є перевіряємі властивості програмних абстракцій, безпечний рефакторинг, та краща документація.

*Перевіряємі властивості.* Статичні системи типів можуть забезпечити відсутність певних помилок часу виконання. Наприклад, вони можуть доказати такі властивості: `Boolean` не буде доданий до цілого; приватні змінні не отримують доступ поза меж класу; функції застосовуються до відповідного числа аргументів; тільки рядки будь-коли будуть додаватись до множини рядків.

Інші відомі помилки не виявляються сьогоднішніми статичними системами типів. Наприклад, вони зазвичай не будуть не-терміновані функції, порушення меж масивів, або ділення на ноль. Вони також не детектують, що ваша програма не відповідає її специфікації (вважаємо що така специфікація є, саме так!). Статичні системи типів, мають бути звільнені, як не дуже корисні. Аргумент, що надається, що оскільки такі системи можуть виявляти тільки прості помилки, тоді як юніт тести провадять більш екстенсивне покриття, чому треба борсатись зі статичними типами взагалі? Ми впевнені, що ці аргументи позбавлені змісту. Хоча статичні системи типів напевне не можуть замінити юніт тести, вони можуть зменшити число потрібних юніт тестів, пілчкуючись про деякі властивості, для яких інакше знадобились би тести. Подібним чином, юніт тести не можуть замінити статичну типізацію. Кінець кінцем, як казав Edsger Dijkstra, тестування може тільки довести наявність присутності помилок, та ніколи їх відсутність.footnote:[Dijkstra, "Notes on Structured Programming." [Dij70\]] Так що гарантії, що надає статична типізація, може бути слабкою, але це реальні гарантії в формі, яку не може забезпечити ніяка кількість тестів.

*Безпечний рефакторинг.* Статичні системи типів провадять страховку, що дозволяє вам робити зміни в базі коду з високою мірою довіри. Розглянемо примірник рефакторингу, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто підігнати всі рядки, що видають помилку типу. Коли ви скінчите з цім, ви впевнені, що найшли всі місця, що треба змінити. Те саме вірно для багатьох інших випадків простого рефакторингу, як зміни імені методу, або переміщення методів з одного класу до іншого. В усіх ціх випадках перевірка статичного типу буде провадити досить акуратності, щоб нова система робила так само, як стара.

*Документація.* Статичні типи є документацією програми, що перевіряється компілятором на коректність. На відміну від звичайних коментарів, анотації типів ніколи не можуть застаріти (щонайменьше якощ файл коду, що містить їх, недавно проходив через компілятор). Більше того, компілятори і інтегровані середовища розробки (IDE) можуть використовувати анотації типів для провадження кращої контекстної підказки. Наприклад, IDE може відображувати всі члени, доступні для вибору, через визначення статичного типу виразу, на якому робиться вибір, та перегляд членів цього типу.

Навіть хоча статичні типи загалом корисні для документації програми, вони можуть інколи бути надокучливі, коли вони захаращують програму. Типово, корисна документація - це те, що читачі програми не можуть просто вивести самі по собі. В визначенні метода як цей:
[source,scala]
----
def f(x: String) = ...
----
корисно знати, що аргумент має бути `String`. Або, з іншого боку, щонайменьше одна з двох анотацій в наступному прикладі є подразником:
[source,scala]
----
val x: HashMap[Int, String] = new HashMap[Int, String]()
----
Зрозуміло, що має бути достатньо сказати тільки один раз, що `x` є `HashMap` з `Int` в якості ключа, та `Strings` як значення; немає потреби повторювати ту саму фразу двічі. Scala має дуже складну систему виводу типів, що дозволяє вам оминати майже всю інформацію типів, що звичайно сприймається як надокучлива. В попередньому прикладі наступні дві менш дратливі альтернативи також будуть робити:
[source,scala]
----
val x = new HashMap[Int, String]()
val x: Map[Int, String] = new HashMap()
----
ВИвід типів в Scala може зайти досить далеко. Фактично, не є рідкістю для користувацького кода, взагалі не мати явних типів. Таким чином, програми Scala часто виглядають трохи як програми, написані на динамічно типізованій скриптоівій мові. Це вірно зокрема для кода клієнтськіх застосувань, що зліплюють разом попередньо написані бібліотечні компоненти. Це менш вірно для самих компонент бібліотек, оскільки вони часто вживають дуже складні типи, щоб забезпечити гнучкі шаблони застосування. Це просто природно. Кінець кінцем, сигнатури типів членів, що складають інтерфейс реюзабельного компонента, повинен бути наданий явно, оскільки вони складають основну частину контракту між компонентом та його клієнтами.

1.4 Корені Scala
----------------
Дизайн Scala бів під впливом багатьох мов програмування, та ідей в дослідженні програмних мов. Фактично, тільки декілька можливостей Scala чисто нові; більшість вже мали застосування в деякій формі в інших мовах. Інновація Scala в основному походить від того, як вона покладає ці конструкції разом. В цьому розділі ми перелічимо головні впливи на розробку Scala. Список не може бути вичерпним — існує дуже багато розумних ідей коло розробки мови програмування, щоб перелічити тут їх всі.

На поверхневому рівні Scala адоптує значну частину синтаксиса Java та C#, що, в свою чергу, позичає більшість зі своїх синтаксичних домовленостей від C та C++. Вирази, твердження та блокі здебільшо як в Java, так само, як синтаксис класів, пакунків та імпортів.footnote:[Головне відхидення від Java в плані синтаксису для анотацій типу, це "змінна: типу" замість "тип змінної" в Java. Постфіксний синтаксис типу в Scala копіює Pascal, Modula-2, або Eiffel. Головна причина для цього відхилення має відношення до виводу типів, що часто дозволяє вам оминути тип змінної або тип повернення метода. Використання синтаксису "змінна: типу" просте - тільки опустіть крапку з комою та тип. Але в C-style синтаксисі "тип змінної" ви не можете просто відкинути тип; більше намає маркера що почалась декларація. Вам знадобиться деяке альтернативне ключове слово, щоб бути заповнювачем для відсутнього типу (C# 3.0, що робить деякий вивід типів, використовує `var` для ціх цілей). Таке альтернативне ключове слово виглядає більш притягнутим, та менш регулярним, ніж підхід Scala.] Крім синтаксиса Scala адоптує багато інших елементів Java, такі як базові типи, її бібліотеки типів, та її модель виконання.

Scala також заборгувала багатьом іншим мовам. Її уніформна об'єктна модель започаткована  Smalltalk, і згодом прийнята Ruby. Її ідея про універсальне вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, більш пізніше, в Beta та gbeta. Її принцип уніформного доступу для виклику методів та виборів полів надходить від Eiffel. Її підхід до функціонального програмування є дуже подібним до духу сім'ї мов ML, таких як SML, OCaml та F#, в якості видатних членів. Багато високорівневих функцій в стандартній бібліотеці Scala також присутні в ML або Haskell. Неявні параметри були мотивовані класами типів Haskell; вони досягли аналогічних результатів в більше класичной об'єктно-орієнтовному оточенні. Головна актор-базована бібліотека конкурентності, Akka, дуже надихалась Erlang.

Scala не є першою мовою, що наголошує на маштабованості та розширюваності. Історичні корені розширюваної мови, що може перетинати різні області застосування, знаходяться в статті Peter Landin 1966го року,"The Next 700 Programming Languages."footnote:[Landin, "The Next 700 Programming Languages." [Lan66\]] (Мова, описана в цьому документі, Iswim, стоїть поряд з Lisp як один з першопроходців функціональних мов). Специфічна ідея трактувати інфіксний оператор як функцію можна прослідкувати до Iswim та Smalltalk. Інша важлива ідея є дозволити функціональні літерали (або блоки) в якості параметрів, що дозвоялє бібліотекам визначати керівні структури. Знову, це тягнеться назад до Iswim та Smalltalk. Smalltalk та Lisp обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх, домен-специфічних мов. C++ є іншою маштабованою мовою, що може бути адаптований та розширений через перевантаження операторів, та його систему шаблонів; порівняно зі Scala він побудований на ніжньому рівні, більш системно-орієнтовному ядрі. Scala також не є першою мовою, що інтегрує функціональне та об'єкт-орієнтовне програмування, хоча вона, можливо, зашла найбільш далеко в цьому напрямку. Інші мови, що інтегрували деякі елементи функціонального програмування в об'єкто-орієнтовне програмування (OOP) включають Ruby, Smalltalk та Python. На Java платформі, Pizza, Nice, Multi-Java — та сама Java 8  — мають розширене Java-подібне ядро з функціональними ідеями. Також існують здебільше функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F#, та PLT-Scheme.

Scala також привнесла деякі інновації до поля мов програмування. Наприклад, її абстрактні типи провадять більше об'єктно-орієнтовної альтернативи до дженерік типів, її трейти дозволяють гнучкі збірки компонент, та її екстрактори провадять незалежний від представлення спосіб співпадіння шаблонів. Ці інновації були представлені в документах на конференціях з мов програмування в останні роки.footnote:[Для додаткової інформації дивіться [Ode03\], [Ode05\], та [Emi07\] в бібліографії.]

1.5 Висновок
------------
В цій главі ми дали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Напевне, Scala не є срібною кулею, що магічно зробить вас більш продуктивним. Щоб просуватись, вам знадобиться містецьки застосувати Scala, та це буде потребувати деякого навчання та практики. Якщо ви прийшли до Scala від Java, найбільш викличний аспект у вивченні Scala може включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книжки м'яко провести вас кривою навчання Scala, по кроку за раз. Ми вважаємо, що ви знайдете це корисним інтелектуальним досвідом, що розширить ваші горизонти, та змусить вас думати інакше щодо розробки програм. Надіємось, що ви також отримаєте задоволення та натхнення від програмуванн на Scala.

В наступній главі ми почнемо з вами писати деякий Scala код.
