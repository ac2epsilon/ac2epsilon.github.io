include::headers.adoc[]

Глава 15
--------

Кейс класи та порівняння шаблонів
==================================

Ця глава вводить _кейс класи_ та _порівняння шаблонів_, споріднені конструкції, що підтримують вас коли ви пишете регулярні, не-інкапсульовані структури даних. Ці дві конструкції зокрема корисні для дерево-подібних рекурсивних даних.

Якщо ви до цього програмували на функціональній мові, тоді ви, можливо, розпізнали порівняння шаблонів. Але кейс класи будуть новими для вас. Кейс класи це шлях Scala, щоб дозволити порівняння шаблонів на об'єктах, не потребуючи великої кількості кліше. Загалом, все що вам треба робити, це додати одне ключове слово case до кожного класу, що би бажаємо зробити придатним для порівняння.

Ця глава починається з простого прикладу кейс класу та порівняння шаблонів. Потім вона проходить по всіх підтримуваних шаблонах, каже про роль закоркованих класів, дискутує тип `Option`, та показує деякі не-очевидні місця в мові, де використовується порівняння шаблонів. Нарешті, показаний більший, більш реалістичний приклад порівняння шаблонів.

15.1 Простий приклад
--------------------
Перед зануренням в усі правила та нюанси порівняння шаблонів, варто подивитись на простий приклад, щоб зрозуміти головну ідею. Скажімо, вам треба написати бібліотеку, що маніпулює арифметичними виразами, можливо як частину домен-специфічної мови, яку ви розробляєте.

Перший крок подолання цієї проблеми є визначення вхідних даних. Щоб утримувати речі простими, ми сконцентруємось на арифметичних виразах, що складаються зі змінних, чисел, та одно- і дво-місних операціях. Це виражається через ієрархію Scala класів, показану в Лістингу 15.1.
[source,scala]
----
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
    left: Expr, right: Expr) extends Expr
----
Лістинг 15.1 - Визначення кейс класів.

Ієрархія включає абстрактний базовий клас `Expr` з чотирма субкласами, по одному для кожного типу виразу, що розглядається.footnote:[Замість абстрактного класу, ми також можемо обрати змоделювати корінь ієрархії класів як трейт. Моделювання його як абстрактного класу може бути трохі більш ефективним.] Тіла всіх п'яти класів порожні. Як зазначалось раніше, в Scala ви можете відкинути фігурні дужки коло порожніх класів, якщо бажаєте, та що `class C` те саме, що і `class C {}`.

Кейс класи
~~~~~~~~~~
Інша варта уваги річ щодо декларацій на Лістингу 15.1 є те, що кожний клас має модифікатор `case`. Класи з таким модифікатором називаються кейс класами. Використання модифікатора змушує Scala компілятор додати деякі синтаксичні зручності до вашого класу.

Перше, він додає метод фабрику з ім'ям класу. Це означає, наприклад, що ви можете писати `Var("x")` для конструювання об'єкту `Var`, замість трохи довшого `new Var("x")`:
[source,scala]
----
scala> val v = Var("x")
v: Var = Var(x)
----
Методи фабрик зокрема гарні, коли ви вкладаєте їх. Оскільки не існує шумлячих ключових слів `new`, розкиданих по коду, ви можете збагнути структуру вираза з одного погляду:
[source,scala]
----
scala> val op = BinOp("+", Number(1), v)
op: BinOp = BinOp(+,Number(1.0),Var(x))
----
Друга синтаксична зручність в тому, що всі ці аргументи в списку параметрів кейс класів неявно отримують префікс `val`, так що вони обробляються як поля:
[source,scala]
----
scala> v.name
res0: String = x

scala> op.left
res1: Expr = Number(1.0)
----
Третє, компілятор додає "природні" реалізації методів `toString`, `hashCode` та `equals` до вашого класу. Вони будуть друкувати, хешувати, та порівнювати цілі дерева, що складається з вашого класу, та (рекурсивно), всіх його аргументів. Оскільки `==` в Scala завжди делегує до `equals`, це означає, що елементи кейс класів завжди порівнюються структурно:
[source,scala]
----
scala> println(op)
BinOp(+,Number(1.0),Var(x))

scala> op.right == Var("x")
res3: Boolean = true
----
Нарешті, компілятор додає метод `copy` до вашого класу, щоб робити модифіковані копії. Цей метод корисний для створення нових примірників класу, що такі самі, як і інший, за винятком того, що один або два аргументи відрізняються. Метод робить через використання іменованих та параметрів за замовчанням (дивіться Розділ 8.8). Ви вказуєте зміни, що ви б хотіли зробити, використовуючи іменовані параметри. Для любих параметрів, які ви не вказуєте, буде використано значення зі старого об'єкту. Як приклад, ось як ви можете зробити операцію, таку саму як `op`, за винятком того, що оператор змінений:
[source,scala]
----
scala> op.copy(operator = "-")
res4: BinOp = BinOp(-,Number(1.0),Var(x))
----
Всі ці домовленості додають великі зручності за малу ціну. Ви мали написати лише модифікатор `case`, та ваші класи і об'єкти стають трохи більшими. Вони більші, оскільки згенеровані додаткові методи та додані неявні поля для кожного параметру конструктора. Однак найбільша вигода від кейс класів є те, що вони підтримують порівняння шаблонів.

Порівняння шаблонів
~~~~~~~~~~~~~~~~~~~
Скажімо, ви бажаєте спростити арифметичні вирази тільки що представлених типів. Є багато можливих правил спрощення. Наступні три правила служать тільки для ілюстрації
:
[source,scala]
----
UnOp("-", UnOp("-", null)) => null  // Подвійна зміна знаку
BinOp("+", null, Number(0)) => null // Додавання нуля
BinOp("*", null, Number(1)) => null // Множення на одинницю
----
Використовуючи порівняння шаблонів, ці правила можуть розгядатись майже так, якби вони формували основу функції спрощення в Scala, як показано на Лістингу 15.2. Функція `simplifyTop`, може використовуватись таким чином:
[source,scala]
----
scala> simplifyTop(UnOp("-", UnOp("-", Var("x"))))
res4: Expr = Var(x)

  def simplifyTop(expr: Expr): Expr = expr match {
    case UnOp("-", UnOp("-", e)) => e  // Подвійна зміна знаку
    case BinOp("+", e, Number(0)) => e // Додавання нуля
    case BinOp("*", e, Number(1)) => e // Множення на одинницю
    case _ => expr
  }
----  
Лістинг 15.2 - Функція `simplifyTop`, що робить порівняння шаблонів.

Права сторона `simplifyTop` складається з вираза `match`. `match` відповідає до `switch` в Java, але він записаний після вираза селектора. Іншими словами, це:
[source,scala]
----
selector match { alternatives }
----
замість:
[source,scala]
----
switch (selector) { alternatives }
----
Порівняння шаблонів включає послідовність альтернатив, кожне починається з ключового слова `case`. Кожна альтернатива включає шаблон, та один або більше виразів, що будуть обчислені, якщо шаблон співпадає. Символ стрілки `=>` відділяє шаблон від виразів.

Вираз `match` обчислюється через спробу кожного з шаблонів по порядку, як вони записані. Перший шаблон, що співпаде, буде обраний, та частина, що стоїть за стрілкою, обирається та виконується.

_Шаблон константи_ як `"+"` або `1` співпадає зі значеннями, що дорівнюють константі з точки зору `==`.

_Шаблон змінної_ як `e` співпадає з любим значенням. Змінна після цього посилається на це значення в правій частині твердження `case`. В цьому прикладі зауважте, що перші три альтернативи обчислюються до `e`, змінної, що прив'язана в асоційованому шаблоні. Підстановочний шаблон `_` також співпадає з кожним значенням, але він не вводить ім'я змінної, що посилається на це значення. В Лістингу 15.2 зауважте, як `match` закінчується на випадок за замовчаню, що нічого не робить з виразом. Замість цього, він просто має результат `expr`, вираз, якій порівнюється.

_Шаблон конструктора_ виглядає `UnOp("-", e)`. Цей шаблон співпадає з усіма значеннями типу `UnOpwhose`, чий перший аргумент співпадає з `"-"`, та чий другий аргумент співпадає з `e`. Зауважте, що аргументи до конструктора самі є шаблонами. Це дозволяє вам писати глибокі шаблони, використовуючи стислу нотацію.

Ось приклад:
[source,scala]
----
UnOp("-", UnOp("-", e))
----
Уявіть реалізцію тієї самої функціональності з використанням дизайну шаблону візитора!footnote:[Gamma, et. al., Design Patterns [Gam95\]]Майже так само незручно, уявіть його реалізацію як довгої послідовності тверджень `if`, перевірок та перетворень типів.

Порівняння `match` та `switch`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Вирази `match` можуть розглядатись як узагальнення `switch` в стилі Java. Перемикачі в стилі Java можуть бути природно виражені як вирази `match`, де кожний шаблон є константою, та останній шаблон може бути підстановочним (що презентує випадок `default` в `switch`).

Однак існує три відмінності, що треба мати на увазі: перше - `match` є виразом в Scala (тобто, він завжди повертає значення). Друге, вирази альтернатив в Scala ніколи не "провалюються" в наступний випадок. Третє, як жодний з шаблонів не співпадає, закидається виключення `MatchError`. Це означає, що ви завжди маєте переконатись, що покриті всі випадки, навіть якщо це означає додавання випадку за замовчанням, якій нічого не робить.
[source,scala]
----
expr match {
  case BinOp(op, left, right) =>
    println(expr + " is a binary operation")
  case _ =>
}
----
Лістинг 15.3 - Шаблон `match` з порожнім випадком `"default"`.

Лістинг 15.3 показує приклад. Другий випадок є необхідним, оскільки без нього вираз `match` буде викликати `MatchError` для кожного аргументу `expr`, що не є `BinOp`. В цьому прикладі для другого випадка немає коду, так що при виконанні випадка нічого не виконується. В любому випадку результат є одиничне значенню `()`, що також є результатом всього виразу `match`.

15.2 Різновиди шаблонів
-----------------------
Попередній приклад показує декілька типів шаблонів в швидкій послідовності. Тепер затратимо хвилину, та детально поглянемо на кожний шаблон.

Синтаксис шаблонів простий, так що не турбуйтесь щодо цього дуже сильно. Всі шаблони виглядають точно так, як відповідні вирази. Наприклад, маючи ієрархію з Лістингу 15.1, шаблон `Var(x)` співпадає з любим виразом змінної, пов'язуючи `x` з ім'ям змінної. Використовуючи вираз `Var(x)` — точно такий же синтаксис — перестворює еквівалентний об'єкт, вважаючи, що `x` вже прикріалений до імені змінної. Оскільки синтаксис шаблонів такий прозорий, головна річ, на яку варто звертати увагу, це тільки те, які шаблони взагалі можливі.

Підстановочні шаблони
~~~~~~~~~~~~~~~~~~~~~
Підстановочний шаблон (`_`) співпадає взагалі з любим об'єктом. Ми вже бачили, як це використовується по замовчанню, в альтернативі спіймати-всіє:
[source,scala]
----
expr match {
  case BinOp(op, left, right) =>
    println(expr + " is a binary operation")
  case _ => // обробляє випадок за замовчанням
}
----
Підстановки можуть також бути використані для ігнорування частини об'єкта, яка нас не цікавить. Наприклад, попередній приклад насправді не переймається, які елементи є в двомісній операції; він тільки перевіряє, чи це є це двомісною операцією, чи ні. Таким чином, код так само може використовувати підстановочний шаблон для елементів `BinOp`, як показано в Лістингу 15.4.
[source,scala]
----
expr match {
  case BinOp(_, _, _) => println(expr + " is a binary operation")
  case _ => println("It's something else")
}
----
Лістинг 15.4 - Порівняння шаблонів з підстановочними шаблонами.

Шаблони констант
~~~~~~~~~~~~~~~~
Шаблон константи співпадає тільки сам з собою. В якості константи може бути використаний любий літерал. Наприклад, `5`, `true`, `"hello"` всі є шаблонами константами. Також в якості константи може використовуватись любий val або об'єкт синглтон. Наприклад, об'єкт синглтон `Nil` є шаблоном, що співпадає тільки з порожнім списком. Лістинг 15.5 показує деякі приклади шаблонів констант:
[source,scala]
----
def describe(x: Any) = x match {
  case 5 => "five"
  case true => "truth"
  case "hello" => "hi!"
  case Nil => "the empty list"
  case _ => "something else"
}
----
Лістинг 15.5 - Порівняння шаблонів з шаблонами константами.

Ось як порівняння шаблонів, показане в Лістингу 15.5, виглядає в дії:
[source,scala]
----
scala> describe(5)
res6: String = five

scala> describe(true)
res7: String = truth

scala> describe("hello")
res8: String = hi!

scala> describe(Nil)
res9: String = the empty list

scala> describe(List(1,2,3))
res10: String = something else
----

Шаблони змінні
~~~~~~~~~~~~~~
Шаблон змінна співпадає з любим об'єктом, так само як підстановка. Але на відміну від підстановки, Scala прив'язує змінну до цього об'єкту. Потім ви можете використовувати цю змінну, щоб діяти на цьому об'єкті. Наприклад, Лістинг 15.6 показує порівняння шаблонів, що має особливий випадок для нуля, та випадок за замовчанням для всіх інших значень. Випадок за замовченням використовує шаблон змінної, яка надає ім'я значенню, не важливо що це є.
[source,scala]
----
expr match {
  case 0 => "zero"
  case somethingElse => "not zero: " + somethingElse
}
----
Лістинг 15.6 - Порівняння шаблонів з шаблоном змінної.

Змінна або константа?
~~~~~~~~~~~~~~~~~~~~~
Шаблони констант можуть мати символічні імена. Ви вже бачили це, коли ми використовували  `Nil` як шаблон. Ось пов'язаний приклад, де порівняння шаблонів задіє константи `E`(2.71828...) та `Pi` (3.14159...):
[source,scala]
----
scala> import math.{E, Pi}
import math.{E, Pi}

scala> E match {
  case Pi => "дивна математика? Pi = " + Pi
  case _ => "OK"
}
res11: String = OK
----
Як і очікувалось, `E` не дорівнює `Pi`, так що варіант "дивна математика" не використовується.

Як компілятор Scala знає, що `Pi` є константою, імпортаваною з `scala.math`, а не змінна, що сама складає значення селектора? Scala використовує просте лексичне правило для вирішення неоднозначностей: просте ім'я, що починається з літери в нижньому реєстрі приймається як змінна шаблона; Всі інші посилання розглядаються як константи. Щоб побачити різницю, створіть псевдоним в нижньому реєстрі для `pi`, та спробуте виконати таке:
[source,scala]
----
scala> val pi = math.Pi
pi: Double = 3.141592653589793

scala> E match {
  case pi => "strange math? Pi = " + pi
}
res12: String = strange math? Pi = 2.718281828459045
----
Тут компілятор навіть взагалі не дозволить вам додати випадок за замовчанням. Оскільки  `pi` є шаблоном змінної, вона буде співпадати з усіма входами, так що за нею жодний `case` не буде досяжний:
[source,scala]
----
scala> E match {
case pi => "strange math? Pi = " + pi
  case _ => "OK"
}
<console>:12: warning: unreachable code
case _ => "OK"
          ^
----
Ви все ще можете використовувати ім'я в нижньому реєстрі для шаблогів констант, якщо вам так треба, але використовуючи один або два трюки. Перше, якщо константа є полем деякого об'єкта, ви можете поставити перед нею кваліфікатор. Наприклад, `pi` буде шаблоном змінної, але `this.pi` або `obj.pi` будуть константами, навіть якщо вони починаються з літер в нижньому реєстрі. Якщо це не робить (скажімо, тому що `pi` є локальною змінною), альтернативно ви можете оточити ім'я змінної в зворотні дефіси. Наприклад, 
----
`pi`
----
знову буде інтерпретовано як константа, не як змінна:
[source,scala]
----
scala> E match {
  case `pi` => "дивна математика? Pi = " + pi
  case _ => "OK"
}
res14: String = OK
----
Як ви можете бачити, синтаксис з дефісами для ідентифікаторів використовуються в Scala для двох різних призначень, щоб допомогти вам кодувати у ваш спосіб за незвичних обставин. Тут ви бачили, як це використовується для трактування ідентифікатора в нижньому реєстрі як константи в порівнянні шаблонів. Раніше, в Розділі 6.10, ви бачили, що це також може бути використано для трактування ключового слова як звичайного ідентифікатора, тобто, коли ви пишете 
----
Thread.`yield`() 
----
`yield` буде розглядатись як ідентифікатор, не як ключове слово.

Шаблони конструктори
~~~~~~~~~~~~~~~~~~~~
Конструктори є те, де порівняння шаблонів стає дійсно потужним. Шаблоне конструктора виглядє як `BinOp("+", e, Number(0))`. Це складається з імені (`BinOp`), та потім з декількох шаблонів в дужках: `"+"`, `e` та `Number(0)`. Вважаючи, що ім'я означає кейс клас, такий шаблон означає, що спочатку перевіряється, що об'єкт є членом названого кейс класу, та потім перевіряє, що параметри конструктора об'єкта співпадають з наданими додатковими шаблонами.

Ці додаткові шаблони означають, що шаблони Scala підтримують _глибоке порівняння_. Такі шаблони не тільки перевіряють наданий об'єкт високого рівня, але також вміст цього об'єкту щодо подальших шаблонів. Оскільки додаткові шаблони самі можуть бути шаблонами конструкторів, ви можете використовувати їх для перевірки довільної глибини вкладених об'єктів. Наприклад, шаблон, показаний в Лістингу 15.7, перевіряє, що об'єкт вищого рівня є `BinOp`, що його третій параметр конструктора є `Number`, та що значення поля цього числа є `0`. Цей шаблон довжиною в один рядок перевіряє на три рівня в глибину.
[source,scala]
----
expr match {
  case BinOp("+", e, Number(0)) => println("a deep match")
  case _ =>
}
----
Лістинг 15.7 - Порівняння шаблонів з шаблоном конструктора.

Шаблони послідовностей
~~~~~~~~~~~~~~~~~~~~~~
Ви можете порівнювати з типами послідовностей, як `List` або `Array`, так само, як ви порівнюєте з кейс класами. Використовується той самий синтаксис, але тепер ви можете вказати число елементів в шаблоні. Лістинг 15.8 показує шаблон, що перевіряє в пошуках три-елементних списків, що починаються з нуля.
[source,scala]
----
expr match {
  case List(0, _, _) => println("found it")
  case _ =>}
----
Лістинг 15.8 - Шаблон послідовності фіксованої довжини.

Якщо ви бажаєте порівняти з послідовністю, не вказуючи наскільки довгі вони є, ви можете вказати `_*` як останній елемент шаблону. Цей цікаво-виглядаючий шаблон співпадає з любим числом елементів в послідовності, включаючи нуль елементів. Лістинг 15.9 показує приклад, що співпадає з любим списком, що починається з нуля, не важливо які вони за довжиною.
[source,scala]
----
expr match {
    case List(0, _*) => println("found it")
case _ =>
}
----
Лістинг 15.9 - Шаблон послідовності довільної довжини.

Шаблони таплів
~~~~~~~~~~~~~~
Ви можете також порівнювати з таплами. Шаблон як `(a, b, c)` співпадає з довільним 3-таплом. Приклад показаний в Лістингу 15.10.
[source,scala]
----
def tupleDemo(expr: Any) =
  expr match {
    case (a, b, c) => println("matched " + a + b + c)
    case _ =>
  }
----
Лістинг 15.10 - Порівняння шаблонів з шаблоном тапла.

Якщо ви завантажите в інтерпретатор метод `tupleDemo`, показаний в Лістингу 15.10, та передасте до нього тапл з трьох елементів, ви побачите:
[source,scala]
----
scala> tupleDemo(("a ", 3, "-tuple"))
matched a 3-tuple
----
Шаблони типів
~~~~~~~~~~~~~
Ви можете використовувати _шаблон типу_ як зручну заміну для перевірки типу та приведення типів. Лістинг 15.11 показує приклад.
[source,scala]
----
def generalSize(x: Any) = x match {
  case s: String => s.length
  case m: Map[_, _] => m.size
  case _ => -1
}
----
Лістинг 15.11 - Порівняння шаблонів з шаблоном типу.

Ось декілька прикладів виконання `generalSize` в інтерпретаторі Scala:
[source,scala]
----
scala> generalSize("abc")
res16: Int = 3

scala> generalSize(Map(1 -> 'a', 2 -> 'b'))
res17: Int = 2

scala> generalSize(math.Pi)
res18: Int = -1
----
Метод `generalSize` повертає розмір або довжину об'єктів різних типів. Його аргумент має тип `Any`, так що він може мати любе значення. Якщо аргументом є `String`, метод повертає довжину рядка. Шаблон `s: String` є шаблоном типу; він співпадає з кожним (не-null) примірником `String`. Шаблон змінної `s` після співпадіння посилається на цей рядок.

Зауважте, що навіть якщо `s` та `x` посилаються на те саме значення, типом `x` є `Any`, тоді як типом `s` є `String`. Так що ви можете записати `s.length` в виразі альтернативи, що відповідає шаблону, але ви не можете написати `x.length`, оскільки тип `Any` не має члена `length`. Еквівалентний, але більш довготривалий шлях досягти такий самий ефект порівняння з шаблоном типу, включає перевірку типу, за яким слідує перетворення типу. Scala використовує інший синтаксис для цього, ніж Java. Скажімо, щоб протестувати, чи вираз `expr` має тип `String`, ви пишете:
[source,scala]
----
expr.isInstanceOf[String]
----
Щоб привести той самий вираз до типу `String`, ви використовуєте:
[source,scala]
----
expr.asInstanceOf[String]
----
Використовуючи перевірку та приведення типів, ви можете переписати перший `case` попереднього виразу `match`, як показано в Лістингу 15.12.
[source,scala]
----
if (x.isInstanceOf[String]) {
  val s = x.asInstanceOf[String]
  s.length
} else ...
----
Лістинг 15.12 - Використання `isInstanceOf` та `asInstanceOf` (слабкий стиль).

Оператори `isInstanceOf` та `asInstanceOf` розглядаються як передвизначені методи класу `Any`, що приймає параметр типу в прямокутних дужках. Фактично, `x.asInstanceOf[String]` є особливим випадком виклику метода з явним параметром типу `String`.

Як ви, сподіваємось, вже зауважили, написання перевірки та приведення типів є скоріше балакучим в  Scala. Це зроблене навмисно, оскільки ця практика не заохочується. Звичайно ви зробите краще, якщо використаєте порівняння шаблонів з шаблоном типу. Це зокрема вірно, якщо вам треба зробити одночасно перевірку та приведення типу, оскільки обидві операції можна закатати в одне порівняння шаблону.

Другий `case` виразу `match` в Лістингу 15.11 містить шаблон типу `m: Map[_, _]`. Цей шаблон співпадає з любим значенням, що є `Map` деякого довільного типу ключа та значення, да встановлює `m` як посилання на цю мапу. Таким чином, `m.size` гарно типізоване і повертає розмір мапи. Підкреслення в шаблоні типу, footnote:[В шаблоні типу `m: Map[_, _]`, частина `Map[_, _]` називається шаблоном типу.] є подібними до замінників в інших шаблонах. Ви також можете використовувати замість цього змінні типів (в нижньому реєстрі).

Затирання типів
~~~~~~~~~~~~~~~
Чи ви можете також перевірити мапу щодо певних типів елементів? Це може стати в нагоді, скажімо, для перевірки, чи певне значення є мапа з типу `Int` до типу `Int`. Давайте спробуємо:
[source,scala]
----
scala> def isIntIntMap(x: Any) = x match {
  case m: Map[Int, Int] => true
  case _ => false
}
<console>:9: warning: non-variable type argument Int in type
pattern scala.collection.immutable.Map[Int,Int] (the
underlying of Map[Int,Int]) is unchecked since it is
eliminated by erasure
case m: Map[Int, Int] => true
        ^
----
Scala використовує модель затирання дженериків, так само як робить Java. Це означає, що під час виконання немає інформації щодо типів аргументів. Відповідно немає шляху визначити під час виконання, чи об'єкт `Map` був створений з двома аргументами `Int`, скоріше, ніж з двома аргументами інших типів. Все, що може зробити система, це визначити, що значення є Map з довільними типами параметрів. Ви можете перевірити цю поведінку, через застосування `isIntIntMap` до аргументів різних примірників класу `Map`:
[source,scala]
----
scala> isIntIntMap(Map(1 -> 1))
res19: Boolean = true

scala> isIntIntMap(Map("abc" -> "abc"))
res20: Boolean = true
----
Перше застосування повертає `true`, що виглядає коректним, але друге застосування також повертає `true`, що може бути сюрпризом. Щоб попередити вас щодо можливої не-інтуітивної поведінки в рантаймі, компілятор видає попередження, як таке, що ви бачили перед цім.

Одне виключення до правила затирання є масиви, тому що вони обробляються окремо в Java, так само як в Scala. Тип елементів масива зберігається зі значенням масиву, так що ви можете порівнювати шаблони завдяки цьому.

Ось приклад:
[source,scala]
----
scala> def isStringArray(x: Any) = x match {
  case a: Array[String] => "yes"
  case _ => "no"
} 
isStringArray: (x: Any)String

scala> val as = Array("abc")
as: Array[String] = Array(abc)

scala> isStringArray(as)
res21: String = yes

scala> val ai = Array(1, 2, 3)
ai: Array[Int] = Array(1, 2, 3)

scala> isStringArray(ai)
res22: String = no
----
Прив'язування змінних
~~~~~~~~~~~~~~~~~~~~~
На додаток до окремих шаблонів змінних, ви також можете додати змінну до любого іншого шаблону. Ви просто пишете ім'я змінної, знак `@`, та потім шаблон. Це дає вам шаблон з прив'язуванням змінної, що означає, що шаблон порівнюється як звичайно, і якщо співпадіння успішне, встановлює змінну в співпадаючий об'єкт, так само, як при звичайному шаблоні змінної.

Як приклад, Лістинг 15.13 показує порівняння шаблонів, що шукає операцію абсолютного значення, яке застосоване два рази поспіль. Такі вирази можуть бути спрощені, щоб брати абсолютне значення тільки один раз.
[source,scala]
----
expr match {
  case UnOp("abs", e @ UnOp("abs", _)) => e
  case _ =>
}
----
Лістинг 15.13 - Шаблон з прив'язуванням змінної (через знак @).

Приклад, показаний в Лістингу 15.13, включає шаблон  прив'язування змінної, з `e` в якості змінної, та `UnOp("abs", _)` в якості шаблону. Якщо співпадіння цілого шаблону буде успішним, тоді частина, що співпадає з `UnOp("abs", _)`, буде доступна як змінна `e`. Результатом `case` є сама `e`, оскільки `e` має те саме значення, що і `expr`, але меньше на одну операцію абсолютного значення.

15.3 Захисники шаблонів
-----------------------
Іноді синтаксичне порівняння шаблонів не є достатеьо точним. Скажімо, наприклад, ви має завдання сформулювати правило спрощення, що представляє вирази суми з двома однаковими операндами, такі як `e + e`, як множення на два (тобто, `e * 2`). В мові дерев `Expr` вираз як:
[source,scala]
----
BinOp("+", Var("x"), Var("x"))
----
може бути трансформована цім правилом до:
[source,scala]
----
BinOp("*", Var("x"), Number(2))
----
Ви можете спробувати виразити це правило таким чином:
[source,scala]
----
scala> def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, x) => BinOp("*", x, Number(2))
  case _ => e
}
<console>:14: error: x is already defined as value x
case BinOp("+", x, x) => BinOp("*", x, Number(2))
                   ^
----
Це схибить, оскільки Scala обмежує шаблони до лінійності: змінна шаблона може з'являтись в шаблоні тільки один раз. Однак, ви можете пере-формулювати `match` за допомогою захисника шаблона, як показано в Лістингу 15.14:
[source,scala]
----
scala> def simplifyAdd(e: Expr) = e match {
  case BinOp("+", x, y) if x == y => BinOp("*", x, Number(2))
  case _ => e
}
simplifyAdd: (e: Expr)Expr
----
Лістинг 15.14 - Вираз `match` з захисником шаблону.

Захисник шаблону іде після шаблону, та починається з `if`. Захисник може бути довільним логічним виразом, що звичайно посилається на змінні в шаблоні. Якщо захисник шаблону присутній, `match` буде успішним тільки якщо захисник обчислюється до `true`. Таким чином, перший `case` вище буде співпадати тільки з двомісними операціями з двома однаковими операндами.
 
Деякі інші приклади захищених шаблонів:
[source,scala]
----
// співпадає тільки з додатними цілими
case n: Int if 0 < n => ...

// співпадає тільки з рядками, що починаються на літеру 'a'
case s: String if s(0) == 'a' => ...
----
15.4 Перекриття шаблонів
------------------------
Шаблони випробовуються в порядку, в якому вони записані. Версія `simplify`, показана в Лістингу 15.15, представляє приклад, де порядок `case` має значення.
[source,scala]
----
def simplifyAll(expr: Expr): Expr = expr match {
  case UnOp("-", UnOp("-", e)) => 
    simplifyAll(e) // '-' подвійна інверсія
  case BinOp("+", e, Number(0)) => 
   simplifyAll(e) // '0' є нейтральним елементом для '+'
  case BinOp("*", e, Number(1)) =>
    simplifyAll(e) // '1' є нейтральним елементом для `*'
  case UnOp(op, e) =>
    UnOp(op, simplifyAll(e))
  case BinOp(op, l, r) =>
    BinOp(op, simplifyAll(l), simplifyAll(r))
  case _ => expr
}
----
Лістинг 15.15 - Вираз `match`, в якому порядок `case` має значення.

Версія `simplify`, показана в Лістингу 15.15, буде застосовувати правила спрощення будь-де в виразі, не тільки на вищому рівні, як робив `simplifyTop`. Він може походити від `simplifyTop` через додавання ще двох випадків для узагальнених одно- та дво-місних виразів (випадки чотири та п'ять в Лістингу 15.15).

Четвертий випадок має шаблон `UnOp(op, e)`; тобто, від співпадає з кожною одномісною операцією. Оператор та операнд одномісної операції можуть бути довільними. Вони прив'язуються до змінних шаблону, `op` и `e`, відповідно. Альтернатива в цьому `case` застосовує `simplifyAll` рекурсивно до операнда `e`, та потім перебудовує ту саму одномісну операцію з (можливо) спрощеним операндом. П'ятий `case` для `BinOp` є аналогічним: це випадок "спіймати-все" `case` для довільних двомісних операцій, що рекурсивно застосовує метод спрощення до своїх двох операндів.

В цьому прикладі є важливим, що випадкі спіймати-всі ідуть після більш специфічних правил спрощення. Якщо ви запишете їх в іншому порядку, тоді випадок спіймати-всі мав би виконуватись раніше, ніж специфічні випадки. В багатьох випадках компілятор навіть буде скаржитись, якщо ви спробуєте. Наприклад, ось вираз `match`, що не компілюється, оскілький перший `case` буде співпадати з усім, з чим може співпасти другий `case`:
[source,scala]
----
scala> def simplifyBad(expr: Expr): Expr = expr match {
         case UnOp(op, e) => UnOp(op, simplifyBad(e))
         case UnOp("-", UnOp("-", e)) => e
       }
<console>:21: warning: unreachable code
      case UnOp("-", UnOp("-", e)) => e
                                      ^
----
15.5 Закорковані класи
----------------------
Коли б ви не писали порівняння шаблонів, вам треба переконатись, що ви розглянули всі можливі випадки. Іноді ви можете зробити це через додавання випадку за замовчанням до кінця `match`, але це має сенс, якщо існує доцільна поведінка за замовчанням. Що ви робитимете, якщо немає такого замовчання? Як ви будете почуватись впевнено, що покрили всі випадки?

Ви можете отримати допомогу від Scala компілятора в визначенні пропущених комбінацій шаблонів в виразі `match`. Щоб зробити це, компілятор має бути в змозі сказати, які випадки є можливими. Загалом це неможливо в Scala, оскільки нові кейс класи можуть бути визначені в любий момент, та в довільних одиниціх компіляції. Наприклад, ніщо не завадить вам додати п'ятий кейс клас до ієрархії класу `Expr` в іншій одиниці компіляції, ніж та, де були визначені інші чотири випадки.

Альтернативою є зробити суперклас вашого кейс класу закоркованим. Закоркований клас не може мати жодних субкласів, ніж ті, що знаходяться з мим в одному файлі. Це дуже корисно для порівняння шаблонів, оскільки це означає, що вам треба турбуватись тілкьи про субкласи, про які ви вже знаєте. Ще більше, ви також маєте більше підтримки з боку компілятора. Якщо ви порівнюєте кейс класи, що походять від закоркованого класу, компілятор буде помічати відсутні комбінації шаблонів повідомленнями попереджень.

Якщо ви пишете ієрархію класів, призначених для порівняння шаблонів, ви маєте зробити їх закоркованими. Просто покладіть ключове слово `sealed` перед `class` зверху ієрархії. Програмісти, що використовують вашу ієрархію класів, після цього будуть почуватись зручно з порівнянням шаблонів. Таким чином, ключове слово `sealed` часто є ліцензією для порівняння шаблонів. Лістинг 15.16 показує приклад, в якому `Expr` перетворено на закоркований клас.
[source,scala]
----
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
  left: Expr, right: Expr) extends Expr
----
Лістинг 15.16 - Закоркована ієрархія кейс класів.

Тепер визначимо порівняння шаблонів, де пропущені деякі можливі варіанти:
[source,scala]
----
def describe(e: Expr): String = e match {
  case Number(_) => "a number"
  case Var(_) => "a variable"
}
----
Ви отримаєте попередження компілятора, подібне до наступного:
----
warning: match is not exhaustive!
missing combination           UnOp
missing combination          BinOp
----
Паке попередження каже вам, що існує ризик що ваш код може продукувати виключення `MatchError`, оскільки деякі можливі шаблони (`UnOp`, `BinOp`) не оброблені. Попередження вказує на потенційне джерело збоїв під час виконання, так що це звичайно гарна допомога, щоб зробити ваш код вірним.

Однак, часом ви можете натрапити на ситуацію, коли компілятор дуже прискіпливий, видаючи попередження. Наприклад, ви можете знати з контексту, що ви будете застосовувати описаний вище метод до виразів, що є або `Numbers` або `Vars`, так що ви знаєте, що він не спродукує `MatchError`. Щоб повідомлення пішло, ви можете додати третій випадок спіймати-всі до цього метода, ось так:
[source,scala]
----
def describe(e: Expr): String = e match {
  case Number(_) => "a number"
  case Var(_) => "a variable"
  case _ => throw new RuntimeException // Не має трапитись
}
----
Це робить, але це не ідеальне. Ви, можливо, не будете дуже щасливі, коли будете змушені додати код, якій ніколи не буде виконуватись (або ви так думаєте), просто попросивши компілятор помовчати.

Більш полегшена альтернатива є додати анотацію `@unchecked` до вираза селектора в `match`. Це робиться таким чином:
[source,scala]
----
def describe(e: Expr): String = (e: @unchecked) match {
  case Number(_) => "a number"
  case Var(_) => "a variable"
}
----
Анотації описані в Главі 27. Загалом, ви можете додати анотацію до виразу в той самий спосіб, як ви додаєте тип: за виразом слідують дві крапки і ім'я анотації (зі знаком '@'). Наприклад, в цьому випадку ви додаєте анотацію `@unchecked` до змінної `e` за допомогою `e: @unchecked`. Анотація `@unchecked` має особливе значення для порівняння шаблонів. Якщо селектор `match`має цю анотацію, всебічна перевірка шаблону, що слідує, буде придушена.

15.6 Тип Option
---------------
Scala має стандартний тип на ім'я `Option` для опціональних значень. Таке значення може бути в двох формах: `Some(x)`, де `x` є дійсним значенням, або об'єкт `None`, що представляє відсутність значення.

Опціональні значення продукуються деякими зі стандартних операцій для колекцій Scala. Наприклад, метод `get` зі Scala `Map` продукує `Some(value)`, якщо значення, відповідне до наданого ключа, було знайдене, або `None`, якщо наданий ключ не визначений в `Map`. Ось приклад:
[source,scala]
----
scala> val capitals = 
          Map("France" -> "Paris", "Japan" -> "Tokyo")
capitals: scala.collection.immutable.Map[String,String] =
Map(France -> Paris, Japan -> Tokyo)

scala> capitals get "France"
res23: Option[String] = Some(Paris)

scala> capitals get "North Pole"
res24: Option[String] = None
----
Найбільш загальний шлях прийняти опціональні значення окремо - через порівняння шаблонів. Наприклад:
[source,scala]
----
scala> def show(x: Option[String]) = x match {
         case Some(s) => s
         case None => "?"
       }
show: (x: Option[String])String

scala> show(capitals get "Japan")
res25: String = Tokyo

scala> show(capitals get "France")
res26: String = Paris

scala> show(capitals get "North Pole")
res27: String = ?
----
Тип `Option` часто використовується в програмах Scala. Порівняйте це з домінуючою ідіомою Java, використовувати `null` для вказання відсутності значення. Наприклад, метод `get` в `java.util.HashMapreturns` повертає або значення, що зберігається в `HashMap`, або `null`, якщо значення не знайдене. Цей підхід робить для Java, але схильний до помилок, оскільки на практиці складно відстежувати, які змінні в програмі можуть приймати значення `null`.

Якщо змінній дозволено бути `null`, тоді ви маєте пам'ятати перевіряти її на `null` кожного разу, коли ви використосуєте її. Якщо ви забудете перевірити, ви відкриєте можливість, щоб під час виконання отримати `NullPointerException`. Оскільки такі виключення не можуть траплятись дуже часто, може бути складно визначити помилку під час тестування. Для Scala цей підхід не робить взагалі, оскільки можливо зберігати значення типів в хеш мапах, але `null` не є легальним елементом для типу значення. Наприклад, `HashMap[Int, Int]` не може повертати `null` для позначення "нема елементу".

Для контрасту Scala заохочує використання `Option` для індикації опціонального значення. Цей підхід до опціональних значень має декілька переваг над Java. Перше, це значно більш очевидне для читачів коду, що змінна, чий тип `Option[String]` є опціональний `String`, ніж змінна типу `String`, що може інколи бути `null`. Але більш важливо, що описана раніше помилка програмування, щодо використання змінної, що може бути `null` без попередньої перевірки її на `null`, в Scala стає помилкою типу. Якщо змінна має тип `Option[String]`, і ви намагаєтесь використовувати її як `String`, ваша Scala програма не буде компілюватись.

15.7 Шаблони кругом
-------------------
Шаблони дозволені в багатьох частинах Scala, не тільки в окремих виразах `match`. Погляньте на деякі інші місця, де ви можете використовувати шаблони.

Шаблони в присвоєнні змінних
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Кожного разу, коли ви визначаєте `val` або `var`, ви можете використовувати шаблон замість простого ідентифікатора. Наприклад, ви можете розібрати тапл на частини, та присвоїти кожній з частин свою власну змінну, як показане в Лістингу 15.17:
[source,scala]
----
scala> val myTuple = (123, "abc")
myTuple: (Int, String) = (123,abc)

scala> val (number, string) = myTuple
number: Int = 123
string: String = abc
----
Лістинг 15.17 - Визначення декількох змінних одним присвоєнням.

Ця конструкція досить корисна, коли робите з кейс класами. Якщо ви точно знаєте кейс клас, з яким ви працюєте, тоді ви можете деконструювати його в шаблоні. Ось приклад:
[source,scala]
----
scala> val exp = new BinOp("*", Number(5), Number(1))
exp: BinOp = BinOp(*,Number(5.0),Number(1.0))

scala> val BinOp(op, left, right) = exp
op: String = *
left: Expr = Number(5.0)
right: Expr = Number(1.0)
----
Послідовності `сase` як часткові функції
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Послідовність випадків (тобто альтернативи) в фігурних дужках можуть бути використані будь-де, де може бути використаний функціональний літерал. В основному послідовність `case` є функціональним літералом. Змість мати одну точку входу та список параметрів, `case` послідовність має декілька точок входу, кожна зі своїм списком параметрів. Кожний `case` є точкою входу до функції, та параметри задаються шаблоном. Тіло кожної точки входу є правою стороною `case`.

Ось простий приклад:
[source,scala]
----
val withDefault: Option[Int] => Int = {
  case Some(x) => x
  case None => 0
}
----
Тіло цієї функції має два `case` випадки. Перший `case` співпадає з `Some`, та повертає число в `Some`. Другий `case` співпадає з `None`, та повертає значення за замовчанням, нуль. Ось ця функція в дії:
[source,scala]
----
scala> withDefault(Some(10))
res28: Int = 10

scala> withDefault(None)
res29: Int = 0
----
Ця можливість досить корисна для бібліотеки акторів Akka, оскільки вона дозволяє її методу `receive` бути визначеним як послідовність `cases`:
[source,scala]
----
var sum = 0
def receive = {
  case Data(byte) =>
    sum += byte
  case GetChecksum(requester) =>
    val checksum = ~(sum & 0xFF) + 1
    requester ! checksum
}
----
Ще одне узагальнення нічого не коштує: послідовність випадків дає вам _часткову функцію_. Якщо ви застосуєте таку функцію до значення, яке вона не підтримує, вона згенерує виключення часу виконання. Наприклад, ось часткова функція, що повертає другий елемент зі списку цілих:
[source,scala]
----
val second: List[Int] => Int = {
  case x :: y :: _ => y
}
----
Коли ви компілюєте це, компілятор буде коректно попереджати, що порівняння не є вичерпним:
----
<console>:17: warning: match is not exhaustive!
missing combination
Nil
----
Ця функція буде успішною, якщо ви передасте список з трьох елементів, але ні, якщо ви передасте порожній список:
[source,scala]
----
scala> second(List(5, 6, 7))
res24: Int = 6

scala> second(List())
scala.MatchError: List()
      at $anonfun$1.apply(<console>:17)
      at $anonfun$1.apply(<console>:17)
----
Якщо ви бажаєте перевірити, чи часткова функція визначена, ви повинні спочатку сказати компілятору, що ви знаєте, що робите з частковими функціями. Тип `List[Int] => Int` включають всі функції зі списків цілих до цілих, чи є вони частковими, чи ні. Тип, що включає тільки часткові функції з масива цілих до цілих, записується `PartialFunction[List[Int],Int]`. Ось знову друга функція, на цей раз написана як тип часткової функції:
[source,scala]
----
val second: PartialFunction[List[Int],Int] = {
  case x :: y :: _ => y
}
----
Часткові функції мають метод `isDefinedAt`, що може бути використана для тестування, чи функція визначена на певному значенні. В цьому випадку функція визначена для кожного списку, що мають щонайменше два елементу:
[source,scala]
----
scala> second.isDefinedAt(List(5,6,7))
res30: Boolean = true

scala> second.isDefinedAt(List())
res31: Boolean = false
----
Типовий приклад часткової функції є функціональний літерал порівняння шаблону, як той з попереднього прикладу. Фактично, такий вираз транслюється компілятором Scala на часткову функцію, через транслювання шаблону двічі — один раз для реалізації справжньої функції, та ще раз, щоб перевірити, чи функція визначена, чи ні.

Наприклад, функціональний літерал `{ case x :: y :: _ => y }` буде трансльований до наступного значення часткової функції:
[source,scala]
----
new PartialFunction[List[Int], Int] {
  def apply(xs: List[Int]) = xs match {
    case x :: y :: _ => y
  }
  def isDefinedAt(xs: List[Int]) = xs match {
    case x :: y :: _ => true
    case _ => false
  }
}
----
Ця трансляція набуває ефекту, кожного разу, коли декларований тип функціонального літералу є `PartialFunction`. Якщо декларований тип є тільки `Function1`, або він відсутній, функціональний літерал замість цього транслюється до повної функції.

Загалом, ви повинні намагатись робити з повними функціями, коли це можливо, оскільки використання часткових функцій дозволяє помилки часу виконання, з якими компілятор не може вам допомогти. З іншого боку, часткові функції часом дійсно корисні. Ви можете бути впевнені, що необроблене значення ніколи не буде надане. Альтернативно, ви можете використовувати фреймворк, що отримує часткові функції, і, таким чином, завжди буде перевіряти `isDefinedAt` перед викликом функції. Приклад останнього є приклад `receive`, наданий вище, де аргумент є частково визначеною функцією, визначена в точності для тих повідомлень, що викликаючий бажає обробити.

Шаблони в `for` виразах
~~~~~~~~~~~~~~~~~~~~~~~
Ви також можете використовувати шаблон в `for` виразі, як показано в Лістингу 15.18. Цей `for` вираз отримує пари ключ/значення мапи `capitals`. Кожна пара порівнюється з шаблоном `(country, city)`, що визначає дві змінні, `country` та `city`.
[source,scala]
----
scala> for ((country, city) <- capitals)
println("The capital of " + country + " is " + city)
The capital of France is Paris
The capital of Japan is Tokyo
----
Лістинг 15.18 - Вираз `for` з шаблоном таплом.

Шаблон пари, показаний в Лістингу 15.18 був особливий, оскільки порівняння з ним ніколи не може схибити. Зрозуміло, що `capitals` видає послідовність пар, так що ви можете бути певні, що кожна згенерована пара може бути порівняна з шаблоном пари. Але так само можливо, що шаблон може не співпасти зі згенерованим значенням. Лістинг 15.19 показує приклад, де відбувається саме це.
[source,scala]
----
scala> val results = List(Some("apple"), None, Some("orange"))
results: List[Option[String]] = List(Some(apple), None, Some(orange))

scala> for (Some(fruit) <- results) println(fruit)
apple
orange
----
Лістинг 15.19 - Обирання елементів списку, що співпадають з шаблоном.

Як ви можете бачити з цього прикладу, згенеровані значення, що не співпадають з шаблоном, будуть відкинуті. Наприклад, другий елемент `None` є результатом списку, що не співпадає з шаблоном `Some(fruit)`; таким чином, він не показаний на виході.

15.8 Більший приклад
--------------------
Після навчання різним формам шаблонів, ви можете бути зацікавлені побачити їх застосування в більшому прикладі. Запропоноване завдання є написати клас форматування виразів, що відображує арифметичні вирази в двомірному розташуванні. Ділення, такі як `x / (x + 1)` має друкуватись вертикально, через розташування чисельника зверху займенника, ось так:
----
   x
 -----
 x + 1
----
Як інший приклад, ось приклад `((a / (b * c) + 1 / n) / 3)` в двовимірному розташуванні:
----
   a     1
 ----- + -
 b * c   n
 ---------
     3
----
З ціх прикладів виглядає, що клас (назвемо його `ExprFormatter`) буде мати справу з жонглюванням розміткою, так що має сенс використовувати бібліотеку розташування, розроблену в Главі 10. Ми також будемо використовувати сімейство кейс класів `Expr`, який ми бачили раніше в цій главі, та покладемо обоє, бібліотеку розташування з Глави 10 та форматування виразів з цієї глави в іменовані пакунки. Повний код приклада буде показаний в Лістингу 15.20 та 15.21.

Корисний перший крок є концентрація на горизонтальному розташуванні. Стуруктурований вираз, як:
----
BinOp("+",
  BinOp("*",
    BinOp("+", Var("x"), Var("y")),
      Var("z")),
  Number(1))
----
має друкувати `(x + y) * z + 1`. Зауважте, що дужки необхідні навколо `x + y`, але можуть бути опціональними навколо `(x + y) * z`. Щоб утримувати розташування як можливо стислішим, вашею ціллю має бути уникати дужок, коли вони надлишкові, при цьому переконавшись, що всі потрібні дужки присутні.

Щоб знати, де треба поставити дужки, код має знати щодо відносних преоритетов кожного оператора, так що є гарною ідеєю спочатку поладнати це. Ви можете виразити відносні преоритети напряму, як літеральна мапа наступної форми:
[source,scala]
----
Map(
  "|" -> 0, "||" -> 0,
  "&" -> 1, "&&" -> 1, ...
)
----
Однак це може включати деяку кількість обчислень преоритетов з вашого боку. Більш зручний підхід є просте визначення груп операторів зі збільшенням преоритетів, та потім обчислювати преоритети кожного оператора на цій основі. Лістинг 15.20 показує код.
[source,scala]
----
package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem

sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
    left: Expr, right: Expr) extends Expr

class ExprFormatter {
// Містить оператори в групах за збільшенням преоритету
  private val opGroups =
    Array(
      Set("|", "||"),
      Set("&", "&&"),
      Set("^"),
      Set("==", "!="),
      Set("<", "<=", ">", ">="),
      Set("+", "-"),
      Set("*", "%")
    )
// Відзеркалення операторів на їх преоритети
  private val precedence = {
    val assocs =
      for {
        i <- 0 until opGroups.length
        op <- opGroups(i)
      } yield op -> i
    assocs.toMap
  }

  private val unaryPrecedence = opGroups.length
  private val fractionPrecedence = -1
// продовження в Лістингу 15.21...
----
Лістинг 15.20 - Верхня частина форматувальника виразів.

[source,scala]
----
// ...продовження Лістингу 15.20
import org.stairwaybook.layout.Element

private def format(e: Expr, enclPrec: Int): Element =
  e match {
    case Var(name) =>
      elem(name)

    case Number(num) =>
      def stripDot(s: String) =
        if (s endsWith ".0") s.substring(0, s.length - 2)
        else s
      elem(stripDot(num.toString))

    case UnOp(op, arg) =>
      elem(op) beside format(arg, unaryPrecedence)

    case BinOp("/", left, right) =>
      val top = format(left, fractionPrecedence)
      val bot = format(right, fractionPrecedence)
      val line = elem('-', top.width max bot.width, 1)
      val frac = top above line above bot
      if (enclPrec != fractionPrecedence) frac
      else elem(" ") beside frac beside elem(" ")

    case BinOp(op, left, right) =>
      val opPrec = precedence(op)
      val l = format(left, opPrec)
      val r = format(right, opPrec + 1)
      val oper = l beside elem(" " + op + " ") beside r
      if (enclPrec <= opPrec) oper
      else elem("(") beside oper beside elem(")")
  }

  def format(e: Expr): Element = format(e, 0)
}
----
Лістинг 15.21 - Нижня частина форматувальника виразів.

Змінна `precedence` є мапою від операторів на їх преоритети, що є цілими, починаючи з 0. Вони обчислюються в виразі `for` з двома генераторами. Перший генератор продукує кожний індекс `i` для масиву `opGroups`. Другий генератор продукує кожний оператор `op` в `opGroups(i)`. Для кожного такого оператора вираз `for`видає асоціацію від оператора `op` на його індекс `i`. Таким чином, відносна позиція оператора в масиві береться як його преоритет.

Асоціації записані як інфіксна стрілка, `op -> i`. Так що ви бачите асоціації тільки як частину конструкції мапи, але вони також є значеннями сами по собі. Фактично, асоціація `op -> i` є нічим іншим, ніж парою `(op, i)`.

Тепер, коли ви поладнали преоритети всіх двомісних операторів, крім `/`, має сенс узагальнити цю концепцію, що також покриває одномісні оператори. Преоритети одномісних операторів вищі, ніж преоритет кожного двомісного оператора. Таким чином ми можете встановити `unaryPrecedence` (показане в Лістингу 15.20) в довжину масива `opGroups`,що на один більше, ніж преоритет операторів `*` та `%`. Преоритет дробі трактується інакше від інших операторів, оскількі дріб використовує вертикальне розташування. Однак, це буде зручним, присвоїти оператору ділення особливий преоритет зі значенням -1, так що ми будемо ініціалізувати `fractionPrecedence` в -1 (показане в Лістингу 15.20).

Після ціх підготувань ви готові написати головний метод форматування. Цей метод приймає два аргумента: вираз `e`, типу `Expr`, та преоритет `enclPrec` оператора напряму оточуючого виразу `e`. (Якщо нема оточуючого оператора, `enclPrec` повинне бути нулем). Метод видає елемент розташування, що представляє двомірний масив символів.

Лістинг 15.21 показує залишок класу `ExprFormatter`, що включає три метода. Перший метод, `stripDot`, є допоміжним методом. Наступний метод, приватний метод `format`, робить більшість роботи по форматуванню виразів. Останній метод, також названий `format`, є єдиним публічним методом в бібліотеці, що приймає вираз, який треба форматувати. Приватний метод `format` робить свою роботу, виконуючи порівняння шаблонів на різновиді виразу. Вираз `match` має п'ять випадків `case`. Ми обговоримо кожний `case` окремо.

Перший case є:
[source,scala]
----
case Var(name) =>
  elem(name)
----
Якщо вираз є змінна, результат є елементом, сформованим з імені змінної.

Другмй вираз є:
[source,scala]
----
case Number(num) =>
  def stripDot(s: String) =
    if (s endsWith ".0") s.substring(0, s.length - 2)
    else s
  elem(stripDot(num.toString))
----
Якщо вираз є числом, результат є елементом, сформованим зі значення числа. Функція `stripDot` очищує вигляд чисел з плаваючою крапкою, відкидаючи любі суфікси `".0"` з рядка.

Третій випадок наступний:
[source,scala]
----
case UnOp(op, arg) =>
  elem(op) beside format(arg, unaryPrecedence)
----
Якщо вираз є одномісною операцією `UnOp(op, arg)`, результатом буде сформований з операнда `op` та результата форматування аргумента `arg` з найвищим-можливим преоритетом оточення.footnote:[Значення `unaryPrecedence` є найвищим можливим преоритетом, оскільки він ініціалізований на один більше, ніж преоритет операторів `*` та `%`.] 

Це означає, що якщо `arg` є двомісною операцією (але не дрібом), вона завжди буде відображатись в дужках.

Четвертий випадок `case`:
[source,scala]
----
case BinOp("/", left, right) =>
  val top = format(left, fractionPrecedence)
  val bot = format(right, fractionPrecedence)
  val line = elem('-', top.width max bot.width, 1)
  val frac = top above line above bot
  if (enclPrec != fractionPrecedence) frac
  else elem(" ") beside frac beside elem(" ")
----
Якщо вираз є дробом, проміжний результат `frac` формується через розміщення форматованих операндів `left` та `right` зверху один одного, розділені елементом горизонтальної лінії. Ширина `width` горизонтальної лінії є максимум з ширин форматованих операндів. Цей проміжний результат є також фінальним результатом, тільки якщо дріб сам не з'являється як аргумент в іншій дробі. В останньому випадку з кожного боку `frac` додаються проміжки. Щоб зрозуміти чому, розглянемо вираз `(a / b) / c`.

Без корекції ширини форматування цього виразу буде давати:
----
 a
 -
 b
 -
 c
----
Пробелма з таким форматуванням є доказ — незрозуміло, де є риска вищого рівня. Вираз вище може означати або `(a / b) / c`, або `a / (b / c)`. Щоб вирішити неоднозначність, треба додати проміжки до кожної сторони розташування вкладеного дробу `a / b`. Тоді розташування стає однозначним:
----
  a
  -
  b
 ---
  c
----
П'ятий, та останній, `case`:
[source,scala]
----
case BinOp(op, left, right) =>
  val opPrec = precedence(op)
  val l = format(left, opPrec)
  val r = format(right, opPrec + 1)
  val oper = l beside elem(" " + op + " ") beside r
  if (enclPrec <= opPrec) oper
  else elem("(") beside oper beside elem(")")
----
Цей випадок стосується всіх інших двомісних операндів. Оскільки він іде після випадку, що починається як:
[source,scala]
----
case BinOp("/", left, right) => ...
----
ви знаєте, що оператор `op` в шаблоні `BinOp(op, left, right)` не може бути діленням. Щоб форматувати таку двомісну операцію, вам знадобиться спочатку форматувати її операнди `left` та `right`. Параметр преоритету для форматування лівого операнда є преоритет `opPrec` оператора `op`, тоді як для правого операнда він на один більше. Така схема гарантує, що дужки також відображають коректну асоциативність.

Наприклад, операція:
[source,scala]
----
BinOp("-", Var("a"), BinOp("-", Var("b"), Var("c")))
----
буде коректно оточена дужками, як "a - (b - c)". Проміжний результат `oper` потім формується через розміщення форматованих операндів `left` та `right` поряд, розділених оператором. Якщо преоритет поточного оператора менше, ніж преоритет оточуючого оператора, `oper` покладається між дужками; інакше він повертається як є.
[source,scala]
----
import org.stairwaybook.expr._

object Express extends App {

  val f = new ExprFormatter

  val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),
                      BinOp("+", Var("x"), Number(1)))

  val e2 = BinOp("+", BinOp("/", Var("x"), Number(2)),
                      BinOp("/", Number(1.5), Var("x")))

  val e3 = BinOp("/", e1, e2)

  def show(e: Expr) = println(f.format(e)+ "\n\n")

  for (e <- Array(e1, e2, e3)) show(e)
}
----
Лістинг 15.22 - Застосування, що друкує форматовані вирази.

Це завершує розробку приватної функції `format`. Єдиний залишений метод є публічний метод `format`, що дозволяє програмістам клієнтів форматувати високорівневі вирази, не передаючи аргумент преоритетів. Лістинг 15.22 показує демо програму, що випробовує `ExprFormatter`.

Зауважте, що навіть хоча ця програма не містить метод, вона все ще виконується, оскільки вона наслідує від трейту App. Ви можете виконувати програму `Express` такою командою:
[source,scala]
----
scala Express
----
Це буде тавати наступний вивід:
----
 1
 - * (x + 1)
 2

 x   1.5
 - + ---
 2    x

  1
  - * (x + 1)
  2 
 -----------
   x   1.5
   - + ---
   2    x
----

15.9 Висновок
-------------
В цій главі ви детально навчились щодо кейс класів та порівняння шаблонів. Використовуючи це, ви можете отримати переваги від декількох стислих ідіом, звичайно недоступних в об'єктно-орієнтовних мовах. Однак порівняння шаблонів в Scala іде далі, ніж описане в цій главі. Якщо ви бажаєте використати порівняння шаблонів на одному з ваших класів, але ви не бажаєте відкривати доступ до ваших класів в спосіб, як це роблять кейс класи, ви можете використовувати екстрактори, описані в Главі 26. В наступній главі ми звернемо нашу увагу на списки.