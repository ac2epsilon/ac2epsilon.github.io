include::headers.adoc[]

Глава 11
--------

Ієрархія Scala
==============

Тепер, коли ви бачили деталі наслідування класів в попередньому розділі, настав гарний час зробити крок назад, та подивитись на ієрархію класів в цілому. В Scala кожний клас наслідує від загального суперкласа на ім'я `Any`. Оскільки кожний клас є субкласом `Any`, методи, визначені в `Any` є "універсальними" методами: вони можуть бути викликані на любих об'єктах. Scala також визначає деякі цікаві класи знизу ієрархії, `Null` та `Nothing`, що, загалом, діють як загальні субкласи. Наприклад, так само, як `Any` є суперкласом для кожного іншого класу, `Nothing` є субкласом кожного іншого класа. В цій главі ми надамо вам тур по ієрархії класів Scala.

11.1 Ієрархія класів Scala
--------------------------
Малюнок 11.1 показує контур ієрархії класів Scala. Нагорі ієрархії класів знаходиться клас `Any`, що визначає методи, включаючі наступні:
[source,scala]
----
final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def ##: Int
def hashCode: Int
def toString: String
----
Оскільки кожний клас наслідує від `Any`, кожний об'єкт в програмі Scala може бути порівняні з використанням `==`, `!=`, або `equals`; хешовані з використанням `##` або `hashCode`; та форматовані з використанням `toString`. Методи рівності або нерівності, `==` та `!=` декларовані як фінальні в класі `Any`, так що вони не можуть бути перекриті в субкласах. Метод `==` загалом те саме, що і `equals`, та `!=` завжди протилежність до `equals`.footnote:[Один випадок, коли `==` напряму не викликає `equals`, це для боксованих числових класів Java, такіх, як `Integer` або `Long`. В Java `new Integer(1)` не еквівалентне як `equal` до `new Long(1)`, навіть не зважаючи, що для примітивів `1 == 1L`. Оскільки Scala є більш регулярною мовою, ніж Java, було необхідним скорегувати цю невідповідність через особливий метод == для ціх класів. Подібно, метод `##` провадить Scala версію хешування, що така сама, як і Java `hashCode`, за винятко боксованих числових типів, де він робить узгоджено з `==`. Наприклад, `new Integer(1)` та `new Long(1)` хешуються `##` однаково, не зважаючи на те, що в Java їх `hashCode` різні.] Так що індивідуальні класи можуть вирішувати, що означає `==` або `!=` через перекриття метода `equals`. Ми покажемо приклад пізніше в цій главі.

Ієрархія класів в Scala.
------------------------
Кореневий клас `Any` має два субкласи: `AnyVal` та `AnyRef`. `AnyVal` є батьківським класом для класів значень в Scala. Хоча ви можете визначити ваші власні класи значень (дивіться Розділ 11.4), існують дев'ять класів значень, вбудованих в Scala: `Byte`, `Short`, `Char`, `Int`, `Long`, `Float`, `Double`, `Boolean`, `Unit`. Перші вісім з них відповідають примітивним класам Java, та їх значення представлені під час виконання як примітивні значення Java. Примірники ціх класів всі написані як літерали в Scala. Наприклад, `42` є примірником of `Int`, `'x'` є примірником `Char`, та `false` примірник `Boolean`. Ви не можете створити примірники ціх класів використовуючи `new`. Це досягається "трюком", так що класи значень всі визначені одночасно абстрактними та фінальними.

Так що якщо ви запишете:
[source,scala]
----
scala> new Int
----
ви отримаєте:
[source,scala]
----
<console>:5: error: class Int is abstract; cannot be
instantiated
       new Int
       ^
----
Інший клас значення, `Unit`, грубо відповідає до типу Java `void`; він використовується як тип результате метода, що інакше не повертає цікавого результата. `Unit` має єдине значення примірника, що записується `()`, як обговорюється в Розділі 7.2.

Як пояснюється в Главі 5, класи значення підтримують звичайні арифметичні та логічні оператори, як методи. Наприклад, `Int` має методи на ім'я `+` та `*`, та `Boolean` має методи на ім'я `||` та `&&`. Класи значень також наслідують всі методи від класу `Any`. Ви можете протестувати це в інтерпретаторі:
[source,scala]
----
scala> 42.toString
res1: String = 42

scala> 42.hashCode
res2: Int = 42

scala> 42 equals 42
res3: Boolean = true
----
Зауважте, що простір класів значень плаский; всі класи значень є субтипами `scala.AnyVal`,але вони не є субкласами один одного. Замість цього, існують неявні перетворення між різними типами класів значень. Наприклад, примірник класу `scala.Int` за потреби автоматично розширюється (через неявне перетворення) на примірник класу `scala.Long`.

Як зазначається в Розділі 5.10, неявні перетворення також використовуються для додавання більшої функціональності до типів значень. Наприклад, тип `Int` підтримує всі з операторів нижче:
[source,scala]
----
scala> 42 max 43
res4: Int = 43

scala> 42 min 43
res5: Int = 42

scala> 1 until 5
res6: scala.collection.immutable.Range = Range(1, 2, 3, 4)

scala> 1 to 5
res7: scala.collection.immutable.Range.Inclusive
= Range(1, 2, 3, 4, 5)

scala> 3.abs
res8: Int = 3

scala> (-3).abs
res9: Int = 3
----
Ось як це робить: методи `min`, `max`, `until`, `to` та `abs` всі визначені в класі `scala.runtime.RichInt`, та існує неявне перетворення від класа `Int` на `RichInt`. Перетворення набирає чинності, коли на `Int` викликається метод, що невизначений в `Int`, але визначений в `RichInt`. Подібні "бустерні класи" та неявні перетворення існують також для інших класах значень. Неявні перетворення будуть дискутуватись детально в Главі 21.

Інший субклас кореневого класа `Any` є клас `AnyRef`. Це базовий клас всіх класів посилань в Scala. Як зазначалось раніше, на Java платформі `AnyRef` фактично є псевдонімом для класа `java.lang.Object`. Так що класи, написані на Java, так само, як класи, написані на Scala, всі наслідують від `AnyRef`.footnote:[Причина, з якої існує псевдонім `AnyRef`, замість простого використання імені `java.lang.Object`, є факт, що  Scala була початково розроблена для роботи на обох платформах Java та .NET. На .NET  `AnyRefwas` є псевдонімом до `System.Object`.] Таким чином, один зі способів думати про `java.lang.Object`, є спосіб, як `AnyRef` реалізований на платформі Java. Так що, хоча ви можете використовувати `Object` та `AnyRef` взаємозамінно в програмах Scala на Java платформі, рекомендованим стилем є повсякчасне використання `AnyRef`.

11.2 Як реалізовані примітиви
-----------------------------
Як це все реалізоване? Фактично, Scala зберігає цілі в той самий спосіб, що і Java — як 32-бітні слова. Це важливо для ефективності на JVM, і також для взаємодії з бібліотеками Java. Стандартні операції, як додавання або множення, реалізовані як примітивні операції. Однак Scala використовує "дублюючий" клас `java.lang.Integer`, коли ціле має виглядати як (Java) об'єкт. Це трапляється, наприклад, коли викликається метод `toString` на цілому числі, або коли присвоюються ціле до змінної типу `Any`. Цілі типу `Int` при необхідності прозоро конвертуються до "боксованих цілих" типу `java.lang.Integer`.

Все це виглядає як авто-боксування в Java 5, і насправді досить подібно. Однак є одна значна різниця: боксування в Scala значно менш помітне, ніж боксування в Java. Спробуйте наступне в Java:
[source,scala]
----
// Це Java
boolean isEqual(int x, int y) {
    return x == y;
}
System.out.println(isEqual(421, 421));
----
Ви, звичайно, отримаєте `true`. Тепер змініть типи аргументів `isEqual` на `java.lang.Integer` (або `Object`, результат буде той самий):
[source,scala]
----
// Це Java
boolean isEqual(Integer x, Integer y) {
    return x == y;
}
System.out.println(isEqual(421, 421));
----
Ви знайдете, що тепер ви отримуєте `false`! Що відбувається, це число `421`боксується  двічі, так що аргументи для `x` та `y` є двома різними об'єктами. Оскільки `==` означає рівність посилань, та `Integer` є типом посилання, та результат буде `false`. Це один з аспектів, який показує, що Java не є чистою об'єктно-орієнтовною мовою. Існує різниця між примітивними типами, та типами посилань, що можливо ясно спостерігати.

Тепер спробуємо той самий експеримент в Scala:
[source,scala]
----
scala> def isEqual(x: Int, y: Int) = x == y
isEqual: (x: Int, y: Int)Boolean

scala> isEqual(421, 421)
res10: Boolean = true

scala> def isEqual(x: Any, y: Any) = x == y
isEqual: (x: Any, y: Any)Boolean

scala> isEqual(421, 421)
res11: Boolean = true
----
Операція еквівалентності `==` в Scala розроблений бути прозорим з точки зору представлення типу. Для типів значень це природна (числова та логічна) рівність. Для типів посилань, інших ніж боксовані числові типи Java, `==` трактується як псевдоним для метода `equals`, наслідуваного від `Object`. Цей метод в оригіналі визначений як референсна еквівалентність, але перекритий багатьма субкласами для реалізації їх природної нотації рівності. Це також означає, що в Scala ви ніколи не попадете в гарно відому ловушку Java, що стосується порівняння рядків. В Scala порівняння рідків робить як повинно:
[source,scala]
----
scala> val x = "abcd".substring(2)
x: String = cd

scala> val y = "abcd".substring(2)
y: String = cd

scala> x == y
res12: Boolean = true
----
В Java результат порівняння `x` з `y` буде `false`. Програміст має використовувати `equals` в цьому випадку, але про це легко забути.

Однак є ситуації, коли вам потрібна рівність посилань, замість визначеної користувачем рівності. Наприклад, в деяких ситуаціях, де ефективність є понад усе, ви, можливо, вирішите хешувати класи, та порівнювати їх примірники на рівність посилань.footnote:[Ви хешуєте примірники класу, кешуючи всі примірники, які ви створюєте в слабкій колекції. Потім, кожного разу, коли вам треба новий примірник класу, ви спочатку перевіряєте кеш. Якщо кеш вже має елемент, еквівалентний до того, що ви збираєтесь створити, ви можете повторно використати існуючий примірник. Як результат цього механізму, любі два примірника, що еквівалентні згідно `equals()`, також є еквівалентні згідно рівності посилань.] Для ціх випадків клас `AnyRef` визначає додатковий метод `eq`, що не може бути перекритий, та реалізований як рівність посилання (тобто, він поводиться як `==` в Java для типів посилань). Також є доповнення до `eq`, що називається `ne`. Наприклад:
[source,scala]
----
scala> val x = new String("abc")
x: String = abc

scala> val y = new String("abc")
y: String = abc

scala> x == y
res13: Boolean = true

scala> x eq y
res14: Boolean = false

scala> x ne y
res15: Boolean = true
----
Еквівалентність в Scala обговорюється далі в Главі 30.

11.3 Нижні типи
---------------
Знизу ієрархії типів на Малюнку 11.1 ви бачите два класи, `scala.Null` та `scala.Nothing`. Це особливі типи, що обробляють деякі "пограничні випадки" об'єктно-орієнтовної системи типів Scala в уніформний спосіб.

Клас `Null` є типом посилання `null`; це субклас кожного класу посилань (тобто, кожного класу, що сам наслідує від `AnyRef`). `Null` не сумісний з типами значень. Наприклад, ви не можете присвоїти значення `null` до цілого значення:
[source,scala]
----
scala> val i: Int = null
<console>:7: error: an expression of type Null is ineligible
for implicit conversion
       val i: Int = null
                    ^
----
Тип `Nothing` є на самому дні ієрархії класів Scala; це субтип кожного іншого типу. Однак не існує жодного примірника цього типу. Чому може бути сенс мати тип без значень? Як обговорюється в Розділі 7.4, одне використання `Nothing` є сигналювання щодо ненормального завершення.

Наприклад, існує метод `error` в об'єкті `Predef` стандартної бібліотеки Scala, що визначений таким чином:
[source,scala]
----
def error(message: String): Nothing =
  throw new RuntimeException(message)
----
Тип повернення `error` є `Nothing`, що каже користувачам, що метод не буде повертати значення звичайним чином (замість цього він закидає виключення). Оскільки `Nothing` є субтипом кожного іншого типу, ви можете використовувати методи, як `error`, в дуже гнучкі способи. Наприклад:
[source,scala]
----
def divide(x: Int, y: Int): Int =
  if (y != 0) x / y
  else error("can't divide by zero")
----
Гілка `then`умовного виразу, `x / y`, має тип `Int`, тоді як гілка `else` викликає `error`, та має тип `Nothing`. Оскільки `Nothing` є субтипом `Int`, тип цілого виразу є `Int`, як це і вимагається.

11.4 Визначення ваших власних класів значення
---------------------------------------------
Як зазначалось в Розділі 11.1, ви можете визначити ваші власні класи значень, щоб покращити ті, що вже є вбудовані. Як і вбудовані класи значень, примірник вашого класу значення буде звичайно компілюватись в Java бійткод, що не використовує клас огортки. В контекстах, коли огортка потрібна, як в коді дженериків, значення буде боксоване та розбоксоване автоматично.

Тільки певні класи можуть бути перетворені в класи значень. Щоб клас був класом значення, він повинен мати рівно один параметр, і він не повинен містити всередині нічого, за винятком `def`. Більше того, жодний інший клас не може розширяти клас значення, та клас значення не може перевизначати `equals` або `hashCode`.

Щоб визначити клас значення, зробіть його субкласом `AnyVal`, та покладіть `val` перед одним параметром. Ось приклад класу значення:
[source,scala]
----
class Dollars(val amount: Int) extends AnyVal {
  override def toString() = "$" + amount
}
----
Як описано в Розділі 10.6, префікс `val` дозволяє параметру `amount` бути досяжним як поле. Наприклад, наступний код створює примірник класу значення, що отримує значення з поля:
[source,scala]
----
scala>val money = new Dollars(1000000)
money: Dollars = $1000000

scala>money.amount
res16: Int = 1000000
----
В цьому прикладі `money` посилається на примірник класу значення. Його тип в джерельному коді Scala буде `Dollars`, але скомпільований байткод Java буде напряму використовувати тип  `Int`.

Цей приклад визначає метод `toString`, і компілятор здогадується, коли його використовувати. Ось чому друк `money` дає `$1000000` зі знаком долара, але друк `money.amount` дає `1000000`. Ви навіть можете визначити декілька типів значень, що одночасно підтримуються тим самим значенням `Int`. Наприклад:
[source,scala]
----
class SwissFrancs(val amount: Int) extends AnyVal {
  override def toString() = amount + " CHF"
}
----
Навіть не зважаючи, що обоє, `Dollars` та `SwissFrancs` представлені як цілі, це робить добре, коли вони використовуються разом в полі зору:
[source,scala]
----
scala> val dollars = new Dollars(1000)
dollars: Dollars = $1000

scala> val francs = new SwissFrancs(1000)
francs: SwissFrancs = 1000 CHF
----
Уникнення монокультури типів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Щоб отримати найбільшу вигоду від ієрархії класів Scala, намагайтесь визначати нові класи для кожної галузевої концепції, навіть коли можливо використати той самий клас для різних призначень. Навіть, якщо такий клас є так званим _крихітним типом_ без методів або полів, визначення додаткових класів є шляхом допомогти компілятору бути корисним для вас.

Наприклад, уявімо, що ви пишете деякий код для генерації HTML. В HTML ім'я стиля представлений як рядок. Так само як ідентифікатори якорів. Сам HTML також є рядком, так що, якщо ви бажаєте, ви можете визначити допоміжний код з використанням рядків, щоб представляти все це, ось так:
[source,scala]
----
def title(text: String, anchor: String, style: String): String =
  s"<a id='$anchor'><h1 class='$style'>$text</h1></a>"
----
Ця сигнатура типу має чотири рядки в собі! Такий за-рядковано типізований код технічно строго типізований, але оскільки все в полі зору має тип `String`, компілятор не може допомогти вам детектувати використання одного, коли ви мали на увазі написати інше. Наприклад, він не зупинить вас від цієї пародії:
[source,scala]
----
scala> title("chap:vcls", "bold", "Value Classes")
res17: String = <a id='bold'><h1 class='Value 
    Classes'>chap:vcls</h1></a>
----
Цей HTML геть перекручений. Призначений для відображення текст `"Value Classes"` був використаний як клас стилю, та відображений текст є `"chap.vcls"`, що був задуманий як якір. Щоб довершити все, насправді ідентифікатор якоря є `"bold"`, що мав бути класом стилю. Не зважаючи на цю комедію помилок, компілятор не вимовив ані слова.

Компілятор міг бути більш корисним, якщо ви визначите крихітні типи для кожної доменної концепції. Наприклад, ви можете визначити малий клас для стилю, ідентифікатора якоря, тексту для відображення та HTML. Оскільки ці класи мають один параметр, і не мають членів, вони можуть бути визначені як класи значення:
[source,scala]
----
class Anchor(val value: String) extends AnyVal
class Style(val value: String) extends AnyVal
class Text(val value: String) extends AnyVal
class Html(val value: String) extends AnyVal
----
Маючи ці класи можливо написати версію `title`, що має менш тривіальну сигнатуру типів:
[source,scala]
----
def title(text: Text, anchor: Anchor, style: Style): Html =
  new Html(
    s"<a id='${anchor.value}'>" +
    s"<h1 class='${style.value}'>" +
    text.value +
    "</h1></a>"
  )
----
Якщо ви спробуєте використати цю версію з аргументами в невірному порядку, компілятор тепер може детектувати помилку. Наприклад:
[source,scala]
----
scala> title(new Anchor("chap:vcls"), new Style("bold"),
           new Text("Value Classes"))
<console>:18: error: type mismatch;
 found   : Anchor
 required: Text
                new Anchor("chap:vcls"),
                ^
<console>:19: error: type mismatch;
 found   : Style
 required: Anchor
                new Style("bold"),
                ^
<console>:20: error: type mismatch;
 found   : Text
 required: Style
                new Text("Value Classes"))
                ^
----
11.5 Висновок
-------------
В цій главі ми показали вам класи нагорі та знизу ієрархії класів Scala. Тепер, коли ви отримали гарне підгрунтя щодо наслідування класів в Scala, ви готові для розуміння композиції міксінів. В наступній главі ви навчитесь щодо трейтів.
