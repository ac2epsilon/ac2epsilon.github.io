<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__20">Глава 20</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Абстрактні члени</h1>
<div class="paragraph"><p>Член класа або трейта є абстрактним, якщо член не має повного визначення в класі. Абстрактні члени призначені бути реалізованими в субкласах класа, в якому вони визначені. Ця ідея знаходиться в багатьох об'єктно-рієнтованих мовах. Наприклад, Java дозволяє вам декларувани абстрактні методи. Scala також дозволяє вам декларувати такі методи, як ви бачили в Розділі 10.2. Але Scala іде далі, і реалізує ідею в своїй повній загальності: крім методів, ви можете декларувати абстрактні поля, та навіть абстрактні типи, як члени класів та трейтів.</p></div>
<div class="paragraph"><p>В цій главі ми опишемо всі типи абстрактних членів: <code>val</code>, <code>var</code>, методи та типи. По ходу ми обсудимо наперед-ініціалізовані поля, ліниві <code>val</code>, шлях-залежні типи та енумерації.</p></div>
<div class="sect1">
<h2 id="_20_1_____">20.1 Швидкий тур для абстрактних членів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наступний трейт декларує по одному з кожного типу абстрактних членів: абстрактний тип (<code>T</code>), метод (<code>transform</code>), <code>val</code> (<code>initial</code>), та <code>var</code> (<code>current</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Суцільна реалізація <code>Abstract</code> потребує заповнення визначень для кожного з його абстрактних членів. Ось приклад реалізації, що провадить ці визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Concrete</span> <span class="k">extends</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
  <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">initial</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація надає певне значення типу на ім'я <code>T</code>, через його визначення як псевдониму до типу <code>String</code>. Операція <code>transform</code> конкатенує наданий рядок з собою, та значення <code>initial</code> та <code>current</code> обоє встановлені в <code>"hi"</code>.</p></div>
<div class="paragraph"><p>Цей приклад надає вам грубу першу ідею щодо типів абстрактних членів, що існують в Scala. Залишок глави буде презентувати деталі, та пояснювати, для чого гарні нові форми абстрактних членів, так само, як і типи членів взагалі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_2__">20.2 Члени типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви можете бачити з приклада в попередньому розділі, термін <em>абстрактний тип</em> в Scala означає тип, декларований (за допомогою ключового слова <code>type</code>) як член класу або трейта, без вказання визначення. Класи самі можуть бути абстрактними, та трейти по визначенню абстрактні, але на жодний з них не посилаються як на абстрактні типи в Scala. Абстрактний тип в Scala завжди є членом деякого класу або трейта, як тип <code>T</code> в трейті <code>Abstract</code>.</p></div>
<div class="paragraph"><p>Ви можете думати про не-абстрактні (або <em>суцільні</em>) члени типів, як тип <code>T</code> в класі <code>Concrete</code>, як шлях для визначення нового визначення, або псевдоним, для типу. Наприклад, в класі <code>Concrete</code>, типу <code>String</code> наданий псевдоним <code>T</code>. Як результат, будь-де, де з'являється <code>T</code> в визначенні класа <code>Concrete</code>, це означає <code>String</code>. Це включає параметр і типи результатів для <code>transform</code>, <code>initial</code> та <code>current</code>, які згадують <code>T</code>, коли вони декларовані в супертрейті <code>Abstract</code>. Таким чином, коли клас <code>Concrete</code> реалізує ці методи, ці <code>T</code> інтерпретуються щоб означати <code>String</code>.</p></div>
<div class="paragraph"><p>Одна з причин для використання члена типу є визначення коротких, описових псевдонимів для типів, чиє дійсне ім'я більш балакуче, або менш очевидне за значенням, ніж псевдоним. Такі члени типів можуть допомогти прояснити код класа або трейта. Інше головне використання членів типа є декларація абстрактних типів, що мають бути визначені в субкласах. Це використання, що було продемонстроване в попередньому розділі, буде детально описане в цій главі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_3__val">20.3 Абстрактні val</h2>
<div class="sectionbody">
<div class="paragraph"><p>Абстрактна декларація <code>val</code> має таку форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона надає ім'я та тип для <code>val</code>, але не його значення. Це значення має бути запровадження через суцільне визначення <code>val</code> в субкласі. Наприклад, клас <code>Concrete</code> реалізує <code>val</code> з використанням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви використовуєте абстрактну декларацію <code>val</code> в класі, коли ви не знаєте коректного значення в класі, але ви знаєте, що змінна буде мати незмінне значення для кожного примірника класа.</p></div>
<div class="paragraph"><p>Абстрактна декларація <code>val</code> повторює декларацію абстрактного безпараметричного метода, декларованого таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Клієнтській код може посилатись на обох, <code>val</code> та метод, в точно той самий спосіб (тобто, <code>obj.initial</code>). Однак, якщо <code>initial</code> є абстрактна <code>val</code>, клієнту гарантовано, що <code>obj.initial</code> буде давати те саме значення кожний раз, коли на нього посилаються. Якщо <code>initial</code> буде абстрактний метод, ця гарантія не виконується, оскільки в цьому випадку <code>initial</code> може бути реалізований суцільним методом, що повертає різне значення при кожному виклику.</p></div>
<div class="paragraph"><p>Іншими словами, абстрактний <code>val</code> обмежує свою легальну реалізацію: люба реалізація може бути визначенням <code>val</code>; це не може бути <code>var</code> або <code>def</code>. З іншого боку, абстрактні декларації методів можуть бути реалізовані на вибір, як визначення суцільного метода, або як суцільне визначення <code>val</code>. Беручи абстрактний клас <code>Fruit</code>, показаний в Лістингу 20.1, клас <code>Apple</code> буде легальною реалізацією субкласа, але клас <code>BadApple</code> ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// v означає value</span>
  <span class="k">def</span> <span class="n">m</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// m означає method</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// OK перекривати def за допомогою val</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BadApple</span> <span class="k">extends</span> <span class="nc">Fruit</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span> <span class="c1">// ПОМИЛКА: не можна перекривати val за допомогою def</span>
  <span class="k">def</span> <span class="n">m</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.1 - Перекриття абстрактного <code>val</code> та безпараметрного метода.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_4__var">20.4 Абстрактні var</h2>
<div class="sectionbody">
<div class="paragraph"><p>Подібно до абстрактного <code>val</code>, абстрактний <code>var</code> декларує лише ім'я і тип, але не початкове значення. Наприклад, Лістинг 20.2 показує трейт <code>AbstractTime</code>, що декларує дві абстрактні змінні на ім'я <code>hour</code> та <code>minute</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">AbstractTime</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.2 - Декларація абстрактних <code>var</code>.</p></div>
<div class="paragraph"><p>Яке значення має визначення абстрактних <code>var</code>, як <code>hour</code> та <code>minute</code>?Ви бачили в Розділі 18.2, що <code>var</code>, задекларовані як члени класів ідуть обладнані методвами геттера та сеттера. Це дотримується також і для абстрактних методів. Якщо ви, наприклад, декларуєте абстрактний <code>var</code> на ім'я <code>hour</code>, ви неявно декларуєте абстрактний метод геттера, <code>hour</code>, та абстрактний метод сеттера, <code>hour_=</code>. Немає переприсвоюваного поля, що треба визначати — він надійде в субкласах, що визначають суцільну реалізацію абстрактного <code>var</code>. Наприклад, визначення <code>AbstractTime</code>, показане в Лістингу 20.2, в точності еквівалентна до визначення, показаній в Лістингу 20.3.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">AbstractTime</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// геттер для hour</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// сеттер для hour</span>
  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// геттер для minute</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// сеттер для minute</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.3 - Як абстрактні <code>var</code> розширюються в геттери та сеттери.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_5___val">20.5 Ініціалізація абстрактних val</h2>
<div class="sectionbody">
<div class="paragraph"><p>Абстрактні <code>val</code> іноді грають роль, аналогічну до параметрів суперкласу: вони дозволяють вам провадити деталі в субкласі, що відсутні в суперкласі. Це зокрема важливо для трейтів, оскільки трейти не мають конструктора, до якого ви можете передати параметри. Так що звичайна нотація параметризації трейтів робить через абстрактні <code>val</code>, що реалізовані в субкласах.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо переформулювання класу <code>Rational</code> з Глави 6, як показано на Лістингу 6.5, в вигляді трейта:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас <code>Rational</code> з Глави 6 має два параметри: <code>n</code> для чисельника раціонального числа, та <code>d</code> для займенника. Наданий тут трейт <code>RationalTrait</code> визначає замість цього абстрактні <code>val</code>: <code>numerArg</code> та <code>denomArg</code>. Щоб створити суцільний примірник цього трейту, вам треба реалізувати визначення <code>val</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ключове слово <code>new</code> з'являється перед іменем трейта, <code>RationalTrait</code>, за яким слідує тіло класа в фігурних дужках. Цей вираз дає примірник анонімного класу, що міксує трейт, та визначений в тілі. Цей окремий примірник анонімного класу має ефект, аналогічний створенню примірника <code>new Rational(1, 2)</code>.</p></div>
<div class="paragraph"><p>Однак аналогія недосконала. Існує тонка різниця щодо порядку, в якому ініціалізуються вирази. Коли ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">expr1</span><span class="o">,</span> <span class="n">expr2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>два вирази, <code>expr1</code> та <code>expr2</code>, обчислюються перед тим, як буде ініціалізований клас <code>Rational</code>, так що значення <code>expr1</code> та <code>expr2</code> доступні для ініціалізації класу <code>Rational</code>.</p></div>
<div class="paragraph"><p>Для трейтів ситуація протилежна. Коли ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="n">expr1</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="n">expr2</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>вирази <code>expr1</code> та <code>expr2</code> обчислюються як частина ініціалізації анонімного класу, але анонімний клас ініціалізується <em>після</em>  <code>RationalTrait</code>. Так що значення <code>numerArg</code> та <code>denomArg</code> не доступні впродовж ініціалізації <code>RationalTrait</code> (більш точно, вибір любого зі значень буде давати значення по замовчанню для типу <code>Int</code>, <code>0</code>). Для визначення наданого вище <code>RationalTrait</code> це не проблема, оскільки ініціалізація трейта на використовує значення значень <code>numerArg</code> або <code>denomArg</code>. Однак це стає проблемою в варіанті <code>RationalTrait</code>, показаному в Лістингу 20.4, що визначає нормалізовані чисельник та займенник.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.4 - Трейт, що використовує свої абстрактні <code>val</code>.</p></div>
<div class="paragraph"><p>Якщо ви спробуєте створити примірник цього трейту з деякими виразами чисельника та займенника, що не є простими літералами, ви отримаєте виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
          <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
          <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
        <span class="o">}</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">IllegalArgumentException</span><span class="k">:</span> <span class="kt">requirement</span> <span class="kt">failed</span>
<span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="nc">Predef</span><span class="n">$</span><span class="o">.</span><span class="n">require</span><span class="o">(</span><span class="nc">Predef</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">207</span><span class="o">)</span>
<span class="n">at</span> <span class="nc">RationalTrait$class</span><span class="o">.</span><span class="nc">$init</span><span class="n">$</span><span class="o">(&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="o">)</span>
<span class="o">...</span> <span class="mi">28</span> <span class="n">elided</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі виключення буде закинено через те, що <code>denomArg</code> все ще має значення по замовчанню, <code>0</code>, коли клас <code>RationalTrait</code> було ініціалізовано, що спричиняє збій при виклику <code>require</code>.</p></div>
<div class="paragraph"><p>Цей приклад демонструє, що порядок ініціалізації не той самий для параметрів класів та абстрактних полів. Аргумент параметру класа обчислюється до того, як воно передається в клнструктор класу (за винятком коли параметр є за-ім'ям). Для контрасту, реалізація визначення <code>val</code> в субкласі обчислюється тільки після того, як суперклас був ініціалізований.</p></div>
<div class="paragraph"><p>Тепер, коли ви розумієте, чому абстрактні <code>val</code> поводяться інакше, ніж параметри, гарно буде знати, що ми можемо з цім робити. Чи можливо визначити <code>RationalTrait</code>, що може бути ініціалізований надійно, без старху помилок через неініціалізовані поля? Фактично, Scala пропонує альтернативні рішення до цієї проблеми, пре-ініціалізовані поля та ліниві <code>val</code>. Вони представлені і залишку цього розділу.</p></div>
<div class="sect2">
<h3 id="___">Пре-ініціалізовані поля</h3>
<div class="paragraph"><p>Перше рішення, пре-ініціалізовані поля, дозволяє вам ініціалізувати поле субкласа перед тим, як буде викликано субклас. Щоб зробити це, просто покладіть визначення поля в фігурних дужках перед викликом конструктора суперкласа. Як приклад, Лістинг 20.5 показує іншу спробу створити примірник <code>RationalTrait</code>. Як ви бачите з приклада, розділ ініціалізації іде перед зазначенням супертрейта  <code>RationalTrait</code>. Обоє розділені <code>with</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">RationalTrait</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.5 - Пре-ініціалізовані поля в виразі анонімного класу.</p></div>
<div class="paragraph"><p>Пре-ініціалізовані поля не обмежуються до анонімних класів; вони можуть також застосовуватись в об'єктах або іменованих субкласах. Два приклада показані в Лістингах 20.6 та 20.7. Як ви можете бачити з ціх прикладів, розділ пре-ініціалізації кожний раз іде після ключового слова <code>extends</code> визначеного об'єкта або класа. Клас <code>RationalClass</code>, показаний в Лістингу 20.7, надає приклад загальної схеми того, як параметри класів можуть бути зроблені доступними для ініціалізації супертрейта.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">twoThirds</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">3</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.6 - Пре-ініціалізовані поля в визначенні об'єкта.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">RationalClass</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="n">d</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">RationalClass</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RationalClass</span><span class="o">(</span>
    <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
    <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
  <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.7 - Пре-ініціалізовані поля в визначенні класу.</p></div>
<div class="paragraph"><p>Оскільки пре-ініціалізовані поля є ініціалізовані перед викликом конструктора суперкласа, їх ініціалізатори не можуть посилатись на об'єкт, що наразі конструюється. Відповідно, якщо такий ініалізатор посилається на <code>this</code>, посилання іде на об'єкт, що містить клас або об'єкт, який конструюється, не на самий створюваний об'єкт.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numerArg</span> <span class="o">*</span> <span class="mi">2</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">RationalTrait</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">11</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">numerArg</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">object</span>
<span class="nc">$iw</span>
                <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numerArg</span> <span class="o">*</span> <span class="mi">2</span>
                                    <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад не компілюється, оскільки посилання <code>this.numerArg</code> шукає  <code>numerArgfield</code> в об'єкті, що містить <code>new</code> (що в цьому випадку є синтетичним об'єктом на ім'я <code>$iw</code>, в який інтерпретатор покладає поля, що вводить користувач). Ще раз, пре-ініціалізовані поля поводяться в цьому відношенні як аргументи конструктора класа.</p></div>
</div>
<div class="sect2">
<h3 id="__code_val_code">Ліниві <code>val</code></h3>
<div class="paragraph"><p>Ви можете використовувати пре-ініціалізовані поля для точної симуляції поведінки ініціалізації аргументів конструкторів класу. Однак іноді ви можете обрати дозволити системі самій з'ясувати, які речі мають бути ініціалізовані. Це може бути досягнуто через створення ваших визначень <code>val</code> як <code>lazy</code>. Якщо перед <code>val</code> поставити модифікатор <code>lazy</code>, вираз ініціалізації в правій стороні буде обчислений тільки перший раз, коли використовується <code>val</code>.</p></div>
<div class="paragraph"><p>Наприклад, визначимо об'єкт <code>Demo</code> з <code>val</code> наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;initializing x&quot;</span><span class="o">);</span> <span class="s">&quot;done&quot;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">defined</span> <span class="k">object</span> <span class="nc">Demo</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, спочатку посилаємось на <code>Demo</code>, потвм на <code>Demo.x</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span>
<span class="n">initializing</span> <span class="n">x</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Demo.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Demo</span><span class="n">$</span><span class="k">@</span><span class="mi">2129</span><span class="n">a843</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span><span class="o">.</span><span class="n">x</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">done</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, коли ви використовуєте <code>Demo</code>, його поле <code>x</code> стає ініціалізованим. Ініціалізація <code>x</code> формує частину ініціалізації <code>Demo</code>. Ситуація змінюється, якщо ви визначите поле <code>x</code> як <code>lazy</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">object</span> <span class="nc">Demo</span> <span class="o">{</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;initializing x&quot;</span><span class="o">);</span> <span class="s">&quot;done&quot;</span> <span class="o">}</span>
<span class="o">}</span>
<span class="n">defined</span> <span class="k">object</span> <span class="nc">Demo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Demo.</span><span class="k">type</span> <span class="o">=</span> <span class="nc">Demo</span><span class="n">$</span><span class="k">@</span><span class="mi">5</span><span class="n">b1769c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Demo</span><span class="o">.</span><span class="n">x</span>
<span class="n">initializing</span> <span class="n">x</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">done</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ініціалізація <code>Demo</code> не включає ініціалізацію <code>x</code>. Ініціалізація <code>x</code> буде відкладена, доки <code>x</code> не буде ініціалізоване перший раз. Це подібно до ситуації, коли <code>x</code> визначена як безпараметричний метод з використанням <code>def</code>. Однак, на відміну від <code>def</code>, <code>lazy val</code> ніколи не визначається більше ніж один раз. Фактично, після першого обчислення <code>lazy val</code> результат обчислення зберігається, щоб бути використаний, якщо та сама <code>val</code> буде використовуватись декілька разів.</p></div>
<div class="paragraph"><p>Дивлячись на цей приклад, здається, що об'єкти як <code>Demo</code> самі поводяться як <code>lazy val</code>, в тому, що вони ініціалізуються на вимогу, коли вони використовуються перший раз. Це коректно. Фактично, визначення об'єкта може розглядатись як скорочення для визначення <code>lazy val</code> з анонімним класом, що описує вміст об'єкту.</p></div>
<div class="paragraph"><p>Використавуя <code>lazy val</code>, ви можете переформулювати <code>RationalTrait</code>, як показано в Лістингу 20.8. В новому визначенні трейта всі суцільні поля визначені як ліниві. Інша зміна з точки зору попереднього визначення <code>RationalTrait</code>, показаного на Лістингу 20.4, в тому, що твердження <code>require</code> було переміщено з тіла трейта до ініціалізатора приватного поля, <code>g</code>, що обчислює найбільший загальний дільник <code>numerArg</code> та <code>denomArg</code>. З ціма змінними нема нічого, що треба зробити при ініціалізації <code>LazyRationalTrait</code>; весь код ініціалізації тепер є частиною правої сторони <code>lazy val</code>. Таким чином, є безпечним ініціалізувати абстрактні поля <code>LazyRationalTrait</code> після того, як клас визначений.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
  <span class="k">private</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.8 - Ініціалізація трейта за допомогою лінивих змінних.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
         <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
         <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
       <span class="o">}</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">LazyRationalTrait</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Попередня ініціалізація непотрібна. Буде повчальним прослідити послідовність ініціалізації, що призведе до того, що рядок <code>1/2</code> буде надрукований кодом вище:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Свіжий примірник <code>LazyRationalTrait</code> буде створений, та код ініціалізації <code>LazyRationalTrait</code> виконується. Цей код ініціалізації порожній; жодне з полів <code>LazyRationalTrait</code> досі не ініціалізований.
</p>
</li>
<li>
<p>
Далі виконується первинний конструктор анонімного субкласу, визначеного виразом <code>new</code>. Це включає ініціалізацію <code>numerArg</code> значенням 2, та <code>denomArg</code> значенням 4.
</p>
</li>
<li>
<p>
Далі викликається метод <code>toString</code> на конструйованому інтерпретатором об'єкті, так що результуюче значення може бути роздруковане.
</p>
</li>
<li>
<p>
Далі в перший раз відбувається доступ до поля <code>numer</code> з метода <code>toString</code> в трейті <code>LazyRationalTrait</code>, так що її ініціалатор обчислюється.
</p>
</li>
<li>
<p>
Ініціалізатор <code>numer</code> отримує доступ до приватного поля <code>g</code>, так що наступним ініціалізується <code>g</code>. Це обчислення отримує доступ до <code>numerArg</code> та <code>denomArg</code>, що були визначені на Кроці 2.
</p>
</li>
<li>
<p>
Далі метод <code>toString</code> отримує доступ до значення <code>denom</code>, що спричинить обчислення <code>denom</code>. Обчислення <code>denom</code> отримує доступ до <code>denomArg</code> та <code>g</code>. Ініціалізатор поля <code>g</code> не переобчислюється, оскільки він вже був обчислений на Кроці 5.
</p>
</li>
<li>
<p>
Нарешті, конструюється та друкується результуючий рядок <code>"1/2"</code>.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Зауважте, що визначення <code>g</code> текстуально іде після визначення <code>numer</code> та <code>denom</code> в класі <code>LazyRationalTrait</code>. Тим не менше, оскільки всі ці значення ліниві, <code>g</code> стає ініціалізованим перед тим, як ініціалізація <code>numer</code> та <code>denom</code> буде завершеною.</p></div>
<div class="paragraph"><p>Це показує важливу властивість лінивих змінних: текстуальний порядок їх визначення не має значення, оскільки значення ініціалізуються на вимогу. Таким чином, ліниві змінні вивільняють вам як програміста від роздумів, як вистроїти визначення <code>val</code>, щоб переконатись, що все визначено, коли це треба.</p></div>
<div class="paragraph"><p>Однак ця перевага дотримується тільки доти, доки ініціалізація лінивих змінних ані не призводить до побічних ефектів, ані не залежить від них. В присутності побічних ефектів порядок ініцалізації починає ставати важливим. І потім може стати досить складним відстежити, в якому порядку виконується код ініціалізації, як демонструє попередній приклад. Так що ліниві змінні є ідеальним доповненням до функціональних об'єктів, де порядок ініціалізації не має значення, доки все стає при нагоді ініціалізованим. Вони менш підходять для коду, що є здебільшого імперативним.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Ліниві функціональні мови</h3>
<div class="paragraph"><p>Scala жодним чином не є першою мовою, що чудово відповідає лінивим визначеням та функціональному коду. Фактично є категорія "лінивих функціональних мов програмування", в яких кожне значення та парамент ініціалізуються ліниво. Найбільш відомий член цього класу мов є Haskell [SPJ02].</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_20_6__">20.6 Абстрактні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>На початку цієї глави ви бачили <code>type T</code>, декларацію абстрактного типу. Залишок цієї глави дискутує, що означають такі декларації абстрактних типів, та для чого вони добрі. Як всі інши абстрактні декларації, декларації абстрактних типів є замінниками для чогось, що буде визначено суцільним в субкласах. В цьому випадку це тип, що буде визначений десь далі в ієрархії типів. Так що тип <code>T</code> вище посилається на тип, що досі невідомий в точці, де він визначений. Різні субкласи можуть провадити різні реалізації для <code>T</code>.</p></div>
<div class="paragraph"><p>Ось гарно відомий приклад, де абстрактні типи виглядають природними. Уявімо, що ми отримали завдання змоделювати істівні звички тварин. Ви можете почати з класу <code>Food</code> та класу <code>Animal</code> за методом <code>eat</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ви можете спробувати спеціалізувати ці два класа, до класу <code>Cows</code>, що їсть <code>Grass</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span> <span class="c1">// Це не компілюєтья</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ви спробуєте компілювати ці нові класи, ви отримаєте наступну помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BuggyAnimals</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">7</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Cow</span> <span class="kt">needs</span> <span class="kt">to</span> <span class="kt">be</span>
<span class="k">abstract</span><span class="o">,</span> <span class="n">since</span> <span class="n">method</span> <span class="n">eat</span> <span class="n">in</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="n">of</span> <span class="k">type</span>
    <span class="o">(</span><span class="kt">Food</span><span class="o">)</span><span class="kt">Unit</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">defined</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
      <span class="o">^</span>
<span class="nc">BuggyAnimals</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">8</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">method</span> <span class="kt">eat</span> <span class="kt">overrides</span> <span class="kt">nothing</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, ще те, що метод <code>eat</code> класу <code>Cow</code> не перекриває метод <code>eat</code> в класі <code>Animal</code>, оскікльи його тип параметру інший: це  <code>Grass</code> в класі <code>Cow</code> vs. <code>Food</code> в класі <code>Animal</code>.</p></div>
<div class="paragraph"><p>Деякі люди заперечують, що така система типів сувора без необхідності в відмові цім класам. Вони кажуть, що повинно бути OK спеціалізувати параметр метода в субкласі. Однак, якщо класам дозволити бути написаними таким чином, дуже швидко ви можете опинитись в небезпечній ситуації. Наприклад, наступний скрипт буде проходити перевірку типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Food</span><span class="o">)</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span> <span class="c1">// Це не буде компілюватись,</span>
<span class="o">}</span>                                    <span class="c1">// але якщо б могло,...</span>
<span class="k">class</span> <span class="nc">Fish</span> <span class="k">extends</span> <span class="nc">Food</span>
  <span class="k">val</span> <span class="n">bessy</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cow</span>
  <span class="n">bessy</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Fish</span><span class="o">)</span>               <span class="c1">// ...ви б могли кормити корів рибою.</span>
</pre></div></div></div>
<div class="paragraph"><p>Програма могла б компілюватись, якщо обмеження були б послаблені, оскільки <code>Cows</code> є <code>Animals</code>, та <code>Animals</code> мають метод <code>eat</code>, що приймає любий різновид <code>Food</code>, включаючи <code>Fish</code>. Але напевно корові не буде гарно, якщо вона поїсть риби! Що вам треба замість цього, це застосувати якесь більш точне моделювання. <code>Animals</code> їдять <code>Food</code>, але який різновид <code>Food</code> їсть кожний <code>Animal</code>, залежить від самого <code>Animal</code>. Це може бути гарно виражено за допомогою абстрактного типу, як показано в Лістингу 20.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="k">&lt;:</span> <span class="kt">Food</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">SuitableFood</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.9 - Моделювання підходящої їжи через абстрактний тип.</p></div>
<div class="paragraph"><p>З новим визначенням класу, <code>Animal</code> може їсти тільки іжу, що їй підходить. Яка їжа є підходящою не може бути визначено на рівні класу <code>Animal</code>. Ось чому <code>SuitableFood</code> змодельований як абстрактний клас. Тип має верхню межу, <code>Food</code>, що виражається як вираз <code>&lt;: Food</code>. Це означає, що любий суцільний примірник <code>SuitableFood</code> (в субкласі <code>Animal</code>) має бути субкласом <code>Food</code>. Наприклад, ви не можете створити примірник <code>SuitableFood</code> за допомогою класу <code>IOException</code>.</p></div>
<div class="paragraph"><p>З визначеним <code>Animal</code> ви тепер можете переходити до корів, як показано в Лістингу 20.10. Клас <code>Cow</code> ладнає свій <code>SuitableFood</code> до <code>Grass</code>, а також визначає суцільний метод <code>eat</code> для цього різновиду їжі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.10 - Реалізація абстрактного типу в субкласі.</p></div>
<div class="paragraph"><p>Ці нові визначення класів компілюються без помилок. Якщо ви спробуєте виконати контрприклад "корови-що-їдять-рибу" з новими визначеннями класів, ви будете отримувати наступну помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Fish</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">Fish</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bessy</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cow</span>
<span class="n">bessy</span><span class="k">:</span> <span class="kt">Animal</span> <span class="o">=</span> <span class="nc">Cow</span><span class="k">@</span><span class="mi">1515</span><span class="n">d8a6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bessy</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Fish</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
  <span class="n">found</span>   <span class="k">:</span> <span class="kt">Fish</span>
  <span class="n">required</span><span class="k">:</span> <span class="kt">bessy.SuitableFood</span>
              <span class="n">bessy</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Fish</span><span class="o">)</span>
                         <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_7___">20.7 Шляхо-залежні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знову поглянемо на останнє повідомлення про помилку. Що цікавє, це те, який тип потребує метод <code>eat</code>: <code>bessy.SuitableFood</code>. Цей тип містить посилання на об'єкт, <code>bessy</code>, за яким іде поле типу об'єкту, <code>SuitableFood</code>. Це показує, що об'єкти в Scala може мати типи в якості членів. Значення <code>bessy.SuitableFood</code> є "тип <code>SuitableFood</code>, що є членом об'єкту, на який посилаєтья <code>bessy</code>" або, альтернативно, тип їжі, що підходить для <code>bessy</code>.</p></div>
<div class="paragraph"><p>Тип як <code>bessy.SuitableFood</code> називається шляхо-залежним типом. Слово "шлях" тут означає посилання на об'єкт. Це може бути простим іменем, таке як <code>bessy</code>, або довший шлях доступу, такий як <code>farm.barn.bessy</code>, де кожний з <code>farm</code>, <code>barn</code>, та <code>bessy</code> є змінними (або іменами об'єктів синглтонів), що посилаються на об'єкти.</p></div>
<div class="paragraph"><p>Як підказує термін "шляхо-залежний тип", тип залежить від шляху; загалом, різні шляхи дають різні типи. Наприклад, скажімо, ви визначили класи <code>DogFood</code> та <code>Dog</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DogFood</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">DogFood</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">DogFood</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви спробуєте погодувати собаку їжею, що підходить для корови, ваш код не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bessy</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cow</span>
<span class="n">bessy</span><span class="k">:</span> <span class="kt">Cow</span> <span class="o">=</span> <span class="nc">Cow</span><span class="k">@</span><span class="mi">713</span><span class="n">e7e09</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">lassie</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span>
<span class="n">lassie</span><span class="k">:</span> <span class="kt">Dog</span> <span class="o">=</span> <span class="nc">Dog</span><span class="k">@</span><span class="mi">6</span><span class="n">eaf2c57</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">bessy</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Grass</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">DogFood</span>
             <span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">bessy</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>
                         <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема тут в тому, що тип об'єкта <code>SuitableFood</code>, переданого до метода <code>eat</code>, <code>bessy.SuitableFood</code>, несумісний з типом параметра <code>eat</code>, <code>lassie.SuitableFood</code>.</p></div>
<div class="paragraph"><p>Випадок може бути іншим для двох <code>Dog</code>. Оскікльи тип <code>Dog</code> <code>SuitableFood</code> визначений бути псевдонімом для класу <code>DogFood</code>, типи  <code>SuitableFood</code> для двох <code>Dog</code> є фактично ті самі. Як результат, примірник <code>Dog</code> на ім'я <code>lassie</code> насправді може їсти підходящц їжу іншого примірника <code>Dog</code> (який ми назвемо <code>bootsie</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bootsie</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span>
<span class="n">bootsie</span><span class="k">:</span> <span class="kt">Dog</span> <span class="o">=</span> <span class="nc">Dog</span><span class="k">@</span><span class="mi">13</span><span class="n">a7c48c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">bootsie</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Шляхо-залежнийA тип копіює синтаксис для типу внутрішнього класу в Java, але є важлива відмінність: шляхо-залежний тип називає зовнішній клас. Типи внутрішніх класів в стилі Java також можуть бути виражені в Scala, але вони записуються інакше. Розглянемо ці два класи, <code>Outer</code> та <code>Inner</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Inner</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala внутрішній клас адресується з використанням виразу <code>Outer#Inner</code> замість <code>Outer.Inner</code> в Java. Синтаксис <code>.</code> зарезервований для об'єктів. Наприклад, уявімо, що ви створили два об'єкти типу <code>Outer</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">o1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
<span class="k">val</span> <span class="n">o2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>o1.Inner</code> та <code>o2.Inner</code> є два шляхо-залежні типи (і вони різні типи). Обоє з ціх типів відповідають до (є субтипами до) більш загального типу <code>Outer#Inner</code>, що представляє клас <code>Inner</code> з довільним зовнішнім об'єктом типу <code>Outer</code>. Для контрасту, тип <code>o1.Inner</code> посилається на клас <code>Inner</code> зі специфічним зовнішнім об'єктом (на який посилається <code>o1</code>). Подібним чином, тип <code>o2.Inner</code> посилається на клас <code>Inner</code> з іншим, специфічним зовнішнім об'єктом (на який посилається o2).</p></div>
<div class="paragraph"><p>В Scala, як і в Java, примірники внутрішнього класу містять посилання на оточуючий примірник зовнішнього класа. Це дозволяє внутрішньому класу, наприклад, отримувати доступ до членів свого зовнішнього класу. Таки чином, ви не зможете створити внутрішній клас, в деякий спосіб не указавши примірник зовнішнього класу. Один спосіб зробити це є створити внутрішній клас всередині зовнішнього класу. В цьому випадку буде використаний поточний примірник зовнішнього класу (на який вказує <code>this</code>).</p></div>
<div class="paragraph"><p>Інший шлях є використати шляхо-залежний тип. Наприклад, оскікльи тип <code>o1.Inner</code> іменує специфічний зовнішній об'єкт, ви можете створити його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="n">o1</span><span class="o">.</span><span class="nc">Inner</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">o1.Inner</span> <span class="o">=</span> <span class="nc">Outer$Inner</span><span class="k">@</span><span class="mi">1</span><span class="n">ae1e03f</span>
</pre></div></div></div>
<div class="paragraph"><p>Результуючий інутрішній об'єкт буде містити посилання на на свій зовнішній об'єкт, на який посилається o1. Для контрасту, оскільки тип <code>Outer#Inner</code> не іменує жодний специфічний примірник <code>Outer</code>, ви не можете створити його примірник:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Outer</span><span class="k">#</span><span class="nc">Inner</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Outer</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">legal</span> <span class="kt">prefix</span> <span class="kt">for</span> <span class="kt">a</span>
<span class="n">constructor</span>
              <span class="k">new</span> <span class="nc">Outer</span><span class="k">#</span><span class="nc">Inner</span>
                        <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_8__">20.8 Уточнені типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли клас наслідує від іншого, кажуть, що перший клас є <em>номінальним</em> субтипом іншого. Це <em>номінальний</em> субтип, бо кожний тип має <em>ім'я</em>, і імена явно декларовані як такі, що вають відношення субтипізації. Scala додатково підтримує <em>структурну</em> субтипізацію, коли ви маєте відношення субтипізації, просто тому що два типи мають сумісні члени. Щоб отримати структурну субтипізацію в Scala, використовуйте уточнення типів Scala.</p></div>
<div class="paragraph"><p>Номінальна типізація звичайно є більш зручною, так що вам слідує зпочатку спробувати номінальні типи в кожній новій розробці. Ім'я є простим коротким ідентифікатором, і, таким чином, більш стислі, ніж явний перелік членів типів. Більше того, структурна субтипізація часто більш гнучка, ніж ви бажаєте. Віджет може <code>draw()</code>, та ковбой заходу також може <code>draw()</code>, але вони насправді не замінюють один одного. Ви будете переважно обирати отримання помилки компіляції, якщо ви спробуєте замінити ковбоя на віджет.</p></div>
<div class="paragraph"><p>Тим не менш, структурна субтипізація має власні переваги. Одна з них в тому, що іноді немає більше ніякого типу, ніж перелік членів. Наприклад, уявімо, що ви бажаєте визначити клас <code>Pasture</code>, що може містити тварин, що їдять траву. Одна з опцій буде визначити трейт <code>AnimalThatEatsGrass</code>, та міксувати його в кожний клас, який це стосується. Однак це може бути балакучим. Клас <code>Cow</code> вже був визначений як тварина, та що їсть траву, і тепер він має додатково бути визначений також як тварина-що-їсть-траву. Замість визначення <code>AnimalThatEatsGrass</code> ви можете використовувати уточнюючий тип. Просто запишіть базовий тип, <code>Animal</code>, за яким слідує послідовність членів в фігурних дужках. Члени в фігурних дужках далі специфікують — або, якщо бажаєте, уточнюють — типи членів від базового класу. Ось як ви записуєте тип "тварина, що їсть траву":</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей тип, тепер ви можете записати клас пасовиська таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Pasture</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">animals</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="kt">=</span> <span class="kt">Grass</span> <span class="o">}]</span> <span class="k">=</span> <span class="nc">Nil</span>
<span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_9_">20.9 Енумератори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цікаве застосування для шляхо-залежних типів знаходиться в Scala підтримці енумераторів. Деякі інші мови, включаючи Java та C#, мають енумератори як вбудовані конструкції мови, що визначають нові типи. Scala не потребує особливого синтаксису для енумераторів. Замість цього існує клас в стандадртній бібліотеці, <code>scala.Enumeration</code>.</p></div>
<div class="paragraph"><p>Щоб створити нову енумерацію ви визначаєте об'єкт, що розширює цей клас, як в наступному прикладі, що визначає новий енумератор <code>Colors</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span> <span class="k">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">Green</span> <span class="k">=</span> <span class="nc">Value</span>
  <span class="k">val</span> <span class="nc">Blue</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala дозволяє вам скоротити декілька послідовних визначень <code>val</code> або <code>var</code> з тою самою правою стороною. Еквівалентно до попереднього ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей об<em>єкт провадить три значення: <code>Color.Red</code>, <code>Color.Green</code>, та 'Color.Blue</em>. Ви також можете імпортувати все з <code>Color</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Color._</span>
</pre></div></div></div>
<div class="paragraph"><p>та потім тільки використовувати <code>Red</code>, <code>Green</code>, та <code>Blue</code>. Але який буде тип ціх значень? <code>Enumeration</code> визначає внутрішній клас на ім'я <code>Value</code>, та так само названий безпараметричний метод <code>Value</code> повертає свіжий примірник цього класу. Іншими словами, значення, таке як <code>Color.Red</code> має тип <code>Color.Value</code>; <code>Color.Value</code> є типом для всіх значень енумератора, визначених в об'єкті <code>Color</code>. Це шляхо-залежний тип, де <code>Color</code> є шляхом, та <code>Value</code> є залежним типом. Що важливо щодо цього, це те, що це повністю новий тип, відмінний від всіх інших типів.</p></div>
<div class="paragraph"><p>Зокрема, якщо ви визначите іншу енумерацію, як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">North</span><span class="o">,</span> <span class="nc">East</span><span class="o">,</span> <span class="nc">South</span><span class="o">,</span> <span class="nc">West</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>тоді <code>Direction.Value</code> буде відмінне від <code>Color.Value</code>, оскільки два типи відрізняються в частині шляху.</p></div>
<div class="paragraph"><p>В Scala клас <code>Enumeration</code> також пропонує багато інших можливостей, які можна знайти в дизайні енумераторів в інших мовах. Ви можете асоціювати імена зі значеннями енумерації, використовуючи різні перевантажені варіанти метода <code>Value</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">North</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;North&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">East</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;East&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">South</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;South&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">West</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">&quot;West&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете ітерувати по значенням енумерації через множину, що повертає метод <code>values</code> енумерації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">d</span> <span class="k">&lt;-</span> <span class="nc">Direction</span><span class="o">.</span><span class="n">values</span><span class="o">)</span> <span class="n">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span>
<span class="nc">North</span> <span class="nc">East</span> <span class="nc">South</span> <span class="nc">West</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення енумерації нумеруються від <code>0</code>, і ви можете знайти номер значення енумерації через його метод <code>id</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Direction</span><span class="o">.</span><span class="nc">East</span><span class="o">.</span><span class="n">id</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Також можливо піти іншим шляхом, від не-від'ємного цілого до значення, що має цей номер в якості <code>id</code> в енумерації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Direction</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Direction.Value</span> <span class="o">=</span> <span class="nc">East</span>
</pre></div></div></div>
<div class="paragraph"><p>Цього має бути достатньо, щоб почати робити з енумераціями. Ви можете знайти додаткову інформацію в коментарях Scaladoc до класу <code>scala.Enumeration</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_10___">20.10 Лабораторна робота: валюта</h2>
<div class="sectionbody">
<div class="paragraph"><p>Залишок цієї глави презентує лабораторну роботу, що пояснює, як абстрактні типи можуть бути використані в Scala. Завданням буде розробити клас <code>Currency</code>. Типовий примірник <code>Currency</code> буде представляти кількість грошей в доларах, євро, ієнах або в якійсь іншій валюті. Повинно бути можливим виконувати деяку арифметику з валютами. Наприклад, ви можете бути в змозі додавати дві суми в тій самій валюті. Або ви повинні бути в змозі помножити суму в валюті на коефіціент, що представляє відсотковий рівень.</p></div>
<div class="paragraph"><p>Ці роздуми призводять до наступного першого дизайну класу валюти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Перший (невдалий) дизайн класу Currency</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Сума <code>amount</code> валюти є часло в одиницях валюти, яку вона представляє. Це поле типу <code>Long</code>, так що можуть бути представлені дуже великі суми, такі як капіталізація ринку Google або Apple. Тут це залишено абстрактним, очікуючи визначення коли субклас казатиме про конкретні об'єми грошей. Поле <code>designation</code> для валюти є рядок, що ідентифікує валюту. Метод <code>toString</code> класу <code>Currency</code> вказує суму та позначення. Він буде видавати результати в такому вигляді:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>79 USD
11000 Yen
99 Euro</code></pre>
</div></div>
<div class="paragraph"><p>Нарешті, є метод <code>+</code> для додавання валюти, та <code>*</code> для множення валюти на число з плаваючою крапкою. Ви можете створити суцільне значення валюти, через надання конкретних значень суми та назви валюти, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="mi">79L</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей дизайн буде OK, якщо все, що ми бажаємо, це єдина валюта, як тільки долар або тільки євро. Але він схибить, якщо нам буде треба мати справу з декількома валютами. Уявімо, що ви модулюєте долари та єаро як два субкласи до класу валюти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
<span class="o">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Euro</span> <span class="k">extends</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;Euro&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>На перший погляд це виглядає розумним. Але це дасть нам змогу додавати долари до євро. Результат такого додавання має бути типу <code>Currency</code>. Але це буде цікава валюта, що складається з суміші євро та доларів. Що ми бажаємо замість цього, є більш специфікована версія метода <code>+</code>. Коли реалізується клас <code>Dollar</code>, віе має брати аргументи <code>Dollar</code>, та видавати результат <code>Dollar</code>; коли реалізується клас <code>Euro</code>, він повинен брати аргументи <code>Euro</code>, та видавати результат <code>Euro</code>. Так що тип результату метода додавання буде змінюватись, в залежності від того, в якому класі він знаходиться. Тим не менш, ви бажаєте написати метод додавання тільки один раз, та не кожного разу, коли визначаєте нову валюту.</p></div>
<div class="paragraph"><p>В Scala існує простий прийом, що порається з подібними ситуаціями. Якщо дещо невідоме в точці, де визначається клас, зробіть це абстрактним в класі. Це стосується до обох, значень та типів. В випадку валют, точний тип аргументів та результату метода складання невідомий, так що це гарний кандидат на абстрактний тип.</p></div>
<div class="paragraph"><p>Це може привести до наступного скетчу класа <code>AbstractCurrency</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Другий (все ще недосконалий) дизайн класу Currency</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span>
  <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span><span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдина різниця з попередньою ситуацією в тому, що тепер клас називається <code>AbstractCurrency</code>, і що він містить абстрактний тип <code>Currency</code>, що презентує реальну валюту. Кожний суцільний субклас <code>AbstractCurrency</code> буде потребувати полагодження <code>Currencytype</code>, щоб він посилався на сам суцільний субклас, таким чином "затягуючи петлю".</p></div>
<div class="paragraph"><p>Наприклад, ось нова версія класу <code>Dollar</code>, що тепер розширює клас <code>AbstractCurrency</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Dollar</span>
  <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей дизайн робить, але він все ще не ідеальний. Одна проблема ховається за крапками, що вказують на відсутні визначення методів <code>+</code> та <code>*</code> в класі <code>AbstractCurrency</code>. Зокрема, як має додавання бути реалізоване в цьому класі? Досить просто обчислити коректну суму нової валюти, як <code>this.amount + that.amount</code>, але як ви будете конвертувати суму в валюту правильного типу?</p></div>
<div class="paragraph"><p>Ви можете спробувати щось таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Currency</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак це не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">error</span><span class="k">:</span> <span class="kt">class</span> <span class="k">type</span> <span class="kt">required</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Currency</span> <span class="o">{</span>
                                         <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Одне з обмежень трактування Scala абстрактніх типів в тому, що вона ніколи не буде створювати примірник абстрактного типу, ані матиме абстрактний тип як супертип іншого класу.<span class="footnote"><br />[Є деяке обіцяюче останнє дослідження в віртуальних класах, що може дозволити це, але віртуальні класи наразі не підтримуються в Scala.]<br /></span> Так що компілятор буде відхиляти код в прикладі, що намагається створити примірник <code>Currency</code>.</p></div>
<div class="paragraph"><p>Однак ви можете обійти це обмеження, використовуючи метод фабрики. Замість створення примірника абстрактного класу напряму, декларуйте абстрактний метод, що робить це. Потім, коли абстрактний клас зафіксований як деякий суцільний тип, вам також треба надати суцільну реалізацію матода фабрики. Для класу <code>AbstractCurrency</code> це може виглядати наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span> <span class="c1">// абстрактний тип</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span>  <span class="c1">// метод фабрики</span>
<span class="o">...</span>
<span class="c1">// залишок класу</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Дизайн як цей можна зробити робочим, але він виглядає скоріше підозрілим. Чому класти метод фабрики всередину класу <code>AbstractCurrency</code>? Це виглядає сумнівно з двох причин. Перше, якщо ви маєте якусь суму валюти (скажімо, один долар), ви також тримаєте в своїх руках можливість зрбити більше в тій же валюті, використовуючи код як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">myDollar</span><span class="o">.</span><span class="n">make</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span> <span class="c1">// тут ще одна сотня!</span>
</pre></div></div></div>
<div class="paragraph"><p>В епоху кольорового копіювання це може бути привабливим сценарієм, але, сподіваюсь, не тим, який ви б могли робити довго, не бувши спійманим. Друга проблема з цім кодом в тому, що ви можете зробити більше об'єктів <code>Currency</code>, якщо ви вже маєте посилання на об'єкт <code>Currency</code>. Але як ви отримаєте перший об'єкт даної <code>Currency</code>? Вам знадобиться інший метод, що робить ту саму роботу, що і <code>make</code>. Так що ви маєте випадок дублікації коду, що є певним знаком, що ваш код завонявся.</p></div>
<div class="paragraph"><p>Рішення, звичайно, є перемістити абстрактний тип та метод фабрики за межі класу <code>AbstractCurrency</code>. Вам треба створити інший клас, що містить клас <code>AbstractCurrency</code>, тип <code>Currency</code>, та методо фабрики <code>make</code>.</p></div>
<div class="paragraph"><p>Ми будемо називати це <code>CurrencyZone</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span>

  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
    <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span>
    <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">*</span> <span class="n">x</span><span class="o">).</span><span class="n">toLong</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад суцільного <code>CurrencyZone</code> є <code>US</code>, що може бути визначено так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">US</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Dollar</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollar</span> <span class="o">{</span> <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>US</code> є об'єктом, що розширює <code>CurrencyZone</code>. Він визначає клас <code>Dollar</code>, що є субкласом <code>AbstractCurrency</code>. Так що тип грошей в цій зоні є <code>US.Dollar</code>. Об'єкт <code>US</code> також фіксує тип <code>Currency</code> як псевдонім для <code>Dollar</code>, та він надає реалізацію метода фабрики <code>make</code>, що повертає суму в доларах.</p></div>
<div class="paragraph"><p>Це робочий дизайн. Залишилось додати лише декілька покращень. Перше покращення стосується субодиниць. Досі кожна валюта обчислювалась в єдиних одиницях: долари, євро, або ієни. Однак більшість валют мають субодиниці: наприклад, в US це долари та центи. Найбільш прямолінійний шлях моделювати центи є мати поле <code>amount</code> в <code>US.Currency</code>, що представляє центи замість доларів. Для конвертації назад до доларів є корисним ввести поле <code>CurrencyUnit</code> в клас <code>CurrencyZone</code>, що містить суму в одній стандартній одиниці цієї валюти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
<span class="o">...</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span><span class="k">:</span> <span class="kt">Currency</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як показано в Лістингу 20.11, об'єкт <code>US</code> може визначати кількості в <code>Cent</code>, <code>Dollar</code>, та <code>CurrencyUnit</code>. Це визначення є таке саме, як попереднє визначення об'єкта <code>US</code>, за винятком того, що воно додає три нові поля. Поле <code>Cent</code> представляє суму в 1 <code>US.Currency</code>. Це об'єкт, аналогічний до монеті в один цент. Поле <code>Dollar</code> представляє суму в 100 <code>US.Currency</code>. Так що об'єкт <code>US</code> тепер визначає ім'я <code>Dollar</code> в два способи. Тип <code>Dollar</code> (визначаний абстрактним інутрішнім класом на ім'я <code>Dollar</code>) представляє дженерік ім'я <code>Currency</code>, валідної в валютній зоні <code>US</code>. Для контрасту, значення <code>Dollar</code> (на яке посилається поле <code>val</code> на ім'я <code>Dollar</code>) представляє окремий US долар, подібно до однодоларового чеку. Третє визначення поля <code>CurrencyUnit</code> задає факт, що стандартна одиниця валюти в US зоні є <code>Dollar</code> (тобто, значення <code>Dollar</code>, на яке посилається поле, не тип <code>Dollar</code>).</p></div>
<div class="paragraph"><p>Метод <code>toString</code> в класі <code>Currency</code> також потребує бути адаптованим, щоб приймати до уваги субодиниці. Наприклад, сума десяти доларів і двадцяти трьох центів має друкуватись як десятичне число: 10.23 USD.</p></div>
<div class="paragraph"><p>Щоб досягти цього, ви повинні реалізовати метод <code>Currency</code> <code>toString</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
  <span class="o">((</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
  <span class="n">formatted</span> <span class="o">(</span><span class="s">&quot;%.&quot;</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;f&quot;</span><span class="o">)</span>
  <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>formatted</code> є методом, що Scala робить доступним для декількох класів, включачи <code>Double</code>.<span class="footnote"><br />[Scala використовує багаті огортки, описані в Розділі 5.10, щоб зробити форматування можливим.]<br /></span> Метод <code>formatted</code> повертає рядок, що є результатом форматування оригінального рядка, на якому було викликано <code>formatted</code>, відповідно до рядка формату, переданого як правий операнд метода <code>formatted</code>. Синтаксис рядка формату, переданого в <code>formatted</code>, той самий, що і для Java метода <code>String.format</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">US</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Dollar</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;USD&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Dollar</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">cents</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollar</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">cents</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">Cent</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">Dollar</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span> <span class="k">=</span> <span class="nc">Dollar</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.11 - Валютна зона <code>US</code>.</p></div>
<div class="paragraph"><p>Наприклад, рядок формату <code>%.2f</code> форматує число з двома десятичними цифрами. Рядок формату, використаний в показаному <code>toString</code> складається з виклику метода <code>decimals</code> на <code>CurrencyUnit.amount</code>. Цей метод повертає число десятичних знаків в десятичній ступіні мінус один. Наприклад, <code>decimals(10)</code> є <code>1</code>, <code>decimals(100)</code> є <code>2</code>, і так далі. Метод <code>decimals</code> реалізований через просту рекурсію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">private</span> <span class="k">def</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.12 показує деякі інші валютні зони. Як інше покращення ви можете додати до моделі можливість конвертації валют. Зпершу, вам треба написати о'бєкт <code>Converter</code>, що містить допустимі курси обміну між валютами, як показано в Лістингу 20.13. Потім ви можете додати метод конвертації, <code>from</code>, до класу <code>Currency</code>, що конвертує з наданої валюти в поточну валюту об'єкту <code>Currency</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">CurrencyZone</span><span class="k">#</span><span class="kt">AbstractCurrency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
  <span class="n">make</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">round</span><span class="o">(</span>
  <span class="n">other</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">*</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">exchangeRate</span>
  <span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">designation</span><span class="o">)(</span><span class="k">this</span><span class="o">.</span><span class="n">designation</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>from</code> приймає довільну валюту як аргумент. Це виражається в типи його формального параметру, <code>CurrencyZone#AbstractCurrency</code>, що вказує, що аргумент, переданий як <code>other</code>, має бути типу <code>AbstractCurrency</code> в якійсь, невідомій <code>CurrencyZone</code>. Він продукує свій результат чеерз множення суми в іншій валюті на курс обміну між іншою та поточною валютою.<span class="footnote"><br />[Доречі, якщо ви думаєте ви отримали погані справи з японською ієною, курси обміну конвертують валюти на основі своїх сум <code>CurrencyZone</code>. Таким чином, 1.211 є курс обміну між US центами та японськіми ієнами.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Europe</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Euro</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;EUR&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Euro</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">cents</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Euro</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">cents</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">Cent</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">Euro</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span> <span class="k">=</span> <span class="nc">Euro</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Japan</span> <span class="k">extends</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Yen</span> <span class="k">extends</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">designation</span> <span class="k">=</span> <span class="s">&quot;JPY&quot;</span>
  <span class="o">}</span>
  <span class="k">type</span> <span class="kt">Currency</span> <span class="o">=</span> <span class="nc">Yen</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">yen</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Yen</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span> <span class="k">=</span> <span class="n">yen</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">Yen</span> <span class="k">=</span> <span class="n">make</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span> <span class="k">=</span> <span class="nc">Yen</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.12 - Валютні зони для Європи та Японії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Converter</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">exchangeRate</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span>
    <span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span>   <span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.7596</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.211</span> <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.223</span><span class="o">),</span>
    <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.316</span> <span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.594</span> <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.623</span><span class="o">),</span>
    <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.8257</span><span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.6272</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span>   <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.018</span><span class="o">),</span>
    <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;USD&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.8108</span><span class="o">,</span> <span class="s">&quot;EUR&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.6160</span><span class="o">,</span>
                 <span class="s">&quot;JPY&quot;</span> <span class="o">-&gt;</span> <span class="mf">0.982</span> <span class="o">,</span> <span class="s">&quot;CHF&quot;</span> <span class="o">-&gt;</span> <span class="mf">1.0</span> <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.13 - Об'єкт конвертора з мапою курсів обміну.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CurrencyZone</span> <span class="o">{</span>

  <span class="k">type</span> <span class="kt">Currency</span> <span class="k">&lt;:</span> <span class="kt">AbstractCurrency</span>
  <span class="k">def</span> <span class="n">make</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span>

  <span class="k">abstract</span> <span class="k">class</span> <span class="nc">AbstractCurrency</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Long</span>
    <span class="k">def</span> <span class="n">designation</span><span class="k">:</span> <span class="kt">String</span>

    <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">*</span> <span class="n">x</span><span class="o">).</span><span class="n">toLong</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
      <span class="n">make</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">make</span><span class="o">((</span><span class="k">this</span><span class="o">.</span><span class="n">amount</span> <span class="o">/</span> <span class="n">that</span><span class="o">).</span><span class="n">toLong</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Currency</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">this</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="n">that</span><span class="o">.</span><span class="n">amount</span>

    <span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">CurrencyZone</span><span class="k">#</span><span class="kt">AbstractCurrency</span><span class="o">)</span><span class="k">:</span> <span class="kt">Currency</span> <span class="o">=</span>
        <span class="n">make</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">round</span><span class="o">(</span>
        <span class="n">other</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">*</span> <span class="nc">Converter</span><span class="o">.</span><span class="n">exchangeRate</span>
        <span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="n">designation</span><span class="o">)(</span><span class="k">this</span><span class="o">.</span><span class="n">designation</span><span class="o">)))</span>

    <span class="k">private</span> <span class="k">def</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">10</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span>
      <span class="o">((</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span> <span class="o">/</span> <span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">.</span><span class="n">toDouble</span><span class="o">)</span>
       <span class="n">formatted</span> <span class="o">(</span><span class="s">&quot;%.&quot;</span> <span class="o">+</span> <span class="n">decimals</span><span class="o">(</span><span class="nc">CurrencyUnit</span><span class="o">.</span><span class="n">amount</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot;f&quot;</span><span class="o">)</span>
       <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">designation</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">val</span> <span class="nc">CurrencyUnit</span><span class="k">:</span> <span class="kt">Currency</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 20.14 - Повний код класу <code>CurrencyZone</code>.</p></div>
<div class="paragraph"><p>Фінальна версія класу <code>CurrencyZone</code> показана на Лістингу 20.14. Ви можете протестувати клас в командній оболонці Scala. Ми будемо вважати, що клас <code>CurrencyZone</code> та всі суцільні об'єкти <code>CurrencyZone</code> визначені в пакунку <code>org.stairwaybook.currencies</code>. Перший крок є імпортувати  <code>org.stairwaybook.currencies._</code> в командну оболонку. Потім ви можете зробити деякі конвертації валют:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Japan</span><span class="o">.</span><span class="nc">Yen</span> <span class="n">from</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">*</span> <span class="mi">100</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Japan.Currency</span> <span class="o">=</span> <span class="mi">12110</span> <span class="nc">JPY</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Europe</span><span class="o">.</span><span class="nc">Euro</span> <span class="n">from</span> <span class="n">res16</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Europe.Currency</span> <span class="o">=</span> <span class="mf">75.95</span> <span class="nc">EUR</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="n">from</span> <span class="n">res17</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">US.Currency</span> <span class="o">=</span> <span class="mf">99.95</span> <span class="nc">USD</span>
</pre></div></div></div>
<div class="paragraph"><p>Факт, що ви отримали майже ті самі суми після трьох конвертацій каже нам, що це досить гарні обмінні курси! Ви також можете пододавати значення в тій самій валюті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">res18</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">US.Currency</span> <span class="o">=</span> <span class="mf">199.95</span> <span class="nc">USD</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку, ви не можете додавати суми в різних валютах:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">+</span> <span class="nc">Europe</span><span class="o">.</span><span class="nc">Euro</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Europe.Euro</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">US.Currency</span>
    <span class="o">(</span><span class="n">which</span> <span class="n">expands</span> <span class="n">to</span><span class="o">)</span> <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span>
              <span class="nc">US</span><span class="o">.</span><span class="nc">Dollar</span> <span class="o">+</span> <span class="nc">Europe</span><span class="o">.</span><span class="nc">Euro</span>
                                 <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Через запобігання додавань двох значень в різних одиницях (в цьому випадку валют), абстракція типів робить свою роботу. Це утримує нас від виконання безглуздих обчислень. Збої коректної конвертації між різними одиницями може виглядати як тривіальні баги, але вони призводили до багатьох серйозних системних відмов. Як приклад можна навести аварію космічного корабля Mars Climate Orbiter 23 вересня 1999го року, що сталась через те, що одна інженерна команда використовувала метричні одиниці, тоді як інша використовувала англійські одиниці. Якщо одиниці були б закодовані в той же спосіб, що і валюти в цьому розділі, ця помилка була б детектована простим запуском компілятора. Замість цього це спричинило аварію орбітального корабля після майже десятимісячної подорожі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_11_">20.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala пропонує систематичну і дуже загальну підтримку для об'єктно-орієнтовних абстракцій. Вона дозволяє вам абстрагувати не тільки методи, але також значення, змінні і типи. Ця глава показала, як отримати переваги від абстрактних членів. Вони підтримують простий, але ефективний принцип для структурування систем: коли ви розробляєте клас, робіть все, що доки невідоме, як абстрактний член. Потім система типів буде рухати розробку вашої моделі, так само, як ви бачили в лабораторій роботі про валюту. Не має значення, чи невідомим є тип, метод, змінна або значення. В Scala все це може бути визначено абстрактно.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-11 08:03:11 EET
</div>
</div>
</body>
</html>
