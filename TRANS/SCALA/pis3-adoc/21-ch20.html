<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__20">Глава 20</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Абстрактні члени</h1>
<div class="paragraph"><p>Член класа або трейта є абстрактним, якщо член не має повного визначення в класі. Абстрактні члени призначені бути реалізованими в субкласах класа, в якому вони визначені. Ця ідея знаходиться в багатьох об'єктно-рієнтованих мовах. Наприклад, Java дозволяє вам декларувани абстрактні методи. Scala також дозволяє вам декларувати такі методи, як ви бачили в Розділі 10.2. Але Scala іде далі, і реалізує ідею в своїй повній загальності: крім методів, ви можете декларувати абстрактні поля, та навіть абстрактні типи, як члени класів та трейтів.</p></div>
<div class="paragraph"><p>В цій главі ми опишемо всі типи абстрактних членів: <code>val</code>, <code>var</code>, методи та типи. По ходу ми обсудимо наперед-ініціалізовані поля, ліниві <code>val</code>, шлях-залежні типи та енумерації.</p></div>
<div class="sect1">
<h2 id="_20_1_____">20.1 Швидкий тур для абстрактних членів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Наступний трейт декларує по одному з кожного типу абстрактних членів: абстрактний тип (<code>T</code>), метод (<code>transform</code>), <code>val</code> (<code>initial</code>), та <code>var</code> (<code>current</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Суцільна реалізація <code>Abstract</code> потребує заповнення визначень для кожного з його абстрактних членів. Ось приклад реалізації, що провадить ці визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Concrete</span> <span class="k">extends</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
  <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">initial</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація надає певне значення типу на ім'я <code>T</code>, через його визначення як псевдониму до типу <code>String</code>. Операція <code>transform</code> конкатенує наданий рядок з собою, та значення <code>initial</code> та <code>current</code> обоє встановлені в <code>"hi"</code>.</p></div>
<div class="paragraph"><p>Цей приклад надає вам грубу першу ідею щодо типів абстрактних членів, що існують в Scala. Залишок глави буде презентувати деталі, та пояснювати, для чого гарні нові форми абстрактних членів, так само, як і типи членів взагалі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_2__">20.2 Члени типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як ви можете бачити з приклада в попередньому розділі, термін <em>абстрактний тип</em> в Scala означає тип, декларований (за допомогою ключового слова <code>type</code>) як член класу або трейта, без вказання визначення. Класи самі можуть бути абстрактними, та трейти по визначенню абстрактні, але на жодний з них не посилаються як на абстрактні типи в Scala. Абстрактний тип в Scala завжди є членом деякого класу або трейта, як тип <code>T</code> в трейті <code>Abstract</code>.</p></div>
<div class="paragraph"><p>Ви можете думати про не-абстрактні (або <em>суцільні</em>) члени типів, як тип <code>T</code> в класі <code>Concrete</code>, як шлях для визначення нового визначення, або псевдоним, для типу. Наприклад, в класі <code>Concrete</code>, типу <code>String</code> наданий псевдоним <code>T</code>. Як результат, будь-де, де з'являється <code>T</code> в визначенні класа <code>Concrete</code>, це означає <code>String</code>. Це включає параметр і типи результатів для <code>transform</code>, <code>initial</code> та <code>current</code>, які згадують <code>T</code>, коли вони декларовані в супертрейті <code>Abstract</code>. Таким чином, коли клас <code>Concrete</code> реалізує ці методи, ці <code>T</code> інтерпретуються щоб означати <code>String</code>.</p></div>
<div class="paragraph"><p>Одна з причин для використання члена типу є визначення коротких, описових псевдонимів для типів, чиє дійсне ім'я більш балакуче, або менш очевидне за значенням, ніж псевдоним. Такі члени типів можуть допомогти прояснити код класа або трейта. Інше головне використання членів типа є декларація абстрактних типів, що мають бути визначені в субкласах. Це використання, що було продемонстроване в попередньому розділі, буде детально описане в цій главі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_20_3__val">20.3 Абстрактні val</h2>
<div class="sectionbody">
<div class="paragraph"><p>Абстрактна декларація <code>val</code> має таку форму:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона надає ім'я та тип для <code>val</code>, але не його значення. Це значення має бути запровадження через суцільне визначення <code>val</code> в субкласі. Наприклад, клас <code>Concrete</code> реалізує <code>val</code> з використанням:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">&quot;hi&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви використовуєте абстрактну декларацію <code>val</code> в класі, коли ви не знаєте коректного значення в класі, але ви знаєте, що змінна буде мати незмінне значення для кожного примірника класа.</p></div>
<div class="paragraph"><p>Абстрактна декларація <code>val</code> повторює декларацію абстрактного безпараметричного метода, декларованого таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Клієнтській код може посилатись на обох, <code>val</code> та метод, в точно той самий спосіб (тобто, <code>obj.initial</code>). Однак, якщо <code>initial</code> є абстрактна <code>val</code>, клієнту гарантовано, що <code>obj.initial</code> буде давати те саме значення кожний раз, коли на нього посилаються. Якщо <code>initial</code> буде абстрактний метод, ця гарантія не виконується, оскільки в цьому випадку <code>initial</code> може бути реалізований суцільним методом, що повертає різне значення при кожному виклику.</p></div>
<div class="paragraph"><p>In other words, an abstract val constrains its legal implementation: Any implementation must be
a val definition; it may not be a var or a def. Abstract method declarations, on the other hand, may be
implemented by both concrete method definitions and concrete valdefinitions. Given the abstract
class Fruit shown in Listing 20.1, class Apple would be a legal subclass implementation, but
class BadApple would not.
abstract class Fruit {val v: String // &8216;v&#8217; for value
def m: String // &#8216;m&#8217; for method
}
abstract class Apple extends Fruit {
val v: String
val m: String // OK to override a &#8216;def&#8217; with a &#8216;val&#8217;
}
abstract class BadApple extends Fruit {
def v: String // ERROR: cannot override a &#8216;val&#8217; with a &#8216;def&#8217;
def m: String
}
Listing 20.1 - Overriding abstract vals and parameterless methods.
20.4 ABSTRACT VARS
Like an abstract val, an abstract var declares just a name and a type, but not an initial value. For
instance, Listing 20.2 shows a trait AbstractTime, which declares two abstract variables
named hour and minute:
trait AbstractTime {
var hour: Int
var minute: Int
}
Listing 20.2 - Declaring abstract vars.
What is the meaning of abstract vars like hour and minute? You saw in Section 18.2 that vars declared
as members of classes come equipped with getter and setter methods. This holds for abstract vars as
well. If you declare an abstract var named hour, for example, you implicitly declare an abstract getter
method, hour, and an abstract setter method, hour_=. There&#8217;s no reassignable field to be defined—that
will come in subclasses that define the concrete implementation of the abstract var. For instance, the
definition of AbstractTime shown inListing 20.2 is exactly equivalent to the definition shown in Listing
20.3.
trait
def
def
def
def
}
AbstractTime {
hour: Int
hour_=(x: Int)
minute: Int
minute_=(x: Int)


getter
setter
getter
setter
for
for
for
for
&#8216;hour&#8217;
&#8216;hour&#8217;
&#8216;minute&#8217;
&#8216;minute&#8217;
Listing 20.3 - How abstract vars are expanded into getters and setters.
20.5 INITIALIZING ABSTRACT VALS
Abstract vals sometimes play a role analogous to superclass parameters: they let you provide details in
a subclass that are missing in a superclass. This is particularly important for traits, because traits don&#8217;t
have a constructor to which you could pass parameters. So the usual notion of parameterizing a trait
works via abstract vals that are implemented in subclasses.As an example, consider a reformulation of class Rational from Chapter 6, as shown in Listing
6.5 here, as a trait:
trait RationalTrait {
val numerArg: Int
val denomArg: Int
}
The Rational class from Chapter 6 had two parameters: n for the numerator of the rational number,
and d for the denominator. The RationalTrait trait given here defines instead two
abstract vals: numerArg and denomArg. To instantiate a concrete instance of that trait, you need to
implement the abstract val definitions. Here&#8217;s an example:
new RationalTrait {
val numerArg = 1
val denomArg = 2
}
Here the keyword new appears in front of a trait name, RationalTrait, which is followed by a class body
in curly braces. This expression yields an instance of an anonymous class that mixes in the trait and is
defined by the body. This particular anonymous class instantiation has an effect analogous to the
instance creation new Rational(1, 2).
The analogy is not perfect, however. There&#8217;s a subtle difference concerning the order in which
expressions are initialized. When you write:
new Rational(expr1, expr2)
the two expressions, expr1 and expr2, are evaluated before class Rational is initialized, so the values
of expr1 and expr2 are available for the initialization of class Rational.
For traits, the situation is the opposite. When you write:
new RationalTrait {
val numerArg = expr1
val denomArg = expr2
}
the expressions, expr1 and expr2, are evaluated as part of the initialization of the anonymous class, but
the anonymous class is initialized after the RationalTrait. So the values of numerArgand denomArg are
not available during the initialization of RationalTrait (more precisely, a selection of either value would
yield the default value for type Int, 0). For the definition ofRationalTrait given previously, this is not a
problem, because the trait&#8217;s initialization does not make use of values numerArg or denomArg.
However, it becomes a problem in the variant ofRationalTrait shown in Listing 20.4, which defines
normalized numerators and denominators.
trait RationalTrait {
val numerArg: Int
val denomArg: Int
require(denomArg != 0)
private val g = gcd(numerArg, denomArg)}
val numer = numerArg / g
val denom = denomArg / g
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
override def toString = numer + "/" + denom
Listing 20.4 - A trait that uses its abstract vals.
If you try to instantiate this trait with some numerator and denominator expressions that are not simple
literals, you&#8217;ll get an exception:
scala&gt; val x = 2
x: Int = 2
scala&gt; new RationalTrait {
val numerArg = 1 * x
val denomArg = 2 * x
}
java.lang.IllegalArgumentException: requirement failed
at scala.Predef$.require(Predef.scala:207)
at RationalTrait$class.$init$(&lt;console&gt;:10)
&#8230; 28 elided
The exception in this example was thrown because denomArg still had its default value of 0 when
class RationalTrait was initialized, which caused the require invocation to fail.
This example demonstrates that initialization order is not the same for class parameters and abstract
fields. A class parameter argument is evaluated before it is passed to the class constructor (unless the
parameter is by-name). An implementing val definition in a subclass, by contrast, is evaluated
only after the superclass has been initialized.
Now that you understand why abstract vals behave differently from parameters, it would be good to
know what can be done about this. Is it possible to define a RationalTrait that can be initialized
robustly, without fearing errors due to uninitialized fields? In fact, Scala offers two alternative solutions
to this problem, pre-initialized fields and lazy vals. They are presented in the remainder of this section.
Pre-initialized fields
The first solution, pre-initialized fields, lets you initialize a field of a subclass before the superclass is
called. To do this, simply place the field definition in braces before the superclass constructor call. As
an example, Listing 20.5 shows another attempt to create an instance of RationalTrait. As you see from
this example, the initialization section comes before the mention of the supertrait RationalTrait. Both
are separated by a with.
scala&gt; new {
val numerArg = 1 * x
val denomArg = 2 * x
} with RationalTrait
res1: RationalTrait = 1/2Listing 20.5 - Pre-initialized fields in an anonymous class expression.
Pre-initialized fields are not restricted to anonymous classes; they can also be used in objects or named
subclasses. Two examples are shown in Listings 20.6 and 20.7. As you can see from these examples,
the pre-initialization section comes in each case after the extends keyword of the defined object or
class. Class RationalClass, shown in Listing 20.7, exemplifies a general schema of how class
parameters can be made available for the initialization of a supertrait.
object twoThirds extends {
val numerArg = 2
val denomArg = 3
} with RationalTrait
Listing 20.6 - Pre-initialized fields in an object definition.
class RationalClass(n: Int, d: Int) extends {
val numerArg = n
val denomArg = d
} with RationalTrait {
def + (that: RationalClass) = new RationalClass(
numer * that.denom + that.numer * denom,
denom * that.denom
)
}
Listing 20.7 - Pre-initialized fields in a class definition.
Because pre-initialized fields are initialized before the superclass constructor is called, their initializers
cannot refer to the object that&#8217;s being constructed. Consequently, if such an initializer refers to this, the
reference goes to the object containing the class or object that&#8217;s being constructed, not the constructed
object itself.
Here&#8217;s an example:
scala&gt; new {
val numerArg = 1
val denomArg = this.numerArg * 2
} with RationalTrait
&lt;console&gt;:11: error: value numerArg is not a member of object
$iw
val denomArg = this.numerArg * 2
<sup>
The example did not compile because the reference this.numerArg was looking for a numerArgfield in
the object containing the new (which in this case was the synthetic object named $iw, into which the
interpreter puts user input lines). Once more, pre-initialized fields behave in this respect like class
constructor arguments.
Lazy vals
You can use pre-initialized fields to simulate precisely the initialization behavior of class constructor
arguments. Sometimes, however, you might prefer to let the system itself sort out how things should be
initialized. This can be achieved by making your val definitions lazy. If you prefix a val definition witha lazy modifier, the initializing expression on the right-hand side will only be evaluated the first time
the val is used.
For an example, define an object Demo with a val as follows:
scala&gt; object Demo {
val x = { println("initializing x"); "done" }
}
defined object Demo
Now, first refer to Demo, then to Demo.x:
scala&gt; Demo
initializing x
res3: Demo.type = Demo$@2129a843
scala&gt; Demo.x
res4: String = done
As you can see, the moment you use Demo, its x field becomes initialized. The initialization of xforms
part of the initialization of Demo. The situation changes, however, if you define the x field to be lazy:
scala&gt; object Demo {
lazy val x = { println("initializing x"); "done" }
}
defined object Demo
scala&gt; Demo
res5: Demo.type = Demo$@5b1769c
scala&gt; Demo.x
initializing x
res6: String = done
Now, initializing Demo does not involve initializing x. The initialization of x will be deferred until the
first time x is used. This is similar to the situation where x is defined as a parameterless method, using
a def. However, unlike a def, a lazy val is never evaluated more than once. In fact, after the first
evaluation of a lazy val the result of the evaluation is stored, to be reused when the same val is used
subsequently.
Looking at this example, it seems that objects like Demo themselves behave like lazy vals, in that they
are also initialized on demand, the first time they are used. This is correct. In fact an object definition
can be seen as a shorthand for the definition of a lazy val with an anonymous class that describes the
object&#8217;s contents.
Using lazy vals, you could reformulate RationalTrait as shown in Listing 20.8. In the new trait
definition, all concrete fields are defined lazy. Another change with respect to the previous definition
of RationalTrait, shown in Listing 20.4, is that the require clause was moved from the body of the trait
to the initializer of the private field, g, which computes the greatest common divisor
of numerArg and denomArg. With these changes, there&#8217;s nothing that remains to be donewhen LazyRationalTrait is initialized; all initialization code is now part of the right-hand side of a
lazy val. Thus, it is safe to initialize the abstract fields of LazyRationalTrait after the class is defined.
trait LazyRationalTrait {
val numerArg: Int
val denomArg: Int
lazy val numer = numerArg / g
lazy val denom = denomArg / g
override def toString = numer + "/" + denom
private lazy val g = {
require(denomArg != 0)
gcd(numerArg, denomArg)
}
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 20.8 - Initializing a trait with lazy vals.
Here&#8217;s an example:
scala&gt; val x = 2
x: Int = 2
scala&gt; new LazyRationalTrait {
val numerArg = 1 * x
val denomArg = 2 * x
}
res7: LazyRationalTrait = 1/2
No pre-initialization is needed. It&#8217;s instructive to trace the sequence of initializations that lead to the
string 1/2 to be printed in the code above:
1. A fresh instance of LazyRationalTrait gets created and the initialization code
ofLazyRationalTrait is run. This initialization code is empty; none of the fields
ofLazyRationalTrait is initialized yet.
2. Next, the primary constructor of the anonymous subclass defined by the new expression is
executed. This involves the initialization of numerArg with 2 and denomArg with 4.
3. Next, the toString method is invoked on the constructed object by the interpreter, so that the
resulting value can be printed.
4. Next, the numer field is accessed for the first time by the toString method in
traitLazyRationalTrait, so its initializer is evaluated.
5. The initializer of numer accesses the private field, g, so g is evaluated next. This evaluation
accesses numerArg and denomArg, which were defined in Step 2.
6. Next, the toString method accesses the value of denom, which causes denom&#8217;s evaluation. The
evaluation of denom accesses the values of denomArg and g. The initializer of the g field is not
re-evaluated, because it was already evaluated in Step 5.
7. Finally, the result string "1/2" is constructed and printed.Note that the definition of g comes textually after the definitions of numer and denom in
classLazyRationalTrait. Nevertheless, because all three values are lazy, g gets initialized before the
initialization of numer and denom is completed.
This shows an important property of lazy vals: The textual order of their definitions does not matter
because values get initialized on demand. Thus, lazy vals can free you as a programmer from having to
think hard how to arrange val definitions to ensure that everything is defined when it is needed.
However, this advantage holds only as long as the initialization of lazy vals neither produces side
effects nor depends on them. In the presence of side effects, initialization order starts to matter. And
then it can be quite difficult to trace in what order initialization code is run, as the previous example has
demonstrated. So lazy vals are an ideal complement to functional objects, where the order of
initializations does not matter, as long as everything gets initialized eventually. They are less well
suited for code that&#8217;s predominantly imperative.
LAZY FUNCTIONAL LANGUAGES
Scala is by no means the first language to have exploited the perfect match of lazy definitions and
functional code. In fact, there is a category of "lazy functional programming languages" in
which every value and parameter is initialized lazily. The best known member of this class of languages
is Haskell [SPJ02].
20.6 ABSTRACT TYPES
In the beginning of this chapter, you saw, "type T", an abstract type declaration. The rest of this chapter
discusses what such an abstract type declaration means and what it&#8217;s good for. Like all other abstract
declarations, an abstract type declaration is a placeholder for something that will be defined concretely
in subclasses. In this case, it is a type that will be defined further down the class hierarchy. So T above
refers to a type that is as yet unknown at the point where it is declared. Different subclasses can provide
different realizations of T.
Here is a well-known example where abstract types show up naturally. Suppose you are given the task
of modeling the eating habits of animals. You might start with a class Food and a classAnimal with
an eat method:
class Food
abstract class Animal {
def eat(food: Food)
}
You might then attempt to specialize these two classes to a class of Cows that eat Grass:
class Grass extends Food
class Cow extends Animal {
override def eat(food: Grass) = {} // This won&#8217;t compile
}
However, if you tried to compile the new classes, you&#8217;d get the following compilation errors:BuggyAnimals.scala:7: error: class Cow needs to be
abstract, since method eat in class Animal of type
(Food)Unit is not defined
class Cow extends Animal {
</sup>
BuggyAnimals.scala:8: error: method eat overrides nothing
override def eat(food: Grass) = {}
<sup>
What happened is that the eat method in class Cow did not override the eat method in
classAnimal because its parameter type is different: it&#8217;s Grass in class Cow vs. Food in class Animal.
Some people have argued that the type system is unnecessarily strict in refusing these classes. They
have said that it should be OK to specialize a parameter of a method in a subclass. However, if the
classes were allowed as written, you could get yourself in unsafe situations very quickly.
For instance, the following script would pass the type checker:
class Food
abstract class Animal {
def eat(food: Food)
}
class Grass extends Food
class Cow extends Animal {
override def eat(food: Grass) = {} // This won&#8217;t compile,
}

class Fish extends Food
val bessy: Animal = new Cow
bessy eat (new Fish)

The program would compile if the restriction were eased, because Cows are Animals and Animals do
have an eat method that accepts any kind of Food, including Fish. But surely it would do a cow no
good to eat a fish!
What you need to do instead is apply some more precise modeling. Animals do eat Food, but what kind
of Food each Animal eats depends on the Animal. This can be neatly expressed with an abstract type,
as shown in Listing 20.9:
class Food
abstract class Animal {
type SuitableFood &lt;: Food
def eat(food: SuitableFood)
}
Listing 20.9 - Modeling suitable food with an abstract type.
With the new class definition, an Animal can eat only food that&#8217;s suitable. What food is suitable cannot
be determined at the level of the Animal class. That&#8217;s why SuitableFood is modeled as an abstract type.
The type has an upper bound, Food, which is expressed by the "&lt;: Food" clause. This means that any
concrete instantiation of SuitableFood (in a subclass of Animal) must be a subclass of Food. For
example, you would not be able to instantiate SuitableFood with classIOException.With Animal defined, you can now progress to cows, as shown in Listing 20.10. Class Cow fixes
its SuitableFood to be Grass and also defines a concrete eat method for this kind of food.
class Grass extends Food
class Cow extends Animal {
type SuitableFood = Grass
override def eat(food: Grass) = {}
}
Listing 20.10 - Implementing an abstract type in a subclass.
These new class definitions compile without errors. If you tried to run the "cows-that-eat-fish"
counterexample with the new class definitions, you would get the following compiler error:
scala&gt; class Fish extends Food
defined class Fish
scala&gt; val bessy: Animal = new Cow
bessy: Animal = <a href="mailto:Cow@1515d8a6">Cow@1515d8a6</a>
scala&gt; bessy eat (new Fish)
&lt;console&gt;:14: error: type mismatch;
found
: Fish
required: bessy.SuitableFood
bessy eat (new Fish)
</sup>
20.7 PATH-DEPENDENT TYPES
Have a look at the last error message again. What&#8217;s interesting about it is the type required by
the eat method: bessy.SuitableFood. This type consists of an object reference, bessy, followed by a type
field, SuitableFood, of the object. So this shows that objects in Scala can have types as members. The
meaning of bessy.SuitableFood is "the type SuitableFood that is a member of the object referenced
from bessy" or, alternatively, the type of food that&#8217;s suitable for bessy.
A type like bessy.SuitableFood is called a path-dependent type. The word "path" here means a
reference an object. It could be a single name, such as bessy, or a longer access path, such
asfarm.barn.bessy, where each of farm, barn, and bessy are variables (or singleton object names) that
refer to objects.
As the term "path-dependent type" implies, the type depends on the path; in general, different paths
give rise to different types. For instance, say you defined classes DogFood andDog, like this:
class DogFood extends Food
class Dog extends Animal {
type SuitableFood = DogFood
override def eat(food: DogFood) = {}
}
If you attempted to feed a dog with food fit for a cow, your code would not compile:
scala&gt; val bessy = new Cow
bessy: Cow = <a href="mailto:Cow@713e7e09scala">Cow@713e7e09scala</a>&gt; val lassie = new Dog
lassie: Dog = <a href="mailto:Dog@6eaf2c57">Dog@6eaf2c57</a>
scala&gt; lassie eat (new bessy.SuitableFood)
&lt;console&gt;:16: error: type mismatch;
found
: Grass
required: DogFood
lassie eat (new bessy.SuitableFood)
<sup>
The problem here is that the type of the SuitableFood object passed to
the eat method,bessy.SuitableFood, is incompatible with the parameter type of eat, lassie.SuitableFood.
The case would be different for two Dogs. Because Dog&#8217;s SuitableFood type is defined to be an alias
for class DogFood, the SuitableFood types of two Dogs are in fact the same. As a result,
the Doginstance named lassie could actually eat the suitable food of a different Dog instance (which
we&#8217;ll name bootsie):
scala&gt; val bootsie = new Dog
bootsie: Dog = <a href="mailto:Dog@13a7c48c">Dog@13a7c48c</a>
scala&gt; lassie eat (new bootsie.SuitableFood)
A path-dependent type resembles the syntax for an inner class type in Java, but there is a crucial
difference: a path-dependent type names an outer object, whereas an inner class type names an
outer class. Java-style inner class types can also be expressed in Scala, but they are written differently.
Consider these two classes, Outer and Inner:
class Outer {
class Inner
}
In Scala, the inner class is addressed using the expression Outer#Inner instead of Java&#8217;sOuter.Inner. The
&#8216;.&#8217; syntax is reserved for objects. For example, imagine you instantiate two objects of type Outer, like
this:
val o1 = new Outer
val o2 = new Outer
Here o1.Inner and o2.Inner are two path-dependent types (and they are different types). Both of these
types conform to (are subtypes of) the more general type Outer#Inner, which represents the Inner class
with an arbitrary outer object of type Outer. By contrast, typeo1.Inner refers to the Inner class with
a specific outer object (the one referenced from o1). Likewise, type o2.Inner refers to the Inner class
with a different, specific outer object (the one referenced from o2).
In Scala, as in Java, inner class instances hold a reference to an enclosing outer class instance. This
allows an inner class, for example, to access members of its outer class. Thus you can&#8217;t instantiate an
inner class without in some way specifying an outer class instance. One way to do this is to instantiatethe inner class inside the body of the outer class. In this case, the current outer class instance
(referenced from this) will be used.
Another way is to use a path-dependent type. For example, because the type, o1.Inner, names a specific
outer object, you can instantiate it:
scala&gt; new o1.Inner
res11: o1.Inner = Outer$<a href="mailto:Inner@1ae1e03f">Inner@1ae1e03f</a>
The resulting inner object will contain a reference to its outer object, the object referenced from o1. By
contrast, because the type Outer#Inner does not name any specific instance of Outer, you can&#8217;t create an
instance of it:
scala&gt; new Outer#Inner
&lt;console&gt;:9: error: Outer is not a legal prefix for a
constructor
new Outer#Inner
</sup>
20.8 REFINEMENT TYPES
When a class inherits from another, the first class is said to be a nominal subtype of the other one. It&#8217;s
a nominal subtype because each type has a name, and the names are explicitly declared to have a
subtyping relationship. Scala additionally supports structural subtyping,where you get a subtyping
relationship simply because two types have compatible members. To get structural subtyping in Scala,
use Scala&#8217;s refinement types.
Nominal subtyping is usually more convenient, so you should try nominal types first with any new
design. A name is a single short identifier and thus is more concise than an explicit listing of member
types. Further, structural subtyping is often more flexible than you want. A widget can draw(), and a
Western cowboy can draw(), but they aren&#8217;t really substitutable. You&#8217;d typically prefer to get a
compilation error if you tried to substitute a cowboy for a widget.
Nonetheless, structural subtyping has its own advantages. One is that sometimes there really is no more
to a type than its members. For example, suppose you want to define a Pastureclass that can contain
animals that eat grass. One option would be to define a traitAnimalThatEatsGrass and mix it into every
class where it applies. It would be verbose, however. Class Cow has already declared that it&#8217;s an animal
and that it eats grass, and now it would have to declare that it is also an animal-that-eats-grass.
Instead of defining AnimalThatEatsGrass, you can use a refinement type. Simply write the base
type, Animal, followed by a sequence of members listed in curly braces. The members in the curly
braces further specify—or refine, if you will—the types of members from the base class.
Here is how you write the type, "animal that eats grass":
Animal { type SuitableFood = Grass }
Given this type, you can now write the pasture class like this:class Pasture {
var animals: List[Animal { type SuitableFood = Grass }] = Nil

}
20.9 ENUMERATIONS
An interesting application of path-dependent types is found in Scala&#8217;s support for enumerations. Some
other languages, including Java and C, have enumerations as a built-in language construct to define
new types. Scala does not need special syntax for enumerations. Instead, there&#8217;s a class in its standard
library, scala.Enumeration.
To create a new enumeration, you define an object that extends this class, as in the following example,
which defines a new enumeration of Colors:
object Color extends Enumeration {
val Red = Value
val Green = Value
val Blue = Value
}
Scala lets you also shorten several successive val or var definitions with the same right-hand side.
Equivalently to the above you could write:
object Color extends Enumeration {
val Red, Green, Blue = Value
}
This object definition provides three values: Color.Red, Color.Green, and Color.Blue. You could also
import everything in Color with:
import Color._
and then just use Red, Green, and Blue. But what is the type of these values?
Enumeration defines an inner class named Value, and the same-named parameterless Valuemethod
returns a fresh instance of that class. In other words, a value such as Color.Red is of
type Color.Value; Color.Value is the type of all enumeration values defined in object Color. It&#8217;s a path-
dependent type, with Color being the path and Value being the dependent type. What&#8217;s significant about
this is that it is a completely new type, different from all other types.
In particular, if you define another enumeration, such as:
object Direction extends Enumeration {
val North, East, South, West = Value
}
then Direction.Value would be different from Color.Value because the path parts of the two types differ.Scala&#8217;s Enumeration class also offers many other features found in the enumeration designs of other
languages. You can associate names with enumeration values by using a different overloaded variant of
the Value method:
object Direction extends Enumeration {
val North = Value("North")
val East = Value("East")
val South = Value("South")
val West = Value("West")
}
You can iterate over the values of an enumeration via the set returned by the
enumeration&#8217;svalues method:
scala&gt; for (d &#8592; Direction.values) print(d + " ")
North East South West
Values of an enumeration are numbered from 0, and you can find out the number of an enumeration
value by its id method:
scala&gt; Direction.East.id
res14: Int = 1
It&#8217;s also possible to go the other way, from a non-negative integer number to the value that has this
number as id in an enumeration:
scala&gt; Direction(1)
res15: Direction.Value = East
This should be enough to get you started with enumerations. You can find more information in the
Scaladoc comments of class scala.Enumeration.
20.10 CASE STUDY: CURRENCIES
The rest of this chapter presents a case study that explains how abstract types can be used in Scala. The
task is to design a class Currency. A typical instance of Currency would represent an amount of money
in dollars, euros, yen, or some other currency. It should be possible to do some arithmetic on
currencies. For instance, you should be able to add two amounts of the same currency. Or you should
be able to multiply a currency amount by a factor representing an interest rate.
These thoughts lead to the following first design for a currency class:

abstract class Currency {
val amount: Long
def designation: String
override def toString = amount + " " + designation
def + (that: Currency): Currency = &#8230;
def * (x: Double): Currency = &#8230;
}The amount of a currency is the number of currency units it represents. This is a field of typeLong so
that very large amounts of money, such as the market capitalization of Google or Apple, can be
represented. It&#8217;s left abstract here, waiting to be defined when a subclass talks about concrete amounts
of money. The designation of a currency is a string that identifies it. The toString method of
class Currency indicates an amount and a designation. It would yield results such as:
79 USD
11000 Yen
99 Euro
Finally, there are methods + for adding currencies and * for multiplying a currency with a floating-
point number. You can create a concrete currency value by supplying
concrete amountand designation values, like this:
new Currency {
val amount = 79L
def designation = "USD"
}
This design would be OK if all we wanted to model was a single currency, like only dollars or only
euros. But it fails if we need to deal with several currencies. Assume that you model dollars and euros
as two subclasses of class currency:
abstract class Dollar extends Currency {
def designation = "USD"
}
abstract class Euro extends Currency {
def designation = "Euro"
}
At first glance this looks reasonable. But it would let you add dollars to euros. The result of such an
addition would be of type Currency. But it would be a funny currency that was made up of a mix of
euros and dollars. What you want instead is a more specialized version of the +method. When
implemented in class Dollar, it should take Dollar arguments and yield a Dollarresult; when
implemented in class Euro, it should take Euro arguments and yield a Euro result. So the type of the
addition method would change depending on which class you are in. Nonetheless, you would like to
write the addition method just once, not each time a new currency is defined.
In Scala, there&#8217;s a simple technique to deal with situations like this. If something is not known at the
point where a class is defined, make it abstract in the class. This applies to both values and types. In the
case of currencies, the exact argument and result type of the addition method are not known, so it is a
good candidate for an abstract type.
This would lead to the following sketch of class AbstractCurrency:

abstract class AbstractCurrency {
type Currency &lt;: AbstractCurrency
val amount: Long
def designation: String}
override def toString = amount + " " + designation
def + (that: Currency): Currency = &#8230;
def * (x: Double): Currency = &#8230;
The only differences from the previous situation are that the class is now calledAbstractCurrency, and
that it contains an abstract type Currency, which represents the real currency in question. Each concrete
subclass of AbstractCurrency would need to fix the Currencytype to refer to the concrete subclass
itself, thereby "tying the knot."
For instance, here is a new version of class Dollar, which now extends class AbstractCurrency:
abstract class Dollar extends AbstractCurrency {
type Currency = Dollar
def designation = "USD"
}
This design is workable, but it is still not perfect. One problem is hidden by the ellipses that indicate
the missing method definitions of + and * in class AbstractCurrency. In particular, how should addition
be implemented in this class? It&#8217;s easy enough to calculate the correct amount of the new currency
as this.amount + that.amount, but how would you convert the amount into a currency of the right type?
You might try something like:
def + (that: Currency): Currency = new Currency {
val amount = this.amount + that.amount
}
However, this would not compile:
error: class type required
def + (that: Currency): Currency = new Currency {
<sup>
One of the restrictions of Scala&#8217;s treatment of abstract types is that you can neither create an instance of
an abstract type nor have an abstract type as a supertype of another class.<span class="footnote"><br />[There&#8217;s some promising recent research on virtual classes, which would allow this, but virtual classes are not currently supported in Scala.]<br /></span> So the compiler would
refuse the example code here that attempted to instantiate Currency.
However, you can work around this restriction using a factory method. Instead of creating an instance
of an abstract type directly, declare an abstract method that does it. Then, wherever the abstract type is
fixed to be some concrete type, you also need to give a concrete implementation of the factory
method. For class AbstractCurrency, this would look as follows:
abstract class AbstractCurrency {
type Currency &lt;: AbstractCurrency // abstract type
def make(amount: Long): Currency // factory method
&#8230;

}
A design like this could be made to work, but it looks rather suspicious. Why place the factory
method inside class AbstractCurrency? This looks dubious for at least two reasons. First, if you havesome amount of currency (say, one dollar), you also hold in your hand the ability to make more of the
same currency, using code such as:
myDollar.make(100)

In the age of color copying this might be a tempting scenario, but hopefully not one which you would
be able to do for very long without being caught. The second problem with this code is that you can
make more Currency objects if you already have a reference to a Currencyobject. But how do you get
the first object of a given Currency? You&#8217;d need another creation method, which does essentially the
same job as make. So you have a case of code duplication, which is a sure sign of a code smell.
The solution, of course, is to move the abstract type and the factory method outside
classAbstractCurrency. You need to create another class that contains the AbstractCurrency class,
theCurrency type, and the make factory method.
We&#8217;ll call this a CurrencyZone:
abstract class CurrencyZone {
type Currency &lt;: AbstractCurrency
def make(x: Long): Currency
abstract class AbstractCurrency {
val amount: Long
def designation: String
override def toString = amount + " " + designation
def + (that: Currency): Currency =
make(this.amount + that.amount)
def * (x: Double): Currency =
make((this.amount * x).toLong)
}
}
An example concrete CurrencyZone is the US, which could be defined as:
object US extends CurrencyZone {
abstract class Dollar extends AbstractCurrency {
def designation = "USD"
}
type Currency = Dollar
def make(x: Long) = new Dollar { val amount = x }
}
Here, US is an object that extends CurrencyZone. It defines a class Dollar, which is a subclass
ofAbstractCurrency. So the type of money in this zone is US.Dollar. The US object also fixes the
typeCurrency to be an alias for Dollar, and it gives an implementation of the make factory method to
return a dollar amount.
This is a workable design. There are only a few refinements to be added. The first refinement concerns
subunits. So far, every currency was measured in a single unit: dollars, euros, or yen. However, most
currencies have subunits: For instance, in the US, it&#8217;s dollars and cents. The most straightforward way
to model cents is to have the amount field in US.Currencyrepresent cents instead of dollars. To convertback to dollars, it&#8217;s useful to introduce a fieldCurrencyUnit into class CurrencyZone, which contains
the amount of one standard unit in that currency:
class CurrencyZone {
&#8230;
val CurrencyUnit: Currency
}
As shown in Listing 20.11, The US object could define the quantities Cent, Dollar, andCurrencyUnit.
This definition is just like the previous definition of the US object, except that it adds three new fields.
The field Cent represents an amount of 1 US.Currency. It&#8217;s an object analogous to a one-cent coin. The
field Dollar represents an amount of 100 US.Currency. So theUS object now defines the name Dollar in
two ways. The type Dollar (defined by the abstract inner class named Dollar) represents the generic
name of the Currency valid in the US currency zone. By contrast, the value Dollar (referenced from
the val field named Dollar) represents a single US dollar, analogous to a one-dollar bill. The third field
definition of CurrencyUnitspecifies that the standard currency unit in the US zone is the Dollar (i.e., the
value Dollar, referenced from the field, not the type Dollar).
The toString method in class Currency also needs to be adapted to take subunits into account. For
instance, the sum of ten dollars and twenty three cents should print as a decimal number: 10.23 USD.
To achieve this, you could implement Currency&#8217;s toString method as follows:
override def toString =
((amount.toDouble / CurrencyUnit.amount.toDouble)
formatted ("%." + decimals(CurrencyUnit.amount) + "f")
+ " " + designation)
Here, formatted is a method that Scala makes available on several classes, including Double.<span class="footnote"><br />[Scala uses rich wrappers, described in Section 5.10, to make formatted available.]<br /></span>The formatted method returns the string that results from formatting the original string on
which formatted was invoked according to a format string passed as the formatted method&#8217;s right-hand
operand. The syntax of format strings passed to formatted is the same as that of
Java&#8217;s String.format method.
object US extends CurrencyZone {
abstract class Dollar extends AbstractCurrency {
def designation = "USD"
}
type Currency = Dollar
def make(cents: Long) = new Dollar {
val amount = cents
}
val Cent = make(1)
val Dollar = make(100)
val CurrencyUnit = Dollar
}
Listing 20.11 - The US currency zone.
For instance, the format string %.2f formats a number with two decimal digits. The format string used
in the toString shown previously is assembled by calling the decimals method onCurrencyUnit.amount.This method returns the number of decimal digits of a decimal power minus one. For
instance, decimals(10) is 1, decimals(100) is 2, and so on. The decimals method is implemented by a
simple recursion:
private def decimals(n: Long): Int =
if (n == 1) 0 else 1 + decimals(n / 10)
Listing 20.12 shows some other currency zones. As another refinement, you can add a currency
conversion feature to the model. First, you could write a Converter object that contains applicable
exchange rates between currencies, as shown in Listing 20.13. Then, you could add a conversion
method, from, to class Currency, which converts from a given source currency into the
current Currency object:
def from(other: CurrencyZone#AbstractCurrency): Currency =
make(math.round(
other.amount.toDouble * Converter.exchangeRate
(other.designation)(this.designation)))
The from method takes an arbitrary currency as argument. This is expressed by its formal parameter
type, CurrencyZone#AbstractCurrency, which indicates that the argument passed asother must be
an AbstractCurrency type in some arbitrary and unknown CurrencyZone. It produces its result by
multiplying the amount of the other currency with the exchange rate between the other and the current
currency.<span class="footnote"><br />[By the way, in case you think you&#8217;re getting a bad deal on Japanese yen, the exchange rates convert currencies based on their CurrencyZone amounts. Thus, 1.211 is the exchange rate between US cents and Japanese yen.]<br /></span>
object Europe extends CurrencyZone {
abstract class Euro extends AbstractCurrency {
def designation = "EUR"
}
type Currency = Euro
def make(cents: Long) = new Euro {
val amount = cents
}
val Cent = make(1)
val Euro = make(100)
val CurrencyUnit = Euro
}
object Japan extends CurrencyZone {
abstract class Yen extends AbstractCurrency {
def designation = "JPY"
}
type Currency = Yen
def make(yen: Long) = new Yen {
val amount = yen
}
val Yen = make(1)
val CurrencyUnit = Yen
}
Listing 20.12 - Currency zones for Europe and Japan.
object Converter {
var exchangeRate = Map(
"USD" &#8594; Map("USD" &#8594; 1.0
, "EUR" &#8594; 0.7596,)
"JPY"
"EUR" &#8594; Map("USD"
"JPY"
"JPY" &#8594; Map("USD"
"JPY"
"CHF" &#8594; Map("USD"
"JPY"
&#8594;
&#8594;
&#8594;
&#8594;
&#8594;
&#8594;
&#8594;
1.211 ,
1.316 ,
1.594 ,
0.8257,
1.0
,
0.8108,
0.982 ,
"CHF"
"EUR"
"CHF"
"EUR"
"CHF"
"EUR"
"CHF"
&#8594;
&#8594;
&#8594;
&#8594;
&#8594;
&#8594;
&#8594;
1.223),
1.0
,
1.623),
0.6272,
1.018),
0.6160,
1.0 )
}
Listing 20.13 - A converter object with an exchange rates map.
abstract class CurrencyZone {
type Currency &lt;: AbstractCurrency
def make(x: Long): Currency
abstract class AbstractCurrency {
val amount: Long
def designation: String
def + (that: Currency): Currency =
make(this.amount + that.amount)
def * (x: Double): Currency =
make((this.amount * x).toLong)
def - (that: Currency): Currency =
make(this.amount - that.amount)
def / (that: Double) =
make((this.amount / that).toLong)
def / (that: Currency) =
this.amount.toDouble / that.amount
def from(other: CurrencyZone#AbstractCurrency): Currency =
make(math.round(
other.amount.toDouble * Converter.exchangeRate
(other.designation)(this.designation)))
private def decimals(n: Long): Int =
if (n == 1) 0 else 1 + decimals(n / 10)
override def toString =
((amount.toDouble / CurrencyUnit.amount.toDouble)
formatted ("%." + decimals(CurrencyUnit.amount) + "f")
+ " " + designation)
}
}
val CurrencyUnit: Currency
Listing 20.14 - The full code of class CurrencyZone.
The final version of the CurrencyZone class is shown in Listing 20.14. You can test the class in the
Scala command shell. We&#8217;ll assume that the CurrencyZone class and all concrete CurrencyZoneobjects
are defined in a package org.stairwaybook.currencies. The first step is to import
"org.stairwaybook.currencies._" into the command shell. Then you can do some currency conversions:
scala&gt; Japan.Yen from US.Dollar * 100res16: Japan.Currency = 12110 JPY
scala&gt; Europe.Euro from res16
res17: Europe.Currency = 75.95 EUR
scala&gt; US.Dollar from res17
res18: US.Currency = 99.95 USD
The fact that we obtain almost the same amount after three conversions implies that these are some
pretty good exchange rates! You can also add up values of the same currency:
scala&gt; US.Dollar * 100 + res18
res19: US.Currency = 199.95 USD
On the other hand, you cannot add amounts of different currencies:
scala&gt; US.Dollar + Europe.Euro
&lt;console&gt;:12: error: type mismatch;
found
: Europe.Euro
required: US.Currency
(which expands to) US.Dollar
US.Dollar + Europe.Euro
</sup>
By preventing the addition of two values with different units (in this case, currencies), the type
abstraction has done its job. It prevents us from performing calculations that are unsound. Failures to
convert correctly between different units may seem like trivial bugs, but they have caused many serious
systems faults. An example is the crash of the Mars Climate Orbiter spacecraft on September 23, 1999,
which was caused because one engineering team used metric units while another used English units. If
units had been coded in the same way as currencies are coded in this chapter, this error would have
been detected by a simple compilation run. Instead, it caused the crash of the orbiter after a near ten-
month voyage.
20.11 CONCLUSION
Scala offers systematic and very general support for object-oriented abstraction. It enables you to not
only abstract over methods, but also over values, variables, and types. This chapter has shown how to
take advantage of abstract members. They support a simple yet effective principle for systems
structuring: when designing a class, make everything that is not yet known into an abstract member.
The type system will then drive the development of your model, just as you saw with the currency case
study. It does not matter whether the unknown is a type, method, variable or value. In Scala, all of these
can be declared abstract.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-08 13:57:57 EET
</div>
</div>
</body>
</html>
