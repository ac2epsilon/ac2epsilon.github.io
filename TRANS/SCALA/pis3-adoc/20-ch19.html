<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__19">Глава 19</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Параметризація типів</h1>
<div class="paragraph"><p>В цій главі ми пояснимо деталі параметризації типів в Scala. По ходу ми продемонструємо деякі з прийомів приховування інформації, з якою ви ознайомились в Главі 13 через використання суцільного прикладу: розробки класу для повністю функціональних черг. Ми презентуємо параметризацію типів та приховування разом, оскільки приховування інформації може використовуватись для більш загальної параметризації типів з анотаціями варіантності.</p></div>
<div class="paragraph"><p>Типова параметризація дозволяє вам писати загальні класи та трейти. Наприклад, множини є загальними та приймають параметр типу: вони визначені як <code>Set[T]</code>. Як результат, любий окремий примірник множини може бути <code>Set[String]</code>, <code>Set[Int]</code>, тощо, але він має бути множиною чогось. На відміну від Java, що дозволяє сирі типи, Scala вимагає, щоб ви вказували параметри типів. Варіантність визначає відношення наслідування для параметризованих типів, наприклад, такі як: чи є <code>Set[String]</code> субтипом <code>Set[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Глава містить три частини. Перша частина розробляє структуру даних для повністю функціональних черг. Друга частина розробляє техніку для приховування деталей внутрішньої репрезентації цієї структури. Заключна частина пояснює варіантність, та як вона взаємодіє з приховуваннями інформації.</p></div>
<div class="sect1">
<h2 id="_19_1__">19.1 Функціональні черги</h2>
<div class="sectionbody">
<div class="paragraph"><p>Функціональна черга є структурою даних з трьома операціями:</p></div>
<div class="paragraph"><p><code>head</code> повертає перший елемент черги</p></div>
<div class="paragraph"><p><code>tail</code> повертає чергу без першого елемента</p></div>
<div class="paragraph"><p><code>enqueue</code> повертає нову чергу з наданим елементом
          доданим в кінець</p></div>
<div class="paragraph"><p>На відміну від змінної черги, функціональна черга не змінює вміст коли додається елемент. Замість цього повертається нова черга, що містить цей елемент. Ціль цієї глави - створити клас, що буде мати ім'я <code>Queue</code>, що робить таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q1</span> <span class="k">=</span> <span class="n">q</span> <span class="n">enqueue</span> <span class="mi">4</span>
<span class="n">q1</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>Queue</code> мав би змінну реалізацію, операція <code>enqueue</code> в другому рядку мала б впливати на вміст <code>q</code>; фактично, після цієї операції обидві черги, результат <code>q1</code> та оригінальна черга <code>q</code>, мали б містити послідовність <code>1, 2, 3, 4</code>. Але для функціональної черги додане значення можна побачити тільки в результаті <code>q1</code>, та не в черзі <code>q</code>, на якій виконується операція.</p></div>
<div class="paragraph"><p>Чисто функціональні черги також мають деяку подібність до списків. Обоє є так званими повністю стійкими структурами даних, коли старі версії залишаються доступні, навіть після розширення або модифікації. Вони підтримують операції <code>head</code> та <code>tail</code>. Але коли список звичайно розширюється зпереду, використовуючи операцію <code>::</code>, черга розширюється з кінця, використовуючи <code>enqueue</code>.</p></div>
<div class="paragraph"><p>Як це може бути реалізовано ефективно? Ідеально, функціональна (незмінна) черга не повинна мати фундаментально вище навантаження, ніж імперативна (змінна). Тобто, всі три операції, <code>head</code>, <code>tail</code>, <code>enqueue</code>, повинні виконуватись за сталий час. Один простий підхід реалізувати функціональну чергу, що буде використовувати список як тип репрезентації.</p></div>
<div class="paragraph"><p>Тоді <code>head</code> та <code>tail</code> будуть просто транслюватись в такі ж операції на списках, тоді як <code>enqueue</code> має бути конкатенацією.</p></div>
<div class="paragraph"><p>Це буде давати таку реалізацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SlowAppendQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// неефективне</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">elems</span><span class="o">.</span><span class="n">head</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowAppendQueue</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowAppendQueue</span><span class="o">(</span><span class="n">elems</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема з цією реалізацією знаходиться в операції <code>enqueue</code>. Вона займає час, пропорційну до числа елементів, що зберігаються в черзі. Якщо ви бажаєте додавати елементи за сталий час, ви також можете спробувати обернути порядок елементів в представленому списку, так щоб останній елемент, що додається, був би першим в списку. Це може привести до наступної реалізації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SlowHeadQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">smele</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// неефективне</span>
<span class="c1">// smele це обернене elems</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">smele</span><span class="o">.</span><span class="n">last</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowHeadQueue</span><span class="o">(</span><span class="n">smele</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowHeadQueue</span><span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">smele</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>enqueue</code> займає сталий час, але <code>head</code> та <code>tail</code> - ні. Тепер вони витрачають час, пропорційний до кількості елементів, що зберігаються в черзі.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дивлячись на ці два приклади, виглядає непростим запропонувати реалізацію, що має сталий час для всіх трьох операцій. Фактично, виглядає сумнівним, щоб це взагалі було можливим! Однак комбінуючи дві операції ви можете підійти дуже близько. Ідея є представити чергу як два списки, названі <code>leading</code> та <code>trailing</code>. Список <code>leading</code> містить елементи, ближчі до початку, тоді як список <code>trailing</code> містить елементи, ближчі до кінця черги в оберненому порядку. Вміст цілої черги в кожну мить є рівним `leading 
</dt>
<dd>
<p>
trailing.reverse`.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Тепер, щоб додати елемент, ви просто робите йому <code>cons</code> до списку <code>trailing</code>, використовуючи оператор <code>::</code>, так що <code>enqueue</code> має сталий час. Це означає, що спочатку, коли порожня черга конструююється з послідовних операцій <code>enqueue</code>, список <code>trailing</code> буде зростати, тоді як список <code>leading</code> буде залишатись порожньою. Потім, перед першою операцією <code>head</code> або <code>tail</code>, що буде виконана для порожнього списку <code>leading</code>, цілий список <code>trailing</code> копіюється до <code>leading</code> з реверсом порядку елементів. Це робиться операцією, що називається <code>mirror</code>. Лістинг 19.1 показує реалізацію черги, що використовує цей підхід.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="k">this</span>

  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.1 - Базова функціональна черга.</p></div>
<div class="paragraph"><p>Яка складність цієї реалізації черги? Операція <code>mirror</code> може займати час, пропорційну до кількості елементів в списку, але тільки якщо список <code>leading</code> порожній. Він повертається безпосередьньо, якщо <code>leading</code> непорожній. Оскільки <code>head</code> та <code>tail</code> викликають <code>mirror</code>, їх складність також може бути лінійною до розміру черги, також. Однак чим більшою стає черга, тим рідше викликається <code>mirror</code>.</p></div>
<div class="paragraph"><p>Дійсно, припустімо є черга довжиною <code>n</code> з порожнім списком <code>leading</code>. Тоді <code>mirror</code> має реверс-копіювати список довжини <code>n</code>. Однак наступного разу <code>mirror</code> буде мати виконати будь яку роботу, коли список <code>leading</code> буде знову порожній, що буде після <code>n</code> операцій <code>tail</code>. Це означає, що ви можете "заряджати" кожну з ціх <code>n</code> операцій <code>tail</code> один раз на <code>n</code> від складності <code>mirror</code>, що означає сталу кількість роботи. Зважаючи, що операції <code>head</code>, <code>tail</code>, та <code>enqueue</code> з'являються з тою самою частотою, амортизована складність, таким чином, є константою для кожної операції. Так що функціональні черги асимптотично такі ж само ефективні, як і змінні.</p></div>
<div class="paragraph"><p>Тепер, ось декілька застережень, що треба додати до ціх аргументів. Перше, дискусія була тільки про асимптотичну поведінку. Друге, аргументація покладалась на факт, що <code>head</code>, <code>tail</code> та <code>enqueue</code> викликаються з майже такою ж частотою. Якщо <code>head</code> викликана значно частіше, ніж інші дві операції, наш аргумент не діє, бо кожний виклик <code>head</code> може включати коштовну реорганізацію списку в <code>mirror</code>. Друге застереження можна оминути; можливо розробити функціональні черги, так щоб для послідовних операцій <code>head</code> тільки перша могла потребувати реорганізації. Ви з'ясуєте в кінці цієї глави, як це робиться.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_2__">19.2 Приховування інформації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Реалізація <code>Queue</code>, показана в Лістингу 19.1 тепер досить гарна, в відношенні ефективності. Однак ви можете заперечити, що ця ефективність сплачена викриттям непотрібних деталей реалізації. Конструктор, що є глобально доступним, приймає два списки як параметри, один з яких реверсований — навряд чи інтуітивна репрезентація черги. Що потрібно, це шлях приховати цей конструктор від клієнтського коду. В цьому розділі ми покажемо деякі шляхи досягти цього в Scala.</p></div>
<div class="sect2">
<h3 id="_____">Приватні конструктори та методи фабрик</h3>
<div class="paragraph"><p>В Java ви можете приховати конструктор, зробивши його приватним. В Scala первинний конструктор не має явного визначення; він визначений явно через параметри та тіло класу. Тим не менше, все ще можливо приховати первинний конструктор, через додавання модифікатора <code>private</code> перед списком параметрів класу, як показано в Лістингу 19.2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.2 - Приховування первинного конструктора через створення його приватним.</p></div>
<div class="paragraph"><p>Модифікатор <code>private</code> між ім'ям класу та його параметрами вказує, що конструктор <code>Queue</code> є приватним: до нього можна отримати доступ тільки з самого класу, та його об'єкта компанйона. Ім'я класу <code>Queue</code> все ще публічне, так що ви можете використовувати його як тип, але ви не можете викликати конструктор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">constructor</span> <span class="kt">Queue</span> <span class="kt">in</span> <span class="kt">class</span> <span class="kt">Queue</span> <span class="kt">cannot</span>
<span class="n">be</span> <span class="n">accessed</span> <span class="n">in</span> <span class="k">object</span> <span class="nc">$iw</span>
              <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли цей приватний конструктор класу <code>Queue</code> не може бути викликаний з клієнтського коду, виникає потреба в деякому іншому способі створювати нові черги. Одна можливість є добавити додатковий конструктор, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Додатковий конструктор, показаний в попередньому прикладі, будує порожню чергу. Як покращення, додатковий конструктор може приймати список початкових елементів черги:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нагадаємо, що <code>T*</code> є нотацією для повторюваних параметрів, як описано в Розділі 8.8.</p></div>
<div class="paragraph"><p>Інша можливість є додати метод фабрики, що будує чергу з такої послідовності початкових елементів. Милий спосіб зробити це є визначення об'єкта <code>Queue</code>, що має те саме ім'я, що і клас, що визначається, та містить метод <code>apply</code>, як показано в Лістингу 19.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>
<span class="c1">// конструює чергу з початковими елементами xs</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.3 - Метод фабрика <code>apply</code> в об'єкті компанйоні.</p></div>
<div class="paragraph"><p>Через покладання цього об'єкту в той самий джерельний файл, що і клас <code>Queue</code>, ви робите об'єкт об'єктом компанйоном цього класу. Ви бачили в Розділі 13.5, що об'єкт компанйон має ті самі права доступу, що і його клас. Завдяки цьому метод <code>apply</code> в об'єкті <code>Queue</code> може створити новий об'єкт <code>Queue</code>, навіть якщо конструктор класу <code>Queue</code> є приватним.</p></div>
<div class="paragraph"><p>Зауважте, що оскільки метод фабрики названий <code>apply</code>, клієнти можуть створювати черги за допомогою виразів, таких як <code>Queue(1, 2, 3)</code>. Цей вираз розширюється до <code>Queue.apply(1, 2, 3)</code>, оскільки <code>Queue</code> є об'єктом, а не функцією. Як результат, <code>Queue</code> виглядає для клієнтів так, якби це був глобально визначений метод фабрики. В реальності Scala не має глобально видимих методів; кожний метод має бути розміщений в об'єкті або класі. Однак використовуючи методи, названі <code>apply</code>, всередині глобальних об'єктів, ви можете підтримати шаблони використання, що виглядають як виклики глобальних методів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
        <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="k">this</span>

    <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.4 - Абстракції типів для функціональних черг.</p></div>
</div>
<div class="sect2">
<h3 id="___">Альтернатива: приватні класи</h3>
<div class="paragraph"><p>Приватні конструктори та приватні члени є одним способом приховати ініціалізацію та репрезентацію класу. Інший, більш радикальний шлях є приховати сам клас, та імпортувати тільки трейт, що розкриває публічний інтерфейс класу. Код в Лістингу 19.4 реаліщзує цей дизайн. Це трейт <code>Queue</code>, який декларує методи <code>head</code>, <code>tail</code>, та <code>enqueue</code>. Всі три методи реалізовані як субклас <code>QueueImpl</code>, що по собі є приватним інутрішнім класом об'єкта <code>Queue</code>. Це виставляє клієнтам ту саму інформацію, що і раніше, але використовуючи іншу технологію. Замість приховування індивідуальних конструкторів та методів, ця версія приховує цілий клас реалізації.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_19_3__">19.3 Анотації варіантності</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>Queue</code>, як визначено в Лістингу 19.4, є трейтом, але не типом. <code>Queue</code> не є типом, бо він приймає параметр типу.</p></div>
<div class="paragraph"><p>Як результат, ви не можете створити змінні типу <code>Queue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">doesNotCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Queue</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
        <span class="k">def</span> <span class="n">doesNotCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього, трейт <code>Queue</code> дозволяє вам вказати параметризовані типи, такі як <code>Queue[String]</code>, <code>Queue[Int]</code>, або <code>Queue[AnyRef]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">doesCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">])</span> <span class="k">=</span> <span class="o">{}</span>
<span class="n">doesCompile</span><span class="k">:</span> <span class="o">(</span><span class="kt">q:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">])</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, <code>Queue</code> є трейтом, та <code>Queue[String]</code> є типом. <code>Queue</code> також називають конструктором типу, оскільки ви можете конструювати тип за допомогою нього, вказавши тип параметра. (Це аналогічно до конструювання примірника об'єкта за допомогою старого доброго конструктора, вказавши значення параметра). Конструктор типа <code>Queue</code> "генерує" сімейство типів, що включає <code>Queue[Int]</code>, <code>Queue[String]</code>, та <code>Queue[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Також ви можете сказати, що <code>Queue</code> є <em>дженерік</em> трейтом. (Класи та трейти, що приймають параметри типів, є "дженеріками", але типи, що вони генерують, є "параметризованими", не дженеріками). Термін "дженерік" означає, що ви визначаєте багато специфічних типів за допомогою одного загально написаного класу або трейту. Наприклад, трейт <code>Queue</code> в Лістингу 19.4 визначає дженерік чергу. <code>Queue[Int]</code> та <code>Queue[String]</code>, тощо, будуть специфічними чергами.</p></div>
<div class="paragraph"><p>Комбінація параметрів типів та субтипізація виставляє деякі цікаві питання. Наприклад, чи існують якісь особливі відношення субтипізації між членами сімейства типів, згенерованих <code>Queue[T]</code>? Біль точно, чи має <code>Queue[String]</code> розглядатись як субтип <code>Queue[AnyRef]</code>? Або більш загально, якщо <code>S</code> є субтипом типу <code>T</code>, тоді чи має <code>Queue[S]</code> розглядатись як субтип <code>Queue[T]</code>? Якщо так, ви можете сказати, що трейт <code>Queue</code> є коваріантним (або "гнучким") по його параметру типу <code>T</code>. Або, оскікльи він має тільки один параметр типу, ви можете просто сказати, що <code>Queue</code> є коваріантними. Коваріантність <code>Queue</code> може означати, наприклад, що ви можете передати <code>Queue[String]</code> до метода <code>doesCompile</code>, показаного перед цім, що приймає значення параметра типу <code>Queue[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Інтуітивно, все це виглядає OK, оскільки черга <code>String</code> виглядає як особливий випадок черги <code>AnyRefs</code>. Однак в Scala дженерік типи мають по замовчанню неваріантне (або "жорстку") субтипізацію. Тобто, з <code>Queue</code>, визначеним в Лістингу 19.4, черги з разними типами елементів ніколи не будуть в відношенні субтипізації. <code>Queue[String]</code> не буде корисним як <code>Queue[AnyRef]</code>. Однак, ви можете вимагати коваріантної (гнучкої) субтипізації черг, через зміну першого рядка цього визначення класу <code>Queue</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Вказуючи префікс <code>+</code> перед формальним параметром типу, вказує, що субтипізація коваріантна (гнучка) в цьому параметрі. Через додавання цього одного символа, ви кажете Scala, що ви бажаєте, щоб <code>Queue[String]</code>, наприклад, розглядався як субтип <code>Queue[AnyRef]</code>. Компілятор буде перевіряти, що <code>Queue</code> визначений в спосіб, що така субтипізація має місце.</p></div>
<div class="paragraph"><p>Крім <code>+</code>, також є і префікс <code>-</code>, що вказує контрваріантну субтипізацію. Якщо б <code>Queue</code> було визначено таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>тоді, якщо <code>T</code> є субтипом типу <code>S</code>, це буде означати, що <code>Queue[S]</code> є субтипом <code>Queue[T]</code> (що в випадку черги буде досить несподівано!). Чи є параметр типу коваріантним, контрваріантним або неваріантним, все це називається варіантністю параметра. Символи <code>+</code> та <code>-</code>, що ви можете покладати коло параметрів типу, називаються анотаціями варіантності.</p></div>
<div class="paragraph"><p>В чисто функціональному світі багато типів є природно коваріантними (гнучкими). Однак ситуація змінюється, коли ми вводимо змінні дані. Щоб зрозуміти чому, розглянемо простий тип одно-елементних клітин, що можуть бути прочитані та записані, показаний в Лістингу 19.5.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cell</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">init</span>
  <span class="k">def</span> <span class="n">get</span> <span class="k">=</span> <span class="n">current</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">current</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.5 - Неваріантний (жорсткий) клас <code>Cell</code>.</p></div>
<div class="paragraph"><p>Тип <code>Cell</code> в Лістингу 19.5 деклароване як неваріантне (жорстке). Для цілей доказу, уявімо на момент, що замість цього <code>Cell</code> був декларований коваріантним, тобто, він був деларований як клас <code>Cell[+T]</code> — і в такому вигляді переданий компілятору Scala. (Він не буде, і ми скоро пояснимо чому). Тоді ви можете сконструювати наступну проблематичну послідовність тверджень:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cell</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">c2</span><span class="k">:</span> <span class="kt">Cell</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">c1</span>
<span class="n">c2</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">get</span>
</pre></div></div></div>
<div class="paragraph"><p>Взяті окремо, кожний з ціх чотирьох рядків виглядають OK. Перший рядок створює клітину рядків, та зберігає її в <code>val</code> на ім'я <code>c1</code>. Другий рядок визначає новий <code>val</code>, <code>c2</code>, типу <code>Cell[Any]</code>, що ініціалізований <code>c1</code>. Це OK, оскільки <code>Cells</code> вважається контрваріантним. Третій рядок встановлює значення клітинки <code>c2</code> в <code>1</code>. Це також OK, оскільки присвоєне значення <code>1</code> є примірником типу елемента <code>c2</code>, <code>Any</code>. Нарешті, останній рядок присвоює значення елементу <code>c1</code> в рядок. Тут також нічого дивного, бо обоє сторін однакового типу. Вле взяті разом, ці чотири рядка закінчуються присвоєнням цілого <code>1</code> до рядка <code>s</code>. Це, очевидно, порушення значення типу.</p></div>
<div class="paragraph"><p>Яка операція винна в рантайм збої? Це, напевне, другий, що використовує коваріантну субтипізацію. Ініш твердження дуже прості та фундаментальні. Таким чином, <code>Cell</code> зі <code>String</code> також є <code>Cell</code> з <code>Any</code>, оскільки є такі речі, які ви можете робити з <code>Cell</code> з <code>Any</code>, які ви не можете робити з <code>Cell</code> з <code>String</code>. Наприклад, ви не можете використовувати <code>set</code> з аргументом <code>Int</code> на <code>Cell</code> зі <code>String</code>.</p></div>
<div class="paragraph"><p>Фактично, коли ви передаєте коваріанту версію <code>Cell</code> до компілятора <code>Scala</code>, ви будете отримувати помилку часу компілятора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Cell</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">7</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">x</span>
    <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">current</span> <span class="k">=</span> <span class="n">x</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="____2">Варіантність та масиви</h3>
<div class="paragraph"><p>Цікаво порівняти цю поведінку з масивами в Java. В принципі масиви такі ж, як клітини, за винятком того, що вони можуть мати більше одного елементу. Тим не менш, масиви розглядаються як коваріантні в Java. Ви можете спробувати приклад, аналогічний до взаємодії з клітиною, описаний тут для Java масивів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// це Java</span>
<span class="n">String</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">&quot;abc&quot;</span> <span class="o">};</span>
<span class="n">Object</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">;</span>
<span class="n">a2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">17</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a1</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви спробуєте цей приклад, ви знайдете, що це буде компілюватись. Але виконання програми буде викликати виключення <code>ArrayStore</code>, що буде закинуте, коли <code>a2[0]</code> присвоюється до <code>Integer</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArrayStoreException</span><span class="k">:</span>
<span class="kt">java.lang.Integer</span>
        <span class="n">at</span> <span class="nc">JavaArrays</span><span class="o">.</span><span class="n">main</span><span class="o">(</span><span class="nc">JavaArrays</span><span class="o">.</span><span class="n">java</span><span class="k">:</span><span class="err">8</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це те, що Java зберігає тип елементу під час виконання. Потім, кожний раз, коли елемент масиву оновлюється, значення нового елементу перевіряється на збережений тип. Якщо це не примірник цього типу, буде закинуте виключення <code>ArrayStore</code>.</p></div>
<div class="paragraph"><p>Ви можете запитати, чому Java прийняла цей дизайн, що виглядає одночасно небезпечним та коштовним. Коли йому задавали це питання, James Gosling, головний винахідник мови Java, відповідав, що вони бажали мати прості засоби для загального трактування масивів. Наприклад, вони бажали бути в змозі записати метод для сортування всіх елементів в масиві, використовуючи сигнатуру, подібну до наступної, що приймає массив з <code>Object</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">sort</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Comparator</span> <span class="n">cmp</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коваріантність масивів була необхідною, так щоб масиви довільного типу посилання могли бути передані до метода <code>sort</code>. Звичайно, з появою Java дженериків такий метод <code>sort</code> тепер може бути написаний з параметром типу, так що коваріантність масивів більше не потрібна. Однак з причин сумісності вона дозволена в Java до цього дня.</p></div>
<div class="paragraph"><p>Scala намагається бути чистішою, ніж Java, не розглядаючи масиви як коваріантні. Ось що ми отримаємо, якщо перенесемо перші два рядкі приклада масива в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">a1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
        <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
                             <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це те, що Scala розглядає масиви як неваріантні (жорсткі), так що <code>Array[String]</code> не розглядається як сумісний з <code>Array[Any]</code>. Однак, іноді є необхідним взаємодіяти зі старими методами в Java, що використовують масив <code>Object</code>, як спосіб емуляції дженерік масивів. Наприклад, ви можете побажати викликати метод <code>sort</code>, як описаний до цього, з масивом <code>String</code> в якості аргумента. Щоб зробити це можливим, Scala дозволяє вам привести масив <code>T</code> до масива любого супертипу T:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">a1</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]]</span>
<span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Кастинг завжди легальний під час компіляції, та він буде завжди успішним під час виконання, тому що модель рантайма JVM трактує масиви як коваріантні, так само, як сама мова Java. Але після цього ви можете отримати виключення <code>ArrayStore</code>, знову так само, як це відбувається в Java.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_19_4___">19.4 Перевірка анотацій варіантності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили деякі приклади, де варіантність не має сенсу, ви можете поцікавитись, які визначення класу треба відсторонити, та які можуть бути прийнятними. Досі всі порушення сенсу типізації включали деяке переприсвоюване поле або елемент масиву. Чисто функціональна реалізація черги, з іншого боку, виглядає як гарний варіант на коваріантність. Однак наступний приклад показує, що ви можете "зінженерити" безглузду ситуацію, навіть якщо немає жодних переприсвоюваних полів.</p></div>
<div class="paragraph"><p>Щоб налаштувати приклад, будемо вважати, що черги, визначені в Лістингу 19.4, коваріантними. Потім створимо субклас черги, що спеціалізує тип елементу як <code>Int</code>, та перекриває метод <code>enqueue</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StrangeIntQueue</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
    <span class="k">super</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>enqueue</code> з <code>StrangeIntQueue</code> роздруковує квадратний корінь свого (цілого) аргументу, перед виконанням власне додавання.</p></div>
<div class="paragraph"><p>Тепер ми можемо написати контрприклад в два рядки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StrangeIntQueue</span>
<span class="n">x</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший з ціх двох рядків валідний, бо <code>StrangeIntQueue</code> є субкласом <code>Queue[Int]</code>, і, зважаючи на коваріантність черг, <code>Queue[Int]</code> є субтипом <code>Queue[Any]</code>. Другий рядок є валідним, оскільки ви можете додати <code>String</code> до <code>Queue[Any]</code>. Однак, взяті разом, ці два рядка мають ефект застосування квадратного кореня до рядка, що не має сенсу.</p></div>
<div class="paragraph"><p>Зрозуміло, що це не тільки змінні поля, що робить коваріантні типи безглуздими. Проблема більш загальна. З'ясовується, що як тільки дженерік параметр типу з'являється як тип параметру метода, клас або трейт, що містить це, не може бути коваріантним по цьому параметру типу.</p></div>
<div class="paragraph"><p>Для черг метод <code>enqueue</code> порушує цю умову:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Виконуючи модифікований клас черги, як вище, через компілятор Scala, буде давати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">11</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">x</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
             <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Переприсвоювані поля є особливим випадком правила, що не дозволяє параметрам типу,анотованим з допомогою <code>+</code>, бути використаними як паратаметри типів в методах. Як зазначалось в Розділі 18.2, переприсвоюване поле, <code>var x: T</code>, трактується в Scala як метод геттер <code>def x: T</code>, та метод сеттер, <code>def x_=(y: T)</code>. Як ви можете бачити, метод сеттера має параметр типа поля <code>T</code>. Так що цей тип не може бути коваріантним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>В залишку цього розділу ми опишемо механізм, завдяки якому компілятор Scala перевіряє анотації варіантності. Якщо вам доки досить деталей, ви можете безпечно перейти до Розділу 19.5. Найбільш важлива річ, що треба зрозуміти, це що компілятор Scala буде перевіряти кожну анотацію варіантності, яку ви покладете до параметрів типу. Наприклад, якщо ви спробуєте декларувати параметр типу як коваріантний (через додавання <code>+</code>), але це призведе до потенційних помилок під час виконання, ваша програма не буде компілюватись.</p></div>
<div class="paragraph"><p>Щоб перевірити коректність анотацій варіантності, компілятор Scala класифікує всі позиції в тілі класу або трейта як позитівні, негативні, або нейтральні. "Позиція" є люба локація в тілі класу або трейта (відтепер будемо казати просто "клас"), де може використовуватись параметр типу. Наприклад, кожний параметр значення метода є позицією, оскільки значення параметру метода має тип. Таким чином, параметр типу може опинитись в цій позиції.</p></div>
<div class="paragraph"><p>Компілятор перевіряє кожне використання кожного з параметрів типу класа. Параметри типів, анотовані за допомогою <code>+</code>, можуть використовуватись в позитивних позиціях, тоді як параметри типів, анотовані за допомогою <code>-</code>, можуть бути використані тільки в негативних позиціях. Параметр типу, що не має анотації варіантності, може бути використаний в любій позиції, і, таким чином, є одним різновидом параметрів типу, що може використовуватись в нейтральних позиціях тіла класу.</p></div>
<div class="paragraph"><p>Щоб класифікувати позиції, компілятор починає з декларації параметру типу, та потім рухається всередину, через глибокі вкладені рівні. Позиції на верхньому рівні декларації класу класифікуються як позитивні. По замовчанню, позиції на глибших вкладених рівнях класифікуються так само, що і на оточуючих рівнях, але є декілька виключень, де класифікація змінюється. Параметри значень методів є позиції, де класифікація обертається відносно кваліфікації за межами метода, де позитивна класифікація стає негативно, негативна позитивною, та обертання нейтральної класифікації буде знову нейтральна.</p></div>
<div class="paragraph"><p>Крім позицій параметрів значень методів, поточна класифікація обертається на параметрах типів методу. Класифікація іноді обертається в позиції аргумента типу для типу, як в <code>Arg</code> в <code>C[Arg]</code>, в залежності від варіантності відповідного параметру типу. Якщо параметр типу типу <code>C</code> анотований з <code>+</code>, тоді класифікація залишається та сама. Якщо параметр типу <code>C</code> анотований з  <code>-</code>, тоді поточна класифікація обертається. Якщо параметр типу <code>C</code> не має анотацій варіантності, тоді поточна класифікація змінюється до нейтральної.</p></div>
<div class="paragraph"><p>Як дещо надуманий приклад, розглянемо наступне визначення класу, де декілька позицій анотовані за допомогою своєї класифікації, <code>^+</code> (для позитивної) або <code>^-</code> (для негативної):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Cat</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">meow</span><span class="o">[</span><span class="kt">W^-</span><span class="o">](</span><span class="n">volume</span><span class="k">:</span> <span class="kt">T^-</span><span class="o">,</span> <span class="n">listener</span><span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]^-)</span>
    <span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]</span><span class="kt">^-</span>, <span class="kt">U^+</span><span class="o">]^+</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Позиції параметру типу, <code>W</code>, та двох параметрів значень, <code>volume</code> та <code>listener</code>, є всі негативними. Дивлячись на результат <code>meow</code>, позиція першого аргумента <code>Cat[U, T]</code> є негативною, бо перший параметр типу <code>Cat</code>, <code>T</code>, анотований за допомогою <code>-</code>. Тип <code>U</code> в цьому аргументі знову в позитивній позиції (два обертання), Тоді як тип <code>T</code> в цьому аргументі все ще в негативній позиції. Ви бачите з цієї дискусії, що відстежувати позиції варіантності досить складно.</p></div>
<div class="paragraph"><p>Ось чому буде приємною новина, що компілятор Scala робить це за вас.</p></div>
<div class="paragraph"><p>Коли класифікація обчислена, компілятор перевіряє кожний параметр типу, що він використовується тільки в позиціях, де він відповідно класифікаваний. В цьому випадку <code>T</code> використовується тільки в негативних позиціях, та <code>U</code> тільки в позитивних позиціях. Так що клас <code>Cat</code> є типово коректним.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_5__">19.5 Нижня межа</h2>
<div class="sectionbody">
<div class="paragraph"><p>Повертаючись до класу <code>Queue</code>. Ви бачили, що попереднє визначення <code>Queue[T]</code>, показане в Лістингу 19.4, не може бути зроблене коваріантним по <code>T</code>, оскільки <code>T</code> з'являється як параметр типу метода <code>enqueue</code>, і це негативна позиція.</p></div>
<div class="paragraph"><p>На щастя, є шлях роблокувати ситуацію: ви можете узагальнити <code>enqueue</code>, зробивши його поліморфним (тобто, надавши самому методу <code>enqueue</code> параметр типу), та використавши нижню межу для його параметру типу. Лістинг 19.6 показує нове формулювання <code>Queue</code>, що реалізує цю ідею.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">(</span><span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span> <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.6 - Параметр типу з нижньою межею.</p></div>
<div class="paragraph"><p>Нове визначення надає <code>enqueue</code> параметр типу <code>U</code>, та за допомогою синтаксиса <code>U &gt;: T</code> визначає <code>T</code> як нижню межу для <code>U</code>. Як результат, від <code>U</code> вимагається бути субтипом  <code>T</code>.<span class="footnote"><br />[Відношення субтипу та супертипу є рефлексивними, що означає, що тип є одночасно супертипом та субтипом себе. Навіть якщо <code>T</code> є нижньою межею для <code>U</code>, ви все ще можете передати в <code>enqueue</code> <code>T</code>.]<br /></span> Параметр <code>enqueue</code> тепер є типу <code>U</code>, замість <code>T</code>, та повернене значення метода тепер <code>Queue[U]</code>, замість <code>Queue[T]</code>.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що є клас <code>Fruit</code> з двома субкласами, <code>Apple</code> та <code>Orange</code>. З новим визначенням класу <code>Queue</code> можливо додати <code>Orange</code> до <code>Queue[Apple]</code>. Результатом буде <code>Queue[Fruit]</code>.</p></div>
<div class="paragraph"><p>Це модифіковане визначення <code>enqueue</code> типово коректне. Інтуітивно, якщо <code>T</code> є більш специфічним типом, ніж очікується (наприклад, <code>Apple</code> замість <code>Fruit</code>), виклик до <code>enqueue</code> все одно буде робити, оскільки <code>U</code> (<code>Fruit</code>) буде все ще супертипом типу <code>T</code> (<code>Apple</code>).<span class="footnote"><br />[Технічно, те що відбувається, це обернення для нижньої межі. Параметр типу <code>U</code> є в негативній позиції (1 обернення), тоді як нижня межа (<code>&gt;: T</code>) в позитивній позиції (2 обернення).]<br /></span></p></div>
<div class="paragraph"><p>Нове визначення <code>enqueue</code> є, можливо, кращим, ніж старе, оскільки воне більш загальне. На відміну від старої версії, нове визначення дозволяє вам додати довільний супертип <code>U</code> типу елемента черги <code>T</code>. Після цього результатом буде <code>Queue[U]</code>. Разом з коваріантністю черги, це дає правильний різновід гнучкості для моделювання черг з різними типами елементів в природний спосіб.</p></div>
<div class="paragraph"><p>Це показує, що анотації варіантності та ніжні межі гарно грають разом. Вони є гарним прикладом типо-рушійної розробки, де типи інтерфейсів направляють її детальний дизайн та реалізацію. В випадку черг, можливо, ви не будете розмірковувати щодо покращеної реалізації <code>enqueue</code> з нижньою межею. Але ви можете вирішити зробити чергу коваріантною, в якому випадку компілятор буде вказувати на помилку варіантностів в <code>enqueue</code>. Корегування помилки варіантності через додавання нижньої межі робить <code>enqueue</code> більш загальним, та черги загалом більш корисними.</p></div>
<div class="paragraph"><p>Це дослідження також є головною причиною того, що Scala обирає варіантність на стороні декларації, замість варіантності на боці використання, як це відбувається в замінниках Java. З варіантністю на боці використання, ви наодинці при розробці свого класу. Це буде клієнт класу, той, що покладатиме підстановку, і якщо він зробить щось не так, деякі важливі методи примірників будуть більше незастосовні. Варіантність залишається хитрою справою, користувачі часто розміють її невірно, та вони ідуть геть, думаючи, що підстановки та дженеріки дуже ускладнені. З варіантністю на боці визначення ви викладаєте ваші наміри компілятору, та компілятор двічи перевірить, що методи, які ви бажаєте, будуть доступними.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_6_">19.6 Контрваріантність</h2>
<div class="sectionbody">
<div class="paragraph"><p>Докі в цій главі всі приклади, що ви бачили, були або коваріантними, або неваріантними. Але також є випадки, коли є природною контрваріантність. Наприклад, розглянемо трейт вихідного каналу, показаний на Лістингу 19.7:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">OutputChannel</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.7 - Контрваріантний вихідний канал.</p></div>
<div class="paragraph"><p>Тут <code>OutputChannel</code> визначений бути контрваріантним по <code>T</code>. Так що, скажімо, вихідний канал <code>AnyRefs</code> є субтипом вихідного каналу <code>Strings</code>. Хоча це може виглядати неінтуітивним, насправді це має сенс. Щоб побачити чому, розглянемо, що ви можете робити з <code>OutputChannel[String]</code>. Одна підтримувана операція є запис <code>String</code> в канал. Та сама операція може також бути виконана на <code>OutputChannel[AnyRef]</code>. Так що безпечно підставити <code>OutputChannel[AnyRef]</code> замість <code>OutputChannel[String]</code>. Для контрасту, може бути небезпечним підставити <code>OutputChannel[String]</code> там, де потрібен <code>OutputChannel[AnyRef]</code>. Кінець кінцем, ви можете надіслати любий об'єкт до <code>OutputChannel[AnyRef]</code>, в той час, коли <code>OutputChannel[String]</code> потребує щоб всі записані елементи були рядками.</p></div>
<div class="paragraph"><p>Ці міркування вказують на загальний принцип в розробці системи типів: безпечно вважати, що тип <code>T</code> є субтипом типу <code>U</code>, якщо ви можете підставити значення <code>T</code> там, де вимагається значення типу <code>U</code>. Це називається принципом підстановки Ліскова. Принцип стверджує, що тоді <code>T</code> підтримує ті самі операції, що і <code>U</code>, та всі операції <code>T</code> потребують меньше, та провадять більше, ніж відповідні операції <code>U</code>. В цьому випадку з вихідними каналами, <code>OutputChannel[AnyRef]</code> може бути субтипом <code>OutputChannel[String]</code>, оскільки обоє підтримують ту саму операцію <code>write</code>, та ця операція потребує меньше в <code>OutputChannel[AnyRef]</code>, ніж в <code>OutputChannel[String]</code>. "Меньше" означає, що від аргумента вимагається тільки бути <code>AnyRef</code> в першому випадку, тоді як він має бути  <code>String</code> в другому випадку.</p></div>
<div class="paragraph"><p>Іноді коваріантність та контрваріантність змішані в одному типі. Яскравий приклад є функціональні трейти Scala. Наприклад, коли ви пишете функціональний тип <code>A =&gt; B</code>, Scala розширює це до <code>Function1[A, B]</code>. Визначення <code>Function1</code> в стандартній бібліотеці використовує одночасно коваріантність та контрваріантність: трейт <code>Function1</code> є контрваріантним по функціональному типу аргумента <code>S</code>, та коваріантним по типу результату <code>T</code>, як показано в Лістингу 19.8. Це задовільняє принципу підстановки Ліскова, оскільки аргументи є іноді тим, що вимагається, тоді як результат іноді те, що було запроваджено.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-S</span>, <span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.8 - Коваріантність та контрваріантність <code>Function1s</code>.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо застосування, показане в Лістингу 19.9. Тут клас <code>Publication</code> містить одно параметричне поле, <code>title</code>, типу <code>String</code>. Клас <code>Book</code> розширює <code>Publication</code>, та пересилає його параметр <code>title</code> в конструктор свого суперкласу. Об'єкт синглтон <code>Library</code> визначає набір книжок, та метод <code>printBookList</code>, що приймає функцію на ім'я <code>info</code>, типу <code>typeBook =&gt; AnyRef</code>. Іншими словами, тип єдиного параметра <code>printBookList</code> є функцією, що приймає один аргумент <code>Book</code>, та повертає <code>AnyRef</code>. Застосування <code>Customer</code> визначає метод <code>getTitle</code>, що приймає <code>Publication</code> як свій єдиний параметр, та повертає <code>String</code>, заголовок переданого <code>Publication</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Publication</span><span class="o">(</span><span class="k">val</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Publication</span><span class="o">(</span><span class="n">title</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">&quot;Programming in Scala&quot;</span><span class="o">),</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">&quot;Walden&quot;</span><span class="o">)</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="n">printBookList</span><span class="o">(</span><span class="n">info</span><span class="k">:</span> <span class="kt">Book</span> <span class="o">=&gt;</span> <span class="nc">AnyRef</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">book</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">info</span><span class="o">(</span><span class="n">book</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Customer</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">getTitle</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Publication</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">title</span>
  <span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.9 - Демонстрація варіантності параметру типу функції.</p></div>
<div class="paragraph"><p>Тепер поглянемо на останній рядок <code>Customer</code>. Цей рядок викликає метод <code>Library</code>  <code>printBookList</code>, та передає <code>getTitle</code>, оточений в функціональне значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей рядок коду проходить перевірку типів, навіть якщо <code>String</code>, тип результату функції, є субтипом <code>AnyRef</code>, типу результата параметра <code>info</code> метода <code>printBookList</code>. Цей код проходить компілятор, оскільки типи результата функції декларований як коваріантний (<code>+T</code> в Лістингу 19.8). Якщо ви подивитесь в тіло <code>printBookList</code>, ви можете отримати проблиск, чому це має сенс.</p></div>
<div class="paragraph"><p>Метод <code>printBookList</code> ітерує по своєму списку книжок, та викликає передану функцію для кожної книжки. Він передає результат <code>AnyRef</code>, що повертає <code>info</code>, до <code>println</code>, що викликає на ньому <code>toString</code>, та друкує результат. Ця активність буде робити зі <code>String</code> так само, як і інші субкласи <code>AnyRef</code>, що саме і означає коваріантність результату функції.</p></div>
<div class="paragraph"><p>Тепер розглянемо тип параметру функції, коли він передається до метода <code>printBookList</code>. Хоча тип параметра <code>printBookList</code> декларований як <code>Book</code>, <code>getTitle</code>, яку ми передаємо туди, приймає <code>Publication</code>, супертип <code>Book</code>. Причина, чому це робить, полягає в тому, що оскільки тип параметра <code>printBookList</code> є <code>Book</code>, в тілі метода <code>printBookList</code> буде дозволено передати <code>Book</code> в функцію. І оскількі тип параметра <code>getTitle</code> є <code>Publication</code>, тіло цієї функції буде в змозі отримати доступ тільки до свого параметра, <code>p</code>, члени якого декларовані в класі <code>Publication</code>. Оскільки любий метод, декларований в <code>Publication</code> також доступний в субкласі <code>Book</code>, все повинно робити, що є саме те, що означає контрваріантність функціонального параметру. Ви можете бачити все це графічно на Малюнку 19.1.</p></div>
<div class="paragraph"><p>Код в Лістингу 19.9 компілюється, оскільки <code>Publication =&gt; String</code> є субтипом <code>Book =&gt; AnyRef</code>, як показано в центрі Малюнка 19.1. Оскільки тип результата <code>Function1</code> є визначеним як коваріантний, відношення наслідування двох типів результату, показані справа діаграми, є в тому самому напрямку, що той у двох функцій, показаних в центрі. По контрасту, оскільки тип параметра <code>Function1</code> визначений як контрваріантний, відношення наслідування двох типів параметрів, показаних зліва від діаграми, ідуть в зворотньому напрямку, ніж ті для двох функцій.</p></div>
<div class="paragraph"><p>Малюнок 19.1 - Коваріантність і контрваріантність в параметрах типів функції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span><span class="o">()</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">trailing</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">leading</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">leading</span>
        <span class="n">trailing</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">tail</span>
      <span class="o">}</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="n">leading</span><span class="o">.</span><span class="n">head</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.10 - Оптимізована функціональна черга.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_7____">19.7 Приватні дані об'єкта</h2>
<div class="sectionbody">
<div class="paragraph"><p>Клас <code>Queue</code>, яку ми бачили до цього, має проблему в тому, що операція <code>mirror</code> буде постійно копіювати список <code>trailing</code> в <code>leading</code>, якщо <code>head</code> буде викликатись декілька разів поспіль для списку, коли <code>leading</code> є порожнім. Марного копіювання можна уникнути, додаючи деякі розсудливі побічні ефекти. Лістинг 19.10 презентує нову реалізацію <code>Queue</code>, що виконує щонайбільше одне коригування <code>trailing</code> до <code>leading</code> для кожної послідовності операцій <code>head</code>.</p></div>
<div class="paragraph"><p>Що тут відмінне з точки зору попередньої версії, є те, що тепер <code>leading</code> та <code>trailing</code> є переприсвоювані змінні, і <code>mirror</code> виконує реверсивну копію від <code>trailing</code> до <code>leading</code> як побічний ефект на поточній черзі, замість повернення нової черги. Цей побічний ефект чисто внутрішній відносно до реалізації операцій <code>Queue</code>; оскільки <code>leading</code> та <code>trailing</code> є приватними змінними, ефект не є видимий для клієнтів <code>Queue</code>. Так що за термінологією, встановленою в Главі 18, нова версія <code>Queue</code> все ще визначає чисто функціональні об'єкти, не зважаючи на факт, що вони тепер містять переприсвоювані поля.</p></div>
<div class="paragraph"><p>Ви можете поцікавитись, чи цей код пройде перевірку типів Scala. Кінець кінцем, тепер черги містять два переприсвоювані поля коваріантного параметру типу <code>T</code>. Чи це не порушення правил варіантності? Це було б так, за винятком тої деталі, що <code>leading</code> та <code>trailing</code> мають модифікатор <code>private[this]</code>, і, таким чином декларовані як приватні до об'єкта.</p></div>
<div class="paragraph"><p>Як зазначалось в Розділі 13.5, приватні до об'єкта члени можуть отримувати доступ тільки з того самого об'єкта, де вони визначені. З'ясовується, що доступ до змінних з того самого об'єкта, в якому вони визначені, не викликають проблем з варіантністю. Інтуітивне пояснення в тому, що щоб сконструювати випадок, коли варіантність призведе до помилки типів, вам треба мати посилання на містячий об'єкт, що має статично слабший тип, ніж тип об'єкта, з яким об'єкт був визначений. Але для доступу до об'єкт приватних значень це неможливо.</p></div>
<div class="paragraph"><p>Перевірка варіантності в Scala містить особливий випадок для об'єкт приватних визначень. Такі визначення оминаються при перевірці, що параметр типу з анотаціями <code>+</code> або <code>-</code> з'являється лише в позиціях, що мають ту саму класифікацію варіантності. Таким чином, код в Лістингу 19.10 компілюється без помилок. З іншого боку, якщо ви приберете кваліфікатор <code>[this]</code> для двох  модифікаторів <code>private</code>, ви побачите дві помилки типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">of</span> <span class="n">parameter</span> <span class="n">of</span>
<span class="n">setter</span> <span class="n">leading_=</span>
<span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span><span class="k">private</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
                                     <span class="o">^</span>
<span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">of</span> <span class="n">parameter</span> <span class="n">of</span>
<span class="n">setter</span> <span class="n">trailing_=</span>
                        <span class="k">private</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
                                    <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_8__">19.8 Верхня межа</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Лістингу 16.1 ми показали функцію сортування злиттям для списків, що приймає функцію порівняння як перший аргумент, і список для сортування в якості другого, каровані аргументи. Інший шлях, як ви можете організувати таку функцію сортування, це змусити тип списку зміксувати трейт <code>Ordered</code>. Як зазначалось в Розділі 12.4, через міксування <code>Ordered</code> в клас, та реалізуючи єдиний абстрактний метод <code>Ordered</code>, <code>compare</code>, ви дозволяєте клієнтам порівнювати примірники цього класу за допомогою <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, та <code>&gt;=</code>. Наприклад, Лістинг 19.11 показує <code>Ordered</code>, що зміксовано в клас <code>Person</code>.</p></div>
<div class="paragraph"><p>Як результат ви можете порівнювати двох людей, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">robert</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Robert&quot;</span><span class="o">,</span> <span class="s">&quot;Jones&quot;</span><span class="o">)</span>
<span class="n">robert</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="nc">Robert</span> <span class="nc">Jones</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sally</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Sally&quot;</span><span class="o">,</span> <span class="s">&quot;Smith&quot;</span><span class="o">)</span>
<span class="n">sally</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="nc">Sally</span> <span class="nc">Smith</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">robert</span> <span class="o">&lt;</span> <span class="n">sally</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">firstName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">lastNameComparison</span> <span class="k">=</span>
      <span class="n">lastName</span><span class="o">.</span><span class="n">compareToIgnoreCase</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">lastName</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lastNameComparison</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">lastNameComparison</span>
    <span class="k">else</span>
      <span class="n">firstName</span><span class="o">.</span><span class="n">compareToIgnoreCase</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">firstName</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">firstName</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">lastName</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.11 - Клас <code>Person</code>, міксує трейт <code>Ordered</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">orderedMergeSort</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">ys</span><span class="o">),</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">zs</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.12 - Функція сортування злиттям з верхньою межею.</p></div>
<div class="paragraph"><p>Щоб змусити тип списку, що передається в нову функцію сортування, міксувати <code>Ordered</code>, вам треба встановити верхню межу. Верхня межа вказується подібно до нижньої межі, за винятком того, що замість символа <code>&gt;:</code>, що використовується для нижньої межі, ви використовуєте символ <code>&lt;:</code>, як показано в Лістингу 19.12.</p></div>
<div class="paragraph"><p>З синтаксисом <code>T &lt;: Ordered[T]</code> ви вказуєте, що параметр типу, <code>T</code>, має верхню межу,<code>Ordered[T]</code>. Це означає, що тип елемента списка, переданого до <code>orderedMergeSort</code>, має бути субтипом від <code>Ordered</code>. Таким чином, ви можете передати <code>List[Person]</code> до <code>orderedMergeSort</code>, оскільки <code>Person</code> зміксований з <code>Ordered</code>.</p></div>
<div class="paragraph"><p>Наприклад, розглянемо цей список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Larry&quot;</span><span class="o">,</span> <span class="s">&quot;Wall&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Anders&quot;</span><span class="o">,</span> <span class="s">&quot;Hejlsberg&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Guido&quot;</span><span class="o">,</span> <span class="s">&quot;van Rossum&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Alan&quot;</span><span class="o">,</span> <span class="s">&quot;Kay&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Yukihiro&quot;</span><span class="o">,</span> <span class="s">&quot;Matsumoto&quot;</span><span class="o">)</span>
       <span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Larry</span> <span class="nc">Wall</span><span class="o">,</span> <span class="nc">Anders</span> <span class="nc">Hejlsberg</span><span class="o">,</span>
  <span class="nc">Guido</span> <span class="n">van</span> <span class="nc">Rossum</span><span class="o">,</span> <span class="nc">Alan</span> <span class="nc">Kay</span><span class="o">,</span> <span class="nc">Yukihiro</span> <span class="nc">Matsumoto</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки тип елемента цього списка, <code>Person</code>, міксується (і таким чином є його субтипом) <code>Ordered[People]</code>, ви можете передати список до <code>orderedMergeSort</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sortedPeople</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">people</span><span class="o">)</span>
<span class="n">sortedPeople</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Anders</span> <span class="nc">Hejlsberg</span><span class="o">,</span> <span class="nc">Alan</span> <span class="nc">Kay</span><span class="o">,</span>
  <span class="nc">Yukihiro</span> <span class="nc">Matsumoto</span><span class="o">,</span> <span class="nc">Guido</span> <span class="n">van</span> <span class="nc">Rossum</span><span class="o">,</span> <span class="nc">Larry</span> <span class="nc">Wall</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, хоча функція сортування, показана в Лістингу 19.12, служить як корисна ілюстрація верхньої межі, насправді це не найбільш загальний шлях в Scala для розробки функції сортування, що набуває вигод від трейту <code>Ordered</code>.</p></div>
<div class="paragraph"><p>Наприклад, ви не можете використовувати функцію <code>orderedMergeSort</code> для сортування списку цілих, оскільки клас <code>Int</code> не є субтипом <code>Ordered[Int]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wontCompile</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">inferred</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">do</span>
   <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="n">method</span> <span class="n">orderedMergeSort</span><span class=" -Symbol">&#39;s</span> <span class="k">type</span>
      <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
        <span class="k">val</span> <span class="n">wontCompile</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
                          <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>В Розділі 21.6 ми побачимо, як використовувати неявні параметри та обмеження контекстів, щоб досягти більш загального рішення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_9_">19.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили декілька прийомів для приховування інформації: приватні конструктори, методи фабрик, абстракції типів та об'єкт приватні члени. Ви також навчились, як задавати варіантність типів, та що це накладає на реалізацію класів. Нарешті, ви бачили два прийоми, що допоможуть в отриманні гнучких анотацій варіантності: нижні межі для параметрів типу методів, та анотації <code>private[this]</code> для локальних полів та методів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-07 07:15:36 EET
</div>
</div>
</body>
</html>
