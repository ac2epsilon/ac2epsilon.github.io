<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__19">Глава 19</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Параметризація типів</h1>
<div class="paragraph"><p>В цій главі ми пояснимо деталі параметризації типів в Scala. По ходу ми продемонструємо деякі з прийомів приховування інформації, з якою ви ознайомились в Главі 13 через використання суцільного прикладу: розробки класу для повністю функціональних черг. Ми презентуємо параметризацію типів та приховування разом, оскільки приховування інформації може використовуватись для більш загальної параметризації типів з анотаціями варіантності.</p></div>
<div class="paragraph"><p>Типова параметризація дозволяє вам писати загальні класи та трейти. Наприклад, множини є загальними та приймають параметр типу: вони визначені як <code>Set[T]</code>. Як результат, любий окремий примірник множини може бути <code>Set[String]</code>, <code>Set[Int]</code>, тощо, але він має бути множиною чогось. На відміну від Java, що дозволяє сирі типи, Scala вимагає, щоб ви вказували параметри типів. Варіантність визначає відношення наслідування для параметризованих типів, наприклад, такі як: чи є <code>Set[String]</code> субтипом <code>Set[AnyRef]</code>.</p></div>
<div class="paragraph"><p>Глава містить три частини. Перша частина розробляє структуру даних для повністю функціональних черг. Друга частина розробляє техніку для приховування деталей внутрішньої репрезентації цієї структури. Заключна частина пояснює варіантність, та як вона взаємодіє з приховуваннями інформації.</p></div>
<div class="sect1">
<h2 id="_19_1__">19.1 Функціональні черги</h2>
<div class="sectionbody">
<div class="paragraph"><p>Функціональна черга є структурою даних з трьома операціями:</p></div>
<div class="paragraph"><p><code>head</code> повертає перший елемент черги</p></div>
<div class="paragraph"><p><code>tail</code> повертає чергу без першого елемента</p></div>
<div class="paragraph"><p><code>enqueue</code> повертає нову чергу з наданим елементом
          доданим в кінець</p></div>
<div class="paragraph"><p>На відміну від змінної черги, функціональна черга не змінює вміст коли додається елемент. Замість цього повертається нова черга, що містить цей елемент. Ціль цієї глави - створити клас, що буде мати ім'я <code>Queue</code>, що робить таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q1</span> <span class="k">=</span> <span class="n">q</span> <span class="n">enqueue</span> <span class="mi">4</span>
<span class="n">q1</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Queue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>Queue</code> мав би змінну реалізацію, операція <code>enqueue</code> в другому рядку мала б впливати на вміст <code>q</code>; фактично, після цієї операції обидві черги, результат <code>q1</code> та оригінальна черга <code>q</code>, мали б містити послідовність <code>1, 2, 3, 4</code>. Але для функціональної черги додане значення можна побачити тільки в результаті <code>q1</code>, та не в черзі <code>q</code>, на якій виконується операція.</p></div>
<div class="paragraph"><p>Чисто функціональні черги також мають деяку подібність до списків. Обоє є так званими повністю стійкими структурами даних, коли старі версії залишаються доступні, навіть після розширення або модифікації. Вони підтримують операції <code>head</code> та <code>tail</code>. Але коли список звичайно розширюється зпереду, використовуючи операцію <code>::</code>, черга розширюється з кінця, використовуючи <code>enqueue</code>.</p></div>
<div class="paragraph"><p>Як це може бути реалізовано ефективно? Ідеально, функціональна (незмінна) черга не повинна мати фундаментально вище навантаження, ніж імперативна (змінна). Тобто, всі три операції, <code>head</code>, <code>tail</code>, <code>enqueue</code>, повинні виконуватись за сталий час. Один простий підхід реалізувати функціональну чергу, що буде використовувати список як тип репрезентації.</p></div>
<div class="paragraph"><p>Тоді <code>head</code> та <code>tail</code> будуть просто транслюватись в такі ж операції на списках, тоді як <code>enqueue</code> має бути конкатенацією.</p></div>
<div class="paragraph"><p>Це буде давати таку реалізацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SlowAppendQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elems</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// неефективне</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">elems</span><span class="o">.</span><span class="n">head</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowAppendQueue</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowAppendQueue</span><span class="o">(</span><span class="n">elems</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема з цією реалізацією знаходиться в операції <code>enqueue</code>. Вона займає час, пропорційну до числа елементів, що зберігаються в черзі. Якщо ви бажаєте додавати елементи за сталий час, ви також можете спробувати обернути порядок елементів в представленому списку, так щоб останній елемент, що додається, був би першим в списку. Це може привести до наступної реалізації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SlowHeadQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">smele</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span> <span class="c1">// неефективне</span>
<span class="c1">// smele це обернене elems</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">smele</span><span class="o">.</span><span class="n">last</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowHeadQueue</span><span class="o">(</span><span class="n">smele</span><span class="o">.</span><span class="n">init</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SlowHeadQueue</span><span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">smele</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер <code>enqueue</code> займає сталий час, але <code>head</code> та <code>tail</code> - ні. Тепер вони витрачають час, пропорційний до кількості елементів, що зберігаються в черзі.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дивлячись на ці два приклади, виглядає непростим запропонувати реалізацію, що має сталий час для всіх трьох операцій. Фактично, виглядає сумнівним, щоб це взагалі було можливим! Однак комбінуючи дві операції ви можете підійти дуже близько. Ідея є представити чергу як два списки, названі <code>leading</code> та <code>trailing</code>. Список <code>leading</code> містить елементи, ближчі до початку, тоді як список <code>trailing</code> містить елементи, ближчі до кінця черги в оберненому порядку. Вміст цілої черги в кожну мить є рівним `leading 
</dt>
<dd>
<p>
trailing.reverse`.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Тепер, щоб додати елемент, ви просто робите йому <code>cons</code> до списку <code>trailing</code>, використовуючи оператор <code>::</code>, так що <code>enqueue</code> має сталий час. Це означає, що спочатку, коли порожня черга конструююється з послідовних операцій <code>enqueue</code>, список <code>trailing</code> буде зростати, тоді як список <code>leading</code> буде залишатись порожньою. Потім, перед першою операцією <code>head</code> або <code>tail</code>, що буде виконана для порожнього списку <code>leading</code>, цілий список <code>trailing</code> копіюється до <code>leading</code> з реверсом порядку елементів. Це робиться операцією, що називається <code>mirror</code>. Лістинг 19.1 показує реалізацію черги, що використовує цей підхід.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
      <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="k">this</span>

  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.1 - Базова функціональна черга.</p></div>
<div class="paragraph"><p>Яка складність цієї реалізації черги? Операція <code>mirror</code> може займати час, пропорційну до кількості елементів в списку, але тільки якщо список <code>leading</code> порожній. Він повертається безпосередьньо, якщо <code>leading</code> непорожній. Оскільки <code>head</code> та <code>tail</code> викликають <code>mirror</code>, їх складність також може бути лінійною до розміру черги, також. Однак чим більшою стає черга, тим рідше викликається <code>mirror</code>.</p></div>
<div class="paragraph"><p>Дійсно, припустімо є черга довжиною <code>n</code> з порожнім списком <code>leading</code>. Тоді <code>mirror</code> має реверс-копіювати список довжини <code>n</code>. Однак наступного разу <code>mirror</code> буде мати виконати будь яку роботу, коли список <code>leading</code> буде знову порожній, що буде після <code>n</code> операцій <code>tail</code>. Це означає, що ви можете "заряджати" кожну з ціх <code>n</code> операцій <code>tail</code> один раз на <code>n</code> від складності <code>mirror</code>, що означає сталу кількість роботи. Зважаючи, що операції <code>head</code>, <code>tail</code>, та <code>enqueue</code> з'являються з тою самою частотою, амортизована складність, таким чином, є константою для кожної операції. Так що функціональні черги асимптотично такі ж само ефективні, як і змінні.</p></div>
<div class="paragraph"><p>Тепер, ось декілька застережень, що треба додати до ціх аргументів. Перше, дискусія була тільки про асимптотичну поведінку. Друге, аргументація покладалась на факт, що <code>head</code>, <code>tail</code> та <code>enqueue</code> викликаються з майже такою ж частотою. Якщо <code>head</code> викликана значно частіше, ніж інші дві операції, наш аргумент не діє, бо кожний виклик <code>head</code> може включати коштовну реорганізацію списку в <code>mirror</code>. Друге застереження можна оминути; можливо розробити функціональні черги, так щоб для послідовних операцій <code>head</code> тільки перша могла потребувати реорганізації. Ви з'ясуєте в кінці цієї глави, як це робиться.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_2__">19.2 Приховування інформації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Реалізація <code>Queue</code>, показана в Лістингу 19.1 тепер досить гарна, в відношенні ефективності. Однак ви можете заперечити, що ця ефективність сплачена викриттям непотрібних деталей реалізації. Конструктор, що є глобально доступним, приймає два списки як параметри, один з яких реверсований — навряд чи інтуітивна репрезентація черги. Що потрібно, це шлях приховати цей конструктор від клієнтського коду. В цьому розділі ми покажемо деякі шляхи досягти цього в Scala.</p></div>
<div class="sect2">
<h3 id="_____">Приватні конструктори та методи фабрик</h3>
<div class="paragraph"><p>В Java ви можете приховати конструктор, зробивши його приватним. В Scala первинний конструктор не має явного визначення; він визначений явно через параметри та тіло класу. Тим не менше, все ще можливо приховати первинний конструктор, через додавання модифікатора <code>private</code> перед списком параметрів класу, як показано в Лістингу 19.2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.2 - Приховування первинного конструктора через створення його приватним.</p></div>
<div class="paragraph"><p>The private modifier between the class name and its parameters indicates that the constructor of Queue is private: it can be accessed only from within the class itself and its companion object. The class name Queue is still public, so you can use it as a type, but you cannot call its constructor:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">constructor</span> <span class="kt">Queue</span> <span class="kt">in</span> <span class="kt">class</span> <span class="kt">Queue</span> <span class="kt">cannot</span>
<span class="n">be</span> <span class="n">accessed</span> <span class="n">in</span> <span class="k">object</span> <span class="nc">$iw</span>
              <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>
              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Now that the primary constructor of class Queue can no longer be called from client code, there needs to be some other way to create new queues. One possibility is to add an auxiliary constructor, like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the auxiliary constructor could take a list of initial queue elements:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Recall that T* is the notation for repeated parameters, as described in Section 8.8.</p></div>
<div class="paragraph"><p>Another possibility is to add a factory method that builds a queue from such a sequence of initial elements. A neat way to do this is to define an object Queue that has the same name as the class being defined and contains an apply method, as shown in Лістинг 19.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>
<span class="c1">// constructs a queue with initial elements `xs&#39;</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.3 - Метод фабрика <code>apply</code> в об'єкті компанйоні.</p></div>
<div class="paragraph"><p>By placing this object in the same source file as class Queue, you make the object a companion object of the class. You saw in Section 13.5 that a companion object has the same access rights as its class. Because of this, the apply method in object Queue can create a new Queue object, even though the constructor of class Queue is private.</p></div>
<div class="paragraph"><p>Note that, because the factory method is called apply, clients can create queues with an expression such as Queue(1, 2, 3). This expression expands to Queue.apply(1, 2, 3) since Queue is an object instead of a function. As a result, Queue looks to clients as if it was a globally defined factory method. In reality, Scala has no globally visible methods; every method must be contained in an object or a class. However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

    <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
        <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="k">this</span>

    <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.4 - Абстракції типів для функціональних черг.</p></div>
</div>
<div class="sect2">
<h3 id="___">Альтернатива: приватні класи</h3>
<div class="paragraph"><p>Private constructors and private members are one way to hide the initialization and representation of a class. Another more radical way is to hide the class itself and only export a trait that reveals the public interface of the class. The code in Лістинг 19.4 implements this design. There&#8217;s a trait Queue, whichdeclares the methods head, tail, and enqueue. All three methods are implemented in a subclass QueueImpl, which is itself a private inner class of objectQueue. This exposes to clients the same information as before, but using a different technique. Instead of hiding individual constructors and methods, this version hides the whole implementation class.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_19_3__">19.3 Анотації варіантності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Queue, as defined in Лістинг 19.4, is a trait, but not a type. Queue is not a type because it takes a type parameter.</p></div>
<div class="paragraph"><p>As a result, you cannot create variables of type Queue:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">doesNotCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Queue</span> <span class="kt">takes</span> <span class="k">type</span> <span class="kt">parameters</span>
        <span class="k">def</span> <span class="n">doesNotCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">)</span> <span class="k">=</span> <span class="o">{}</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Instead, trait Queue enables you to specify parameterized types, such as Queue[String],Queue[Int], or Queue[AnyRef]:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">doesCompile</span><span class="o">(</span><span class="n">q</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">])</span> <span class="k">=</span> <span class="o">{}</span>
<span class="n">doesCompile</span><span class="k">:</span> <span class="o">(</span><span class="kt">q:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">AnyRef</span><span class="o">])</span><span class="nc">Unit</span>
</pre></div></div></div>
<div class="paragraph"><p>Thus, Queue is a trait and Queue[String] is a type. Queue is also called a type constructor because you can construct a type with it by specifying a type parameter. (This is analogous to constructing an object instance with a plain-old constructor by specifying a value parameter.) The type constructor Queue "generates" a family of types, which includes Queue[Int],Queue[String], and Queue[AnyRef].</p></div>
<div class="paragraph"><p>You can also say that Queue is a <em>generic</em> trait. (Classes and traits that take type parameters are "generic," but the types they generate are "parameterized," not generic.) The term "generic" means that you are defining many specific types with one generically written class or trait. For example, trait Queue in Лістинг 19.4 defines a generic queue. Queue[Int] and Queue[String],etc., would be the specific queues.</p></div>
<div class="paragraph"><p>The combination of type parameters and subtyping poses some interesting questions. For example, are there any special subtyping relationships between members of the family of types generated by Queue[T]? More specifically, should a Queue[String] be considered a subtype of Queue[AnyRef]? Or more generally, if S is a subtype of type T, then should Queue[S] be considered a subtype of Queue[T]? If so, you could say that trait Queue is covariant (or "flexible") in its type parameter T. Or, since it just has one type parameter, you could say simply that Queues are covariant. Covariant Queues would mean, for example, that you could pass a Queue[String] to the doesCompile method shown previously, which takes a value parameter of type Queue[AnyRef].</p></div>
<div class="paragraph"><p>Intuitively, all this seems OK, since a queue of Strings looks like a special case of a queue ofAnyRefs. In Scala, however, generic types have by default nonvariant (or "rigid") subtyping. That is, with Queue defined as in Лістинг 19.4, queues with different element types would never be in a subtyperelationship. A Queue[String] would not be usable as a Queue[AnyRef]. However, you can demand covariant (flexible) subtyping of queues by changing the first line of the definition of class Queue like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Prefixing a formal type parameter with a + indicates that subtyping is covariant (flexible) in that parameter. By adding this single character, you are telling Scala that you wantQueue[String], for example, to be considered a subtype of Queue[AnyRef]. The compiler will check that Queue is defined in a way that this subtyping is sound.</p></div>
<div class="paragraph"><p>Besides +, there is also a prefix -, which indicates contravariant subtyping. If Queue were defined like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>then if T is a subtype of type S, this would imply that Queue[S] is a subtype of Queue[T] (which in the case of queues would be rather surprising!). Whether a type parameter is covariant, contravariant, or nonvariant is called the parameter&#8217;s variance. The + and - symbols you can place next to type parameters are called variance annotations.</p></div>
<div class="paragraph"><p>In a purely functional world, many types are naturally covariant (flexible). However, the situation changes once you introduce mutable data. To find out why, consider the simple type of one-element cells that can be read or written, shown in Лістинг 19.5.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Cell</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">init</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">init</span>
  <span class="k">def</span> <span class="n">get</span> <span class="k">=</span> <span class="n">current</span>
  <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">current</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.5 - A nonvariant (rigid) Cell class.</p></div>
<div class="paragraph"><p>The Cell type of Лістинг 19.5 is declared nonvariant (rigid). For the sake of argument, assume for a moment that Cell was declared covariant instead—i.e., it was declared class Cell[+T]—and that this passed the Scala compiler. (It doesn&#8217;t, and we&#8217;ll explain why shortly.) Then you could construct the following problematic statement sequence:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">c1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cell</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">c2</span><span class="k">:</span> <span class="kt">Cell</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">c1</span>
<span class="n">c2</span><span class="o">.</span><span class="n">set</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">get</span>
</pre></div></div></div>
<div class="paragraph"><p>Seen by itself, each of these four lines looks OK. The first line creates a cell of strings and stores it in a val named c1. The second line defines a new val, c2, of type Cell[Any], which initialized with c1. This is OK since Cells are assumed to be covariant. The third line sets the value of cell c2 to 1. This is also OK because the assigned value 1 is an instance of c2&#8217;s element type Any. Finally, the last line assigns the element value of c1 into a string. Nothing strange here, as both the sides are of the sametype. But taken together, these four lines end up assigning the integer 1 to the string s. This is clearly a violation of type soundness.</p></div>
<div class="paragraph"><p>Which operation is to blame for the runtime fault? It must be the second one, which uses covariant subtyping. The other statements are too simple and fundamental. Thus, a Cell ofString is not also a Cell of Any, because there are things you can do with a Cell of Any that you cannot do with a Cell of String. You cannot use set with an Int argument on a Cell of String, for example.</p></div>
<div class="paragraph"><p>In fact, were you to pass the covariant version of Cell to the Scala compiler, you would get a compile- time error:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Cell</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">7</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">x</span>
    <span class="k">def</span> <span class="n">set</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">current</span> <span class="k">=</span> <span class="n">x</span>
               <span class="o">^</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="____2">Варіантність та масиви</h3>
<div class="paragraph"><p>It&#8217;s interesting to compare this behavior with arrays in Java. In principle, arrays are just like cells except that they can have more than one element. Nevertheless, arrays are treated as covariant in Java. You can try an example analogous to the cell interaction described here with Java arrays:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// ще Java</span>
<span class="n">String</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">&quot;abc&quot;</span> <span class="o">};</span>
<span class="n">Object</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">;</span>
<span class="n">a2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">17</span><span class="o">);</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a1</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</pre></div></div></div>
<div class="paragraph"><p>If you try out this example, you will find that it compiles. But executing the program will cause an ArrayStore exception to be thrown when a2[0] is assigned to an Integer:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Exception</span> <span class="n">in</span> <span class="n">thread</span> <span class="s">&quot;main&quot;</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">ArrayStoreException</span><span class="k">:</span>
<span class="kt">java.lang.Integer</span>
        <span class="n">at</span> <span class="nc">JavaArrays</span><span class="o">.</span><span class="n">main</span><span class="o">(</span><span class="nc">JavaArrays</span><span class="o">.</span><span class="n">java</span><span class="k">:</span><span class="err">8</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>What happens here is that Java stores the element type of the array at runtime. Then, every time an array element is updated, the new element value is checked against the stored type. If it is not an instance of that type, an ArrayStore exception is thrown.</p></div>
<div class="paragraph"><p>You might ask why Java adopted this design, which seems both unsafe and expensive. When asked this question, James Gosling, the principal inventor of the Java language, answered that they wanted to have a simple means to treat arrays generically. For instance, they wanted to be able to write a method to sort all elements of an array, using a signature like the following that takes an array of Object:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">sort</span><span class="o">(</span><span class="nc">Object</span><span class="o">[]</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Comparator</span> <span class="n">cmp</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Covariance of arrays was needed so that arrays of arbitrary reference types could be passed to this sort method. Of course, with the arrival of Java generics, such a sort method can now be writtenwith a type parameter, so the covariance of arrays is no longer necessary. For compatibility reasons, though, it has persisted in Java to this day.</p></div>
<div class="paragraph"><p>Scala tries to be purer than Java in not treating arrays as covariant. Here&#8217;s what you get if you translate the first two lines of the array example to Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">a1</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
        <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>
                             <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>What happened here is that Scala treats arrays as nonvariant (rigid), so an Array[String] is not considered to conform to an Array[Any]. However, sometimes it is necessary to interact with legacy methods in Java that use an Object array as a means to emulate a generic array. For instance, you might want to call a sort method like the one described previously with an array of Strings as argument. To make this possible, Scala lets you cast an array of Ts to an array of any supertype of T:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span>
          <span class="n">a1</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]]</span>
<span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The cast is always legal at compile-time, and it will always succeed at run-time because the JVM&#8217;s underlying run-time model treats arrays as covariant, just as Java the language does. But you might get ArrayStore exceptions afterwards, again just as you would in Java.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_19_4___">19.4 Перевірка анотацій варіантності</h2>
<div class="sectionbody">
<div class="paragraph"><p>Now that you have seen some examples where variance is unsound, you may be wondering which kind of class definitions need to be rejected and which can be accepted. So far, all violations of type soundness involved some reassignable field or array element. The purely functional implementation of queues, on the other hand, looks like a good candidate for covariance. However, the following example shows that you can "engineer" an unsound situation even if there is no reassignable field.</p></div>
<div class="paragraph"><p>To set up the example, assume that queues as defined in Лістинг 19.4 are covariant. Then, create a subclass of queues that specializes the element type to Int and overrides the enqueuemethod:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">StrangeIntQueue</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
    <span class="k">super</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>The enqueue method in StrangeIntQueue prints out the square root of its (integer) argument before doing the append proper.</p></div>
<div class="paragraph"><p>Now, you can write a counterexample in two lines:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StrangeIntQueue</span>
<span class="n">x</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The first of these two lines is valid because StrangeIntQueue is a subclass of Queue[Int] and, assuming covariance of queues, Queue[Int] is a subtype of Queue[Any]. The second line is valid because you can append a String to a Queue[Any]. However, taken together, these two lines have the effect of applying a square root method to a string, which makes no sense.</p></div>
<div class="paragraph"><p>Clearly it&#8217;s not just mutable fields that make covariant types unsound. The problem is more general. It turns out that as soon as a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter.</p></div>
<div class="paragraph"><p>For queues, the enqueue method violates this condition:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Running a modified queue class like the one above through a Scala compiler would yield:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">11</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">of</span> <span class="kt">value</span> <span class="kt">x</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
             <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Reassignable fields are a special case of the rule that disallows type parameters annotated with + from being used as method parameter types. As mentioned in Section 18.2, a reassignable field, "var x: T", is treated in Scala as a getter method, "def x: T", and a setter method, "def x_=(y: T)". As you can see, the setter method has a parameter of the field&#8217;s type T. So that type may not be covariant.</p></div>
</div>
</div>
<h1 id="___2">Швидкий шлях</h1>
<div class="paragraph"><p>In the rest of this section, we&#8217;ll describe the mechanism by which the Scala compiler checks variance annotations. If you&#8217;re not interested in such detail right now, you can safely skip toSection 19.5. The most important thing to understand is that the Scala compiler will check any variance annotations you place on type parameters. For example, if you try to declare a type parameter to be covariant (by adding a +), but that could lead to potential runtime errors, your program won&#8217;t compile.</p></div>
<div class="paragraph"><p>To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or trait body as positive, negative or neutral. A "position" is any location in the class or trait (but from now on we&#8217;ll just write "class") body where a type parameter may be used. For example, every method value parameter is a position because a method value parameter has a type. Therefore a type parameter could appear in that position.</p></div>
<div class="paragraph"><p>The compiler checks each use of each of the class&#8217;s type parameters. Type parameters annotated with + may only be used in positive positions, while type parameters annotated with - may only be usedin negative positions. A type parameter with no variance annotation may be used in any position, and is, therefore, the only kind of type parameter that can be used in neutral positions of the class body.</p></div>
<div class="paragraph"><p>To classify the positions, the compiler starts from the declaration of a type parameter and then moves inward through deeper nesting levels. Positions at the top level of the declaring class are classified as positive. By default, positions at deeper nesting levels are classified the same as that at enclosing levels, but there are a handful of exceptions where the classification changes. Method value parameter positions are classified to the flipped classification relative to positions outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and the flip of a neutral classification is still neutral.</p></div>
<div class="paragraph"><p>Besides method value parameter positions, the current classification is also flipped at the type parameters of methods. A classification is sometimes flipped at the type argument position of a type, such as the Arg in C[Arg], depending on the variance of the corresponding type parameter. If C&#8217;s type parameter is annotated with a + then the classification stays the same. If C&#8217;s type parameter is annotated with a -, then the current classification is flipped. IfC&#8217;s type parameter has no variance annotation then the current classification is changed to neutral.</p></div>
<div class="paragraph"><p>As a somewhat contrived example, consider the following class definition, where several positions are annotated with their classifications, <sup>+ (for positive) or </sup>- (for negative):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Cat</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">meow</span><span class="o">[</span><span class="kt">W^-</span><span class="o">](</span><span class="n">volume</span><span class="k">:</span> <span class="kt">T^-</span><span class="o">,</span> <span class="n">listener</span><span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]^-)</span>
    <span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">Cat</span><span class="o">[</span><span class="kt">U^+</span>, <span class="kt">T^-</span><span class="o">]</span><span class="kt">^-</span>, <span class="kt">U^+</span><span class="o">]^+</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>The positions of the type parameter, W, and the two value parameters, volume and listener, are all negative. Looking at the result type of meow, the position of the first Cat[U, T] argument is negative because Cat&#8217;s first type parameter, T, is annotated with a -. The type U inside this argument is again in positive position (two flips), whereas the type T inside that argument is still in negative position. You see from this discussion that it&#8217;s quite hard to keep track of variance positions.</p></div>
<div class="paragraph"><p>That&#8217;s why it&#8217;s a welcome relief that the Scala compiler does this job for you.</p></div>
<div class="paragraph"><p>Once the classifications are computed, the compiler checks that each type parameter is only used in positions that are classified appropriately. In this case, T is only used in negative positions, and U is only used in positive positions. So class Cat is type correct.</p></div>
<h1 id="_19_5__">19.5 Нижня межа</h1>
<div class="paragraph"><p>Back to the Queue class. You saw that the previous definition of Queue[T] shown in Лістинг 19.4cannot be made covariant in T because T appears as a type of a parameter of the enqueuemethod, and that&#8217;s a negative position.</p></div>
<div class="paragraph"><p>Fortunately, there&#8217;s a way to get unstuck: you can generalize enqueue by making it polymorphic (i.e., giving the enqueue method itself a type parameter) and using a lower bound for its type parameter. Лістинг 19.6 shows a new formulation of Queue that implements this idea.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">(</span><span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span> <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.6 - Параметр типу з нижньою межею.</p></div>
<div class="paragraph"><p>The new definition gives enqueue a type parameter U, and with the syntax, "U &gt;: T", defines T as the lower bound for U. As a result, U is required to be a supertype of T.<span class="footnote"><br />[Supertype and subtype relationships are reflexive, which means a type is both a supertype and a subtype of itself. Even though T is a lower bound for U, you could still pass in a T toenqueue.]<br /></span> The parameter toenqueue is now of type U instead of type T, and the return value of the method is now Queue[U]instead of Queue[T].</p></div>
<div class="paragraph"><p>For example, suppose there is a class Fruit with two subclasses, Apple and Orange. With the new definition of class Queue, it is possible to append an Orange to a Queue[Apple]. The result will be aQueue[Fruit].</p></div>
<div class="paragraph"><p>This revised definition of enqueue is type correct. Intuitively, if T is a more specific type than expected (for example, Apple instead of Fruit), a call to enqueue will still work because U (Fruit) will still be a supertype of T (Apple).<span class="footnote"><br />[Technically, what happens is a flip occurs for lower bounds. The type parameter U is in a negative position (1 flip), while the lower bound (&gt;: T) is in a positive position (2 flips).]<br /></span></p></div>
<div class="paragraph"><p>The new definition of enqueue is arguably better than the old, because it is more general. Unlike the old version, the new definition allows you to append an arbitrary supertype U of the queue element type T. The result is then a Queue[U]. Together with queue covariance, this gives the right kind of flexibility for modeling queues of different element types in a natural way.</p></div>
<div class="paragraph"><p>This shows that variance annotations and lower bounds play well together. They are a good example of type-driven design, where the types of an interface guide its detailed design and implementation. In the case of queues, it&#8217;s likely you would not have thought of the refined implementation of enqueue with a lower bound. But you might have decided to make queues covariant, in which case, the compiler would have pointed out the variance error for enqueue. Correcting the variance error by adding a lower bound makes enqueue more general and queues as a whole more usable.</p></div>
<div class="paragraph"><p>This observation is also the main reason that Scala prefers declaration-site variance over use-site variance as it is found in Java&#8217;s wildcards. With use-site variance, you are on your own designing a class. It will be the clients of the class that need to put in the wildcards, and if they get it wrong, some important instance methods will no longer be applicable. Variance being a tricky business, users usually get it wrong, and they come away thinking that wildcards and generics are overly complicated. With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available.</p></div>
<div class="sect1">
<h2 id="_19_6_">19.6 Контрваріантність</h2>
<div class="sectionbody">
<div class="paragraph"><p>So far in this chapter, all examples you&#8217;ve seen were either covariant or nonvariant. But there are also cases where contravariance is natural. For instance, consider the trait of output channels shown in Лістинг 19.7:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">OutputChannel</span><span class="o">[</span><span class="kt">-T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">write</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.7 - Контрваріантний вихідний канал.</p></div>
<div class="paragraph"><p>Here, OutputChannel is defined to be contravariant in T. So an output channel of AnyRefs, say, is a subtype of an output channel of Strings. Although it may seem non-intuitive, it actually makes sense. To see why, consider what you can do with an OutputChannel[String]. The only supported operation is writing a String to it. The same operation can also be done on anOutputChannel[AnyRef]. So it is safe to substitute an OutputChannel[AnyRef] for anOutputChannel[String]. By contrast, it would not be safe to substitute an OutputChannel[String]where an OutputChannel[AnyRef] is required. After all, you can send any object to anOutputChannel[AnyRef], whereas an OutputChannel[String] requires that the written values are all strings.</p></div>
<div class="paragraph"><p>This reasoning points to a general principle in type system design: It is safe to assume that a type T is a subtype of a type U if you can substitute a value of type T wherever a value of type Uis required. This is called the Liskov Substitution Principle. The principle holds if T supports the same operations as U, and all of T&#8217;s operations require less and provide more than the corresponding operations in U. In the case of output channels, an OutputChannel[AnyRef] can be a subtype of an OutputChannel[String] because the two support the same write operation, and this operation requires less in OutputChannel[AnyRef] than in OutputChannel[String]. "Less" means the argument is only required to be an AnyRef in the first case, whereas it is required to be a Stringin the second case.</p></div>
<div class="paragraph"><p>Sometimes covariance and contravariance are mixed in the same type. A prominent example is Scala&#8217;s function traits. For instance, whenever you write the function type A &#8658; B, Scala expands this to Function1[A, B]. The definition of Function1 in the standard library uses both covariance and contravariance: the Function1 trait is contravariant in the function argument type S and covariant in the result type T, as shown in Лістинг 19.8. This satisfies the Liskov Substitution Principle because arguments are something that&#8217;s required, whereas results are something that&#8217;s provided.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Function1</span><span class="o">[</span><span class="kt">-S</span>, <span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.8 - Коваріантність та контрваріантність <code>Function1s</code>.</p></div>
<div class="paragraph"><p>As an example, consider the application shown in Лістинг 19.9. Here, class Publicationcontains one parametric field, title, of type String. Class Book extends Publication and forwards its string title parameter to the constructor of its superclass. The Library singleton object defines a set of books and a method printBookList, which takes a function, named info, of typeBook &#8658; AnyRef. In other words, the type of the lone parameter to printBookList is a function that takes one Book argument and returns an AnyRef. The Customer application defines a method,getTitle, which takes a Publication as its lone parameter and returns a String, the title of the passed Publication.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Publication</span><span class="o">(</span><span class="k">val</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Publication</span><span class="o">(</span><span class="n">title</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">&quot;Programming in Scala&quot;</span><span class="o">),</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">&quot;Walden&quot;</span><span class="o">)</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="n">printBookList</span><span class="o">(</span><span class="n">info</span><span class="k">:</span> <span class="kt">Book</span> <span class="o">=&gt;</span> <span class="nc">AnyRef</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">book</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">info</span><span class="o">(</span><span class="n">book</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Customer</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">getTitle</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Publication</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">title</span>
  <span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.9 - Демонстрація варіантності параметру типу функції.</p></div>
<div class="paragraph"><p>Now take a look at the last line in Customer. This line invokes Library&#8217;s printBookList method and passes getTitle, wrapped in a function value:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>This line of code type checks even though String, the function&#8217;s result type, is a subtype ofAnyRef, the result type of printBookList&#8217;s info parameter. This code passes the compiler because function result types are declared to be covariant (the +T in Лістинг 19.8). If you look inside the body of printBookList, you can get a glimpse of why this makes sense.</p></div>
<div class="paragraph"><p>The printBookList method iterates through its book list and invokes the passed function on each book. It passes the AnyRef result returned by info to println, which invokes toString on it and prints the result. This activity will work with String as well as any other subclass of AnyRef, which is what covariance of function result types means.</p></div>
<div class="paragraph"><p>Now consider the parameter type of the function being passed to the printBookList method. Although printBookList&#8217;s parameter type is declared as Book, the getTitle we&#8217;re passing in takes a Publication, a supertype of Book. The reason this works is that since printBookList&#8217;s parameter type is Book, the body of the printBookList method will only be allowed to pass a Book into the function. And because getTitle&#8217;s parameter type is Publication, the body of that function will only be able to access on its parameter, p, members that are declared in class Publication. Because any method declared in Publication is also available on its subclass Book, everything should work, which is what contravariance of function parameter types means. You can see all this graphically in Figure 19.1.</p></div>
<div class="paragraph"><p>The code in Лістинг 19.9 compiles because Publication &#8658; String is a subtype of Book &#8658; AnyRef, as shown in the center of the Figure 19.1. Because the result type of a Function1 is defined as covariant, the inheritance relationship of the two result types, shown at the right of the diagram, is in the same direction as that of the two functions shown in the center. By contrast, because the parameter type of a Function1 is defined as contravariant, the inheritance relationship of the two parameter types, shown at the left of the diagram, is in the opposite direction as that of the two functions.</p></div>
<div class="paragraph"><p>Figure 19.1 - Covariance and contravariance in function type parameters.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span><span class="o">()</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">trailing</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">leading</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">leading</span>
        <span class="n">trailing</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">tail</span>
      <span class="o">}</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="n">leading</span><span class="o">.</span><span class="n">head</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.10 - Оптимізована An optimized functional queue.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_7____">19.7 Приватні дані об'єкта</h2>
<div class="sectionbody">
<div class="paragraph"><p>The Queue class seen so far has a problem in that the mirror operation will repeatedly copy thetrailing into the leading list if head is called several times in a row on a list where leading is empty. The wasteful copying could be avoided by adding some judicious side effects. Лістинг 19.10 presents a new implementation of Queue, which performs at most one trailing to leadingadjustment for any sequence of head operations.</p></div>
<div class="paragraph"><p>What&#8217;s different with respect to the previous version is that now leading and trailing are reassignable variables, and mirror performs the reverse copy from trailing to leading as a side effect on the current queue instead of returning a new queue. This side effect is purely internal to the implementation of the Queue operation; since leading and trailing are private variables, the effect is not visible to clients of Queue. So by the terminology established inChapter 18, the new version of Queue still defines purely functional objects, in spite of the fact that they now contain reassignable fields.</p></div>
<div class="paragraph"><p>You might wonder whether this code passes the Scala type checker. After all, queues now contain two reassignable fields of the covariant parameter type T. Is this not a violation of the variance rules? It would be indeed, except for the detail that leading and trailing have aprivate[this] modifier, and are thus declared to be object private.</p></div>
<div class="paragraph"><p>As mentioned in Section 13.5, object private members can be accessed only from within the object in which they are defined. It turns out that accesses to variables from the same object in which they are defined do not cause problems with variance. The intuitive explanation is that, in order to construct a case where variance would lead to type errors, you need to have a reference to a containing object that has a statically weaker type than the type the object was defined with. For accesses to object private values, however, this is impossible.</p></div>
<div class="paragraph"><p>Scala&#8217;s variance checking rules contain a special case for object private definitions. Such definitions are omitted when it is checked that a type parameter with either a + or -annotation occurs only in positions that have the same variance classification. Therefore, the code in Лістинг 19.10 compiles without error. On the other hand, if you had left out the [this]qualifiers from the two private modifiers, you would see two type errors:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">of</span> <span class="n">parameter</span> <span class="n">of</span>
<span class="n">setter</span> <span class="n">leading_=</span>
<span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span><span class="k">private</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
                                     <span class="o">^</span>
<span class="nc">Queues</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">covariant</span> <span class="k">type</span> <span class="kt">T</span> <span class="kt">occurs</span> <span class="kt">in</span>
<span class="n">contravariant</span> <span class="n">position</span> <span class="n">in</span> <span class="k">type</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="n">of</span> <span class="n">parameter</span> <span class="n">of</span>
<span class="n">setter</span> <span class="n">trailing_=</span>
                        <span class="k">private</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
                                    <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_8__">19.8 Верхня межа</h2>
<div class="sectionbody">
<div class="paragraph"><p>In Listing 16.1 here, we showed a merge sort function for lists that took a comparison function as a first argument and a list to sort as a second, curried argument. Another way you might want to organize such a sort function is by requiring the type of the list to mix in theOrdered trait. As mentioned in Section 12.4, by mixing Ordered into a class and implementingOrdered&#8217;s one abstract method, compare, you enable clients to compare instances of that class with &lt;, &gt;, &#8656;, and &gt;=. For example, Listing 19.11 shows Ordered being mixed into a Person class.</p></div>
<div class="paragraph"><p>As a result, you can compare two people like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">robert</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Robert&quot;</span><span class="o">,</span> <span class="s">&quot;Jones&quot;</span><span class="o">)</span>
<span class="n">robert</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="nc">Robert</span> <span class="nc">Jones</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sally</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Sally&quot;</span><span class="o">,</span> <span class="s">&quot;Smith&quot;</span><span class="o">)</span>
<span class="n">sally</span><span class="k">:</span> <span class="kt">Person</span> <span class="o">=</span> <span class="nc">Sally</span> <span class="nc">Smith</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">robert</span> <span class="o">&lt;</span> <span class="n">sally</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="k">val</span> <span class="n">firstName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="k">val</span> <span class="n">lastName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">lastNameComparison</span> <span class="k">=</span>
      <span class="n">lastName</span><span class="o">.</span><span class="n">compareToIgnoreCase</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">lastName</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">lastNameComparison</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">lastNameComparison</span>
    <span class="k">else</span>
      <span class="n">firstName</span><span class="o">.</span><span class="n">compareToIgnoreCase</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">firstName</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">firstName</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">lastName</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.11 - Клас <code>Person</code>, міксує трейт <code>Ordered</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">orderedMergeSort</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">ys</span><span class="o">),</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">zs</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 19.12 - Функція сортування злиттям з верхньою межею.</p></div>
<div class="paragraph"><p>To require that the type of the list passed to your new sort function mixes in Ordered, you need to use an upper bound. An upper bound is specified similar to a lower bound, except instead of the &gt;: symbol used for lower bounds, you use a &lt;: symbol, as shown in Лістинг 19.12.</p></div>
<div class="paragraph"><p>With the "T &lt;: Ordered[T]" syntax, you indicate that the type parameter, T, has an upper bound,Ordered[T]. This means that the element type of the list passed to orderedMergeSort must be a subtype of Ordered. Thus, you could pass a List[Person] to orderedMergeSort because Person mixes in Ordered.</p></div>
<div class="paragraph"><p>For example, consider this list:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">people</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Larry&quot;</span><span class="o">,</span> <span class="s">&quot;Wall&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Anders&quot;</span><span class="o">,</span> <span class="s">&quot;Hejlsberg&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Guido&quot;</span><span class="o">,</span> <span class="s">&quot;van Rossum&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Alan&quot;</span><span class="o">,</span> <span class="s">&quot;Kay&quot;</span><span class="o">),</span>
          <span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;Yukihiro&quot;</span><span class="o">,</span> <span class="s">&quot;Matsumoto&quot;</span><span class="o">)</span>
       <span class="o">)</span>
<span class="n">people</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Larry</span> <span class="nc">Wall</span><span class="o">,</span> <span class="nc">Anders</span> <span class="nc">Hejlsberg</span><span class="o">,</span>
  <span class="nc">Guido</span> <span class="n">van</span> <span class="nc">Rossum</span><span class="o">,</span> <span class="nc">Alan</span> <span class="nc">Kay</span><span class="o">,</span> <span class="nc">Yukihiro</span> <span class="nc">Matsumoto</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Because the element type of this list, Person, mixes in (and is therefore a subtype of)Ordered[People], you can pass the list to orderedMergeSort:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sortedPeople</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">people</span><span class="o">)</span>
<span class="n">sortedPeople</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Anders</span> <span class="nc">Hejlsberg</span><span class="o">,</span> <span class="nc">Alan</span> <span class="nc">Kay</span><span class="o">,</span>
  <span class="nc">Yukihiro</span> <span class="nc">Matsumoto</span><span class="o">,</span> <span class="nc">Guido</span> <span class="n">van</span> <span class="nc">Rossum</span><span class="o">,</span> <span class="nc">Larry</span> <span class="nc">Wall</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Now, although the sort function shown in Лістинг 19.12 serves as a useful illustration of upper bounds, it isn&#8217;t actually the most general way in Scala to design a sort function that takes advantage of the Ordered trait.</p></div>
<div class="paragraph"><p>For example, you couldn&#8217;t use the orderedMergeSort function to sort a list of integers, because class Int is not a subtype of Ordered[Int]:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wontCompile</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">inferred</span> <span class="k">type</span> <span class="kt">arguments</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">do</span>
   <span class="n">not</span> <span class="n">conform</span> <span class="n">to</span> <span class="n">method</span> <span class="n">orderedMergeSort</span><span class=" -Symbol">&#39;s</span> <span class="k">type</span>
      <span class="kt">parameter</span> <span class="kt">bounds</span> <span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span>
        <span class="k">val</span> <span class="n">wontCompile</span> <span class="k">=</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
                          <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>In Section 21.6, we&#8217;ll show you how to use implicit parameters and context bounds to achieve a more general solution.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_19_9_">19.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>In this chapter you saw several techniques for information hiding: private constructors, factory methods, type abstraction, and object private members. You also learned how to specify data type variance and what it implies for class implementation. Finally, you saw two techniques which help in obtaining flexible variance annotations: lower bounds for method type parameters and private[this] annotations for local fields and methods.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-04 22:06:31 EET
</div>
</div>
</body>
</html>

