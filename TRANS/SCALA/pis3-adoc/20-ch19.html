<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__19">Глава 19</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Типова параметризація</h1>
<div class="paragraph"><p>In this chapter, we&#8217;ll explain the details of type parameterization in Scala. Along the way we&#8217;ll
demonstrate some of the techniques for information hiding introduced in Chapter 13 by using a
concrete example: the design of a class for purely functional queues. We&#8217;re presenting type
parameterization and information hiding together, because information hiding can be used to obtain
more general type parameterization variance annotations.
Type parameterization allows you to write generic classes and traits. For example, sets are generic and
take a type parameter: they are defined as Set[T]. As a result, any particular set instance might be
a Set[String], a Set[Int], etc., but it must be a set of something. Unlike Java, which allows raw
types, Scala requires that you specify type parameters. Variance defines inheritance relationships of
parameterized types, such as whether a Set[String], for example, is a subtype of Set[AnyRef].
The chapter contains three parts. The first part develops a data structure for purely functional queues.
The second part develops techniques to hide internal representation details of this structure. The final
part explains variance of type parameters and how it interacts with information hiding.
19.1 FUNCTIONAL QUEUES
A functional queue is a data structure with three operations:
head
returns the first element of the queue
tail
returns a queue without its first element
enqueue returns a new queue with a given element
appended at the end
Unlike a mutable queue, a functional queue does not change its contents when an element is appended.
Instead, a new queue is returned that contains the element. The goal of this chapter will be to create a
class, which we&#8217;ll name Queue, that works like this:
scala&gt; val q = Queue(1, 2, 3)
q: Queue[Int] = Queue(1, 2, 3)
scala&gt; val q1 = q enqueue 4
q1: Queue[Int] = Queue(1, 2, 3, 4)
scala&gt; q
res0: Queue[Int] = Queue(1, 2, 3)
If Queue were a mutable implementation, the enqueue operation in the second input line above would
affect the contents of q; in fact both the result, q1, and the original queue, q, would contain the
sequence 1, 2, 3, 4 after the operation. But for a functional queue, the appended value shows up only in
the result, q1, not in the queue, q, being operated on.Purely functional queues also have some similarity with lists. Both are so called fully persistent data
structures, where old versions remain available even after extensions or modifications. Both
support head and tail operations. But where a list is usually extended at the front, using a :: operation, a
queue is extended at the end, using enqueue.
How can this be implemented efficiently? Ideally, a functional (immutable) queue should not have a
fundamentally higher overhead than an imperative (mutable) one. That is, all three
operations, head, tail, and enqueue, should operate in constant time.
One simple approach to implement a functional queue would be to use a list as representation type.
Then head and tail would just translate into the same operations on the list, whereas enqueue would be
concatenation.
This would give the following implementation:
class
def
def
def
}
SlowAppendQueue[T](elems: List[T]) { // Not efficient
head = elems.head
tail = new SlowAppendQueue(elems.tail)
enqueue(x: T) = new SlowAppendQueue(elems ::: List(x))
The problem with this implementation is in the enqueue operation. It takes time proportional to the
number of elements stored in the queue. If you want constant time append, you could also try to reverse
the order of the elements in the representation list, so that the last element that&#8217;s appended comes first
in the list. This would lead to the following implementation:
class SlowHeadQueue[T](smele: List[T]) { // Not efficient

def head = smele.last
def tail = new SlowHeadQueue(smele.init)
def enqueue(x: T) = new SlowHeadQueue(x :: smele)
}
Now enqueue is constant time, but head and tail are not. They now take time proportional to the
number of elements stored in the queue.
Looking at these two examples, it does not seem easy to come up with an implementation that&#8217;s
constant time for all three operations. In fact, it looks doubtful that this is even possible! However, by
combining the two operations you can get very close. The idea is to represent a queue by two lists,
called leading and trailing. The leading list contains elements towards the front, whereas the trailing list
contains elements towards the back of the queue in reversed order. The contents of the whole queue are
at each instant equal to "leading ::: trailing.reverse".
Now, to append an element, you just cons it to the trailing list using the :: operator, so enqueueis
constant time. This means that, when an initially empty queue is constructed from
successive enqueue operations, the trailing list will grow whereas the leading list will stay empty. Then,
before the first head or tail operation is performed on an empty leading list, the whole trailing list iscopied to leading, reversing the order of the elements. This is done in an operation
called mirror. Listing 19.1 shows an implementation of queues that uses this approach.
class Queue[T](
private val leading: List[T],
private val trailing: List[T]
) {
private def mirror =
if (leading.isEmpty)
new Queue(trailing.reverse, Nil)
else
this
def head = mirror.leading.head
def tail = {
val q = mirror
new Queue(q.leading.tail, q.trailing)
}
}
def enqueue(x: T) =
new Queue(leading, x :: trailing)
Listing 19.1 - A basic functional queue.
What is the complexity of this implementation of queues? The mirror operation might take time
proportional to the number of queue elements, but only if list leading is empty. It returns directly
if leading is non-empty. Because head and tail call mirror, their complexity might be linear in the size
of the queue, too. However, the longer the queue gets, the less often mirror is called.
Indeed, assume a queue of length n with an empty leading list. Then mirror has to reverse-copy a list of
length n. However, the next time mirror will have to do any work is once the leading list is empty
again, which will be the case after n tail operations. This means you can "charge" each of
these n tail operations with one n&#8217;th of the complexity of mirror, which means a constant amount of
work. Assuming that head, tail, and enqueue operations appear with about the same frequency,
the amortized complexity is hence constant for each operation. So functional queues are asymptotically
just as efficient as mutable ones.
Now, there are some caveats that need to be attached to this argument. First, the discussion was only
about asymptotic behavior; the constant factors might well be somewhat different. Second, the
argument rested on the fact that head, tail and enqueue are called with about the same frequency.
If head is called much more often than the other two operations, the argument is not valid, as each call
to head might involve a costly re-organization of the list with mirror. The second caveat can be
avoided; it is possible to design functional queues so that in a sequence of successive head operations
only the first one might require a re-organization. You will find out at the end of this chapter how this is
done.19.2 INFORMATION HIDING
The implementation of Queue shown in Listing 19.1 is now quite good with regards toefficiency. You
might object, though, that this efficiency is paid for by exposing a needlessly detailed implementation.
The Queue constructor, which is globally accessible, takes two lists as parameters, where one is
reversed—hardly an intuitive representation of a queue. What&#8217;s needed is a way to hide this constructor
from client code. In this section, we&#8217;ll show you some ways to accomplish this in Scala.
Private constructors and factory methods
In Java, you can hide a constructor by making it private. In Scala, the primary constructor does not
have an explicit definition; it is defined implicitly by the class parameters and body. Nevertheless, it is
still possible to hide the primary constructor by adding a private modifier in front of the class parameter
list, as shown in Listing 19.2:
class Queue[T] private (
private val leading: List[T],
private val trailing: List[T]
)
Listing 19.2 - Hiding a primary constructor by making it private.
The private modifier between the class name and its parameters indicates that the constructor
of Queue is private: it can be accessed only from within the class itself and its companion object. The
class name Queue is still public, so you can use it as a type, but you cannot call its constructor:
scala&gt; new Queue(List(1, 2), List(3))
&lt;console&gt;:9: error: constructor Queue in class Queue cannot
be accessed in object $iw
new Queue(List(1, 2), List(3))
<sup>
Now that the primary constructor of class Queue can no longer be called from client code, there needs
to be some other way to create new queues. One possibility is to add an auxiliary constructor, like this:
def this() = this(Nil, Nil)
The auxiliary constructor shown in the previous example builds an empty queue. As a refinement, the
auxiliary constructor could take a list of initial queue elements:
def this(elems: T*) = this(elems.toList, Nil)
Recall that T* is the notation for repeated parameters, as described in Section 8.8.
Another possibility is to add a factory method that builds a queue from such a sequence of initial
elements. A neat way to do this is to define an object Queue that has the same name as the class being
defined and contains an apply method, as shown in Listing 19.3:
object Queue {

def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
}Listing 19.3 - An apply factory method in a companion object.
By placing this object in the same source file as class Queue, you make the object a companion object
of the class. You saw in Section 13.5 that a companion object has the same access rights as its class.
Because of this, the apply method in object Queue can create a new Queue object, even though the
constructor of class Queue is private.
Note that, because the factory method is called apply, clients can create queues with an expression such
as Queue(1, 2, 3). This expression expands to Queue.apply(1, 2, 3) since Queue is an object instead of a
function. As a result, Queue looks to clients as if it was a globally defined factory method. In reality,
Scala has no globally visible methods; every method must be contained in an object or a class.
However, using methods named apply inside global objects, you can support usage patterns that look
like invocations of global methods.
trait
def
def
def
}
Queue[T] {
head: T
tail: Queue[T]
enqueue(x: T): Queue[T]
object Queue {
def apply[T](xs: T*): Queue[T] =
new QueueImpl[T](xs.toList, Nil)
private class QueueImpl[T](
private val leading: List[T],
private val trailing: List[T]
) extends Queue[T] {
def mirror =
if (leading.isEmpty)
new QueueImpl(trailing.reverse, Nil)
else
this
def head: T = mirror.leading.head
def tail: QueueImpl[T] = {
val q = mirror
new QueueImpl(q.leading.tail, q.trailing)
}
def enqueue(x: T) =
new QueueImpl(leading, x :: trailing)
}
}
Listing 19.4 - Type abstraction for functional queues.
An alternative: private classes
Private constructors and private members are one way to hide the initialization and representation of a
class. Another more radical way is to hide the class itself and only export a trait that reveals the public
interface of the class. The code in Listing 19.4 implements this design. There&#8217;s a trait Queue, whichdeclares the methods head, tail, and enqueue. All three methods are implemented in a
subclass QueueImpl, which is itself a private inner class of objectQueue. This exposes to clients the
same information as before, but using a different technique. Instead of hiding individual constructors
and methods, this version hides the whole implementation class.
19.3 VARIANCE ANNOTATIONS
Queue, as defined in Listing 19.4, is a trait, but not a type. Queue is not a type because it takes a type
parameter.
As a result, you cannot create variables of type Queue:
scala&gt; def doesNotCompile(q: Queue) = {}
&lt;console&gt;:8: error: class Queue takes type parameters
def doesNotCompile(q: Queue) = {}
</sup>
Instead, trait Queue enables you to specify parameterized types, such as Queue[String],Queue[Int],
or Queue[AnyRef]:
scala&gt; def doesCompile(q: Queue[AnyRef]) = {}
doesCompile: (q: Queue[AnyRef])Unit
Thus, Queue is a trait and Queue[String] is a type. Queue is also called a type constructor because you
can construct a type with it by specifying a type parameter. (This is analogous to constructing an object
instance with a plain-old constructor by specifying a value parameter.) The type
constructor Queue "generates" a family of types, which includes Queue[Int],Queue[String],
and Queue[AnyRef].
You can also say that Queue is a generic trait. (Classes and traits that take type parameters are
"generic," but the types they generate are "parameterized," not generic.) The term "generic" means that
you are defining many specific types with one generically written class or trait. For example,
trait Queue in Listing 19.4 defines a generic queue. Queue[Int] and Queue[String],etc., would be the
specific queues.
The combination of type parameters and subtyping poses some interesting questions. For example, are
there any special subtyping relationships between members of the family of types generated
by Queue[T]? More specifically, should a Queue[String] be considered a subtype of Queue[AnyRef]?
Or more generally, if S is a subtype of type T, then should Queue[S] be considered a subtype
of Queue[T]? If so, you could say that trait Queue is covariant (or "flexible") in its type parameter T.
Or, since it just has one type parameter, you could say simply that Queues are covariant.
Covariant Queues would mean, for example, that you could pass a Queue[String] to
the doesCompile method shown previously, which takes a value parameter of type Queue[AnyRef].
Intuitively, all this seems OK, since a queue of Strings looks like a special case of a queue ofAnyRefs.
In Scala, however, generic types have by default nonvariant (or "rigid") subtyping. That is,
with Queue defined as in Listing 19.4, queues with different element types would never be in a subtyperelationship. A Queue[String] would not be usable as a Queue[AnyRef]. However, you can demand
covariant (flexible) subtyping of queues by changing the first line of the definition of class Queue like
this:
trait Queue[<code>T] { &#8230; }
Prefixing a formal type parameter with a + indicates that subtyping is covariant (flexible) in that
parameter. By adding this single character, you are telling Scala that you wantQueue[String], for
example, to be considered a subtype of Queue[AnyRef]. The compiler will check that Queue is defined
in a way that this subtyping is sound.
Besides +, there is also a prefix -, which indicates contravariant subtyping. If Queue were defined like
this:
trait Queue[-T] { &#8230; }
then if T is a subtype of type S, this would imply that Queue[S] is a subtype of Queue[T] (which in the
case of queues would be rather surprising!). Whether a type parameter is covariant, contravariant, or
nonvariant is called the parameter&#8217;s variance. The + and - symbols you can place next to type
parameters are called variance annotations.
In a purely functional world, many types are naturally covariant (flexible). However, the situation
changes once you introduce mutable data. To find out why, consider the simple type of one-element
cells that can be read or written, shown in Listing 19.5.
class Cell[T](init: T) {
private[this] var current = init
def get = current
def set(x: T) = { current = x }
}
Listing 19.5 - A nonvariant (rigid) Cell class.
The Cell type of Listing 19.5 is declared nonvariant (rigid). For the sake of argument, assume for a
moment that Cell was declared covariant instead—i.e., it was declared class Cell[+T]—and that this
passed the Scala compiler. (It doesn&#8217;t, and we&#8217;ll explain why shortly.) Then you could construct the
following problematic statement sequence:
val c1 = new Cell[String]("abc")
val c2: Cell[Any] = c1
c2.set(1)
val s: String = c1.get
Seen by itself, each of these four lines looks OK. The first line creates a cell of strings and stores it in
a val named c1. The second line defines a new val, c2, of type Cell[Any], which initialized with c1.
This is OK since Cells are assumed to be covariant. The third line sets the value of cell c2 to 1. This is
also OK because the assigned value 1 is an instance of c2&#8217;s element type Any. Finally, the last line
assigns the element value of c1 into a string. Nothing strange here, as both the sides are of the sametype. But taken together, these four lines end up assigning the integer 1 to the string s. This is clearly a
violation of type soundness.
Which operation is to blame for the runtime fault? It must be the second one, which uses covariant
subtyping. The other statements are too simple and fundamental. Thus, a Cell ofString is not also
a Cell of Any, because there are things you can do with a Cell of Any that you cannot do with
a Cell of String. You cannot use set with an Int argument on a Cell of String, for example.
In fact, were you to pass the covariant version of Cell to the Scala compiler, you would get a compile-
time error:
Cell.scala:7: error: covariant type T occurs in
contravariant position in type T of value x
def set(x: T) = current = x
<sup>
Variance and arrays
It&#8217;s interesting to compare this behavior with arrays in Java. In principle, arrays are just like cells except
that they can have more than one element. Nevertheless, arrays are treated as covariant in Java.
You can try an example analogous to the cell interaction described here with Java arrays:

String[] a1 = { "abc" };
Object[] a2 = a1;
a2[0] = new Integer(17);
String s = a1[0];
If you try out this example, you will find that it compiles. But executing the program will cause
an ArrayStore exception to be thrown when a2[0] is assigned to an Integer:
Exception in thread "main" java.lang.ArrayStoreException:
java.lang.Integer
at JavaArrays.main(JavaArrays.java:8)
What happens here is that Java stores the element type of the array at runtime. Then, every time an
array element is updated, the new element value is checked against the stored type. If it is not an
instance of that type, an ArrayStore exception is thrown.
You might ask why Java adopted this design, which seems both unsafe and expensive. When asked this
question, James Gosling, the principal inventor of the Java language, answered that they wanted to
have a simple means to treat arrays generically. For instance, they wanted to be able to write a method
to sort all elements of an array, using a signature like the following that takes an array of Object:
void sort(Object[] a, Comparator cmp) { &#8230; }
Covariance of arrays was needed so that arrays of arbitrary reference types could be passed to
this sort method. Of course, with the arrival of Java generics, such a sort method can now be writtenwith a type parameter, so the covariance of arrays is no longer necessary. For compatibility reasons,
though, it has persisted in Java to this day.
Scala tries to be purer than Java in not treating arrays as covariant. Here&#8217;s what you get if you translate
the first two lines of the array example to Scala:
scala&gt; val a1 = Array("abc")
a1: Array[String] = Array(abc)
scala&gt; val a2: Array[Any] = a1
&lt;console&gt;:8: error: type mismatch;
found
: Array[String]
required: Array[Any]
val a2: Array[Any] = a1
</sup>
What happened here is that Scala treats arrays as nonvariant (rigid), so an Array[String] is not
considered to conform to an Array[Any]. However, sometimes it is necessary to interact with legacy
methods in Java that use an Object array as a means to emulate a generic array. For instance, you might
want to call a sort method like the one described previously with an array of Strings as argument. To
make this possible, Scala lets you cast an array of Ts to an array of any supertype of T:
scala&gt; val a2: Array[Object] =
a1.asInstanceOf[Array[Object]]
a2: Array[Object] = Array(abc)
The cast is always legal at compile-time, and it will always succeed at run-time because the JVM&#8217;s
underlying run-time model treats arrays as covariant, just as Java the language does. But you might
get ArrayStore exceptions afterwards, again just as you would in Java.
19.4 CHECKING VARIANCE ANNOTATIONS
Now that you have seen some examples where variance is unsound, you may be wondering which kind
of class definitions need to be rejected and which can be accepted. So far, all violations of type
soundness involved some reassignable field or array element. The purely functional implementation of
queues, on the other hand, looks like a good candidate for covariance. However, the following example
shows that you can "engineer" an unsound situation even if there is no reassignable field.
To set up the example, assume that queues as defined in Listing 19.4 are covariant. Then, create a
subclass of queues that specializes the element type to Int and overrides the enqueuemethod:
class StrangeIntQueue extends Queue[Int] {
override def enqueue(x: Int) = {
println(math.sqrt(x))
super.enqueue(x)
}
}
The enqueue method in StrangeIntQueue prints out the square root of its (integer) argument before
doing the append proper.Now, you can write a counterexample in two lines:
val x: Queue[Any] = new StrangeIntQueue
x.enqueue("abc")
The first of these two lines is valid because StrangeIntQueue is a subclass of Queue[Int] and, assuming
covariance of queues, Queue[Int] is a subtype of Queue[Any]. The second line is valid because you can
append a String to a Queue[Any]. However, taken together, these two lines have the effect of applying
a square root method to a string, which makes no sense.
Clearly it&#8217;s not just mutable fields that make covariant types unsound. The problem is more general. It
turns out that as soon as a generic parameter type appears as the type of a method parameter, the
containing class or trait may not be covariant in that type parameter.
For queues, the enqueue method violates this condition:
class Queue[+T] {
def enqueue(x: T) =
&#8230;
}
Running a modified queue class like the one above through a Scala compiler would yield:
Queues.scala:11: error: covariant type T occurs in
contravariant position in type T of value x
def enqueue(x: T) =
<sup>
Reassignable fields are a special case of the rule that disallows type parameters annotated with + from
being used as method parameter types. As mentioned in Section 18.2, a reassignable field, "var x: T", is
treated in Scala as a getter method, "def x: T", and a setter method, "def x_=(y: T)". As you can see, the
setter method has a parameter of the field&#8217;s type T. So that type may not be covariant.
THE FAST TRACK
In the rest of this section, we&#8217;ll describe the mechanism by which the Scala compiler checks variance
annotations. If you&#8217;re not interested in such detail right now, you can safely skip toSection 19.5. The
most important thing to understand is that the Scala compiler will check any variance annotations you
place on type parameters. For example, if you try to declare a type parameter to be covariant (by adding
a +), but that could lead to potential runtime errors, your program won&#8217;t compile.
To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or
trait body as positive, negative or neutral. A "position" is any location in the class or trait (but from
now on we&#8217;ll just write "class") body where a type parameter may be used. For example, every method
value parameter is a position because a method value parameter has a type. Therefore a type parameter
could appear in that position.
The compiler checks each use of each of the class&#8217;s type parameters. Type parameters annotated
with + may only be used in positive positions, while type parameters annotated with - may only be usedin negative positions. A type parameter with no variance annotation may be used in any position, and is,
therefore, the only kind of type parameter that can be used in neutral positions of the class body.
To classify the positions, the compiler starts from the declaration of a type parameter and then moves
inward through deeper nesting levels. Positions at the top level of the declaring class are classified as
positive. By default, positions at deeper nesting levels are classified the same as that at enclosing
levels, but there are a handful of exceptions where the classification changes. Method value parameter
positions are classified to the flipped classification relative to positions outside the method, where the
flip of a positive classification is negative, the flip of a negative classification is positive, and the flip of
a neutral classification is still neutral.
Besides method value parameter positions, the current classification is also flipped at the type
parameters of methods. A classification is sometimes flipped at the type argument position of a type,
such as the Arg in C[Arg], depending on the variance of the corresponding type parameter. If C&#8217;s type
parameter is annotated with a + then the classification stays the same. If C&#8217;s type parameter is annotated
with a -, then the current classification is flipped. IfC&#8217;s type parameter has no variance annotation then
the current classification is changed to neutral.
As a somewhat contrived example, consider the following class definition, where several positions are
annotated with their classifications, </sup></code> (for positive) or <sup>- (for negative):
abstract class Cat[-T, <code>U] {
def meow[W</sup>-](volume: T<sup>-, listener: Cat[U</sup></code>, T<sup>-]</sup>-)
: Cat[Cat<sup><span class="U^<code>">-, U</span></sup></code>]<sup>+
}
The positions of the type parameter, W, and the two value parameters, volume and listener, are all
negative. Looking at the result type of meow, the position of the first Cat[U, T] argument is negative
because Cat&#8217;s first type parameter, T, is annotated with a -. The type U inside this argument is again in
positive position (two flips), whereas the type T inside that argument is still in negative position.
You see from this discussion that it&#8217;s quite hard to keep track of variance positions. That&#8217;s why it&#8217;s a
welcome relief that the Scala compiler does this job for you.
Once the classifications are computed, the compiler checks that each type parameter is only used in
positions that are classified appropriately. In this case, T is only used in negative positions, and U is
only used in positive positions. So class Cat is type correct.
19.5 LOWER BOUNDS
Back to the Queue class. You saw that the previous definition of Queue[T] shown in Listing 19.4cannot
be made covariant in T because T appears as a type of a parameter of the enqueuemethod, and that&#8217;s a
negative position.
Fortunately, there&#8217;s a way to get unstuck: you can generalize enqueue by making it polymorphic (i.e.,
giving the enqueue method itself a type parameter) and using a lower bound for its type
parameter. Listing 19.6 shows a new formulation of Queue that implements this idea.class Queue[+T] (private val leading: List[T],
private val trailing: List[T] ) {
def enqueue[U &gt;: T](x: U) =
new Queue[U](leading, x :: trailing) // &#8230;
}
Listing 19.6 - A type parameter with a lower bound.
The new definition gives enqueue a type parameter U, and with the syntax, "U &gt;: T", defines T as the
lower bound for U. As a result, U is required to be a supertype of T.<span class="footnote"><br />[Supertype and subtype relationships are reflexive, which means a type is both a supertype and a subtype of itself. Even though T is a lower bound for U, you could still pass in a T toenqueue.]<br /></span> The parameter toenqueue is now
of type U instead of type T, and the return value of the method is now Queue[U]instead of Queue[T].
For example, suppose there is a class Fruit with two subclasses, Apple and Orange. With the new
definition of class Queue, it is possible to append an Orange to a Queue[Apple]. The result will be
aQueue[Fruit].
This revised definition of enqueue is type correct. Intuitively, if T is a more specific type than expected
(for example, Apple instead of Fruit), a call to enqueue will still work because U (Fruit) will still be a
supertype of T (Apple).<span class="footnote"><br />[Technically, what happens is a flip occurs for lower bounds. The type parameter U is in a negative position (1 flip), while the lower bound (&gt;: T) is in a positive position (2 flips).]<br /></span>
The new definition of enqueue is arguably better than the old, because it is more general. Unlike the old
version, the new definition allows you to append an arbitrary supertype U of the queue element type T.
The result is then a Queue[U]. Together with queue covariance, this gives the right kind of flexibility
for modeling queues of different element types in a natural way.
This shows that variance annotations and lower bounds play well together. They are a good example
of type-driven design, where the types of an interface guide its detailed design and implementation. In
the case of queues, it&#8217;s likely you would not have thought of the refined implementation
of enqueue with a lower bound. But you might have decided to make queues covariant, in which case,
the compiler would have pointed out the variance error for enqueue. Correcting the variance error by
adding a lower bound makes enqueue more general and queues as a whole more usable.
This observation is also the main reason that Scala prefers declaration-site variance over use-site
variance as it is found in Java&#8217;s wildcards. With use-site variance, you are on your own designing a
class. It will be the clients of the class that need to put in the wildcards, and if they get it wrong, some
important instance methods will no longer be applicable. Variance being a tricky business, users usually
get it wrong, and they come away thinking that wildcards and generics are overly complicated. With
definition-side variance, you express your intent to the compiler, and the compiler will double check
that the methods you want available will indeed be available.
19.6 CONTRAVARIANCE
So far in this chapter, all examples you&#8217;ve seen were either covariant or nonvariant. But there are also
cases where contravariance is natural. For instance, consider the trait of output channels shown
in Listing 19.7:
trait OutputChannel[-T] {
def write(x: T)}
Listing 19.7 - A contravariant output channel.
Here, OutputChannel is defined to be contravariant in T. So an output channel of AnyRefs, say, is a
subtype of an output channel of Strings. Although it may seem non-intuitive, it actually makes sense.
To see why, consider what you can do with an OutputChannel[String]. The only supported operation is
writing a String to it. The same operation can also be done on anOutputChannel[AnyRef]. So it is safe
to substitute an OutputChannel[AnyRef] for anOutputChannel[String]. By contrast, it would not be safe
to substitute an OutputChannel[String]where an OutputChannel[AnyRef] is required. After all, you can
send any object to anOutputChannel[AnyRef], whereas an OutputChannel[String] requires that the
written values are all strings.
This reasoning points to a general principle in type system design: It is safe to assume that a type T is a
subtype of a type U if you can substitute a value of type T wherever a value of type Uis required. This
is called the Liskov Substitution Principle. The principle holds if T supports the same operations as U,
and all of T&#8217;s operations require less and provide more than the corresponding operations in U. In the
case of output channels, an OutputChannel[AnyRef] can be a subtype of
an OutputChannel[String] because the two support the same write operation, and this operation requires
less in OutputChannel[AnyRef] than in OutputChannel[String]. "Less" means the argument is only
required to be an AnyRef in the first case, whereas it is required to be a Stringin the second case.
Sometimes covariance and contravariance are mixed in the same type. A prominent example is Scala&#8217;s
function traits. For instance, whenever you write the function type A &#8658; B, Scala expands this
to Function1[A, B]. The definition of Function1 in the standard library uses both covariance and
contravariance: the Function1 trait is contravariant in the function argument type S and covariant in the
result type T, as shown in Listing 19.8. This satisfies the Liskov Substitution Principle because
arguments are something that&#8217;s required, whereas results are something that&#8217;s provided.
trait Function1[-S, +T] {
def apply(x: S): T
}
Listing 19.8 - Covariance and contravariance of Function1s.
As an example, consider the application shown in Listing 19.9. Here, class Publicationcontains one
parametric field, title, of type String. Class Book extends Publication and forwards its
string title parameter to the constructor of its superclass. The Library singleton object defines a set of
books and a method printBookList, which takes a function, named info, of typeBook &#8658; AnyRef. In
other words, the type of the lone parameter to printBookList is a function that takes one Book argument
and returns an AnyRef. The Customer application defines a method,getTitle, which takes
a Publication as its lone parameter and returns a String, the title of the passed Publication.
class Publication(val title: String)
class Book(title: String) extends Publication(title)
object Library {val books: Set[Book] =
Set(
new Book("Programming in Scala"),
new Book("Walden")
)
def printBookList(info: Book &#8658; AnyRef) = {
for (book &#8592; books) println(info(book))
}
}
object Customer extends App {
def getTitle(p: Publication): String = p.title
Library.printBookList(getTitle)
}
Listing 19.9 - Demonstration of function type parameter variance.
Now take a look at the last line in Customer. This line invokes Library&#8217;s printBookList method and
passes getTitle, wrapped in a function value:
Library.printBookList(getTitle)
This line of code type checks even though String, the function&#8217;s result type, is a subtype ofAnyRef, the
result type of printBookList&#8217;s info parameter. This code passes the compiler because function result
types are declared to be covariant (the +T in Listing 19.8). If you look inside the body
of printBookList, you can get a glimpse of why this makes sense.
The printBookList method iterates through its book list and invokes the passed function on each book.
It passes the AnyRef result returned by info to println, which invokes toString on it and prints the
result. This activity will work with String as well as any other subclass of AnyRef, which is what
covariance of function result types means.
Now consider the parameter type of the function being passed to the printBookList method.
Although printBookList&#8217;s parameter type is declared as Book, the getTitle we&#8217;re passing in takes
a Publication, a supertype of Book. The reason this works is that since printBookList&#8217;s parameter type
is Book, the body of the printBookList method will only be allowed to pass a Book into the function.
And because getTitle&#8217;s parameter type is Publication, the body of that function will only be able to
access on its parameter, p, members that are declared in class Publication. Because any method
declared in Publication is also available on its subclass Book, everything should work, which is what
contravariance of function parameter types means. You can see all this graphically in Figure 19.1.
The code in Listing 19.9 compiles because Publication &#8658; String is a subtype of Book &#8658; AnyRef, as
shown in the center of the Figure 19.1. Because the result type of a Function1 is defined as covariant,
the inheritance relationship of the two result types, shown at the right of the diagram, is in the same
direction as that of the two functions shown in the center. By contrast, because the parameter type of
a Function1 is defined as contravariant, the inheritance relationship of the two parameter types, shown
at the left of the diagram, is in the opposite direction as that of the two functions.Figure 19.1 - Covariance and contravariance in function type parameters.
class Queue[+T] private (
private[this] var leading: List[T],
private[this] var trailing: List[T]
) {
private def mirror() =
if (leading.isEmpty) {
while (!trailing.isEmpty) {
leading = trailing.head :: leading
trailing = trailing.tail
}
}
def head: T = {
mirror()
leading.head
}
def tail: Queue[T] = {
mirror()
new Queue(leading.tail, trailing)
}
}
def enqueue[U &gt;: T](x: U) =
new Queue[U](leading, x :: trailing)
Listing 19.10 - An optimized functional queue.
19.7 OBJECT PRIVATE DATA
The Queue class seen so far has a problem in that the mirror operation will repeatedly copy
thetrailing into the leading list if head is called several times in a row on a list where leading is empty.
The wasteful copying could be avoided by adding some judicious side effects. Listing 19.10 presents a
new implementation of Queue, which performs at most one trailing to leadingadjustment for any
sequence of head operations.
What&#8217;s different with respect to the previous version is that now leading and trailing are reassignable
variables, and mirror performs the reverse copy from trailing to leading as a side effect on the current
queue instead of returning a new queue. This side effect is purely internal to the implementation of
the Queue operation; since leading and trailing are private variables, the effect is not visible to clients
of Queue. So by the terminology established inChapter 18, the new version of Queue still defines
purely functional objects, in spite of the fact that they now contain reassignable fields.You might wonder whether this code passes the Scala type checker. After all, queues now contain two
reassignable fields of the covariant parameter type T. Is this not a violation of the variance rules? It
would be indeed, except for the detail that leading and trailing have aprivate[this] modifier, and are
thus declared to be object private.
As mentioned in Section 13.5, object private members can be accessed only from within the object in
which they are defined. It turns out that accesses to variables from the same object in which they are
defined do not cause problems with variance. The intuitive explanation is that, in order to construct a
case where variance would lead to type errors, you need to have a reference to a containing object that
has a statically weaker type than the type the object was defined with. For accesses to object private
values, however, this is impossible.
Scala&#8217;s variance checking rules contain a special case for object private definitions. Such definitions are
omitted when it is checked that a type parameter with either a + or -annotation occurs only in positions
that have the same variance classification. Therefore, the code in Listing 19.10 compiles without error.
On the other hand, if you had left out the [this]qualifiers from the two private modifiers, you would see
two type errors:
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter leading_=
class Queue[+T] private (private var leading: List[T],
</sup>
Queues.scala:1: error: covariant type T occurs in
contravariant position in type List[T] of parameter of
setter trailing_=
private var trailing: List[T]) {
<sup>
19.8 UPPER BOUNDS
In Listing 16.1 here, we showed a merge sort function for lists that took a comparison function as a first
argument and a list to sort as a second, curried argument. Another way you might want to organize such
a sort function is by requiring the type of the list to mix in theOrdered trait. As mentioned in Section
12.4, by mixing Ordered into a class and implementingOrdered&#8217;s one abstract method, compare,
you enable clients to compare instances of that class with &lt;, &gt;, &#8656;, and &gt;=. For example, Listing
19.11 shows Ordered being mixed into a Person class.
As a result, you can compare two people like this:
scala&gt; val robert = new Person("Robert", "Jones")
robert: Person = Robert Jones
scala&gt; val sally = new Person("Sally", "Smith")
sally: Person = Sally Smith
scala&gt; robert &lt; sally
res0: Boolean = true
class Person(val firstName: String, val lastName: String)extends Ordered[Person] {
def compare(that: Person) = {
val lastNameComparison =
lastName.compareToIgnoreCase(that.lastName)
if (lastNameComparison != 0)
lastNameComparison
else
firstName.compareToIgnoreCase(that.firstName)
}
override def toString = firstName + " " + lastName
}
Listing 19.11 - A Person class that mixes in the Ordered trait.
def orderedMergeSort[T &lt;: Ordered[T]](xs: List[T]): List[T] = {
def merge(xs: List[T], ys: List[T]): List[T] =
(xs, ys) match {
case (Nil, <em>) &#8658; ys
case (</em>, Nil) &#8658; xs
case (x :: xs1, y :: ys1) &#8658;
if (x &lt; y) x :: merge(xs1, ys)
else y :: merge(xs, ys1)
}
val n = xs.length / 2
if (n == 0) xs
else {
val (ys, zs) = xs splitAt n
merge(orderedMergeSort(ys), orderedMergeSort(zs))
}
}
Listing 19.12 - A merge sort function with an upper bound.
To require that the type of the list passed to your new sort function mixes in Ordered, you need to use
an upper bound. An upper bound is specified similar to a lower bound, except instead of the &gt;: symbol
used for lower bounds, you use a &lt;: symbol, as shown in Listing 19.12.
With the "T &lt;: Ordered[T]" syntax, you indicate that the type parameter, T, has an upper
bound,Ordered[T]. This means that the element type of the list passed to orderedMergeSort must be a
subtype of Ordered. Thus, you could pass a List[Person] to orderedMergeSort because Person mixes
in Ordered.
For example, consider this list:
scala&gt; val people = List(
new Person("Larry", "Wall"),
new Person("Anders", "Hejlsberg"),
new Person("Guido", "van Rossum"),
new Person("Alan", "Kay"),
new Person("Yukihiro", "Matsumoto")
)
people: List[Person] = List(Larry Wall, Anders Hejlsberg,
Guido van Rossum, Alan Kay, Yukihiro Matsumoto)Because the element type of this list, Person, mixes in (and is therefore a subtype of)Ordered[People],
you can pass the list to orderedMergeSort:
scala&gt; val sortedPeople = orderedMergeSort(people)
sortedPeople: List[Person] = List(Anders Hejlsberg, Alan Kay,
Yukihiro Matsumoto, Guido van Rossum, Larry Wall)
Now, although the sort function shown in Listing 19.12 serves as a useful illustration of upper bounds,
it isn&#8217;t actually the most general way in Scala to design a sort function that takes advantage of
the Ordered trait.
For example, you couldn&#8217;t use the orderedMergeSort function to sort a list of integers, because
class Int is not a subtype of Ordered[Int]:
scala&gt; val wontCompile = orderedMergeSort(List(3, 2, 1))
&lt;console&gt;:5: error: inferred type arguments [Int] do
not conform to method orderedMergeSort&#8217;s type
parameter bounds [T &lt;: Ordered[T]]
val wontCompile = orderedMergeSort(List(3, 2, 1))
</sup>
In Section 21.6, we&#8217;ll show you how to use implicit parameters and context bounds to achieve a more
general solution.
19.9 CONCLUSION
In this chapter you saw several techniques for information hiding: private constructors, factory
methods, type abstraction, and object private members. You also learned how to specify data type
variance and what it implies for class implementation. Finally, you saw two techniques which help in
obtaining flexible variance annotations: lower bounds for method type parameters
and private[this] annotations for local fields and methods.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-17 23:18:22 EET
</div>
</div>
</body>
</html>
