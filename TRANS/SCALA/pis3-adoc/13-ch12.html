<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__12">Глава 12</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_">Трейти</h1>
<div class="paragraph"><p>Трейти є фундаментальною одиницею повторного використання коду в Scala. Трейт енкапсулює визначення методів та полів, що потім може бути використані через його міксування з полями. На відміну від наслідування класів, в якому кожний клас має наслідувати від тільки одного суперкласу, клас може міксувати любе число трейтів. Ця глава показує вам, як роблять трейти, та показує два з найбільш загальних шляхів, як вони можуть бути корисні: розширення інтерфейсів до багатих, та визначення накладуваних модифікацій. Вона також показує, як використовувати трейти <code>Ordered</code> та <code>compares</code> як множинного наслідування в інших мовах.</p></div>
<div class="sect1">
<h2 id="_12_1___">12.1 Як роблять трейти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Визначення трейта виглядає так само, як визначення класу, з тією різницею, що він використовує ключове слово <code>trait</code>. Приклад показаний в Лістингу 12.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;I consume memory, therefore I am!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.1 - Визначення трейта <code>Philosophical</code>.</p></div>
<div class="paragraph"><p>Цей трейт з назвою <code>Philosophical</code>. Він не декларує суперкласа, так що як в класи, він має суперклас по замовчанню, <code>AnyRef</code>. Він визначає один метод, названий <code>philosophize</code>, що є суцільним. Це простий трейт, але достатній для того, як роблять трейти.</p></div>
<div class="paragraph"><p>Коли трейт визначений, він може бути зміксований з класом, використовуючи ключові слова <code>extends</code>, або <code>with</code>. Програмісти Scala "міксують" трейти, скоріше ніж наслідують від них, оскільки міксування трейту має важливі відмінності від множинного наслідування, яке можна знайти в інших мовах. Цей момент дискутується в Розділі 12.6. Наприклад, Лістинг 12.2 показує клас, що міксує трейт <code>Philosophical</code> з використанням <code>extends</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.2 - Міксування трейту використовуючи <code>extends</code>.</p></div>
<div class="paragraph"><p>Ви можете використовувати ключове слово <code>extends</code> для міксування трейта; в цьому випадку ви неявно наслідуєте від суперкласа трейта. Наприклад, в Лістингу 12.2 клас <code>Frog</code> є субкласом <code>AnyRef</code> (суперклас <code>Philosophical</code>), та міксує <code>Philosophical</code>. Методи, наслідувані від трейта, можуть бути використані так само, як і методи, наслідувані від суперкласа. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">frog</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Frog</span>
<span class="n">frog</span><span class="k">:</span> <span class="kt">Frog</span> <span class="o">=</span> <span class="n">green</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">frog</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="n">I</span> <span class="n">consume</span> <span class="n">memory</span><span class="o">,</span> <span class="n">therefore</span> <span class="n">I</span> <span class="n">am</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>Трейт також визначає тип. Ось приклад, в якому <code>Philosophical</code> використовується як тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">phil</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">frog</span>
<span class="n">phil</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">green</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">phil</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="n">I</span> <span class="n">consume</span> <span class="n">memory</span><span class="o">,</span> <span class="n">therefore</span> <span class="n">I</span> <span class="n">am</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>phil</code> є трейт <code>Philosophical</code>. Таким чином, змінна <code>phil</code> може бути ініціалізована любим об'єктом, чий клас міксує <code>Philosophical</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте міксувати трейт в клас, що явно розширює суперклас, ви використовуєте  <code>extends</code> для вказання суперкласа, та <code>mix</code> для підмішування трейта. Лістинг 12.3 показує приклад. Якщо ви бажаєте зміксувати декілька трейтів, ви додаєте більше тверджень <code>with</code>. Наприклад, маючи трейт <code>HasLegs</code>, ви можете міксувати обоє, <code>Philosophical</code> та <code>HasLegs</code> у <code>Frog</code>, як показане в Лістингу 12.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.3 - Mixing in a trait using with.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">HasLegs</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="k">with</span> <span class="nc">HasLegs</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.4 - Міксування декількох трейтів.</p></div>
<div class="paragraph"><p>В прикладі, що ви бачили дотепер, клас <code>Frog</code> наслідував реалізацію <code>philosophize</code> від трейта <code>Philosophical</code>. Альтернативно, <code>Frog</code> може перекривати <code>philosophize</code>. Синтаксис виглядає так, як і перекриття метода, декларованого в суперкласі. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;It ain&#39;t easy being &quot;</span> <span class="o">+</span> <span class="n">toString</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки це нове визначення <code>Frog</code> все ще міксує трейт <code>Philosophical</code>, ви можете використовувати його зі змінними цього типу. Але оскільки <code>Frog</code> перекриває реалізацію <code>Philosophical</code> для <code>philosophize</code>, ви отримаєте нову поведінку при його виклику:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">phrog</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Frog</span>
<span class="n">phrog</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">greenscala</span><span class="o">&gt;</span> <span class="n">phrog</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="nc">It</span> <span class="n">ain</span><span class=" -Symbol">&#39;t</span> <span class="n">easy</span> <span class="n">being</span> <span class="n">green</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>В цій точці ви можете <em>philosophize</em> що трейти подібні до Java інтерфейсів з суцільними методами, але насправді вони можуть значно більше. Наприклад, трейти можуть декларувати поля та підтримувати стан. Фактично, ви можете робити будь-що в визначенні трейта, що ви можете робити в визначенні класу, та синтаксис виглядає так само, з двома виключеннями.</p></div>
<div class="paragraph"><p>Перше, трейт не може мати жодних параметрів "класу" (тобто параметрів, що передаються до первинного конструктора класу). Іншими словами, хоча ви можете визначити клас таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Наступна спроба визначити трейт не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">NoPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// Не компілюється</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите в Розділі 20.5, як обійти це обмеження.</p></div>
<div class="paragraph"><p>Інша різниця між класами та трейтами в тому, що в класах супер виклики статично прив'язані, в трейтах вони прив'язані динамічно. Якщо ви напишете <code>super.toString</code> в класі, ви точно знаєте, який метод реалізації буде викликаний. Однак коли ви пишете те саме в трейті, метод реалізації, що буде викликаний для <code>super</code> виклику невизначений на час визначення трейта. Скоріше реалізація для виклику буде визначена по новій кожного разу, коли трейт підміксовується в суцільний клас. Ця цікава поведінка <code>super</code> є ключем для можливості трейтів робити як накладувані модифікації, що будуть описані в Розділі 12.5. Правила для розрішення супер викликів будуть надані в Розділі 12.6.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_2_____">12.2 Тонкі інтерфейси проти багатих інтерфейсів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одне головне використання трейтів є автоматичне додавання методів до класу в термінах методів, що клас вже має. Тобто трейти можуть збагатити тонкий інтерфейс, перетворяючи його на багатий інтерфейс.</p></div>
<div class="paragraph"><p>Тонкі інтерфейси проти багатих інтерфейсів представляє загально зустріваний компроміс в об'єктно-орієнтовній розробці. Компроміс між реалізаторами та клієнтами інтерфейсу. Багатий інтерфейс має багато методів, що робить його зручним для викликаючого. Клієнти можуть обрати метод, що точно співпадає з потрібною їм функціональністю. З іншого боку, тонкий інтерфейс має меньше методів, і, таким чином, легше для реалізації. Однак клієнти, що викликають тонкий інтерфейс, мають писати більше коду. Маючи менший вибір методів, що можна викликати, вони мають менший за ідеальний вибір для своїх потреб, та пишуть додатковий код, щоб використати його.</p></div>
<div class="paragraph"><p>Інтерфейси Java більш часто тонкі, ніж багаті. Наприклад, <code>CharSequence</code>, що був введений в Java 1.4, є тонким інтерфейсом, загальним для всіх рядок-подібних класів, що містить послідовність символів. Ось його визначення, якщо дивитись на нього як на Scala трейт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">CharSequence</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">charAt</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Char</span>
  <span class="k">def</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">subSequence</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">CharSequence</span>
  <span class="k">def</span> <span class="n">toString</span><span class="o">()</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча більшість з дюжин методів в класі <code>String</code> можна застосувати до любого <code>CharSequence</code>, інтерфейс Java <code>CharSequence</code> декларує тільки чотири методи. Якщо б <code>CharSequence</code> замість цього включав повний інтерфейс <code>String</code>, це б наклало великий безлад на реалізаторів <code>CharSequence</code>. Кожний програміст, що реалізує <code>CharSequence</code> в Java, мав би перевизначати дюжини методів. Оскільки трейти Scala можуть суцільні методи, вони роблять багаті інтерфейси значно більш зручними.</p></div>
<div class="paragraph"><p>Додавання суцільного метода до трейта схиляє компроміс тонкий-багатий в напрямку багатих інтерфейсів. На відміну від Java, додавання суцільного метода до трейта Scala є одноразовим зусиллям. Вам треба тільки реалізовати метод один раз, в самому трейті, замість потреби повторно реалізовувати його для кожного класу, що міксується з цім трейтом. Таким чином, багаті інтерфейси вимагають меньшої роботи в Scala, ніж в мові без трейтів.</p></div>
<div class="paragraph"><p>Щоб збагатити інтерфейс з використанням трейтів, просто визначте трейт з малим числом абстрактних методів — тонку частину інтерфейса трейта — та потенційно велике число конкретних методів, всі реалізовані в термінах абстрактних методів. Потім ви можете міксувати збагачений трейт в клас, реалізувати тонку частину інтерфейсу, та опинитись з класом з цілим багатим інтерфейсом.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_3____">12.3 Приклад: прямокутні об'єкти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Графічні біблиотеки часто мають багато різних класів, що представляють дещо прямокутне. Деякими прикладами є вікна, бітові зображення, та регіони, обрані мишею. Щоб зробити ці прямокутні об'єкти зручними для використання, було б гарним, щоб бібліотека провадила геометричні запити, такі як <code>width</code>, <code>height</code>, <code>left</code>, <code>right</code>, <code>topLeft</code>, і так далі. Однак, існує багато таких методів, які було б добре мати, так що дописувачі бібліотеки мають великий безлад, провадячи їх до всіх прямокутних об'єктів в Java бібліотеці. Якщо така бібліотека була б написана на Scala, для контрасту, дописувач бібліотеки міг би використовувати трейти, щоб з легкістю запропонувати всі ці зручні методи для всіх класів, до яких побажає.</p></div>
<div class="paragraph"><p>Щоб побачити як це буде, спершу уявімо, як мав би виглядати код без трейтів. Мали б бути базові геометричні класи, як <code>Point</code> та <code>Rectangle</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">val</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span><span class="o">,</span> <span class="k">val</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас <code>Rectangle</code> приймає дві точки в його первинному конструкторі: координати верхнього-лівого та нижнього-правого кутів. Потім він реалізує багато зручних методів, такі як <code>left</code>, <code>right</code> та <code>width</code>, через виконання простих обчислень на ціх двох точках.</p></div>
<div class="paragraph"><p>Інший клас графічної бібліотеки може мати 2-D графічний віджет:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Pointdef</span>
  <span class="n">вуа</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що визначення <code>left</code>, <code>right</code> та <code>width</code> в точності такі самі в двох класів. Вони також будуть ті самі, крім декількох малих варіацій, в любих інших класах для прямокутних об'єктів.</p></div>
<div class="paragraph"><p>Ця репрезентація може бути усунута за допомогою збагаючуючого трейта. Трейт буде мати два абстрактні метода: один що повертатиме верхню-ліву координату об'єкта, та інший, що повертає нижню-праву координату. Потім він може надати суцільні реалізації всіх інших геометричних запитів. Лістинг 12.5 показує, як це буде виглядати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Rectangular</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.5 - Визначення покращеного трейта.</p></div>
<div class="paragraph"><p>Клас <code>Component</code> може зміксувати трейт, щоб отримати всі геометричні методи, що провадить <code>Rectangular</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="k">extends</span> <span class="nc">Rectangular</span> <span class="o">{</span>
<span class="c1">// інші методи...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього, сам <code>Rectangle</code> може міксувати трейт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">val</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span><span class="o">,</span> <span class="k">val</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Rectangular</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// інші методи...</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці визначення, ви можете створити <code>Rectangle</code>, та викликати геометричні методи, такі як <code>width</code> та <code>left</code> на ньому:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rect</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
           <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">))</span>
<span class="n">rect</span><span class="k">:</span> <span class="kt">Rectangle</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="k">@</span><span class="mi">5</span><span class="n">f5da68c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">left</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">right</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">width</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_4__">12.4 Впорядкований трейт</h2>
<div class="sectionbody">
<div class="paragraph"><p>Порівняння є інша галузь, де багаті інтерфейси є зручними. Коли ви порівнюєте два об'єкти, що є впорядкованими, зручно, якщо ви використовуєте простий виклик метода, щоб запитати щодо точного порівняння, яке ви бажаєте. Якщо ви бажаєте "менше ніж", ви можете викликати <code>&lt;</code>, та якщо ви бажаєте "меньше або рівне", ви бажаєте викликати <code>&lt;=</code>. З тонким інтерфейсом порівняння, ви можете мати лише метод <code>&lt;</code>, та ви можете іноді писати речі як <code>(x &lt; y) || (x == y)</code>. Багаті інтерфейси будуть провадити всі зі звичайних операторів порівняння, таким чином дозволяючи вам писати речі, як <code>x &lt;= y</code>.</p></div>
<div class="paragraph"><p>Перед поглядом на <code>Ordered</code>, уявімо, що б ви могли робити без нього. Уявімо, що ви взяли клас <code>Rational</code> з Глави 6, та додали до нього операції порівняння:<span class="footnote"><br />[Цей приклад базується на класі <code>Rational</code>, показаному в Лістингу 6.5, з доданими <code>equals</code>, <code>hashCode</code> та модифікаціями, що запевняють в позитивному займеннику.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// ...</span>
  <span class="k">def</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span>
  <span class="k">def</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="n">that</span> <span class="o">&lt;</span> <span class="k">this</span>
  <span class="k">def</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">that</span><span class="o">)</span>
  <span class="k">def</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">that</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">that</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас визначає чотири оператора порівняння (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, та <code>&gt;=</code>), та це класична демонстрація ціни визначення багатого інтерфейсу. Перше, зауважте, що три оператора порівнянь визначені в термінах першого. Наприклад, <code>&gt;</code> визначений як зворотній до <code>&lt;</code>, та <code>&lt;=</code> визначений буквально як "менше ніж або дорівнює". Далі, зауважте, що всі три з ціх методів будуть ті самі для любого іншого класу, який підтримує порівняння. Немає нічого особливого щодо раціональних чисел відносно <code>&lt;=</code>. В контексті порівняння <code>&lt;=</code> завжди використовується для позначення "меньше ніж або дорівнює". Загалом, присутнє багато шаблонного коду в цьому класі, який буде тим самим в іншому класі, що реалізує операції порівняння.</p></div>
<div class="paragraph"><p>Ця проблема така загальна, що Scala провадить трейт щоб допомогти вам з цім. Трейт має назву <code>Ordered</code>. Щоб використати його, ви заміняєте всі індивідуальні методи порівняння на єдиний метод <code>compare</code>. Потім трейт <code>Ordered</code> визначає <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, та <code>&gt;=</code> за вас в термінах цього одного метода. Таким чином, трейт <code>Ordered</code> дозволяє вам збагатити клас за допомогою методів порівнянь, через реалізацію тільки одного метода <code>compare</code>.</p></div>
<div class="paragraph"><p>Ось як тепер це виглядає, якщо ви визначите операції порівняння в <code>Rational</code> через використання трейта <code>Ordered</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span> <span class="o">{</span>
<span class="c1">// ...</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує тільки дві речі, що залишилось зробити. Перше, ця версія <code>Rational</code> міксує трейт  <code>Ordered</code>. На відміну від трейтів, що ви бачили дотепер, <code>Ordered</code> вимагає від вас вказати <em>параметр типу</em>, коли ви міксуєте його. Параметри типів не обговорюються в деталях до Глави 19, але поки все що вам треба знати, це що коли ви міксуєте клас з <code>Ordered</code>, насправді ви міксуєте <code>Ordered[C]</code>, де <code>C</code> є класом, елементи якого ми порівнюємо. В цьому випадку <code>Rational</code> міксується з <code>Ordered[Rational]</code>.</p></div>
<div class="paragraph"><p>Друга річ, що вам треба зрбити, це визначити метод <code>compare</code> для порівняння двох об'єктів. Цей метод буде порівнювати отримувача, <code>this</code>, з об'єктом, переданим як аргумент до метода. Він має повертати ціле число, що буде нуль, якщо об'єкти однакові, від'ємне, якщо отримувач менший за аргумент, та додатнє, якщо отримувач більший за аргумент.</p></div>
<div class="paragraph"><p>В цьому випадку, метод порівняння в <code>Rational</code> використовує формулу, базовану на конвертації дрібу до загального займенника, та потім віднімання отриманих чисельників. Маючи цей міксін та визначення <code>compare</code>, тепер клас <code>Rational</code> має всі чотири методи порівняння:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">half</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">half</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">third</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">third</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">half</span> <span class="o">&lt;</span> <span class="n">third</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">half</span> <span class="o">&gt;</span> <span class="n">third</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожного разу, коли ви реалізуєте клас, що впорядкований згідно деякого порівняння, ви маєте міксувати його з трейтом <code>Ordered</code>. Якщо ви зробите це, ви запровадите користувачів класа багатим набором методів порівняння.</p></div>
<div class="paragraph"><p>Зважайте, що трейт <code>Ordered</code> не визначає метод <code>equals</code> за вас, оскільки він не може цього зробити. Проблема в тому, що реалізація <code>equals</code> в термінах <code>compare</code> вимагає перевірки типу переданого об'єкту, та завдяки затиранню типів, сам по собі <code>Ordered</code> не може зробити цю перевірку. Таким чином, вам треба самому визначити <code>equals</code>, навіть якщо ви наслідуєте <code>Ordered</code>. Ви знайдете як це робити в Главі 30.</p></div>
<div class="paragraph"><p>Повний трейт <code>Ordered</code>, мінус коментарі та дещо для сумісності, виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>

  <span class="k">def</span> <span class="o">&lt;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&gt;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&lt;=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&gt;=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Не дуже турбуйтесь щодо <code>T</code> та <code>[T]</code>. Тут <code>T</code> є параметром типу, як описано в деталях в Главі 19. Для розуміння трейту <code>Ordered</code> просто думайте про нього, як про "той самий тип, що і отримувач". Потім ви можете бачити, що цей трейт визначає один абстрактний метод, <code>compare</code>, що, як очікується, буде порівнювати отримувач (<code>this</code>) з іншим об'єктом того самого типу, що і отримувач (<code>that</code>). Маючи цей метод, <code>Ordered</code> може провадити суцільні визначення для <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> та <code>&gt;=</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_5____">12.5 Трейти як накладувані модифікації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили одне головне затосування трейтів: перетворення тонких інтерфейсів в багаті. Тепер ми звернемось до другого головного застосування: провадити накладувані модифікації для класів. Трейти дозволяють <em>модифікувати</em> методи класів, і вони роблять це в такий спосіб, що дозволяє вам накладати ці модифікації одне на одне.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо накладання модифікацій для церги з цілих чисел. Черга буде мати дві операції: <code>put</code>, що покладає цілі в чергу, та <code>get</code>, що вибирає їх звідси. Черги побудовані як перший-увійшов перший-вийшов, так що <code>get</code> повинен повертати цілі в тому ж порядку, в якому вони були покладені <code>put</code> в чергу.</p></div>
<div class="paragraph"><p>Маючи клас, що реалізує таку чергу, ви можете визначити трейти для виконання модифікацій, як такі:</p></div>
<div class="ulist"><ul>
<li>
<p>
Doubling: подвоює всі цілі, що поставлені в чергу
</p>
</li>
<li>
<p>
Incrementing: збільшує всі цілі, що поставлені в чергу
</p>
</li>
<li>
<p>
Filtering: відфільтровує від'ємні цілі з черги
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ці три трейти представляють модифікації, оскільки вони модифікують поведінку класу підлеглої черги, скоріше, ніж самому визначати повний клас черги. Ці три також можна накладувати один на одний. Ви можете обрати любі з ціх трьох, зміксувати їх в клас, та отримати новий клас, який матиме всі модифікації, що ви обрали.</p></div>
<div class="paragraph"><p>Абстрактний клас <code>IntQueue</code> показаний на Лістингу 12.6. <code>IntQueue</code> має метод <code>put</code>, що додає нові цілі до черги, та метод <code>get</code>, що видлаяє та повертає їх. Базова реалізація <code>IntQueue</code>, що використовує <code>ArrayBuffer</code>, показана в Лістингу 12.7.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.6 - Абстрактний клас <code>IntQueue</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">class</span> <span class="nc">BasicIntQueue</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span> <span class="k">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.7 - <code>BasicIntQueue</code> реалізований з допомогою <code>ArrayBuffer</code>.</p></div>
<div class="paragraph"><p>Клас <code>BasicIntQueue</code> має приватне поле, що містить буферний масив. Метод <code>get</code> видаляє входження з одного кінця буфера, тоді як метод <code>put</code> додаєж елементи з іншого кінця. Ось як ця реалізація виглядає, коли ви використовуєте її:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="o">=</span> <span class="nc">BasicIntQueue</span><span class="k">@</span><span class="mi">23164256</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Доки все добре. Тепер поглянемо на використання трейтів для модифікації цієї поведінки. Лістинг 12.8 показує трейт, що подвоює цілі, по мірі того, як воні покладаються в чергу. Трейт <code>Doubling</code> має дві цікаві речі, що відбуваються. Перша це те, що він декларує суперклас <code>IntQueue</code>. Ця декларація означає, що трейт може бути міксований в клас, що також розширює <code>IntQueue</code>. Таким чином, ви можете міксувати <code>Doubling</code> в <code>BasicIntQueue</code>, але не в <code>Rational</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Doubling</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.8 - Трейт накладуваної модифікації <code>Doubling</code>.</p></div>
<div class="paragraph"><p>Друга цікава річ в тому, що трейт має супер виклик на методі, що визначений як абстрактний. Такі виклики нелегальні для звичайних класів, оскільки вони напевне будуть схиблювати під час виконання. Однак для трейта такий виклик насправді може бути успішним. Оскільки супер виклики в трейті динамічно зв'язані, супер виклик в трейті <code>Doubling</code> буде робити до тих пір, доки трейт міксований після іншого трейта або класа, що надає суцільне визначення методу.</p></div>
<div class="paragraph"><p>Цей механізм часто потрібний для трейтів, коли реалізуються накладувані модифікації. Щоб сказати компілятору, що ви робите це навмисно, ви маєте позначити такі методи як <code>abstract override</code>. Ця комбінація модифікаторів дозволена тільки для членів трейтів, не класів, і це означає, що трейт має бути зміксований в деякий клас, що має суцільне визначення розглядуваного метода.</p></div>
<div class="paragraph"><p>З таким простим трейтом можливі багато речей! Ось як виглядає використання цього трейта:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyQueue</span> <span class="k">extends</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">MyQueue</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MyQueue</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">MyQueue</span> <span class="o">=</span> <span class="nc">MyQueue</span><span class="k">@</span><span class="mi">44</span><span class="n">bbf788</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому рядку цієї сессії інтерпретатора ми визначаємо клас <code>MyQueue</code>,що розширює <code>BasicIntQueueand</code> з міксованим <code>Doubling</code>. Потім ми покладаємо <code>10</code> в чергу, але оскільки був доміксований <code>Doubling</code>, <code>10</code> було подвоєне. Коли ви отримаєте ціле з черги, це буде 20.</p></div>
<div class="paragraph"><p>Зауважте, що <code>MyQueue</code> не визначає новий код. Він просто ідентифікує клас та міксує трейт. В цій ситуації ви можете просто надати <code>BasicIntQueue with Doubling</code> напряму до <code>new</code>, замість визначення іменованого класу. Це буде виглядати як показано в Лістингу 12.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Doubling</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">141</span><span class="n">f05bf</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.9 - Міксування трейту при створенні екземпляру за допомогою <code>new</code>.</p></div>
<div class="paragraph"><p>Щоб побачити, як накладати модифікації, нам треба визначити інша два трейта модифікації, <code>Incrementing</code> та <code>Filtering</code>. Реалізації ціх трейтів показані в Лістингу 12.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Incrementing</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Filtering</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.10 - Накладувані модифікації в вигляді трейтів <code>Incrementing</code> та <code>Filtering</code>.</p></div>
<div class="paragraph"><p>Маючи ці модифікації ви можете тепер обирати, які саме ви бажаєте застосувати для певної черги. Наприклад, ось черга, що одначасно фільтрує від'ємні числа та додає одиницю до всіх чисел, які вона містить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">BasicIntQueue</span>
<span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Filtering</span><span class="o">)</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Incrementing</span> <span class="kt">with</span> <span class="kt">Filtering...</span>

<span class="kt">scala&gt;</span> <span class="kt">queue.put</span><span class="o">(</span><span class="kt">-</span><span class="err">1</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Порядок міксінів важливий.<span class="footnote"><br />[Коли трейт заміксований в клас, ви можете альтернативно називати його міксін.]<br /></span> Точні правила надаються в наступному розділі, але грубо кажучи, трейти, що стоять більш зправа, набувають чинності перші. Коли ви викликаєте метод або клас на міксіні, метод в трейті, що правіший, буде викликаний першим. Якщо метод визиває <code>super</code>, він викликає наступний трейт, що лівіше, і так далі. В попередньому прикладі <code>Filtering</code> <code>put</code> викликається першим, так що він для початку видаляє від'ємні цілі. <code>Incrementing</code> <code>put</code> викликається другим, так що він додає одиницю до цілих, що залишились.</p></div>
<div class="paragraph"><p>Якщо ви вмінити порядок, цілі спочатку будуть збільшені, та потім цілі, що все ще від'ємні, будуть відкинуті:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">BasicIntQueue</span>
           <span class="k">with</span> <span class="nc">Filtering</span> <span class="k">with</span> <span class="nc">Incrementing</span><span class="o">)</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Filtering</span> <span class="kt">with</span> <span class="kt">Incrementing...</span>

<span class="kt">scala&gt;</span> <span class="kt">queue.put</span><span class="o">(</span><span class="kt">-</span><span class="err">1</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Загалом, код, що написаний в такому стилі дає вам добрі можливості щодо гнучкості. Ви можете визначити шістнадцять різних класів, міксуючи ці три трейти в різних комбінаціях на порядках. Це багато гнучкості для невеликого обсягу коду, так що ви маєте тримати очі відкритими в пошуках можливостей втілити в коді накладувані модифікації.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_6____">12.6 Чому не множинне наслідування?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Трейти є шляхом наслідувати від багатьох класо-подібних конструкцій, але вони відрізняються в важливий спосіб від множинного наслідування, що присутнє в інших мовах. Одна різниця є особливо важливою: інтерпретація <code>super</code>. З множинним наслідуванням метод, що викликається через <code>super</code> може бути викликаний саме там, де відбувається виклик. З трейтами викликаний метод визначається через лінеарізацію класів та трейтів, зміксованих в клас. Ця різниця дозволяє накладання модифікацій, описану в попередньому розділі.</p></div>
<div class="paragraph"><p>Перед тим, як поглянути на лінеарізацію, ми витратимо момент, та розглянемо, як накладати модифікації в мові з традиційним множинним наслідуванням. Уявімо наступний код, але на цей раз інтерпретований як множинне наслідування замість міксування трейтів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Множинне наслідування як експерімент</span>
<span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="c1">// який put має бути викликаний?</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше питання: який метод <code>put</code> буде викликаний, коли робиться цей виклик? Можливо, правило буде таке, що останній суперклас перемагає, в якому випадку буде викликаний <code>Doubling</code>. <code>Doubling</code> подвоїть свій аргумент, та викличе <code>super.put</code>, і це вже буде кінець. Інкрементація не відбудеться! Так само, якщо правило буде таке, що перший суперклас перемагає, отримана черга буде збільшувати цілі, але не подвоювати їх. Так що жодний порядок не буде робити.</p></div>
<div class="paragraph"><p>Ви можете також прокрутити таку можливість: дозволити програмістам вказати, який метод суперкласу вони мають на увазі, коли кажуть <code>super</code>. Наприклад, уявімо наступний Scala-подібний код, в якому <code>super</code> явно викликається на обох, <code>Incrementing</code> та <code>Doubling</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Експерименти з множинним наслідуванням</span>
<span class="k">trait</span> <span class="nc">MyQueue</span> <span class="k">extends</span> <span class="nc">BasicIntQueue</span>
    <span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Doubling</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Incrementing</span><span class="o">.</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// (Несправжня Scala)</span>
    <span class="nc">Doubling</span><span class="o">.</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей підхід дає нам нові проблеми (балакучість цього підходу є найменьшою з його проблем). Що відбудеться, це те, що метод <code>put</code> базового класу буде викликано двічі, перший раз для збільшеного значення, та ще раз для подвоєного значення, але жодного разу для збільшеного та подвоєного значення.</p></div>
<div class="paragraph"><p>Просто не існує гарного рішення цієї проблеми з використанням множинного наслідування. Вам доведеться переробити код в інший спосіб. Для контрасту, рішення з трейтами в Scala є прямолінійним. Ви просто міксуєте <code>Incrementing</code> та <code>Doubling</code>, та спеціальне трактування super в трейтах Scala робить всю іншу роботу. Тут дещо чітко відрізняється від традиційного множинного наслідування, але що? Як ми натякали перед цім, відповідь є лінеарізація. Коли ми створюємо примірник класу за допомогою <code>new</code>, Scala бере клас та всі його унаслідувані класи та трейти, та шакує їх в єдиний, лінійний порядок. Тоді,якщо ви викликаєте <code>super</code> в одному з ціх класів, викликаний метод є наступним в черзі. Якщо всі методи, крім останнього, викликають <code>super</code>, чистим результатом буде накладання поведінки.</p></div>
<div class="paragraph"><p>Точний порядок лінеарізації описаний в специфікації мови. Він трохи заскладний, але головна річ, що вам треба знати, це що при любій лінеаризації клас клас завжди лінеаризується перед усіма своїми суперкласами та доміксованими трейтами. Таким чином, коли ви пишете метод, що викликає <code>super</code>, цей метод напевне модифікує поведінку суперкласів і зміксованих трейтів, і іншого шляху немає.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Залишок цього розділу описує деталі лінеаризації. Ви можете безпечно пропустити залишок цього розділу, якщо ви не зацікавлені розуміти ці деталі просто зараз.</td>
</tr></table>
</div>
<div class="paragraph"><p>Головні властивості лінеаризації Scala проілючтровані на наступному прикладі: скажімо, ви маєте клас <code>Cat</code>, що наслідує від суперкласа <code>Animal</code>, та двох супертрейтів, <code>Furry</code> та <code>FourLegged</code>. <code>FourLegged</code>, в свою чергу, розширює трейт <code>HasLegs</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">Furry</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">HasLegs</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">FourLegged</span> <span class="k">extends</span> <span class="nc">HasLegs</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Furry</span> <span class="k">with</span> <span class="nc">FourLegged</span>
</pre></div></div></div>
<div class="paragraph"><p>Ієрархія наслідування та лінеаризація класу Cat показана на Малюнку 12.1. Наслідування використовує традиційну UML нотацію:<span class="footnote"><br />[Rumbaugh, et. al., The Unified Modeling Language Reference Manual. [Rum04]]<br /></span> стрілки з білими трикутними наконечниками означають наслідування, стрілки вказують на супертипи. Стрілки з темнішими, не трикутними наконечниками позначають лінеаризацію. Темніші стрілки вказують в напрямку, в якому будуть розрішуватись виклики <code>super</code>.</p></div>
<div class="paragraph"><p>Малюнок 12.1 - Ієрархія наслідування і лінеарізація класу Cat.</p></div>
<div class="paragraph"><p>Лінеаризація <code>Cat</code> обчислюється яз кінця в начало наступним чином. Остання частина лінеаризації <code>Cat</code> є лінеаризація його суперкласу <code>Animal</code>. Ця лінеаризація копіюється без всяких змін. (Лінеаризація кожного з ціх типів показана в Таблиці 12.) Оскільки  <code>Animal</code> явно не розширює суперклас, або не міксує якийсь трейт, він по замовчанню розширює <code>AnyRef</code>, що розширює <code>Any</code>. Таким чином лінеаризація <code>Animal</code> виглядає так:</p></div>
<div class="paragraph"><p>Друга з кінця частина є лінеаризація першого міксіна, трейта <code>Furry</code>, але всі класи, що вже знаходяться в лінеаризації <code>Animal</code> тепер відкидаються, так що кожний клас з'являється тільки один раз в лінеаризації <code>Cat</code>. Результат такий:</p></div>
<div class="paragraph"><p>За цім слідує лінеаризація <code>FourLegged</code>, де знову любі класи, що вже були скопійовані в лінеаризації суперкласів або першого міксіну відкидаються:</p></div>
<div class="paragraph"><p>Нарешті, перший клас в лінеаризації <code>Cat</code> є сам <code>Cat</code>:</p></div>
<div class="paragraph"><p>Коли кожний з ціх класів та трейтів викликає метод через <code>super</code>, викликається реалізація, що буде першою реалізацією зправа в лінеаризації.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 12.1 Лінеарізація типів в ієрархії Cat</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Тип </th>
<th align="center" valign="top"> Лінеаризація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right" valign="top"><p class="table">Animal</p></td>
<td align="left" valign="top"><p class="table">Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">Furry</p></td>
<td align="left" valign="top"><p class="table">Furry, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">FourLegged</p></td>
<td align="left" valign="top"><p class="table">FourLegged, HasLegs, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">HasLegs</p></td>
<td align="left" valign="top"><p class="table">HasLegs, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">Cat</p></td>
<td align="left" valign="top"><p class="table">Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_12_7___">12.7 Чи використовувати трейти?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли ви реалізуєте повторно використовувану колекцію поведінок, ви повинні прийняти рішення, чи ви бажаєте використати трейт або абстрактний клас. Немає надійного правила, але цей розділ містить декілька настанов, які треба зважити.</p></div>
<div class="paragraph"><p><em>Якщо поведінка не буде використовуватись повторно</em>, тоді робіть суцільний клас. Кінець кінцем це не повторно використовувана поведінка.</p></div>
<div class="paragraph"><p>_Якщо вона може бути використана в декількох непов'язаних класах_, зробіть трейт. Тільки трейти можуть бути зміксовані в різні частини ієрархії класів.</p></div>
<div class="paragraph"><p><em>Якщо ви бажаєте наслідувати від поведінки в Java коді</em>, використовуйте абстрактний клас. Оскільки трейти з кодом не мають близького Java аналогу, як правило незручно наслідувати від трейта в Java класі. В той же час, наслідувати від Scala класу є точно таким же, як наслідування від Java класу. Як одне виключення, трейт Scala з тільки одними абстрактними членами транслюється напряму в Java інтерфейс, так що ви можете вільно визначати такі трейти, навіть якщо очікуєте, що Java код буде наслідувати від них. Дивіться Розділ 31 щодо додаткової інформації по роботі з Java та Scala разом.</p></div>
<div class="paragraph"><p><em>Якщо ви плануєте розповсюджувати це в компільованій формі</em>, та ви очікуєте, що зовнішні групи будуть писати класи з наслідуванням від вашого коду, ви можете трохи ухилитись, використовуючи абстрактний клас. Проблема в тому, що коли трейт отримує або втрачає член, любі класи, що наслідують від нього, мають бути перекомпільовані, навіть якщо вони не змінились. Якщо зовнішні клієнти будуть тільки викликати поведінку, замість наслідувати від неї, тоді використання трейтів є гарним.</p></div>
<div class="paragraph"><p><em>Якщо ви все ще не знаєте</em>, навіть після розляду питань вище, тоді починайте створивши трейт. Ви завжди можете поміняти це пізніше, і, загалом, трейт тримає більше опцій відкритими.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_8_">12.8 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава показала вам як роблять трейти, та як використовувати їх в декількох загальних ідіомах. Ви побачили, як трейти подібні до множинного наслідування. Але, оскілкьи трейти інтерпретують <code>super</code> з використанням лінеаризації, вони одночасно уникають деяких складнощей традиційного множинного наслідування, та дозволяють вам накладати поведінку. Ви також бачили трейт <code>Ordered</code>, та навчились, як писати ваші власні збагачуючі трейти.</p></div>
<div class="paragraph"><p>Тепер, коли ви побачили всі ці грані, має сенс відступити назад, та зробити ще один погляд на трейти як на ціле. Трейти не тільки просто підтримують ідіоми, описані в цій главі; вони є фундаментальною одиницею коду, що повторно використовується через інтерфейс. Ось чому багато досвідчених Scala програмістів починають з трейтів, коли вони знаходяться на ранішній стадії реалізації. Кожний трейт може містити меньше ніж цілу концепцію, а тільки фрагмент концепції. По мірі застигання розробки фрагменти можуть бути скомбіновані в більш цілісні концеації через міксування трейтів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-16 13:44:32 EET
</div>
</div>
</body>
</html>
