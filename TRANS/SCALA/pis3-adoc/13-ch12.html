<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__12">Глава 12</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_">Трейти</h1>
<div class="paragraph"><p>Traits are a fundamental unit of code reuse in Scala. A trait encapsulates method and field definitions, which can then be reused by mixing them into classes. Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits. This chapter shows you how traits work and shows two of the most common ways they are useful: widening thin interfaces to rich ones, and defining stackable modifications. It also shows how to use the Ordered trait and compares traits to the multiple inheritance of other languages.</p></div>
<div class="sect1">
<h2 id="_12_1___">12.1 Як роблять трейти</h2>
<div class="sectionbody">
<div class="paragraph"><p>A trait definition looks just like a class definition except that it uses the keyword trait. An example is shown in Listing 12.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;I consume memory, therefore I am!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.1 - Визначення трейта <code>Philosophical</code>.</p></div>
<div class="paragraph"><p>This trait is named Philosophical. It does not declare a superclass, so like a class, it has the default superclass of AnyRef. It defines one method, named philosophize, which is concrete. It&#8217;s a simple trait, just enough to show how traits work.</p></div>
<div class="paragraph"><p>Once a trait is defined, it can be mixed in to a class using either the extends or with keywords.Scala programmers "mix in" traits rather than inherit from them, because mixing in a trait has important differences from the multiple inheritance found in many other languages. This issue is discussed in Section 12.6. For example, Listing 12.2 shows a class that mixes in thePhilosophical trait using extends:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.2 - Міксування трейту використовуючи <code>extends</code>.</p></div>
<div class="paragraph"><p>You can use the extends keyword to mix in a trait; in that case you implicitly inherit the trait&#8217;s superclass. For instance, in Listing 12.2, class Frog subclasses AnyRef (the superclass ofPhilosophical) and mixes in Philosophical. Methods inherited from a trait can be used just like methods inherited from a superclass. Here&#8217;s an example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">frog</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Frog</span>
<span class="n">frog</span><span class="k">:</span> <span class="kt">Frog</span> <span class="o">=</span> <span class="n">green</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">frog</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="n">I</span> <span class="n">consume</span> <span class="n">memory</span><span class="o">,</span> <span class="n">therefore</span> <span class="n">I</span> <span class="n">am</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>A trait also defines a type. Here&#8217;s an example in which Philosophical is used as a type:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">phil</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">frog</span>
<span class="n">phil</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">green</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">phil</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="n">I</span> <span class="n">consume</span> <span class="n">memory</span><span class="o">,</span> <span class="n">therefore</span> <span class="n">I</span> <span class="n">am</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>The type of phil is Philosophical, a trait. Thus, variable phil could have been initialized with any object whose class mixes in Philosophical.</p></div>
<div class="paragraph"><p>If you wish to mix a trait into a class that explicitly extends a superclass, you use extends to indicate the superclass and with to mix in the trait. Listing 12.3 shows an example. If you want to mix in multiple traits, you add more with clauses. For example, given a trait HasLegs, you could mix both Philosophical and HasLegs into Frog as shown in Listing 12.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Listing 12.3 - Mixing in a trait using with.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">HasLegs</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="k">with</span> <span class="nc">HasLegs</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Listing 12.4 - Mixing in multiple traits.</p></div>
<div class="paragraph"><p>In the examples you&#8217;ve seen so far, class Frog has inherited an implementation of philosophizefrom trait Philosophical. Alternatively, Frog could override philosophize. The syntax looks the same as overriding a method declared in a superclass. Here&#8217;s an example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>

<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">&quot;green&quot;</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;It ain&#39;t easy being &quot;</span> <span class="o">+</span> <span class="n">toString</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Because this new definition of Frog still mixes in trait Philosophical, you can still use it from a variable of that type. But because Frog overrides Philosophical&#8217;s implementation of philosophize, you&#8217;ll get a new behavior when you call it:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">phrog</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Frog</span>
<span class="n">phrog</span><span class="k">:</span> <span class="kt">Philosophical</span> <span class="o">=</span> <span class="n">greenscala</span><span class="o">&gt;</span> <span class="n">phrog</span><span class="o">.</span><span class="n">philosophize</span><span class="o">()</span>
<span class="nc">It</span> <span class="n">ain</span><span class=" -Symbol">&#39;t</span> <span class="n">easy</span> <span class="n">being</span> <span class="n">green</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p>At this point you might philosophize that traits are like Java interfaces with concrete methods, but they can actually do much more. Traits can, for example, declare fields and maintain state. In fact, you can do anything in a trait definition that you can do in a class definition, and the syntax looks exactly the same, with only two exceptions.</p></div>
<div class="paragraph"><p>First, a trait cannot have any "class" parameters (i.e., parameters passed to the primary constructor of a class). In other words, although you could define a class like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The following attempt to define a trait would not compile:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">NoPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="c1">// Does not compile</span>
</pre></div></div></div>
<div class="paragraph"><p>You&#8217;ll find out in Section 20.5 how to work around this restriction.</p></div>
<div class="paragraph"><p>The other difference between classes and traits is that whereas in classes, super calls are statically bound, in traits, they are dynamically bound. If you write "super.toString" in a class, you know exactly which method implementation will be invoked. When you write the same thing in a trait, however, the method implementation to invoke for the super call is undefined when you define the trait. Rather, the implementation to invoke will be determined anew each time the trait is mixed into a concrete class. This curious behavior of super is key to allowing traits to work as stackable modifications, which will be described in Section 12.5. The rules for resolving super calls will be given in Section 12.6.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_2_____">12.2 Тонкі інтерфейси проти багатих інтерфейсів</h2>
<div class="sectionbody">
<div class="paragraph"><p>One major use of traits is to automatically add methods to a class in terms of methods the class already has. That is, traits can enrich a thin interface, making it into a rich interface.</p></div>
<div class="paragraph"><p>Thin versus rich interfaces represents a commonly faced trade-off in object-oriented design. The trade- off is between the implementers and the clients of an interface. A rich interface has many methods, which make it convenient for the caller. Clients can pick a method that exactly matches the functionality they need. A thin interface, on the other hand, has fewer methods, and thus is easier on the implementers. Clients calling into a thin interface, however, have to write more code. Given the smaller selection of methods to call, they may have to choose a less than perfect match for their needs and write extra code to use it.</p></div>
<div class="paragraph"><p>Java&#8217;s interfaces are more often thin than rich. For example, interface CharSequence, which was introduced in Java 1.4, is a thin interface common to all string-like classes that hold a sequence of characters. Here&#8217;s its definition when seen as a Scala trait:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">CharSequence</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">charAt</span><span class="o">(</span><span class="n">index</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Char</span>
  <span class="k">def</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">subSequence</span><span class="o">(</span><span class="n">start</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">end</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">CharSequence</span>
  <span class="k">def</span> <span class="n">toString</span><span class="o">()</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Although most of the dozens of methods in class String would apply to any CharSequence, Java&#8217;sCharSequence interface declares only four methods. Had CharSequence instead included the fullString interface, it would have placed a large burden on implementers of CharSequence. Every programmer that implemented CharSequence in Java would have had to define dozens more methods. Because Scala traits can contain concrete methods, they make rich interfaces far more convenient.</p></div>
<div class="paragraph"><p>Adding a concrete method to a trait tilts the thin-rich trade-off heavily towards rich interfaces. Unlike in Java, adding a concrete method to a Scala trait is a one-time effort. You only need to implement the method once, in the trait itself, instead of needing to reimplement it for every class that mixes in the trait. Thus, rich interfaces are less work to provide in Scala than in a language without traits.</p></div>
<div class="paragraph"><p>To enrich an interface using traits, simply define a trait with a small number of abstract methods—the thin part of the trait&#8217;s interface—and a potentially large number of concrete methods, all implemented in terms of the abstract methods. Then you can mix the enrichment trait into a class, implement the thin portion of the interface, and end up with a class that has all of the rich interface available.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_3____">12.3 Приклад: прямокутні об'єкти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Graphics libraries often have many different classes that represent something rectangular. Some examples are windows, bitmap images, and regions selected with a mouse. To make these rectangular objects convenient to use, it is nice if the library provides geometric queries, such as width, height, left, right, topLeft, and so on. However, many such methods exist that would be nice to have, so it can be a large burden on library writers to provide all of them for all rectangular objects in a Java library. If such a library were written in Scala, by contrast, the library writer could use traits to easily supply all of these convenience methods on all the classes they like.</p></div>
<div class="paragraph"><p>To see how, first imagine what the code would look like without traits. There would be some basic geometric classes like Point and Rectangle:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">val</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span><span class="o">,</span> <span class="k">val</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>This Rectangle class takes two points in its primary constructor: the coordinates of the top-left and bottom-right corners. It then implements many convenience methods, such as left, right, and width, by performing simple calculations on these two points.</p></div>
<div class="paragraph"><p>Another class a graphics library might have is a 2-D graphical widget:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Pointdef</span>
  <span class="n">вуа</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Notice that the definitions of left, right, and width are exactly the same in the two classes. They will also be the same, aside from minor variations, in any other classes for rectangular objects.</p></div>
<div class="paragraph"><p>This repetition can be eliminated with an enrichment trait. The trait will have two abstract methods: one that returns the top-left coordinate of the object, and another that returns the bottom-right coordinate. It can then supply concrete implementations of all the other geometric queries. Listing 12.5 shows what it will look like:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Rectangular</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="n">topLeft</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="n">bottomRight</span><span class="o">.</span><span class="n">x</span>
  <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span>
<span class="c1">// та більше інших графічних методів...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.5 - Визначення покращеного трейта.</p></div>
<div class="paragraph"><p>Class Component can mix in this trait to get all the geometric methods provided by Rectangular:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Component</span> <span class="k">extends</span> <span class="nc">Rectangular</span> <span class="o">{</span>
<span class="c1">// інші методи...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Similarly, Rectangle itself can mix in the trait:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">val</span> <span class="n">topLeft</span><span class="k">:</span> <span class="kt">Point</span><span class="o">,</span> <span class="k">val</span> <span class="n">bottomRight</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">Rectangular</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// інші методи...</span>
</pre></div></div></div>
<div class="paragraph"><p>Given these definitions, you can create a Rectangle and call geometric methods such as widthand left on it:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rect</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span>
           <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">))</span>
<span class="n">rect</span><span class="k">:</span> <span class="kt">Rectangle</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="k">@</span><span class="mi">5</span><span class="n">f5da68c</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">left</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">right</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rect</span><span class="o">.</span><span class="n">width</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">9</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_4__">12.4 Впорядкований трейт</h2>
<div class="sectionbody">
<div class="paragraph"><p>Comparison is another domain where a rich interface is convenient. Whenever you compare two objects that are ordered, it is convenient if you use a single method call to ask about the precise comparison you want. If you want "is less than," you would like to call &lt;, and if you want "is less than or equal," you would like to call &#8656;. With a thin comparison interface, you might just have the &lt; method, and you would sometimes have to write things like "(x &lt; y) || (x == y)". A rich interface would provide you with all of the usual comparison operators, thus allowing you to directly write things like "x &#8656; y".</p></div>
<div class="paragraph"><p>Before looking at Ordered, imagine what you might do without it. Suppose you took the Rationalclass from Chapter 6 and added comparison operations to it. You would end up with something like this:<span class="footnote"><br />[This example is based on the Rational class shown in Listing 6.5 here, with equals, hashCode, and modifications to ensure a positive denom added.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
<span class="c1">// ...</span>
  <span class="k">def</span> <span class="o">&lt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span>
  <span class="k">def</span> <span class="o">&gt;</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="n">that</span> <span class="o">&lt;</span> <span class="k">this</span>
  <span class="k">def</span> <span class="o">&lt;=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">this</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">that</span><span class="o">)</span>
  <span class="k">def</span> <span class="o">&gt;=</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">this</span> <span class="o">&gt;</span> <span class="n">that</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">that</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>This class defines four comparison operators (&lt;, &gt;, &#8656;, and &gt;=), and it&#8217;s a classic demonstration of the costs of defining a rich interface. First, notice that three of the comparison operators are defined in terms of the first one. For example, &gt; is defined as the reverse of &lt;, and &#8656; is defined as literally "less than or equal." Next, notice that all three of these methods would be the same for any other class that is comparable. There is nothing special about rational numbers regarding &#8656;. In a comparison context, &#8656; is always used to mean "less than or equals." Overall, there is quite a lot of boilerplate code in this class which would be the same in any other class that implements comparison operations.</p></div>
<div class="paragraph"><p>This problem is so common that Scala provides a trait to help with it. The trait is calledOrdered. To use it, you replace all of the individual comparison methods with a single comparemethod. The Ordered trait then defines &lt;, &gt;, &#8656;, and &gt;= for you in terms of this one method. Thus, trait Ordered allows you to enrich a class with comparison methods by implementing only one method, compare.</p></div>
<div class="paragraph"><p>Here is how it looks if you define comparison operations on Rational by using the Ordered trait:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span> <span class="o">{</span>
<span class="c1">// ...</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>There are just two things to do. First, this version of Rational mixes in the Ordered trait. Unlike the traits you have seen so far, Ordered requires you to specify a <em>параметр типу</em> when you mix it in. Type parameters are not discussed in detail until Chapter 19, but for now all you need to know is that whenyou mix in Ordered, you must actually mix in Ordered[C], where C is the class whose elements you compare. In this case, Rational mixes in Ordered[Rational].</p></div>
<div class="paragraph"><p>The second thing you need to do is define a compare method for comparing two objects. This method should compare the receiver, this, with the object passed as an argument to the method. It should return an integer that is zero if the objects are the same, negative if receiver is less than the argument, and positive if the receiver is greater than the argument.</p></div>
<div class="paragraph"><p>In this case, the comparison method of Rational uses a formula based on converting the fractions to a common denominator and then subtracting the resulting numerators. Given this mixin and the definition of compare, class Rational now has all four comparison methods:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">half</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">half</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">third</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">third</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">half</span> <span class="o">&lt;</span> <span class="n">third</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">half</span> <span class="o">&gt;</span> <span class="n">third</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Any time you implement a class that is ordered by some comparison, you should consider mixing in the Ordered trait. If you do, you will provide the class&#8217;s users with a rich set of comparison methods.</p></div>
<div class="paragraph"><p>Beware that the Ordered trait does not define equals for you, because it is unable to do so. The problem is that implementing equals in terms of compare requires checking the type of the passed object, and because of type erasure, Ordered itself cannot do this test. Thus, you need to define equals yourself, even if you inherit Ordered. You&#8217;ll find out how to go about this inChapter 30.</p></div>
<div class="paragraph"><p>The complete Ordered trait, minus comments and compatibility cruft, is as follows:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>

  <span class="k">def</span> <span class="o">&lt;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&gt;(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&lt;=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="o">&gt;=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">(</span><span class="k">this</span> <span class="n">compare</span> <span class="n">that</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Do not worry much about the T&#8217;s and [T]'s. T here is a type parameter, as described in detail inChapter 19. For understanding the Ordered trait, just think of it as "the same type as the receiver". You can then see that this trait defines one abstract method, compare, which is expected to compare the receiver (this) against another object of the same type as the receiver (that). Given this one method, Ordered can then provide concrete definitions for &lt;, &gt;, &#8656;, and &gt;=.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_5____">12.5 Трейти як накладувані модифікації</h2>
<div class="sectionbody">
<div class="paragraph"><p>You have now seen one major use of traits: turning a thin interface into a rich one. Now we&#8217;ll turn to a second major use: providing stackable modifications to classes. Traits let <em>модифікувати</em> the methods of a class, and they do so in a way that allows you to stack those modifications with each other.</p></div>
<div class="paragraph"><p>As an example, consider stacking modifications to a queue of integers. The queue will have two operations: put, which places integers in the queue, and get, which takes them back out. Queues are first-in, first-out, so get should return the integers in the same order they were put in the queue.</p></div>
<div class="paragraph"><p>Given a class that implements such a queue, you could define traits to perform modifications such as these:</p></div>
<div class="ulist"><ul>
<li>
<p>
Doubling: double all integers that are put in the queue
</p>
</li>
<li>
<p>
Incrementing: increment all integers that are put in the queue
</p>
</li>
<li>
<p>
Filtering: filter out negative integers from a queue
</p>
</li>
</ul></div>
<div class="paragraph"><p>These three traits represent modifications, because they modify the behavior of an underlying queue class rather than defining a full queue class themselves. The three are alsostackable. You can select any of the three you like, mix them into a class, and obtain a new class that has all of the modifications you chose.</p></div>
<div class="paragraph"><p>An abstract IntQueue class is shown in Listing 12.6. IntQueue has a put method that adds new integers to the queue, and a get method that removes and returns them. A basic implementation of IntQueue that uses an ArrayBuffer is shown in Listing 12.7.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.6 - Абстрактний клас <code>IntQueue</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>

<span class="k">class</span> <span class="nc">BasicIntQueue</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">()</span> <span class="k">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.7 - <code>BasicIntQueue</code> реалізований з допомогою <code>ArrayBuffer</code>.</p></div>
<div class="paragraph"><p>Class BasicIntQueue has a private field holding an array buffer. The get method removes an entry from one end of the buffer, while the put method adds elements to the other end. Here&#8217;s how this implementation looks when you use it:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="o">=</span> <span class="nc">BasicIntQueue</span><span class="k">@</span><span class="mi">23164256</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>So far so good. Now take a look at using traits to modify this behavior. Listing 12.8 shows a trait that doubles integers as they are put in the queue. The Doubling trait has two funny things going on. The first is that it declares a superclass, IntQueue. This declaration means that the trait can only be mixed into a class that also extends IntQueue. Thus, you can mix Doubling intoBasicIntQueue, but not into Rational.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Doubling</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Listing 12.8 - The Doubling stackable modification trait.</p></div>
<div class="paragraph"><p>The second funny thing is that the trait has a super call on a method declared abstract. Such calls are illegal for normal classes because they will certainly fail at run time. For a trait, however, such a call can actually succeed. Since super calls in a trait are dynamically bound, the super call in trait Doubling will work so long as the trait is mixed in after another trait or class that gives a concrete definition to the method.</p></div>
<div class="paragraph"><p>This arrangement is frequently needed with traits that implement stackable modifications. To tell the compiler you are doing this on purpose, you must mark such methods as abstractoverride. This combination of modifiers is only allowed for members of traits, not classes, and it means that the trait must be mixed into some class that has a concrete definition of the method in question.</p></div>
<div class="paragraph"><p>There is a lot going on with such a simple trait, isn&#8217;t there! Here&#8217;s how it looks to use the trait:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">MyQueue</span> <span class="k">extends</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">defined</span> <span class="k">class</span> <span class="nc">MyQueue</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MyQueue</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">MyQueue</span> <span class="o">=</span> <span class="nc">MyQueue</span><span class="k">@</span><span class="mi">44</span><span class="n">bbf788</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>In the first line in this interpreter session, we define class MyQueue, which extends BasicIntQueueand mixes in Doubling. We then put a 10 in the queue, but because Doubling has been mixed in, the 10 is doubled. When we get an integer from the queue, it is a 20.</p></div>
<div class="paragraph"><p>Note that MyQueue defines no new code. It simply identifies a class and mixes in a trait. In this situation, you could supply "BasicIntQueue with Doubling" directly to new instead of defining a named class. It would look as shown in Listing 12.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Doubling</span> <span class="o">=</span> <span class="nc">$anon$1</span><span class="k">@</span><span class="mi">141</span><span class="n">f05bf</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Listing 12.9 - Mixing in a trait when instantiating with new.</p></div>
<div class="paragraph"><p>To see how to stack modifications, we need to define the other two modification traits,Incrementing and Filtering. Implementations of these traits are shown in Listing 12.10:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">Incrementing</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">Filtering</span> <span class="k">extends</span> <span class="nc">IntQueue</span> <span class="o">{</span>
  <span class="k">abstract</span> <span class="k">override</span> <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 12.10 - Stackable modification traits Incrementing and Filtering.</p></div>
<div class="paragraph"><p>Given these modifications, you can now pick and choose which ones you want for a particular queue. For example, here is a queue that both filters negative numbers and adds one to all numbers that it keeps:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">BasicIntQueue</span>
<span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Filtering</span><span class="o">)</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Incrementing</span> <span class="kt">with</span> <span class="kt">Filtering...</span>

<span class="kt">scala&gt;</span> <span class="kt">queue.put</span><span class="o">(</span><span class="kt">-</span><span class="err">1</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>The order of mixins is significant.<span class="footnote"><br />[Once a trait is mixed into a class, you can alternatively call it a mixin.]<br /></span> The precise rules are given in the following section, but, roughly speaking, traits further to the right take effect first. When you call a method on a class with mixins, the method in the trait furthest to the right is called first. If that method calls super, it invokes the method in the next trait to its left, and so on. In the previous example, Filtering&#8217;s put is invoked first, so it removes integers that were negative to begin with. Incrementing&#8217;s put is invoked second, so it adds one to those integers that remain.</p></div>
<div class="paragraph"><p>If you reverse the order, first integers will be incremented, and then the integers that are still negative will be discarded:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">BasicIntQueue</span>
           <span class="k">with</span> <span class="nc">Filtering</span> <span class="k">with</span> <span class="nc">Incrementing</span><span class="o">)</span>
<span class="n">queue</span><span class="k">:</span> <span class="kt">BasicIntQueue</span> <span class="kt">with</span> <span class="kt">Filtering</span> <span class="kt">with</span> <span class="kt">Incrementing...</span>

<span class="kt">scala&gt;</span> <span class="kt">queue.put</span><span class="o">(</span><span class="kt">-</span><span class="err">1</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Overall, code written in this style gives you a great deal of flexibility. You can define sixteen different classes by mixing in these three traits in different combinations and orders. That&#8217;s a lot of flexibility for a small amount of code, so you should keep your eyes open for opportunities to arrange code as stackable modifications.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_6____">12.6 Чому не множинне наслідування?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Traits are a way to inherit from multiple class-like constructs, but they differ in important ways from the multiple inheritance present in many languages. One difference is especially important: the interpretation of super. With multiple inheritance, the method called by a supercall can be determined right where the call appears. With traits, the method called is determined by a linearization of the classes and traits that are mixed into a class. This is the difference that enables the stacking of modifications described in the previous section.</p></div>
<div class="paragraph"><p>Before looking at linearization, take a moment to consider how to stack modifications in a language with traditional multiple inheritance. Imagine the following code, but this time interpreted as multiple inheritance instead of trait mixin:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Множинне наслідування як експерімент</span>
<span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Doubling</span>
<span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span> <span class="c1">// який put має бути викликаний?</span>
</pre></div></div></div>
<div class="paragraph"><p>The first question is: Which put method would get invoked by this call? Perhaps the rule would be that the last superclass wins, in which case Doubling would get called. Doubling would double its argument and call super.put, and that would be it. No incrementing would happen! Likewise, if the rule were that the first superclass wins, the resulting queue would increment integers but not double them. Thus neither ordering would work.</p></div>
<div class="paragraph"><p>You might also entertain the possibility of allowing programmers to identify exactly which superclass method they want when they say super. For example, imagine the following Scala-like code, in which super appears to be explicitly invoked on both Incrementing and Doubling:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Multiple inheritance thought experiment</span>
<span class="k">trait</span> <span class="nc">MyQueue</span> <span class="k">extends</span> <span class="nc">BasicIntQueue</span>
    <span class="k">with</span> <span class="nc">Incrementing</span> <span class="k">with</span> <span class="nc">Doubling</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="nc">Incrementing</span><span class="o">.</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="c1">// (Несправжня Scala)</span>
    <span class="nc">Doubling</span><span class="o">.</span><span class="k">super</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>This approach would give us new problems (with the verbosity of this attempt being the least of its problems). What would happen is that the base class&#8217;s put method would get calledtwice—once with an incremented value and once with a doubled value, but neither time with an incremented, doubled value.</p></div>
<div class="paragraph"><p>There is simply no good solution to this problem using multiple inheritance. You would have to back up in your design and factor the code differently. By contrast, the traits solution in Scala is straightforward. You simply mix in Incrementing and Doubling, and Scala&#8217;s special treatment of super in traits makes it all work out. Something is clearly different here from traditional multiple inheritance, but what? As hinted previously, the answer is linearization. When you instantiate a class with new, Scala takes the class, and all of its inherited classes and traits, and puts them in a single, linear order. Then, whenever you call super inside one of those classes, the invoked method is the next one up the chain. If all of the methods but the last call super, the net result is stackable behavior.</p></div>
<div class="paragraph"><p>The precise order of the linearization is described in the language specification. It is a little bit complicated, but the main thing you need to know is that, in any linearization, a class is always linearized in front of all its superclasses and mixed in traits. Thus, when you write a method that calls super, that method is definitely modifying the behavior of the superclasses and mixed in traits, not the other way around.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">The remainder of this section describes the details of linearization. You can safely skip the rest of this section if you are not interested in understanding those details right now.</td>
</tr></table>
</div>
<div class="paragraph"><p>The main properties of Scala&#8217;s linearization are illustrated by the following example: Say you have a class Cat, which inherits from a superclass Animal and two supertraits Furry andFourLegged. FourLegged extends in turn another trait HasLegs:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">Furry</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">HasLegs</span> <span class="k">extends</span> <span class="nc">Animal</span>
<span class="k">trait</span> <span class="nc">FourLegged</span> <span class="k">extends</span> <span class="nc">HasLegs</span>
<span class="k">class</span> <span class="nc">Cat</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Furry</span> <span class="k">with</span> <span class="nc">FourLegged</span>
</pre></div></div></div>
<div class="paragraph"><p>Class Cat&#8217;s inheritance hierarchy and linearization are shown in Figure 12.1. Inheritance is indicated using traditional UML notation:<span class="footnote"><br />[Rumbaugh, et. al., The Unified Modeling Language Reference Manual. [Rum04]]<br /></span> arrows with white, triangular arrowheads indicate inheritance, with the arrowhead pointing to the supertype. The arrows with darkened, non-triangular arrowheads depict linearization. The darkened arrowheads point in the direction in which super calls will be resolved.</p></div>
<div class="paragraph"><p>Малюнок 12.1 - Ієрархія наслідування і лінеарізація класу Cat.</p></div>
<div class="paragraph"><p>The linearization of Cat is computed from back to front as follows. The last part of the linearization of Cat is the linearization of its superclass, Animal. This linearization is copied over without any changes. (The linearization of each of these types is shown in Table 12.1here.) Because Animal doesn&#8217;t explicitly extend a superclass or mix in any supertraits, it by default extends AnyRef, which extends Any. Animal&#8217;s linearization, therefore, looks like:</p></div>
<div class="paragraph"><p>The second to last part is the linearization of the first mixin, trait Furry, but all classes that are already in the linearization of Animal are left out now, so that each class appears only once inCat&#8217;s linearization. The result is:</p></div>
<div class="paragraph"><p>This is preceded by the linearization of FourLegged, where again any classes that have already been copied in the linearizations of the superclass or the first mixin are left out:</p></div>
<div class="paragraph"><p>Finally, the first class in the linearization of Cat is Cat itself:</p></div>
<div class="paragraph"><p>When any of these classes and traits invokes a method via super, the implementation invoked will be
the first implementation to its right in the linearization.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 12.1 Лінеарізація типів в ієрархії Cat</caption>
<col width="16%" />
<col width="83%" />
<thead>
<tr>
<th align="center" valign="top"> Тип </th>
<th align="center" valign="top"> Лінеаризація</th>
</tr>
</thead>
<tbody>
<tr>
<td align="right" valign="top"><p class="table">Animal</p></td>
<td align="left" valign="top"><p class="table">Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">Furry</p></td>
<td align="left" valign="top"><p class="table">Furry, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">FourLegged</p></td>
<td align="left" valign="top"><p class="table">FourLegged, HasLegs, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">HasLegs</p></td>
<td align="left" valign="top"><p class="table">HasLegs, Animal, AnyRef, Any</p></td>
</tr>
<tr>
<td align="right" valign="top"><p class="table">Cat</p></td>
<td align="left" valign="top"><p class="table">Cat, FourLegged, HasLegs, Furry, Animal, AnyRef, Any</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_12_7___">12.7 Чи використовувати трейти?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Whenever you implement a reusable collection of behavior, you will have to decide whether you want to use a trait or an abstract class. There is no firm rule, but this section contains a few guidelines to consider.</p></div>
<div class="paragraph"><p><em>If the behavior will not be reused</em>, then make it a concrete class. It is not reusable behavior after all.</p></div>
<div class="paragraph"><p><em>If it might be reused in multiple, unrelated classes</em>, make it a trait. Only traits can be mixed into different parts of the class hierarchy.</p></div>
<div class="paragraph"><p><em>If you want to inherit from it in Java code</em>, use an abstract class. Since traits with code do not have a close Java analog, it tends to be awkward to inherit from a trait in a Java class. Inheriting from a Scala class, meanwhile, is exactly like inheriting from a Java class. As one exception, a Scala trait with only abstract members translates directly to a Java interface, so you should feel free to define such traits even if you expect Java code to inherit from it. SeeChapter 31 for more information on working with Java and Scala together.</p></div>
<div class="paragraph"><p><em>If you plan to distribute it in compiled form</em>, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class. The issue is that when a trait gains or loses a member, any classes that inherit from it must be recompiled, even if they have not changed. If outside clients will only call into the behavior, instead of inheriting from it, then using a trait is fine.</p></div>
<div class="paragraph"><p><em>If you still do not know</em>, after considering the above, then start by making it as a trait. You can always change it later, and in general using a trait keeps more options open.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_12_8_">12.8 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>This chapter has shown you how traits work and how to use them in several common idioms. You saw that traits are similar to multiple inheritance. But because traits interpret super using linearization, they both avoid some of the difficulties of traditional multiple inheritance and allow you to stack behaviors. You also saw the Ordered trait and learned how to write your own enrichment traits.</p></div>
<div class="paragraph"><p>Now that you have seen all of these facets, it is worth stepping back and taking another look at traits as a whole. Traits do not merely support the idioms described in this chapter; they are a fundamental unit of code that is reusable through inheritance. As such, many experienced Scala programmers start with traits when they are at the early stages of implementation. Each trait can hold less than an entire concept, a mere fragment of a concept. As the design solidifies, the fragments can be combined into more complete concepts through trait mixin.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-12 21:25:14 EET
</div>
</div>
</body>
</html>
