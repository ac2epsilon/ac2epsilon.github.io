<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__6">Глава 6</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Функціональні об'єкти</h1>
<div class="paragraph"><p>З розумінням основ Scala, яке ви отримали від попередніх глав, ви готові до розробки більш наповнених можливістями класів в Scala. В цій главі ми зробимо наголос не класах, що визначають функціональні об'єкти, або об'єкти, що не мають жодного змінного стану. В якості роблячого прикладу, ми створимо декілька варіантів класу, що моделює раціональні числа як незмінні об'єкти. По ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного програмування в Scala: параметри класів та конструктори, методи та оператори, приватні члени, перекриття, перевірку передумов, перевантаження та посилання на себе.</p></div>
<div class="sect1">
<h2 id="_6_1___rational">6.1 Специфікація класа Rational</h2>
<div class="sectionbody">
<div class="paragraph"><p><em>Раціональне число</em> є таке, що може бути виражене як відношеня <code>n/d</code>, де <code>n</code> та <code>d</code> є цілі, за винятком того, що <code>d</code> не може бути нулем. <code>n</code> називається чисельником, та <code>d</code> знаменником. Приклади раціональних чисел є 1/2, 2/3, 112/239, та 2/1. Порівняно з числами з плаваючою крапкою, раціональні числа мають перевагу в тому, що дробі представлені точно, без округлення або апроксимації.</p></div>
<div class="paragraph"><p>Клас, який ми будемо розробляти в цей главі, має моделювати поведінку раціональних чисел, включаючи можливіть додавати їх, віднімати, множити та ділити. Щоб додати двоє раціональних числа, вам треба зпочатку отримати загальний знаменник, потім додати два чисельника. Наприклад, щоб додати <code>1/2 + 2/3</code>, ви множите обі частини лівого операнда на 3, та обі частини правого операнда на 2, що дає вам <code>3/6 + 4/6</code>. Додавання двох чисельників дає вам результат, <code>7/6</code>. Щоб помножити два раціональні числа, ви просто множите їх чисельники, та множите їх займенники. Таким чином, <code>1/2 * 2/5</code> дає <code>2/10</code>, що може бути представлено більш компактно в "нормалізованій" формі як <code>1/5</code>. Ви ділите обмінюючи чисельник та займенник правого операнда, та потім виконуєте множення. Наприклад, <code>1/2 / 3/5</code> є те саме, що <code>1/2 * 5/3</code>, або <code>5/6</code>.</p></div>
<div class="paragraph"><p>Одне, можливо тривіальне, спостереження полягає в тому, що раціональні числа не мають змінного стану. Ви можете дадати одне раціональне до іншого, але результат буде новим раціональним числом. Оригінальні числа не будуть "змінені". Незмінний клас <code>Rational</code>, що ми будемо розробляти в цій главі, буде мати ту саму властивість. Кожне раціональне число буде представлене одним об'єктом <code>Rational</code>. Коли ми додаємо два об'єкти <code>Rational</code>, ви будете створювати новий об'єкт <code>Rational</code> щоб утримувати суму. Ця глава надасть вам  побіжне враження, як Scala дозволяє вам писати бібліотеки, що відчуваються як природна підтримка мови. Наприклад, в кінці цієї глави ви будете в змозі зробити це з класом <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoThirds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">twoThirds</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">oneHalf</span> <span class="o">/</span> <span class="mi">7</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">twoThirds</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">17</span><span class="o">/</span><span class="mi">42</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_2__rational">6.2 Конструювання Rational</h2>
<div class="sectionbody">
<div class="paragraph"><p>Гарне місце почати розробку класа <code>Rational</code> є вирішити, як програмісти клієнти будуть створювати новий об'єкт <code>Rational</code>. Зважаючи, що ми приняли рішення зробити об'єкти <code>Rational</code> незмінними, ми потребуємо, щоб клієнти надали всі дані, що треба для примірника (в цьому випадку чисельник та займенник), коли вони конструюють примірник. Таким чином, ми почнемо розробку з такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з перших речей, що треба зауважити щодо цього рядка кода, це те, що якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча ви можете, звичайно, якщо бажаєте). Ідентифікатори <code>n</code> та <code>d</code> в дужках після імені класу <code>Rational</code>, називаються параметрами класу. Компілятор Scala збере докупи ці параметри класу, та створить первинний конструктор, що матиме саме два параметри.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____">Компроміс незмінних об'єктів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Незмінні об'єкти пропонують декілька переваг над змінним об'єктами, та один потенційний недолік. Перше, незмінні об'єкти часто простіше продумуються, ніж змінні, бо вони не мають складних просторів стану, що змінюються з часом. Друге, ви можете передавати незмінні об'екти довкола досить вільно, тоді як вам може знадобитись робити захисні копії змінних об'єктів, перед тим, як передаватий їх в інший код. Третє, немає способу для двох потоків, що одночасно отримують доступ до незмінного об'єкту, пошкодити його стан, коли він вже відповідно створений, бо потік взагалі не може змінити стан незмінного. Четверте, незмінні об'єкти роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт зміниться після того, як він покладений, наприклад, в <code>HashSet</code>, цей об'єкт може бути не знайдений наступний раз, коли ви шукаєте в <code>HashSet</code>.</p></div>
<div class="paragraph"><p>Головний недолік незмінних об'єктів в тому, що вони іноді потребують копіювання великого об'єктного графа, тоді як оновлення може бути зроблене на місці. В деяких випадках це може бути незручно виразити, і також може стати вузьким місцем продуктивності. Як результат, не нє рідкістю для бібліотек провадити змінні альтернативи до незмінних класів. Наприклад, клас <code>StringBuilder</code> є змінною альтернативою до незмінного  <code>String</code>. Ми надамо вам більше інформації щодо розробки змінних класів в Scala в Главі 18.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Цей початковий приклад <code>Rational</code> підкреслює різницю між Java та Scala. В Java класи мають конструктори, що можуть приймати параметри; тоді як в Scala класи самі можуть приймати параметри. Нотація Scala більше стисла — параметри класу можуть бути використані напряму в тілі класу; немає потреби визначати поля та писати присвоєння, що копіюють параметри конструктора в поля. Це може дати значну економію в шаблонному коді, особливо для малих класів.</td>
</tr></table>
</div>
<div class="paragraph"><p>Компілятор Scala буде компілювати любий код, який ви покладете в тіло класа, що не є частиною поля або визначення метода, в первинний конструктор. Наприклад, ви можете надрукувати повідомлення зневадження таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Created &quot;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Беручи цей код, компілятор Scala покладе виклик до <code>println</code> в первинний конструктор <code>Rational</code>. Таким чином, виклик <code>println</code> буде друкувати своє повідолениня зпевадження, коли ви будете створювати новий примірник <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="nc">Created</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="nc">Rational</span><span class="k">@</span><span class="mi">2591</span><span class="n">e0c9</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_3___tostring">6.3 Реалізація метода toString</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли ви створили примірник <code>Rational</code> в попередньому прикладі, інтерпретатор надрукував <code>Rational@90110a</code>. Інтерпретатор отримав цей, дещо дивно вигладаючий, рядок викликаючи <code>toString</code> на об'єкті <code>Rational</code>. По замовченню клас <code>Rational</code> наслідує реалізацію <code>toString</code>, визначену в класі <code>java.lang.Object</code>, що просто друкує ім'я класу, символ <code>@</code>, та шістнадцятирічне число. Метод <code>toString</code> початково призначений для допомоги програмістам, провадячи інформацію, що може використовуватись для друкування повідомлень зневадження, журналювання повідомлень, звітів про збій тестів, та виводу інтерпретатора та знаваджувача. Результат, що наразі провадиться <code>toString</code>, не особливо корисний, бо він не надає жодного натяку щодо значення раціонального числа. Більш корисна реалізація <code>toString</code> може друкувати значення чисельника та займенника Rational. Ви можете <em>перекрити</em> реалізацію по замовчанню, через додавання метода <code>toString</code> до класу <code>Rational</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>override</code> попереду визначення метода сигналить, що попереднє визначення перекривається (більше про це в Главі 10). Оскільки числа <code>Rational</code> тепер будуть гарно відображатись, ми видалили твердження  <code>println</code>, що ми поклали в тіло попередньої версії класа <code>Rational</code>. Ви можете протестувати нову поведінку  <code>Rational</code> в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">7</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_4__">6.4 Перевірка передумов</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як наступний крок, ми звернемо нашу увагу на проблему з поточною поведінкою первинного конструктора. Як зазначалось на початку цієї глави, раціональні числа не можуть мати нуль в якості займенника. Однак зараз первинний конструктор приймає нуль, переданий для <code>d</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з переваг об'єктно-орієнтовного програмування є те, що воно дозволяє вам інкапсулювати дані в об'єкті, так що ви можете бути впевнені, що дані валідні на протязі його життя. В випадку незмінних об'єктів, таких як <code>Rational</code>, це означає, що вам треба переконатись, що дані валідні при конструюванні об'єкта. Зважаючи, що нульовий займенник є невілідним станом для числа Rational, вам не слідує дозволити конструювання  <code>Rational</code>, якщо нуль передається в параметрі <code>d</code>.</p></div>
<div class="paragraph"><p>Кращий шлях підійти до цієї проблеми є визначити передумову в первинному конструкторі, що <code>d</code> не має бути нулем. Передумова є обмеження на значення, передані в метод або конструктор, вимога, якій має задовільняти вікликаюча сторона. Один спосіб зробити це є використанян <code>require</code>,<span class="footnote"><br />[Метод <code>require</code> визначений в окремому об'єкті <code>Predef</code>. Як зазначено в Главі 4.4, члени <code>Predef</code> імпортуються автоматично в кожний файл Scala.]<br /></span> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>require</code> приймає один логічний параметр. Якщо передане значення є <code>true</code>, <code>require</code> поверне керування звичайно. Інакше <code>require</code> буде запобігати створенню об'єкта, через виклик <code>IllegalArgumentException</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_5__">6.5 Додавання полів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли первинний конструктор відповідно перевіряє виконання передумови, ми звернемо нашу увагу на підтримку додавання. Щоб зробити це, ми визначимо публічний метод <code>add</code> на класі <code>Rational</code>, що приймає інше <code>Rational</code> як параметр. Щоб утримувати <code>Rational</code> незмінним, метод <code>add</code> не має додавати передане раціональне число до себе. Скоріше, він має створити та повернути нове <code>Rational</code>, що міститиме суму. Ви можете подумати, що можете написати <code>add</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// Не буде компілюватись</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">d</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">d</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">d</span><span class="o">,</span> <span class="n">d</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак, маючи цей код, компілятор буде скаржитись:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^</code></pre>
</div></div>
<div class="paragraph"><p>Хоча параметри класу <code>n</code> та <code>d</code> в полі зору коду вашого метода <code>add</code>, ви можете отримувати доступ до їх значень тільки для об'єкта, на якому був викликаний метод <code>add</code>. Таким чином, коли ви кажете <code>n</code> або <code>d</code> в реалізцаії <code>add</code>, компілятор буде щасливий провадити значення для ціх параметрів класу. Але він не дає вам казати <code>that.n</code> або <code>that.d</code>, оскільки це не посилається на об'єкт <code>Rational</code>, на якому був визваний <code>add</code>.<span class="footnote"><br />[Насправді, ви можете додати Rational до себе, в якому випадку це буде посилатись на об'єкт, на якому викликається <code>add</code>. Але оскільки ви можете передати любий об'єкт <code>Rational</code> до <code>add</code>, компілятор все ще не дає вам сказати <code>that.n</code>.]<br /></span> Щоб отримати чисельник та займенник на <code>that</code>, вам треба перетворити їх на поля. Лістинг 6.1 показує, як ви можете додати ці поля до класу <code>Rational</code>.<span class="footnote"><br />[В Розділі 10.6 ви прочитаєте щодо параметричних полів, що провадять скорочення для написання того самого кода.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">d</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.1 - Rational з полями.</p></div>
<div class="paragraph"><p>В версії <code>Rational</code>, показаній в Лістингу 6.1 ми дадали два поля на ім'я <code>numer</code> та <code>denom</code>, та ініціалізували їх значеннями параметрів класу, <code>n</code> та <code>d</code>.<span class="footnote"><br />[Навіть якщо <code>n</code> та <code>d</code> використовуються в тілі класу, виходячи з того, що вони використовуються тільки в конструкторах, компілятор Scala не буде створювати поля для них. Таким чином, маючи цей код компілятор Scala буде генерувати клас з двома полями <code>Int</code>, одне для <code>numer</code> та одне для <code>denom</code>.]<br /></span> Ми змінили реалізацію <code>toString</code> та <code>add</code>, так що вони використовують поля, а не параметри класу. Ця версія <code>Rational</code> компілюється. Ви можете протестувати її, додавши деякі раціональні числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">twoThirds</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">twoThirds</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="n">add</span> <span class="n">twoThirds</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Інша річ, яку ви можете зробити тепер, але не могли раніше, є доступ до значень чисельника та займенника з поза меж об'єкта. Просто отримайте доступ до публічних полів <code>numer</code> та <code>denom</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">numer</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">denom</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_6___">6.6 Посилання на себе</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ключове слово <code>this</code> посилається на примірник об'єкту, на якому був визваний метод, який наразі виконується, або в випадку конструктора - примірник об'єкта, що створюється. Як приклад, розглянемо додавання метода  <code>lessThan</code>, що перевіряє, що дане Rational меньше ніж параметр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">lessThan</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">this</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">&lt;</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="k">this</span><span class="o">.</span><span class="n">denom</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>this.numer</code> посилається на чисельник об'єкта, на якому викликане <code>lessThan</code>. Ви також можете облишити цей префікс, та записати тільки <code>numer</code>; дві нотифікації є еквівалентними. Як приклад того, що ви не можете робити без <code>this</code>, розглянемо додавання метода <code>max</code> до класу <code>Rational</code>, що повертає більше з даного раціонального та аргумента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">lessThan</span><span class="o">(</span><span class="n">that</span><span class="o">))</span> <span class="n">that</span> <span class="k">else</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут перше <code>this</code> є надлишковим. Ви можете відкинути його, та записати: <code>lessThan(that)</code>. Але друге <code>this</code> представляє результат метода, в випадку, коли перевірка поверне <code>false</code>; коли ми оминемо його, нам нічого не залишиться повертати!</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_7__">6.7 Додаткові конструктори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді вам треба декілька конструкторів класу. В Scala конструктори, крім первинного, називаються додатковими конструкторами. Наприклад, раціональне число з займенником 1 може бути записане більш лаконічно як один чисельник. Наприклад, замість <code>5/1</code>, ви можете записати лише 5. Таким чином, це було б гарно, якщо замість запису <code>Rational(5, 1)</code>, програмісти клієнти могли просто писати <code>new Rational(5)</code>. Це буде потребувати додавання додаткового конструктора до <code>Rational</code>, що приймає лише один аргумент, чисельник, з займенником передвизначеним як 1. Лістинг 6.2 показує, на що це може бути схоже.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">val</span> <span class="n">numer</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denom</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">d</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// додатковий конструктор</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.2 - Rational з додатковим конструктором.</p></div>
<div class="paragraph"><p>Додаткові конструктори в Scala починаються з <code>def this(...)</code>. Тіло додаткового конструктора <code>Rational</code> просто викликає первинний конструктор, передаючи йому всій єдиний аргумент, <code>n</code>, як чисельник, та 1 як займенник. Ви можете бачити додатковий конструктор в дії, написавши таке в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala кожний зовнішінй конструктор має викликати інший конструктор того самого класу в якості першої дії. Іншими словами, перше твердження в кожному додатковому конструкторі кожного класа Scala буде мати форму <code>this(...)</code>. Викликаний конструктор є або первинним конструктором (як в прикладі <code>Rational</code>), або інший додатковий конструктор, що текстуально іде перед викликаючим конструктором. Нетто ефект з цього правила в тому, що кожний виклик конструктора в Scala згодом буде закінчувати викликом первинного конструктора класу. Первинний конструктор, таким чином, є єдиною точкою входу класу.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Якщо ви знакомі з Java, ви можете здивуватись, чому правила Scala для конструкторів трохи більш обмежуючі, ніж в Java. В Java конструктор в якості першой дії має або викликати інший конструктор того самого класу, або напряму викликати конструктор суперкласу. В класах Scala тільки первинний конструктор може викликати конструктор суперкласу. Збільшення обмеження в Scala насправді є компроміс дизайну, який треба заплатити за більшу стислість та простоту констуркторів Scala, порівняно з Java. Суперкласи та деталі, як взаємодіють виклики конструкторів та наслідування, пояснені в Главі 10.</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_8____">6.8 Приватні поля та методи</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередній версії <code>Rational</code> ми просто ініціалізували <code>numer</code> як <code>n</code> та <code>denom</code> як <code>d</code>. Як результат, чисельник та займенник <code>Rational</code> можуть бути більші, ніж треба. Наприклад, дріб <code>66/42</code> може бути нормалізована до екввалентної скороченої форми, <code>11/7</code>, але первинний конструктор <code>Rational</code> наразі не робить цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">66</span><span class="o">/</span><span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб нормалізувати число і такий спосіб, нам треба розділити чисельник та займенник на їх спільний дільник. Наприклад, найбільший дільник для <code>66</code> та <code>42</code> є <code>6</code>. (Іншими словами, 6 є більшим цілим, що рівно ділить обоє, 66 та 42.) Ділення обох, чисельника та займенника <code>66/42</code> на <code>6</code> дає скорочену форму, 11/7. Лістинг 6.3 показує спосіб, як зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
  <span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.3 - Rational з приватним полем та методом.</p></div>
<div class="paragraph"><p>В цій версії Rational ми додали приватне поле <code>g</code>, та модифікували ініціалізатори для <code>numer</code> та <code>denom</code>. (Ініціалізатор є код, що ініціалізує змінну; наприклад, <code>n / g</code>, що ініціалізує <code>numer</code>.) Оскільки <code>g</code> є приватним, доступ до неї може відбуватись тільки з тіла класу, але не ззовні. Ми також додали приватний метод, <code>gcd</code>, що обчислює найбільший загальний дільник двох переданих <code>Int</code>. Наприклад, <code>gcd(12, 8)</code> є <code>4</code>. Як ви бачили в Розділі 4.1, щоб зробити поле або метод приватними, ви просто можете покласти ключове слово <code>private</code> перед його визначенням. Призначення приватного "допоміжного метода" <code>gcd</code> є виділити код, потрібний для якоїсь іншої частини класу, в цьому випадку первинному конструктору. Щоб переконатись, що <code>g</code> завжди додатнє, ми передаємо абсолютні значення <code>n</code> та <code>d</code>, що ми отримали через виклик на них метода <code>abs</code>, метод, що ви можете викликати на кожному <code>Int</code> щоб отримати його абсолютне значення.</p></div>
<div class="paragraph"><p>Компілятор Scala буде покладати код для ініціалізаторів трьох полів <code>Rational</code> в первинний конструктор, в порядку як вони з'являються в джерельному коді. Таким чином, ініціалізатор <code>g</code>, <code>gcd(n.abs, d.abs)</code>, буде виконуватись перед іншими двома, оскільки він іде першим в тексті. Поле <code>g</code> буде ініціалізоване результатом, найбільшим загальним дільником абсолютних значень параметрів класу, <code>n</code> та <code>d</code>. Поле <code>g</code> потім використовується в ініціалізаторах <code>numer</code> та <code>denom</code>. Після ділення <code>n</code> та <code>d</code> на їх найбільший загальний дільник, <code>g</code>, кожний <code>Rational</code> буде сконструйований в його нармалізованій формі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">11</span><span class="o">/</span><span class="mi">7</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_9__">6.9 Визначення операцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поточна реалізація додавання <code>Rational</code> є OK, але може бути зроблене зручнішим в роботі. Ви можете спитати себе, чому ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>якщо <code>x</code> та <code>y</code> є цілі або з плаваючою крапкою, але ви маєте писати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або щонайменше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="n">add</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>якщо вони раціональні числа. Немає переконливої причини, чому має бути саме так. Раціональні числа є числами, як любі інші числа. В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з плаваючою крапкою.</p></div>
<div class="paragraph"><p>Чому ми не повинні використовувати природні арифметичні оператори для них? В Scala ви можете робити це. В залишку глави ми покажемо вам як.</p></div>
<div class="paragraph"><p>Перший крок є замінити <code>add</code> на звичайний математичний символ. Це прямолінійне, бо <code>+</code> є легальним ідентифікатором в Scala. Ми можемо просто визначили метод з <code>+</code> в якості імені. Поки ми вже в цьому, ми можемо також реалізувати метод на ім'я <code>*</code>, що виконує множення. Результат показаний в Лістингу 6.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">gdef</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.4 - Rational з операторними методами.</p></div>
<div class="paragraph"><p>Коли клас <code>Rational</code> визначений в цей спосіб, тепер ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Як завжди, операторний синтаксис в останньому рядку еквівалентний до викликуу метода. Ви можете також записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span><span class="o">.+(</span><span class="n">y</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">7</span><span class="o">/</span><span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>але це не читабельне.</p></div>
<div class="paragraph"><p>Інша річ, що треба зауважити, є приймаючи до уваги правила Scala для преоритетів операторів, описані в Розділі 5.9, метод <code>*</code> буде притулятись більш тісно, ніж метод <code>+</code> для <code>Rationals</code>. Іншими словами, вираз, що включає операції <code>+</code> та <code>*</code> на <code>Rationals</code> буде поводитись як очікується. Наприклад, <code>x + x * y</code> буде виконуватись як <code>x + (x * y)</code>, не <code>(x + x) * y</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">*</span> <span class="n">y</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">66.10</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___scala">Ідентифікатори в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили два найбільш важливі способи сформувати ідентифікатор в Scala: алфавітно-цифрові та оператори. Scala має дуже гнучки правила для формування ідентифікаторів. Кірм двох форм ви також бачили тут дві інші. Всі чотири форми створенні ідентифікатоірв описані і цьому розділі. Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення, за яким можуть далі слідувати літери, цифри або підкреслення. Символ <code>$</code> також рахується як літера; однак, вона зарезервована для ідентифікатором, згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах по повинні містити символи <code>$</code>, навіть якщо це і буде компілюватись; якщо вони будуть, це може призвести до стикання імен з ідентифікаторами, згенерованих компілятором Scala.</p></div>
<div class="paragraph"><p>Scala слідує домовленості Java використання кемел-кейсу в ідентифікаторах,<span class="footnote"><br />[Цей стиль іменування ідентифікаторів названий кемел-кейс (верблюжий реєстр), оскільки ідентифікатори HaveHumps мають вбудовані великі літери.]<br /></span> такі як <code>toString</code> та <code>HashSet</code>. Хоча підкреслення є легальні в ідентифікаторах, вони не використовуються так часто в Scala програмах, частково щоб бути узгодженою з Java, але також оскільки підкреслення мають багато інших не-ідентифікаторних використань в Scala коді. Як результат, накраще уникати ідентифікаторів, як <code>to_string</code>, <code>__init__</code>, або <code>name_</code>.</p></div>
<div class="paragraph"><p>Кемел-кейс імена полів, параметрів методів, локальних змінних та функцій повинні починатись з літери в нижньому реєстрі, наприклад: <code>length</code>, <code>flatMap</code> та <code>s</code>. Кемел-кейс імена класів та трейтів повинні починатись з літери в верхньому реєстрі, наприклад: <code>BigInt</code>, <code>List</code> та <code>UnbalancedTreeMap</code>.<span class="footnote"><br />[В Розділі 16.5 ви побачите, що іноді ви бажаєте надати спеціальному типу класу, відомому як кейс клас, ім'я, що повністю складається з символів операторів. Наприклад, Scala API має клас на ім'я <code>::</code>, що спрощує співпадіння шаблонів для List.]<br /></span></p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Один наслідок з використання заключного підкреслення в ідентифікаторі є в тому, що якщо ви спробуєте, наприклад, написати декларацію, як цю: <code>val name_: Int = 1</code>, ви отримаєте помилку компілятора. Компілятор буде думати, що ви намагаєтесь декларувати <code>val</code> на ім'я <code>name_:</code>. Щоб змісити це компілюватись, вам треба вставити додатковий проміжок перед двокрапкою, як тут: <code>val name_ : Int = 1</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Один шлях, в який домовленості Scala відходять від Java включають імена констант. В Scala слово <code>constant</code> означає на просто <code>val</code>. Навіть якщо <code>val</code> має залишатись сталою після ініціалізації, це все ще змінна. Наприклад, параметри методів є <code>vals</code>, але кожний раз, коли визивається метод, ці <code>val</code> може містити різні значення. <code>constant</code> більш стійкі. Наприклад, <code>scala.math.Pi</code> визначена щоб бути значенням подвійної точності, найближчим до дійсного значення <code>π</code>, відношення довжини кола до його диаметру. Це значення навряд чи зміниться будь-коли; таким чином, <code>Pi</code> явно є константою. Ви можете також використовувати константи для надання імен значенням, що інакше були б магічними числами в коді: літеральні значення без пояснення, що в гіршому випадку з'являються в декількох місцях. Ви можете також побажати визначити константи для використання в співпадінні шаблонів, приклади використання яких описані в Розділі 15.2. В Java домовленість полягає в використанні імен констант з великих літер, з підкресленнями в якості роздільнииків слів, таких як <code>MAX_VALUE</code> або <code>PI</code>. В Scala домовленість просто така, щоб перша літера була великою. Таким чином, константи, названі в стилі Java, такі як <code>X_OFFSET</code>, будуть робити як Scala константи, але домовленість Scala використовувати кемел-кейс для констант, такі як <code>XOffset</code>.</p></div>
<div class="paragraph"><p>Операторний ідентифікатор складається з одного або більше операторних символів. Операторні символи є друковані ASCII символи, такі як <code>+</code>, <code>:</code>, <code>?</code>, <code>~</code> або <code>#</code>.<span class="footnote"><br />[Більш точно, операторний символ належить до множини Unicode математичних символів (Sm) або інших символів (So), або до 7-бітних ASCII символів, що не є літерами, цифрами, дужками, прямокутними дужками, фігурними дужками, поодинокими та подвійними лапками, або підкресленням, крапкою, крапкою з комою, комою, або апострофом.]<br /></span> Ось деякі приклади операторних ідентифікаторів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">+</span>
<span class="o">++</span>
<span class="o">:::</span> <span class="o">&lt;?&gt;</span>
<span class="o">:-&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор Scala буде всредині "колдувати" з операторними ідентифікаторами, щоб перетворити їх на легальні  Java ідентифікатори з вбудованими символами <code>$</code>. Наприклад, ідентифкатор <code>:-&gt;</code> внутрішньо буде представлений як <code>$colon$minus$greater</code>. Якщо ви колись побажаєте отримати доступ до цього ідентифікатора з Java кода, вам знадобиться використовувати цю внутрішню репрезентацію.</p></div>
<div class="paragraph"><p>Оскільки операторні ідентифікатори в Scala можуть стати довільно довгі, існує мала різниця між Java та Scala. В Java ввод <code>x&lt;-y</code> буде розібране як чотири лексичні символі, так що це буде еквівалентне до <code>x &lt; - y</code>. В Scala <code>&lt;-</code> буде розібране як єдиний ідентифікатор, даючи <code>x &lt;- y</code>. Якщо ви бажаєте першу інтерпретацію, вам треба відокремити символи <code>&lt;</code> та <code>-</code> проміжками. Це навряд чи буде проблемою на практиці, бо дуже мало людей пишуть <code>x&lt;-y</code> в Java, без вставлення проміжків або дужок між операторами.</p></div>
<div class="paragraph"><p>Змішений ідентифікатор складається з алфавітно-цифрового ідентифікатора, за яким слідує підкреслення, та операторний ідентифікатор. Наприклад, <code>unary_+</code> використовується як ім'я метода, що визначає унарний оператор <code>+</code>. Або <code>myvar_=</code>, що використовується як ім'я метода, що визначає оператор присвоєння. На додаток, змішані ідентифікатори в формі <code>myvar_=</code> генеруються компілятором Scala для підтримки властивостей (більше про це в Главі 18).</p></div>
<div class="paragraph"><p>Літеральний ідентифікатор є довільним рядком, оточений зворотніми апострофами `&#8230;\`. Деякі приклади літеральних ідентифікатоірв:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">`x`</span>
<span class="n">`&lt;clinit&gt;`</span>
<span class="n">`yield`</span>
</pre></div></div></div>
<div class="paragraph"><p>Ідея в тому, що ви покладаєте любий рядок, що допустимий під час виконання, як ідентифікатор між апострофами. Результат завжди є Scala ідентифікатор. Це робить навіть якщо ім'я в апострофах буде зарезервованим словом Scala. Типове використання є доступ до статичного метода <code>yield</code> в класі Java Thread. Ви не можете писати <code>Thread.yield()</code>, оскільки <code>yield</code> є зарезервованим словом Scala. Однак ви можете все ще назвати метод в апострофах, тобто <code>Thread.`yield</code>()`.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_11__">6.11 Перевантаження методів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Повернемось до класу <code>Rational</code>. З останніми змінами ви тепер можете робити операції додавання та множення в природний спосіб на раціональних числах. Але одна річ все ще відсутня - це змішана арифметика. Наприклад, ви не можете множити раціональне число на ціле, оскільки операнди <code>*</code> завжди мають бути <code>Rational</code>. Так що для раціонального числа <code>r</code> ви не можете написати <code>r * 2</code>. Ви маєте писати <code>r * new Rational(2)</code>, що не таке гарне.</p></div>
<div class="paragraph"><p>Щоб зробити <code>Rational</code> навіть ще зручнішим, ми додаємо методи до класу, що виконують змішане додавання та множення на раціональних числах та цілих. Доки ми тут, ми також додаємо методи для віднімання та ділення. Результат показаний на Лістингу 6.5.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>

  <span class="n">require</span><span class="o">(</span><span class="n">d</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="n">abs</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">d</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">n</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span>
      <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">-</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
      <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="o">-</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">i</span><span class="o">,</span> <span class="n">denom</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span><span class="o">)</span>

  <span class="k">def</span> <span class="o">/</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span>
    <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">numer</span><span class="o">,</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">i</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">&quot;/&quot;</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 6.5 - Rational з перевантаженими методами.</p></div>
<div class="paragraph"><p>Тепер є дві версії для кожного арифметичного метода: одна що приймає раціональне в якості аргумента, та інша, що приймає ціле. Іншими словами, ім'я кожного з ціх методів перевантажене, оскільки кожне ім'я може використовуватись для декількох методів. Наприклад, ім'я <code>+</code> використовується одним методом, що приймає <code>Rational</code>, та інший, що приймає <code>Int</code>. В виклику метода компілятор обирає версію перевантаженого методу, що коректно співпадає з типами аргументів. Наприклад, якщо аргумент <code>y</code> в <code>x.+(y)</code> є <code>Rational</code>, компілятор буде обирати метод <code>+</code>, що приймає параметр <code>Rational</code>. Але якщо аргумент є цілим, компілятор обере метод <code>+</code>, що приймає параметр <code>Int</code>. Якщо ви спробуєте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">9</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви побачите, що викликаний метод <code>*</code> визначений в кожному випадку по типу правого операнду.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">процес Scala з розрішення перевантажених методів дуже подібний до Java. В жодному разі обрана перевантажена версія є однією, що найкраще співпадає зі статичними типами аргументів. Іноді немає версії для унікального кращого співпадіння; в такому випадку компілятор видасть вам помилку "ambiguous reference".</td>
</tr></table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_6_12__">6.12 Неявні перетворення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви можете написати <code>r * 2</code>, ви можете також побажати обміняти операнди, як <code>2 * r</code>. Нажаль, це все ще не робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">10</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">overloaded</span> <span class="kt">method</span> <span class="kt">value</span> <span class="kt">*</span> <span class="kt">with</span>
<span class="n">alternatives</span><span class="k">:</span>
<span class="o">(</span><span class="kt">x:</span> <span class="kt">Double</span><span class="o">)</span><span class="kt">Double</span> <span class="kt">&lt;and&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span><span class="nc">Float</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="nc">Long</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Short</span><span class="o">)</span><span class="nc">Int</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span>
<span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Byte</span><span class="o">)</span><span class="nc">Int</span>
<span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="o">(</span><span class="nc">Rational</span><span class="o">)</span>
<span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема тут в тому, що <code>2 * r</code> еквівалентне до <code>2.*(r)</code>, так що це виклик метода на числі 2, що є цілим. Але клас <code>Int</code> не містить метода множення, що приймає аргумент <code>Rational</code> — він не може, бо клас <code>Rational</code> не є стандартним класом в бібліотеці Scala.</p></div>
<div class="paragraph"><p>Однак є інший шлях вирішити цю проблему в Scala: ви можете створити неявне перетворення, що автоматично конвертує цілі на раціональні числа в разі потреби. Спробуйте додавання цього рядка в інтерпретатор:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це викликає метод перетвоерння з <code>Int</code> до <code>Rational</code>. Модифікатор <code>implicit</code> попереду метода каже компілятору застосувати його автоматично в декількох ситуаціях. З визначеним перетворенням, ви можете повторити спробу приклада, що схибив до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="n">r</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">r</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб неявне перетворення працювало, воно має бути в полі зору. Якщо ми покладемо визначення неявного метода в клас <code>Rational</code>, він не буде в полі зору інтерпретатора. Поки ви повинні визначати його прямо в інтерпретаторі. Як ви здогадались з цього приклада, неявні перетворення дуже потужний прийом, щоб зробити бібліотеки більш гнучкими та більш зручними для використання. Оскільки вони такі потужні, вони можуть бути легко невірно використані. Ви побачите більше щодо неявних перетворень, включаючи шляхи занести їх в поле зору коли треба, в Главі 21.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_13__">6.13 Слово попередження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як демонструє ця глава, створення методів з іменами операторів та визначення неявних перетворень може допомогти вам розробляти бібліотеки, для яких клієнтськіій код є стислим та легко зрозумілим. Scala дає вам велику пропозицію щодо потужності, щоб розробляти такі прості-в-використанні бібліотеки. Але майте на увазі, що з силою іде відповідальність.</p></div>
<div class="paragraph"><p>Використані без майстерності, обоє, операторні методи та неявні перетворення можуть дати поштовх клієнтському коду, що складно читати та розуміти. Оскільки неявні перетворення застосовуються неявно компілятором, не явно прописані в коді, може бути неочевидним для програмістів клієнтів, що невні перетворення були застосовані. Та хоча операторні методи будуть звичайно робити клієнтський код більш стислим, вони будуть робити його краще читаємим тільки в тій мірі, в якій програмісти клієнітв будуть здатні розпізнавати та запам'ятовувати значення кожного оператора. Ціль, яку ви маєте тримати в голові, коли розробляєте бібліотеки, це не просто зрообити можливим підвищити стислість клієнтського кода, але також читабельний, зрозумілий клієнтський код. Стислість часто буде великою часткою читабельності, але ви можете зайти в стислості дуже далеко. Розробляючі бібліотеки, що дозволяють стислість зі смаком, та в той же час зрозумілий клієнтський код, ви можете допомогти програмістам клієнтів робити продуктивно.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_6_14_">6.14 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили багато аспектів класів в Scala. Ви бачили, як додавати параметри до класу, визначати декілька конструкторів, визначати оператори як методи, та налаштовувати класи, так щоб користування їми було природним. Можливо, більш важливо, ви побачили, що визначення та використання незмінних об'єктів є досить натуральним шляхом кодувати в Scala.</p></div>
<div class="paragraph"><p>Хоча фінальна версія <code>Rational</code>, показана в цій главі, задовільняє всім вимогам, встановленим напочатку глави, він все ще може покращений. Ми будемо фактично повертатись до цього прикладу пізніше в цій книзі. Наприклад, в Главі 30 ми вивчемо, як перекривати <code>equals</code> та <code>hashcode</code>, щоб дозволити <code>Rationals</code> краще поводитись при порівнянні за допомогою <code>==</code> або покладаючись в хеш таблиці. В Главі 21 ви навчитесь, як покласти визначення неявних методів в об'єкт компанйон <code>Rational</code>, так що вони можуть бути більш легко покладені в поле зору, коли програмісти клієнтів роблять з <code>Rationals</code>.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-30 07:23:01 EET
</div>
</div>
</body>
</html>
