<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="paragraph"><p>Chapter 6
Functional Objects
With the understanding of Scala basics you&#8217;ve gained from previous chapters, you&#8217;re ready to design
more full-featured classes in Scala. In this chapter, the emphasis is on classes that define functional
objects, or objects that do not have any mutable state. As a running example, we&#8217;ll create several
variants of a class that models rational numbers as immutable objects. Along the way, we&#8217;ll show you
more aspects of object-oriented programming in Scala: class parameters and constructors, methods and
operators, private members, overriding, checking preconditions, overloading, and self references.
6.1 A SPECIFICATION FOR CLASS RATIONAL
A rational number is a number that can be expressed as a ratio n/d, where n and d are integers, except
that d cannot be zero. n is called the numerator and d the denominator. Examples of rational numbers
are 1/2, 2/3, 112/239, and 2/1. Compared to floating-point numbers, rational numbers have the
advantage that fractions are represented exactly, without rounding or approximation.
The class we&#8217;ll design in this chapter must model the behavior of rational numbers, including allowing
them to be added, subtracted, multiplied, and divided. To add two rationals, you must first obtain a
common denominator, then add the two numerators. For example, to add1/2 + 2/3, you multiply both
parts of the left operand by 3 and both parts of the right operand by 2, which gives you 3/6 + 4/6.
Adding the two numerators yields the result, 7/6. To multiply two rational numbers, you can simply
multiply their numerators and multiply their denominators. Thus, 1/2 * 2/5 gives 2/10, which can be
represented more compactly in its "normalized" form as 1/5. You divide by swapping the numerator
and denominator of the right operand and then multiplying. For instance 1/2 / 3/5 is the same
as 1/2 * 5/3, or 5/6.
One, maybe rather trivial, observation is that in mathematics, rational numbers do not have mutable
state. You can add one rational number to another, but the result will be a new rational number. The
original numbers will not have "changed." The immutable Rational class we&#8217;ll design in this chapter
will have the same property. Each rational number will be represented by one Rational object. When
you add two Rational objects, you&#8217;ll create a newRational object to hold the sum.
This chapter will give you a glimpse of some of the ways Scala enables you to write libraries that feel
like native language support. For example, at the end of this chapter you&#8217;ll be able to do this with
class Rational:
scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; (oneHalf / 7) + (1 - twoThirds)
res0: Rational = 17/426.2 CONSTRUCTING A RATIONAL
A good place to start designing class Rational is to consider how client programmers will create a
new Rational object. Given we&#8217;ve decided to make Rational objects immutable, we&#8217;ll require that
clients provide all data needed by an instance (in this case, a numerator and a denominator) when they
construct the instance. Thus, we will start the design with this:
class Rational(n: Int, d: Int)
One of the first things to note about this line of code is that if a class doesn&#8217;t have a body, you don&#8217;t
need to specify empty curly braces (though you could, of course, if you wanted to). The
identifiers n and d in the parentheses after the class name, Rational, are called class parameters. The
Scala compiler will gather up these two class parameters and create aprimary constructor that takes the
same two parameters.
IMMUTABLE OBJECT TRADE-OFFS
Immutable objects offer several advantages over mutable objects, and one potential disadvantage. First,
immutable objects are often easier to reason about than mutable ones, because they do not have
complex state spaces that change over time. Second, you can pass immutable objects around quite
freely, whereas you may need to make defensive copies of mutable objects before passing them to other
code. Third, there is no way for two threads concurrently accessing an immutable to corrupt its state
once it has been properly constructed, because no thread can change the state of an immutable. Fourth,
immutable objects make safe hash table keys. If a mutable object is mutated after it is placed into
a HashSet, for example, that object may not be found the next time you look into the HashSet.
The main disadvantage of immutable objects is that they sometimes require that a large object graph be
copied, whereas an update could be done in its place. In some cases this can be awkward to express and
might also cause a performance bottleneck. As a result, it is not uncommon for libraries to provide
mutable alternatives to immutable classes. For example, class StringBuilder is a mutable alternative to
the immutable String. We&#8217;ll give you more information on designing mutable objects in Scala
in Chapter 18.
Note
This initial Rational example highlights a difference between Java and Scala. In Java, classes have
constructors, which can take parameters; whereas in Scala, classes can take parameters directly. The
Scala notation is more concise—class parameters can be used directly in the body of the class; there&#8217;s
no need to define fields and write assignments that copy constructor parameters into fields. This can
yield substantial savings in boilerplate code, especially for small classes.
The Scala compiler will compile any code you place in the class body, which isn&#8217;t part of a field or a
method definition, into the primary constructor. For example, you could print a debug message like
this:
class Rational(n: Int, d: Int) {}
println("Created " + n + "/" + d)
Given this code, the Scala compiler would place the call to println into Rational&#8217;s primary constructor.
The println call will, therefore, print its debug message whenever you create a new Rational instance:
scala&gt; new Rational(1, 2)
Created 1/2
res0: Rational = <a href="mailto:Rational@2591e0c9">Rational@2591e0c9</a>
6.3 REIMPLEMENTING THE TOSTRING METHOD
When we created an instance of Rational in the previous example, the interpreter printed
"Rational@90110a". The interpreter obtained this somewhat funny looking string by callingtoString on
the Rational object. By default, class Rational inherits the implementation oftoString defined in
class java.lang.Object, which just prints the class name, an @ sign, and a hexadecimal number. The
result of toString is primarily intended to help programmers by providing information that can be used
in debug print statements, log messages, test failure reports, and interpreter and debugger output. The
result currently provided by toString is not especially helpful because it doesn&#8217;t give any clue about the
rational number&#8217;s value. A more useful implementation of toString would print out the values of
the Rational&#8217;s numerator and denominator. You can override the default implementation by adding a
method toString to class Rational, like this:
class Rational(n: Int, d: Int) {
override def toString = n + "/" + d
}
The override modifier in front of a method definition signals that a previous method definition is
overridden (more on this in Chapter 10). Since Rational numbers will display nicely now, we removed
the debug println statement we put into the body of previous version of classRational. You can test the
new behavior of Rational in the interpreter:
scala&gt; val x = new Rational(1, 3)
x: Rational = 1/3
scala&gt; val y = new Rational(5, 7)
y: Rational = 5/7
6.4 CHECKING PRECONDITIONS
As a next step, we will turn our attention to a problem with the current behavior of the primary
constructor. As mentioned at the beginning of this chapter, rational numbers may not have a zero in the
denominator. Currently, however, the primary constructor accepts a zero passed as d:
scala&gt; new Rational(5, 0)
res1: Rational = 5/0
One of the benefits of object-oriented programming is that it allows you to encapsulate data inside
objects so that you can ensure the data is valid throughout its lifetime. In the case of an immutableobject such as Rational, this means that you should ensure the data is valid when the object is
constructed. Given that a zero denominator is an invalid state for a Rationalnumber, you should not let
a Rational be constructed if a zero is passed in the d parameter.
The best way to approach this problem is to define as a precondition of the primary constructor
that d must be non-zero. A precondition is a constraint on values passed into a method or constructor, a
requirement which callers must fulfill. One way to do that is to userequire,<span class="footnote"><br />[The require method is defined in standalone object, Predef. As mentioned in Section 4.4,Predef&#8217;s members are imported automatically into every Scala source file.]<br /></span> like this:
class Rational(n: Int, d: Int) {
require(d != 0)
override def toString = n + "/" + d
}
The require method takes one boolean parameter. If the passed value is true, require will return
normally. Otherwise, require will prevent the object from being constructed by throwing
an IllegalArgumentException.
6.5 ADDING FIELDS
Now that the primary constructor is properly enforcing its precondition, we will turn our attention to
supporting addition. To do so, we&#8217;ll define a public add method on class Rationalthat takes
another Rational as a parameter. To keep Rational immutable, the add method must not add the passed
rational number to itself. Rather, it must create and return a new Rationalthat holds the sum. You might
think you could write add this way:
class Rational(n: Int, d: Int) { // This won&#8217;t compile
require(d != 0)
override def toString = n + "/" + d
def add(that: Rational): Rational =
new Rational(n * that.d + that.n * d, d * that.d)
}
However, given this code the compiler will complain:
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
<sup>
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
</sup>
Although class parameters n and d are in scope in the code of your add method, you can only access
their value on the object on which add was invoked. Thus, when you say n or d in add&#8217;s
implementation, the compiler is happy to provide you with the values for these class parameters. But it
won&#8217;t let you say that.n or that.d because that does not refer to the Rationalobject on which add was
invoked.<span class="footnote"><br />[Actually, you could add a Rational to itself, in which case that would refer to the object on which add was invoked. But because you can pass any Rational object to add, the compiler still won&#8217;t let you say that.n.]<br /></span> To access the numerator and denominator on that, you&#8217;ll need to make them into
fields. Listing 6.1 shows how you could add these fields to classRational.<span class="footnote"><br />[In Section 10.6 you&#8217;ll find out about parametric fields, which provide a shorthand for writing the same code.]<br /></span>
class Rational(n: Int, d: Int) {
require(d != 0)
val numer: Int = n}
val denom: Int = d
override def toString = numer + "/" + denom
def add(that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
Listing 6.1 - Rational with fields.
In the version of Rational shown in Listing 6.1, we added two fields named numer and denom, and
initialized them with the values of class parameters n and d.<span class="footnote"><br />[Even though n and d are used in the body of the class, given they are only used inside constructors, the Scala compiler will not emit fields for them. Thus, given this code the Scala compiler will generate a class with two Int fields, one for numer and one for denom.]<br /></span> We also changed the implementation
of toString and add so that they use the fields, not the class parameters. This version of
class Rational compiles. You can test it by adding some rational numbers:
scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; oneHalf add twoThirds
res2: Rational = 7/6
One other thing you can do now that you couldn&#8217;t do before is access the numerator and denominator
values from outside the object. Simply access the public numer and denom fields, like this:
scala&gt; val r = new Rational(1, 2)
r: Rational = 1/2
scala&gt; r.numer
res3: Int = 1
scala&gt; r.denom
res4: Int = 2
6.6 SELF REFERENCES
The keyword this refers to the object instance on which the currently executing method was invoked, or
if used in a constructor, the object instance being constructed. As an example, consider adding a
method, lessThan, which tests whether the given Rational is smaller than a parameter:
def lessThan(that: Rational) =
this.numer * that.denom &lt; that.numer * this.denom
Here, this.numer refers to the numerator of the object on which lessThan was invoked. You can also
leave off the this prefix and write just numer; the two notations are equivalent.
As an example of where you can&#8217;t do without this, consider adding a max method to classRational that
returns the greater of the given rational number and an argument:
def max(that: Rational) =
if (this.lessThan(that)) that else thisHere, the first this is redundant. You could have left it off and written: lessThan(that). But the
second this represents the result of the method in the case where the test returns false; were you to omit
it, there would be nothing left to return!
6.7 AUXILIARY CONSTRUCTORS
Sometimes you need multiple constructors in a class. In Scala, constructors other than the primary
constructor are called auxiliary constructors. For example, a rational number with a denominator of 1
can be written more succinctly as simply the numerator. Instead of 5/1, for example, you can just write
5. It might be nice, therefore, if instead of writingnew Rational(5, 1), client programmers could simply
write new Rational(5). This would require adding an auxiliary constructor to Rational that takes only
one argument, the numerator, with the denominator predefined to be 1. Listing 6.2 shows what that
would look like.
class Rational(n: Int, d: Int) {
require(d != 0)
val numer: Int = n
val denom: Int = d
def this(n: Int) = this(n, 1) // auxiliary constructor
override def toString = numer + "/" + denom
def add(that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
}
Listing 6.2 - Rational with an auxiliary constructor.
Auxiliary constructors in Scala start with def this(&#8230;). The body of Rational&#8217;s auxiliary constructor
merely invokes the primary constructor, passing along its lone argument, n, as the numerator and 1 as
the denominator. You can see the auxiliary constructor in action by typing the following into the
interpreter:
scala&gt; val y = new Rational(3)
y: Rational = 3/1
In Scala, every auxiliary constructor must invoke another constructor of the same class as its first
action. In other words, the first statement in every auxiliary constructor in every Scala class will have
the form "this(&#8230;)". The invoked constructor is either the primary constructor (as in
the Rational example), or another auxiliary constructor that comes textually before the calling
constructor. The net effect of this rule is that every constructor invocation in Scala will end up
eventually calling the primary constructor of the class. The primary constructor is thus the single point
of entry of a class.Note
If you&#8217;re familiar with Java, you may wonder why Scala&#8217;s rules for constructors are a bit more
restrictive than Java&#8217;s. In Java, a constructor must either invoke another constructor of the same class,
or directly invoke a constructor of the superclass, as its first action. In a Scala class, only the primary
constructor can invoke a superclass constructor. The increased restriction in Scala is really a design
trade-off that needed to be paid in exchange for the greater conciseness and simplicity of Scala&#8217;s
constructors compared to Java&#8217;s. Superclasses and the details of how constructor invocation and
inheritance interact will be explained in Chapter 10.
6.8 PRIVATE FIELDS AND METHODS
In the previous version of Rational, we simply initialized numer with n and denom with d. As a result,
the numerator and denominator of a Rational can be larger than needed. For example, the
fraction 66/42 could be normalized to an equivalent reduced form, 11/7, but Rational&#8217;s primary
constructor doesn&#8217;t currently do this:
scala&gt; new Rational(66, 42)
res5: Rational = 66/42
To normalize in this way, you need to divide the numerator and denominator by theirgreatest common
divisor. For example, the greatest common divisor of 66 and 42 is 6. (In other words, 6 is the largest
integer that divides evenly into both 66 and 42.) Dividing both the numerator and denominator
of 66/42 by 6 yields its reduced form, 11/7. Listing 6.3 shows one way to do this:
class Rational(n: Int, d: Int) {
require(d != 0)
private val g = gcd(n.abs, d.abs)
val numer = n / g
val denom = d / g
def this(n: Int) = this(n, 1)
def add(that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
override def toString = numer + "/" + denom
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 6.3 - Rational with a private field and method.
In this version of Rational, we added a private field, g, and modified the initializers
for numerand denom. (An initializer is the code that initializes a variable; for example, the "n / g" that
initializes numer.) Because g is private, it can be accessed inside the body of the class, but not outside.We also added a private method, gcd, which calculates the greatest common divisor of two passed Ints.
For example, gcd(12, 8) is 4. As you saw in Section 4.1, to make a field or method private you simply
place the private keyword in front of its definition. The purpose of the private "helper method" gcd is to
factor out code needed by some other part of the class, in this case, the primary constructor. To
ensure g is always positive, we pass the absolute value of n and d, which we obtain by invoking abs on
them, a method you can invoke on any Int to get its absolute value.
The Scala compiler will place the code for the initializers of Rational&#8217;s three fields into the primary
constructor in the order in which they appear in the source code. Thus, g&#8217;s initializer,gcd(n.abs, d.abs),
will execute before the other two, because it appears first in the source. Fieldg will be initialized with
the result, the greatest common divisor of the absolute value of the class parameters, n and d. Field g is
then used in the initializers of numer and denom. By dividingn and d by their greatest common
divisor, g, every Rational will be constructed in its normalized form:
scala&gt; new Rational(66, 42)
res6: Rational = 11/7
6.9 DEFINING OPERATORS
The current implementation of Rational addition is OK, but could be made more convenient to use. You
might ask yourself why you can write:
x + y
if x and y are integers or floating-point numbers, but you have to write:
x.add(y)
or at least:
x add y
if they are rational numbers. There&#8217;s no convincing reason why this should be so. Rational numbers are
numbers just like other numbers. In a mathematical sense they are even more natural than, say,
floating-point numbers.
Why should you not use the natural arithmetic operators on them? In Scala you can do this. In the rest
of this chapter, we&#8217;ll show you how.
The first step is to replace add by the usual mathematical symbol. This is straightforward, as <code>is a legal
identifier in Scala. We can simply define a method with + as its name. While we&#8217;re at it, we may as well
implement a method named * that performs multiplication. The result is shown in Listing 6.4:
class Rational(n: Int, d: Int) {
require(d != 0)
private val g = gcd(n.abs, d.abs)
val numer = n / g
val denom = d / gdef this(n: Int) = this(n, 1)
def + (that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
def * (that: Rational): Rational =
new Rational(numer * that.numer, denom * that.denom)
override def toString = numer + "/" + denom
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 6.4 - Rational with operator methods.
With class Rational defined in this manner, you can now write:
scala&gt; val x = new Rational(1, 2)
x: Rational = 1/2
scala&gt; val y = new Rational(2, 3)
y: Rational = 2/3
scala&gt; x + y
res7: Rational = 7/6
As always, the operator syntax on the last input line is equivalent to a method call. You could also
write:
scala&gt; x.</code>(y)
res8: Rational = 7/6
but this is not as readable.
Another thing to note is that given Scala&#8217;s rules for operator precedence, which were described
in Section 5.9, the * method will bind more tightly than the + method for Rationals. In other words,
expressions involving + and * operations on Rationals will behave as expected.For
example, x + x * y will execute as x + (x * y), not (x + x) * y:
scala&gt; x + x * y
res9: Rational = 5/6
scala&gt; (x + x) * y
res10: Rational = 2/3
scala&gt; x + (x * y)
res11: Rational = 5/66.10 IDENTIFIERS IN SCALA
You have now seen the two most important ways to form an identifier in Scala: alphanumeric and
operator. Scala has very flexible rules for forming identifiers. Besides the two forms you have seen
there are also two others. All four forms of identifier formation are described in this section.
An alphanumeric identifier starts with a letter or underscore, which can be followed by further letters,
digits, or underscores. The &#8216;$&#8217; character also counts as a letter; however, it is reserved for identifiers
generated by the Scala compiler. Identifiers in user programs should not contain &#8216;$&#8217; characters, even
though it will compile; if they do, this might lead to name clashes with identifiers generated by the
Scala compiler.
Scala follows Java&#8217;s convention of using camel-case identifiers,<span class="footnote"><br />[This style of naming identifiers is called camel case because the identifiersHaveHumps consisting of the embedded capital letters.]<br /></span> such
as toString andHashSet. Although underscores are legal in identifiers, they are not used that often in
Scala programs, in part to be consistent with Java, but also because underscores have many other non-
identifier uses in Scala code. As a result, it is best to avoid identifiers like to_string,<em>init</em>, or name_.
Camel-case names of fields, method parameters, local variables, and functions should start with a lower
case letter, for example: length, flatMap, and s. Camel-case names of classes and traits should start with
an upper case letter, for example: BigInt, List, and UnbalancedTreeMap.<span class="footnote"><br />[In Section 16.5, you&#8217;ll see that sometimes you may want to give a special kind of class known as a case class a name consisting solely of operator characters. For example, the Scala API contains a class named ::, which facilitates pattern matching on Lists.]<br /></span>
Note
One consequence of using a trailing underscore in an identifier is that if you attempt, for example, to
write a declaration like this, "val name_: Int = 1", you&#8217;ll get a compiler error. The compiler will think
you are trying to declare a val named "name_:". To get this to compile, you would need to insert an
extra space before the colon, as in: "val name_ : Int = 1".
One way in which Scala&#8217;s conventions depart from Java&#8217;s involves constant names. In Scala, the
word constant does not just mean val. Even though a val does remain constant after it is initialized, it is
still a variable. For example, method parameters are vals, but each time the method is called those vals
can hold different values. A constant is more permanent. For example, scala.math.Pi is defined to be the
double value closest to the real value of π, the ratio of a circle&#8217;s circumference to its diameter. This
value is unlikely to change ever; thus, Pi is clearly a constant. You can also use constants to give names
to values that would otherwise bemagic numbers in your code: literal values with no explanation,
which in the worst case appear in multiple places. You may also want to define constants for use in
pattern matching, a use case that will be described in Section 15.2. In Java, the convention is to give
constants names that are all upper case, with underscores separating the words, such
as MAX_VALUE or PI. In Scala, the convention is merely that the first character should be upper case.
Thus, constants named in the Java style, such as X_OFFSET, will work as Scala constants, but the
Scala convention is to use camel case for constants, such as XOffset.
An operator identifier consists of one or more operator characters. Operator characters are printable
ASCII characters such as +, :, ?, ~ or #.<span class="footnote"><br />[More precisely, an operator character belongs to the Unicode set of mathematical symbols(Sm) or other symbols(So), or to the 7-bit ASCII characters that are not letters, digits, parentheses, square brackets, curly braces, single or double quote, or an underscore, period, semi-colon, comma, or back tick character.]<br /></span> Here are some examples of operator identifiers:</p></div>
<div class="paragraph"><p>+
<code>+
::: &lt;?&gt;
:&#8594;The Scala compiler will internally "mangle" operator identifiers to turn them into legal Java identifiers
with embedded $ characters. For instance, the identifier :&#8594; would be represented internally
as $colon$minus$greater. If you ever wanted to access this identifier from Java code, you&#8217;d need to use
this internal representation.
Because operator identifiers in Scala can become arbitrarily long, there is a small difference between
Java and Scala. In Java, the input x&#8592;y would be parsed as four lexical symbols, so it would be
equivalent to x &lt; - y. In Scala, &#8592; would be parsed as a single identifier, giving x &#8592; y. If you want the
first interpretation, you need to separate the &lt; and the - characters by a space. This is unlikely to be a
problem in practice, as very few people would write x&#8592;y in Java without inserting spaces or
parentheses between the operators.
A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an
operator identifier. For example, unary_</code> used as a method name defines a unary <code>operator.
Or, myvar_= used as method name defines an assignment operator. In addition, the mixed identifier
form myvar_= is generated by the Scala compiler to support properties (more on that in Chapter 18).
A literal identifier is an arbitrary string enclosed in back ticks (` &#8230;<code>). Some examples of literal
identifiers are:
`x</code>
<code>&lt;clinit&gt;</code>
<code>yield</code>
The idea is that you can put any string that&#8217;s accepted by the runtime as an identifier between back
ticks. The result is always a Scala identifier. This works even if the name contained in the back ticks
would be a Scala reserved word. A typical use case is accessing the static yieldmethod in
Java&#8217;s Thread class. You cannot write Thread.yield() because yield is a reserved word in Scala.
However, you can still name the method in back ticks, e.g., Thread.<code>yield</code>().
6.11 METHOD OVERLOADING
Back to class Rational. With the latest changes, you can now do addition and multiplication operations
in a natural style on rational numbers. But one thing still missing is mixed arithmetic. For instance, you
cannot multiply a rational number by an integer because the operands of * always have to be Rationals.
So for a rational number r you can&#8217;t write r * 2. You must write r * new Rational(2), which is not as
nice.
To make Rational even more convenient, we&#8217;ll add new methods to the class that perform mixed
addition and multiplication on rational numbers and integers. While we&#8217;re at it, we&#8217;ll add methods for
subtraction and division too. The result is shown in Listing 6.5.
class Rational(n: Int, d: Int) {
require(d != 0)
private val g = gcd(n.abs, d.abs)
val numer = n / g
val denom = d / gdef this(n: Int) = this(n, 1)
def + (that: Rational): Rational =
new Rational(
numer * that.denom + that.numer * denom,
denom * that.denom
)
def + (i: Int): Rational =
new Rational(numer + i * denom, denom)
def - (that: Rational): Rational =
new Rational(
numer * that.denom - that.numer * denom,
denom * that.denom
)
def - (i: Int): Rational =
new Rational(numer - i * denom, denom)
def * (that: Rational): Rational =
new Rational(numer * that.numer, denom * that.denom)
def * (i: Int): Rational =
new Rational(numer * i, denom)
def / (that: Rational): Rational =
new Rational(numer * that.denom, denom * that.numer)
def / (i: Int): Rational =
new Rational(numer, denom * i)
override def toString = numer + "/" + denom
private def gcd(a: Int, b: Int): Int =
if (b == 0) a else gcd(b, a % b)
}
Listing 6.5 - Rational with overloaded methods.
There are now two versions each of the arithmetic methods: one that takes a rational as its argument
and another that takes an integer. In other words, each of these method names isoverloaded because
each name is now being used by multiple methods. For example, the name + is used by one method
that takes a Rational and another that takes an Int. In a method call, the compiler picks the version of an
overloaded method that correctly matches the types of the arguments. For instance, if the
argument y in x.</code>(y) is a Rational, the compiler will pick the method + that takes a Rational parameter.
But if the argument is an integer, the compiler will pick the method + that takes an Int parameter
instead. If you try this:
scala&gt; val x = new Rational(2, 3)
x: Rational = 2/3
scala&gt; x * x
res12: Rational = 4/9
scala&gt; x * 2res13: Rational = 4/3
You&#8217;ll see that the * method invoked is determined in each case by the type of the right operand.
Note
Scala&#8217;s process of overloaded method resolution is very similar to Java&#8217;s. In every case, the chosen
overloaded version is the one that best matches the static types of the arguments. Sometimes there is no
unique best matching version; in that case the compiler will give you an "ambiguous reference" error.
6.12 IMPLICIT CONVERSIONS
Now that you can write r * 2, you might also want to swap the operands, as in 2 * r. Unfortunately this
does not work yet:
scala&gt; 2 * r
&lt;console&gt;:10: error: overloaded method value * with
alternatives:
(x: Double)Double &lt;and&gt;
(x: Float)Float &lt;and&gt;
(x: Long)Long &lt;and&gt;
(x: Int)Int &lt;and&gt;
(x: Char)Int &lt;and&gt;
(x: Short)Int &lt;and&gt;
(x: Byte)Int
cannot be applied to (Rational)
2 * r
^
The problem here is that 2 * r is equivalent to 2.*(r), so it is a method call on the number 2, which is an
integer. But the Int class contains no multiplication method that takes a Rationalargument—it couldn&#8217;t
because class Rational is not a standard class in the Scala library.
However, there is another way to solve this problem in Scala: You can create an implicit conversion
that automatically converts integers to rational numbers when needed. Try adding this line in the
interpreter:
scala&gt; implicit def intToRational(x: Int) = new Rational(x)
This defines a conversion method from Int to Rational. The implicit modifier in front of the method
tells the compiler to apply it automatically in a number of situations. With the conversion defined, you
can now retry the example that failed before:
scala&gt; val r = new Rational(2,3)
r: Rational = 2/3
scala&gt; 2 * r
res15: Rational = 4/3
For an implicit conversion to work, it needs to be in scope. If you place the implicit method definition
inside class Rational, it won&#8217;t be in scope in the interpreter. For now, you&#8217;ll need to define it directly in
the interpreter.As you can glimpse from this example, implicit conversions are a very powerful technique for making
libraries more flexible and more convenient to use. Because they are so powerful, they can also be
easily misused. You&#8217;ll find out more on implicit conversions, including ways to bring them into scope
where they are needed, in Chapter 21.
6.13 A WORD OF CAUTION
As this chapter has demonstrated, creating methods with operator names and defining implicit
conversions can help you design libraries for which client code is concise and easy to understand. Scala
gives you a great deal of power to design such easy-to-use libraries. But please bear in mind that with
power comes responsibility.
If used unartfully, both operator methods and implicit conversions can give rise to client code that is
hard to read and understand. Because implicit conversions are applied implicitly by the compiler, not
explicitly written down in the source code, it can be non-obvious to client programmers what implicit
conversions are being applied. And although operator methods will usually make client code more
concise, they will only make it more readable to the extent client programmers will be able to recognize
and remember the meaning of each operator.
The goal you should keep in mind as you design libraries is not merely enabling concise client code,
but readable, understandable client code. Conciseness will often be a big part of that readability, but
you can take conciseness too far. By designing libraries that enable tastefully concise and at the same
time understandable client code, you can help those client programmers work productively.
6.14 CONCLUSION
In this chapter, you saw more aspects of classes in Scala. You saw how to add parameters to a class,
define several constructors, define operators as methods, and customize classes so that they are natural
to use. Maybe most importantly, you saw that defining and using immutable objects is a quite natural
way to code in Scala.
Although the final version of Rational shown in this chapter fulfills the requirements set forth at the
beginning of the chapter, it could still be improved. We will in fact return to this example later in the
book. For example, in Chapter 30, you&#8217;ll learn how to override equals andhashcode to allow Rationals
to behave better when compared with == or placed into hash tables. In Chapter 21, you&#8217;ll learn how to
place implicit method definitions in a companion object forRational, so they can be more easily placed
into scope when client programmers are working with Rationals.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-27 23:55:23 EET
</div>
</div>
</body>
</html>
