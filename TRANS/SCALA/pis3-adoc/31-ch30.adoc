include::headers.adoc[]

Глава 30
--------

Еквівалентність об'єктів
========================

Порівняння двох об'єктів на еквівалентність є наріжним в програмуванні. Воно більш заплутане, ніж здається на перший погляд. Ця глава дає погляд на еквівалентність в деталях, та дає деякі рекомендації для розгляду, коли ви розробляєте ваші власні тести еквівалентності.

30.1 Еквівалентність в Scala
----------------------------
Як зазначалось в Розділі 11.2, визначення еквівалентності є різне в Scala та Java. Java має два порівняння на еквівалентність: оператор `==`, що є природною рівністю для типів значення та ідентичності об'єктів для типів посилань, та метод `equals`, що є  (визначена користувачем) канонічна еквівалентність для типів посилань. Ця домовленість є проблематичною, оскільки більш природний символ `==` не завжди відповідає до природної нотації еквівалентності. При програмуванні на Java загальна пастка для початківців є порівняння об'єктів за допомогою `==`, коли вони мають порівнюватись за допомогою `equals`. Наприклад, порівняння двох рядків `x` та `y` з використанням `x == y` може дати `false` в Java, навіть якщо `x` та `y` мають ті самі символи в тому ж порядку.

Scala також має метод еквівалентності, що означає ідентичність об'єктів, але він використовується не часто. Цей різновид еквівалентності, що записується `x eq y`, є `true`, якщо `x` та `y` посилаються на той самий об'єкт. Еквівалентність `==` зарезервована в Scala для "природної" еквівалентності кожного типу. Для типів значень `==` є порівняння значень, так само, як в Java. Для типів посилань `==` є те саме, що `equals` в Java. Ви можете перевизначити поведінку `==` для нових типів через перевизначення метода `equals`, що завжди наслідується від класу `Any`. Наслідуване `equals`, що набуває сили якщо не перекрите, є ідентичність об'єкта, як це відбувається в Java. Так що `equals` (та разом і `==`) по замовчанню те саме, що і `eq`, але ви можете змінити його поведінку через перекриття метода `equals` в класі, що ви визначаєте. Неможливо перекрити `==` напряму, бо це визначене як фінальний метод в класі `Any`. Тобто Scala трактує `==` якби воно було визначене наступним чином в класі `Any`:
[source,scala]
----
final def == (that: Any): Boolean =
  if (null eq this) {null eq that} else {this equals that}
----

30.2 Написання метода еквівалентності
-------------------------------------
Як має бути визначений метод `equals`? З'ясовується, що написання коректного метода еквівалентності є несподівано складним в об'єктно орієнтованих мовах. Фактично, після вивчення великого обсягу Java коду, автори документу 2007 прийшли до висновку, що майже всі реалізації метода `equals` невдалі.footnote:[Vaziri, et. al., "Declarative Object Identity Using Relation Types" [Vaz07\]] Це проблематично, бо еквівалентність є базисом багатьої інших речей. Для початку, хибний метод еквівалентності для типу `C` може означати, що ви не можете надійно покласти об'єкт типу `C` до колекції.

Наприклад, ви можете мати два елементи, `elem1` та `elem2`, типу `C`, що еквівалентні (тобто, `elem1 equals elem2` дає `true`). Тим не менше, з загально зустріваною хибною реалізацією метода `equals` ви можете все ще бачити поведінку, подібну до такої:
[source,scala]
----
var hashSet: Set[C] = new collection.immutable.HashSet
hashSet += elem1
hashSet contains elem2 // повертає false!
----
Ось чотири загальні пастки,footnote:[Всі крім третьої описані і контексті Java в книзі Effective Java Second Edition, by Joshua Bloch. [Blo08\]] що можуть спричинити неузгоджену поведінку при перекритті `equals`:

1. Визначення `equals` з помилковою сигнатурою.

2. Зміна `equals` без одночасної зміни `hashCode`.

3. Визначення `equals` в термінах змінних полів.

4. Схиблене визнечення `equals` як відношення еквівалентності.

Ці чотири пастки дискутуються в залишку цього розділу. 

Пастка #1: Визначення `equals` з помилковою сигнатурою 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Розглянемо додавання метода еквівалентності до наступного класу простих точок:
[source,scala]
----
class Point(val x: Int, val y: Int) { ... }
----
Майже очевидний, але невірний шлях буде визначити це так:
[source,scala]
----
// Повністю невірне визначення `equals`
def equals(other: Point): Boolean =
  this.x == other.x && this.y == other.y
----
Що не так з цім методом? На перший погляд здається, що все робить OK:
[source,scala]
----
scala> val p1, p2 = new Point(1, 2)
p1: Point = Point@37d7d90f
p2: Point = Point@3beb846d

scala> val q = new Point(2, 3)
q: Point = Point@e0cf182

scala> p1 equals p2
res0: Boolean = true

scala> p1 equals q
res1: Boolean = false
----
Однак проблеми починаються, як тільки ви починаєте покладати точки до колекції:
[source,scala]
----
scala> import scala.collection.mutable
import scala.collection.mutable

scala> val coll = mutable.HashSet(p1)
coll: scala.collection.mutable.HashSet[Point] =
Set(Point@37d7d90f)

scala> coll contains p2
res2: Boolean = false
----
Як пояснити, що `coll` не містить `p2`, навіть якщо `p1` був доданий до неї, та `p1` та `p2` еквівалентні об'єкти? Причина явно полягає в наступній ітерації, де точний тип однієї з порівнюваних точок замаскований. Визначте `p2a` як псевдоним `p2`, але з типом `Any` замість `Point`:
[source,scala]
----
scala> val p2a: Any = p2
p2a: Any = Point@3beb846d
----
Тепер, коли ви повторите перше порівняння, але з псевдонимом `p2a` замість `p2`, ви отримаєте:
[source,scala]
----
scala> p1 equals p2a
res3: Boolean = false
----
Що не так? Версія `equals`, надана до цього, не перекриває стандартний метод `equals`, оскільки її тип інший. Ось тип метода `equals`, як він визначений в кореневому класі `Any`:footnote:[Якщо ви багато пишете на Java, ви можете очікувати, що аргумент цього метода буде типу `Object`, замість типу `Any`. Не турбуйтесь про це; це той самий метод `equals`. Компілятор просто робить що воно виглядає як тип `Any`.]
[source,scala]
----
def equals(other: Any): Boolean
----
Оскільки метод `equals` в `Point` приймає `Point` замість `Any` як аргумент, він не перекриває `equals` в `Any`. Замість цього він просто є перевантаженою альтернативою. Тепер, перевантаження в Scala та в Java розрішене статичним типом аргумента, не типом часу виконання. Так що доки статичний тип аргумента є `Point`, буде викликатись метод `equals` в `Point`. Однак як тільки статичний аргумент стає типу `Any`, замість цього починає викликатись метод `equals` в Any. Цей метод не був перекритий, так що він досі реалізований через порівняння ідентичності об'єктів.

Ось чому порівняння  `p1 equals p2a` дає `false`, навіть якщо точки `p1` та `p2a` мають ті самі значення `x` та `y`. Ось чому метод `contains` в `HashSet` повертає `false`. Оскільки цей метод оперує на дженерік множинах, він викликає дженерік метод `equals` в `Object`, замість перевантаженого варіанта в `Point`. Ось кращий метод `equals`:
[source,scala]
----
// Краще визначення, але все ще не ідеальне
override def equals(other: Any) = other match {
  case that: Point => this.x == that.x && this.y == that.y
  case _ => false
}
----
Тепер `equals` має коректний тип. Він приймає значення типу `Any` як параметр, та дає результат `Boolean`. Реалізація цього метода використовує порівняння шаблонів. Спочатку він перевіряє, чи об'єкт також є типу `Point`. Якщо це так, він порівнює координати двох точок, та повертає результат. Інакше результат `false`.

Пов'язана пастка є визначити `==` з невірноє сигнатурою. Нормально, якщо ви намагаєтесь перевизначити `==` з коректною сигнатурою, що приймає аргумент типу `Any`, компілятор буде давати вам помилку, оскільки ви намагаєтесь переписати фінальний метод типу `Any`.

Новачки в Scala іноді роблять дві помилки разом: вони намагаються перекрити `==`, і вони дають невірну сигнатуру. Наприклад:
[source,scala]
----
def ==(other: Point): Boolean = // Не робіть цього!
----
В цьому випадку визначений користувачем метод `==` трактується як перевантажений варіант так само названого метода з класа `Any`, і програма компілюється. Однак поведінка програми буде такою ж сумнівною, якби ви визначили `equals` з невірною сигнатурою.

Пастка #2: Зміна `equals` без одночасної зміни `hashCode`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ми будемо продовжувати використовувати приклад з пастки #1. Якщо ви продовжите порівняння `p1` та `p2a` з останнім визначенням `Point`, ви отримаєте `true`, як очікувалось. Однак якщо ми повторимо перевірку `HashSet.contains`, ви будете вірогідно все ще отримувати `false`:
[source,scala]
----
scala> val p1, p2 = new Point(1, 2)
p1: Point = Point@122c1533
p2: Point = Point@c23d097

scala> collection.mutable.HashSet(p1) contains p2
res4: Boolean = false
----
Але цей результат не на 100% певний. Ви можете також отримати `true` в простому експерименті. Якщо ви зробите це, ви можете спробувати деякі інші точки з координатами 1 та 2. З часом ви отримаєте таку, що не містилась в множині. Що тут не так, це те, що `Point` перевизначає `equals`, при цьому також не перевизначаючи `hashCode`.

Зауважте, що колекція в прикладі є `HashSet`. Це означає, що елементи колекції покладаються в "хеш ьакети", що визначаються їх хеш кодом. Перевірка `contains` спершу визначає хеш бакет, де дивитись, та потім порівнює надані елементи з усіма елементами в бакеті. Тепер, остання версія класу `Point` перевизначила `equals`, але вона в той же час не перевизначила `hashCode`. Так що `hashCode` все ще той, що був в версії для класа `AnyRef`: деяка трансформація адреси розміщеного об'єкта.

Хеш коди `p1` та `p2` майже напевне різні, навіть якщо поля обох точок однакові. Різні хеш коди означають, з великою вірогідністю, різні хеш бакети в множині. Перевірка `contains` буде шукати співпадаючий елемент в бакеті, що відповідає до хеш коду `p2`. В більшості випадків точка `p1` буде в іншому бакеті, так що вона ніколи не буде знайдена. `p1` та `p2` можуть також з вірогідністю попасти в той самий хеш бакет. В цьому випадку перевірка поверне `true`. Проблема в тому, що остання реалізація `Point` порушує контракт на `hashCode`, як визначено для класа `Any`:footnote:[Текст контракту `Any` `hashCode` надихнено документацією Javadoc класу `java.lang.Object`.]

  Якщо два класи еквівалентні відповідно до метода `equals`, тоді виклик `hashCode` на кожному з двох об'єктів має продукувати той самий цілий результат.

Фактично, це добре відомо в Java, що `hashCode` та `equals` повинні завжди бути перевизначені разом. Більше того, `hashCode` можу залежати тільки від полів, на які покладається `equals`. Для класа `Point` наступне може бути підходящим визначенням `hashCode`:
[source,scala]
----
class Point(val x: Int, val y: Int) {
  override def hashCode = (x, y).##
  override def equals(other: Any) = other match {
    case that: Point => this.x == that.x && this.y == that.y
    case _ => false
  }
}
----
Це тільки одне з багатьох можливих реалізацій `hashCode`. Нагадаємо, що метод `##`є скороченням для обчислення хеш кодів, що роблять з примітивними значеннями, типами посилань та `null`. Коли викликається на колекції або таплі, він обчислює змішаний хеш, що чутливий до хеш кодів всіх елементів в колекції. Ми запровадимо більше настанов по написанню  `hashCode` пізніше в цій главі.

Додавання `hashCode` лагодить проблему еквівалентності, коли визначаються класи як `Point`; однак є інші проблемні місця, до яких треба придивитись.

Пастка #3: Визначення `equals` в термінах змінних полів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Розглянемо наступну невелику варіацію класу `Point`:
[source,scala]
----
class Point(var x: Int, var y: Int) { // Проблематично
  override def hashCode = (x, y).##
  override def equals(other: Any) = other match {
    case that: Point => this.x == that.x && this.y == that.y
    case _ => false
  }
}
----
Єдина відмінність в тому, що поля `x` та `y` тепер `var` замість `val`. Методи `equals` та `hashCode` тепер визначені в термінах ціх змінних полів, так що їх результати змінюються, коли змінюються поля. Це може мати дивний ефект, коли ваші точки потраплять до колекції:
[source,scala]
----
scala> val p = new Point(1, 2)
p: Point = Point@5428bd62

scala> val coll = collection.mutable.HashSet(p)
coll: scala.collection.mutable.HashSet[Point] =
Set(Point@5428bd62)

scala> coll contains p
res5: Boolean = true
----
Тепер, якщо ви зміните поле в `p`, чи буде колекція все ще містити точку? Ми спробуємо це:
[source,scala]
----
scala> p.x += 1

scala> coll contains p
res7: Boolean = false
----
Це виглядає дивно. Куди зникла `p`? Більше дивини буде, якщо ви перевірите, чи ітератор по множині містить `p`:
[source,scala]
----
scala> coll.iterator contains p
res8: Boolean = true
----
Так що тут множина, що не містить `p`, але `p` є серед елементів множини! Що трапилось, це те, що після зміни поля `x`, точка `p` залишилась з невірним хеш бакетом в множині `coll`. Тобто, її оригінальний хеш бакет більше не відповідає до нового значення її хеш коду. Кажучи розмовною мовою, точка `p` "випала з поля зору" в множині `coll`, навіть якщо вона все ще належить до її елементів.

Урок, що треба винести з цього прикладу, в тому, що коли `equals` та `hashCode` залежать від змінного стану, це призводить до проблем для потенційних користувачів. Якщо ви покладете такі об'єкти до колекцій, ви маєте бути уважними, щоб ніколи не модифікувати цей стан, і це складно. Якщо вам треба порівняння, що приймає до уваги поточний стан об'єкта, вам слідує назвати це якось інакше, не `equals`.

Розглядаючи останнє визначення `Point`, можливо буде мати вигоду оминути перевизначення `hashCode`, та назвати метод порівняння `equalContents` або деяким ішим ім'ям, відмінним від `equals`. Після цього `Point` буде наслідувати реалізацію по замовчанню `equals` та `hashCode`; `p` буде шукатись в `coll` навіть після модифікацій до його поля `x`.

Пастка #4: Схиблене визнечення `equals` як відношення еквівалентності
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Контракт метода `equals` в `scala.Any` вказує, що `equals` має реалізувати відношення еквівалентності на не-`null` об'єктах:footnote:[Як з `hashCode`, контракт `Any` для метода `equals` базується на контракті метода equals в `java.lang.Object`.]

* Він рефлексивний: Для любого не-`null` значення `x` вираз `x.equals(x)` повинен повертати `true`.

* Він симетричний: для любих не-`null` значень `x` та `y`, `x.equals(y)` повинно повертати `true` тоді і тільки тоді, якщо `y.equals(x)` повертає `true`.

* Він транзитивний: для любих не-`null` значень `x`, `y`, та `z`, якщо `x.equals(y)` повертає `true`, та `y.equals(z)` повертає `true`, тоді `x.equals(z)` повинно повертати `true`.

* Він узгоджений: для любих не-`null` значень `x` та `y`, декілька викликів `x.equals(y)` повинно узгоджено повертати `true`, або узгоджено повертати `false`, вважаючи, що інформація, яка використовувалась для порівнянь не змінювалась.

* Для кожного не-`null` значення `x`, `x.equals(null)` повинно повертати `false`.

Визначення `equals`, розроблене для класа `Point` дотепер, задовільняє контракту для `equals`. Однак речі стають складнішими, коли прийняти до уваги субкласи. Скажімо, існує субклас `ColoredPoint` від `Point`, що додає поле `color` типу `Color`. Нехай `Color` визначений як перелік, як представлено в Розділі 20.9:
[source,scala]
----
object Color extends Enumeration {
  val Red, Orange, Yellow, Green, Blue, Indigo, Violet = Value
}
----
`ColoredPoint` перекриває `equals`, щоб прийняти до уваги нове поле `color`:
[source,scala]
----
class ColoredPoint(x: Int, y: Int, val color: Color.Value)
    extends Point(x, y) { // Пробелма: equals не симетричне

  override def equals(other: Any) = other match {
    case that: ColoredPoint =>
      this.color == that.color && super.equals(that)
    case _ => false
  }
}
----
Це те, що більшість програмістів скоріше всього напишуть. Зауважте, що в цьому випадку клас `ColoredPoint` не повинен перекрити `hashCode`. Оскільки нове визначення `equals` на `ColoredPoint` суворіше, ніж перекрите визначення в `Point` (що означає, що воно прирівняє меньшу кількість об'єктів), контракт для `hashCode` залишається валідним. Якщо дві кольорові точки еквівалентні, вони повинні мати ті самі координати, так що їх хеш коди також гарантовано рівні.

Беручи сам клас `ColoredPoint`, його визначення `equals` виглядає OK. Однак контракт для `equals` ламається, як тільки точки і кольорові точки змішуються. Розглянемо:
[source,scala]
----
scala> val p = new Point(1, 2)
p: Point = Point@5428bd62

scala> val cp = new ColoredPoint(1, 2, Color.Red)
cp: ColoredPoint = ColoredPoint@5428bd62

scala> p equals cp
res9: Boolean = true

scala> cp equals p
res10: Boolean = false
----
Порівняння `p equals cp` викликає метод `p.equals`, що визначений в класі `Point`. Цей метод приймає до уваги тільки координати двох точок. Як слідоцтво, порівняння дає `true`. З іншого боку, порівняння `cp equals p` викликає метод `cp.equals`, що визначений в класі `ColoredPoint`. Цей метод повертає `false`, оскільки `p` не є `ColoredPoint`. Так що відношення, визначене `equals`, не є симетричним.

Втрата симетрії може мати неочікувані наслідки для колекцій. Ось приклад:
[source,scala]
----
scala> collection.mutable.HashSet[Point](p) contains cp
res11: Boolean = true

scala> collection.mutable.HashSet[Point](cp) contains p
res12: Boolean = false
----
Навіть якщо `p` та `cp` рівні, одна перевірка `contains` буде успішна, та інша невдала:

Як ви можете змінити визначення `equals`, так щоб він став симетричний? В основному є два шляхи. Ви можете або зробити відношення більш загальним, або більш суворим. Створення його більш загальним означає, що пара з двох об'єктів, `x` та `y`, має вважатись рівними, якщо любе з порівнянь `x` до `y`, або `y` до `x`, дасть `true`. Ось код що робить це:
[source,scala]
----
class ColoredPoint(x: Int, y: Int, val color: Color.Value)
    extends Point(x, y) { // Проблема: equals не транзитивне

  override def equals(other: Any) = other match {
    case that: ColoredPoint =>
      (this.color == that.color) && super.equals(that)
    case that: Point =>
      that equals this
    case _ =>
      false
  }
}
----
Нове визначення `ColoredPoint` має один додатковий `case`, ніж старе: якщо об'єкт `other` є `Point`, але не `ColoredPoint`, метод відсилає до метода `equals` в `Point`. Це має бажаний ефект, що робить `equals` симетричним. Тепер обоє, `cp equals p` та `p equals cp` дають `true`. Однак контракт для `equals` все ще поломаний. Проблема в тому, що нове відношення більше не транзитивне!

Ось послідовність тверджень, що демонструють це. Визначте точку і дві кольорові точки різного кольору, всі з однаковими координатами:
[source,scala]
----
scala> val redp = new ColoredPoint(1, 2, Color.Red)
redp: ColoredPoint = ColoredPoint@5428bd62

scala> val bluep = new ColoredPoint(1, 2, Color.Blue)
bluep: ColoredPoint = ColoredPoint@5428bd62
----
Взяті окремо, `redp` рівне до `p`, та `p` рівне до `bluep`:
[source,scala]
----
scala> redp == p
res13: Boolean = true

scala> p == bluep
res14: Boolean = true
----
Однак порівняння `redp` та `bluep` дає `false`:
[source,scala]
----
scala> redp == bluep
res15: Boolean = false
----
Таким чином, твердження транзитивності контракту `equals` порушене.

Створення відношення `equals` більш загальним, здається, призводить до глухого кута. Ми спробуємо зробити його замість цього суворішим. Один спосіб зробити `equals` суворішим - це завжди вприймати об'єкти різних типів як різні. Цього можна досягти, можифікуючи методи `equals` в класах `Point` та `ColoredPoint`. В класі `Point` ви можете додати додаткове порівняння, що перевіряє, чи клас часу виконання іншої `Point` точно такий самий, як і в класа цієї `Point`:
[source,scala]
----
// Технічно валідний, але незадовільний метод equals
class Point(val x: Int, val y: Int) {
  override def hashCode = (x, y).##
  override def equals(other: Any) = other match {
    case that: Point =>
      this.x == that.x && this.y == that.y &&
          this.getClass == that.getClass
    case _ => false
  }
}
----
Тепер ви можете відкатити реалізацію класа `ColoredPoint` назад до версії, що перед цім порушувала вимогу симетричності:footnote:[Маючи нову реалізацію `equals` в `Point`, ця версія `ColoredPoint` більше не порушує вимогу симетрії.]
[source,scala]
----
class ColoredPoint(x: Int, y: Int, val color: Color.Value)
    extends Point(x, y) {

  override def equals(other: Any) = other match {
    case that: ColoredPoint =>
      (this.color == that.color) && super.equals(that)
    case _ => false
  }
}
----
Тут примірник класу `Point` визнається рівним до деякого іншого примірника того самого класу, тільки якщо об'єкти мають ті самі координати, та вони мають той клас часу виконання, що означає, що `getClass` на кожному об'єкті поверне те саме значення. Нові визначення задовільняють симетрії та транзитивності, оскільки тепер кожне порівняння між об'єктами різних класів дає `false`. Так що кольорова точка ніколи не буде рівна точці. Ця домовленість виглядає логічною, але ви можете сказати, що нове обмеження дуже суворе.

Розглянеом наступний обхідний шлях визначити точку з координатами `(1, 2)`:
[source,scala]
----
scala> val pAnon = new Point(1, 1) { override val y = 2 }
pAnon: Point = $anon$1@5428bd62
----
Чи `pAnon` рівне до `p`? Відповідь є ні, оскільки об'єкти `java.lang.Class`, асоційовані з `p` та `pAnon` є різні. Для `p` це `Point`, тоді як для `pAnon` це анонімний субклас `Point`. Але ясно, що `pAnon` є тільки нова точка з координатами `(1, 2)`. Не виглядає логічним розглядати її як іншу, ніж `p`.

Виглядає що ми буксуємо. Чи існує розумний спосіб перевизначити еквівалентність на декількох рівнях ієрархії класів, при цьому дотримуючись контракту? Фактично, існує такий метод, але він потребує одночасного перевизначення ще одного метода разом з `equals` та `hashCode`. Ідея в тому, що як тільки клас перевизначає `equals` (та `hashCode`), він також має явно встановити, що об'єкти цього класу ніколи не рівні до об'єктів деякого суперкласу, що реалізує інший метод еквівалентності. Це досягається додаванням методу `canEqual` до кожного класу, що перевизначає `equals`. Ось сигнатура метода:
[source,scala]
----
def canEqual(other: Any): Boolean
----
Метод повинен повертати `true`, якщо інший об'єкт є примірником класу, в якому `canEqual` є (пере)визначеним, інакше `false`. Він викликається з `equals`, щоб переконатись, що об'єкти можна порівняти в обох напрямках. Лістинг 30.1 показує нову (та фінальну) реалізацію класу `Point`, разом з ціма рядками:
[source,scala]
----
class Point(val x: Int, val y: Int) {
  override def hashCode = (x, y).##
  override def equals(other: Any) = other match {
    case that: Point =>
      (that canEqual this) &&
          (this.x == that.x) && (this.y == that.y)
    case _ =>
      false
  }
  def canEqual(other: Any) = other.isInstanceOf[Point]
}
----
Лістинг 30.1 - Метод суперкласа `equals`, що викликає `canEqual`.

Метод `equals` в цій версії класу `Point` містить додаткову вимогу, щоб об'єкт `other` міг бути еквівалентним до `this`, як визначено в методі `canEqual`. Реалізація `canEqual` в `Point` стверджує, що всі примірники `Point` можуть бути рівними.

Лістинг 30.2 показує відповідну реалізацію `ColoredPoint`.
[source,scala]
----
class ColoredPoint(x: Int, y: Int, val color: Color.Value)
    extends Point(x, y) {

  override def hashCode = (super.hashCode, color).##
  override def equals(other: Any) = other match {
    case that: ColoredPoint =>
      (that canEqual this) &&
          super.equals(that) && this.color == that.color
    case _ =>
      false
  }
  override def canEqual(other: Any) =
    other.isInstanceOf[ColoredPoint]
}
----
Лістинг 30.2 - Метод субкласу `equals`, що викликає `canEqual`.

Може бути показане, що нове визначення `Point` та `ColoredPoint` дотрумуються контракту для `equals`. Еквівалентність є симетричною та транзитивною. Порівняння `Point` з `ColoredPoint` завжди дає `false`. Зрозуміло, що для кожної точки `p` та кольорової точки `cp`, `p equals cp` буде повертати `false`, оскільки `cp canEqual p` буде повертати `false`. Зворотнє порівняння `cp equals p` буде також повертати `false`, оскільки `p` не є `ColoredPoint`, так що перше співпадіння шаблонів в тілі `equals` в `ColoredPoint` схибить.

З іншого боку, примірники різних субкласів `Point` можуть бути рівні, доти, докі ніякий з субкласів не перевизначає метод рівності. Наприклад, з повим визначенням класу, порівняння `p` та `pAnon` даватиме `true`. Ось деякі приклади:
[source,scala]
----
scala> val p = new Point(1, 2)
p: Point = Point@5428bd62

scala> val cp = new ColoredPoint(1, 2, Color.Indigo)
cp: ColoredPoint = ColoredPoint@e6230d8f

scala> val pAnon = new Point(1, 1) { override val y = 2 }
pAnon: Point = $anon$1@5428bd62

scala> val coll = List(p)
coll: List[Point] = List(Point@5428bd62)

scala> coll contains p
res16: Boolean = true

scala> coll contains cp
res17: Boolean = false

scala> coll contains pAnon
res18: Boolean = true
----
Ці приклади демонструють, що якщо реалізація `equals` суперкласа визначає та викликає `canEqual`, тоді програмісти, що реалізують субкласи можуть вирішувати, зможе чи ні примірник їхнього субкласу бути рівний примірникам суперкласу. Наприклад, оскільки `ColoredPoint` перекриває `canEqual`, кольорова точка ніколи не може бути рівною до простої старої точки. Але оскільки анонімний субклас, на який посилається `pAnon` не перекриває `canEqual`, його примірник може бути рівним до примірника `Point`.

Одне з потенційних зауважень підходу `canEqual` в тому, що він порушує Принцип Підстановки Ліскова (LSP). Наприклад, техніка реалізації `equals` через порівняння типів часу виконання, що призводить до неможливості визначити субклас, чиї примірники можуть бути рівні примірникам суперкласу, була описана як порушення LSP.footnote:[Bloch, Effective Java Second Edition, p. 39 [Blo08\]] LSP стверджує, що повинна бути можливість використовувати (підставляти) примірники субкласів, там, де потрібні примірники суперкласа.

Однак в попередньому прикладі `coll contains cp` повертає `false`, навіть якщо в `cp` значення `x` та `y` співпадають з такими для точки в колекції. Таким чином, це може виглядати як порушення LSP, оскільки ви не можете використовувати `ColoredPoint` там, де очікувався `Point`. Ми віримо, що це помилкова інтерпретація, оскільки LSP не вимагає, щоб субклас поводився ідентично до своїх суперкласів, а тільки щоб він поводився так, щоб задовільняти контракту свого суперкласу.

Проблема з написанням метода `equals`, що порівнює класи часу виконання не в тому, що він порушує LSP, але в тому, що він не дає вам спосіб створити субклас, чиї примірники можуть бути еквівалентні примірникам суперкласу. Наприклад, як ми використовували техніку рантайм класів в попередньому прикладі, `coll contains pAnon` мало б повертати `false`, але не те, чого ми б хотіли. Для контрасту, ми реально хочемо, щоб `coll contains cp повертав `false`, оскільки через перекриття `equals` в `ColoredPoint` ми в основному кажемо, що точка кольору індіго з координатами `(1, 2)` не те саме, що некольорова точка `(1, 2)`. Таким чином, в попередньому прикладі ми були в змозі передати два різні примірники субкласа `Point` до метода `contains`, та ми отримали назад дві різні відповіді, обоє коректні.

30.3 Визначення параметрів для параметризованих типів
-----------------------------------------------------
В методі `equals` в попередніх прикладах все починалось з шаблона порівняння, що перевіряв, чи тип операнда відповідав типу класу, що містить метод `equals`. Коли класи параметризовані, ця схема потребує невеликої адаптації.

Як приклад розглянемо бінарні дерева. Ієрархія класів, показана на Лістингу 30.3 визначає абстрактний клса `Tree` для бінарного дерева, з двома альтернативними реалізаціями: об'єкт `EmptyTree`, та клас `Branch`, що представляє непорожні дерева. Непорожне дерево складається з деякого елемента `elem`, та лівого та правого дочірніх дерев. Тип цього елементу береться з параметру типу `T`.
[source,scala]
----
trait Tree[+T] {
  def elem: T
  def left: Tree[T]
  def right: Tree[T] 
}

object EmptyTree extends Tree[Nothing] {
  def elem =
    throw new NoSuchElementException("EmptyTree.elem")
  def left =
    throw new NoSuchElementException("EmptyTree.left")
  def right =
    throw new NoSuchElementException("EmptyTree.right")
}

class Branch[+T](
  val elem: T,val left: Tree[T],
  val right: Tree[T]
) extends Tree[T]
----  
Лістинг 30.3 - Ієрархія для бінарних дерев.

Тепер ми додамо методи `equals` та `hashCode` до ціх класів. Для самого класу `Tree` нічого робити, оскільки ми вважаємо, що ці методи реалізовані окремо для кожної реалізації абстрактного класу. Для об'єкту `EmptyTree` все ще нічого робити, оскільки реалізація по замовчанню для `equals` та `hashCode`, які `EmptyTree` наслідує від `AnyRef`, роблять чудово. Кінець кінцем, `EmptyTree` единий буде рівний сам собі, так що еквівалентність буде посилатись на ідентичність, що наслідується від `AnyRef`.

Але додавання `equals` та `hashCode` до `Branch` потребує деякої роботи. Значення `Branch` має бути рівне тільки іншим значенням `Branch`, та тільки в тому випадку, якщо два значення мають рівні поля `elem`, `left` та `right`. Буде природним застосувати схему для `equals`, що була розроблена в попередніх розділах цієї глави. Це дасть вам:
[source,scala]
----
class Branch[T](
  val elem: T,
  val left: Tree[T],
  val right: Tree[T]
) extends Tree[T] {

  override def equals(other: Any) = other match {
    case that: Branch[T] => this.elem == that.elem &&
                            this.left == that.left &&
                            this.right == that.right
    case _ => false
  }
}
----
Однак компіляція цього прикладу дає позначку, що виникло попередження "unchecked". Нова компіляція з опцією -unchecked викриває наступну проблему:
[source,scala]
----
$ fsc -unchecked Tree.scala
Tree.scala:14: warning: non variable type-argument T in type
pattern is unchecked since it is eliminated by erasure
    case that: Branch[T] => this.elem == that.elem &&
               ^
----
Як каже попередження, існує порівняння шаблонів щодо типу `Branch[T]`, але вивтема може тільки перевірити, що інше посилання є (деяким різновидом) `Branch`; вона не може перевірити, що тип елементу дерева є `T`. В Главі 19 ви зустрічали причину цього: типи елементів параметризованих типів видаляються на фазі затирання компілятора; вони недоступні для інспекції під час виконання.

Так що ми можемо зробити? Нащастя, з'ясовується, що вам не обов'язково перевіряти, що два `Branch` мають той самий тип елементів при їх порівнянні. Досить можливо, що два `Branch` з різними типами елементів рівні, доки їх поля такі самі. Простий приклад цього може бути `Branch`, що складається з одного елементу `Nil` та двох порожніх субдерев. Прийнятно вважати любі два таких  `Branch` як рівні, не важливо, які статичні типи вони мають:
[source,scala]
----
scala> val b1 = new Branch[List[String]](Nil,
           EmptyTree, EmptyTree)
b1: Branch[List[String]] = Branch@9d5fa4f

scala> val b2 = new Branch[List[Int]](Nil,
           EmptyTree, EmptyTree)
b2: Branch[List[Int]] = Branch@56cdfc29

scala> b1 == b2
res19: Boolean = true
----
Позитивний результат порівняння вище було отримане від реалізації `equals` на `Branch`, показаної до цього. Це демонструє, що тип елементу `Branch` не був перевірений — якщо б він був перевірений, результатом мало б бути `false`.

Ми можемо не погоджуватись, який з двох результатів буде більш натуральний. Кінець цінцем, це залежить від ментальної моделі того, як класи представлені. В моделі, де параметри типу присутні лише під час компіляції, природно вважати, що два `Branch`, `b1` та `b2`, рівні. В альтернатівній моделі, де параметри типу формують частину значення об'єкту, так само природно розглядати їх як різні. Оскільки Scala приймає модель затирання типів, параметри типів неприсутні під час виконання, так що `b1` та `b2` природно розглядаються як рівні.

Існує тільки маленька зміна, потрібна для формулювання методу `equals`, що не продукує неперевіреного попередження. Замість елементу типу `T` використовуйте літеру малого реєсту, таку як `t`:
[source,scala]
----
case that: Branch[t] => this.elem == that.elem &&
                        this.left == that.left &&
                        this.right == that.right
----
Згадайте з Розділу 15.2, що параметр типу в шаблоні, що починається з малої літери, представляє невідомий тип. Тепер шаблон співпаде:
[source,scala]
----
case that: Branch[t] =>
----
буде успішним для значень `Branch` любого типу. Параметр типу `t` представляє невідомий елемент типу для `Branch`. Він також може бути замінений на підкреслення, що те саме, що і попередній варіант:
[source,scala]
----
case that: Branch[_] =>
----
Одна річ, що залишилось визначити для класу `Branch` є два інші методи, `hashCode` та `canEqual`, що ідуть з `equals`. Ось можлива реалізація `hashCode`:
[source,scala]
----
override def hashCode: Int = (elem, left, right).##
----
Це тільки одна з багатьох можливих реалізацій. Як показано раніше, принцип є взяти `hashCode` з усіх полів, та скомбінувати їх. Ось реалізація методу `canEqual` в класі `Branch`:
[source,scala]
----
def canEqual(other: Any) = other match {case that: Branch[_] => true
  case _ => false
}
----
Реалізація метода `canEqual` використовує типізоване порівняння шаблонів. Також можливо свормулювати його за допомогою `isInstanceOf`:
[source,scala]
----
def canEqual(other: Any) = other.isInstanceOf[Branch[_]]
----
Якщо ви почуваєтесь як nit-picking — і ми заохочуємо, щоб ви так і почувались! — ви можете здивуватись, що значить поява підкреслення в типі вище. Кінець кінцем, `Branch[_]` є технічно параметром типу для метода, не типом шаблону. То як це можливо залишити деякі його частини невизначеними?

Відповідь на це запитання обговорюється в наступній главі. `Branch[_]` є скороченням для так званого підстановочного типу, що є, грубо кажучи, типом з деякими невідомими частинами. Так що навіть якщо технічно підкреслення означає дві різні речі в порівнянні шаблонів та параметрі типу в виклику метода, в основному значення те саме: воно дозволяє вам помітити дещо, що є невідомим. Фінальна версія `Branch` показана в Лістингу 30.4.
[source,scala]
----
class Branch[T](
  val elem: T,
  val left: Tree[T],
  val right: Tree[T]
) extends Tree[T] {

  override def equals(other: Any) = other match {
    case that: Branch[_] => (that canEqual this) &&
                            this.elem == that.elem &&
                            this.left == that.left &&
                            this.right == that.right
    case _ => false
  }
  
  def canEqual(other: Any) = other.isInstanceOf[Branch[_]]
  
  override def hashCode: Int = (elem, left, right).##
}

Лістинг 30.4 - Параметризований тип з `equals` та `hashCode`.

30.4 Рецепти щодо `equals` та `hashCode`
----------------------------------------
В цьому розділі ми надамо крок-за-кроком рецепти для створення методів `equals` та `hashCode`, що повинні підходити для більшості ситуацій. Як ілюстрація, ми будемо використовувати методи класу `Rational`, показаного в Лістингу 30.5.

Щоб створити цей клас ми видалили методи математичних операцій з версії класу `Rational`, показаного в Лістингу 6.5. Ми також зробили мінорні покращення до `toString`, та модифікували ініціалізатори `numer` та `denom`, щоб нормалізувати всі дробі, що мають додатний дільник (тобто, трансформувати `1/-2` до `-1/2`).

Рецепт для `equals`
~~~~~~~~~~~~~~~~~~~
Ось рецепт для перекриття `equals`:

1. Щоб перекрити `equals` в нефінальному класі, створіть метод `canEqual`. Якщо наслідуване визначення `equals` походить від `AnyRef` (тобто `equals` не був перевизначений вище в ієрархії класів), визначення `canEqual` повинне бути нове; інакше воно буде перекривати повереднє визначення метода з таким же ім'ям. Одне виключення до цієї вимоги є для фінальних класів, що перевизначають метод `equals`, наслідуваний від `AnyRef`. Для них аномалії субкласів, описані в Розділі 30.2 не можуть виникти; відповідно вони не мають визначати `canEqual`. Тип об'єкту, переданий до `canEqual` повинен бути `Any`:
[source,scala]
----
def canEqual(other: Any): Boolean =
----

2. Метод `canEqual` повинен давати `true`, якщо об'єкт аргумента є примірником поточного класу (iтобто класу, в якому визначений `canEqual`), та `false` інакше:
[source,scala]
----
other.isInstanceOf[Rational]
----

3. В методі `equals` переконайтесь, що ви задекларували тип об'єкта, переданого як `Any`:
[source,scala]
----
override def equals(other: Any): Boolean =
----

4. Напишіть тіло метода `equals` як єдиний вираз `match`. Селектор  `match` повинен бути об'єктом, переданим до `equals`:
[source,scala]
----
other match {
// ...
}
----

5. Вираз `match` повинен мати два випадки. Перший повинен декларувати шаблон типу для класу, в якому ви визначаєте метод `equals`:
[source,scala]
----
case that: Rational =>
----

6. В тілі цього `case` запишіть вираз, що логчно пов'язує разом окремі вирази, що мають бути `true` для рівних об'єктів. Якщо метод `equals`, що ви перекриваєте, не походить від `AnyRef`, ви будете найбільш вірогідно включати виклик метода `equals` суперкласа:
[source,scala]
----
super.equals(that) &&
----
Якщо ви визначаєте `equals` для класа, що перший визначає `canEqual`,ви повинні викликати `canEqual` на аргументі до метода рівності, передавши його як аргумент:
[source,scala]
----
(that canEqual this) &&
----
Перекриття перевизначень `equals` також повенне включати виклик `canEqual`, якщо вони не включають виклик до `super.equals`. В останньому випадку перевірка `canEqual` буде вже зроблена викликом суперкласа. Нарешті, для кожного поля, що має відношення до рівності, перевірте, що поле для об'єкту `this` рівне до відповідного поля переданого об'єкта:
[source,scala]
----
numer == that.numer &&
denom == that.denom
----

7. Для другого випадку використовуйте підстановочний шаблон, що дає `false`:
[source,scala]
----
case _ => false
----
Якщо ви дотримуватиметесь цього рецепту для `equals`, рівність гарантовано буде відношенням еквівалентності, як вимагається контрактом `equals`.
[source,scala]
----
class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = (if (d < 0) -n else n) / g
  val denom = d.abs / g
  private def gcd(a: Int, b: Int): Int =
  if (b == 0) a else gcd(b, a % b)

  override def equals(other: Any): Boolean =
    other match {
      case that: Rational =>
        (that canEqual this) &&
        numer == that.numer &&
        denom == that.denom
      case _ => false
    }

  def canEqual(other: Any): Boolean =
    other.isInstanceOf[Rational]

  override def hashCode: Int = (numer, denom).##

  override def toString =
    if (denom == 1) numer.toString else numer + "/" + denom
}
----
Лістинг 30.5 - Клас `Rational` з `equals` та `hashCode`.

Рецепт для `hashCode`
~~~~~~~~~~~~~~~~~~~~~
Для `hashCode` ви звичайно можете досягти задовільних результатів, якщо будете використовувати наступний рецепт, що подібний до рецепту, рекомендуємого для Java класів в Effective Java.footnote:[Bloch, Effective Java Second Edition. [Blo08\]] Включіть в обчислення кожне поле в вашому об'єкту, що використовується для визначення рівності в методі `equals` ("відповідні" поля). Зробіть тапл, що містить значення з усіх ціх полів. Потім викличте `##` на отриманому таплі.

Наприклад, щоб реалізувати хеш код для об'єкта, що має п'ять відповідних полів з іменами `a`, `b`, `c`, `d`, `e`, ви можете записати:
[source,scala]
----
override def hashCode: Int = (a, b, c, d, e).##
----
Якщо метод `equals` викликає `super.equals(that)` як частину своїх обчислень, ви маєет почати ваше обчислення `hashCode` з виклика` super.hashCode`. Наприклад, якщо метод `Rational` `equals` мав викликати `super.equals(that)`, його `hashCode` був би такий:
[source,scala]
----
override def hashCode: Int = (super.hashCode, numer, denom).##
----
Одна річ, що треба пам'ятати коли пишете методи `hashCode` за допомогою цього підходу, це те, ваш хеш код буде гарний тільки настільки, наскільки гарні хеш коди, на яких він побудований, а саме хеш коди, що ви отримали викликаючи `hashCode` на відповідних полях вашого об'єкта. Іноді вам буде треба дещо крім простого виклику  `hashCode` на полі, щоб отримати корисний хеш код для цього поля. Наприклад, якщо одне з ваших полів є колекція, ви вірогідно бажаєте хеш код для цього поля, що базується на всіх елементах, що містяться в цій колекції. Якщо поле є `Vector`, `List`, `Set`, `Map`, або тапл, ви можете просто включити його в список елементів, по яких ви хешуєте, оскільки `equals` та `hashCode` перекриті в ціх класах, щоб прийняти до уваги елементи, які вони містять. Але це не так для  `Array`, що не приймає до уваги елементи при обчисленні хеш коду. таким чином для масивів ви маєте трактувати кожний елемент масиву як окреме поле вашого об'єкту, викликаюч `##` на кожному елементі явно, або передаючи масив до одного з методів `hashCode` в синглтон об'єкті `java.util.Arrays`.

Нарешті, якщо ви знайдете, що окреме обчислення хеш коду шкодить продуктивності вашої програми, розгляньте кешування хеш коду. Якщо об'єкт незмінний, ви можете обчислити хеш код, коли об'єкт створюється, та зберігти його в полі. Ви можете зробити це, просто перекривши `hashCode` за допомогою `val` замість `def`, ось так:
[source,scala]
----
override val hashCode: Int = (numer, denom).##
----
Цей підхід є компроміс між пам'ятю та часом виконання, оскільки кожний примірник незмінного класу буде мати на одне поле більше, що зберігатиме кешоване значення хеш коду.

30.5 Висновок
-------------
В ретроспктиві визначення коректної реалізації `equals` було несподівано тонким. Ви маєте бути уважним щодо сигнатури типу; ви маєте перекрити `hashCode`; ви повинні уникати залежностей від змінного стану; та ви маєте реалізувати та використовувати метод `canEqual`, якщо ваш клас не є фінальним.

Беручи до уваги, як складно реалізувати коректний метод рівності, ви можете схилитись до визначення ваших класів для об'єктів що порівнюються як кейс класів. Таким чином компілятор Scala буде додавати методи `equals` та `hashCode` з правильними властивостями автоматично.
