<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__28">Глава 28</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___xml">Робота з XML</h1>
<div class="paragraph"><p>Ця глава вводить в підтримку XML в Scala. Після дискутування напів-структурованих даних взагалі, вона показує основну функціональність в Scala для маніпулювання XML: як створити вузли з допомогою XML літералів, як зберігти та завантажити XML з файлів, та як розбити XML вузли з використанням методів запитів та порівняння шаблонів. Ця глава є тільки коротким введенням в те, що можливо з допомогою XML, але вона показує вам досить для початку.</p></div>
<div class="sect1">
<h2 id="_28_1___">28.1 Напів-структуровані дані</h2>
<div class="sectionbody">
<div class="paragraph"><p>XML є формою _напів-структурованих_ даних. Він є більш структурованим ніж прості рядки, оскільки він організує вміст даних в вигляді дерев. Однак простий XML менш структурований, ніж об'єкти в мові програмування, оскільки він дозволяє довільний текст між тегами, та йому бракує системи типів.<span class="footnote"><br />[Існують системи типів для XML, такі як XML Schemas, але вони за полем зору цієї книги.]<br /></span></p></div>
<div class="paragraph"><p>Напів-структуровані дані дуже корисні кожного разу, коли вам треба серіалізувати дані програми для збереження в файлі або доставки через мережу. Замість конвертування структурованих даних кожного разу до байтів, ви конвертуєте їх до-та-з напів-структурованих даних. Потім ви використовуєте існуючу бібліотечні процедури для конвертації напів-структурованих даних в бінарні дані, зберігаючи ваш час для більш важливих проблем.</p></div>
<div class="paragraph"><p>Існує багато форм напів-структурованих даних, але XML є найбільш широко використовуваною формою в інтернеті. Існують XML інструменти для більшості операційних систем, та більшість мов програмування мають доступні XML бібліотеки. Його популярність само-підсилююча. Чим більше інструментів та бібліотек розробляється у відповідь на популірність XML, тим вірогідніше інженери програмного забезпечення оберуть XML як частину своїх форматів. Якщо ви пишете програмне забезпечення, що комунікує через інтернет, тоді скоріше або пізніше вам буде треба взаємодіяти з якимось сервісом, що розмовляє мовою XML.</p></div>
<div class="paragraph"><p>З усіх ціх причин Scala включає спеціальну підтримку для обробки XML. Ця глава показує вам підтримку Scala для конструювання XML, його обробку звичайними методами, та обробку за допомогою порівняння шаблонів Scala. На додаток до ціх основ, глава по ходу показує декілька загальних ідіом по використанню XML в Scala.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_2__xml">28.2 Огляд XML</h2>
<div class="sectionbody">
<div class="paragraph"><p>XML побудований з двох базових елементів, тексту та тегів.<span class="footnote"><br />[Повна історія трохи складніша, але цього достатньо щоб бути ефективним з XML.]<br /></span> Текст є, як звичайно, любою послідовністю символів. Теги, записані як <code>&lt;pod&gt;</code>, складаються зі знака меньше, літерної мітки, та знака більше. Тегі можуть бути відкриваючими та закриваючими. Закриваючий тег виглядає як відкриваючий, за винятком того, що він має косу прямо перед міткою тега, як тут: &lt;/pod&gt;.</p></div>
<div class="paragraph"><p>Відкриваючий та закриваючий тег мають відповідати один до одного, так само як дужки. Кожний відкриваючий тег повинен раніше чи пізніше мати закриваючий тег з такою ж міткою. Так що наступне нелегальне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>// Illegal XML
One <span class="nt">&lt;pod&gt;</span>, two <span class="nt">&lt;pod&gt;</span>, three <span class="nt">&lt;pod&gt;</span> zoo
</pre></div></div></div>
<div class="paragraph"><p>Більше того, вміст любих двух парних тегів сам має бути валідним XML. Ви не можете мати дві пари тегів, які перекривають один одного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>// Also illegal
<span class="nt">&lt;pod&gt;</span>Three <span class="nt">&lt;peas&gt;</span> in the <span class="nt">&lt;/pod&gt;&lt;/peas&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете, однак, написати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nt">&lt;pod&gt;</span>Three <span class="nt">&lt;peas&gt;&lt;/peas&gt;</span> in the <span class="nt">&lt;/pod&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки теги мають співпадати один з одним в такий спосіб, XML структурований як вкладені елементи. Кожна пара відповідних відкриваючих та закриваючих тегів формують елемент, та елементи можуть бути вкладені один в другий. В прикладі вище цілий <code>&lt;pod&gt;Three &lt;peas&gt;&lt;/peas&gt; in the &lt;/pod&gt;</code> є елементом, <code>&lt;peas&gt;&lt;/peas&gt;</code> є елементом, вкладеним в перший.</p></div>
<div class="paragraph"><p>Такі основи. Дві інші речі, які вам треба знати: перше, існує скорочена нотація для відкриваючого тега, за яким зразу іде закриваючий тег. Просто запишіть один тег з косою після мітки тегу. Такий тег складається з порожнього елементу. Використовуючи порожній елемент, попередній приклад може бути просто записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">pod</span><span class="o">&gt;</span><span class="nc">Three</span> <span class="o">&lt;</span><span class="n">peas</span><span class="o">/&gt;</span> <span class="n">in</span> <span class="n">the</span> <span class="o">&lt;/</span><span class="n">pod</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Друге, початковий тег може мати приєднані до нього атрибути. Атрибут є пара ім'я-значення, написана зі знаком рівності між ними. Ім'я атрибуту є простим, неструктурованим текстом, та значення оточене або подвійними (<code>""</code>) або поодинокими (<code>''</code>) лапками. Атрибути виглядають так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nt">&lt;pod</span> <span class="na">peas=</span><span class="s">&quot;3&quot;</span> <span class="na">strings=</span><span class="s">&quot;true&quot;</span><span class="nt">/&gt;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_3_xml_">28.3 XML літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala дозволяє вам вбивати XML як літерал будь-де, де є валідним вираз. Просто набираєте початковий тег та потім продовжуєте писати XML вміст. Компілятор перейде в режим вводу XML та буде читати вміст XML доки не побачить закриваючий тег, що співпадає з тим, з якого ви почали:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
          <span class="nc">This</span> <span class="n">is</span> <span class="n">some</span> <span class="nc">XML</span><span class="o">.</span>
          <span class="nc">Here</span> <span class="n">is</span> <span class="n">a</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">&lt;atag/&gt;</span>
       <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
  <span class="nc">This</span> <span class="n">is</span> <span class="n">some</span> <span class="nc">XML</span><span class="o">.</span>
  <span class="nc">Here</span> <span class="n">is</span> <span class="n">a</span> <span class="n">tag</span><span class="k">:</span> <span class="kt">&lt;atag/&gt;</span>
<span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Результатом цього виразу є тип <code>Elem</code>, що означає елемент XML з міткою <code>a</code> та вмістом <code>"This is some XML...,"</code>. Деякі інші важливі XML класи:</p></div>
<div class="ulist"><ul>
<li>
<p>
Клас <code>Node</code> є абстрактним суперкласом всіх класів вузлів XML.
</p>
</li>
<li>
<p>
Клас <code>Text</code> є вузол, що містить лише текст. Наприклад, <code>"stuff"</code> що є частиною <code>&lt;a&gt;stuff&lt;/a&gt;</code> має клас <code>Text</code>.
</p>
</li>
<li>
<p>
Клас <code>NodeSeq</code> містить послідовність вузлів. Багато методів в XML бібліотеці обробляють <code>NodeSeqs</code> в місцях, де ви б могли очікувати, що вони обробляють окремі <code>Node</code>. Ви все ще можете використовувати такі методи з окремими вузлами, однак, оскільки <code>Node</code> є розширенням <code>NodeSeq</code>. Це може виглядати збочено, але це гарно робить для XML. Ви можете думати про окремі <code>Node</code>, як про одно-елементні <code>NodeSeq</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ви не обмежені виписувати точний XML який бажаєте, символ в символ. Ви можете обислити Scala код всередині XML дітерала, через використання фігурних дужок <code>{}</code> як виключення. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="s">&quot;hello&quot;</span> <span class="o">+</span> <span class="s">&quot;, world&quot;</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">hello</span><span class="o">,</span> <span class="n">world</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Виключення фігурними дужками включає довільний Scala вміст, включаючи подальші XML літерали. Таким чином, по мірі зростання рівня вкладеності, ваш код може перемикатись між XML та звичайним Scala кодом.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">1955</span>
<span class="n">yearMade</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1955</span>

<span class="n">scala</span><span class="o">&gt;</span>  <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span> <span class="k">if</span> <span class="o">(</span><span class="n">yearMade</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="o">)</span> <span class="o">&lt;</span><span class="n">old</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">old</span><span class="o">&gt;</span>
              <span class="k">else</span> <span class="n">xml</span><span class="o">.</span><span class="nc">NodeSeq</span><span class="o">.</span><span class="nc">Empty</span> <span class="o">}</span>
        <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">old</span><span class="o">&gt;</span><span class="mi">1955</span><span class="o">&lt;/</span><span class="n">old</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо код в фігурних дужках обчислюється або до XML вузла, або до послідовності XML вузлів, ці вузли вставляються прямо як є. В прикладі вище, якщо <code>yearMade</code> меньше ніж <code>2000</code>, він огортається в теги <code>&lt;old&gt;</code>, та додається до елемента <code>&lt;a&gt;</code>. Інакше нічого не додається. Зауважте щодо прикладу вище, що "нічого" як XML вузол позначається <code>xml.NodeSeq.Empty</code>. Вираз виключення в фігурних дужках не має обчислюватись до вузла XML. Він може обчислюватись до любого значення Scala. В такому випадку результат буде перетворено на рядок, та вставлено як текстовий вузол:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="mi">7</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Любі символи <code>&lt;</code>, <code>&gt;</code> та <code>&amp;</code> в тексті будуть виключені, якщо ви роздрукуєте вузол:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">{</span><span class="s">&quot;&lt;/a&gt;potential security hole&lt;a&gt;&quot;</span><span class="o">}</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;/</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span><span class="n">potential</span> <span class="n">security</span>
<span class="n">hole</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">a</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Для контрасту, якщо ви створюєте XML з низькорівневими операціями з рядками, ви попадете в пастку, як наступна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="s">&quot;&lt;a&gt;&quot;</span> <span class="o">+</span> <span class="s">&quot;&lt;/a&gt;potential security hole&lt;a&gt;&quot;</span> <span class="o">+</span> <span class="s">&quot;&lt;/a&gt;&quot;</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span><span class="n">potential</span> <span class="n">security</span> <span class="n">hole</span><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це що наданий користувачем рядок включає XML теги самі по собі, в цьому випадку <code>&lt;/a&gt;</code> та <code>&lt;a&gt;</code>. Ця поведінка може дозволити деякі капосні сюрпризи для початкового програміста, оскільки дозволяє користувачеві впливати на результуюче дерево XML за межами простору, наданому для користувача в елементі <code>&lt;a&gt;</code>. Ви можете запобігти всьому цьому класу проблем, завжди конструюючи XML з використанням XML літералів, а не додавання рядків.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_4_">28.4 Сериалізація</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили досить щодо Scala підтримки XML, щоб написати першу частину серіалізатора: перетворення від внутрішніх структур даних до XML. Все що вам треба для цього, це XML літерали та їх виключення в фігурних дужках.</p></div>
<div class="paragraph"><p>Як приклад, уявімо, що ви реалізуєте базу даних, яка відстежує вашу екстенсивну колекцію вінтажних термометрів Coca-Cola. Ви можете зробити наступний внутрішній клас, що утримуватиме елементи каталогу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CCTherm</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">yearMade</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">dateObtained</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">bookPrice</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// in US cents</span>
  <span class="k">val</span> <span class="n">purchasePrice</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// in US cents</span>
  <span class="k">val</span> <span class="n">condition</span><span class="k">:</span> <span class="kt">Int</span> <span class="c1">// 1 to 10</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">description</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це прямолінійний, набитий даними клас, що містить різні частини інформації, такі, як де термометр було зроблено, коли ви його отримали, та скільки заплатили за нього. Щоб конвертувати примірники цього класу до XML, просто додайте метод <code>toXML</code>, що використовує XML літерали та виключення в фігурних дужках, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">CCTherm</span> <span class="o">{</span>
<span class="o">...</span>
<span class="k">def</span> <span class="n">toXML</span> <span class="k">=</span>
  <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;{</span><span class="n">description</span><span class="o">}&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;{</span><span class="n">dateObtained</span><span class="o">}&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;{</span><span class="n">bookPrice</span><span class="o">}&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;{</span><span class="n">purchasePrice</span><span class="o">}&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;{</span><span class="n">condition</span><span class="o">}&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось цей метод в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">therm</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CCTherm</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">description</span> <span class="k">=</span> <span class="s">&quot;hot dog #5&quot;</span>
        <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">1952</span>
        <span class="k">val</span> <span class="n">dateObtained</span> <span class="k">=</span> <span class="s">&quot;March 14, 2006&quot;</span>
        <span class="k">val</span> <span class="n">bookPrice</span> <span class="k">=</span> <span class="mi">2199</span>
        <span class="k">val</span> <span class="n">purchasePrice</span> <span class="k">=</span> <span class="mi">500</span>
        <span class="k">val</span> <span class="n">condition</span> <span class="k">=</span> <span class="mi">9</span>
      <span class="o">}</span>
<span class="n">therm</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span> <span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">therm</span><span class="o">.</span><span class="n">toXML</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>

<span class="nc">NOTE</span><span class="k">:</span> <span class="kt">Вираз</span> <span class="kt">`new CCTherm`</span> <span class="kt">в</span> <span class="kt">попередньому</span> <span class="kt">прикладі</span> <span class="kt">робить</span><span class="o">,</span> <span class="n">навіть</span> <span class="n">якщо</span> <span class="n">`CCTherm`</span> <span class="n">є</span> <span class="n">абстрактним</span> <span class="n">класом</span><span class="o">,</span> <span class="n">оскільки</span> <span class="n">цей</span> <span class="n">синтаксис</span> <span class="n">насправді</span> <span class="n">створює</span> <span class="n">примірник</span> <span class="n">анонімного</span> <span class="n">субкласу</span> <span class="n">`CCTherm`</span><span class="o">.</span> <span class="n">Анонімні</span> <span class="n">класи</span> <span class="n">описані</span> <span class="n">в</span> <span class="n">Розділі</span> <span class="mf">20.5</span><span class="o">.</span>

<span class="n">Доречі</span><span class="o">,</span> <span class="n">якщо</span> <span class="n">ви</span> <span class="n">бажаєте</span> <span class="n">включити</span> <span class="n">фігурні</span> <span class="n">дужки</span> <span class="n">`{`</span> <span class="n">або</span> <span class="n">`}`</span> <span class="n">як</span> <span class="nc">XML</span> <span class="n">текст</span><span class="o">,</span> <span class="n">але</span> <span class="n">не</span> <span class="n">використовувати</span> <span class="n">їх</span> <span class="n">для</span> <span class="n">виключення</span> <span class="nc">Scala</span> <span class="n">коду</span><span class="o">,</span> <span class="n">просто</span> <span class="n">запишіть</span> <span class="n">їх</span> <span class="n">два</span> <span class="n">рази</span> <span class="n">поспіль</span><span class="k">:</span> <span class="err">[</span><span class="kt">source</span><span class="o">,</span><span class="n">scala</span><span class="err">]</span>
</pre></div></div></div>
<div class="paragraph"><p>scala&gt; &lt;a&gt; {{{{brace yourself!}}}} &lt;/a&gt;
res7: scala.xml.Elem = &lt;a&gt; {{brace yourself!}} &lt;/a&gt;</p></div>
<div class="listingblock">
<div class="content">
<pre><code>28.5 Розбиття XML на частини</code></pre>
</div></div>
<div class="paragraph"><p>Серед багатьох методів, доступних для XML класів, існує щонайменьше три, про які вам слідує знати. Вони дозволяють вам розбити XML на частини, багато не думаючи щодо того, як саме в точності XML представлений в Scala. Ці методи базуються на мові XPath для обробки XML. Як взагалі в Scala, ви можете писати їх напряму в коді Scala, замість викликати зовнішній інструмент.</p></div>
<div class="paragraph"><p><strong>Екстрагування тексту.</strong> Через виклик метода <code>text</code> на любому вузлі XML ви отримуєте весь текст в вузлі, мінус тегі елементів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="nc">Sounds</span> <span class="o">&lt;</span><span class="n">tag</span><span class="o">/&gt;</span> <span class="n">good</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">text</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Sounds</span> <span class="n">good</span>
</pre></div></div></div>
<div class="paragraph"><p>Любі закодовані символи розкодуються автоматично:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">---&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">output</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">text</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot; input ---&gt; output &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><strong>Екстрагування суб-елементів.</strong> Якщо ви бажаєте знайти суб-елементи за іменем тегу, просто викличте <code>\</code> з ім'ям тегу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span><span class="s">&quot;b&quot;</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">(&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете зробити "глибокий пошук", щоб шукати в суб-елементах, і так далі, використовуючи оператор <code>\\</code> замість <code>\</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span><span class="s">&quot;c&quot;</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\\</span><span class="s">&quot;c&quot;</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">(&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span><span class="s">&quot;a&quot;</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">NodeSeq</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\\</span><span class="s">&quot;a&quot;</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span>
<span class="nc">NodeSeq</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Scala використовує <code>\</code> та <code>\\</code> замість <code>/</code> та <code>//</code> в XPath. Причина в тому, що <code>//</code> починає коментар в Scala! Таким чином мав використовуватись якійсь інший символ, і інші косі роблять добре.</td>
</tr></table>
</div>
<div class="paragraph"><p><strong>Екстракція атрибутів.</strong> Ви можете екстрагувати атрибути тегу, використовуючі ті самі методи <code>\</code> та <code>\\</code>. Просто покладіть знак <code>at</code>
(<code>@</code>) перед ім'ям атрибуту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">joe</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">employee</span>
          <span class="n">name</span><span class="o">=</span><span class="s">&quot;Joe&quot;</span>
          <span class="n">rank</span><span class="o">=</span><span class="s">&quot;code monkey&quot;</span>
          <span class="n">serial</span><span class="o">=</span><span class="s">&quot;123&quot;</span><span class="o">/&gt;</span>
<span class="n">joe</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">employee</span> <span class="n">name</span><span class="o">=</span><span class="s">&quot;Joe&quot;</span> <span class="n">rank</span><span class="o">=</span><span class="s">&quot;code monkey&quot;</span>
 <span class="n">serial</span><span class="o">=</span><span class="s">&quot;123&quot;</span><span class="o">/&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">joe</span> <span class="o">\</span><span class="s">&quot;@name&quot;</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="nc">Joe</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">joe</span> <span class="o">\</span><span class="s">&quot;@serial&quot;</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">scala.xml.NodeSeq</span> <span class="o">=</span> <span class="mi">123</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_6_">28.6 Десеаріалізація</h2>
<div class="sectionbody">
<div class="paragraph"><p>Використовуючи попередні методи для розбиття XML на частини, тепер ви можете написати пару до серіалізатора, парсер з XML знову назад до ваших внутрішніх структур даних. Наприклад, ви можете знови розбити примірник <code>CCTherm</code>, через використання наступного коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">CCTherm</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">description</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span>
    <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;yearMade&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">dateObtained</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;dateObtained&quot;</span><span class="o">).</span><span class="n">text</span>
    <span class="k">val</span> <span class="n">bookPrice</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;bookPrice&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">purchasePrice</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;purchasePrice&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">condition</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span><span class="s">&quot;condition&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код шукає по вхідному вузлу XML на ім'я <code>node</code>, щоб знайти кожну з шести частин даних, потрібних щоб зібрати <code>CCTherm</code>. Дані, що є текстом, отримуються через <code>.text</code> та залишаються як є. Ось цей метод в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="n">therm</span><span class="o">.</span><span class="n">toXML</span>
<span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span> <span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_7___">28.7 Загрузка та збереження</h2>
<div class="sectionbody">
<div class="paragraph"><p>Є одна остання частина, потрібна для серіалізатора даних: перетворення між XML anта потоками даних. Ця остання частина є найпростішою, оскільки є бібліотечні процедури, що будуть робити все це за вас. Ви просто маєте викликати правильну процедуру на правильних даних.</p></div>
<div class="paragraph"><p>Щоб конвертувати XML в рядок все що вам треба, це <code>toString</code>. Присутність робочого <code>toString</code> це те, чому ви можете експериментувати з XML в оболонці Scala. Однак краще використавувати бібліотетчні процедури, та конвертувати все підряд до байтів. Таки чином, результуючий XML може включати директиву, що вказує, яке кодування символів було використане. Якщо ви закодуєте рядок до байтів самі, тоді відповідальність за відстеження кодування символів лягає на вас.</p></div>
<div class="paragraph"><p>Щоб конвертувати з XML до файлу з байтів, ви можете використовувати команду <code>XML.save</code>. Ви маєте задати ім'я файлу і вузол, що треба зберегти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">.</span><span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="s">&quot;therm1.xml&quot;</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Після виконання команди вище, отриманий файл <code>therm1.xml</code> виглядає наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;</span>
<span class="nt">&lt;cctherm&gt;</span>
  <span class="nt">&lt;description&gt;</span>hot dog #5<span class="nt">&lt;/description&gt;</span>
  <span class="nt">&lt;yearMade&gt;</span>1952<span class="nt">&lt;/yearMade&gt;</span>
  <span class="nt">&lt;dateObtained&gt;</span>March 14, 2006<span class="nt">&lt;/dateObtained&gt;</span>
  <span class="nt">&lt;bookPrice&gt;</span>2199<span class="nt">&lt;/bookPrice&gt;</span>
  <span class="nt">&lt;purchasePrice&gt;</span>500<span class="nt">&lt;/purchasePrice&gt;</span>
  <span class="nt">&lt;condition&gt;</span>9<span class="nt">&lt;/condition&gt;</span>
<span class="nt">&lt;/cctherm&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Завантаження простіше ніж збереження, оскільки файл містить все, що повинно знати завантажувачу. Просто викличте <code>XML.loadFile</code> з ім'ям файлу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">loadnode</span> <span class="k">=</span> <span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">loadFile</span><span class="o">(</span><span class="s">&quot;therm1.xml&quot;</span><span class="o">)</span>
<span class="n">loadnode</span><span class="k">:</span> <span class="kt">scala.xml.Elem</span> <span class="o">=</span>
<span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">loadnode</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span> <span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p>Those are the basic methods you need. There are many variations on these loading and saving methods, including methods for reading and writing to various kinds of readers, writers, input and output streams.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_8____xml">28.8 Порівняння шаблонів на XML</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поки що ми бачили, як розділяти XML використовуючи <code>text</code> та методи, подібні до XPath <code>\</code> та <code>\\</code>. Вони гарні, коли ви знаєте точно, який тип структури XML ви розбиваєте на частки. Однак іноді існує декілька можливих структур, які може мати XML. Можливо багато різновидів записів з даними, наприклад, оскільки ви розширили вашу колекцію термометрів, щоб включити годинники та тарілки для сендвічів. Можливо ви просто бажаєте пропустити всі проміжки між тегами. З будь якої причини ви можете використовувати порівняння шаблонів для перемикання між можливостями.</p></div>
<div class="paragraph"><p>Шаблон XML виглядає просто як XML літерал. Головна різниця в тому, що якщо ви вставляєте виключення <code>{}</code>, тоді код в <code>{}</code> не є виразом, але шаблоном. Шаблон, вставлений в <code>{}</code> може використовувати повну мову шаблонів Scala, включаючи прив'язку нових змінних, виконання перевірки типів, та ігнорування контенту з використанням шаблонів <code>_</code> та <code>_*</code>. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span><span class="o">}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s an a: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span><span class="o">}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s a b: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s something else.&quot;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція має перевірку шаблонів з трьома випадками. Перший випадок шукає елемент <code>&lt;a&gt;</code>, чий вміст складається з одного підвузла. Він прикліплює цей вміст до змінної на ім'я <code>contents</code>, та потім обчислює код зправа від асоційованої стрілки вправо (<code>=&gt;</code>). Другий випадок робить те саме для <code>&lt;b&gt;</code> замість <code>&lt;a&gt;</code>, та третій випадок співпадає з будь-чим, що не співпало з іншими випадками. Ось ця функція в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">an</span> <span class="n">a</span><span class="k">:</span> <span class="kt">apple</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">banana</span><span class="o">&lt;/</span><span class="n">b</span><span class="o">&gt;)</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">a</span> <span class="n">b</span><span class="k">:</span> <span class="kt">banana</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">cherry</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;)</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>Скоріше всього, ця функція не саме те, що вам треба, тому що вона шукає точно такий вміст, що складається з одного субвузла в <code>&lt;a&gt;</code> або <code>&lt;b&gt;</code>. Таким чином вона буде хибити в випадках як наступний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">red</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">/&gt;)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">something</span> <span class="k">else</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте функцію, що співпадає з випадками, як цей, ви можете порівняти з послідовністю вузлів замість одного. Шаблон для "любої послідовності" XML вузлів записується <code>_*</code>. Візуально ця послідовність виглядає як підстановочний шаблон (<code>_</code>), за яким слідує regex-стильна зірочка Kleene (<code>*</code>). Ось оновлена функція, що порівнює послідовності субелементів, замість одного субелемента:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s an a: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s a b: &quot;</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;It&#39;s something else.&quot;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що результат <code>_*</code> прикріплений до вмісту змінної через використання шаблону <code>@</code>, описаного в Розділі 15.2. Тут нова версія в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">red</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">an</span> <span class="n">a</span><span class="k">:</span> <span class="kt">ArrayBuffer</span><span class="o">(</span><span class="kt">a</span> <span class="o">,</span> <span class="kt">&lt;em&gt;red&lt;/em&gt;</span><span class="o">,</span> <span class="n">apple</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">/&gt;)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">It</span><span class=" -Symbol">&#39;s</span> <span class="n">an</span> <span class="n">a</span><span class="k">:</span> <span class="kt">WrappedArray</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Як фінальна підказка, майте на увазі, що шаблони XML роблять дуже гарно з виразами <code>for</code>, як шлях ітерувати по деяких частинах дерева XML, при цьому ігноруючі інші частини. Наприклад, уявімо, що ви бажаєте пропустити деякі проміжки між записами в наступній XML структурі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">catalog</span> <span class="k">=</span>
  <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="nc">Sprite</span> <span class="nc">Boy</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1964</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">April</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">2003</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">1695</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">595</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Візуально це виглядає як два елементи в елементі <code>&lt;catalog&gt;</code>. Однак насправді їх п'ять. Існує проміжок перед, після та між двома елементами! Якщо ви не приймете до уваги ці проміжки, ви можете некоретно обробити записи термометрів, таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">catalog</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;{</span><span class="n">therms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">therm</span> <span class="k">&lt;-</span> <span class="n">therms</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;processing: &quot;</span> <span class="o">+</span>
              <span class="o">(</span><span class="n">therm</span> <span class="o">~</span><span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">processing</span><span class="k">:</span>
<span class="kt">processing:</span> <span class="kt">hot</span> <span class="kt">dog</span> <span class="k">#</span><span class="err">5</span>
<span class="kt">processing:</span>
<span class="n">processing</span><span class="k">:</span> <span class="kt">Sprite</span> <span class="kt">Boy</span>
<span class="n">processing</span><span class="k">:</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте рядки, де іде спроба обробити всі проміжки так, якби це були б дійсними записами термометрів. Що б ви дійсно бажали зробити, це ігнорувати ці проміжки, та обробляти тільки ті субвузли, що є всередині елементу <code>&lt;cctherm&gt;</code>. Ви можете описати цю підмножину, використовуючи шаблон <code>&lt;cctherm&gt;{_*}&lt;/cctherm&gt;</code>, та ви можете обмежити вираз <code>for</code> до ітерації по елементах, що співпадають з шаблоном:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">catalog</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;{</span><span class="n">therms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">therm</span> <span class="k">@</span> <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;{</span><span class="k">_</span><span class="o">*}&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span> <span class="k">&lt;-</span> <span class="n">therms</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">&quot;processing: &quot;</span> <span class="o">+</span>
              <span class="o">(</span><span class="n">therm</span> <span class="o">/</span><span class="s">&quot;description&quot;</span><span class="o">).</span><span class="n">text</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">processing</span><span class="k">:</span> <span class="kt">hot</span> <span class="kt">dog</span> <span class="k">#</span><span class="err">5</span>
<span class="kt">processing:</span> <span class="kt">Sprite</span> <span class="kt">Boy</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_28_9_">28.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава тільки подерла поверхню того, що можна робити за допомогою XML. Існує багато інших розширень, бібліотек та інструментів, про які ви можете знати, деякі з яких прилаштовані для Scala, деякі зроблені для Java, але корисні в Scala, та деякі мово-нейтральні. Що ми можемо винести з цієї глави, це як використовувати напів-структуровані дані для обміну, та як отримувати доступ до напів-структурованих даних через підтримку XML в Scala.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-13 20:05:38 EEST
</div>
</div>
</body>
</html>
