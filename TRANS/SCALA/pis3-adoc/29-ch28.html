<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__28">Глава 28</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___xml">Робота з XML</h1>
<div class="paragraph"><p>This chapter introduces Scala&#8217;s support for XML. After discussing semi-structured data in general, it
shows the essential functionality in Scala for manipulating XML: how to make nodes with XML
literals, how to save and load XML to files, and how to take apart XML nodes using query methods and
pattern matching. This chapter is just a brief introduction to what is possible with XML, but it shows
enough to get you started.
28.1 SEMI-STRUCTURED DATA
XML is a form of semi-structured data. It is more structured than plain strings, because it organizes the
contents of the data into a tree. Plain XML is less structured than the objects of a programming
language, though, as it admits free-form text between tags and it lacks a type system.<span class="footnote"><br />[There are type systems for XML, such as XML Schemas, but they are beyond the scope of this book.]<br /></span>
Semi-structured data is very helpful any time you need to serialize program data for saving in a file or
shipping across a network. Instead of converting structured data all the way down to bytes, you convert
it to and from semi-structured data. You then use pre-existing library routines to convert between semi-
structured data and binary data, saving your time for more important problems.
There are many forms of semi-structured data, but XML is the most widely used on the Internet. There
are XML tools on most operating systems, and most programming languages have XML libraries
available. Its popularity is self-reinforcing. The more tools and libraries are developed in response to
XML&#8217;s popularity, the more likely software engineers are to choose XML as part of their formats. If
you write software that communicates over the Internet, then sooner or later you will need to interact
with some service that speaks XML.
For all of these reasons, Scala includes special support for processing XML. This chapter shows you
Scala&#8217;s support for constructing XML, processing it with regular methods, and processing it with
Scala&#8217;s pattern matching. In addition to these nuts and bolts, the chapter shows along the way several
common idioms for using XML in Scala.
28.2 XML OVERVIEW
XML is built out of two basic elements, text and tags.<span class="footnote"><br />[The full story is more complicated, but this is enough to be effective with XML.]<br /></span> Text is, as usual, any sequence of characters.
Tags, written like &lt;pod&gt;, consist of a less-than sign, an alphanumeric label, and a greater than sign.
Tags can be start or end tags. An end tag looks just like a start tag except that it has a slash just before
the tag&#8217;s label, like this: &lt;/pod&gt;.
Start and end tags must match each other, just like parentheses. Any start tag must eventually be
followed by an end tag with the same label. Thus the following is illegal:

One &lt;pod&gt;, two &lt;pod&gt;, three &lt;pod&gt; zooFurther, the contents of any two matching tags must itself be valid XML. You cannot have two pairs of
matching tags overlap each other:

&lt;pod&gt;Three &lt;peas&gt; in the &lt;/pod&gt;&lt;/peas&gt;
You could, however, write it like this:
&lt;pod&gt;Three &lt;peas&gt;&lt;/peas&gt; in the &lt;/pod&gt;
Since tags are required to match in this way, XML is structured as nested elements. Each pair of
matching start and end tags forms an element, and elements may be nested within each other. In the
above example, the entirety of &lt;pod&gt;Three &lt;peas&gt;&lt;/peas&gt; in the &lt;/pod&gt; is an element,
and &lt;peas&gt;&lt;/peas&gt; is an element nested within it.
Those are the basics. Two other things you should know are, first, there is a shorthand notation for a
start tag followed immediately by its matching end tag. Simply write one tag with a slash put after the
tag&#8217;s label. Such a tag comprises an empty element. Using an empty element, the previous example
could just as well be written as follows:
&lt;pod&gt;Three &lt;peas/&gt; in the &lt;/pod&gt;
Second, start tags can have attributes attached to them. An attribute is a name-value pair written with
an equals sign in the middle. The attribute name itself is plain, unstructured text, and the value is
surrounded by either double quotes ("") or single quotes ("). Attributes look like this:
&lt;pod peas="3" strings="true"/&gt;
28.3 XML LITERALS
Scala lets you type in XML as a literal anywhere that an expression is valid. Simply type a start tag and
then continue writing XML content. The compiler will go into an XML-input mode and will read
content as XML until it sees the end tag matching the start tag you began with:
scala&gt; &lt;a&gt;
This is some XML.
Here is a tag: &lt;atag/&gt;
&lt;/a&gt;
res0: scala.xml.Elem =
&lt;a&gt;
This is some XML.
Here is a tag: &lt;atag/&gt;
&lt;/a&gt;
The result of this expression is of type Elem, meaning it is an XML element with a label ("a") and
children ("This is some XML&#8230;," etc.). Some other important XML classes are:
• Class Node is the abstract superclass of all XML node classes.
• Class Text is a node holding just text. For example, the "stuff" part of &lt;a&gt;stuff&lt;/a&gt; is of
classText.• Class NodeSeq holds a sequence of nodes. Many methods in the XML library processNodeSeqs
in places you might expect them to process individual Nodes. You can still use such methods
with individual nodes, however, since Node extends from NodeSeq. This may sound weird, but
it works out well for XML. You can think of an individual Node as a one-elementNodeSeq.
You are not restricted to writing out the exact XML you want, character for character. You can evaluate
Scala code in the middle of an XML literal by using curly braces ({}) as an escape. Here is a simple
example:
scala&gt; &lt;a&gt; {"hello" + ", world"} &lt;/a&gt;
res1: scala.xml.Elem = &lt;a&gt; hello, world &lt;/a&gt;
A braces escape can include arbitrary Scala content, including further XML literals. Thus, as the
nesting level increases, your code can switch back and forth between XML and ordinary Scala code.
Here&#8217;s an example:
scala&gt; val yearMade = 1955
yearMade: Int = 1955
scala&gt;
else xml.NodeSeq.Empty }
&lt;/a&gt;
res2: scala.xml.Elem =
&lt;a&gt; &lt;old&gt;1955&lt;/old&gt;
&lt;/a&gt;
If the code inside the curly braces evaluates to either an XML node or a sequence of XML nodes, those
nodes are inserted directly as is. In the above example, if yearMade is less than 2000, it is wrapped
in &lt;old&gt; tags and added to the &lt;a&gt; element. Otherwise, nothing is added. Note in the above example
that "nothing" as an XML node is denoted with xml.NodeSeq.Empty.
An expression inside a brace escape does not have to evaluate to an XML node. It can evaluate to any
Scala value. In such a case, the result is converted to a string and inserted as a text node:
scala&gt; &lt;a&gt; {3 + 4} &lt;/a&gt;
res3: scala.xml.Elem = &lt;a&gt; 7 &lt;/a&gt;
Any &lt;, &gt;, and &amp; characters in the text will be escaped if you print the node back out:
scala&gt; &lt;a&gt; {"&lt;/a&gt;potential security hole&lt;a&gt;"} &lt;/a&gt;
res4: scala.xml.Elem = &lt;a&gt; &lt;/a&gt;potential security
hole&lt;a&gt; &lt;/a&gt;
To contrast, if you create XML with low-level string operations, you will run into traps such as the
following:
scala&gt; "&lt;a&gt;" + "&lt;/a&gt;potential security hole&lt;a&gt;" + "&lt;/a&gt;"
res5: String = &lt;a&gt;&lt;/a&gt;potential security hole&lt;a&gt;&lt;/a&gt;
What happens here is that a user-supplied string has included XML tags of its own, in this
case &lt;/a&gt; and &lt;a&gt;. This behavior can allow some nasty surprises for the original programmer, becauseit allows the user to affect the resulting XML tree outside of the space provided for the user inside
the &lt;a&gt; element. You can prevent this entire class of problems by always constructing XML using
XML literals, not string appends.
28.4 SERIALIZATION
You have now seen enough of Scala&#8217;s XML support to write the first part of a serializer: conversion
from internal data structures to XML. All you need for this are XML literals and their brace escapes.
As an example, suppose you are implementing a database to keep track of your extensive collection of
vintage Coca-Cola thermometers. You might make the following internal class to hold entries in the
catalog:
abstract class CCTherm {
val description: String
val yearMade: Int
val dateObtained: String
val bookPrice: Int

val purchasePrice: Int // in US cents
val condition: Int

}
override def toString = description
This is a straightforward, data-heavy class that holds various pieces of information such as when the
thermometer was made, when you got it, and how much you paid for it.
To convert instances of this class to XML, simply add a toXML method that uses XML literals and
brace escapes, like this:
abstract class CCTherm {
&#8230;
def toXML =
&lt;cctherm&gt;
&lt;/cctherm&gt;
}
Here is the method in action:
scala&gt; val therm = new CCTherm {
val description = "hot dog #5"
val yearMade = 1952
val dateObtained = "March 14, 2006"
val bookPrice = 2199
val purchasePrice = 500
val condition = 9
}
therm: CCTherm = hot dog #5scala&gt; therm.toXML
res6: scala.xml.Elem =
&lt;cctherm&gt;
&lt;description&gt;hot dog #5&lt;/description&gt;
&lt;yearMade&gt;1952&lt;/yearMade&gt;
&lt;dateObtained&gt;March 14, 2006&lt;/dateObtained&gt;
&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
&lt;condition&gt;9&lt;/condition&gt;
&lt;/cctherm&gt;
Note
The "new CCTherm" expression in the previous example works even thoughCCTherm is an abstract
class, because this syntax actually instantiates an anonymous subclass of CCTherm. Anonymous
classes were described inSection 20.5.
By the way, if you want to include a curly brace (&#8216;{&#8217; or &#8216;}&#8217;) as XML text, as opposed to using them to
escape to Scala code, simply write two curly braces in a row:
scala&gt; &lt;a&gt; {{{{brace yourself!}}}} &lt;/a&gt;
res7: scala.xml.Elem = &lt;a&gt; {{brace yourself!}} &lt;/a&gt;
28.5 TAKING XML APART
Among the many methods available for the XML classes, there are three in particular that you should
be aware of. They allow you to take apart XML without thinking too much about the precise way XML
is represented in Scala. These methods are based on the XPath language for processing XML. As is
common in Scala, you can write them directly in Scala code instead of needing to invoke an external
tool.
Extracting text. By calling the text method on any XML node you retrieve all of the text within that
node, minus any element tags:
scala&gt; &lt;a&gt;Sounds &lt;tag/&gt; good&lt;/a&gt;.text
res8: String = Sounds good
Any encoded characters are decoded automatically:
scala&gt; &lt;a&gt; input ---&gt; output &lt;/a&gt;.text
res9: String = " input --&#8594; output "
Extracting sub-elements. If you want to find a sub-element by tag name, simply call \with the name of
the tag:
scala&gt; &lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; <sub>"b"
res10: scala.xml.NodeSeq = NodeSeq(&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;)
You can do a "deep search" and look through sub-sub-elements, etc., by using \\ instead of
the \ operator:
scala&gt;
&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; </sub>"c"res11: scala.xml.NodeSeq = NodeSeq()
scala&gt; &lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; ~"c"
res12: scala.xml.NodeSeq = NodeSeq(&lt;c&gt;hello&lt;/c&gt;)
scala&gt; &lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; <sub>"a"
res13: scala.xml.NodeSeq = NodeSeq()
scala&gt; &lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt; \</sub>"a"
res14: scala.xml.NodeSeq =
NodeSeq(&lt;a&gt;&lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;)
Note
Scala uses \ and \\ instead of XPath&#8217;s / and //. The reason is that // starts a comment in Scala! Thus,
some other symbol has to be used, and using the other kind of slashes works well.
Extracting attributes. You can extract tag attributes using the same \ and \\ methods.Simply put an at
sign (@) before the attribute name:
scala&gt; val joe = &lt;employee
name="Joe"
rank="code monkey"
serial="123"/&gt;
joe: scala.xml.Elem = &lt;employee name="Joe" rank="code monkey"
serial="123"/&gt;
scala&gt; joe <sub>"@name"
res15: scala.xml.NodeSeq = Joe
scala&gt; joe </sub>"@serial"
res16: scala.xml.NodeSeq = 123
28.6 DESERIALIZATION
Using the previous methods for taking XML apart, you can now write the dual of a serializer, a parser
from XML back into your internal data structures. For example, you can parse back
aCCTherm instance by using the following code:
def fromXML(node: scala.xml.Node): CCTherm =
new CCTherm {
val description
= (node <sub>"description").text
val yearMade
= (node </sub>"yearMade").text.toInt
val dateObtained = (node <sub>"dateObtained").text
val bookPrice
= (node </sub>"bookPrice").text.toInt
val purchasePrice = (node <sub>"purchasePrice").text.toInt
val condition
= (node </sub>"condition").text.toInt
}
This code searches through an input XML node, named node, to find each of the six pieces of data
needed to specify a CCTherm. The data that is text is extracted with .text and left as is. Here is this
method in action:
scala&gt; val node = therm.toXML
node: scala.xml.Elem =&lt;cctherm&gt;
&lt;description&gt;hot dog #5&lt;/description&gt;
&lt;yearMade&gt;1952&lt;/yearMade&gt;
&lt;dateObtained&gt;March 14, 2006&lt;/dateObtained&gt;
&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
&lt;condition&gt;9&lt;/condition&gt;
&lt;/cctherm&gt;
scala&gt; fromXML(node)
res17: CCTherm = hot dog #5
28.7 LOADING AND SAVING
There is one last part needed to write a data serializer: conversion between XML and streams of bytes.
This last part is the easiest, because there are library routines that will do it all for you. You simply have
to call the right routine on the right data.
To convert XML to a string, all you need is toString. The presence of a workable toString is why you
can experiment with XML in the Scala shell. However, it is better to use a library routine and convert
all the way to bytes. That way, the resulting XML can include a directive that specifies which character
encoding was used. If you encode the string to bytes yourself, then the onus is on you to keep track of
the character encoding.
To convert from XML to a file of bytes, you can use the XML.save command. You must specify a file
name and a node to be saved:
scala.xml.XML.save("therm1.xml", node)
After running the above command, the resulting file therm1.xml looks like the following:
&lt;?xml version=<em>1.0</em> encoding=<em>UTF-8</em>?&gt;
&lt;cctherm&gt;
&lt;description&gt;hot dog #5&lt;/description&gt;
&lt;yearMade&gt;1952&lt;/yearMade&gt;
&lt;dateObtained&gt;March 14, 2006&lt;/dateObtained&gt;
&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
&lt;condition&gt;9&lt;/condition&gt;
&lt;/cctherm&gt;
Loading is simpler than saving, because the file includes everything the loader needs to know. Simply
call XML.loadFile on a file name:
scala&gt; val loadnode = xml.XML.loadFile("therm1.xml")
loadnode: scala.xml.Elem =
&lt;cctherm&gt;
&lt;description&gt;hot dog #5&lt;/description&gt;
&lt;yearMade&gt;1952&lt;/yearMade&gt;
&lt;dateObtained&gt;March 14, 2006&lt;/dateObtained&gt;
&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
&lt;condition&gt;9&lt;/condition&gt;
&lt;/cctherm&gt;scala&gt; fromXML(loadnode)
res14: CCTherm = hot dog #5
Those are the basic methods you need. There are many variations on these loading and saving methods,
including methods for reading and writing to various kinds of readers, writers, input and output
streams.
28.8 PATTERN MATCHING ON XML
So far you have seen how to dissect XML using text and the XPath-like methods, \ and \\.These are
good when you know exactly what kind of XML structure you are taking apart. Sometimes, though,
there are a few possible structures the XML could have. Maybe there are multiple kinds of records
within the data, for example because you have extended your thermometer collection to include clocks
and sandwich plates. Maybe you simply want to skip over any white space between tags. Whatever the
reason, you can use the pattern matcher to sift through the possibilities.
An XML pattern looks just like an XML literal. The main difference is that if you insert a {}escape,
then the code inside the {} is not an expression but a pattern. A pattern embedded in{} can use the full
Scala pattern language, including binding new variables, performing type tests, and ignoring content
using the _ and <em>* patterns. Here is a simple example:
def proc(node: scala.xml.Node): String =
node match {
case _ &#8658; "It&#8217;s something else."
}
This function has a pattern match with three cases. The first case looks for an &lt;a&gt; element whose
contents consist of a single sub-node. It binds those contents to a variable namedcontents and then
evaluates the code to the right of the associated right arrow (&#8658;). The second case does the same thing
but looks for a &lt;b&gt; instead of an &lt;a&gt;, and the third case matches anything not matched by any other
case. Here is the function in use:
scala&gt;
res18:
scala&gt;
res19:
scala&gt;
res20:
proc(&lt;a&gt;apple&lt;/a&gt;)
String = It&#8217;s an a: apple
proc(&lt;b&gt;banana&lt;/b&gt;)
String = It&#8217;s a b: banana
proc(&lt;c&gt;cherry&lt;/c&gt;)
String = It&#8217;s something else.
Most likely this function is not exactly what you want, because it looks precisely for contents
consisting of a single sub-node within the &lt;a&gt; or &lt;b&gt;. Thus it will fail to match in cases like the
following:
scala&gt;
res21:
scala&gt;
res22:
proc(&lt;a&gt;a &lt;em&gt;red&lt;/em&gt; apple&lt;/a&gt;)
String = It&#8217;s something else.
proc(&lt;a/&gt;)
String = It&#8217;s something else.If you want the function to match in cases like these, you can match against a sequence of nodes
instead of a single one. The pattern for "any sequence" of XML nodes is written &#8216;</em>*&#8217;.Visually, this
sequence looks like the wildcard pattern (<em>) followed by a regex-style Kleene star (<strong>). Here is the
updated function that matches a sequence of sub-elements instead of a single sub-element:
def proc(node: scala.xml.Node): String =
node match {
case &lt;a&gt;{contents @ _</strong>}&lt;/a&gt; &#8658; "It&#8217;s an a: " + contents
case &lt;b&gt;{contents @ _*}&lt;/b&gt; &#8658; "It&#8217;s a b: " + contents
case _ &#8658; "It&#8217;s something else."
}
Notice that the result of the _* is bound to the contents variable by using the @ pattern described
in Section 15.2. Here is the new version in action:
scala&gt;
res23:
apple)
scala&gt;
res24:
proc(&lt;a&gt;a &lt;em&gt;red&lt;/em&gt; apple&lt;/a&gt;)
String = It&#8217;s an a: ArrayBuffer(a , &lt;em&gt;red&lt;/em&gt;,
proc(&lt;a/&gt;)
String = It&#8217;s an a: WrappedArray()
As a final tip, be aware that XML patterns work very nicely with for expressions as a way to iterate
through some parts of an XML tree while ignoring other parts. For example, suppose you wish to skip
over the white space between records in the following XML structure:
val catalog =
&lt;catalog&gt;
&lt;cctherm&gt;
&lt;description&gt;hot dog #5&lt;/description&gt;
&lt;yearMade&gt;1952&lt;/yearMade&gt;
&lt;dateObtained&gt;March 14, 2006&lt;/dateObtained&gt;
&lt;bookPrice&gt;2199&lt;/bookPrice&gt;
&lt;purchasePrice&gt;500&lt;/purchasePrice&gt;
&lt;condition&gt;9&lt;/condition&gt;
&lt;/cctherm&gt;
&lt;cctherm&gt;
&lt;description&gt;Sprite Boy&lt;/description&gt;
&lt;yearMade&gt;1964&lt;/yearMade&gt;
&lt;dateObtained&gt;April 28, 2003&lt;/dateObtained&gt;
&lt;bookPrice&gt;1695&lt;/bookPrice&gt;
&lt;purchasePrice&gt;595&lt;/purchasePrice&gt;
&lt;condition&gt;5&lt;/condition&gt;
&lt;/cctherm&gt;
&lt;/catalog&gt;
Visually, it looks like there are two nodes inside the &lt;catalog&gt; element. Actually, though, there are five.
There is white space before, after, and between the two elements! If you do not consider this white
space, you might incorrectly process the thermometer records as follows:
catalog match {
case &lt;catalog&gt;{therms @ _*}&lt;/catalog&gt; &#8658;
for (therm &#8592; therms)
println("processing: "<br />
(therm <sub>"description").text)
}processing:
processing: hot dog #5
processing:
processing: Sprite Boy
processing:
Notice all of the lines that try to process white space as if it were a true thermometer record. What you
would really like to do is ignore the white space and process only those sub-nodes that are inside
a &lt;cctherm&gt; element. You can describe this subset using the pattern &lt;cctherm&gt;{</em>*}&lt;/cctherm&gt;, and
you can restrict the for expression to iterating over items that match that pattern:
catalog match {
case &lt;catalog&gt;{therms @ <em>*}&lt;/catalog&gt; &#8658;
for (therm @ &lt;cctherm&gt;{</em>*}&lt;/cctherm&gt; &#8592;
println("processing: "<br />
(therm </sub>"description").text)
}
therms)
processing: hot dog #5
processing: Sprite Boy
28.9 CONCLUSION
This chapter has only scratched the surface of what you can do with XML. There are many other
extensions, libraries, and tools you could learn about, some customized for Scala, some made for Java
but usable in Scala, and some language-neutral. What you should walk away from this chapter with is
how to use semi-structured data for interchange, and how to access semi-structured data via Scala&#8217;s
XML support.
Footnotes for Chapter 28:
[1] .</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-18 00:14:22 EET
</div>
</div>
</body>
</html>
