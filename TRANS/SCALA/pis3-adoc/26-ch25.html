<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__25">Глава 25</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___scala">Архитектура колекцій Scala</h1>
<div class="paragraph"><p>Ця глава описує архитектуру фреймворка колекцій Scala в деталях. Продовжуючи тему Глави 24, ви знайдете більше щодо внутрішньої роботи фреймворка. Ви також навчитесь, як ця архитектура допомагає вам визначити ваші власні колекції в декількох рядках коду, при цьому використовуючи значну частину функціональності колекцій з фреймворку.</p></div>
<div class="paragraph"><p>Глава 24 перелічує велику кількість операцій з колекціями, що існують одноманітно на великій кількості реалізацій колекцій. Реалізація кожної операції колекцій поновій для кожного типу колекцій може призвести до значного обсягу коду, більшість якого буде копіюваться з інших місць. Така дублікація коду може з часом призвести до неузгодженості, коли операція додається або модифікується в одній частині бібліотеки колекцій, але не інших. Принципова ціль розробки фреймворка нових колекцій було уникнути жодних дублікацій, визначення кожної операції в стількох небагатьох місцях, наскільки це можливо.<span class="footnote"><br />[Ідеально все має бути визначено тільки в одному місці, але є декілька виключень, де речі мають бути перевизначені.]<br /></span> Підхід розробки полягав в визначенні більшость операцій в "шаблонах" колекцій, що можуть бути гнучко наслідувані від окремих базових класів та реалізацій. В цій главі ми дослідимо ці шаблони, та інші класи і трейти, що складають "будівельні блоки" фреймворка, так само, як принципи конструкції, які вони підтримують.</p></div>
<div class="sect1">
<h2 id="_25_1_">25.1 Будівельники</h2>
<div class="sectionbody">
<div class="paragraph"><p>Майже всі операції колекцій реалізовані в термінах проходів та будівельників. Перехідні обробляються методом <code>Traversable</code> <code>foreach</code>, та побудова новий колекцій обробляється примірниками класу <code>Builder</code>. Лістинг 25.1 представляє дещо скорочений конутр цього класу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection.generic</span>
<span class="k">class</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+=(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.type</span>
  <span class="k">def</span> <span class="n">result</span><span class="o">()</span><span class="k">:</span> <span class="kt">To</span>
  <span class="k">def</span> <span class="n">clear</span><span class="o">()</span>
  <span class="k">def</span> <span class="n">mapResult</span><span class="o">[</span><span class="kt">NewTo</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">To</span> <span class="o">=&gt;</span> <span class="nc">NewTo</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">NewTo</span><span class="o">]</span>
  <span class="k">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.1 - Контур класу <code>Builder</code>.</p></div>
<div class="paragraph"><p>Ви можете додати елемент <code>x</code> до білдера <code>b</code> за допомогою <code>b += x</code>. Також є синтаксис для додавання більше одного елемента за раз: наприклад <code>b += (x, y)</code> та <code>b ++= xs</code> роблять як для буферів. (Фактично, буфери є підсиленими версіями будівельників). Метод  <code>result()</code> повертає колекцію з будівельника. Стан будівельника невизначений після отримання його результату, але він може бути скинутий в новий порожній стан з використанням <code>clear()</code>. Будівельники є дженеріками по обох, типі елементів <code>Elem</code>, та по <code>To</code>, типу колекції, яку він повертає.</p></div>
<div class="paragraph"><p>Часто будівельник може посилатись на деякий інший будівельник для збирання елементів колекції, але потім трансформує результат іншого будівництва, щоб отримати інший тип. Це завдання спрощене методом <code>mapResult</code> в класі <code>Builder</code>. Уявімо, наприклад, що ви маєте буфер масиву <code>buf</code>. Буфери масивів є будівельниками для самих себе, так що отримання  <code>result()</code> буфера масива буде повертати той самий буфер. Якщо ви бажаєте використовувати цей буфер для продукування будівельника, що будує масиви, ви можете використати <code>mapResult</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">scala.collection.mutable.ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bldr</span> <span class="k">=</span> <span class="n">buf</span> <span class="n">mapResult</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toArray</span><span class="o">)</span>
<span class="n">bldr</span><span class="k">:</span> <span class="kt">scala.collection.mutable.Builder</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
    <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення результату <code>bldr</code> є будівельник, що використовує буфер масивів <code>buf</code> для збирання елементів. Коли треба результат від <code>bldr</code> обчислюється результат <code>buf</code>, що дає сам буфер масива <code>buf</code>. Цей буфер потім відображується за допомогою <code>_.toArray</code> на масив. Так що кінцевий результат в тому, що <code>bldr</code> є будівельник для масивів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_25_2___">25.2 Виділення загальних операцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Головними цілями дизайну бібліотеки колекцій є мати одночасно природні типи та максимальне поділення коду реалізації. Зокрема, колекції Scala слідують принципу "того самого результату": коли це можливо, метод трансформації для колекції буде видавати колекцію того самого типу. Наприклад, операція <code>filter</code> має видавати на кожному типу колекцій примірник того самого типу. Застосування <code>filter</code> до <code>List</code> повинно давати <code>List</code>; застосування його до <code>Map</code> має давати <code>Map</code>; і так далі. В залишку цього розділу ви побачите, як це досягається.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>Матеріал в цьому розділу трохи плотніший ніж звичайно, та може потребувати часу для сприйняття. Якщо ви бажаєте рухатись вперед швидко, ви можете пропустити залишок цього розділу, та перейти до Розділу 25.3, де ви навчатиметесь на конкретних прикладах, як інтегрувати ваші власні класи колекцій в фреймворк.</p></div>
<div class="paragraph"><p>Бібліотека колекцій Scala уникає дублікації коду, та досягає принциту "того самого результату" через використання дженерік будівельників та проходах по колекціях в так званих трейтах реалізації. Ці трейти названі з суфіксом <code>Like</code>; наприклад, <code>IndexedSeqLike</code> є трейтом реалізаціх для <code>IndexedSeq</code>, та подібно до цього, <code>TraversableLike</code> є трейтом реалізації для <code>Traversable</code>. Класи колекції, такі як <code>Traversable</code> або <code>IndexedSeq</code>, наслідують всі свої суцільні методи реалізації від ціх трейтів. Трейти реалізації мають два параметри типу, замість одного для нормальних колекцій. Вони параметризують не тільки тип елементів колекції, але також тип репрезентації колекції (тобто тип підлеглої колекції), такий як <code>Seq[I]</code> або <code>List[T]</code>.</p></div>
<div class="paragraph"><p>Наприклад, ось заголовок трейта <code>TraversableLike</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">trait</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметр типу <code>Elem</code> означає тип елемента перехідного, тоді як параметр типу <code>Repr</code> означає тип репрезентації. Немає обмежень на <code>Repr</code>. Зокрема, <code>Repr</code> може бути втілено в тип, що сам не є субтипом <code>Traversable</code>. Таким чином, класи за межами ієрархії колекцій, такі як <code>String</code> та <code>Array</code>, все ще можуть використовувати всі операції, визначені в трейті реалізації колекції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection</span>
<span class="k">trait</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Repr</span><span class="o">]</span> <span class="c1">// відкладене</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
<span class="c1">// відкладене</span>
            <span class="o">...</span>
  <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">newBuilder</span>
    <span class="n">foreach</span> <span class="o">{</span> <span class="n">elem</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">elem</span> <span class="o">}</span>
    <span class="n">b</span><span class="o">.</span><span class="n">result</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.2 - Реалізація <code>filter</code> в <code>TraversableLike</code>.</p></div>
<div class="paragraph"><p>Беручи <code>filter</code> в якості приклада, ця операція визначається один раз для всіх класів колекцій в трейті <code>TraversableLike</code>. Нарис відповідного коду показаний в Лістингу 25.2. Трейт декларує два абстрактні методи, <code>newBuilder</code> та <code>foreach</code>, що реалізовані в суцільних класах колекцій. Операція <code>filter</code> реалізована в однаковий спосіб для всіх колекцій, використовуючи ці методи. Він зпочатку конструює нового будівельника для типу репрезентації <code>Repr</code>, використовуючи <code>newBuilder</code>. Потім він проходить по всіх елементах поточної колекції з використанням <code>foreach</code>. Якщо елемент <code>x</code> задовільняє наданому предикату <code>p</code> — тобто, <code>p(x)</code> є <code>true</code> — елемент додається через будівельника. Нарешті, елементи, що побудовані в будівельнику, повертаються як примірник типу колекції <code>Repr</code>, через виклик метода будівельника <code>result</code>.</p></div>
<div class="paragraph"><p>Операція <code>map</code> на колекціях трохи більш складна. Наприклад, як <code>f</code> є функція від <code>String</code> до <code>Int</code>, і <code>xs</code> є <code>List[String]</code>, тоді <code>xs map f</code> має видавати <code>List[Int]</code>. Подібним чином, якщо <code>ys</code> є <code>Array[String]</code>, тоді <code>ys map f</code> повинно давате <code>Array[Int]</code>. Але як ви досягнете цього, без дублікації визначення метода <code>map</code> в списках та масивах?</p></div>
<div class="paragraph"><p>Фреймворк <code>newBuilder</code>/<code>foreach</code>, показаний в Лістингу 25.2, недостатній для цього, оскільки він дозволяє створення нових примірників того самого типу колекцій, тоді як <code>map</code> потребує примірник того самого типу конструктора, але можливо з іншим типом елемента. Більше того, навіть конструктор результуючого типу функції як <code>map</code>, може залежати в нетрівіальний спосіб від типів інших аргументів. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">collection.immutable.BitSet</span>
<span class="k">import</span> <span class="nn">collection.immutable.BitSet</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">bits</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.immutable.BitSet</span> <span class="o">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">bits</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toFloat</span><span class="o">)</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Set</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Set</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">,</span> <span class="mf">3.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви відобразите бітову множину через функцію подвоєння <code>_ * 2</code>, ви отримєте іншу бітову множину. Однак, якщо ви відобразите ту ж множину через функцію <code>(_.toFloat)</code>, результатом буде загальний <code>Set[Float]</code>. Звичайно, це не може бути бітова множина, бо бітові множини містять <code>Int</code>, не <code>Float</code>.</p></div>
<div class="paragraph"><p>Зауважте, що тип результата <code>map</code> залежить від типу функції, що передається до нього. Якщо тип результата цього функціонального аргумента знову <code>Int</code>, результатом <code>map</code> буде <code>BitSet</code>. Але якщо тип результату функціонального аргументу є щось інше, результатом <code>map</code> є простий <code>Set</code>. Скоро ви з'ясуєте, як досягається ця гнучкість типів в Scala.</p></div>
<div class="paragraph"><p>Проблема з <code>BitSet</code> не є ізольованим випадком. Ось дві інші взаємодії з інтерпретатором, що відображують функцію через <code>map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;b&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="o">}</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">java.lang.String</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;a&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;b&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">}</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перша функція обмінює два аргументи пари ключ/значення. Результат відображення цієї функції є знову мапа, але тепер ідемо в іншому напрямку. Фактично, перший вираз дає інверсію оригінальної мапи, зважаючи, що це можливо зробити. Однак друга функція відображує пару ключ/значення на ціле, а саме на частину значення. В цьому випадку ми не можемо сформувати з результату <code>Map</code>, але ми все ще можемо сформувати <code>Iterable</code>, супертрейт <code>Map</code>.</p></div>
<div class="paragraph"><p>Ви можете запитати, чому не обмежити <code>map</code> так, щоб він завжди повертав той самий тип колекції? Наприклад, на бітових множинах <code>map</code> міг би сприймати тільки функції <code>Int</code>-до-<code>Int</code>, та на мапах він міг би сприймати тільки функції пара-до-пари. Це обмеження не тільки небажане з об'єктно-орієнтовної точки зору, воно також нелегальне, бо це порушує принцип підстановки Ліскова: якщо <code>Map</code> є <code>Iterable</code>, кожна операція, що є легальною на <code>Iterable</code>, мусить бути легальною на <code>Map</code>.</p></div>
<div class="paragraph"><p>Замість цього Scala вирішує цю проблему за допомогою перевантаження: не тої простої форми перевантаження, наслідуваної від Java (що не може бути достатньо гнучкою), але більш систематичної форми перевантаження, що провадиться через неявні параметри.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">bf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">bf</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">)</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="n">b</span><span class="o">.</span><span class="n">result</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.3 - Реалізація <code>map</code> в <code>TraversableLike</code>.</p></div>
<div class="paragraph"><p>Лістинг 25.3 показує трейт <code>TraversableLike</code> в частині реалізації <code>map</code>. Це досить подібно до реалізації <code>filter</code>, показаного в Лістингу 25.2. Принципова різниця в тому, що <code>filter</code> використовує метод <code>newBuilder</code>, що є абстрактним в класі <code>TraversableLike</code>, але <code>map</code> використовує фабрику будівельника, що передається як додатковий неявний параметр типу <code>CanBuildFrom</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection.generic</span>
<span class="k">trait</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
<span class="c1">// Створює нового будівельника</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">From</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.4 - Трейт <code>CanBuildFrom</code>.</p></div>
<div class="paragraph"><p>Лістинг 25.4 показує визначення трейта <code>CanBuildFrom</code>, що представляє фабрики будівельниуів. Він має три параметри типу: <code>Elem</code> вказує тип елемента колекції, що має бути побудована, <code>To</code> вказує на тип колекції, що будується, та <code>From</code> вказує тип, для якого застосовуєть ця фабрика будівельників. Через визначення правильних неявних визначень фабрик будівельника, ви можете викроїти вірну поведінку типів, як треба.</p></div>
<div class="paragraph"><p>Візьмемо клас <code>BitSet</code> в якості приклада. Його об'єкт компанйон містить фабрику будівельника типу <code>CanBuildFrom[BitSet, Int, BitSet]</code>. Це означає, що коли робите з <code>BitSet</code>, ви можете сконструювати інший <code>BitSet</code>, маючи що тип колекції для побудови є <code>Int</code>. Якщо це не так, ви завжди можете відкотитись до різних інших неявних фабрик будівельника, на цей раз реалізованих в об'єкті компанйоні <code>mutable.Set</code>. Тип цієї, більш загальної, фабрики будівельника, де <code>A</code> є дженерік параметр типу, такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це означає, що коли ви оперуєте з довільним <code>Set</code>, вираженим типом з підстановкою <code>Set[_]</code>, ви знову можете побудувати <code>Set</code>, неважливо, який є тип елементу <code>A</code>. Маючи ці два неявні примірника <code>CanBuildFrom</code>, ви можете покладатись на правила Scala щодо розрішення неявних, щоб обрати той варіант, що відповідає ситуації і є найбільш специфічним.</p></div>
<div class="paragraph"><p>Так що неявне розрішення провадить коректні статичні типи для складних операцій з колекціями, як <code>map</code>. Але що до динамічних типів? Зокрема, скажімо, якщо ви маєте значення списку, що має <code>Iterable</code> як свій статичний тип, і ви відображуєте деяку функцію по цьому значенню:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>
<span class="n">ys</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Статичний тип <code>ys</code> вище є <code>Iterable</code>, як і очікувалось. Але його динамічний тип є (і має бути) <code>List</code>! Ця поведінка досягається ще одним перенаправленням. Метод <code>apply</code> в <code>CanBuildFrom</code> отримує колекцію джерела як аргумент. Більшість фабрик будівельника для дженеріків перехідних (фактично всі, за винятком фабрик будівельника для класів листів) пересилають виклик до метода <code>genericBuilder</code> колекції.</p></div>
<div class="paragraph"><p>В свою чергу метод <code>genericBuilder</code> викликає будівельник, що належить до колекції, в якій він визначений. Так що Scala використовує неявне розрішення для визначення обмежень по типах <code>map</code>, та віртуально скеровує для обрання кращого динамічного типу, що відповідає цім обмеженням.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_25_3___">25.3 Інтеграція нових колекцій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Що треба зробити, якщо ви бажаєте інтегрувати новий клас колекції, так щоб ви могли отримати вигоди від всіх попередньо визначених операцій від правильних типів? В цьому розділі ми покажемо вам два приклада як це робиться.</p></div>
<div class="sect2">
<h3 id="___2">Інтеграція послідовностей</h3>
<div class="paragraph"><p>Скажімо, ви бажаєте створити новий тип послідовності для спіралей РНК, що є послідовностями основ: A (аденін), T (тимін), G (гуанін) та U (урацил). Визначення для основ встановлюються просто, як показано на Лістингу 25.5.</p></div>
<div class="paragraph"><p>Кожна база визначена як кейс об'єкт, що наслідує від загального абстрактного класу <code>Base</code>. Клас <code>Base</code> має об'єкт компанйон, що визначає дві функції, які пов'язують основи з цілими від 0 до 3. Ви можете побачити на прикладах два різні шляхи використовувати колекції для реалізації ціх функцій. Функція <code>toInt</code> реалізована як <code>Map</code> від значень  <code>Base</code> на цілі. Зворотня функція, <code>fromInt</code>, реалізована як масив. Це використовує факт, що обоє, мапи та масиви є функціями, оскільки вони наслідують від трейта <code>Function1</code>.</p></div>
<div class="paragraph"><p>Наступне завдання визначити клас для спіралей РНК. Концептуально такий ланцюжок РНК є просто <code>Seq[Base]</code>. Однак ланцюжок РНК може стати досить довгим, так що має сенс докласти деякої роботи для компактної репрезентації. Оскільки основ тільки чотири, основа може бути ідентифікована чотирьма бітами, і ви можете зберігати шістнадцять основ в двобайтному значенні як ціле. Тоді ідея побудувати особливий клас <code>Seq[Base]</code>, що використовує цю запаковану репрезентацію.</p></div>
<div class="paragraph"><p>Лістинг 25.6 представляє першу версію цього класу; пізніше вона буде покращена. Клас RNA1 має конструктор, що приймає масив з <code>Int</code> в якості першого елемента. Цей масив містить запаковані дані RNA з шістнадцятьма основами на один елемент, за винятком останнього елементу масива, що може бути заповнений частково. Другий аргумент, довжина, вказує загальну кількість основ в масиві (та в послідовності). Клас <code>RNA1</code> розширює <code>IndexedSeq[Base]</code>. Трейт <code>IndexedSeq</code>, що надходить з пакунка <code>scala.collection.immutable</code>, визначає два абстрактні методи, <code>length</code> та <code>apply</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">T</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">G</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">U</span> <span class="k">extends</span> <span class="nc">Base</span>

<span class="k">object</span> <span class="nc">Base</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">fromInt</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Base</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">toInt</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">G</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">U</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.5 - Основи РНК.</p></div>
<div class="paragraph"><p>Ці методи мають бути реалізованими в суцільних субкласах. Клас <code>RNA1</code> реалізує <code>length</code> автоматично, через визначення параметрического поля (описане в Розділі 10.6) з саме таким ім'ям. Він реалізує метод індексації <code>apply</code> за допомогою кода, наданому в Лістингу 25.6. По суті <code>apply</code> зпочатку виділяє ціле значення з масиву <code>groups</code>, потім виділяє коректне двобітне число з цього цілого з використанням зсува (&gt;&gt;) та маски (&amp;). Приватні константи <code>S</code>, <code>N</code> та <code>M</code> надходять від об'єкта компанйона <code>RNA1</code>. <code>S</code> вказує розмір кожного пакета (тобто, два); <code>N</code> задає число двобітних пакетів в цілому; нарешті, <code>M</code> є бітова маска, що ізолює молодші <code>S</code> біт в слові.</p></div>
<div class="paragraph"><p>Зауважте, що конструктор класу <code>RNA1</code> є приватним. Це означає, що клієнти не можуть створювати послідовності <code>RNA1</code> через виклик <code>new</code>, що має сенс, оскільки приховує реалізацію послідовностей <code>RNA1</code> в термінах запакованих масивів від користувача. Якщо клієнти не можуть бачити, які деталі репрезентації послідовностей РНК, стає можливим змінити цю репрезентацію в любій точці в майбутньому, не впливаючи на клієнтській код.</p></div>
<div class="paragraph"><p>Іншими словами, цей дизайн досягає гарного розділення інтерфейса РНК послідовностей, та його реалізації. Однак, якщо конструювання РНК послідовності за допомогою <code>new</code> неможливе, має бути якійсь інший шлях створювати нові РНК послідовності, або інакше цілий клас буде скоріше некорисним. Є дві альтернативи для створення РНК послідовності, обоє провадяться об'єктом компанйоном <code>RNA1</code>. Перший шлях є метод <code>fromSeq</code>, що конвертує надану послідовність основ (тобто значення типу <code>Seq[Base]</code>) в послідовність класу <code>RNA1</code>. Метод <code>fromSeq</code> робить це через пакування всіх основ, що містяться в послідовності аргументі в масив, потім викликаючи приватний конструктор RNA1 з цім масивом та довжиною оригінальної послідовності в якості аргументів. Це задіє використання факта, що приватний конструктор видимий до об'єкта компанйона класу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">collection.IndexedSeqLike</span>
<span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">Builder</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">collection.generic.CanBuildFrom</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">RNA1</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span>
    <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA1._</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>
    <span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">groups</span><span class="o">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">RNA1</span> <span class="o">{</span>
<span class="c1">// Число біт для представлення групи</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">S</span> <span class="k">=</span> <span class="mi">2</span>

<span class="c1">// Число груп, що містяться в Int</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="mi">32</span> <span class="o">/</span> <span class="n">S</span>

<span class="c1">// Бітова маска для ізоляції групи</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span>

  <span class="k">def</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Base</span><span class="o">])</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">groups</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]((</span><span class="n">buf</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">|=</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span><span class="o">(</span><span class="n">buf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span>
    <span class="k">new</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">bases</span><span class="k">:</span> <span class="kt">Base*</span><span class="o">)</span> <span class="k">=</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">bases</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.6 - Перша версія класу РНК ланцюжків.</p></div>
<div class="paragraph"><p>Другий спосіб створити значення <code>RNA1</code> є провадження метода <code>apply</code> в об'єкті <code>RNA1</code>. Він приймає змінне число аргументів <code>Base</code>, та просто пересилає їх як послідовність до <code>fromSeq</code>.</p></div>
<div class="paragraph"><p>Ось обидві схеми створення в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Product</span> <span class="kt">with</span> <span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">RNA1</span><span class="o">.</span><span class="n">fromSeq</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna1</span> <span class="k">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna1</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____code_rna_code">Адаптація типу результатів методів <code>RNA</code></h3>
<div class="paragraph"><p>Ось ще деякі інтеракції з абстракцією <code>RNA1</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna1</span><span class="o">.</span><span class="n">length</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna1</span><span class="o">.</span><span class="n">last</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="n">T</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna1</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перші два результати виглядають очікуваними, але останній результат отримання трьох елементів від <code>rna1</code>, можливо, ні. Фактично, ви бачите <code>IndexedSeq[Base]</code> як статичний тип результату, та <code>Vector</code> як динамічний тип значення результату. Ви можливо очікували замість цього отримати значення <code>RNA1</code>. Але це неможливо, оскільки все, що ми зробили в Лістингу 25.6, це зробили <code>RNA1</code> розширенням <code>IndexedSeq</code>. Клас <code>IndexedSeq</code>, з іншого боку, має метод <code>take</code>, що повертає <code>IndexedSeq</code>, і це реалізоване в термінах реалізації <code>IndexedSeq</code> по замовчанню, а саме <code>Vector</code>.</p></div>
<div class="paragraph"><p>Тепер, коли ви зрозуміли, чому все відбувається як відбувається, наступне запитання має бути: що треба зробити, щоб змінити це? Один спосіб зробити це може бути перекрити метод <code>take</code> в класі <code>RNA1</code>, можливо так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">take</span><span class="o">(</span><span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">.</span><span class="n">fromSeq</span><span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="n">count</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Це зробить свою роботу для <code>take</code>. Але як щодо <code>drop</code>, або <code>filter</code>, або <code>init</code>? Фактично є більше п'ятидесяти методів на послідовностях, що знову повертають послідовність. Для сумісності всі вони мають бути перекриті. Це менше і менше виглядає як приваблива опція.</p></div>
<div class="paragraph"><p>Нащастя, існує значно простіший спосіб досягти того самого ефекту. Клас <code>RNA</code> має наслідувати не тільки від <code>IndexedSeq</code>, але також від його трейта реалізації <code>IndexedSeqLike</code>. Це показане в Лістингу 25.7. Нова реалізація відрізняється від попередньої тільки в двох аспектах. Перше, клас <code>RNA2</code> тепер також розширяє <code>IndexedSeqLike[Base, RNA2]</code>. Трейт <code>IndexedSeqLike</code> реалізує всі суцільні методи <code>IndexedSeq</code> в розширюваний спосіб.</p></div>
<div class="paragraph"><p>Наприклад, тип повернення методів як <code>take</code>, <code>drop</code>, <code>filter</code> або <code>init</code> є другим параметром типу, переданим до класу <code>IndexedSeqLike</code> (тобто, <code>RNA2</code> в Лістингу 25.7). Щоб зробити це, <code>IndexedSeqLike</code> базує себе на абстракції <code>newBuilder</code>, що створює будівельник правильного різновиду. Субкласи трейту <code>IndexedSeqLike</code> мають перекрити <code>newBuilder</code>, щоб повертати колекції свого власного типу. В класі <code>RNA2</code> метод  <code>newBuilder</code> повертає будівельника типу <code>Builder[Base, RNA2]</code>. Щоб сконструювати цього будівельника він спочатку створює <code>ArrayBuffer</code>, що сам є <code>Builder[Base, ArrayBuffer]</code>. Потім він трансформує будівельник <code>ArrayBuffer</code> через власний метод <code>mapResult</code> до будівельника <code>RNA2</code>. Метод <code>mapResult</code> очікує функцію трансформації від <code>ArrayBuffer</code> до <code>RNA2</code> в якості параметра. Функція є просто <code>RNA2.fromSeq</code>, що конвертує довільну базову послідовність на значення <code>RNA2</code> (згадайте, що буфер масива є різновид послідовності, так що до нього може бути застосований <code>RNA2.fromSeq</code>).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">class</span> <span class="nc">RNA2</span> <span class="k">private</span> <span class="o">(</span>
  <span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">with</span> <span class="nc">IndexedSeqLike</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA2</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA2._</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA2</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="n">mapResult</span> <span class="n">fromSeq</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="c1">// як раніше</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.7 - Клас ланцюжка РНК, друга версія.</p></div>
<div class="paragraph"><p>Якщо ви забудете визначення <code>newBuilder</code>, ви отримаєте повідомлення про помилку, приблизно такого змісту:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">RNA2</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">5</span><span class="kt">:</span> <span class="kt">error:</span> <span class="kt">overriding</span> <span class="kt">method</span> <span class="kt">newBuilder</span> <span class="kt">in</span> <span class="kt">trait</span>
<span class="nc">TraversableLike</span> <span class="n">of</span> <span class="k">type</span> <span class="o">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Builder</span><span class="o">[</span><span class="kt">Base</span>,<span class="kt">RNA2</span><span class="o">];</span>
  <span class="n">method</span> <span class="n">newBuilder</span> <span class="n">in</span> <span class="k">trait</span> <span class="nc">GenericTraversableTemplate</span> <span class="n">of</span> <span class="k">type</span>
  <span class="o">=&gt;</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Builder</span><span class="o">[</span><span class="kt">Base</span>,<span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]]</span> <span class="n">has</span>
  <span class="n">incompatible</span> <span class="k">type</span>
<span class="kt">class</span> <span class="kt">RNA2</span> <span class="kt">private</span> <span class="o">(</span><span class="kt">val</span> <span class="kt">groups:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
      <span class="o">^</span>
<span class="n">one</span> <span class="n">error</span> <span class="n">found</span>
</pre></div></div></div>
<div class="paragraph"><p>Повідомлення про помилку досить довге та заскладне, що відзеркалює плутаний шлях, яким бібліотеки колекцій складаються докупи. Краще проігнорувати інформацію щодо того, звідки походять методи, бо це випадок, коли це більше заважає, ніж допомагає. Що залишається, це те, що метод <code>newBuilder</code> з типом результата <code>Builder[Base, RNA2]</code> має бути визначений, але був знайдений лише метод <code>newBuilder</code> з типом результата <code>Builder[Base,IndexedSeq[Base]]</code>. Останній не перекриває попередній.</p></div>
<div class="paragraph"><p>Перший метод, чий тип результата <code>Builder[Base, RNA2]</code>, є абстрактним методом, що був втілений в цьому типі в Лістингу 25.7, через передачу параметра типу до <code>IndexedSeqLike</code>. Другий метод, з типом результата <code>Builder[Base,IndexedSeq[Base]]</code>, є те, що провадиться наслідуваним класом <code>IndexedSeq</code>. Іншими словами, клас <code>RNA2</code> є невалідним без визначення <code>newBuilder</code> з першим типом результата.</p></div>
<div class="paragraph"><p>З покращеною реалізацією класа <code>RNA</code> в Лістингу 25.7, методи як <code>take</code>, <code>drop</code> або <code>filter</code> роблять як очікується:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna2</span> <span class="k">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna2</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="n">take</span> <span class="mi">3</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="n">filter</span> <span class="o">(</span><span class="n">U</span> <span class="o">!=)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_map_code__">Справи з <code>map</code> та друзями</h3>
<div class="paragraph"><p>Існує інший клас методів, з якими ми досі не мали справи. Ці методи не завжди повертають колекцію точно того самого типу. Вони можуть повернути той самий різновид колекції, але з іншим типом елементів. Класичним прикладом є метод <code>map</code>. Якщо є <code>Seq[Int]</code>, та <code>f</code> є функція від <code>Int</code> до <code>String</code>, тоді <code>s.map(f)</code> буде повертати <code>Seq[String]</code>. Так що тип елементу змінюється від отримувача до результата, але різновид колекції залишається такий самий.</p></div>
<div class="paragraph"><p>Існує декілька інших методів, що поводяться як <code>map</code>. Для деяких з них ви можете очікувати цього (як <code>flatMap</code>, <code>collect</code>), але від інших ні. Наприклад, метод додавання, <code>++</code>, також може повертати результат, тип якого відрізняється від його аргументів — додавання списку зі <code>String</code> до списку <code>Int</code> буде давати список з <code>Any</code>. Як ці методи мають бути адаптовані до ланцюжків <code>RNA</code>? В ідеалі ми очікуємо, що відображення від основи до основи на РНК має знову давати ланцюжок РНК:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna</span> <span class="k">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">case</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">}</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібним чином, додавання двох ланцюжків за допомогою <code>++</code> має давати новий ланцюжор РНК:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="o">++</span> <span class="n">rna</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку, відображення основи на якійсь інший тип на РНК ланцюжку не може дати новий ланцюжок, оскільки нові елементи мають не той тип. Замість цього буде видана послідовність. В тому ж дусі, додавання елементів, що не є типу <code>Base</code> до ланцюжка дає загальну послідовність, але ніколи не може дати новий ланцюжок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="n">map</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;missing&quot;</span><span class="o">,</span> <span class="s">&quot;data&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">java.lang.Object</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Vector</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">missing</span><span class="o">,</span> <span class="n">data</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це те, що ми очікуємо в ідеальному випадку. Але це не те, що провадить клас <code>RNA2</code>, як він є в Лістингу 25.7. Фактично, якщо ви запустите перші два приклади вище з цім класом, ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">rna2</span> <span class="k">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna2</span><span class="k">:</span> <span class="kt">RNA2</span> <span class="o">=</span> <span class="nc">RNA2</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">case</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">}</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">T</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">rna2</span> <span class="o">++</span> <span class="n">rna2</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що результат <code>map</code> та <code>++</code> ніколи не буде ланцюжком, навіть якщо тип елементів згенерованої колекції буде <code>Base</code>. Щоб побачити, як зробити краще, має сенс подивитись на сигнатуру метода <code>map</code> (або <code>++</code>, що має подібну сигнатуру). Оригінально метод <code>map</code> визначений в класі <code>scala.collection.TraversableLike</code> з наступною сигнатурою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cbf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>Elem</code> є типом елементів колекції, та <code>Repr</code> є типом самої колекції; тобто, другий параметр типу, що передається до класу реалізації, такий як <code>TraversableLike</code> та <code>IndexedSeqLike</code>. Метод <code>map</code> приймає два інші параметри типу, <code>B</code> та <code>That</code>.</p></div>
<div class="paragraph"><p>Параметр <code>B</code> позначає тип результату функції відображення, що також є типом елементів нової колекції. <code>That</code> з'являється як тип мапи, так що він представляє тип нової колекції,що створюється.</p></div>
<div class="paragraph"><p>Як визначається тип <code>That</code>? Він зв'язується з іншими типами через неявний параметр <code>cbf</code> за типом <code>CanBuildFrom[Repr, B, That]</code>. Ці неявні <code>CanBuildFrom</code> визначені індивідуальними класами колекцій. В основному неявне значення типу <code>CanBuildFrom[From, Elem, To]</code> каже: "Ось спосіб, маючи колекцію типу <code>From</code>, побудувати з елементів типу <code>Elem</code> колекцію типу <code>To</code>".</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">class</span> <span class="nc">RNA</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">with</span> <span class="nc">IndexedSeqLike</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA._</span>

<span class="c1">// Обов&#39;язкова реалізація `newBuilder` в `IndexedSeq`</span>
  <span class="k">override</span> <span class="k">protected</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">RNA</span><span class="o">.</span><span class="n">newBuilder</span>

<span class="c1">// Обов&#39;язкова реалізація `apply` в `IndexedSeq`</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>
    <span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">groups</span><span class="o">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">}</span>

<span class="c1">// Опціональна реалізація `foreach`, щоб зробити</span>
<span class="c1">// його більш ефективним.</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="n">b</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">b</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="k">else</span> <span class="n">b</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">S</span>
      <span class="n">f</span><span class="o">(</span><span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">))</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.8 - Клас ланцюжків РНК, фінальна версія.</p></div>
<div class="paragraph"><p>Тепер поведінка <code>map</code> та <code>++</code> на <code>RNA2</code> послідовностях стає яснішою. Немає <code>CanBuildFrominstance</code>, що створює <code>RNA2</code> послідовності, так що наступний найкращий доступний <code>CanBuildFrom</code> був знайдений в об'єкті компанйоні наслідуваного трейта <code>IndexedSeq</code>. Цей неявний примірник створює <code>IndexedSeqs</code>, і це те, що ви бачили, коли застосували <code>map</code> до <code>rna2</code>. Щоб виправити цей недолік, вам треба визначити неявний примірник <code>CanBuildFrom</code> в об'єкті компанйоні класу <code>RNA</code>. Цей примірник повинен мати тип <code>CanBuildFrom[RNA, Base, RNA]</code>. Таким чином, цей примірник стверджує, що маючи ланцюжок РНК і новий тип елементу <code>Base</code>, ви можете побудувати іншу колекцію, що знову буде ланцюжком. Лістинг 25.8 та Лістинг 25.9 показують деталі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">RNA</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">S</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// число біт в групі</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1">// бітова маска для ізоляції групи</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="mi">32</span> <span class="o">/</span> <span class="n">S</span> <span class="c1">// кількість груп в Int</span>

  <span class="k">def</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Base</span><span class="o">])</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">groups</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]((</span><span class="n">buf</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
      <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">|=</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span><span class="o">(</span><span class="n">buf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span>
    <span class="k">new</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">bases</span><span class="k">:</span> <span class="kt">Base*</span><span class="o">)</span> <span class="k">=</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">bases</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrayBuffer</span> <span class="n">mapResult</span> <span class="n">fromSeq</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">canBuildFrom</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">RNA</span>, <span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">RNA</span>, <span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="n">newBuilder</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">RNA</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="n">newBuilder</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.9 - Об'єкт компанйон <code>RNA</code>, фінальна версія.</p></div>
<div class="paragraph"><p>Порівняно з класом <code>RNA2</code> є дві важливі відмінності. Перше, реалізація <code>newBuilder</code> була переміщена з класу <code>RNA</code> до його об'єкта компанйона. Метод <code>newBuilder</code> в класі <code>RNA</code> просто пересилає до цього визначення. Друге, тепер в об'єкті <code>RNA</code> є неявне значення <code>CanBuildFrom</code>. Щоб створити такий об'єкт, вам треба визначити два методи <code>apply</code> в трейті <code>CanBuildFrom</code>. Обоє створять нового будівельника для колекції <code>RNA</code>, але в них різний список аргументів. Метод <code>apply()</code> просто створює нового будівельника правильного типу. Для контрасту метод <code>apply(from)</code> приймає оригінал колекції як аргумент. Це може бути корисним для адаптації динамічного типу повернення будівельника, щоб він був той самий, що і динамічний тип отримувача. В випадку з <code>RNA</code> це не має зіграти роль, оскільки  RNA є фінальним класом, так що кожний отримувач статичного типу <code>RNA</code> також матиме <code>RNA</code> в якості динамічного типу. Ось чому <code>apply(from)</code> також просто викликає <code>newBuilder</code>, ігноруючи аргумент.</p></div>
<div class="paragraph"><p>Ось так. Клас <code>RNA</code> в Лістингу 25.8 реалізує всі методи колекцій на їх природний типах. Його реалізація потребує малої частки протоколу. В основному ви маєте знати, де покласти фабрики <code>newBuilder</code> та неявні <code>canBuildFrom</code>. З іншого боку, з відносно невеликим кодом ви отримали велику кількість автоматично визначених методів. Також, якщо ви не маєте намірів робити для ваших колекцій масові операції, як <code>take</code>, <code>drop</code>, <code>map</code> або <code>++</code>, ви можете обрати не робити додаткову <code>length</code>, та зупинитись на реалізації, показаній в Лістингу 25.6.</p></div>
<div class="paragraph"><p>Дискусія досі оберталась коло найменьшої кількості визначень, потрібних для визначення нових послідовностей, з методами, що підкорюються певним типам. Але на практиці ви можете також захотіти додати нову функціональність до ваших послідовностей, або перекрити існуючі методи для кращої ефективності. Прикладом цього є перекритий метод <code>foreach</code> в класі <code>RNA</code>. <code>foreach</code> є важливим методом сам по собі, оскільки він реалізує цикли по колекціях. Більше того, багато інших методів колекцій реалізовані в термінах <code>foreach</code>. Так що має сенс інвестувати деякі зусилля в оптимізацію реалізації цього метода.</p></div>
<div class="paragraph"><p>Стандартна реалізація <code>foreach</code> в <code>IndexedSeq</code> буде просто обирати кожний <code>i</code>-тий елемент колекції, використовуючи <code>apply</code>, де <code>i</code> в диапазоні від 0 до довжини колекції мінус один. Так що стандартна реалізація вибирає елемент та розпаковує з нього основу кожного разу для кожного елемента в <code>RNA</code>. Перекриваюче <code>foreach</code> в класі RNA є розумнішим ніж це. Для кожного обраного елементу масива він безпосередньо застосовує надану функцію до всіх основ, що містяться в елементі. Так що зусилля для виборки з масива та розпаковки біт дуже зменшено.</p></div>
</div>
<div class="sect2">
<h3 id="_____">Інтегрування нових множин та мап</h3>
<div class="paragraph"><p>Другий приклад, який ви вивчете, це як інтегрувати в фреймворк колекцій новий різновид мапи. Ідея полягає в реалізації змінної мапи зі <code>String</code> як типом ключа, через "Patricia дерева".<span class="footnote"><br />[Morrison, "PATRICIA — Practical Algorithm To Retrieve Information Coded in Alphanumeric" [Mor68]]<br /></span> Термін Patricia є скороченням для "Practical Algorithm to Retrieve Information Coded in Alphanumeric". Ідея в зберіганні множини або мапи як дерева,де послідовні символи в ключі пошуку визначають унікальне наступне дерево.</p></div>
<div class="paragraph"><p>Наприклад, дерево Patricia зберігає п'ять рядків, <code>"abc"</code>, <code>"abd"</code>, <code>"al"</code>, <code>"all"</code>, <code>"xy"</code>, та може виглядати як дерево на Малюнку 25.1. Щоб знайти вузол, відповідний рядку <code>"abc"</code> в цьому дереві, просто слідуйте піддереву з міткою <code>"a"</code>, звідти ідіть до піддерева з міткою <code>"b"</code>, щоб нарешті досягти субдерева з міткою <code>"c"</code>. Якщо дерево Patricia використовується як мапа, значення, що асоційоване з ключем, зберігається в вузлах, що можуть бути досяжними по ключу. Якщо це множина, ви просто зберігаєте маркер, який каже що вузол присутній в множині.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">collection._</span>

<span class="k">class</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="nc">extends</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">]</span>
    <span class="k">with</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">MapLike</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">suffixes</span><span class="k">:</span> <span class="kt">immutable.Map</span><span class="o">[</span><span class="kt">Char</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>
    <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">value</span>
      <span class="k">else</span> <span class="n">suffixes</span> <span class="n">get</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">withPrefix</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
      <span class="k">else</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">leading</span> <span class="k">=</span> <span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
        <span class="n">suffixes</span> <span class="n">get</span> <span class="n">leading</span> <span class="k">match</span> <span class="o">{</span>
          <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
            <span class="n">suffixes</span> <span class="k">=</span> <span class="n">suffixes</span> <span class="o">+</span> <span class="o">(</span><span class="n">leading</span> <span class="o">-&gt;</span> <span class="n">empty</span><span class="o">)</span>
          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
        <span class="o">}</span>
        <span class="n">suffixes</span><span class="o">(</span><span class="n">leading</span><span class="o">)</span> <span class="n">withPrefix</span> <span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">)</span>
      <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">withPrefix</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">value</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="k">val</span> <span class="n">prev</span> <span class="k">=</span> <span class="n">value</span><span class="o">;</span> <span class="n">value</span> <span class="k">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">prev</span> <span class="o">}</span>
    <span class="k">else</span> <span class="n">suffixes</span> <span class="n">get</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)]</span> <span class="k">=</span>
    <span class="o">(</span><span class="k">for</span> <span class="o">(</span><span class="n">v</span> <span class="k">&lt;-</span> <span class="n">value</span><span class="o">.</span><span class="n">iterator</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">++</span>
    <span class="o">(</span><span class="k">for</span> <span class="o">((</span><span class="n">chr</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">suffixes</span><span class="o">.</span><span class="n">iterator</span><span class="o">;</span>
          <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">.</span><span class="n">iterator</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="n">chr</span> <span class="o">+:</span> <span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>

  <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">kv</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">T</span><span class="o">))</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span> <span class="n">update</span><span class="o">(</span><span class="n">kv</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">kv</span><span class="o">.</span><span class="n">_2</span><span class="o">);</span> <span class="k">this</span> <span class="o">}</span>

  <span class="k">def</span> <span class="o">-=</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span> <span class="n">remove</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="k">this</span> <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">empty</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.10 - Реалізація префіксної мапи за допомогою Patricia дерев.</p></div>
<div class="paragraph"><p>Малюнок 25.1 - Приклад дерева Patricia.</p></div>
<div class="paragraph"><p>Patricia дерева підтримують дуже ефективні пошуки та оновлення. Інша гарна можливість в тому, що вони підтримують виборку субколекцій по заданому префіксу. Наприклад, в дереві на Малюнку 25.1 ви можете отримати субколекцію по всім ключам, що починаються на <code>"a"</code>, просто слідуя посиланню <code>"a"</code> від кореня дерева.</p></div>
<div class="paragraph"><p>Базуючись на ціх ідеях ми тепер будемо проходити з вами по реалізації мапи, що реалізована як дерево Patricia. Ми назвали мапу <code>PrefixMap</code>, що означає, що вона підтримує метод <code>withPrefix</code>, що обирає субмапу з усіх ключів, що мають наданий префікс.</p></div>
<div class="paragraph"><p>Спочатку ми визначимо префіксну мапу з ключами, показану на Малюнку 25.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">PrefixMap</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;abd&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;al&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span>
<span class="s">&quot;all&quot;</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">,</span> <span class="s">&quot;xy&quot;</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">m</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">abc</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">abd</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">al</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">all</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span>
<span class="o">(</span><span class="n">xy</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли викликається <code>withPrefix</code> на <code>m</code>, це даватиме іншу префіксну мапу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span> <span class="n">withPrefix</span> <span class="s">&quot;a&quot;</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">bc</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">bd</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">ll</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.10 показує визначення <code>PrefixMap</code>. Цей клас параметризований типом асоційованого значення <code>T</code>, та розширює <code>mutable.Map[String, T]</code> та <code>mutable.MapLike[String, T, PrefixMap[T]]</code>. Ви вже бачили цей шаблон для послідовностей в прикладі з РНК ланцюжками. Тепер, коли є наслідування класу реалізації, такого як <code>MapLike</code>, це служить для отримання правильного класу результату для таких трансформацій, як <code>filter</code>.</p></div>
<div class="paragraph"><p>Вузол префіксної мапи має два змінних поля: <code>suffixes</code> та <code>value</code>. Поле <code>value</code> містить додаткове значення, що асоційоване з вузлом. Воно ініціалізоване як <code>None</code>. Поле <code>suffixes</code> містить тмапу від префіксів до значень <code>PrefixMap</code>. Воно ініціалізоване як порожня мапа. Ви можете запитати, чому ми обрали незмінну мапу як тип реалізації для <code>suffixes</code>? Чи не була б змінна мапа більш стандартною, оскільки <code>PrefixMap</code> вцілому також змінна? Відповідь в тому, що незмінні мапи, що містять тільки декілька елементів, є дуже ефективними одночасно, по простору і часу виконання.</p></div>
<div class="paragraph"><p>Наприклад, мапи, що містять меньше ніж 5 елементів, представлені як один об'єкт. Для контрасту, як описано в Розділі 17.2, стандартна змінна мапа є <code>HashMap</code>, що типово займає близько 80 байт, навіть якщо вона порожня. Так що якщо мали колекції є типовими, краще обирати незмінні замість змінних. В випадку дерев Patricia ми очікуємо, що більшість вузлів, за винятком тих, що будуть з самого верху дерева, будуть містити лише декільки наступних. Так що зберігання ціх наступних в незмінній мапі, вірогідно, буде більш ефективним.</p></div>
<div class="paragraph"><p>Тепер подивимось на перший метод, що має бути реалізований для мапи: <code>get</code>. Алгоритм наступний: щоб отримати значення, асоційоване з порожнім рядком в префіксній мапі, просто оберіть опціональне значення, що зберігається в корені дерева. Інакше, якщо рядок не порожній, спробуйте вибрати субмапу, що відповідає першому символу в рядку. Якщо це дає мапу, продовжуйте через пошук залишку ключового рядка після його першого символа в цій мапі. Якщо вибірка схибить, ключ не зберігається в мапі, так що повертаємо <code>None</code>. Комбінована вибірка через опціональне значення елегантно виражене через <code>flatMap</code>. Коли застосовується до опціонального значення <code>ov</code> та замикання <code>f</code>, що в свою чергу повертає опціональне значення, <code>ov flatMap f</code> буде успішним, якщо обоє, <code>ov</code> та <code>f</code> повертає визначене значення. Інакше <code>ov flatMap f</code> буде повертати <code>None</code>.</p></div>
<div class="paragraph"><p>Наступні два методи, що треба реалізувати для змінної мапи, є <code>+=</code> та <code>-=</code>. В реалізації на Лістингу 25.10 вони визначені в термінах двох інших методів: <code>update</code> та <code>remove</code>. Метод <code>remove</code> дуже подібний до метода <code>get</code>, за тим винятком, що перед поверненням асоційованого значення, поле, що містить це значення, встановлюється в <code>None</code>. Метод <code>update</code> спочатку викликає <code>withPrefix</code> для навігації до вузла дерева, що потребує оновлення, та потім встановлює поле цього вузла в надане значення. Метод <code>withPrefix</code> навігує по дереву, створюючи субмапи за необхідності, якщо деякий префікс з символів ще не міститься як шлях в дереві.</p></div>
<div class="paragraph"><p>Останній абстрактний метод, що треба реалізувати для змінної мапи є <code>iterator</code>. Цей метод має продукувати ітератор, що отримує всі пари ключ/значення, що зберігаються в мапі. Для кожної префіксної мапи цей ітератор складається з наступних частин: перше, якщо мапа містить визначене значення, <code>Some(x)</code>, в полі <code>value</code> в своєму корені, потім <code>("", x)</code> є першим елементом, що повертається від ітератора. Більше того, ітератор має пройти по всіх ітераторах всіх субмап, що містяться в полі <code>suffixes</code>, але він має додавати символ перед кожним рядком, що повертається ціма ітераторами. Більш точно, якщо <code>m</code> є субмапою, що досяжна з кореня через символ <code>chr</code>, та <code>(s, v)</code> є елементом, що повертає <code>m.iterator</code>, тоді кореневий ітератор буде повертати <code>(chr +: s, v)</code>.</p></div>
<div class="paragraph"><p>Ця логіка реалізована досить стисло, як конкатенація двох виразів в реалізації метода  <code>iterator</code> з Лістингу 25.10. Перший <code>for</code> вираз ітерує по <code>value.iterator</code>. Це використовує факт, що значення <code>Option</code> визначають метод <code>iterator</code>, що або не повертає елементів, якщо опціональне значення <code>None</code>, або рівно один елемент <code>x</code>, якщо значення опціїif є <code>Some(x)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.</span><span class="o">{</span><span class="nc">Builder</span><span class="o">,</span> <span class="nc">MapBuilder</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.collection.generic.CanBuildFrom</span>

<span class="k">object</span> <span class="nc">PrefixMap</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">kvs</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">T</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">empty</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">kv</span> <span class="k">&lt;-</span> <span class="n">kvs</span><span class="o">)</span> <span class="n">m</span> <span class="o">+=</span> <span class="n">kv</span>
    <span class="n">m</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">MapBuilder</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">empty</span><span class="o">)</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">canBuildFrom</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
        <span class="k">def</span> <span class="n">apply</span><span class="o">()</span> <span class="k">=</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
      <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 25.11 - Об'єкт компанйон для префіксної мапи.</p></div>
<div class="paragraph"><p>Зауважте, що немає метода <code>newBuilder</code>, визначеного в <code>PrefixMap</code>. В ньому немає потреби, оскільки мапи та множини ідуть з будівельниками по замовчанню, що є примірниками класу  <code>MapBuilder</code>. Для змінної мапи будівельник по замовчанню починає з порожньої мапи, та потім додає послідовні елементи, використовуючи метод мапи <code>+=</code>.</p></div>
<div class="paragraph"><p>Змінні множини поводяться таким же чином. Будівельники по замовчанню для незмінних мап та множин використовують неруйнівний метод додавання елементу <code>+</code>, замість метода <code>+=</code>. Однак у всіх ціх випадках, щоб побудувати правильний різновид множини або мапи вам треба почати з порожньої множини або мапи цього виду. Це провадиться методом <code>empty</code>, що є останнім метедом, визначеним в <code>PrefixMap</code>. В Лістингу 25.10 цей метод просто повертає свіжу <code>PrefixMap</code>.</p></div>
<div class="paragraph"><p>Тепер ми перейдемо до об'єкта компанйона <code>PrefixMap</code>, що показаний на Лістингу 25.11. Фактично, не є винятково необхідним визначати цей об'єкт, бо клас <code>PrefixMap</code> може гарно встояти як він є. Головне призначення об'єкта <code>PrefixMap</code> є визначити деякі зручні методи фабрик. Він також визначає неявне значення <code>CanBuildFrom</code>, щоб покращити роботу типізації.</p></div>
<div class="paragraph"><p>Два зручні методи - це <code>empty</code> та <code>apply</code>. Ті самі методи присутні для всіх інших колекцій в фреймворці колекцій Scala, так що має сенс визначити тут їх, також. З ціма двома методами ви можете записати літерали <code>PrefixMap</code>, як ви робите це для всіх інших колекцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">PrefixMap</span><span class="o">(</span><span class="s">&quot;hello&quot;</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">&quot;hi&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">hello</span><span class="o">,</span><span class="mi">5</span><span class="o">),</span> <span class="o">(</span><span class="n">hi</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">PrefixMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший член в об'єкті <code>PrefixMap</code> є неявний примірник <code>CanBuildFrom</code>. Він має те саме призначення, що і визначення <code>CanBuildFrom</code> в останньому розділі: щоб дозволити таким методам, як <code>map</code>, повертати найкращий можливий тип. Наприклад, розглянемо функцію одображення для пар ключ/значення <code>PrefixMap</code>. Доки ця функція продукує пари з рядків та якогось іншого типу, результуюча колекція знову буде <code>PrefixMap</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res0</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">,</span> <span class="s">&quot;x&quot;</span> <span class="o">*</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">((</span><span class="n">hello</span><span class="o">!,</span><span class="n">xxxxx</span><span class="o">),</span> <span class="o">(</span><span class="n">hi</span><span class="o">!,</span><span class="n">xx</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Аргумент наданої функції приймає пари ключ/значення префіксної мапи <code>res0</code>, та продукує пари рядків. Результатом <code>map</code> буде <code>PrefixMap</code>, на цей раз з типом значень <code>String</code> замість <code>Int</code>. Без неявного <code>canBuildFrom</code> в <code>PrefixMap</code>, результат буде загальна змінна мапа, не префіксна мапа.</p></div>
</div>
<div class="sect2">
<h3 id="_">Підсумок</h3>
<div class="paragraph"><p>Якщо ви бажаєте повністю інтегрувати новий клас колекції в фреймворк, вам треба звернути увагу на такі питання:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Вирішити, чи колекція повиння бути змінною чи незмінною.
</p>
</li>
<li>
<p>
Обрати вірний базовий трейт для колекції.
</p>
</li>
<li>
<p>
Наслідувати від правильного трейта реалізації, щоб реалізовати більшість операцій колекцій.
</p>
</li>
<li>
<p>
Якщо ви бажаєте, щоб <code>map</code> та подібні операції повертали примірники вашого класа колекції, запровадьте неявний <code>CanBuildFrom</code> в об'єкті компанйоні вашого класу.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__2">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили, як побудовані колекції Scala, та як ви можете будувати нові різновиди колекцій. Завдяки багатій підтримці абстракцій в Scala, кожний новий тип колекцій може мати велику кількість методів, без потреби кожного разу знову реалізувати їх.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-10 01:11:40 EEST
</div>
</div>
</body>
</html>
