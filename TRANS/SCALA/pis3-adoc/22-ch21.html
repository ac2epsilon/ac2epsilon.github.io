<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__21">Глава 21</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="____">Неявні перетворення та параметри</h1>
<div class="paragraph"><p>Існує фундаментальна відмінність між вашим кодом, та бібліотеками інших людей: ви можете змінити або розширити ваш власний код, як побажаєте, але якщо ви бажаєте використати чиюсь іншу бібліотеку, ви звичайно маєте сприймати її як є. В мовах з'явилось декілька конструкцій для полегчення цієї проблеми. Ruby має модулі, та Smalltalk дозволяє пакункам додавати до класів один одного. Вони дуже потужні, але також небезпечні, тому що ви можете модифікувати поведінку класу для всього застосування, деяки частини якого ви можете не знати. C# 3.0 має статичні методи розширення, які є більш локальними, але також більш обмежуючі, в тому, що ви можете лише добавляти до класа методи, не поля, та ви не можете змусити клас реалізувати нові інтерфейси.</p></div>
<div class="paragraph"><p>Відповіддю Scala є неявні перетворення та параметри. Вони можуть зробити існуючі бібліотеки значно більше приємними у взаємодії, дозволяючі вам облишити за бортом нудні, очевидні деталі, що приховують цікаві частини вашого коду. Коли використовується зі смаком, це призводить до коду, що сфокусований на цікавих, нетривіальних частинах вашої програми. Ця глава показує вам, як неявні роблять, та вона презентує деякі з найбільш загальних шляхів їх використання.</p></div>
<div class="sect1">
<h2 id="_21_1__">21.1 Неявні перетворення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Перед зануренням в деталі неявних перетворень, поглянемо на типовий приклад їх використання. Неявні перетворення часто корисні для роботи з двома тілами програмного забезпечення, що розроблялись без думки один про одне. Кожна бібліотека має свій власний шлях для кодування концепції, що насправді є однією річчю. Неявні перетворення допомагають через зменьшення числа явних перетворень, що потрібні від одного типу до іншого.</p></div>
<div class="paragraph"><p>Java включає бібліотеку на ім'я Swing для реалізації крос-платформених користувацьких інтерфейсів. Одна з речей, що робить Swing, це обробка подій від операційної системи, конвертація їх до платформ-незалежних об'єктів подій, та передача ціх подій до частин застосування, що називаються слухачами подій.</p></div>
<div class="paragraph"><p>Якщо б Swing був написаний зі Scala на думці, слухачі подій мали б, можливо, бути представлені як функціональний тип. Викликачі можуть потім використовувати синтаксис фінкціональних літералів, як легковажний шлях вказати, що має відбуватись для певного класу подій. Оскільки Java не має функціональних літералів, Swing використовує наступну кращу річ, внутрішній клас, що реалізує одно-методний інтерфейс. В випадку слухачів подій, інтерфейсом є <code>ActionListener</code>.</p></div>
<div class="paragraph"><p>Без використання неявних перетворень, програма Scala, що використовує Swing, має використовувати внутрішній клас, так само як в Java. Ось приклад що створює кнопку, та підвішує на неї слухача подій. Слухач подій викликається кожного разу, коли кнопка натискається, і в цій точці він друкує рядок <code>"pressed!"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
     <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код має багато неінформативного шаблону. Факт, що цей слухач є <code>ActionListener</code>, факт, що це метод зворотнього виклику на ім'я <code>actionPerformed</code>, та факт, що аргументом є <code>ActionEvent</code> - все це мається на увазі для кожного аргументу <code>addActionListener</code>. Єдина нова інформація тут є код, що буде виконаний, а саме виклик <code>println</code>. Ця нова інформація тоне в шаблонному коді. Той, хто читає цей код, повинен мати гострий зір, щоб пробитись крізь шум та знайти інформативну частину.</p></div>
<div class="paragraph"><p>Більш Scala-дружня версія приймає функцію як аргумент, значно зменьшуючи кількість шаблоного коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span> <span class="c1">// Неспівпадіння типів!</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але так, як він написаний, цей код не робить.<span class="footnote"><br />[Як буде пояснено в Розділі 31.5, це робить в Scala 2.12.]<br /></span> Метод <code>addActionListener</code> бажає слухача подій, але отримує функцію. З неявними перетвореннями цей код, однак, може бути зроблений робочим.</p></div>
<div class="paragraph"><p>Перший крок є написання неявного перетворення між двома типами. Ось неявне перетворення від функцій до слухачів подій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">function2ActionListener</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">ActionEvent</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це одно-аргументний метод, що приймає функцію, та повертає слухача подій. Як любий інший одно-аргументний метод, він може бути викликаний напряму, та має свій результат переданий далі в інший вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="n">function2ActionListener</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це вже покращення, в порівняні з версією з внутрішнім класом. Зауважте, як довільні маси шаблонного коду були замінені функціональним літералом та викликом метода. Однак з неявними перетвореннями це стає ще краще. Оскільки <code>function2ActionListener</code> помічена як <code>implicit</code>, вона може бути прибрана, і компілятор буде вставляти її автоматично. Ось результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Тепер це робить</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Шлях, яким цей код робить, полягає в тому, що компілятор спочатку компілює його як є, але він бачить помилку типу. Перед тим як здатись, він шукає неявне перетворення, що може владнати проблему. В цьому випадку він знаходить <code>function2ActionListener</code>. Він випробовує метод перетворення, бачить що він робить, та рухається далі. Компілятор виконує тяжку роботу, так що розробник може ігнорувати ще одну дрібну деталь. Слухач подій? Функція обробки подій? Обоє будуть робити — використовуйте те, що більш зручно.</p></div>
<div class="paragraph"><p>В цьому розділі ми ілюструємо деякі з потужностей неявних перетворень, та як вони дозволяють вам причипурити існуючі бібліотеки. В наступних розділах ви вивчите правила, що визначають, коли неявні перетворення будуть спробувані, та як вони будуть шукатись.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_2____">21.2 Правила для неявних визначень</h2>
<div class="sectionbody">
<div class="paragraph"><p>Визначення <code>implicit</code> є такими, що дозволяються компілятору для вставки в програму, щоб поладнати любі з його помилок типів. Наприклад, якщо <code>x + y</code> не проходить перевірку типів,компілятор може змінити його на <code>convert(x) + y</code>, де <code>convert</code> є деяке доступне <code>implicit</code> перетворення. Якщо <code>convert</code> змінює <code>x</code> на дещо, що має метод <code>+</code>, тоді ця зміна може поладнати програму, так що вона пройде перевірку типів та виконається коректно. Якщо <code>convert</code> насправді тільки проста функція перетворення, тоді прибирання її з джерельного коду може бути очищенням.</p></div>
<div class="paragraph"><p>Неявні перетворення регулюються наступними загальними правилами:</p></div>
<div class="paragraph"><p><strong>Правило маркування: доступні тільки визначення, відмічені як <code>implicit</code>.</strong> Ключове слово <code>implicit</code> використовується як маркер, які декларації може використовувати компілятор для неявних перетворень. Ви можете використовувати його для маркування визначення змінної, функції або об'єкта. Ось приклад визначення неявної функції:<span class="footnote"><br />[Змінні та об'єкти синглтони, відмічені як <code>implicit</code>, можуть бути використані як неявні параметри. Цей спосіб використання буде описаний пізніше в цій главі.]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">intToString</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toString</span>
</pre></div></div></div>
<div class="paragraph"><p>Компілятор буде змінювати <code>x + y</code> до <code>convert(x) + y</code>, тільки якщо <code>convert</code> відмічений як <code>implicit</code>. Таким чином, ви уникаєте плутанини, коли компілятор обиратиме випадкові функції, що трапляються в полі зору, та вставляє їх як "перетворення". Компілятор буде обирати тільки між визначеннями, що ви явно відмітили як <code>implicit</code>.</p></div>
<div class="paragraph"><p><strong>Правило поля зору: вставлене неявне перетворення має бути в полі зору як єдиний ідентифікатор, або бути асоційоване з типом джерела або цілі перетворення.</strong> Компілятор Scala буде розглядати тільки неявні перетворення, що знаходяться в полі зору. Таким чином, щоб зробити неявне перетворення доступним, ви повинні деяким чином занести його в поле зору. Більше того, з один виключенням, неявне перетворення має бути в полі зору як <em>єдиний ідентифікатор</em>. Компілятор не буде вставляти перетворення в формі <code>someVariable.convert</code>. Наприклад, він не буде розширювати <code>x + y</code> до <code>someVariable.convert(x) + y</code>. Якщо ви бажаєте зробити <code>someVariable.convert</code> доступним як <code>implicit</code>, вам треба імпортувати його, що робитиме його доступним як єдиний ідентифікатор. Як тільки той імпортований, компілятор буде вільний застосувати його як <code>convert(x) + y</code>. Фактично, є загальним для бібліотек включати об'єкт <code>Preamble</code>, що включає декілька корисних неявних перетворень. Код, що використовує бібліотеку, потім може зробити один <code>import Preamble._</code> для доступу до неявних перетворень бібліотеки.</p></div>
<div class="paragraph"><p>Існує одне виключення до правила "єдиного ідентифікатора". Компілятор також буде дивитись неявні перетворення в об'єкті компанйоні джерела або очікуваного типів перетворення. Наприклад, якщо ви намагаєтесь передати об'єкт <code>Dollar</code> до метода, що приймає <code>Euro</code>, типом джерела є <code>Dollar</code>, та тип цілі є <code>Euro</code>. Таким чином, ви можете запакувати неявне перетворення від <code>Dollar</code> до <code>Euro</code> в об'єкт компанйон любого класу, <code>Dollar</code> або <code>Euro</code>.</p></div>
<div class="paragraph"><p>Ось приклад, в якому визначення <code>implicit</code> покладене в об'єкт компанйон <code>Dollar</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Dollar</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">dollarToEuro</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Dollar</span><span class="o">)</span><span class="k">:</span> <span class="kt">Euro</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
<span class="k">class</span> <span class="nc">Dollar</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку кажуть, що перетворення <code>dollarToEuro</code> <em>асоційоване</em> з типом <code>Dollar</code>. Компілятор буде шукати такі асоційовані перетворення кожний раз, коли йому треба перетворити з примірника типу <code>Dollar</code>. Немає потреби окремо імпортувати перетворення в вашу програму.</p></div>
<div class="paragraph"><p>Правило поля зору допомогає з модульним сприяттям. Коли ви читаєте код в файлі, єдині речі, що вам треба брати до уваги з інших файлів, це тільки те, що або імпортоване, або явно посилається через повністю кваліфіковане ім'я. Ця перевага щонайменьше така ж важлива для неявних, як і для явно написаного коду. Якщо неявні визначення отримали б ефект в маштабах системи, тоді для розуміння файла вам би знадобилось знати щодо кожного неявного перетворення, визначеного будь-де в програмі!</p></div>
<div class="paragraph"><p><strong>Правило один-за-раз: буде вставлене тільки одне неявне перетворення.</strong> Компілятор ніколи не буде переписувати <code>x + y</code> до <code>convert1(convert2(x)) + y</code>. Якщо робити це, час компіляції драматично збільшиться для помилкового коду, та це збільшить різницю між тим, що пише програміст, та що програма насправді робить. Заради збереження здорового глузду, компілятор не вставляє подальші неявні перетворення, коли він вже на середині спроби іншого неявного перетворення. Однак можливо обійти це обмеження, маючи неявні перетворювачі, що приймають неявні параметри, які будуть описані пізніше в цій главі.</p></div>
<div class="paragraph"><p><strong>Правило явні-перші: якщо код проходить перевірку типів як він є, жодні неявні не будуть спробувані.</strong> Компілятор не буде змінювати код, що вже робить. Наслідок з цього правила є такий, що ви завжди можете замінити неявні ідентифікатори на явні, таким чином роблячи код довшим, але з менш вірогідною двозначністю. Ви можете балансувати між ціма виборами на основі випадку-до-випадка. Кожного разу, коли ви бачите код, що виглядає повторюваним та балакучим, неявні перетворення можуть допомогти зменшити нудьгу. Кожного разу, коли ви бачите, що код виглядає скороченим до точки незрозумілості, ви можете вставити явні перетворення. Кількість неявних перетворень, що ви залишите для вставки компілятором, кінець кінцем є предметом стилю.</p></div>
<div class="sect2">
<h3 id="___">Іменування неявного перетворення</h3>
<div class="paragraph"><p>Неявні перетворення можуть мати довільні імена. Ім'я неявного перетворення має значення тільки в двох ситуаціях: якщо ви бажаєте написати його явно в застосуванні метода, та для визначення, які перетворення доступні в любій точці програми. Щоб проілюструвати другу точку, скажімо, ви маєте об'єкт з двома неявними перетвореннями:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">MyConversions</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">stringWrapper</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span>
    <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToString</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В вашому застосуванні ви бажаєте використати перетворення <code>stringWrapper</code>, але ви не бажаєте, щоб цілі автоматично перетворювались на рядки за допомогою <code>intToString</code>. Ви можете досягти цього через імпорт тільки одного перетворення, але не іншого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">MyConversions.stringWrapper</span>
<span class="o">...</span> <span class="c1">// код, що використовує stringWrapper</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі було важливо, щоб неявні перетворення мали імена, оскільки тільки таким чином ви вибірково імпортуєте одні, та не імпортуєте інші.</p></div>
</div>
<div class="sect2">
<h3 id="_____">Де будуть спробувані неявні декларації</h3>
<div class="paragraph"><p>Існує три місця, де в мові використовуються неявні декларації: перетворення до очікуваного типу, перетворення отримувача вибору, та неявні параметри. Неявні перетворення до очікуваного типу дозволяють вам використовувати один тип в контексті, де очікуєтья інший тип. Наприклад, ви можете мати <code>String</code>, та бажати передати його в метод, що потребує <code>IndexedSeq[Char]</code>. Перетворення отримувача дозволяє вам адаптувати отримувач виклику метода (тобто об'єкт, на якому викликається метод), якщо метод не застосований на оригінальному типі. Прикладом є <code>"abc".exists</code>, що конвертований до <code>stringWrapper("abc").exists</code>, оскільки метод <code>exists</code> не доступний на <code>String</code>, але доступний на <code>IndexedSeq</code>. Неявні параметри, з іншого боку, звичайно використовуються для провадження додаткової інформації до викликаної функції, щодо того, що хоче викликач. Неявні параметри особливо корисні з дженерік функціями, коли визивана функція може інакше взагалі нічого не знати щодо типів одного або більше аргументів. Ми будемо досліджувати кожний з ціх трьох різновидів неявних в наступніх розділах.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_21_3_____">21.3 Неявні перетворення до очікуваного типу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявне перетворення до очікуваного типу є перше місце, де компілятор буде використовувати неявні. Це правило просте. Кожного разу, коли компілятор бачить <code>X</code>, але потребує <code>Y</code>, він буде шукати <code>implicit</code> функцію, що конвертує <code>X</code> до <code>Y</code>. Наприклад, звичайно число подвійної точності не може бути використане як ціле, бо воно втратить точність:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
  <span class="n">found</span>   <span class="k">:</span> <span class="kt">Double</span><span class="o">(</span><span class="err">3</span><span class="kt">.</span><span class="err">5</span><span class="o">)</span>
  <span class="kt">required:</span> <span class="kt">Int</span>
        <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>
                     <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак ви можете визначити неявне перетворення, щоб згладити це питання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">doubleToInt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toInt</span>
<span class="n">doubleToInt</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Double</span><span class="o">)</span><span class="kt">Int</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>
<span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається, це коли компілятор бачить <code>Double</code>, зокрема <code>3.5</code>, в контексті де має бути <code>Int</code>. Доки компілятор бачить тільки звичайну помилку типу. Однак перед тим як здатись, він шукає неявне перетворення від <code>Double</code> до <code>Int</code>. В цьому випадку він знаходить таке: <code>doubleToInt</code>, оскільки <code>doubleToInt</code> є в полі зору як єдиний ідентифікатор. (За межами інтерпретатора ви можете занести <code>doubleToInt</code> в поле зору через імпорт, або, можливо, через наслідування). Потім компілятор автоматично вставляє виклик до <code>doubleToInt</code>. За лаштунками код стає такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">doubleToInt</span><span class="o">(</span><span class="mf">3.5</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буквально <em>неявне</em> перетворення. Ви явно не просили про перетворення. Замість цього ви відмітили <code>doubleToInt</code> як доступне неявне перетворення, через занесення його в поле зору як єдиний ідентифікатор, та потім компілятор автоматично використовує його коли треба для конвертації від <code>Double</code> до <code>Int</code>.</p></div>
<div class="paragraph"><p>Конвертація <code>Double</code> до <code>Int</code> може декого здивувати, оскільки є сумнівною ідеєю мати дещо, що спричиняє втрату точності, що відбувається невидимо. Так що це насправді не те перетворення, яке ми рекомендуємо. Це має значно більше сенсу, якщо пійти в зворотньому напрямку, від якогось більш обмеженого типу до більш загального. Наприклад, <code>Int</code> може бути конвертований без страти точності на <code>Double</code>, так що неявне перетворення від <code>Int</code> до <code>Double</code> має сенс. Фактично, це саме те, що відбувається. Об'єкт <code>scala.Predef</code>, що неявно імпортований в кожну Scala програму, визначає неявне перетворення, що конвертує "меньші" числові типи на "більші". Наприклад, ви знайдете в <code>Predef</code> наступне перетворення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">def</span> <span class="n">int2double</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toDouble</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось чому в Scala значення <code>Int</code> може бути збережене в змінних типу <code>Double</code>. Для цього немає особливого правила в системі типів; це просто неявне перетворення, що застосовується при нагоді.<span class="footnote"><br />[Однак бекенд Scala компілятора буде трактувати перетворення особливим чином, транслюючи його в особливий байткод <code>i2d</code>. Так що скомпільований образ буде такий самий, як в Java.]<br /></span></p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_4__">21.4 Перетворення отримувача</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні перетворення також застосовуються до отримувача виклику метода, об'єкт, на якому викликається метод. Цей різновид неявного перетворення має два головні застосування. Перше, перетворення отримувача дозволяє гладшу інтеграцію нових класів в існуючу ієрархію класів. Та друге, вони підтримують написання домен-специфічних мов (DSL) всередині мови.</p></div>
<div class="paragraph"><p>Щоб побачити, як це робить, уявімо, що ви пишете <code>obj.doIt</code>, та <code>obj</code> не має члена на ім'я <code>doIt</code>. Компілятор буде намагатись вставити перетворення, перед тим як здатись. В цьому випадку перетворення треба застосувати до отримувача <code>obj</code>. Компілятор буде діяти так, якби очікуваний "тип" <code>obj</code> мав член на ім'я <code>doIt</code>. Цей "має <code>doIt</code>" тип не є звичайним типом Scala, але концептуально він тут, і ось чому компілятор буде вставляти неявне перетворення в цьому випадку.</p></div>
<div class="sect2">
<h3 id="_____2">Взаємодія з новими типами</h3>
<div class="paragraph"><p>Як вже зазначалось перед цім, одне головне застосування конвертації отримувача є дозволити гладшу інтеграцію нових типів з існуючими типами. Зокрема, вони дозволяють вам дозволити програмістам клієнтів використовувати примірники існуючих типів, так, якби вони були би примірниками нових типів. Візьмемо, наприклад, клас <code>Rational</code>, показаний в Лістингу 6.5. Ось фрагмент цього класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
<span class="o">...</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Клас <code>Rational</code> має два перевантажені варіанта метода <code>+</code>, що приймає <code>Rational</code> та <code>Int</code>,відповідно, в якості аргументів. Так що ви можете або додавати раціональні числа, або раціональне та ціле:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">oneHalf</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="o">+</span> <span class="n">oneHalf</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">oneHalf</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо виразів, як <code>1 + oneHalf</code>? Цей вираз хитрий, оскільки отримувач, <code>1</code>, не має підходящого метода <code>+</code>. Так що наступне дасть помилку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">6</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">overloaded</span> <span class="kt">method</span> <span class="kt">value</span> <span class="kt">+</span> <span class="kt">with</span>
<span class="n">alternatives</span> <span class="o">(</span><span class="nc">Double</span><span class="o">)</span><span class="nc">Double</span> <span class="o">&lt;</span><span class="n">and</span><span class="o">&gt;</span> <span class="o">...</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">applied</span>
<span class="n">to</span> <span class="o">(</span><span class="nc">Rational</span><span class="o">)</span>
      <span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб дозволити цей різновид змішаної арифметики, вам треба визначити неявне перетворення від <code>Int</code> до <code>Rational</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
<span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">intToRational</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">Rational</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли це перетворення на місці, конвертація отримувача робить цей трюк:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут відбувається за лаштунками сцени, це те, що компілятор Scala спочатку намагається перевірити тип варазу  <code>1 + oneHalf</code> як він є. Це схибить, оскільки <code>Int</code> має декілька методів <code>+</code>, але жодного, що приймає аргумент <code>Rational</code>. Далі, компілятор шукає неявне перетворення від <code>Int</code> до іншого типу, що має метод <code>+</code>, який може бути застосований до <code>Rational</code>. Він находить ваше перетворення, та застосовує його, що дає таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">intToRational</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">oneHalf</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому випадку компілятор знайшов функцію неявного перетворення, оскільки ви ввели його визначення в інтерпретатор, що занесло його поле зору до кінця сессії інтерпретатора.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Симуляція нового синтаксису</h3>
<div class="paragraph"><p>Інше головне застосування неявних перетворень це симуляція додавання нового синтаксису. Згадайте, що ви можете створити <code>Map</code>, використовуючи такий синтаксис:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">&quot;two&quot;</span><span class="o">,</span> <span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">&quot;three&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Чи ви не здивувались, як підтримується <code>-&gt;</code>? Це не синтаксис! Замість цього <code>-&gt;</code> є методом класу <code>ArrowAssoc</code>, класу, визначеного в стандартній преамбулі Scala (<code>scala.Predef</code>). Преамбула також визначає неявне перетворення з <code>Any</code> до <code>ArrowAssoc</code>. Коли ви пишете <code>1 -&gt; "one"</code>, компілятор вставляє перетворення від <code>1</code> до <code>ArrowAssoc</code> так що метод <code>-&gt;</code> може бути знайдений. Ось відповідні визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala</span>

<span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tuple2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">any2ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrowAssoc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей шаблон "багатих огорток" загальний в бібліотеках, що провадять до мови синтаксо-подібні розширення, так що ви повинні бути готові розпізнати шаблон, коли ви бачите його. Кожного разу, коли ви бачите ,як дехто викликає методи, що не існують в класі отримувачі, вони вірогідно використовують неявні перетворення. Подібно до цього, якщо ви бачите клас, названий <code>RichSomething</code> (тобто, <code>RichInt</code> або <code>RichBoolean</code>), виглядає що цей клас додає синтакс-подібні методи до типу <code>Something</code>.</p></div>
<div class="paragraph"><p>Ви вже бачили цей шаблон багатих огорток для базових типів, описаних в Главі 5. Як ви можете бачити, ці багаті огортки застосовуються більш широко, часто дозволяючи вам отримати внутрішінй DSL, визначений як бібліотека, коли програмісти на інших мовах відчувають потребу в зовнішньому DSL.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__">Неявні класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні класи були додані в Scala 2.10, щоб спростити написання багатих класів огорток. Неявний клас є клас, перед яким стоїть ключове слово <code>implicit</code>. Для любого такого класу компілятор генерує неявне перетворення від параметру конструктора класу до самого класу. Таке перетворення є саме тим, що вам треба, якщо ви плануєте використовувати клас для шаблону багатих огорток.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що ви маєте клас на ім'я <code>Rectangle</code> для представлення ширини та висоти прямокутника на екрані:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">class</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви використовуєте цей клас дуже часто, ви можете побажати використати шаблон багатої огортки, так щоб ви могли конструювати його більш просто. Ось один спосіб зробити це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">implicit</span> <span class="k">class</span> <span class="nc">RectangleMaker</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">x</span><span class="o">(</span><span class="n">height</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Визначення вище визначає клас <code>RectangleMaker</code> в звичайній манері. На додаток, він спричиняє автоматичну генерацію наступного перетворення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Автоматично згенеровано</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="nc">RectangleMaker</span><span class="o">(</span><span class="n">width</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=new</span> <span class="nc">RectangleMaker</span><span class="o">(</span><span class="n">width</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як результат, ви можете створити точки через покладання <code>x</code> між двома цілими:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">myRectangle</span> <span class="k">=</span> <span class="mi">3</span> <span class="n">x</span> <span class="mi">4</span>
<span class="n">myRectangle</span><span class="k">:</span> <span class="kt">Rectangle</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як це робить: оскільки тип <code>Int</code> не має метода на ім'я <code>x</code>, компілятор буде шукати неявне перетворення від <code>Int</code> до чогось, що має. Він знайде згенероване перетворення <code>RectangleMaker</code>, та <code>RectangleMaker</code> має метод на ім'я <code>x</code>. Компілятор вставляє виклик для цього перетворення, після чого виклик <code>x</code> проходить перевірку типів, і робить те, що задумане.</p></div>
<div class="paragraph"><p>Як засторога для відчайдушних, може бути спокусливо думати, що кожний клас може мати поставлений перед собою <code>implicit</code>. Це не так. Неявний клас не може бути кейс класом, та його конструктор повинен мати рівно один параметр. Також неявний клас мусить розміщуватись в деякому іншому об'єкті, класі або трейті. На практиці, доки ви використовуєте неявні класи як багаті огортки для додавання нових методів в існуючі класи, ці обмеження не повинні мати значення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_5__">21.5 Неявні параметри</h2>
<div class="sectionbody">
<div class="paragraph"><p>Останнє місце, де компілятор вставляє неявні, є спискі аргументів. Компілятор буде іноді замінювати <code>someCall(a)</code> на <code>someCall(a)(b)</code>, або <code>new SomeClass(a)</code> на <code>new SomeClass(a)(b)</code>, таким чином додаючи відсутній список параметрів для завершення виклику функції. Те, що додається є цілим останнім карованим списком параметрів, не просто останній параметр. Наприклад, якщо <code>someCall</code> не вистачає останнього списку параметрів, що приймає три параметра, компілятор може замінити <code>someCall(a)</code> на <code>someCall(a)(b, c, d)</code>. Для цього використання не просто вставлені ідентифікатори, такі як <code>b</code>, <code>c</code>, та <code>d</code> в <code>(b, c, d)</code>, бути відмічені як неявні там, де вони визначені, але також останній список параметрів в  визначенні <code>someCall</code> або <code>someClass</code> має бути маркований як <code>implicit</code>.</p></div>
<div class="paragraph"><p>Ось простий приклад. Уявімо, що ви маєте клас <code>PreferredPrompt</code>, що енкапсулює рядок підказки оболонки (такий як, скажімо <code>"$ "</code> або <code>"&gt; "</code>), який обирає користувач:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Також, уявімо, ви маєте об'єкт <code>Greeter</code> з методом <code>greet</code>, що приймає два списка параметрів. Перший список параметрів приймає ім'я користувача як рядок, та другий список параметрів приймає <code>PreferredPrompt</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;. The system is ready.&quot;</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Останній список параметрів відмічений як <code>implicit</code>, що означає, що він може бути наданий неявно. Але ви можете все ще провадити підказку явно, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">bobsPrompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;relax&gt; &quot;</span><span class="o">)</span>
<span class="n">bobsPrompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span> <span class="o">=</span> <span class="nc">PreferredPrompt</span><span class="k">@</span><span class="mi">714</span><span class="n">d36d6scala</span><span class="o">&gt;</span>
<span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Bob&quot;</span><span class="o">)(</span><span class="n">bobsPrompt</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Bob</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="n">relax</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб дозволити компілятору надавати параметр неявно, вам треба зпочатку визначити змінну очікуваного типу, що в цьому випадку є <code>PreferredPrompt</code>. Ви можете зробити це, наприклад, в об'єкті користувацькіх налаштувань:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">JoesPrefs</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;Yes, master&gt; &quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що сама <code>val</code> відмічена як <code>implicit</code>. Якщо ні, компілятор не буде використовувати її для надання відсутнього списку параметрів. Він також не буде використовувати її, якщо вона не в полі зору як єдиний ідентифікатор, як показано в цьому прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">13</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span>
<span class="n">parameter</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span>
              <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
                           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак коли ви занесете її в поле зору через імпорт, вона буде використана для надання відсутнього списку параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">JoesPrefs._</span>
<span class="k">import</span> <span class="nn">JoesPrefs._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="nc">Yes</span><span class="o">,</span> <span class="n">master</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважне, що ключове слово <code>implicit</code> стосується до цілього списку параметрів, не до індивідуальних параметрів. Лістинг 21.1 показує приклад, в якому останній список параметрів метода <code>Greeter</code> <code>greet</code>, що знову визначений <code>implicit</code>, має два параметри: <code>prompt</code> (типу <code>PreferredPrompt</code>), та <code>drink</code> (типу <code>PreferredDrink</code>).</p></div>
<div class="paragraph"><p>Об'єкт синглтон <code>JoesPrefs</code> декларує дві неявні <code>val</code>, <code>prompt</code> типу <code>PreferredPrompt</code>, та <code>drink</code> типу <code>PreferredDrink</code>. Однак як і раніше, доки воні не в полі зору як прості ідентифікатори, вони не будуть використані для заповнення відсутнього списку параметрів для <code>greet</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">19</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span>
<span class="n">parameter</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span>
              <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
                           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете занести обі неявні <code>val</code> в поле зору за допомогою <code>import</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">JoesPrefs._</span>
<span class="k">import</span> <span class="nn">JoesPrefs._</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки обоє, <code>prompt</code> та <code>drink</code> тепер в полі зору як єдині ідентифікатори, ви можете використовувати їх для явного надання останнього списку параметрів, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)(</span><span class="n">prompt</span><span class="o">,</span> <span class="n">drink</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="nc">But</span> <span class="k">while</span> <span class="n">you</span> <span class="n">work</span><span class="o">,</span> <span class="n">why</span> <span class="n">not</span> <span class="n">enjoy</span> <span class="n">a</span> <span class="n">cup</span> <span class="n">of</span> <span class="n">tea</span><span class="o">?</span>
<span class="nc">Yes</span><span class="o">,</span> <span class="n">master</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Але оскільки тепер задовільняються всі правила для неявних параметрів, альтернативно ви можете дозволити компілятору Scala надати <code>prompt</code> та <code>drink</code> для вас, відкинувши останній список параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">)</span>
<span class="nc">Welcome</span><span class="o">,</span> <span class="nc">Joe</span><span class="o">.</span> <span class="nc">The</span> <span class="n">system</span> <span class="n">is</span> <span class="n">ready</span><span class="o">.</span>
<span class="nc">But</span> <span class="k">while</span> <span class="n">you</span> <span class="n">work</span><span class="o">,</span> <span class="n">why</span> <span class="n">not</span> <span class="n">enjoy</span> <span class="n">a</span> <span class="n">cup</span> <span class="n">of</span> <span class="n">tea</span><span class="o">?</span>
<span class="nc">Yes</span><span class="o">,</span> <span class="n">master</span><span class="o">&gt;</span>

<span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">,</span>
      <span class="n">drink</span><span class="k">:</span> <span class="kt">PreferredDrink</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>

    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">&quot;. The system is ready.&quot;</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot;But while you work, &quot;</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;why not enjoy a cup of &quot;</span> <span class="o">+</span> <span class="n">drink</span><span class="o">.</span><span class="n">preference</span> <span class="o">+</span> <span class="s">&quot;?&quot;</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">JoesPrefs</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">&quot;Yes, master&gt; &quot;</span><span class="o">)</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">drink</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;tea&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.1 - Неявний список параметрів з декількома параметрами.</p></div>
<div class="paragraph"><p>Одна річ, яку треба відмітити щодо попередніх прикладів, є те, що ми не використовуємо <code>String</code> як тип для <code>prompt</code> або <code>drink</code>, навіть якщо кінець кінцем це буде <code>String</code>, що отримають обоє через поля <code>preference</code>. Оскільки компілятор обирає неявні параметри через порівняння типів параметрів з типами змінних в полі зору, неявні параметри звичайно мають досить "рідкі" або "специфічні" типи, щоб зробити випадкове співпадіння маловірогідним. Наприклад, типи <code>PreferredPrompt</code> та <code>PreferredDrink</code> в Лістингу 21.1 були визначені єдино служити як типи неявних параметрів. Як результат, маловірогідно, що неявні змінні ціх типів будуть в полі зору, якщо вони не призначені для використання як неявні параметри для <code>Greeter.greet</code>.</p></div>
<div class="paragraph"><p>Інша річ, що треба знати щодо неявних параметрів, є те, що вони найбільш часто використовуються для провадження інформації щодо типу, вказаного <em>явно</em> в ранішньому списку пармаетрів, подібно до класів типу в Haskell.</p></div>
<div class="paragraph"><p>Як приклад, розглянемо функцію <code>maxListOrdering</code>, показану в Лістингу 21.2, що повертає максимальний елемент переданого списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxListOrdering</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxListOrdering</span><span class="o">(</span><span class="n">rest</span><span class="o">)(</span><span class="n">ordering</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordering</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.2 - Функція з верхньою межею.</p></div>
<div class="paragraph"><p>Сигнатура <code>maxListOrdering</code> подібна до <code>orderedMergeSort</code>, показаного в Лістингу 19.12: він приймає <code>List[T]</code> в якості аргумента, але зараз він приймає додатковий аргумент типу <code>Ordering[T]</code>. Цей додатковий аргумент специфікує, який <code>ordering</code> використовувати при порівнянні елементів типу <code>T</code>. Як така, ця версія може бути використана для типів, що не мають вбудованого спорядкування. Додатково, ця версія може бути використана для типів, що мають вбудоване впорядкування, але для яких ви час від часу бажаєте викорстовувати деякий інший порядок.</p></div>
<div class="paragraph"><p>Ця версія більш загальна, але вона також більш заплутана в використанні. Тепер викликач має вказувати явний порядок, навіть якщо <code>T</code> щось подібне до <code>String</code> або <code>Int</code>, що має явно визначений порядок. Щоб зробити цей новий метод більш зручним, допоможе зробити другий аргумент неявним. Цей підхід показаний в Лістингу 21.3.</p></div>
<div class="paragraph"><p>Параметр <code>ordering</code> в цьому прикладі використаний для описання впорядкування <code>T</code>. В тілі <code>maxListImpParm</code> цей <code>ordering</code> використовується в двох місцях: в рекурсивному виклику до <code>maxListImpParm</code>, та виразі <code>if</code>, що перевіряє, що голова цього списку більша, ніж максимальний елемент в залишку списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxListImpParm</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="k">implicit</span> <span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>

  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="n">rest</span><span class="o">)(</span><span class="n">ordering</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordering</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.3 - Функція з неявним параметром.</p></div>
<div class="paragraph"><p>Функція <code>maxListImpParm</code> є прикладом неявного параметра, використаного для провадження додаткової інформації щодо типу, явно вказаного в попередньому списку параметрів. Більш точно, неявний параметр <code>ordering</code> типу <code>Ordering[T]</code> провадить більше інформації щодо типу T — в цьому випадку як впорядковувати <code>T</code>. Тип <code>T</code>, згаданий в <code>List[T]</code> як параметр типу елементів, з'являється в попередньому списку параметрів. Оскільки елементи мають завжди бути проваджені явно в любому виклику до <code>maxListImpParm</code>, компілятор буде знати <code>T</code> під час компіляції, і, таким чином, може визначити, чи доступне неявне визначення типу <code>Ordering[T]</code>. Якщо це так, він може передати другий список параметрів, <code>ordering</code>, неявно.</p></div>
<div class="paragraph"><p>Цей шаблон такий загальний, що стандартна бібліотека Scala провадить неявні методи <code>ordering</code> для багатьох загальних типів. Таким чином ви можете використовувати цей метод <code>maxListImpParm</code> з різними типами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mf">1.5</span><span class="o">,</span> <span class="mf">5.2</span><span class="o">,</span> <span class="mf">10.7</span><span class="o">,</span> <span class="mf">3.14159</span><span class="o">))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">10.7</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;one&quot;</span><span class="o">,</span> <span class="s">&quot;two&quot;</span><span class="o">,</span> <span class="s">&quot;three&quot;</span><span class="o">))</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">two</span>
</pre></div></div></div>
<div class="paragraph"><p>В першому випадку компілятор вставляє <code>ordering</code> для <code>Int</code>; в другому випадку для <code>Double</code>; в третьому випадку для <code>String</code>.</p></div>
<div class="sect2">
<h3 id="______2">Правило стиля для неявних параметрів</h3>
<div class="paragraph"><p>Як правило стилю, є кращим використовувати власні імена типів в типах неявних параметрів. Наприклад, типи <code>prompt</code> та <code>drink</code> в попередньому прикладі не були <code>String</code>, але  <code>PreferredPrompt</code> та <code>PreferredDrink</code>, відповідно. Як контрприклад розглянемо функцію <code>maxListImpParm</code>, що може так само бути написаний з наступною сигнатурою типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxListPoorStyle</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="k">implicit</span> <span class="n">orderer</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак щоб використати цю версію функції, викликач має надати параметр <code>orderer</code> типу <code>(T, T) =&gt; Boolean</code>. Це досить загальний тип, що включає любу функцію з двох <code>T</code> до <code>Boolean</code>. Він зовсім нічого не вказує щодо того, для чого призначений цей тип; він може бути перевіркою на рівність, перевіркою на менше-ніж, перевіркою на більше-ніж, або повністю чимось іншим.</p></div>
<div class="paragraph"><p>Справжній код для <code>maxListImpParm</code>, наданий в Лістингу 21.3, показує кращий стиль. Він використовує параметр <code>ordering</code> типу <code>Ordering[T]</code>. Слово <code>Ordering</code> в цьому типі точно вказує, для чого призначений неявний параметр: він призначений для впорядкування елементів <code>T</code>. Оскільки цей тип <code>ordering</code> більш явний, немає проблем з додаванням неявних провайдерів для цього типу в стандартній бібліотеці. Для контрасту, уявіть хаос, що настав би, якщо б ви додали неявний тип <code>(T, T) =&gt; Boolean</code> в стантартну бібліотеку, і компілятор почав би зрошувати їм людський код. Ви б скінчили з кодом, що компілюється та виконується, але що робить досить довільні тести з парами елементів! Від цього випливає правило стилю: використовуйте щонайменьше одне роль-визначаюче ім'я в типі неявного параметру.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_21_6__">21.6 Межі контексту</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад мав показати можливості використання неявних, але ні. Зауважте, що коли ви застосовуєте неявне як параметр, не тільки компілятор спробує надати цей параметр через неявне значення, але компілятор також буде використовувати цей параметр як доступне неявне в тілі метода!</p></div>
<div class="paragraph"><p>Таким чином, перше використання <code>ordering</code> в тілі метода може бути відкинуте.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
      <span class="o">(</span><span class="k">implicit</span> <span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>

  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>    <span class="c1">// (ordering) неявне</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordering</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span> <span class="c1">// але це ordering</span>
      <span class="k">else</span> <span class="n">maxRest</span>                   <span class="c1">// все ще явне</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.4 - Функція, що використовує неявний параметр внутрішньо.</p></div>
<div class="paragraph"><p>Коли компілятор перевіряє код в Лістингу 21.4, він буде бачити, що типи не співпадають. Вираз <code>maxList(rest)</code> надає тільки один список параметрів, але <code>maxList</code> потребує два. Оскільки другий список параметрів є неявний, компілятор не здається зразу після перевірки типів. Замість цього він шукає неявний параметр відповідного типу, в цьому випадку <code>Ordering[T]</code>. В цьому випадку він находить такий, та переписує виклик на <code>maxList(rest)(ordering)</code>, після чого код проходить перевірку типів.</p></div>
<div class="paragraph"><p>Є також спосіб уникнути другого використання <code>ordering</code>. Він задіє наступний метод, визначений в стандартній бібліотеки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Ефект виклику <code>implicitly[Foo]</code> в тому, що компілятор буде шукати неявне визначення типу <code>Foo</code>. Потім він буде викликати неявний метод з цім об'єктом, що, в свою чергу, повертає назад об'єкт. Таким чином ви можете записати <code>implicitly[Foo]</code> кожного разу, коли ви бажаєте найти неявний об'єкт типу <code>Foo</code> в поточньому полі зору. Наприклад, Лістинг 21.5 показує використання <code>implicitly[Ordering[T]]</code> для отримання параметра <code>ordering</code> по його типу.</p></div>
<div class="paragraph"><p>Подивіться уважніше на цю останню версію <code>maxList</code>. Тут немає жодного спомину параметру <code>ordering</code> в тексті метода. Другий параметр може так само бути названий <code>comparator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">comparator</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="c1">// те саме тіло...</span>

  <span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
        <span class="o">(</span><span class="k">implicit</span> <span class="n">ordering</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>

    <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
      <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
        <span class="k">else</span> <span class="n">maxRest</span>
    <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.5 - Функція, що використовує <code>implicitly</code>.</p></div>
<div class="paragraph"><p>З цієї причини ця версія бути робити так само:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
<span class="o">(</span><span class="k">implicit</span> <span class="n">iceCream</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="c1">// тіло те саме...</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки цей шаблон є загальним, Scala дозволяє вам пропустити ім'я цього параметру, та скоротити заголовок метода через використання межі контексту. Використання межі контексту дозволяє вам записати сигнатуру <code>maxList</code> як показано на Лістингу 21.6. Синтаксис <code>[T : Ordering]</code> є межою контексту, і він робить дві речі. Перше, він вводить параметр типу <code>T</code>, як звичайно. Друге, він додає неявний параметр типу <code>Ordering[T]</code>. В попередніх версіях <code>maxList</code>, цей параметр був названий <code>ordering</code>, але коли використовується межа контексту, ви не знаєте, що викликається параметром. Як показано раніше, часто вам не треба знати, що викликається параметром.</p></div>
<div class="paragraph"><p>Інтуітивно ви можете думати про межу контаксту, як сказати дещо про параметр типу. Коли ви пишете <code>[T &lt;: Ordered[T]]</code> ви кажете, що <code>T</code> є <code>Ordered[T]</code>. Для контрасту, коли ви пишете <code>[T : Ordering]</code> ви не кажете багато про те, що є <code>T</code>; скоріше, ви кажете, що існує деяка форма впорядкування, асоційована з <code>T</code>. Таким чином межа контексту досить гнучка. Це дозволяє вам використовувати код, що потребує впорядкування — або любу іншу властивість типу — без потреби змінювати визначення цього типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span> <span class="kt">:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">&quot;empty list!&quot;</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">implicitly</span><span class="o">[</span><span class="kt">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]].</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">maxRest</span><span class="o">))</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.6 - Функція з межею контекста.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_7____">21.7 Коли застосовуються декілька конверсій</h2>
<div class="sectionbody">
<div class="paragraph"><p>Може трапитись, що в полі зору знаходяться декілька неявних перетворень, і кожне може робити. В великій мірі Scala відмовляється вставляти перетворення в такому випадку. Неявні роблять гарно, коли перетворення, що відкидається, повністю очевидне та чистий шаблон. Якщо застосовуються декілька перетворень, вибір вже не такий і очевидний, кінець кінцем.</p></div>
<div class="paragraph"><p>Ось простий приклад. Існує метод, що приймає послідовність, перетворення, що обертає ціле на диапазон, та перетворення, що обертає ціле на список цифр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">printLength</span><span class="o">(</span><span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">seq</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">printLength</span><span class="k">:</span> <span class="o">(</span><span class="kt">seq:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Unit</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRange</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">i</span>
<span class="n">intToRange</span><span class="k">:</span> <span class="o">(</span><span class="kt">i:</span>
<span class="kt">Int</span><span class="o">)</span><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Range</span><span class="o">.</span><span class="nc">Inclusive</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToDigits</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
<span class="n">i</span><span class="o">.</span><span class="n">toString</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toInt</span><span class="o">)</span>
<span class="n">intToDigits</span><span class="k">:</span> <span class="o">(</span><span class="kt">i:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printLength</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span><span class="o">(</span><span class="err">12</span><span class="o">)</span>
<span class="kt">required:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="nc">Note</span> <span class="n">that</span> <span class="k">implicit</span> <span class="n">conversions</span> <span class="n">are</span> <span class="n">not</span> <span class="n">applicable</span> <span class="n">because</span>
<span class="n">they</span> <span class="n">are</span> <span class="n">ambiguous</span><span class="k">:</span>
  <span class="kt">both</span> <span class="kt">method</span> <span class="kt">intToRange</span> <span class="kt">of</span> <span class="k">type</span> <span class="o">(</span><span class="kt">i:</span>
<span class="kt">Int</span><span class="o">)</span><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Range</span><span class="o">.</span><span class="nc">Inclusive</span>
  <span class="n">and</span> <span class="n">method</span> <span class="n">intToDigits</span> <span class="n">of</span> <span class="k">type</span> <span class="o">(</span><span class="kt">i:</span> <span class="kt">Int</span><span class="o">)</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="n">are</span> <span class="n">possible</span> <span class="n">conversion</span> <span class="n">functions</span> <span class="n">from</span> <span class="nc">Int</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span> <span class="n">to</span> <span class="nc">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
               <span class="n">printLength</span><span class="o">(</span><span class="mi">12</span><span class="o">)</span>
                           <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Неоднозначність тут є реальною. Перетворення цілого на послідовність цифр повністю відрізняється від перетворення його на диапазон. В цьому випадку програміст має вказати, який варіант потрібен, та бути явним. До Scala 2.7 це було кінцем історії. Кожного разу, коли застосовуються декілька неявних перетворень, компілятор відмовляється обирати між ними. Ситуація була така сама, що і з перевантаженням методів. Якщо ви спробуєте викликати <code>foo(null)</code>, і є два різні перевантаження <code>foo</code>, що приймають <code>null</code>, компілятор відмовиться обирати. Він скаже, що ціль виклику метода неоднозначна.</p></div>
<div class="paragraph"><p>Scala 2.8 послаблює це правило. Якщо одне з доступних перетворень явно більш специфічне, ніж інші, тоді компілятор буде обирати більш специфічний варіант. Ідея в тому, що коли є причина повірити програмісту, що маємо завжди обирати один перетворювач ніж інші, не вимагати від програміста записувати це явно. Кінець кінцем, перевантаження методів має те саме послаблення. Продовжуючи попередній приклад, якщо один з доступних методів <code>foo</code> приймає <code>String</code>, тоді як інший приймає <code>Any</code>, тоді буде обрана версія з <code>String</code>. Це вочевидь більш специфічне.</p></div>
<div class="paragraph"><p>Щоб бути більш точним, неявне перетворення є більш специфічним, якщо відбувається одне з наступного:</p></div>
<div class="ulist"><ul>
<li>
<p>
Тип аргументу першого є субтипом другого.
</p>
</li>
<li>
<p>
Обоє перетворення є методами, та оточуючий клас першого розширює оточуючий клас другого.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Мотивацією для перегляду цього питання та ревізії правила було покращення взаємодії між Java колекціями, Scala колекціями, та рядками.</p></div>
<div class="paragraph"><p>Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">cba</span> <span class="k">=</span> <span class="s">&quot;abc&quot;</span><span class="o">.</span><span class="n">reverse</span>
</pre></div></div></div>
<div class="paragraph"><p>Який тип, що буде виведений для <code>cba</code>? Інтуітивно, типом має бути <code>String</code>. Реверс рядка має давати рядок, вірно? Однак в Scala 2.7 відбувається те, що <code>"abc"</code> було перетворене на Scala колекцію. Реверс Scala колекції дає Scala колекцію, так що тип <code>cba</code> має бути колекцією. Також є неявне перетворення назад до рядка, але це не латає жодних проблем. Наприклад, в версії до Scala 2.8 <code>"abc" == "abc".reverse.reverse</code> було <code>false</code>!</p></div>
<div class="paragraph"><p>В Scala 2.8 тип <code>cba</code> є <code>String</code>. Старе неявне перетворення до Scala колекції (тепер названої <code>WrappedString</code>) залишилось. Однак тепер є більш специфічне перетворення, від  <code>String</code> до нового типу, названого <code>StringOps</code>. <code>StringOps</code> має багато методів, таких як <code>reverse</code>, але замість повернення колекцій вони повертають <code>String</code>. Перетворення до <code>StringOps</code> визначено напряму в <code>Predef</code>, тоді як перетворення до Scala колекцій визначено в новому класі, <code>LowPriorityImplicits</code>, що розширений <code>Predef</code>. Коли існує вибір між ціма двома перетвореннями, компілятор обере перетворення до <code>StringOps</code>, оскільки він визначений в субкласі класу, де визначене інше перетворення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_8__">21.8 Зневадження неявних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні є потужною можливістю в Scala, але те, що іноді важко зрозуміти. Цей розділ містить декілька підказок зі зневадження неявних.</p></div>
<div class="paragraph"><p>Іноді ви можете дивуватись, чому компілятор не знайшов неявне перетворення, яке, як ви сподівались, мало б бути застосоване. В такому випадку допоможе записати це перетворення явно. Якщо  це також видає повідомлення про помилку, тоді ви знатимете, чому компілятор не застосував ваше неявне.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що ви помилково взяли <code>wrapString</code> в якості перетворення від <code>Strings</code>  до <code>List</code>, замість <code>IndexedSeqs</code>. Ви можете здивуватись, чому наступний код не робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;xyz&quot;</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">String</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">xyz</span><span class="err">&quot;</span><span class="o">)</span>
<span class="kt">required:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
      <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="s">&quot;xyz&quot;</span>
                              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову, допоможе написати перетворення <code>wrapString</code> явно, щоб знайти, що іде не так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">wrapString</span><span class="o">(</span><span class="s">&quot;xyz&quot;</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">24</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">scala.collection.immutable.WrappedString</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
      <span class="k">val</span> <span class="n">chars</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">wrapString</span><span class="o">(</span><span class="s">&quot;xyz&quot;</span><span class="o">)</span>
                                        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи це, ви знаходите те що спричинило помилку: <code>wrapString</code> має помилковий тип повернення. З іншого боку, також можливо, що явне вставлення перетворення призведе до зникнення помилки. В цьому випадку ви знаєте, що одне з інших правил (таке як Правило поля зору) перешкоджає застосуванню неявного перетворення.</p></div>
<div class="paragraph"><p>Коли ви зневаджуєте програму, іноді може допомогти побачити, яке неявне перетворення вставляє компілятор. Для цього корисна опція компілятора <code>-Xprint:typer</code>. Якщо ви виконуєте <code>scalac</code> з цією опецією, компілятор буде показувати вам, як буде виглядати код після всіх неявних перетворень, що були додані перевіркою типів. Приклад показаний в Лістингу 21.7 та Лістингу 21.8. Якщо ви подивитесь на останній вираз в кожному лістингу, ви побачите, що другий список параметрів <code>enjoy</code>, що випущений в коді Лістинга 21.7, <code>enjoy("reader")</code> був доданий компілятором, як показано в Лістингу 21.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">enjoy</span><span class="o">(</span><span class="s">&quot;reader&quot;</span><span class="o">)(</span><span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">pref</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви хоробрий, спробуйте <code>scala -Xprint:typer</code> щоб отримати інтерактивну оболонку, що роздруковує пост-типізований код, що використовується внутрішньо. Якщо ви зробите це, будьте готові побачити величезну кількість шаблонного обвісу, що оточує м'ясо вашого коду.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Mocha</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="k">class</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">pref</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;mocha&quot;</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">enjoy</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">drink</span><span class="k">:</span> <span class="kt">PreferredDrink</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">&quot;. Enjoy a &quot;</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="n">drink</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="n">enjoy</span><span class="o">(</span><span class="s">&quot;reader&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.7 - Код прикладу, що використовує неявний параметр.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="nc">Xprint</span><span class="k">:type</span><span class="kt">r</span> <span class="kt">mocha.scala</span>
<span class="o">[[</span><span class="kt">syntax</span> <span class="kt">trees</span> <span class="kt">at</span> <span class="kt">end</span> <span class="kt">of</span> <span class="k">type</span><span class="kt">r</span><span class="o">]]</span>
<span class="c1">// Scala source: mocha.scala</span>
<span class="k">package</span> <span class="err">&lt;</span><span class="nn">empty</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="k">final</span> <span class="k">object</span> <span class="nc">Mocha</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span> <span class="k">with</span> <span class="nc">Application</span>
    <span class="k">with</span> <span class="nc">ScalaObject</span> <span class="o">{</span>

<span class="c1">// ...</span>

    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">pref</span><span class="k">:</span> <span class="kt">Mocha.PreferredDrink</span> <span class="o">=</span>
     <span class="k">new</span> <span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">&quot;mocha&quot;</span><span class="o">);</span>
    <span class="k">implicit</span> <span class="o">&lt;</span><span class="n">stable</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">accessor</span><span class="o">&gt;</span>
      <span class="k">def</span> <span class="n">pref</span><span class="k">:</span> <span class="kt">Mocha.PreferredDrink</span> <span class="o">=</span> <span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">pref</span><span class="o">;</span>
    <span class="k">def</span> <span class="n">enjoy</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
       <span class="o">(</span><span class="k">implicit</span> <span class="n">drink</span><span class="k">:</span> <span class="kt">Mocha.PreferredDrink</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="s">&quot;Welcome, &quot;</span><span class="o">.+(</span><span class="n">name</span><span class="o">));</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="s">&quot;. Enjoy a &quot;</span><span class="o">);</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="n">drink</span><span class="o">.</span><span class="n">preference</span><span class="o">);</span>
      <span class="n">scala</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="nc">Predef</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;!&quot;</span><span class="o">)</span>
    <span class="o">};</span>
    <span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">enjoy</span><span class="o">(</span><span class="s">&quot;reader&quot;</span><span class="o">)(</span><span class="nc">Mocha</span><span class="o">.</span><span class="k">this</span><span class="o">.</span><span class="n">pref</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 21.8 - Код прикладу після перевірки типів та вставки <code>implicit</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_21_9_">21.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Неявні є потужною, кодо-стискаючою можливістю Scala. Ця глава показала вам правила Scala щодо неявних, та декілька загальних програмних ситуацій, коли ви можете отримати вигоди від використання неявних. Як слово застереження, неявні можуть зробити код збентежливим, якщо ви використовуєте їх дуже часто. Таким чином, перед додаванням неявного перетворення, спочатку запитайте, чи ви можете досягти подібного ефекту через інші засоби, такі як наслідування, композиція міксінів або перевантаження методів. Однак якщо все це схибить, і ви відчуваєте, що більшість вашого коду досі нудна та зайва, тоді неявні можуть допомогти вам знайти вихід.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-13 03:40:05 EET
</div>
</div>
</body>
</html>
