<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__16">Глава 16</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Робота зі списками</h1>
<div class="paragraph"><p>Списки, можливо, є найбільш загально уживана структура даних в Scala програмах. Ця глава пояснює списки в деталях. Ми будемо презентувати багато загальних операцій, що можуть бути виконані на списках. Ми будемо також покривати деякі важливі принципи дизайну для програм, що роблять зі списками.</p></div>
<div class="sect1">
<h2 id="_16_1__">16.1 Спискові літерали</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви вже бачили списки в попередніх главах, так що ви знаєте, що список містить елементи  <code>'a'</code>, <code>'b'</code>, та <code>'c'</code> записується як <code>List('a', 'b', 'c')</code>. Ось деякі інші приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;pears&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">diag3</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">)</span>
<span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Списки досить подібні до масивів, але є дві важливі відмінності. Перше, списки є незмінними, елементи списку не можуть бути змінені через присвоєння. Друге, списки мають рекурсивну структуру (тобто,  <em>зв'язаний список</em>),<span class="footnote"><br />[Для графічного представлення структури <code>List</code>, дивіться Малюнок 22.2.]<br /></span>, тоді як масиви пласкі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_2__list">16.2 Тип List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як і масиви, списки є гомогенними: елементи списків всі мають той самий тип. Тип списку, що мають елементи типу <code>T</code>, записується <code>List[T]</code>. Наприклад, ось ті самі чотири списки з доданими явними списками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">fruit</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;apples&quot;</span><span class="o">,</span> <span class="s">&quot;oranges&quot;</span><span class="o">,</span> <span class="s">&quot;pears&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">nums</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="k">val</span> <span class="n">diag3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">)</span>
<span class="k">val</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип списку в Scala є ковариантним. Це означає, що для кожної пари типів <code>S</code> та <code>T</code>, якщо <code>S</code> є субтипом <code>T</code>, тоді <code>List[S]</code> є субтипом <code>List[T]</code>. Наприклад, <code>List[String]</code> є субтипом <code>List[Object]</code>. Це природно, оскільки кожний список рядків може також розглядатись і як список об'єктів.<span class="footnote"><br />[Глава 19 дає більше деталей щодо коваріантності та інших типів варіантності.]<br /></span></p></div>
<div class="paragraph"><p>Зауважте, що порожній список має тип <code>List[Nothing]</code>. Ви бачили в Розділі 11.3, що <code>Nothing</code> є нижнім типом в ієрархії класів Scala. Це субтип кожного іншого типу Scala. Оскільки списки коваріантні, з цього слідує, що <code>List[Nothing]</code> є субтипом <code>List[T]</code> для любого типу <code>T</code>. Так що об'єкт порожнього списку, що має тип <code>List[Nothing]</code>, може також розглядатись як об'єкт кожного іншого типу списка в формі <code>List[T]</code>. Ось чому дозволяється писати код, подібний до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// List() також є типом List[String]!</span>
<span class="k">val</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_3__">16.3 Конструювання списків</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
Всі списки побудовані з двох фундаментальних будівельних блоків, <code>Nil</code> та <code>::</code> (вимовляється <code>cons</code>). <code>Nil</code> представляє порожній список. Інфіксний оператор <code>::</code> виражає розширення списку зпереду. Тобто, `x 
</dt>
<dd>
<p>
xs` представляє список, чий перший елемент є <code>x</code>, за яким слідує (елементи) список <code>xs</code>. Так що попередній список значень також може бути визначений наступним чином:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="s">&quot;apples&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s">&quot;oranges&quot;</span> <span class="o">::</span> <span class="o">(</span><span class="s">&quot;pears&quot;</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
<span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">2</span> <span class="o">::</span> <span class="o">(</span><span class="mi">3</span> <span class="o">::</span> <span class="o">(</span><span class="mi">4</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span>
<span class="k">val</span> <span class="n">diag3</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span> <span class="o">::</span>
            <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span> <span class="o">::</span>
            <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">0</span> <span class="o">::</span> <span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="nc">Nil</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Фактично, попередні визначення <code>fruit</code>, <code>nums</code>, <code>diag3</code>, та <code>empty</code> в термінах <code>List(...)</code> є тільки огортками, що розширюють ці визначення. Наприклад, <code>List(1, 2, 3)</code> створює `list1 :: (2 :: (3 
</dt>
<dd>
<p>
Nil))`.
</p>
</dd>
<dt class="hdlist1">
Оскільки вона завершується на дві крапки, операція <code>::</code> асоціюється зправа: <code>A :: B :: C</code> інтерпретується як `A :: (B 
</dt>
<dd>
<p>
C)`. Таким чином, ви можете відкинути дужки в попередніх визначеннях. Наприклад:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="mi">4</span> <span class="o">::</span> <span class="nc">Nil</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до попереднього визначення <code>nums</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_4____">16.4 Базові операції зі списками</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі операції зі списками можуть бути визначені в термінах наступних трьох:</p></div>
<div class="paragraph"><p><code>head</code> повертає перший елемент списку</p></div>
<div class="paragraph"><p><code>tail</code> повератає список, що складається з усіх елементів списку, крім першого</p></div>
<div class="paragraph"><p><code>isEmpty</code> повертає <code>true</code>, якщо список порожній</p></div>
<div class="paragraph"><p>Ці операції визначені як методи класу <code>List</code>. Деякі приклади показані в Таблиці 16.1. Методи <code>head</code> та <code>tail</code> визначені тільки для не-порожніх списків. Коли вибираються для порожніх списків, вони закидають виключення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Nil</span><span class="o">.</span><span class="n">head</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">head</span> <span class="kt">of</span> <span class="kt">empty</span> <span class="kt">list</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Як приклад того, як списки можуть оброблятись, розглянемо сортування елементів списку, що є числами, в порядку зростання. Один простий спосіб зробити це - сортування вставкою, що робить наступним чином: для сортування непорожнього списку `x 
</dt>
<dd>
<p>
xs`, сортується залишок <code>xs</code>, та перший елемент <code>x</code> вставляється в правильну позицію результата. Виражене як код Scala, алгоритм сортування вставкою виглядає так:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="n">insert</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">,</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>

<span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
</pre></div></div></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 16.1 Базові операції списків</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="center" valign="top"> Що таке </th>
<th align="center" valign="top"> Що робить</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><code>empty.isEmpty</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>true</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>fruit.isEmpty</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>false</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>fruit.head</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>"apples"</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>fruit.tail.head</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>"oranges"</code></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><code>diag3.head</code></p></td>
<td align="left" valign="top"><p class="table">повертає <code>List(1, 0, 0)</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_5__">16.5 Шаблони списків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Списки також можуть бути розділені на частини з використанням порівнянь шаблонів. Шаблони списків відповідають один до однго з виразами списків. Ви можете або порівняти всі елементи списку з використанням шаблону в формі <code>List(...)</code>, або ви розбиваєте список на частини, використовуючи шаблон, скомпонований з оператора <code>::</code> та константи <code>Nil</code>.</p></div>
<div class="paragraph"><p>Ось різновид першого типу шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=</span> <span class="n">fruit</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">apples</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">oranges</span>
<span class="n">c</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">pears</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Шаблон <code>List(a, b, c)</code> співпадає зі списками довжини 3, та прив'язує три елементи до змінних шаблону, <code>a</code>, <code>b</code>, та <code>c</code>. Якщо ви не знаєте число елементів в списку заздалегідь, тоді краще замість цього порівнювати за допомогою <code>::</code>. Наприклад, шаблон `a :: b 
</dt>
<dd>
<p>
rest` співпадає зі списками довжини 2 або більше:
</p>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="____">Щодо порівняння шаблонів списків</h2>
<div class="sectionbody">
<div class="dlist"><dl>
<dt class="hdlist1">
Якщо ви розглядаєте можливі форми шаблонів, пояснених в Главі 15, ви можете винайти, що ні <code>List(...)</code> ані <code>::</code> не вигладають, як підходящі різновиди шаблонів, визначених там. Фактично, <code>List(...)</code> є примірником визначеного в бібліотеці шаблону екстрактора. Такі шаблони будуть обговорюватись в Главі 26. Шаблон <code>cons</code> <code>x :: xs</code> є особливим випадком шаблону інфіксної операції. Як вираз, інфіксна операція еквівалентна до виклику метода. Для шаблонів правила інші: в якості шаблона інфіксна операція, така, як <code>p op q</code> еквівалентна до <code>op(p, q)</code>. Тобто, інфіксний оператор <code>op</code> трактується як шаблон конструктора. Зокрема, шаблон <code>cons</code>, такий як `x 
</dt>
<dd>
<p>
xs`, трактується як <code>::(x, xs)</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Це підказує, що має бути клас на ім'я <code>::</code>, що відповідає до конструктора шаблону. Звісно, такий клас існує — його ім'я <code>scala.::</code>, та це саме той клас, що будує непорожні списки. Так що <code>::</code> існує двічі в Scala, один раз як ім'я, класу в пакунку <code>scala</code>, і знову як метод в класі <code>List</code>. Ефект метода <code>::</code> є продукувати примірник класу <code>scala.::</code>. Ви знайдете більше деталей щодо того, як реалізований клас <code>List</code>, в Главі 22.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=</span> <span class="n">fruit</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">apples</span>
<span class="n">b</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">oranges</span>
<span class="n">rest</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">pears</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Розбиття списків на частити за допомогою шаблонів є альтернативою до їх поділення за допомогою базових методів <code>head</code>, <code>tail</code>, та <code>isEmpty</code>. Наприклад, ось знову сортування вставкою, на цей раз написана за допомогою порівняння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs1</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
                  <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Часто порівняння шаблонів зі списками ясніше, ніж їх декомпозиція за допомогою методів, так що порівняння шаблонів має стати частиною вашого інструментарія обробки списків.</p></div>
<div class="paragraph"><p>Це все що вам треба знати щодо списків в Scala, щоб використовувати їх коректно. Однак існує велика кількість методів, що захоплюють загальні шаблони операцій зі списками. Ці методи роблять програми обробки списків більш стислими, та часто яснішими. Наступні два розділи представляють найбільш важливі методи, визначені в класі <code>List</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_6______list">16.6 Методи першого порядка на класі List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цей розділ пояснює більшість методів першого порядка, визначених в класі <code>List</code>. Метод є першого порядку, якщо він не приймає жодних функцій як аргументів. Ми будемо також вводити деякі рекомендовані прийоми, щоб структурувати програми, що оперують на списках, використовуючи для цього два приклада.</p></div>
<div class="sect2">
<h3 id="____2">Конкатенація двох списків</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Операція, подібна до <code>::</code> є конкатенація списків, що записується як <code>:::</code>. На відміну від <code>::</code>, <code>:::</code> приймає два списка як операнди. Результатом `xs 
</dt>
<dd>
<p>
ys` є новий список, що містить всі елементи <code>xs</code>,за яким слідують всі елементи <code>ys</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">()</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і <code>cons</code>, конкатенація списків асоціюється зправа. Такий вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">:::</span> <span class="n">ys</span> <span class="o">:::</span> <span class="n">zs</span>
</pre></div></div></div>
<div class="paragraph"><p>інтерпретується так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="o">:::</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:::</span> <span class="n">zs</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____2">Принцип "Розділяй та володій"</h3>
<div class="paragraph"><p>Конкатенація (<code>:::</code>) реалізована як метод в класі <code>List</code>. Також можливо реалізувати конкатенацію "вручну", використовуючи порівняння шаблонів для списків. Є повчальним спробувати зробити це самостійно, оскільки це показує загальний шлях реалізації алгоритмів з використанням списків. Перше, ми домовимось щодо сигнатури для метода конкатенації, який ми назвемо <code>append</code>. Щоб не дуже змішувати все докупи, будемо вважати, що <code>append</code> визначений за межами класу <code>List</code>, так що він прийматиме два списки, що будуть канкатеновані, як параметри. Ці два списки мають домовитись щодо типу їх елементів, але цей тип може бути довільним. Це може бути виражене через надання <code>append</code> параметру типа,<span class="footnote"><br />[Параметр типу буде пояснений більш детально в Главі 19.]<br /></span>, що представляє тип елемента двох вхідних списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб розробити реалізацію <code>append</code>, слід пам'ятати принцип розробки "поділяй та володій" для програм з рекурсивними структурами даних, як списки. Багато алгоритмів над списками спочатку розділяють вхідний список на простіші випадки, використовуючи порівняння шаблонів. Це частина <em>роздліляй</em> цього принципу. Потім вони конструюють результат для кожного <code>case</code>. Якщо результат є непорожній список, деякі з його частин можуть бути сконструйовані через рекурсивні виклики того самого алгоритму. Це частина <em>володій</em> принципу.</p></div>
<div class="paragraph"><p>Щоб застосувати цей принцип до реалізації метода <code>append</code>, перше запитання, що треба запитати, це який зі списків порівнювати. Це трохи тривіальніше в випадку <code>append</code>, ніж для багатьох інших методів, оскікльи є два вибори. Однак, наступна фаза "володіння" каже вам, що вам треба сконструювати список, що складається з усіх елементів обох вхідних списків. Оскільки списки сконструйовані з кінця в напрямку початку, <code>ys</code> може залишатись як є, тоді як <code>xs</code> буде треба розбити на частини на поставити перед <code>ys</code>. Таким чином, має сенс сконцентруватись на <code>xs</code>, як джерелі для порівняння шаблонів. Найбільш загальне порівняння шаблонів зі списками є просте розрізнення порожніх та непорожніх списків. Так що це дає наступний контур метода <code>append</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="o">???</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="o">???</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що залишається, це заповнити два місця, відмічені <code>???</code>.<span class="footnote"><br />[Метод <code>???</code>, що закидає <code>scala.NotImplementedError</code>, та має тип результата <code>Nothing</code>, може бути використаний як тимчасова реалізація впродовж розробки.]<br /></span> Перше таке місце є альтернатива, де вхідний список <code>xs</code> порожній. В цьому випадку конкатенація видає другий список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Друге місце, залишене відкритим, є альтернатива, де вхідний список <code>xs</code> складається з деякого заголовка <code>x</code>, за яким слідує хвіст <code>xs1</code>. В цьому випадку результат також є непорожнім списком. Щоб сконструювати непорожній список, вам треба знати, якими має бути голова та хвіст цього списку. Ви знаєте, що перший елемент результуючого списку є <code>x</code>. Як щодо залишку елементів, вони можуть бути обчислені через додавання другого списку, <code>ys</code>, до залишку першого списку, <code>xs1</code>.</p></div>
<div class="paragraph"><p>Це завершує дизайн, та дає таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">append</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Обчислення другої альтернативи ілюструє частину "володій" принципа розділення та заволодіння: думайте спочатку, який контур бажаного виходу має бути, потім обчислюйте індивідуальні частини цього контура, використовуючи рекурсивні виклики алгоритма, коли це доцільно. Нарешті, сконструюйте вихід з ціх частин.</p></div>
</div>
<div class="sect2">
<h3 id="____code_length_code">Отримання довжини списку: <code>length</code></h3>
<div class="paragraph"><p>Метод <code>length</code> обчислює довжину списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">length</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>На списках, на відміну від масивів, <code>length</code> є відносно коштовною операцією. Він змушує подорожувати по цілому списку, щоб знайти кінець, і, таким чином, займає час, пропорційний до числу елементів в списку. Ось чому не є гарною ідеєю замінити тест, такий як <code>xs.isEmpty</code> на <code>xs.length == 0</code>. Результат двох тестів еквівалентний, але другий повільніший, зокрема якщо список <code>xs</code> довгий.</p></div>
</div>
<div class="sect2">
<h3 id="_____code_init_code__code_last_code">Доступ до кінця списку: <code>init</code> та <code>last</code></h3>
<div class="paragraph"><p>Ви вже знаєте базові операції, <code>head</code> та <code>tail</code>, що, відповідно, вибирає перший елемент списку, та залишок списку, крім першого елементу. Вони обоє мають операцію двійника: <code>last</code> повертає останній елемент (непорожнього) списку, тоді як <code>init</code> повертає список, що складається з усіх елементів, крім останнього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">abcde</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">,</span> <span class="sc">&#39;c&#39;</span><span class="o">,</span> <span class="sc">&#39;d&#39;</span><span class="o">,</span> <span class="sc">&#39;e&#39;</span><span class="o">)</span>
<span class="n">abcde</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">last</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">init</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як <code>head</code> та <code>tail</code>, ці методи закидають виключення, коли застосовуються до порожніх списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">().</span><span class="n">init</span>
<span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">UnsupportedOperationException</span><span class="k">:</span> <span class="kt">Nil.init</span>
<span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="nc">List</span><span class="o">.</span><span class="n">init</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">544</span><span class="o">)</span>
<span class="n">at</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">().</span><span class="n">last</span>
<span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">NoSuchElementException</span><span class="k">:</span> <span class="kt">Nil.last</span>
<span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="nc">List</span><span class="o">.</span><span class="n">last</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">563</span><span class="o">)</span><span class="n">at</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>На відміну від <code>head</code> та <code>tail</code>, які обоє виконуються за сталий час, <code>init</code> та <code>last</code> подорожують по цілому списку, щоб отримати свій результат. Як результат, вони займають час, пропорційний до довжини списку.</p></div>
<div class="paragraph"><p>Є гарною ідеєю організувати ваші дані так, щоб більшість доступів приходились на початок списку, скоріше, ніж на останній елемент.</p></div>
</div>
<div class="sect2">
<h3 id="___code_reverse_code">Реверс списку: <code>reverse</code></h3>
<div class="paragraph"><p>Якщо в деякій точці обчислень алгоритм вимагає частого доступу до кінця списку, іноді буває кращим спочатку реверсувати список, та потім робити з результатом. Ось як це робиться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як всі інші операції зі списками, <code>reverse</code> створює новий список, скоріше ніж змінювати той, з яким робить. Оскільки списки незмінні, така заміна все одно не була б можливою. Щоб перевірити це, перевірте, що оригінальне значення <code>abcde</code> незмінне після операції <code>reverse</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Операції <code>reverse</code>, <code>init</code> та <code>last</code> задовільняють деяким законам, що може бути використане для міркувань щодо обчислень та для спрощення програм.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>reverse</code> є інверсією самого себе:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">reverse</span> <span class="nc">_equals_</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>reverse</code> перетворює <code>init</code> на <code>tail</code>, та <code>last</code> на <code>head</code>, за винятком того, що елементи реверсовані:
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">init</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">tail</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">reverse</span>
<span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">head</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">last</span>
<span class="n">xs</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">last</span> <span class="nc">_equals_</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span>
</pre></div></div></div>
<div class="paragraph"><p>Реверс може бути реалізований з використанням конкатенації (<code>:::</code>), як наступний метод, <code>rev</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">rev</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">xs</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">rev</span><span class="o">(</span><span class="n">xs1</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Однак, цей метод менш ефективний, ніж дехто може сподіватись. Щоб вивчити складність <code>rev</code>, вважаючи, що список <code>xs</code> має довжину <code>n</code>. Зауважте, що існує <code>n</code> рекурсивних викликів до <code>rev</code>. Кожний виклик, крім останнього, включає конкатенацію списків. Конкатенація списків, `xs 
</dt>
<dd>
<p>
ys`, займає час, пропорційний до довжини свого першого аргументу, <code>xs</code>. Таким чином, загальна складність <code>rev</code> є:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">+</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">n</span><span class="o">)</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Іншими словами, складність <code>rev</code> є квадратичною до довжини свого вхідного аргументу. Це невтішно, порівнюючи до реверсу змінного зв'язанного списку, що має лінійну складність. Однак поточна реалізація <code>rev</code> не є кращою можливою реалізацією. В прикладі, що починається тут, ви побачите, як прискорити її.</p></div>
</div>
<div class="sect2">
<h3 id="____code_drop_code_code_take_code_code_splitat_code">Префікси та суфікси: <code>drop</code>, <code>take</code>, <code>splitAt</code></h3>
<div class="paragraph"><p>Операції <code>drop</code> та <code>take</code> узагальнують <code>tail</code> та <code>init</code> в тому, що вони повертають довільні префікси або суфікси списку. Вираз <code>xs take n</code> повертає перші <code>n</code> елементів списку <code>xs</code>. Якщо <code>n</code> більше, ніж <code>xs.length</code>, повертається цілий список <code>xs</code>. Операція <code>xs drop n</code> повертає всі елементи списку <code>xs</code>, за винятком перших <code>n</code>. Якщо <code>n</code> більше, ніж <code>xs.length</code>, повертається порожній список.</p></div>
<div class="paragraph"><p>Операція <code>splitAt</code> розділяє список по наданому індексу, повертаючи пару з двох списків.<span class="footnote"><br />[Як зазначалось в Розділі 10.12, термін пара є неформальним ім'ям для <code>Tuple2</code>.]<br /></span> Вона визначається рівністю:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">take</span> <span class="n">n</span><span class="o">,</span> <span class="n">xs</span> <span class="n">drop</span> <span class="n">n</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак <code>splitAt</code> уникає подвійної подорожі по списку <code>xs</code>. Ось деякі приклади ціх трьох методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">take</span> <span class="mi">2</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">drop</span> <span class="mi">2</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">splitAt</span> <span class="mi">2</span>
<span class="n">res10</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span><span class="nc">List</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_apply_code__code_indices_code">Вибір елементів: <code>apply</code> та <code>indices</code></h3>
<div class="paragraph"><p>Вибір довільних елементів підтримується через метод <code>apply</code>; однак це менш поширена операція для списків, ніж для масивів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">apply</span> <span class="mi">2</span> <span class="c1">// рідкість в Scala</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і для інших типів, <code>apply</code> вставляється неявно, коли об'єкт з'являється в функціональній позиції в виклику метода. Так що рядок вище може бути скорочено:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// рідкість в Scala</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна з причин, чому вибір довільного елемента є менш популярним для списків, ніж для масивів, в тому, що <code>xs(n)</code> займає час, пропорційний до індексу <code>n</code>. Фактично, <code>apply</code> просто визначена через комбінацію <code>drop</code> та <code>head</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">apply</span> <span class="n">n</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">drop</span> <span class="n">n</span><span class="o">).</span><span class="n">head</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення також робить зрозумілим, що індекси списків знаходяться в диапазоні від 0 до довжини списку мінус один, так само, як для масивів. Метод <code>indices</code> повертає список, що складається з усіх валідних індексів для даного списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">indices</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span><span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_flatten_code">Зплющення списка списків: <code>flatten</code></h3>
<div class="paragraph"><p>Метод <code>flatten</code> приймає список списків, та зплющує його до одного списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)).</span><span class="n">flatten</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fruit</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toCharArray</span><span class="o">).</span><span class="n">flatten</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">g</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span>
<span class="n">s</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Він може бути застосований тільки до списків, всі елементи яких є списками. Спроба зплющити любі інші списки буде давати помилку компіляції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">flatten</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">No</span> <span class="kt">implicit</span> <span class="kt">view</span> <span class="kt">available</span> <span class="kt">from</span> <span class="kt">Int</span> <span class="o">=&gt;</span>
<span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">GenTraversableOnce</span><span class="o">[</span><span class="kt">B</span><span class="o">].</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">).</span><span class="n">flatten</span>
<span class="o">^</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_zip_code__code_unzip_code">Стиснення списків: <code>zip</code> та <code>unzip</code></h3>
<div class="paragraph"><p>Операція <code>zip</code> приймає два списки, та формує список пар:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">indices</span> <span class="n">zip</span> <span class="n">abcde</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">scala.collection.immutable.IndexedSeq</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Char</span><span class="o">)]</span> <span class="k">=</span>
    <span class="nc">Vector</span><span class="o">((</span><span class="mi">0</span><span class="o">,</span><span class="n">a</span><span class="o">),</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="n">b</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="n">c</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="n">d</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо два списки мають різні довжини, любий неспівпавший елемент відкидається:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">zipped</span> <span class="k">=</span> <span class="n">abcde</span> <span class="n">zip</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">zipped</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Char</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="n">a</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Корисний особливий випадок є <code>zip</code> списку з його індексом. Це робиться більш ефективно за допомогою метода <code>zipWithIndex</code>, що парує кожний елемент списку з позицією, де він з'являється в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">zipWithIndex</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Char</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="n">a</span><span class="o">,</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">d</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span>
    <span class="o">(</span><span class="n">e</span><span class="o">,</span><span class="mi">4</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Любий список таплів також може бути змінений назад, та таплу списків, використовуючи метод <code>unzip</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">zipped</span><span class="o">.</span><span class="n">unzip</span>
<span class="n">res19</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
  <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">),</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи <code>zip</code> та <code>unzip</code> провадять один шлях для обробки декількох списків разом. Дивіться Розділ 16.9 для більш стислого шляху робити це.</p></div>
</div>
<div class="sect2">
<h3 id="___code_tostring_code__code_mkstring_code">Відображення списків: <code>toString</code> та <code>mkString</code></h3>
<div class="paragraph"><p>Операція <code>toString</code> повертає канонічну рядкову репрезентацію списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">toString</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте іншу репрезентацію, ви можете використати метод <code>mkString</code>. Операція <code>xs mkString (pre, sep, post)</code> включає чотири операнди: список <code>xs</code>, що буде відображений, рядок <code>prefix</code>, що буде відображений перед усіма елементами, рядок роздільника <code>sep</code>, що буде відображений між послідовними елементами, та рядок <code>postfix</code>, що буде відображений в кінці.</p></div>
<div class="paragraph"><p>Результатом операції є рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pre</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="o">...+</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">post</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>mkString</code> має два перевантажені варіанти, що дозволяють вам відкинути деякі або всі його пргументи. Перший вариант приймає тільки рядок роздільника:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">mkString</span> <span class="n">sep</span> <span class="nc">_equals_</span> <span class="n">xs</span> <span class="n">mkString</span> <span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">sep</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Другий варіант дозволяє вам оминути всі аргументи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span><span class="o">.</span><span class="n">mkString</span> <span class="nc">_equals_</span> <span class="n">xs</span> <span class="n">mkString</span> <span class="s">&quot;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">mkString</span> <span class="o">(</span><span class="s">&quot;[&quot;</span><span class="o">,</span> <span class="s">&quot;,&quot;</span><span class="o">,</span> <span class="s">&quot;]&quot;</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">[</span><span class="kt">a</span>,<span class="kt">b</span>,<span class="kt">c</span>,<span class="kt">d</span>,<span class="kt">e</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">mkString</span> <span class="s">&quot;&quot;</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcde</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span><span class="o">.</span><span class="n">mkString</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abcde</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">mkString</span> <span class="o">(</span><span class="s">&quot;List(&quot;</span><span class="o">,</span> <span class="s">&quot;, &quot;</span><span class="o">,</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є варіанти методів <code>mkString</code>, названі <code>addString</code>, що додають сконструйований рядок до об'єкту <code>StringBuilder</code>,<span class="footnote"><br />[Це клас <code>scala.StringBuilder</code>, не <code>java.lang.StringBuilder</code>.]<br /></span>, скоріше ніж повертати результат:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
<span class="n">buf</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">addString</span> <span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="s">&quot;(&quot;</span><span class="o">,</span> <span class="s">&quot;;&quot;</span><span class="o">,</span> <span class="s">&quot;)&quot;</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">StringBuilder</span> <span class="o">=</span> <span class="o">(</span><span class="n">a</span><span class="o">;</span><span class="n">b</span><span class="o">;</span><span class="n">c</span><span class="o">;</span><span class="n">d</span><span class="o">;</span><span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи <code>mkString</code> та <code>addString</code> наслідуються від супертрейта <code>List</code>, трейта <code>Traversable</code>, так що вони також застосовуються до всіх інших колекцій.</p></div>
</div>
<div class="sect2">
<h3 id="___code_iterator_code_code_toarray_code_code_copytoarray_code">Перетворення списків: <code>iterator</code>, <code>toArray</code>, <code>copyToArray</code></h3>
<div class="paragraph"><p>Щоб перетворити дані між пласким світом масиву, та рекурсивним світом списків, ви можете використовувати метод <code>toArray</code> в класі <code>List</code>, та <code>toList</code> в класі <code>Array</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="n">abcde</span><span class="o">.</span><span class="n">toArray</span>
<span class="n">arr</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">toList</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є метод <code>copyToArray</code>, що копіює список елементів в послідовні позиції в деякому масиві призначення. Операція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">copyToArray</span> <span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>копіює всі елементи списку <code>xs</code> до масива <code>arr</code>, починаючи з позиції <code>start</code>. Ви маєте переконатись, що масив призначення <code>arr</code> досить довгий, щоб містити список повністю. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">arr2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">10</span><span class="o">)</span>
<span class="n">arr2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">copyToArray</span> <span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">arr2</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, якщо вам треба отримати доступ до елементів списку через ітератор, ви можете використовувати метод <code>iterator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">abcde</span><span class="o">.</span><span class="n">iterator</span>
<span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">non</span><span class="o">-</span><span class="n">empty</span> <span class="n">iterator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">a</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Char</span> <span class="o">=</span> <span class="n">b</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Приклад: сортування злиттям</h3>
<div class="paragraph"><p>Сортування вставкою, презентоване раніше, є стислим для написання, але не дуже ефективним. Його середня складність пропорційна квадрату довжини вхідного списку. Більш ефективний алгоритм є сортування злиттям.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цей приклад провадить іншу ілюстрацію принципу розділяй та володій, карування, а також корисну дискусію по алгоритмічній складності. Якщо ви бажаєте рухатись трохи швидше при першому проходженні цієї книги, ви можете безпечно пропустити Розділ 16.7.</p></div>
<div class="paragraph"><p>Сортування злиттям робить наступним чином: зпершу, якщо список має нуль або один елемент, він вже впорядкований, так що список може бути повернений без змін. Інши списки поділяються на два суб-списки, кожний містить близько половини елементів оригінального списку. Кожний субсписок впорядковується рекурсивним викликом, та отримані два відсортовані списки поєднуються операцією злиття.</p></div>
<div class="paragraph"><p>Для загальної реалізації сортування злиттям ви бажаєте залишити відкритим тип елементів списку, що будуть сортуватись, та функцію, що буде використана для порівняння елементів. Ви отримаєте функцію максімальної загальності, передавши ці два елементи як параметри. Це призводить до реалізації, показаній в Лістингу 16.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">msort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">less</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
    <span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">msort</span><span class="o">(</span><span class="n">less</span><span class="o">)(</span><span class="n">ys</span><span class="o">),</span> <span class="n">msort</span><span class="o">(</span><span class="n">less</span><span class="o">)(</span><span class="n">zs</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 16.1 - Функція сортування злиттям для List.</p></div>
<div class="paragraph"><p>Складність <code>msort</code> має порядок (<em>n log(n)</em>), де <code>n</code> є довжина вхідного списку. Щоб побачити чому, зауважте, що розділення списку на два та злиття двох відсортованих списків, кожне займає час, пропорційний до довжини списків-аргументів. Кожний рекурсивний виклик зменшує навпіл число елементів на вході, так що відбудеться  близько <code>log(n)</code> послідовних рекурсивних викликів, доки буде досягнуто базового випадку зі списками довжиною 1. Однак для довших списків кожний виклик відгалужує два інші виклики. Додаючи все разом, ми отримаємо, що на кожному рівні викликів <em>log(n)</em> кожний елемент оригінальних списків прийме участь в одній операції розділення, та в одній операції злиття.</p></div>
<div class="paragraph"><p>Таким чином, кожний рівень викликів має загальну вартість, пропорційну до <code>n</code>. Оскільки загалом <em>log(n)</em> рівнів виклику, ми отримаємо загальну вартість, пропорційну до <em>n log(n)</em>. Ця вартість не залежить від початкового розподілення елементів в списку, так що найгірша вартість є такою самою, що і середня вартість. Ця властивість робить сортування злиттям привабливим алгоритмом для сортування списків.</p></div>
<div class="paragraph"><p>Ось приклад того, як використовується <code>msort</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>msort</code> є класичним прикладом концепції карування, обговореної в Розділі 9.3. Карування робить простим спеціалізувати функцію для певних функцій порівняння. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">intSort</span> <span class="k">=</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="k">_</span>
<span class="n">intSort</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Змінна <code>intSort</code> посилається на функцію, що приймає список цілих, та сортує їх в числовому порядку. Як описане в Розділі 8.6, підкреслення стоїть замість відсутнього списку аргументів. В цьому випадку відсутній аргумент це список, що має бути впорядкований. Як інший приклад, ось як ви можете визначити функцію, що сортує  список цілих в зворотньому числовому порядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">reverseIntSort</span> <span class="k">=</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="k">_</span>
<span class="n">reverseIntSort</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ви вже провадите функцію порівняння через карування, тепер вам треба провадити список для сортування, коли ви викликаєте функції <code>intSort</code> або <code>reverseIntSort</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">mixedInts</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="n">mixedInts</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">intSort</span><span class="o">(</span><span class="n">mixedInts</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">reverseIntSort</span><span class="o">(</span><span class="n">mixedInts</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_7_____list">16.7 Методи вищих порядків класу List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Багато операцій зі списками мають подібну структуру. Декілька шаблонів з'являються раз за разом. Деякі приклади: трансформація кожного елементу списка в деякий спосіб, перевірка, чи властивість дотримується для всіх елементів в списку, виділення зі списку елементів, що задовільняють певному критерію, або комбінування елементів списку з використанням деякого оператора. В Java такі шаблони будуть зазвичай виражені ідіоматичними комбінаціями циклів <code>for</code> або <code>while</code>. В Scala вони можуть бути виражені більш стисло та напряму, використовуючи оператори вищих порядків,<span class="footnote"><br />[Під операторами вищих порядків ми розуміємо функції вищих порядків, використані в операторній нотації. Як зазначено в Розділі 9.1, функція є "вищого порядку", якщо вона сприймає одну або більше інших функцій в якості параметрів.]<br /></span> що реалізовані як методи в класі <code>List</code>. Ці оператори вищого порядку обговорюються в цьому розділі.</p></div>
<div class="sect2">
<h3 id="___code_map_code_code_flatmap_code_code_foreach_code">Відзеркалення списків: <code>map</code>, <code>flatMap</code>, <code>foreach</code></h3>
<div class="paragraph"><p>Операція <code>xs map f</code> бере як операнди список <code>xs</code> типу <code>List[T]</code>, та функцію <code>f</code> типу <code>T =&gt; U</code>. Вона повертає список, що утворюється застосуванням функції <code>f</code> до кожного елементу в <code>xs</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">res32</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;the&quot;</span><span class="o">,</span> <span class="s">&quot;quick&quot;</span><span class="o">,</span> <span class="s">&quot;brown&quot;</span><span class="o">,</span> <span class="s">&quot;fox&quot;</span><span class="o">)</span>
<span class="n">words</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">the</span><span class="o">,</span> <span class="n">quick</span><span class="o">,</span> <span class="n">brown</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res33</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">)</span>
<span class="n">res34</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">eht</span><span class="o">,</span> <span class="n">kciuq</span><span class="o">,</span> <span class="n">nworb</span><span class="o">,</span> <span class="n">xof</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>flatMap</code> подібний до <code>map</code>, але він приймає функцію, що повертає список елементів в якості свого правого операнда. Він застосовує функцію до кожного елемена списку, та повертає конкатенацію всіх результатів функції. Різниця між <code>map</code> та <code>flatMap</code> проілюстрована в наступному прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
<span class="n">res35</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span>
<span class="n">c</span><span class="o">,</span> <span class="n">k</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span> <span class="n">n</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">x</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>
<span class="n">res36</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">h</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">u</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">k</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">w</span><span class="o">,</span>
<span class="n">n</span><span class="o">,</span> <span class="n">f</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що коли <code>map</code> повертає список зі списків, <code>flatMap</code> повертає єдиний список, в якому всі елементи списку конкатеновані.</p></div>
<div class="paragraph"><p>Відмінність та взаємодія між <code>map</code> та <code>flatMap</code> також продемонстрована в наступному виразі, що конструює список з усіх пар <code>(i, j)</code>, таких що <code>1 ≤ j &lt; i &lt; 5</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span>
  <span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span>
<span class="o">)</span>
<span class="n">res37</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span>
<span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>List.range</code> є допоміжний метод, що створює список з усіх цілих в деякому диапазоні. Він використовується двічи в цьому прикладі: один раз для генерації списку цілих від <code>1</code> (включно) до <code>5</code> (виключно), та другий раз для генерації списку цілих від <code>1</code> до <code>i</code>, для кожного значення <code>i</code>, взятого з першого списку. <code>map</code> в цьому виразі генерує список таплів <code>(i, j)</code>, де <code>j &lt; i</code>. Зовнішній <code>flatMap</code> в цьому прикладі генерую цей список для кожного <code>i</code> між <code>1</code> та <code>5</code>, та потім конкатенує всі результати. Альтернативно, той самий список може бути сконструйований за допомогою виразу <code>for</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="k">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви вивчите більше щодо взаємодії між виразами <code>for</code> та операціями списків в Главі 23.</p></div>
<div class="paragraph"><p>Третя <code>map</code>-подібна операція є <code>foreach</code>. Однак на відміну від <code>map</code> та <code>flatMap</code>, <code>foreach</code> приймає процедуру (функцію, тип якої <code>Unit</code>) в якості правого операнда. Він просто застосовує процедуру до кожного елементу списку. Результат самої операції знову <code>Unit</code>; список результатів не збирається. Як приклад, ось стислий спосіб підсумувати всі числа в списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">sum</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="k">_</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span>
<span class="n">res39</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_filter_code_code_partition_code_code_find_code_code_takewhile_code_code_dropwhile_code_code_span_code">Фільтрування списків: <code>filter</code>, <code>partition</code>, <code>find</code>, <code>takeWhile</code>, <code>dropWhile</code>, <code>span</code></h3>
<div class="paragraph"><p>Операця <code>xs filter p</code> приймає як операнди список <code>xs</code> типу <code>List[T]</code>, та функцію предикат <code>pof</code> типу <code>T =&gt; Boolean</code>. Вона видає список всіх елементів <code>x</code> в <code>xs</code>, для яких <code>p(x)</code> є <code>true</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res40</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res41</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">the</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>partition</code> подібна до <code>filter</code>, але повертає пару списків. Один список містить всі елементи, для яких предикат є <code>true</code>, доки інший містить всі елементи, для яких предикат є <code>false</code>. Це визначено через еквівалентність:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">partition</span> <span class="n">p</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">filter</span> <span class="n">p</span><span class="o">,</span> <span class="n">xs</span> <span class="n">filter</span> <span class="o">(!</span><span class="n">p</span><span class="o">(</span><span class="k">_</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">partition</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res42</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>find</code> також подібний до <code>filter</code>, але він повертає перший елемент, що задовільняє наданому предикату, скоріше ніж всі такі елементи. Операція <code>xs find p</code> приймає список <code>xs</code> та предикат <code>ep</code> як операнди. Він повертає опціональне значення. Якщо існує елемент <code>x</code> в <code>xs</code>, для якого <code>p(x)</code> є <code>true</code>, повертається <code>Some(x)</code>. Інакше <code>p</code> є <code>false</code> для всіх елементів, та повертається <code>None</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">find</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res43</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">find</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res44</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператори <code>takeWhile</code> та <code>dropWhile</code> також приймають предикат як свій правий операнд. Операція <code>xs takeWhile p</code> бере найдовший префікс списку <code>xs</code>, такий що для кожного елементу в префіксі задовільняється <code>p</code>. Аналогічно, операція <code>xs dropWhile p</code> видаляє найдовший префікс зі списку <code>xs</code>, такий, що для кожного елементу в префіксі задовільняється <code>p</code>. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">takeWhile</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res45</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span> <span class="n">startsWith</span> <span class="s">&quot;t&quot;</span><span class="o">)</span>
<span class="n">res46</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">quick</span><span class="o">,</span> <span class="n">brown</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>span</code> комбінує <code>takeWhile</code> та <code>dropWhile</code> в одній операції, так само, як <code>splitAt</code> комбінує <code>take</code> та <code>drop</code>. Він повертає пару з двох списків, визначених еквівалентістю:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">xs</span> <span class="n">span</span> <span class="n">p</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">xs</span> <span class="n">takeWhile</span> <span class="n">p</span><span class="o">,</span> <span class="n">xs</span> <span class="n">dropWhile</span> <span class="n">p</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і <code>splitAt</code>, <code>span</code> уникає подвійного подорожування списком <code>xs</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">span</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">res47</span><span class="k">:</span> <span class="o">(</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span><span class="nc">List</span><span class="o">(-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_forall_code__code_exists_code">Предикати на списках: <code>forall</code> та <code>exists</code></h3>
<div class="paragraph"><p>Операція <code>xs forall p</code> приймає як аргументи список <code>xs</code> та предикат <code>p</code>. Її результат є <code>true</code>, якщо всі елементи в списку задовільняють <code>p</code>. Відповідно, операція <code>xs exists p</code> повертає <code>true</code>, якщо існує елемент в <code>xs</code>, що задовільняє предикату <code>p</code>. Наприклад, щоб з'ясувати, чи матриця, представлена як список списків, має рядок з тільки нульовими елементами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">hasZeroRow</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span>
<span class="n">m</span> <span class="n">exists</span> <span class="o">(</span><span class="n">row</span> <span class="k">=&gt;</span> <span class="n">row</span> <span class="n">forall</span> <span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span>
<span class="n">hasZeroRow</span><span class="k">:</span> <span class="o">(</span><span class="kt">m:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span><span class="nc">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">hasZeroRow</span><span class="o">(</span><span class="n">diag3</span><span class="o">)</span>
<span class="n">res48</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_code__code_code">Згортання списків: <code>/:</code> та <code>:\</code></h3>
<div class="paragraph"><p>Інший загальний різновид операцій комбінують елементи списку за допомогою деякого оператору. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">sum</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="nc">_equals_</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>Це спеціальний примірник операції згортання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">sum</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Подібно до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">product</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="nc">_equals_</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>
</pre></div></div></div>
<div class="paragraph"><p>є особливим примірником цього оператора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">product</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
<span class="n">product</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Операція лівого згортання <code>(z /: xs) (op)</code> включає три об'єкти: початкове значення <code>z</code>, список <code>xs</code>, та двомісну операцію <code>op</code>. Результат згортання є <code>op</code>, застосований між послідовними елементами списку з префіксом <code>z</code>.</p></div>
<div class="paragraph"><p>Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">z</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">))</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">z</span><span class="o">,</span> <span class="n">a</span><span class="o">),</span> <span class="n">b</span><span class="o">),</span> <span class="n">c</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або графічно:</p></div>
<div class="paragraph"><p>Ось інший приклад, що ілючтрує, як використовується <code>/:</code>. Щоб конкатенувати всі слова в списку рядків з проміжками між ними та напочатку, ви можете записати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="s">&quot;&quot;</span> <span class="o">/:</span> <span class="n">words</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res49</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot; the quick brown fox&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дає зайвий проміжок на початку. Щоб видалити цей проміжок ви можете використати невелику варіацію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">head</span> <span class="o">/:</span> <span class="n">words</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res50</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">the</span> <span class="n">quick</span> <span class="n">brown</span> <span class="n">fox</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>/:</code> продукує ліво-сторонні дерева операцій (його синтаксис з косою, що підіймається по ходу має бути відображенням цього). Оператор має <code>:\</code> як аналог, що продукує право-сторонні дерева. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">:\</span> <span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="n">op</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">op</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">op</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">z</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Або графічно:</p></div>
<div class="paragraph"><p>Оператор <code>:\</code> промовляється як праве згортання. Він включає ті самі три операнди що і ліве згортання, але перші два ідуть в зворотньому порядку: перший операнд є список для згортання, другий є початковим значенням.</p></div>
<div class="paragraph"><p>Для асоціативних операцій праве і ліве згортання еквівалентні, але може бути різниця в ефективності. Для приклада розгляньте операцію, відповідну до метода <code>flatten</code>, що конкатенує всі елементи в списку списків. Це може бути реалізоване за допомогою або лівого, або правого згортання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">flattenLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="o">/:</span> <span class="n">xss</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>

<span class="k">def</span> <span class="n">flattenRight</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Оскікльи конкатенація списку `xs 
</dt>
<dd>
<p>
ys` займає час, пропорційний до свого першого елемента <code>xs</code>, реалізація в термінах правого згортання в <code>flattenRight</code> більш ефективна, ніж реалізація лівого згортання в <code>flattenLeft</code>. Проблема в тому, що <code>flattenLeft(xss)</code> копіює перший елемент списку <code>xss.head</code> <code>n-1</code> разів, де <code>n</code> є довжина списку <code>xss</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Зауважте, що обоє версії <code>flatten</code> потребують анотацію типу на порожніх списках, що є початковим значенням згортання. Це через обмеженість виводу типів в Scala, що відмовляється виводити коректний тип списків автоматично. Якщо ви приберете анотацію, ви отримаєте наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">flattenRight</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
           <span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">8</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
           <span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
                              <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб з'ясувати, чому вивід типів не здолав ситуацію, вам треба знати щодо типів методів <code>fold</code>, та як вони реалізовані. Більше про це в Розділі 16.10. Нарешті, хоча оператори <code>/:</code> та <code>:\</code> мають перевагу в тому, що напрямок косої нагадує графічне зображення відповідних ліво- та право-сторонніх дерев, та асоциативність символа двокрапки покладає початкове значення в ту саму позицію в виразі, що і в дереві, дехто може винайти результуючий код недостатньо інтуітивним. Якщо вам подобається, ви можете використовувати замість цього методи <code>foldLeft</code> та <code>foldRight</code>, що також визначені в класі <code>List</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___code_list_code___code_fold_code">Приклад: реверс <code>List</code> з використанням <code>fold</code></h3>
<div class="paragraph"><p>Раніше в цій главі ви бачили реалізацію метода <code>reverse</code>, названу <code>rev</code>, чий час виконання був квадратичним відносно довжини списку, який він обертав. Ось інша реалізація реверсу, що має лінійну ціну. Ідея полягає в використанні лівого згортання, базуючись на наступній схемі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">reverseLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span> <span class="o">(</span><span class="n">startvalue</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)(</span><span class="n">operation</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що залишилось, це заповнити частини <em>startvalue</em> та <em>operation</em>. Фактично, ви можете спробувати вгадати ці частини з деяких простих прикладів. Щоб вивести коректне значення для <code>startvalue</code>, ви можете почати з найменьшим можливим списком, <code>List()</code>, та рахувати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">властивостями</span> <span class="n">reverseLeft</span><span class="o">)</span>

<span class="n">reverseLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">шаблоном</span> <span class="n">reverseLeft</span><span class="o">)</span>

<span class="o">(</span><span class="n">startvalue</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">())(</span><span class="n">operation</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">визначенням</span> <span class="o">/:)</span>

<span class="n">startvalue</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, <em>startvalue</em> має бути <code>List()</code>. Щоб вивести другий операнд, ви можете взяти наступний найменььший список як приклад. Ви вже знаєте, що_startvalue_ є List(), так що ви можете рахувати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">властивостями</span>  <span class="n">reverseLeft</span><span class="o">)</span>

<span class="n">reverseLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">шаблоном</span> <span class="n">reverseLeft</span><span class="o">,</span> <span class="n">з</span> <span class="n">startvalue</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span>

<span class="o">(</span><span class="nc">List</span><span class="o">()</span> <span class="o">/:</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="o">(</span><span class="n">operation</span><span class="o">)</span> <span class="nc">_equals_</span> <span class="o">(</span><span class="n">за</span> <span class="n">визначенням</span> <span class="o">/:)</span>

<span class="n">operation</span><span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Таким чином, <em>operation</em> <code>(List(), x)</code> еквівалентне <code>List(x)</code>, що також може бути записане як `x 
</dt>
<dd>
<p>
List()<code>. Це підказує взяти за операцію оператор `::</code> з переставленими операндами. (Ця операція іноді називається <code>snoc</code>, з посиланням на <code>::</code>, що називається <code>cons</code>.) Ми підходимо до наступної реалізації для <code>reverseLeft</code>:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">reverseLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{(</span><span class="n">ys</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>І знову, анотація типу в <code>List[T]()</code> є необхідною, щоб вивід типів почав робити. Якщо ви аналізуєте складність <code>reverseLeft</code>, ви винайдете, що він застосовує операцію сталого часу (<code>snoc</code>) <code>n</code> раз, де <code>n</code> є довжиною списка аргумента. Таким чином, складність <code>reverseLeft</code> є лінійною.</p></div>
</div>
<div class="sect2">
<h3 id="___code_sortwith_code">Сортування списків: <code>sortWith</code></h3>
<div class="paragraph"><p>Операція <code>xs sortWith before</code>, де <code>xs</code> є списком, а <code>before</code> функцією, що може використовуватись для порівняння двох елементів, сортує елементи списку <code>xs</code>. Вираз <code>x before y</code> повинен повертати <code>true</code>, якщо <code>x</code> повинен іти перед <code>y</code> в бажаному впорядкуванні. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res51</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">words</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="n">res52</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">quick</span><span class="o">,</span> <span class="n">brown</span><span class="o">,</span> <span class="n">the</span><span class="o">,</span> <span class="n">fox</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>sortWith</code> виконує сортування злиттям, подібне до алгоритму <code>msort</code>, показаному в останньому розділі. Але <code>sortWith</code> є методом класу <code>List</code>, тоді як <code>msort</code> визначений за межами списків.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_8____list">16.8 Методи об'єкта List</h2>
<div class="sectionbody">
<div class="paragraph"><p>Досі всі операції, що ви бачили в цій главі, реалізовані як методи класу <code>List</code>, так що ви викликаєте їх на окремих об'єктах списків. Також є декілька методів в глобально досяжному об'єкті <code>scala.List</code>, що є об'єктом компанйоном класу <code>List</code>. Деякі з ціх операцій є методами фабрик, що створюють списки. Інші є операціями, що роблять зі списками деякої специфічної форми. Обоє типи методів будуть представлені в цьому розділі.</p></div>
<div class="sect2">
<h3 id="______code_list_apply_code">Створення списків зі своїх елементів: <code>List.apply</code></h3>
<div class="paragraph"><p>Ви вже бачили при нагоді літерали списків, такі як <code>List(1, 2, 3)</code>. Немає нічого особливого щодо їх синтаксису. Літерал як <code>List(1, 2, 3)</code> є простим застосуванням об'єкта <code>List</code> до елементів <code>1, 2, 3</code>. Тобто, це еквівалентно до <code>List.apply(1, 2, 3)</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res53</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_list_range_code">Створення диапазона цілих: <code>List.range</code></h3>
<div class="paragraph"><p>Метод <code>range</code>, що ви мимохідь бачили раніше в дискусії про <code>map</code> та <code>flatmap</code>, створює список, що відповідає диапазону чисел. Його найпростіша форма є <code>List.range(from, until)</code>, що створює список з усіх чисел, що починається з <code>from</code>, та іде до <code>until</code> мінус один. Так що кінцеве значення, <code>until</code>, не формує частину диапазону.</p></div>
<div class="paragraph"><p>Також існує версія <code>range</code>, що приймає значення <code>step</code> як третій параметр. Ця операція буде давати списко елементів, що відстоять один від одного на відстані <code>step</code>. Значення <code>step</code> може бути додатнім або від'ємним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">res54</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">res55</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">)</span>
<span class="n">res56</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_list_fill_code">Створення уніформних списків: <code>List.fill</code></h3>
<div class="paragraph"><p>Метод <code>fill</code> створює список, що складається з нуля або більше копій того самого елемента. Він приймає два параметри: довжину створюваного списку, та елемент, що треба повторити. Кожний параметр наданий як окремий список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="sc">&#39;a&#39;</span><span class="o">)</span>
<span class="n">res57</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res58</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">hello</span><span class="o">,</span> <span class="n">hello</span><span class="o">,</span> <span class="n">hello</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо в <code>fill</code> надати більше ніж два аргументи, тоді він бути створювати багато-вимірні списки. Тобто він буде створювати списки списків, спискі списків списків, і так далі. Додаткові аргументи ідуть в першому списку аргументів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)(</span><span class="sc">&#39;b&#39;</span><span class="o">)</span>
<span class="n">res59</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___code_list_tabulate_code">Функція табуляції: <code>List.tabulate</code></h3>
<div class="paragraph"><p>Метод <code>tabulate</code> створює список, чиї елементи обчислені згідно наданої функції. Її аргументи такі самі, як для <code>List.fill</code>: перший аргумент `list`надає розмірність створюваного списку, та другий описує елементи списку. Єдина відміність в тому, що замість фіксованих елементів вони обчислюються функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">squares</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">tabulate</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span>
<span class="n">squares</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">16</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">multiplication</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">tabulate</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">5</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
<span class="n">multiplication</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">8</span><span class="o">),</span>
    <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">12</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">16</span><span class="o">))</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____code_list_concat_code">Конкатенація декількох списків: <code>List.concat</code></h3>
<div class="paragraph"><p>Метод <code>concat</code> конкатенує елементи декількох списків. Списки, що будуть конкатеновані, надаються як прямі аргументи до <code>concat</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="sc">&#39;b&#39;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;c&#39;</span><span class="o">))</span>
<span class="n">res60</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;b&#39;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="sc">&#39;c&#39;</span><span class="o">))</span>
<span class="n">res61</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">()</span>
<span class="n">res62</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_16_9____">16.9 Обробка декількох списків разом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Метод <code>zipped</code> на таплах узагальнює декілька загальних операцій для роботи з декількома списками замість одного. Одна така операція є <code>map</code>. Метод <code>map</code> для двох з'єднаних списків відображує пари елементів, скоріше ніж окремі елементи. Одна пара для перших елементів кожного списку, інша пара для другого елементу кожного списку, і так далі — так багато пар, що і довжина списків. Ось приклад його використання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res63</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">30</span><span class="o">,</span> <span class="mi">80</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що третій елемент другого списку відкидається. Метод <code>zipped</code> поєднує тільки стільки елементів, скільки з'являється в усіх списках одночасно. Любі додаткові елементи в кінці відкидаються.</p></div>
<div class="paragraph"><p>Існують також <code>zipped</code> аналоги для <code>exists</code> та <code>forall</code>. Вони подібні до версій з одним списком для ціх методів, за винятком, що вони оперують на елементах з декількох списків замість одного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">,</span> <span class="s">&quot;de&quot;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span>
        <span class="n">forall</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res64</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">,</span> <span class="s">&quot;de&quot;</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span>
        <span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res65</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Швидкий шлях</h2>
<div class="sectionbody">
<div class="paragraph"><p>В настуному (і заключному) розділі цієї глави ми зробимо огляд алгоритму виводу типів Scala. Якщо ви не зацікавлені в таких деталях прямо зараз, ви можете пропустити цілий розділ, та перейти прямо до підсумків.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_10_____scala">16.10 Розуміння алгоритма виводу типів Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна відмінність між попереднім використанням <code>sortWith</code> та <code>msort</code> стосується допустимих синтаксичних форм функції порівняння.</p></div>
<div class="paragraph"><p>Порівняйте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Char</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
<span class="n">res66</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>з:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">abcde</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res67</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Два виразу еквівалентні, але перший використовує довшу форму функції порівняння, з іменованими параметрами та явними типами. Другий використовує стислу форму, <code>(_ &gt; _)</code>, де іменовані параметри замінені на підкреслення. Звичайно, ви також можете використовувати першу, довшу форму порівняння в <code>sortWith</code>.</p></div>
<div class="paragraph"><p>Однак коротша форма не може бути використана з <code>msort</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">missing</span> <span class="kt">parameter</span> <span class="k">type</span> <span class="kt">for</span> <span class="kt">expanded</span>
<span class="n">function</span> <span class="o">((</span><span class="n">x$1</span><span class="o">,</span> <span class="n">x$2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x$1</span><span class="o">.</span><span class="nc">$greater</span><span class="o">(</span><span class="n">x$2</span><span class="o">))</span>
      <span class="n">msort</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
            <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб зрозуміти чому, вам треба знати деякі деталі алгоритму виводу типів в Scala. Виведення типів в Scala базується на потоці. В застосуванні методу <code>m(args)</code>, вивід типів спершу перевіряє, чи метод <code>m</code> має відомий тип. Якщо це так, цей тип використовується для виведення очікуваних типів аргументів. Наприклад, в <code>abcde.sortWith(_ &gt; _)</code>, тип <code>abcde</code> є <code>List[Char]</code>. Таким чином,  <code>sortWith</code> відомий як метод, що приймає аргумент типу <code>(Char, Char) =&gt; Boolean</code>, та продукує результат типу <code>List[Char]</code>. Оскільки параметри типу аргументів функції відомі, їх не треба записувати явно. Маючи те, що відомо про <code>sortWith</code>, вивід може здогадатись, що <code>(_ &gt; _)</code> має розширюватись до <code>((x: Char, y: Char) =&gt; x &gt; y)</code>, що <code>x</code> та <code>y</code> є деякими довільними новими іменами.</p></div>
<div class="paragraph"><p>Тепер розглянемо другий випадок, <code>msort(_ &gt; _)(abcde)</code>. Тип <code>msort</code> є карований, поліморфний тип методу, що приймає аргумент типу <code>(T, T) =&gt; Boolean</code> до функції від <code>List[T]</code> до <code>List[T]</code>, де <code>T</code> є досі невідомий тип. Метод <code>msort</code> потребує бути створений з параметром типу, перед тим як він може бути застосований до його аргументів.</p></div>
<div class="paragraph"><p>Оскільки точний тип примірника <code>msort</code> в застосуванні досі не відома, він не може бути використаний для виведення типу його першого аргументу. Вивід типу змінює свою стратегію в цьому випадку; він спочатку перевіряє аргументи методу, щоб визначити відповідний тип примірника метода. Однак, коли він отримує завдання перевірити тип скороченого функціонального літерала, <code>(_ &gt; _)</code>, він схибить, бо він не має інформації щодо типів неявних функціональних параметрів, що вказані як підкреслення.</p></div>
<div class="paragraph"><p>Один спосіб розв'язати проблему є передати явний параметр типу до <code>msort</code>, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msort</span><span class="o">[</span><span class="kt">Char</span><span class="o">](</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)(</span><span class="n">abcde</span><span class="o">)</span>
<span class="n">res68</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскікльи коректний тип примірника <code>msort</code> тепер відомий, він може бути використаний для вивідення типу аргументів. Інше можливе рішення є переписати метод <code>msort</code>, так що його параметри були переставлені місцями:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">msortSwapped</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">less</span><span class="k">:</span>
    <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
<span class="c1">// така сама реалізація, що і msort,</span>
<span class="c1">// але з переставленими аргументами</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер вивід типу буде успішний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">msortSwapped</span><span class="o">(</span><span class="n">abcde</span><span class="o">)(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res69</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут трапилось, це те, що вивід використав відомий тип першого параметра, <code>abcde</code>, для визначення параметру типа <code>msortSwapped</code>. Як тільки точний тип <code>msortSwapped</code> став відомий, він, в свою чергу, може бути використаний для виведення типу другого параметру, <code>(_ &gt; _)</code>.</p></div>
<div class="paragraph"><p>Загалом, коли завданням є вивід параметру типу для поліморфного методу, вивід типу консультується з типами всіх значень аргументів в першому списку параметрів, але не з аргументами за його межами. Оскільки <code>msortSwapped</code> є карований метод з двома списками параметрів, не має потреби перевіряти другий аргумент (тобто, функціональне значення) для визначення параметру типа метода.</p></div>
<div class="paragraph"><p>Ця схема виведення підказує наступний принцип розробки бібліотеки: коли розробляється поліморфний метод, що приймає не-функціональні аргументи, та функціональний аргумент, поставьте функціональний аргумент останнім окремо, у власному карованому списку аргументів. В такий спосіб, коректний тип примірника метода може бути виведений з не-функціональних аргументів, і цей тип може, в свою чергу, бути використаний для перевірки типу функціонального аргументу. Загальний ефект в тому, що користувачі метода будуть в змозі надавати менше інформації типу, та писати літерали в більш компактний спосіб.</p></div>
<div class="paragraph"><p>Тепер перейдемо до більш складного випадку операції <code>fold</code>. Чому треба задавати явний параметр типу в такому виразі, як тіло метода <code>flattenRight</code>, показаного нижче?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип операції правого згортання поліморфний по двох змінних. Візьмемо вираз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">xs</span> <span class="o">:~</span><span class="n">z</span><span class="o">)</span> <span class="o">(</span><span class="n">op</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>xs</code> має бути списком деякого довільного типу <code>A</code>, скажімо,  <code>xs: List[A]</code>. Початкове значення <code>z</code> може бути деякого іншого типу <code>B</code>. Операція <code>op</code> після цього приймає два аргументи типів <code>A</code> та <code>B</code>, та повертає результат типу <code>B</code>, тобто, <code>op: (A, B) =&gt; B</code>. Оскільки тип <code>z</code> не пов'язаний до типу списка <code>xs</code>, вивід типу не має контекстної інформації для <code>z</code>.</p></div>
<div class="paragraph"><p>Тепер розглянемо вираз в помилковій версії <code>flattenRight</code>, також показаній тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="n">xss</span> <span class="o">:~</span><span class="nc">List</span><span class="o">())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span> <span class="c1">// це не буде компілюватись</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Початкове значення <code>z</code> в цьому <code>fold</code> є порожнім списком, <code>List()</code>, так що без додаткової інформації про тип, його тип виводиться як  <code>List[Nothing]</code>. Таким чином, вивід буде виводити, що тип <code>B</code> в <code>fold</code> є <code>List[Nothing]</code>. Таким чином, операція `(_ 
</dt>
<dd>
<p>
_)` у <code>fold</code>, як очікується, має бути такого типу:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це, очевидно, є можливим типом для операції, такої як <code>fold</code>, але це не дуже корисний тип! Він каже, що операція завжди приймає порожній список в якості другого аргументу, та завжди продукує порожній список як результат.</p></div>
<div class="paragraph"><p>Іншими словами, вивід типів стабілізується дуже рано для типу <code>List()</code>; він мав би дочекатись, доки він не побачить тип операції <code>op</code>. Так що (інакше дуже корисне) правило брати до уваги тільки перший розділ аргументів в застосуванні карованого метода для визначення типу метода, тут є коренем проблеми. З іншого боку, якщо це правило пом'якшити, вивід все ще не зможе надати тип для <code>op</code>, оскільки типи його параметрів не надані. Таким чином, це ситуація Catch-22, що може бути розрішена тільки через явну анотацію типу з боку програміста.</p></div>
<div class="paragraph"><p>Цей приклад підкреслює деякі обмеження локальної, базованої на потоці, схеми виводу типів в Scala. Вона не присутня в більш глобальному стилі виводу типів Hindley-Milner, що використовується в функціональних мовах, як ML або Haskell. Однак локальний вивід типів Scala значно краще поводиться з об'єктно-орієнтовними субтипами, ніж стиль Hindley-Milner. На щастя, обмеження виявляють себе тільки в граничних випадках, та звичайно просто лагодяться додаванням явних анотацій типів.</p></div>
<div class="paragraph"><p>Додавання анотацій типу також є корисною технікою зневадження, коли ви здивовані повідомленнями помилок типів, пов'язаних з поліморфними методами. Якщо ви невпевнені, що спричинило певну помилку типу, просто додайте аргументи типу або інші анотації типів, яка за вашою думкою коректна. Після цього ви будете в змозі швидко подивитись, в чому полягала реальна проблема.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_16_11_">16.11 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер ви бачили багато шляхів роботи зі списками. Ви бачили базові операції, як <code>head</code> та <code>tail</code>, операції першого порядку, як <code>reverse</code>, операції вищого порядку, як <code>map</code>, та допоміжні методи в об'єкті <code>List</code>. По мірі цього ви трохи вивчили щодо того, як робить вивід типів Scala.</p></div>
<div class="paragraph"><p>Списки є реальною робочою конячкою в Scala, так що ви отримаєте перевагу, якщо будете знати, як використовувати її. З цієї причини ця глава глибоко занурюється в те, як використовувати списки. Однак списки є тільки одним різновидом колекцій, що підтримує Scala. наступна глава є широкою, скоріше ніж глибокою, та показує вам, як використовувати різноманітні типи колекцій в Scala.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-27 00:59:53 EET
</div>
</div>
</body>
</html>
