<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__16">Глава 16</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Робота зі списками</h1>
<div class="paragraph"><p>Lists are probably the most commonly used data structure in Scala programs. This chapter explains lists
in detail. We will present many common operations that can be performed on lists. We&#8217;ll also cover
some important design principles for programs working on lists.
16.1 LIST LITERALS
You saw lists already in the preceding chapters, so you know that a list containing the elements <em>a</em>, <em>b</em>,
and <em>c</em> is written List(<em>a</em>, <em>b</em>, <em>c</em>). Here are some other examples:
val fruit = List("apples", "oranges", "pears")
val nums = List(1, 2, 3, 4)
val diag3 =
List(
List(1, 0, 0),
List(0, 1, 0),
List(0, 0, 1)
)
val empty = List()
Lists are quite similar to arrays, but there are two important differences. First, lists are immutable. That
is, elements of a list cannot be changed by assignment. Second, lists have a recursive structure (i.e.,
a linked list),<span class="footnote"><br />[For a graphical depiction of the structure of a List, see Figure 22.2 here.]<br /></span> whereas arrays are flat.
16.2 THE LIST TYPE
Like arrays, lists are homogeneous: the elements of a list all have the same type. The type of a list that
has elements of type T is written List[T]. For instance, here are the same four lists with explicit types
added:
val fruit: List[String] = List("apples", "oranges", "pears")
val nums: List[Int] = List(1, 2, 3, 4)
val diag3: List[List[Int]] =
List(
List(1, 0, 0),
List(0, 1, 0),
List(0, 0, 1)
)
val empty: List[Nothing] = List()
The list type in Scala is covariant. This means that for each pair of types S and T, if S is a subtype of T,
then List[S] is a subtype of List[T]. For instance, List[String] is a subtype ofList[Object]. This is
natural because every list of strings can also be seen as a list of objects.<span class="footnote"><br />[Chapter 19 gives more details on covariance and other kinds of variance.]<br /></span>
Note that the empty list has type List[Nothing]. You saw in Section 11.3 that Nothing is the bottom
type in Scala&#8217;s class hierarchy. It is a subtype of every other Scala type. Because lists are covariant, it
follows that List[Nothing] is a subtype of List[T] for any type T. So the empty list object, which hastype List[Nothing], can also be seen as an object of every other list type of the form List[T]. That&#8217;s why
it is permissible to write code like:

val xs: List[String] = List()
16.3 CONSTRUCTING LISTS
All lists are built from two fundamental building blocks, Nil and :: (pronounced "cons"). Nilrepresents
the empty list. The infix operator, ::, expresses list extension at the front. That is,x :: xs represents a list
whose first element is x, followed by (the elements of) list xs. Hence, the previous list values could also
have been defined as follows:
val fruit = "apples" :: ("oranges" :: ("pears" :: Nil))
val nums = 1 :: (2 :: (3 :: (4 :: Nil)))
val diag3 = (1 :: (0 :: (0 :: Nil))) ::
(0 :: (1 :: (0 :: Nil))) ::
(0 :: (0 :: (1 :: Nil))) :: Nil
val empty = Nil
In fact the previous definitions of fruit, nums, diag3, and empty in terms of List(&#8230;) are just wrappers
that expand to these definitions. For instance, List(1, 2, 3) creates the list1 :: (2 :: (3 :: Nil)).
Because it ends in a colon, the :: operation associates to the right: A :: B :: C is interpreted
asA :: (B :: C). Therefore, you can drop the parentheses in the previous definitions. For instance:
val nums = 1 :: 2 :: 3 :: 4 :: Nil
is equivalent to the previous definition of nums.
16.4 BASIC OPERATIONS ON LISTS
All operations on lists can be expressed in terms of the following three:
head
returns the first element of a list
tail
returns a list consisting of all elements except the first
isEmpty returns true if the list is empty
These operations are defined as methods of class List. Some examples are shown in Table 16.1.
The head and tail methods are defined only for non-empty lists. When selected from an empty list, they
throw an exception:
scala&gt; Nil.head
java.util.NoSuchElementException: head of empty list
As an example of how lists can be processed, consider sorting the elements of a list of numbers into
ascending order. One simple way to do so is insertion sort, which works as follows: To sort a non-
empty list x :: xs, sort the remainder xs and insert the first element x at the right position in the result.
Sorting an empty list yields the empty list. Expressed as Scala code, the insertion sort algorithm looks
like:def isort(xs: List[Int]): List[Int] =
if (xs.isEmpty) Nil
else insert(xs.head, isort(xs.tail))
def insert(x: Int, xs: List[Int]): List[Int] =
if (xs.isEmpty || x &#8656; xs.head) x :: xs
else xs.head :: insert(x, xs.tail)
Table 16.1 - Basic list operations
What it is
empty.isEmpty
fruit.isEmpty
fruit.head
fruit.tail.head
diag3.head
What it does
returns true
returns false
returns "apples"
returns "oranges"
returns List(1, 0, 0)
16.5 LIST PATTERNS
Lists can also be taken apart using pattern matching. List patterns correspond one-by-one to list
expressions. You can either match on all elements of a list using a pattern of the formList(&#8230;), or you
take lists apart bit by bit using patterns composed from the :: operator and the Nil constant.
Here&#8217;s an example of the first kind of pattern:
scala&gt; val List(a, b, c) = fruit
a: String = apples
b: String = oranges
c: String = pears
The pattern List(a, b, c) matches lists of length 3, and binds the three elements to the pattern
variables a, b, and c. If you don&#8217;t know the number of list elements beforehand, it&#8217;s better to match
with :: instead. For instance, the pattern a :: b :: rest matches lists of length 2 or greater:
ABOUT PATTERN MATCHING ON LISTS
If you review the possible forms of patterns explained in Chapter 15, you might find that
neither List(&#8230;) nor :: look like it fits the kinds of patterns defined there. In fact,List(&#8230;) is an instance of
a library-defined extractor pattern. Such patterns will be discussed in Chapter 26. The "cons"
pattern x :: xs is a special case of an infix operation pattern. As an expression, an infix operation is
equivalent to a method call. For patterns, the rules are different: As a pattern, an infix operation such
as p op q is equivalent to op(p, q). That is, the infix operator op is treated as a constructor pattern. In
particular, a cons pattern such as x :: xs is treated as ::(x, xs).
This hints that there should be a class named :: that corresponds to the pattern constructor. Indeed, there
is such a class—it is named scala.:: and is exactly the class that builds non-empty lists. So :: exists
twice in Scala, once as a name of a class in package scala and again as a method in class List. The
effect of the method :: is to produce an instance of the class scala.::. You&#8217;ll find out more details about
how the List class is implemented in Chapter 22.scala&gt; val a :: b :: rest = fruit
a: String = apples
b: String = oranges
rest: List[String] = List(pears)
Taking lists apart with patterns is an alternative to taking them apart with the basic methodshead, tail,
and isEmpty. For instance, here&#8217;s insertion sort again, this time written with pattern matching:
def isort(xs: List[Int]): List[Int] = xs match {
case List()
&#8658; List()
case x :: xs1 &#8658; insert(x, isort(xs1))
}
def insert(x: Int, xs: List[Int]): List[Int] = xs match {
case List() &#8658; List(x)
case y :: ys &#8658; if (x &#8656; y) x :: xs
else y :: insert(x, ys)
}
Often, pattern matching over lists is clearer than decomposing them with methods, so pattern matching
should be a part of your list processing toolbox.
This is all you need to know about lists in Scala to use them correctly. However, there are also a large
number of methods that capture common patterns of operations over lists. These methods make list
processing programs more concise and often clearer. The next two sections present the most important
methods defined in the List class.
16.6 FIRST-ORDER METHODS ON CLASS LIST
This section explains most first-order methods defined in the List class. A method is first-order if it
does not take any functions as arguments. We will also introduce some recommended techniques to
structure programs that operate on lists by using two examples.
Concatenating two lists
An operation similar to :: is list concatenation, written &#8216;:::&#8217;. Unlike ::, ::: takes two lists as operands. The
result of xs ::: ys is a new list that contains all the elements of xs, followed by all the elements of ys.
Here are some examples:
scala&gt; List(1, 2) ::: List(3, 4, 5)
res0: List[Int] = List(1, 2, 3, 4, 5)
scala&gt; List() ::: List(1, 2, 3)
res1: List[Int] = List(1, 2, 3)
scala&gt; List(1, 2, 3) ::: List(4)
res2: List[Int] = List(1, 2, 3, 4)
Like cons, list concatenation associates to the right. An expression like this:
xs ::: ys ::: zsis interpreted like this:
xs ::: (ys ::: zs)
The Divide and Conquer principle
Concatenation (:::) is implemented as a method in class List. It would also be possible to implement
concatenation "by hand," using pattern matching on lists. It&#8217;s instructive to try to do that yourself,
because it shows a common way to implement algorithms using lists. First, we&#8217;ll settle on a signature
for the concatenation method, which we&#8217;ll call append. In order not to mix things up too much, assume
that append is defined outside the List class, so it will take the two lists to be concatenated as
parameters. These two lists must agree on their element type, but that element type can be arbitrary.
This can be expressed by giving append a type parameter,<span class="footnote"><br />[Type parameters will be explained in more detail in Chapter 19.]<br /></span> that represents the element type of the two
input lists:
def append[T](xs: List[T], ys: List[T]): List[T]
To design the implementation of append, it pays to remember the "divide and conquer" design principle
for programs over recursive data structures such as lists. Many algorithms over lists first split an input
list into simpler cases using a pattern match. That&#8217;s the divide part of the principle. They then construct
a result for each case. If the result is a non-empty list, some of its parts may be constructed by recursive
invocations of the same algorithm. That&#8217;s theconquer part of the principle.
To apply this principle to the implementation of the append method, the first question to ask is on
which list to match. This is less trivial in the case of append than for many other methods because there
are two choices. However, the subsequent "conquer" phase tells you that you need to construct a list
consisting of all elements of both input lists. Since lists are constructed from the back towards the
front, ys can remain intact, whereas xs will need to be taken apart and prepended to ys. Thus, it makes
sense to concentrate on xs as a source for a pattern match. The most common pattern match over lists
simply distinguishes an empty from a non-empty list. So this gives the following outline of
an append method:
def append[T](xs: List[T], ys: List[T]): List[T] =
xs match {
case List() &#8658; ???
case x :: xs1 &#8658; ???
}
All that remains is to fill in the two places marked with ???.<span class="footnote"><br />[The ??? method, which throws scala.NotImplementedError and has result type Nothing, can be used as a temporary implementation during development.]<br /></span> The first such place is the alternative
where the input list xs is empty. In this case concatenation yields the second list:
case List() &#8658; ys
The second place left open is the alternative where the input list xs consists of some head xfollowed by
a tail xs1. In this case the result is also a non-empty list. To construct a non-empty list you need to
know what the head and the tail of that list should be. You know that the first element of the result listis x. As for the remaining elements, these can be computed by appending the second list, ys, to the rest
of the first list, xs1.
This completes the design and gives:
def append[T](xs: List[T], ys: List[T]): List[T] =
xs match {
case List() &#8658; ys
case x :: xs1 &#8658; x :: append(xs1, ys)
}
The computation of the second alternative illustrated the "conquer" part of the divide and conquer
principle: Think first what the shape of the desired output should be, then compute the individual parts
of that shape, using recursive invocations of the algorithm where appropriate. Finally, construct the
output from these parts.
Taking the length of a list: length
The length method computes the length of a list.
scala&gt; List(1, 2, 3).length
res3: Int = 3
On lists, unlike arrays, length is a relatively expensive operation. It needs to traverse the whole list to
find its end, and therefore takes time proportional to the number of elements in the list. That&#8217;s why it&#8217;s
not a good idea to replace a test such as xs.isEmpty by xs.length == 0. The result of the two tests is
equivalent, but the second one is slower, in particular if the list xs is long.
Accessing the end of a list: init and last
You know already the basic operations head and tail, which respectively take the first element of a list,
and the rest of the list except the first element. They each have a dual operation: lastreturns the last
element of a (non-empty) list, whereas init returns a list consisting of all elements except the last one:
scala&gt; val abcde = List(<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>)
abcde: List[Char] = List(a, b, c, d, e)
scala&gt; abcde.last
res4: Char = e
scala&gt; abcde.init
res5: List[Char] = List(a, b, c, d)
Like head and tail, these methods throw an exception when applied to an empty list:
scala&gt; List().init
java.lang.UnsupportedOperationException: Nil.init
at scala.List.init(List.scala:544)
at &#8230;
scala&gt; List().last
java.util.NoSuchElementException: Nil.last
at scala.List.last(List.scala:563)at &#8230;
Unlike head and tail, which both run in constant time, init and last need to traverse the whole list to
compute their result. As a result, they take time proportional to the length of the list.
It&#8217;s a good idea to organize your data so that most accesses are at the head of a list, rather than the last
element.
Reversing lists: reverse
If at some point in the computation an algorithm demands frequent accesses to the end of a list, it&#8217;s
sometimes better to reverse the list first and work with the result instead. Here&#8217;s how to do the reversal:
scala&gt; abcde.reverse
res6: List[Char] = List(e, d, c, b, a)
Like all other list operations, reverse creates a new list rather than changing the one it operates on.
Since lists are immutable, such a change would not be possible anyway. To verify this, check that the
original value of abcde is unchanged after the reverse operation:
scala&gt; abcde
res7: List[Char] = List(a, b, c, d, e)
The reverse, init, and last operations satisfy some laws that can be used for reasoning about
computations and for simplifying programs.
1. reverse is its own inverse:
xs.reverse.reverse
equals
xs
2. reverse turns init to tail and last to head, except that the elements are reversed:
xs.reverse.init
xs.reverse.tail
xs.reverse.head
xs.reverse.last
equals
equals
equals
equals
xs.tail.reverse
xs.init.reverse
xs.last
xs.head
Reverse could be implemented using concatenation (:::), like in the following method, rev:
def rev[T](xs: List[T]): List[T] = xs match {
case List() &#8658; xs
case x :: xs1 &#8658; rev(xs1) ::: List(x)
}
However, this method is less efficient than one would hope for. To study the complexity ofrev, assume
that the list xs has length n. Notice that there are n recursive calls to rev. Each call except the last
involves a list concatenation. List concatenation xs ::: ys takes time proportional to the length of its first
argument xs. Hence, the total complexity of rev is:
n + (n - 1) + &#8230; + 1 = (1 + n) * n / 2In other words, rev&#8217;s complexity is quadratic in the length of its input argument. This is disappointing
when compared to the standard reversal of a mutable, linked list, which has linear complexity.
However, the current implementation of rev is not the best implementation possible. In the example
starting here, you will see how to speed it up.
Prefixes and suffixes: drop, take, and splitAt
The drop and take operations generalize tail and init in that they return arbitrary prefixes or suffixes of
a list. The expression "xs take n" returns the first n elements of the list xs. If n is greater than xs.length,
the whole list xs is returned. The operation "xs drop n" returns all elements of the list xs, except for the
first n ones. If n is greater than xs.length, the empty list is returned.
The splitAt operation splits the list at a given index, returning a pair of two lists.<span class="footnote"><br />[As mentioned in Section 10.12, the term pair is an informal name for Tuple2.]<br /></span> It is defined by the
equality:
xs splitAt n
equals
(xs take n, xs drop n)
However, splitAt avoids traversing the list xs twice. Here are some examples of these three methods:
scala&gt; abcde take 2
res8: List[Char] = List(a, b)
scala&gt; abcde drop 2
res9: List[Char] = List(c, d, e)
scala&gt; abcde splitAt 2
res10: (List[Char], List[Char]) = (List(a, b),List(c, d, e))
Element selection: apply and indices
Random element selection is supported through the apply method; however it is a less common
operation for lists than it is for arrays.
scala&gt; abcde apply 2 // rare in Scala
res11: Char = c
As for all other types, apply is implicitly inserted when an object appears in the function position in a
method call. So the line above can be shortened to:
scala&gt; abcde(2)
res12: Char = c

One reason why random element selection is less popular for lists than for arrays is that xs(n)takes time
proportional to the index n. In fact, apply is simply defined by a combination of dropand head:
xs apply n
equals
(xs drop n).head
This definition also makes clear that list indices range from 0 up to the length of the list minus one, the
same as for arrays. The indices method returns a list consisting of all valid indices of a given list:
scala&gt; abcde.indices
res13: scala.collection.immutable.Range= Range(0, 1, 2, 3, 4)
Flattening a list of lists: flatten
The flatten method takes a list of lists and flattens it out to a single list:
scala&gt; List(List(1, 2), List(3), List(), List(4, 5)).flatten
res14: List[Int] = List(1, 2, 3, 4, 5)
scala&gt; fruit.map(<em>.toCharArray).flatten
res15: List[Char] = List(a, p, p, l, e, s, o, r, a, n, g, e,
s, p, e, a, r, s)
It can only be applied to lists whose elements are all lists. Trying to flatten any other list will give a
compilation error:
scala&gt; List(1, 2, 3).flatten
&lt;console&gt;:8: error: No implicit view available from Int &#8658;
scala.collection.GenTraversableOnce[B].
List(1, 2, 3).flatten
<sup>
Zipping lists: zip and unzip
The zip operation takes two lists and forms a list of pairs:
scala&gt; abcde.indices zip abcde
res17: scala.collection.immutable.IndexedSeq[(Int, Char)] =
Vector0
If the two lists are of different length, any unmatched elements are dropped:
scala&gt; val zipped = abcde zip List(1, 2, 3)
zipped: List[(Char, Int)] = Lista
A useful special case is to zip a list with its index. This is done most efficiently with
thezipWithIndex method, which pairs every element of a list with the position where it appears in the
list.
scala&gt; abcde.zipWithIndex
res18: List[(Char, Int)] = List((a,0), (b,1), (c,2), (d,3),
(e,4))
Any list of tuples can also be changed back to a tuple of lists by using the unzip method:
scala&gt; zipped.unzip
res19: (List[Char], List[Int])
= (List(a, b, c),List(1, 2, 3))
The zip and unzip methods provide one way to operate on multiple lists together. See Section 16.9 for a
more concise way to do this.
Displaying lists: toString and mkString
The toString operation returns the canonical string representation of a list:scala&gt; abcde.toString
res20: String = List(a, b, c, d, e)
If you want a different representation you can use the mkString method. The
operationxs mkString (pre, sep, post) involves four operands: the list xs to be displayed, a prefix
string preto be displayed in front of all elements, a separator string sep to be displayed between
successive elements, and a postfix string post to be displayed at the end.
The result of the operation is the string:
pre + xs(0) + sep + &#8230;+ sep + xs(xs.length - 1) + post
The mkString method has two overloaded variants that let you drop some or all of its arguments. The
first variant only takes a separator string:
xs mkString sep
equals
xs mkString ("", sep, "")
The second variant lets you omit all arguments:
xs.mkString
equals
xs mkString ""
Here are some examples:
scala&gt; abcde mkString ("[", ",", "]")
res21: String = [a,b,c,d,e]
scala&gt; abcde mkString ""
res22: String = abcde
scala&gt; abcde.mkString
res23: String = abcde
scala&gt; abcde mkString ("List(", ", ", ")")
res24: String = List(a, b, c, d, e)
There are also variants of the mkString methods called addString which append the constructed string
to a StringBuilder object,<span class="footnote"><br />[This is class scala.StringBuilder, not java.lang.StringBuilder.]<br /></span> rather than returning them as a result:
scala&gt; val buf = new StringBuilder
buf: StringBuilder =
scala&gt; abcde addString (buf, "(", ";", ")")
res25: StringBuilder = (a;b;c;d;e)
The mkString and addString methods are inherited from List&#8217;s super trait Traversable, so they are
applicable to all other collections as well.
Converting lists: iterator, toArray, copyToArray
To convert data between the flat world of arrays and the recursive world of lists, you can use
method toArray in class List and toList in class Array:
scala&gt; val arr = abcde.toArray
arr: Array[Char] = Array(a, b, c, d, e)scala&gt; arr.toList
res26: List[Char] = List(a, b, c, d, e)
There&#8217;s also a method copyToArray, which copies list elements to successive array positions within
some destination array. The operation:
xs copyToArray (arr, start)
copies all elements of the list xs to the array arr, beginning with position start. You must ensure that the
destination array arr is large enough to hold the list in full. Here&#8217;s an example:
scala&gt; val arr2 = new Array[Int](10)
arr2: Array[Int] = Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
scala&gt; List(1, 2, 3) copyToArray (arr2, 3)
scala&gt; arr2
res28: Array[Int] = Array(0, 0, 0, 1, 2, 3, 0, 0, 0, 0)
Finally, if you need to access list elements via an iterator, you can use the iterator method:
scala&gt; val it = abcde.iterator
it: Iterator[Char] = non-empty iterator
scala&gt; it.next
res29: Char = a
scala&gt; it.next
res30: Char = b
Example: Merge sort
The insertion sort presented earlier is concise to write, but it is not very efficient. Its average
complexity is proportional to the square of the length of the input list. A more efficient algorithm
is merge sort.
THE FAST TRACK
This example provides another illustration of the divide and conquer principle and currying, as well as
a useful discussion of algorithmic complexity. If you prefer to move a bit faster on your first pass
through this book, however, you can safely skip to Section 16.7.
Merge sort works as follows: First, if the list has zero or one elements, it is already sorted, so the list
can be returned unchanged. Longer lists are split into two sub-lists, each containing about half the
elements of the original list. Each sub-list is sorted by a recursive call to the sort function, and the
resulting two sorted lists are then combined in a merge operation.
For a general implementation of merge sort, you want to leave open the type of list elements to be
sorted and the function to be used for the comparison of elements. You obtain a function of maximalgenerality by passing these two items as parameters. This leads to the implementation shown in Listing
16.1.
def msort[T](less: (T, T) &#8658; Boolean)
(xs: List[T]): List[T] = {
def merge(xs: List[T], ys: List[T]): List[T] =
(xs, ys) match {
case (Nil, _) &#8658; ys
case (</em>, Nil) &#8658; xs
case (x :: xs1, y :: ys1) &#8658;
if (less(x, y)) x :: merge(xs1, ys)
else y :: merge(xs, ys1)
}
val n = xs.length / 2
if (n == 0) xs
else {
val (ys, zs) = xs splitAt n
merge(msort(less)(ys), msort(less)(zs))
}
}
Listing 16.1 - A merge sort function for Lists.
The complexity of msort is order (n log(n)), where n is the length of the input list. To see why, note that
splitting a list in two and merging two sorted lists each take time proportional to the length of the
argument list(s). Each recursive call of msort halves the number of elements in its input, so there are
about log(n) consecutive recursive calls until the base case of lists of length 1 is reached. However, for
longer lists each call spawns off two further calls. Adding everything up, we obtain at each of the log(n)
call levels, every element of the original lists takes part in one split operation and one merge operation.
Hence, every call level has a total cost proportional to n. Since there are log(n) call levels, we obtain an
overall cost proportional to n log(n). That cost does not depend on the initial distribution of elements in
the list, so the worst case cost is the same as the average case cost. This property makes merge sort an
attractive algorithm for sorting lists.
Here is an example of how msort is used:
scala&gt; msortx: Int
res31: List[Int] = List(1, 3, 5, 7)
The msort function is a classical example of the currying concept discussed in Section 9.3.
Currying makes it easy to specialize the function for particular comparison functions. Here&#8217;s an
example:
scala&gt; val intSort = msort((x: Int, y: Int) &#8658; x &lt; y) _
intSort: List[Int] &#8658; List[Int] = &lt;function1&gt;
The intSort variable refers to a function that takes a list of integers and sorts them in numerical
order. As described in Section 8.6, an underscore stands for a missing argument list. In this case, themissing argument is the list that should be sorted. As another example, here&#8217;s how you could define a
function that sorts a list of integers in reverse numerical order:
scala&gt; val reverseIntSort = msort((x: Int, y: Int) &#8658; x &gt; y) _
reverseIntSort: (List[Int]) &#8658; List[Int] = &lt;function&gt;
Because you provided the comparison function already via currying, you now need only provide the list
to sort when you invoke the intSort or reverseIntSort functions. Here are some examples:
scala&gt; val mixedInts = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
mixedInts: List[Int] = List(4, 1, 9, 0, 5, 8, 3, 6, 2, 7)
scala&gt; intSort(mixedInts)
res0: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
scala&gt; reverseIntSort(mixedInts)
res1: List[Int] = List(9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
16.7 HIGHER-ORDER METHODS ON CLASS LIST
Many operations over lists have a similar structure. Several patterns appear time and time again. Some
examples are: transforming every element of a list in some way, verifying whether a property holds for
all elements of a list, extracting from a list elements satisfying a certain criterion, or combining the
elements of a list using some operator. In Java, such patterns would usually be expressed by idiomatic
combinations of for or while loops. In Scala, they can be expressed more concisely and directly using
higher-order operators,<span class="footnote"><br />[By higher-order operators, we mean higher-order functions used in operator notation. As mentioned in Section 9.1, a function is "higher-order" if it takes one or more other functions as a parameters.]<br /></span> which are implemented as methods in class List. These higher-order
operators are discussed in this section.
Mapping over lists: map, flatMap and foreach
The operation xs map f takes as operands a list xs of type List[T] and a function f of type T &#8658; U. It
returns the list that results from applying the function f to each list element in xs. For instance:
scala&gt; List(1, 2, 3) map (_ + 1)
res32: List[Int] = List(2, 3, 4)
scala&gt; val words = List("the", "quick", "brown", "fox")
words: List[String] = List(the, quick, brown, fox)
scala&gt; words map (<em>.length)
res33: List[Int] = List(3, 5, 5, 3)
scala&gt; words map (</em>.toList.reverse.mkString)
res34: List[String] = List(eht, kciuq, nworb, xof)
The flatMap operator is similar to map, but it takes a function returning a list of elements as its right
operand. It applies the function to each list element and returns the concatenation of all function results.
The difference between map and flatMap is illustrated in the following example:
scala&gt; words map (<em>.toList)
res35: List[List[Char]] = List(List(t, h, e), List(q, u, i,
c, k), List(b, r, o, w, n), List(f, o, x))scala&gt; words flatMap (</em>.toList)
res36: List[Char] = List(t, h, e, q, u, i, c, k, b, r, o, w,
n, f, o, x)
You see that where map returns a list of lists, flatMap returns a single list in which all element lists are
concatenated.
The differences and interplay between map and flatMap are also demonstrated by the following
expression, which constructs a list of all pairs (i, j) such that 1 ≤ j &lt; i &lt; 5:
scala&gt; List.range(1, 5) flatMap (
i &#8658; List.range(1, i) map (j &#8658; (i, j))
)
res37: List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1),
(4,2), (4,3))
List.range is a utility method that creates a list of all integers in some range. It is used twice in this
example: once to generate a list of integers from 1 (including) until 5 (excluding), and a second time to
generate a list of integers from 1 until i, for each value of i taken from the first list. The map in this
expression generates a list of tuples (i, j) where j &lt; i. The outer flatMap in this example generates this
list for each i between 1 and 5, and then concatenates all the results. Alternatively, the same list can be
constructed with a for expression:
for (i &#8592; List.range(1, 5); j &#8592; List.range(1, i)) yield (i, j)
You&#8217;ll learn more about the interplay of for expressions and list operations in Chapter 23.
The third map-like operation is foreach. Unlike map and flatMap, however, foreach takes a procedure
(a function with result type Unit) as right operand. It simply applies the procedure to each list element.
The result of the operation itself is again Unit; no list of results is assembled. As an example, here is a
concise way of summing up all numbers in a list:
scala&gt; var sum = 0
sum: Int = 0
scala&gt; List(1, 2, 3, 4, 5) foreach (sum += <em>)
scala&gt; sum
res39: Int = 15
Filtering lists: filter, partition, find, takeWhile, dropWhile, and span
The operation "xs filter p" takes as operands a list xs of type List[T] and a predicate function pof
type T &#8658; Boolean. It yields the list of all elements x in xs for which p(x) is true. For instance:
scala&gt; List(1, 2, 3, 4, 5) filter (</em> % 2 == 0)
res40: List[Int] = List(2, 4)
scala&gt; words filter (<em>.length == 3)
res41: List[String] = List(the, fox)The partition method is like filter but returns a pair of lists. One list contains all elements for which the
predicate is true, while the other contains all elements for which the predicate is false. It is defined by
the equality:
xs partition p
equals
(xs filter p, xs filter (!p(</em>)))
Here&#8217;s an example:
scala&gt; List(1, 2, 3, 4, 5) partition (_ % 2 == 0)
res42: (List[Int], List[Int]) = (List(2, 4),List(1, 3, 5))
The find method is also similar to filter, but it returns the first element satisfying a given predicate,
rather than all such elements. The operation xs find p takes a list xs and a predicatep as operands. It
returns an optional value. If there is an element x in xs for which p(x) is true,Some(x) is returned.
Otherwise, p is false for all elements, and None is returned. Here are some examples:
scala&gt; List(1, 2, 3, 4, 5) find (_ % 2 == 0)
res43: Option[Int] = Some(2)
scala&gt; List(1, 2, 3, 4, 5) find (_ &#8656; 0)
res44: Option[Int] = None
The takeWhile and dropWhile operators also take a predicate as their right operand. The
operation xs takeWhile p takes the longest prefix of list xs such that every element in the prefix
satisfies p. Analogously, the operation xs dropWhile p removes the longest prefix from list xssuch that
every element in the prefix satisfies p. Here are some examples:
scala&gt; List(1, 2, 3, -4, 5) takeWhile (_ &gt; 0)
res45: List[Int] = List(1, 2, 3)
scala&gt; words dropWhile (_ startsWith "t")
res46: List[String] = List(quick, brown, fox)
The span method combines takeWhile and dropWhile in one operation, just
like splitAt combinestake and drop. It returns a pair of two lists, defined by the equality:
xs span p
equals
(xs takeWhile p, xs dropWhile p)
Like splitAt, span avoids traversing the list xs twice:
scala&gt; List(1, 2, 3, -4, 5) span (_ &gt; 0)
res47: (List[Int], List[Int]) = (List(1, 2, 3),List(-4, 5))
Predicates over lists: forall and exists
The operation xs forall p takes as arguments a list xs and a predicate p. Its result is true if all elements
in the list satisfy p. Conversely, the operation xs exists p returns true if there is an element in xs that
satisfies the predicate p. For instance, to find out whether a matrix represented as a list of lists has a
row with only zeroes as elements:
scala&gt; def hasZeroRow(m: List[List[Int]]) =
m exists (row &#8658; row forall (_ == 0))hasZeroRow: (m: List[List[Int]])Boolean
scala&gt; hasZeroRow(diag3)
res48: Boolean = false
Folding lists: /: and :\
Another common kind of operation combines the elements of a list with some operator. For instance:
sum(List(a, b, c))
equals
0 + a + b + c
This is a special instance of a fold operation:
scala&gt; def sum(xs: List[Int]): Int = (0 /: xs) (_ + <em>)
sum: (xs: List[Int])Int
Similarly:
product(List(a, b, c))
equals
1 * a * b * c
is a special instance of this fold operation:
scala&gt; def product(xs: List[Int]): Int = (1 /: xs) (</em> * <em>)
product: (xs: List[Int])Int
A fold left operation "(z /: xs) (op)" involves three objects: a start value z, a list xs, and a binary
operation op. The result of the fold is op applied between successive elements of the list prefixed by z.
For instance:
(z /: List(a, b, c)) (op)
equals
op(op(op(z, a), b), c)
Or, graphically:
Here&#8217;s another example that illustrates how /: is used. To concatenate all words in a list of strings with
spaces between them and in front, you can write this:
scala&gt; ("" /: words) (</em> + " " + <em>)
res49: String = " the quick brown fox"
This gives an extra space at the beginning. To remove the space, you can use this slight variation:
scala&gt; (words.head /: words.tail) (</em> + " " + <em>)
res50: String = the quick brown foxThe /: operator produces left-leaning operation trees (its syntax with the slash rising forward is intended
to be a reflection of that). The operator has :\ as an analog that produces right-leaning trees. For
instance:
(List(a, b, c) :\ z) (op)
equals
op(a, op(b, op(c, z)))
Or, graphically:
The :\ operator is pronounced fold right. It involves the same three operands as fold left, but the first
two appear in reversed order: The first operand is the list to fold, the second is the start value.
For associative operations, fold left and fold right are equivalent, but there might be a difference in
efficiency. Consider for instance an operation corresponding to the flattenmethod, which concatenates
all elements in a list of lists. This could be implemented with either fold left or fold right:
def flattenLeft[T](xss: List[List[T]]) =
(List[T]() /: xss) (</em> ::: <em>)
def flattenRight[T](xss: List[List[T]]) =
(xss :<sub>List[T]()) (</em> ::: <em>)
Because list concatenation, xs ::: ys, takes time proportional to its first argument xs, the implementation
in terms of fold right in flattenRight is more efficient than the fold left implementation in flattenLeft.
The problem is that flattenLeft(xss) copies the first element listxss.head n-1 times, where n is the length
of the list xss.
Note that both versions of flatten require a type annotation on the empty list that is the start value of the
fold. This is due to a limitation in Scala&#8217;s type inferencer, which fails to infer the correct type of the list
automatically. If you try to leave out the annotation, you get the following:
scala&gt; def flattenRight[T](xss: List[List[T]]) =
(xss :</sub>List()) (</em> ::: <em>)
&lt;console&gt;:8: error: type mismatch;
found
: List[T]
required: List[Nothing]
(xss :<sub>List()) (</em> ::: <em>)
</sup>
To find out why the type inferencer goes wrong, you&#8217;ll need to know about the types of the fold
methods and how they are implemented. More on this in Section 16.10. Lastly, although
the /: and :\ operators have the advantage that the direction of the slash resembles the graphical
depiction of their respective left or right-leaning trees, and the associativity of the colon character
places the start value in the same position in the expression as it is in the tree, some may find theresulting code less than intuitive. If you prefer, you can use the methods
named foldLeft and foldRight instead, which are also defined on class List.
Example: List reversal using fold
Earlier in the chapter you saw an implementation of method reverse, named rev, whose running time
was quadratic in the length of the list to be reversed. Here is a different implementation of reverse that
has linear cost. The idea is to use a fold left operation based on the following scheme:
def reverseLeft[T](xs: List[T]) = (startvalue /: xs)(operation)
What remains is to fill in the startvalue and operation parts. In fact, you can try to deduce these parts
from some simple examples. To deduce the correct value of startvalue, you can start with the smallest
possible list, List(), and calculate as follows:
List()
equals (by the properties of reverseLeft)
reverseLeft(List())
equals (by the template for reverseLeft)
(startvalue /: List())(operation)
equals (by the definition of /:)
startvalue
Hence, startvalue must be List(). To deduce the second operand, you can pick the next smallest list as
an example case. You know already that startvalue is List(), so you can calculate as follows:
List(x)
equals (by the properties of reverseLeft)
reverseLeft(List(x))
equals (by the template for reverseLeft, with startvalue = List())
(List() /: List(x)) (operation)
equals (by the definition of /:)
operation(List(), x)
Hence, operation(List(), x) equals List(x), which can also be written as x :: List(). This suggests taking
as operation the :: operator with its operands exchanged. (This operation is sometimes called "snoc," in
reference to ::, which is called cons.) We arrive then at the following implementation for reverseLeft:
def reverseLeft[T](xs: List[T]) =
(List[T]() /: xs) {(ys, y) &#8658; y :: ys}
Again, the type annotation in List[T]() is needed to make the type inferencer work. If you analyze the
complexity of reverseLeft, you&#8217;ll find that it applies a constant-time operation ("snoc") n times,
where n is the length of the argument list. Thus, the complexity ofreverseLeft is linear.Sorting lists: sortWith
The operation xs sortWith before, where "xs" is a list and "before" is a function that can be used to
compare two elements, sorts the elements of list xs. The expression x before y should
returntrue if x should come before y in the intended ordering for the sort. For instance:
scala&gt; List(1, -3, 4, 2, 6) sortWith (</em> &lt; <em>)
res51: List[Int] = List(-3, 1, 2, 4, 6)
scala&gt; words sortWith (</em>.length &gt; <em>.length)
res52: List[String] = List(quick, brown, the, fox)
Note that sortWith performs a merge sort similar to the msort algorithm shown in the last section.
But sortWith is a method of class List, whereas msort is defined outside lists.
16.8 METHODS OF THE LIST OBJECT
So far, all operations you have seen in this chapter are implemented as methods of class List, so you
invoke them on individual list objects. There are also a number of methods in the globally accessible
object scala.List, which is the companion object of class List. Some of these operations are factory
methods that create lists. Others are operations that work on lists of some specific shape. Both kinds of
methods will be presented in this section.
Creating lists from their elements: List.apply
You&#8217;ve already seen on several occasions list literals such as List(1, 2, 3). There&#8217;s nothing special about
their syntax. A literal like List(1, 2, 3) is simply the application of the object Listto the elements 1, 2, 3.
That is, it is equivalent to List.apply(1, 2, 3):
scala&gt; List.apply(1, 2, 3)
res53: List[Int] = List(1, 2, 3)
Creating a range of numbers: List.range
The range method, which you saw briefly earlier in the discussion of map and flatmap, creates a list
consisting of a range of numbers. Its simplest form is List.range(from, until), which creates a list of all
numbers starting at from and going up to until minus one. So the end value, until, does not form part of
the range.
There&#8217;s also a version of range that takes a step value as third parameter. This operation will yield list
elements that are step values apart, starting at from. The step can be positive or negative:
scala&gt; List.range(1, 5)
res54: List[Int] = List(1, 2, 3, 4)
scala&gt; List.range(1, 9, 2)
res55: List[Int] = List(1, 3, 5, 7)
scala&gt; List.range(9, 1, -3)
res56: List[Int] = List(9, 6, 3)Creating uniform lists: List.fill
The fill method creates a list consisting of zero or more copies of the same element. It takes two
parameters: the length of the list to be created, and the element to be repeated. Each parameter is given
in a separate list:
scala&gt; List.fill(5)(<em>a</em>)
res57: List[Char] = List(a, a, a, a, a)
scala&gt; List.fill(3)("hello")
res58: List[String] = List(hello, hello, hello)
If fill is given more than two arguments, then it will make multi-dimensional lists. That is, it will make
lists of lists, lists of lists of lists, etc. The additional arguments go in the first argument list.
scala&gt; List.fill(2, 3)(<em>b</em>)
res59: List[List[Char]] = List(List(b, b, b), List(b, b, b))
Tabulating a function: List.tabulate
The tabulate method creates a list whose elements are computed according to a supplied function. Its
arguments are just like those of List.fill: the first argument list gives the dimensions of the list to create,
and the second describes the elements of the list. The only difference is that instead of the elements
being fixed, they are computed from a function:
scala&gt; val squares = List.tabulate(5)(n &#8658; n * n)
squares: List[Int] = List(0, 1, 4, 9, 16)
scala&gt; val multiplication = List.tabulate(5,5)(</em> * <em>)
multiplication: List[List[Int]] = List(List(0, 0, 0, 0, 0),
List(0, 1, 2, 3, 4), List(0, 2, 4, 6, 8),
List(0, 3, 6, 9, 12), List(0, 4, 8, 12, 16))
Concatenating multiple lists: List.concat
The concat method concatenates a number of element lists. The lists to be concatenated are supplied as
direct arguments to concat:
scala&gt; List.concat(List(<em>a</em>, <em>b</em>), List(<em>c</em>))
res60: List[Char] = List(a, b, c)
scala&gt; List.concat(List(), List(<em>b</em>), List(<em>c</em>))
res61: List[Char] = List(b, c)
scala&gt; List.concat()
res62: List[Nothing] = List()
16.9 PROCESSING MULTIPLE LISTS TOGETHER
The zipped method on tuples generalizes several common operations to work on multiple lists instead
of just one. One such operation is map. The map method for two zipped lists maps pairs of elements
rather than individual elements. One pair is for the first element of each list, another pair is for thesecond element of each list, and so on—as many pairs as the lists are long. Here is an example of its
use:
scala&gt; (List(10, 20), List(3, 4, 5)).zipped.map(</em> * <em>)
res63: List[Int] = List(30, 80)
Notice that the third element of the second list is discarded. The zipped method zips up only as many
elements as appear in all the lists together. Any extra elements on the end are discarded.
There are also zipped analogs to exists and forall. They are just like the single-list versions of those
methods except they operate on elements from multiple lists instead of just one:
scala&gt; (List("abc", "de"), List(3, 2)).zipped.
forall(</em>.length == <em>)
res64: Boolean = true
scala&gt; (List("abc", "de"), List(3, 2)).zipped.
exists(</em>.length != <em>)
res65: Boolean = false
THE FAST TRACK
In the next (and final) section of this chapter, we provide insight into Scala&#8217;s type inference algorithm.
If you&#8217;re not interested in such details right now, you can skip the entire section and go straight to the
conclusion here.
16.10 UNDERSTANDING SCALA&#8217;S TYPE INFERENCE ALGORITHM
One difference between the previous uses of sortWith and msort concerns the admissible syntactic
forms of the comparison function.
Compare:
scala&gt; msort((x: Char, y: Char) &#8658; x &gt; y)(abcde)
res66: List[Char] = List(e, d, c, b, a)
with:
scala&gt; abcde sortWith (</em> &gt; <em>)
res67: List[Char] = List(e, d, c, b, a)
The two expressions are equivalent, but the first uses a longer form of comparison function with named
parameters and explicit types. The second uses the concise form, (</em> &gt; <em>), where named parameters are
replaced by underscores. Of course, you could also use the first, longer form of comparison
with sortWith.
However, the short form cannot be used with msort.
scala&gt; msort(</em> &gt; <em>)(abcde)
&lt;console&gt;:12: error: missing parameter type for expanded
function x$1
msort(</em> &gt; <em>)(abcde)
^To understand why, you need to know some details of Scala&#8217;s type inference algorithm. Type inference
in Scala is flow based. In a method application m(args), the inferencer first checks whether the
method m has a known type. If it does, that type is used to infer the expected type of the arguments. For
instance, in abcde.sortWith(</em> &gt; <em>), the type of abcde is List[Char]. Hence,sortWith is known to be a
method that takes an argument of type (Char, Char) &#8658; Boolean and produces a result of
type List[Char]. Since the parameter types of the function arguments are known, they need not be
written explicitly. With what it knows about sortWith, the inferencer can deduce that (</em> &gt; <em>) should
expand to ((x: Char, y: Char) &#8658; x &gt; y) where x and y are some arbitrary fresh names.
Now consider the second case, msort(</em> &gt; <em>)(abcde). The type of msort is a curried, polymorphic
method type that takes an argument of type (T, T) &#8658; Boolean to a function
from List[T] toList[T] where T is some as-yet unknown type. The msort method needs to be
instantiated with a type parameter before it can be applied to its arguments.
Because the precise instance type of msort in the application is not yet known, it cannot be used to infer
the type of its first argument. The type inferencer changes its strategy in this case; it first type checks
method arguments to determine the proper instance type of the method. However, when tasked to type
check the short-hand function literal, (</em> &gt; <em>), it fails because it has no information about the types of
the implicit function parameters that are indicated by underscores.
One way to resolve the problem is to pass an explicit type parameter to msort, as in:
scala&gt; msort[Char](</em> &gt; <em>)(abcde)
res68: List[Char] = List(e, d, c, b, a)
Because the correct instance type of msort is now known, it can be used to infer the type of the
arguments. Another possible solution is to rewrite the msort method so that its parameters are swapped:
def msortSwapped[T](xs: List[T])(less:
(T, T) &#8658; Boolean): List[T] = {


}
Now type inference would succeed:
scala&gt; msortSwapped(abcde)(</em> &gt; <em>)
res69: List[Char] = List(e, d, c, b, a)
What has happened is that the inferencer used the known type of the first parameter abcde to determine
the type parameter of msortSwapped. Once the precise type of msortSwapped was known, it could be
used in turn to infer the type of the second parameter, (</em> &gt; <em>).
Generally, when tasked to infer the type parameters of a polymorphic method, the type inferencer
consults the types of all value arguments in the first parameter list but no arguments beyond that.
Since msortSwapped is a curried method with two parameter lists, the second argument (i.e., the
function value) did not need to be consulted to determine the type parameter of the method.This inference scheme suggests the following library design principle: When designing a polymorphic
method that takes some non-function arguments and a function argument, place the function argument
last in a curried parameter list on its own. That way, the method&#8217;s correct instance type can be inferred
from the non-function arguments, and that type can in turn be used to type check the function
argument. The net effect is that users of the method will be able to give less type information and write
function literals in more compact ways.
Now to the more complicated case of a fold operation. Why is there the need for an explicit type
parameter in an expression like the body of the flattenRight method shown here?
(xss :</sub>List[T]()) (</em> ::: <em>)
The type of the fold-right operation is polymorphic in two type variables. Given an expression:
(xs :<sub>z) (op)
The type of xs must be a list of some arbitrary type A, say xs: List[A]. The start value z can be of some
other type B. The operation op must then take two arguments of type A and B, and return a result of
type B, i.e., op: (A, B) &#8658; B. Because the type of z is not related to the type of the listxs, type inference
has no context information for z.
Now consider the expression in the erroneous version of flattenRight, also shown here:
(xss :</sub>List()) (</em> ::: <em>)

The start value z in this fold is an empty list, List(), so without additional type information its type is
inferred to be a List[Nothing]. Hence, the inferencer will infer that the B type of the fold
is List[Nothing]. Therefore, the operation (</em> ::: _) of the fold is expected to be of the following type:
(List[T], List[Nothing]) &#8658; List[Nothing]
This is indeed a possible type for the operation in that fold but it is not a very useful one! It says that
the operation always takes an empty list as second argument and always produces an empty list as
result.
In other words, the type inference settled too early on a type for List(); it should have waited until it
had seen the type of the operation op. So the (otherwise very useful) rule to only consider the first
argument section in a curried method application for determining the method&#8217;s type is at the root of the
problem here. On the other hand, even if that rule were relaxed, the inferencer still could not come up
with a type for op because its parameter types are not given. Hence, there is a Catch-22 situation that
can only be resolved by an explicit type annotation from the programmer.
This example highlights some limitations of the local, flow-based type inference scheme of Scala. It is
not present in the more global Hindley-Milner style of type inference used in functional languages,
such as ML or Haskell. However, Scala&#8217;s local type inference deals much more gracefully with object-
oriented subtyping than the Hindley-Milner style does. Fortunately, the limitations show up only in
some corner cases, and are usually easily fixed by adding an explicit type annotation.Adding type annotations is also a useful debugging technique when you get confused by type error
messages related to polymorphic methods. If you are unsure what caused a particular type error, just
add some type arguments or other type annotations, which you think are correct. Then you should be
able to quickly see where the real problem is.
16.11 CONCLUSION
Now you have seen many ways to work with lists. You have seen the basic operations like headand tail,
the first-order operations like reverse, the higher-order operations like map, and the utility methods in
the List object. Along the way, you learned a bit about how Scala&#8217;s type inference works.
Lists are a real work horse in Scala, so you will benefit from knowing how to use them. For that reason,
this chapter has delved deeply into how to use lists. Lists are just one kind of collection that Scala
supports, however. The next chapter is broad, rather than deep, and shows you how to use a variety of
Scala&#8217;s collection types.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-17 23:04:14 EET
</div>
</div>
</body>
</html>
