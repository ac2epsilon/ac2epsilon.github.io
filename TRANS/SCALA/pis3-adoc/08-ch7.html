<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__7">Глава 7</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Вбудовані керівні структури</h1>
<div class="paragraph"><p>Scala має тільки декілька вбудованих керівних структур. Все, що є, це тільки: <code>if</code>, <code>while</code>, <code>for</code>, <code>try</code>, <code>match</code>, та виклики функцій. Причина, з якої Scala має їх так мало, в тому, що вона включає функціональні літерали з моменту свого створення. Замість накопичення в своєму синтаксисі однієї за одною високорівневих керівних структір, Scala накопичує їх в бібліотеках. (Глава 9 покаже в точності, як це зроблене.) Ця глава покаже ті декілька керівних структур, що є вбудованими.</p></div>
<div class="paragraph"><p>Одна річ, що ви помітите, це що майже всі керівні структури в Scala призводять до деякого результату. Цей підхід взятий від функціональних мов, де програми розглядаються як обчислення значення, так що компоненти програми також повинні обчислювати значення. Ви також можете розглядати цей підхід як логічний висновок з тренду, що вже присутній в імперативних мовах. В імперативних мовах виклики функцій можуть повертати значення, навіть коли викликана функція так само гарно може просто оновити значення вихідної змінної, переданої як аргумент. На додаток, імперативні мови часто мають тримісний оператор (такий як оператор <code>?:</code> в C, C++ та Java), що ефективно поводиться як <code>if</code>, але результатом є значення. Scala адаптує цю модель тримісного оператора, але називає його <code>if</code>. Іншими словами,в Scala <code>if</code> може повертати значення. Потім Scala продовжує цей тренд, маючи <code>for</code>, <code>try</code> та <code>match</code>, що також повертають значення.</p></div>
<div class="paragraph"><p>Програмісти можуть використовувати ці значення для спрощення свого коду, так само, якби вони використовували значення повернуті з функцій. Без цієї можливості програміст має створювати тимчасові змінні, тільки щоб зберігати результати, що обчислюються всередині керівної структури. Видалення ціх змінних робить код  трохи простішим, та він також запобігає багатьом вадам, коли ви встановлюєте змінну в одній гілці, але забуваєте встановити в іншому.</p></div>
<div class="paragraph"><p>Загалом, базові керівні структури Scala, мінімальні як вони є, провадяться всі основи з імперативних мов. Більше того, вони дозволяють скоротити ваш код, узгоджена маючі значення результату. Щоб показати, як це робить, давайте подивимось на базові керівні структури Scala.</p></div>
<div class="sect1">
<h2 id="_7_1__em_if_em">7.1 Вирази <em>if</em></h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala <code>if</code> робить так само, як і в багатьох інших мовах. Він перевіряє умову, і потім виконує одну з двох гілок коду, в залежності чи умова виконується. Ось загальний приклад, написаний в імперативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">filename</span> <span class="k">=</span> <span class="s">&quot;default.txt&quot;</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
  <span class="n">filename</span> <span class="k">=</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код декларує змінну <code>filename</code>, та ініціалізує її значенням по замовчанню. Потім він виконує вираз <code>if</code>, щоб перевірити, чи програмі були надані якісь аргументи. Якщо це так, значення змінної змінюється, щоб вона містила значення, вказане в списку аргументів. Якщо аргументи не надані, змінна залішається встановленою в значення по замовчанню.</p></div>
<div class="paragraph"><p>Цей код може бути записаний краще, оскільки, як зазначалось в Кроці 3 в Главі 2, в Scala <code>if</code> є виразом, що повертає значення. Лістинг 7.1 показує, як ви можете досягти того самого ефекту, що і в попередньому прикладі, без використання жодних <code>var</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filename</span> <span class="k">=</span>
<span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">else</span> <span class="s">&quot;default.txt&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.1 - Ідіома Scala для умовної ініціалізації.</p></div>
<div class="paragraph"><p>На цей раз <code>if</code> має дві гілки. Якщо аргументи не порожні, буде обраний перший елемент, <code>args(0)</code>; інакше буде обране значення по замовчанню. Вираз <code>if</code> має результат в вигляді обраного значення, і змінна <code>filename</code> ініціалізується цім значенням. Цей код трохи коротший, але його справжня перевага в тому, що він використовує <code>val</code> замість <code>var</code>. Використання <code>val</code> є функціональним стилем, і це допомагає вам майже в той спосіб, що і використання фінальних змінних в Java. Це каже читачам коду, що змінна ніколи не буде змінюватись, вберігаючи їх від сканування всього коду в полі зору змінної, дивлячись, чи вона не змінилась.</p></div>
<div class="paragraph"><p>Друга перевага використовувати <code>val</code> замість <code>var</code> в тому, що вони краще підтримують розуміння рівнянь. Введене значення еквівалентне до виразу, що обчислює його, припускаючи, що вираз не має побічних ефектів. Таким чином, кожного разу, коли ви збираєтесь записати ім'я змінної, замість нього ви можете записати вираз. Наприклад, замість <code>println(filename)</code>, ви можете просто записати це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">println</span><span class="o">(</span><span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;default.txt&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вибір за вами. Ви можете записати це любим способом. Використання <code>vals</code> допомагає вам безпечно робити цей тип рефакторингу, по мірі того, як ваш код буде розвиватись з часом. Шукайте можливості використовувати <code>val</code>. Вони можуть зробити ваш код більш простим для читання, та простішим для рефакторингу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_2__while">7.2 Цикли while</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala&#8217;s while loop behaves as in other languages. It has a condition and a body, and the body is executed over and over as long as the condition holds true. Listing 7.2 shows an example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">gcdLoop</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">a</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">var</span> <span class="n">b</span> <span class="k">=</span> <span class="n">y</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">temp</span> <span class="k">=</span> <span class="n">a</span>
    <span class="n">a</span> <span class="k">=</span> <span class="n">b</span> <span class="o">%</span> <span class="n">a</span>
    <span class="n">b</span> <span class="k">=</span> <span class="n">temp</span>
  <span class="o">}</span>
  <span class="n">b</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.2 - Обчислення найбільшого загального дільника за допомогою цикла <code>while</code>.</p></div>
<div class="paragraph"><p>Scala також має цикл <code>do-while</code>. Він робить як цикл <code>while</code>, за винятком того, що він перевіряє умову після тіла циклу, а не до. Лістинг 7.3 показує скрипт Scala, що використовує <code>do-while</code> для відлуння рядків, введених в стандартний вивід, докі не буде введений порожній рядок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="k">do</span> <span class="o">{</span>
  <span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">()</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Read: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
<span class="o">}</span> <span class="k">while</span> <span class="o">(</span><span class="n">line</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.3 - Читання зі стандартного вводу за допомогою do-while.</p></div>
<div class="paragraph"><p>Конструкції <code>while</code> та <code>do-while</code> називаються "циклами", а не виразами, оскільки вони не продукують цікавого значення. Тип результата є <code>Unit</code>. Існує одне значення цього (та загалом тільки одне) типу <code>Unit</code>. Воно називається юніт значенням, та записується <code>()</code>. Існування <code>()</code> є тим, як Scala <code>Unit</code> відрізняється від Java <code>void</code>. Спробуйте це в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">greet</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;hi&quot;</span><span class="o">)</span> <span class="o">}</span>
<span class="n">greet</span><span class="k">:</span> <span class="o">()</span><span class="kt">Unit</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">()</span> <span class="o">==</span> <span class="n">greet</span><span class="o">()</span>
<span class="n">hi</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки перед тілом немає знаку рівняння, <code>greet</code> визначене як процедура з типом результата <code>Unit</code>. Таким чином, <code>greet</code> повертає юніт значення <code>()</code>. Це підтверджується в наступному рядку: порівнюючи результат <code>greet</code> на рівність з юніт значенням <code>()</code>, що дає <code>true</code>.</p></div>
<div class="paragraph"><p>Одна інша конструкція, що має результат в вигляді юніт значення, що релевантне тут, є переприсвоєння до <code>vars</code>. Наприклад, коли ви намагаєтесь читати рядки в Scala, використовуючи наступну ідіому Java, цикл <code>while</code> (та C і C++), ви потрапите в небезпеку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">line</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
<span class="k">while</span> <span class="o">((</span><span class="n">line</span> <span class="k">=</span> <span class="n">readLine</span><span class="o">())</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="c1">// Це не робить!</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Read: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви компілюєте цей код, Scala надасть вам попередження, що порівняння значень типів <code>Unit</code> та <code>String</code> з використанням <code>!=</code> буде завжди давати <code>true</code>. Тоді як в Java присвоєння скінчиться присвоєнням значення (в цьому випадку рядка зі стандартного вводу), в Scala присвоєння завжди зкінчиться юніт значенням, <code>()</code>. Таким чином, значення присвоєння <code>line = readLine()</code> завжди буде <code>()</code>, та ніколи не буде <code>""</code>. Як результат, умова цього цикла <code>while</code> ніколи не буде <code>false</code>, і, таким чином, цикл ніколи не завершиться.</p></div>
<div class="paragraph"><p>Оскікльки цикл <code>while</code> не призводить до значення, він часто відсутній в чисто функціональних мовах. Такі мови мають вирази, а не цикли. Тим не менш, Scala включає цикл <code>while</code>, оскільки деякі імперативні рішення можуть бути більш читабельні, особливо для програмістів з переважно імперативним досвідом. Наприклад, якщо ви бажаєте закодувати алгоритм, що продовжує процес докі деяка умова не зміниться, цикл <code>while</code> може виразити це напряму, тоді як функціональна альтернатива, що вірогідно використовуватиме рекурсію, може бути менш очевидною для деяких читачів коду.</p></div>
<div class="paragraph"><p>Наприклад, Лістинг 7.4 показує альтернативний шлях визначити найбільший загальний дільник двох чисел.<span class="footnote"><br />[Функція gcd, показана в Лістингу 7.4, використовує той самий підхід, що використовується в подібно-названій функції, спершу показаній в Лістингу 6.3, щоб обчислювати найбільший загальний дільник для класу Rational. Головна різниця в тому, що замість Int, gcd з Лістингу 7.4 робить з Long.]<br /></span> Беручи деякі два значення для <code>x</code> та <code>y</code>, функція <code>gcd</code>, показана в Лістингу 7.4 буде повертати той самий результат, що і <code>gcdLoop</code> функція, показана в Лістингу 7.2. Різниця між ціма двома підходами а тому, що <code>gcdLoop</code> написана в імперативному стилі, використовуючи <code>var</code> та цикл <code>while</code>, тоді як <code>gcd</code> написане в більш функціональному стилі, що включає рекурсію (<code>gcd</code> викликає себе), та не потребує <code>var</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.4 - Обчислення найбільшого загального дільника за допомогою рекурсії.</p></div>
<div class="paragraph"><p>Загалом, ми рекомендуємо вас кидати виклик циклам <code>while</code> в вашому коді, так само, як ви кидаєте виклик <code>var</code>. Фактично, цикли <code>while</code> та <code>var</code> часто ідуть рука об руку. Оскільки цикли <code>while</code> не видають результату, щоб призвести до якіхось змін в вашій програмі, цикл  <code>while</code> буде звичайно оновлювати <code>var</code> або виконувати I/O. Ви можете бачити це в дії в <code>gcdLoop</code>, показаному раніше. По мірі того, як цикл <code>while</code> робить свою справу, він оновлює <code>var</code> <code>a</code> та <code>b</code>. Таким чином, ми радимо вам бути трохи підозрілим щодо циклів <code>while</code> в вашому коді. Якщо немає гарного обгрунтування для окремого використання циклів <code>while</code> або <code>do-while</code>, спробуйте знайти спосіб зробити те саме без них.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_3__for">7.3 Вирази for</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вираз <code>for</code> в Scala є швейцарським розкладним ножем ітерації. Він дозволяє комбінувати декілька простих інструментів в різний спосіб, щоб виразити широку різноманітність ітерацій. Прості використання дозволяють вирішувати загальні завдання, такі, як ітерація по послідовності цілих. Більш розвинені вирази можуть ітерувати по декількох колекціях різних типів, фільтрувати елементи на основі довільних умов, та продукувати нові колекції.</p></div>
<div class="sect2">
<h3 id="____2">Ітерації по колекціях</h3>
<div class="paragraph"><p>Простіша річ, що ви можете зробити за допомогою <code>for</code> це ітерувати по всіх елементах колекції. Наприклад, Лістинг 7.5 показує деякий код, що друкує всі файли в поточній директорії. I/O виконується з використанням Java API. Зпочатку ми створюємо <code>java.io.File</code> на поточній директорії,".", та викликаємо його метод <code>listFiles</code>. Цей метод повертає масив з об'єктів <code>File</code>, по одному для кожної директорії та файлу, що містяться в поточній директорії. Ми зберігаємо отриманий масив в змінній <code>filesHere</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>

<span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.5 - Перелічує файли в поточній директорії за допомогою вираза <code>for</code>.</p></div>
<div class="paragraph"><p>За допомогою синтаксиса <code>file &lt;- filesHere</code>, що називається <em>генератором</em>, ми ітеруємо по елементах <code>filesHere</code>. В кожній ітерації ініціалізується нова <code>val</code> на ім'я <code>file</code> зі значенням елемента. Компілятор виводить тип <code>file</code> як <code>File</code>, оскільки <code>filesHere</code> має тип <code>Array[File]</code>. Для кожної ітерації буде виконане тіло вираза, <code>println(file)</code>. Оскільки в <code>File</code> метод <code>toString</code> видає ім'я файла або директорії, будуть роздруковані імена всіх файлів та директорій в поточній директорі.</p></div>
<div class="paragraph"><p>Синтаксис виразу <code>for</code> робить для любого типу колекції, не тільки для масивів.<span class="footnote"><br />[Щоб бути точним, вираз зправа від символа <code>&lt;-</code> в виразі for може бути любого типу, що має певні методи (в цьому випадку foreach) з відповідними сигнатурами. Деталі щодо того, як компілятор Scala обробляє вирази <code>for</code> описані в Главі 23.]<br /></span> Один зручний особливий випадок є тип <code>Range</code>, що ви похопцем бачили в Таблиці 5.4. Ви можете створити <code>Range</code> з використанням синтаксису як <code>1 to 5</code>, та можете ітерувати по ньому за допомогою <code>for</code>. Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
<span class="nc">Iteration</span> <span class="mi">1</span>
<span class="nc">Iteration</span> <span class="mi">2</span>
<span class="nc">Iteration</span> <span class="mi">3</span>
<span class="nc">Iteration</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви не бажаєте включати верхню межу диапазона в значення, по яких піде ітерація використовуйте <code>until</code> замість <code>to</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Iteration &quot;</span> <span class="o">+</span> <span class="n">i</span><span class="o">)</span>
<span class="nc">Iteration</span> <span class="mi">1</span>
<span class="nc">Iteration</span> <span class="mi">2</span>
<span class="nc">Iteration</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ітерація по цілим, як ця, є загальною в Scala, але не так сильно, як в інших мовах. В інших мовах ви можете використати цю можливість для ітерації по масиву, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Не загальне в Scala...</span>
<span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">filesHere</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">filesHere</span><span class="o">(</span><span class="n">i</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вираз <code>for</code> вводить змінну <code>i</code>, встановлює її по черзі в коже ціле між <code>0</code> та <code>filesHere.length - 1</code>, та виконує тіло виразу для кожного встановленого <code>i</code>. Для кожного встановленого <code>i</code>, <code>i`тий елемент `filesHere</code> отримується та обробляється.</p></div>
<div class="paragraph"><p>Причина, з якої цей тип ітерації менш загальний в Scala в тому, що ви можете ітерувати по колекції напряму. Коли ви робите це, ваш код стає коротшим, та ви обходите багато "помилкових помилок", що можуть виникати, коли ви ітеруєте по масивах. Маєте ви почати з 0 або 1? Маєте ви додавати -1, +1, або нічого до фінального значення? На такі запитання легко відповісти, але також легко відповісти помилково. Безпечніше взагалі повністю уникати таких запитань.</p></div>
</div>
<div class="sect2">
<h3 id="_">Фільтрація</h3>
<div class="paragraph"><p>Іноді ви не бажаєте ітерувати по повній колекції; ви бажаєте відфільтрувати її до деякої підмножини. Ви можете зробити це за допомогою вираза <code>for</code> через додавання фільтра, твердження <code>if</code> всередині дужок <code>for</code>. Наприклад, код, показаний в Лістингу 7.6, перелічує тільки ті файли в поточній директорії, чиї імена закінчуються на <code>.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">filesHere</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">File</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)).</span><span class="n">listFiles</span>
<span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
  <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.6 - Пошук файлів <code>.scala</code> використовуючи <code>for</code> з фільтром.</p></div>
<div class="paragraph"><p>Ви можете альтернативно досягти тієї самої цілі за допомогою цього коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
<span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код дає той самий вихід, що і попередній код, та, можливо, виглядає більш знайомим для програмістів з імперативним підгрунтям. Однак імперативна форма є тільки цибулиною, оскільки цей часний вираз <code>for</code> викликається тільки для побічного ефекту друкування, і має результатом юніт значення <code>()</code>. Як буде показано далі в цьому розділі, вираз <code>for</code> названий "виразом", оскільки він може давати в результаті цікаве значення, колекцію, тип якої визначається твердженням <code>&lt;-</code> виразу <code>for</code>.</p></div>
<div class="paragraph"><p>Ви можете включити більше фільтрів, якщо ви бажаєте. Просто продовжуйте додавати фільтри <code>if</code>. Наприклад, щоб бути екстра захищеним, код в Лістингу 7.7 друкує тільки файли, але не директорії. Він робить це через додавання фільтрів, що перевіряють метод <code>isFile</code> для файлів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">isFile</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
<span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.7 - Використання декількох фільтрів в виразі <code>for</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__">Вкладена ітерація</h3>
<div class="paragraph"><p>Якщо ви додасте декілька тверджень <code>&lt;-</code>, ви отримаєте вкладені "цикли". Наприклад, вираз <code>for</code>, показаний в Лістингу 7.8 має два вкладених цикли. Зовнішній цикл ітерує по <code>filesHere</code>, та внутрішній ітерує по <code>fileLines(file)</code> для кожного файлу, що закінчується на <code>.scala</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">java.io.File</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">scala</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">file</span><span class="o">).</span><span class="n">getLines</span><span class="o">().</span><span class="n">toList</span>
<span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">);</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
  <span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span><span class="o">)</span>
<span class="n">grep</span><span class="o">(</span><span class="s">&quot;.*gcd.*&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.8 - Використання декількох генераторів в виразі <code>for</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте, ви можете використовувати фігурні дужки замість звичайних дужок щоб оточити генератори та фільтри. Одна з переваг використання фігурних дужок в тому, що ви можете відкинути деякі з крапок з комою, що потрібні вам, коли ви використовуєте дужки, бо, як пояснено в Розділі 4.2, компілятор Scala не буде виводити коми з крапками, коли знаходиться в дужках.</p></div>
</div>
<div class="sect2">
<h3 id="____">Серед-поточні прикріплення змінних</h3>
<div class="paragraph"><p>Зауважте, що в попередньому коді повторюється вираз <code>line.trim</code>. Це нетривіальне обчислення, так що ви можете побажати обчислити його тільки один раз. Ви можете зробити це, прикріпивши результат до нової змінної, використовуючи знак рівності (=). Прикріплена змінна буде створена, та використовується як звичайна <code>val</code>, тільки без ключового слова <code>val</code>. Лістинг 7.9 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
  <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>
  <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
<span class="o">}</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">trimmed</span><span class="o">)</span>
<span class="n">grep</span><span class="o">(</span><span class="s">&quot;.*gcd.*&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.9 - Серед-поточне присвоєння в виразі <code>for</code>.</p></div>
<div class="paragraph"><p>В Лістингу 7.9 змінна на ім'я <code>trimmed</code> вводиться посеред виразу <code>for</code>. Ця змінна ініціалізована результатом <code>line.trim</code>. Потім залишок виразу використовує її в двох місцях, один раз в <code>if</code>, та ще раз в <code>println</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____3">Продукування нової колекції</h3>
<div class="paragraph"><p>Хоча доки всі приклади тільки оперували з ітерованими значеннями, та потім забували їх, ви також можете генерувати значення, що буде запам'ятовуватись на кожній ітерації. Щоб зробити це, ви ставите перед тілом виразу <code>for</code> ключове слово <code>yield</code>. Наприклад, ось функція, що ідентифікує файли <code>.scala</code>, та зберігає їх в масиві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">scalaFiles</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">file</span>
</pre></div></div></div>
<div class="paragraph"><p>Кожний раз, коли виконується тіло виразу, воно продукує одне значення, в цьому разі просто <code>file</code>. Коли вираз <code>for</code> завершується, результат буде включати всі з отриманих значень, що міститимуться в одній колекції. Тип отриманої колекції базується на типі колекцій, оброблених в твердженнях ітерації. В цьому випадку результат буде  <code>Array[File]</code>, оскільки <code>filesHere</code> є масивом, і тип отриманого виразу є <code>File</code>.</p></div>
<div class="paragraph"><p>Будьте уважні, поміж всього, коли ви розташовуєте ключове слово <code>yield</code>. Синтаксис виразу <code>for-yield</code> виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">clauses</span> <span class="k">yield</span> <span class="n">body</span>
</pre></div></div></div>
<div class="paragraph"><p><code>yield</code> іде перед всім тілом. Навіть якщо тіло є блок, оточений фігурними дужками, покладіть <code>yield</code> перед першою фігурною дужкою, не перед останнім виразом в блоці. Уникайте спокуси писати речі, подібні до цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">yield</span> <span class="n">file</span> <span class="c1">// Синтаксична помилка!</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, вираз <code>for</code>, показаний в Лістингу 7.10 спочатку трансформує <code>Array[File]</code> на ім'я <code>filesHere</code>, що містить всі файли в поточній директорії, до такого, що містить тільки файли <code>.scala</code>. Для кожного з них він генерує <code>Iterator[String]</code>, результат метода <code>fileLines</code>, чиє визначення показане в Лістингу 7.8. <code>Iterator</code> пропонує методи <code>next</code> та <code>hasNext</code>, що дозволяють вам ітерувати по колекції елементів. Цей внутрішній ітератор трансформується в інший ітератор ` Iterator[String]<code>, який містить тільки обрізані рядки, що містять субрядок `"for"</code>. Нарешті, для кожного з них, видається ціла довжина. Результатом цього виразу <code>for</code> є <code>Array[Int]</code>, що містить довжини.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">forLineLengths</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span>
    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">)</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>
    <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="s">&quot;.*for.*&quot;</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.10 - Трансформування <code>Array[File]</code> на <code>Array[Int]</code> з допомогою <code>for</code>.</p></div>
<div class="paragraph"><p>В цій точці ви бачили всі головні функції виразів Scala <code>for</code>, але ми пройшли по них дуже швидко. Більш докладне покриття виразів <code>for</code> надається в Главі 23.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_4______try">7.4 Обробка виключень за допомогою виразів try</h2>
<div class="sectionbody">
<div class="paragraph"><p>Виключення Scala поводяться як в багатьох інших мовах. Замість повернення значення в в нормальний спосіб, метод може завершитись викликом виключення. Викликач метода може або перехопити та обробити це виключення, або він може сам по собі завершитись, що спричинить поширення виключення до викликача викликача. Виключення розповсюджується в такий спосіб, розкручуючи стек викликів, доки метод не обробить його, або доки не залишиться методів.</p></div>
<div class="sect2">
<h3 id="___2">Виклик виключень</h3>
<div class="paragraph"><p>Виклик виключення в Scala виглядає так само, як і в Java. Ви створюєте об'єкт виключення, та потім закидаєте його ключовим словом <code>throw</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це може виглядати трохи парадоксальним, в Scala <code>throw</code> є виразом, що має тип результа. Ось приклад, коли тип результата має значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">half</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">else</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="s">&quot;n must be even&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що тут трапиться, коли <code>n</code> є парним - <code>half</code> буде ініціалізоване до половини <code>n</code>. Якщо воно не парне, буде викликане виключення перед тим, як <code>half</code> взагалі зможе бути ініціалізоване. Через це, безпечно трактувати закидання виключення як взагалі будь-який тип. Любий контекст, що намагатиметься використовувати повернення з <code>throw</code>, ніколи не зможе цього зробити, так що не слід чекати ніякої шкоди.</p></div>
<div class="paragraph"><p>Технічно <code>throw</code> виключення має тип <code>Nothing</code>. Ви можете використовувати <code>throw</code> як вираз, навіть якщо він ніколи нічого не обчислює. Цей невеликий шматок технічної гімнастики може виглядати збоченим, але часто корисний в випадках, як попередній приклад. Одна з гілок <code>if</code> обчислює значення, тоді як інша закидає виключення, та обчислює <code>Nothing</code>. Тип цілого виразу <code>if</code> після цього є типом тієї гілки, що щось обчислює. Тип <code>Nothing</code> дискутується далі в Розділі 11.3.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Перехоплення виключень</h3>
<div class="paragraph"><p>Ви перехоплюєте виключення, використовуючи синтаксис, показаний в Лістингу 7.11 Синтаксис для тверджень <code>catch</code> був обраний за його узгодженість з важливою частиною Scala: співпадінням шаблонів. Співпадіння шаблонів, потужна можливість, коротко описана в цій главі, та в більших деталях в Главі 15.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>
<span class="k">import</span> <span class="nn">java.io.FileNotFoundException</span>
<span class="k">import</span> <span class="nn">java.io.IOException</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">&quot;input.txt&quot;</span><span class="o">)</span>
<span class="c1">// Використовуємо та зачиняємо файл</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">FileNotFoundException</span> <span class="o">=&gt;</span> <span class="c1">// Обробляємо відсутній файл</span>
  <span class="k">case</span> <span class="n">ex</span><span class="k">:</span> <span class="kt">IOException</span> <span class="o">=&gt;</span> <span class="c1">// Обробляємо помилки I/O</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.11 - Твердження <code>try-catch</code> clause in Scala.</p></div>
<div class="paragraph"><p>Поведінка цього виразу <code>try-catch</code> така сама, як і інших мов з виключенями. Тіло виконується, та якщо виникає виключення, кожне твердження <code>catch</code> викликається по черзі. В цьому прикладі, якщо виникає включення типу <code>FileNotFoundException</code>, буде виконане перше твердження. Якщо тип виключення <code>IOException</code>, виконується друге твердження. Якщо виключення не одного з ціх типів, <code>try-catch</code> завершиться, та виключення розповсюдиться далі.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Одна різниця, що ви швидко зауважите, в тому, що на відміну від Java, Scala не вимагає від вас перехоплювати перевірені виключення, або декларувати їх в твердженні <code>throws</code>. Ви можете декларувати <code>throws</code>, якщо бажатєте, за допомогою анотації <code>@throws</code>, але це не вимагається. Дивіться Розділ 31.2 для додаткової інформації щодо <code>@throws</code>.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="__finally">Твердження finally</h3>
<div class="paragraph"><p>Ви можете огорнути вираз за допомогою твердження <code>finally</code>, якщо ви бажаєте виконати деякий код, не важливо як скінчиться вираз. Наприклад, ви можете побажати переконатись, що відкритий файл буде закритий, навіть якщо метод завершується виникненням виключення. Лістинг 7.12 показує приклад.<span class="footnote"><br />[Хоча ви маєте завжди оточувати твердження case в catch в дужки, try та finally не потребують дужок, якщо вони містять тільки один вираз. Наприклад, ви можете написати: try t() catch { case e: Exception &#8658; &#8230; } finally f().]<br /></span></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io.FileReader</span>
<span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="s">&quot;input.txt&quot;</span><span class="o">)</span>
<span class="k">try</span> <span class="o">{</span>
<span class="c1">// Використовуємо файл</span>
<span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
  <span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="o">()</span> <span class="c1">// Переконуємось що зачинили файл</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.12 - Твердження <code>try-finally</code> в Scala.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Лістинг 7.12 показує ідиоматичний спосіб переконатись, що об'єкт не-з-пам'яті, такий як файл, сокет або з'єднання з базою даних, є зачинений. Спочатку ви захоплюєте ресурс. Потім ви починаєте блок <code>try</code>, в якому ви використовуєте ресурс. Нарешті, ви зачиняєте ресурс в блоці <code>finally</code>. Ця ідіома є тою самою в Scala, як в Java; альтернативно, в Scala ви можете задіяти прийом з назвою <em>шаблон позичання</em>, щоб досягти цієї цілі більш стисло. Шаблон позичання буде описаний в Розділі 9.4.</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="___4">Отримання значення</h3>
<div class="paragraph"><p>Як і з багатьма іншими керівними структурами Scala, <code>try-catch-finally</code> повертає значення. Наприклад, Лістинг 7.13 показує, як ви можете спробувати розібрати URL, але використати значення по замовчанню, якщо URL погано сформований. Результатом є те, що полишає твердження <code>try</code>, якщо не виникло виключення, або відповідний код <code>catch</code>, якщо виключення виникло і було перехоплене. Якщо виключення було закинуте, але не перехоплене, вираз взагалі не має результату. Значення, обчислене в твердженні <code>finally</code>, якщо таке є, відкидається. Звичайно в <code>finally</code> робиться деякий різновид очищення, такий як закриття файлів. Звичайно, вони не мають змінювати значення, обчислене в головному тілі або блоці <code>catch</code> твердження <code>try</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.net.URL</span>
<span class="k">import</span> <span class="nn">java.net.MalformedURLException</span>
<span class="k">def</span> <span class="n">urlFor</span><span class="o">(</span><span class="n">path</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="n">path</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">MalformedURLException</span> <span class="o">=&gt;</span>
      <span class="k">new</span> <span class="nc">URL</span><span class="o">(</span><span class="s">&quot;http://www.scala-lang.org&quot;</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.13 - Твердження <code>catch</code>, що надає значення.</p></div>
<div class="paragraph"><p>Якщо ви знайомі з Java, вам зрозуміло, що поведінка Scala відрізняється від Java <code>try-finally</code> тільки в тій частині, що остання не повертає значення. Як і в Java, якщо твердження <code>finally</code> включає явне твердження <code>return</code>, або закидає виключення, значення повернення або виключення буде "анулювати" любі попередні значення, що походять з блоку <code>try</code> або з одного з його тверджень <code>catch</code>. Наприклад, маючи таке, скоріше надумане, визначення функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">f</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span> <span class="k">return</span> <span class="mi">1</span> <span class="k">finally</span> <span class="k">return</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>виклик f() дає 2. Для контрасту, маючи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">g</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="k">try</span> <span class="mi">1</span> <span class="k">finally</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>виклик g() дає 1. Обоє з ціх функцій показують поведінку, що може здивувати багатьох програмістів, так що зазвичай краще уникати повернення значень з твердження <code>finally</code>. Кращий спосіб думати про блок <code>finally</code>, як про спосіб переконатись, що відбувся деякий побічний ефект, такий як зачинення відкритого файлу.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_7_5__match">7.5 Вирази match</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala вираз <code>match</code> дозволяють вам обрати з декількох альтернатив, так само, як твердження <code>switch</code> в інших мовах. Загалом, вираз <code>match</code> дозволяє вам зробити вибір, використовуючі довільні шаблони, що будуть описані в Главі 15. Загальна форма може почекати. Доки розглянемо тільки використання <code>match</code> для обрання між декількома альтернативами.</p></div>
<div class="paragraph"><p>Як приклад, скрипт в Лістингу 7.14 читає назву їжі зі списку аргументів, та друкує додаток до цієї їжі. Цей вираз <code>match</code> перевіряє <code>firstArg</code>, що була встановлена в перший аргумент зі списку аргументів. Якщо рядок є <code>"salt"</code>, друкується <code>"pepper"</code>, та якщо рядок <code>"chips"</code>, друкується <code>"salsa"</code>, і так далі. Випадок по замовчанню вказаний підкресленням (<code>_</code>), підстановочним символом, що часто використовується в Scala як заміщувач для повністю невідомого значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">firstArg</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
<span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`&quot;salt&quot;`</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pepper&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;chips&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;salsa&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">&quot;eggs&quot;</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;bacon&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;huh?&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.14 - Вираз <code>match</code> з побічними ефектами.</p></div>
<div class="paragraph"><p>Існує декілька важливих відмінностей від твердження Java <code>switch</code>. Одна в тому, що любий різновид констант, так само як і інших речей, може використовуватись в <code>case</code> в Scala, не тільки цілі типи, enum, та константи рядків в твердженнях Java <code>case</code>. В Лістингу 7.14 альтернативами є рядки. Інша відмінність в тому, що нема переривань <code>break</code> в кінці кожної альтернативи. Замість цього, <code>break</code> є неявним, і немає провалювання від однієї альтернативи до іншої. Загальний випадок — відсутність провалювання — стає коротший, та уникається джерело помилок, оскільки програмісти більше не провалюватимуться випадково.</p></div>
<div class="paragraph"><p>Однак найбільш значуща різниця з Java <code>switch</code> може полягати в тому, що вирази <code>match</code> повертають значення. В попередньому прикладі кожна з альтернатив в виразі <code>match</code> друкує значення. Також гарно буде робити повернення значення, ніж його друк, як показано в Лістингу  7.15. Значення, що є результатом цього виразу <code>match</code>, зберігається в змінній <code>friend</code>. Крім того, що код став коротший (в любому випадку за числом токенів), код тепер розрізняє дві різні турботи: спочатку він обирає їжу, та потім друкує її.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">firstArg</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">else</span> <span class="s">&quot;&quot;</span>
<span class="k">val</span> <span class="n">friend</span> <span class="k">=</span>
  <span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="s">&quot;salt&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;pepper&quot;</span>
    <span class="k">case</span> <span class="s">&quot;chips&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;salsa&quot;</span>
    <span class="k">case</span> <span class="s">&quot;eggs&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;bacon&quot;</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;huh?&quot;</span>
  <span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="n">friend</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.15 - Вираз <code>match</code>, що продукує значення.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_6___break__continue">7.6 Життя без break та continue</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви, можливо, помітили, що ми не споминули <code>break</code> або <code>continue</code>. Scala полишила ці дві команди, оскільки вони не дуже гарно перетинаються з функціональними літералами, можливістю, описаною в наступній главі. Ясно, що значить <code>continue</code> означає в циклі <code>while</code>,але що воно може значити в функціональному літералі? Хоча Scala підтримує обоє, імперативний та функціональний стилі програмування, в цьому випадку вона трохи схиляється до функціонального програмування, в обмін на спрощення мови. Однак не турбуйтесь. Існує багато шляхів програмувати без <code>break</code> та <code>continue</code>, та якщо ви отримаєте переваги функціональних літералів, ці альтернативи можуть часто бути коротші, ніж оригінальний код.</p></div>
<div class="paragraph"><p>Найпростіший підхід є замінити кожний <code>continue</code> на <code>if</code>, та кожний <code>break</code> на логічну змінну. Логічна змінна вказує, чи оточуючий цикл має продовжуватись. Наприклад, уявімо, що ви шукаєте в списку аргументів рядок, що закінчується на <code>".scala"</code> але не починається на дефіс. В Java ви можете — якщо ви великий прихильник циклів <code>while</code>, <code>break</code> та <code>continue</code> — написати наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="c1">// Це Java</span>
<span class="kt">boolean</span> <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">continue</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="o">{</span>
        <span class="n">foundIt</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб перекласти цей Java код прямо на Scala, замість робити <code>if</code> та потім <code>continue</code>, ви можете написати <code>if</code>, що оточує весь залишок цикла <code>while</code>. Щоб позбавитись <code>break</code>, ви можете звичайно додати логічну змінну, що вказує, чи варто продовжувати, але в цьому випадку ми можемо повторно використати <code>foundIt</code>. Викорисистовуючи обоє з ціх трюків, код приходить до вигляду, як показано на Лістингу 7.16.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="n">foundIt</span> <span class="k">=</span> <span class="kc">false</span>

<span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">foundIt</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span>
      <span class="n">foundIt</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="o">}</span>
  <span class="n">i</span> <span class="k">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.16 - Цикл без <code>break</code> або <code>continue</code>.</p></div>
<div class="paragraph"><p>Цей Scala код в Лістингу 7.16 досить подібний до оригінального Java коду. Всі базові частини все ще тут, і в тому ж порядку. Є дві переприсвоювані змінні та цикл <code>while</code>. В циклі є перевірка, що <code>i</code> менше ніж <code>args.length</code>, перевірка на <code>"-"</code>, та перевірка на <code>".scala"</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте позбутись <code>var</code> в Лістингу 7.16, один підхід, що ви можете спробувати, це переписати цикл як рекурсивну функцію. Ви можете, наприклад, визначити функцію <code>searchFrom</code>, що приймає ціле на вході, шукає з цього місця, та потім повертає індекс потрібного аргументу. Використовуючи цей прийом, код буде виглядати, як показано в Лістингу 7.17:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">args</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">))</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="n">endsWith</span><span class="o">(</span><span class="s">&quot;.scala&quot;</span><span class="o">))</span> <span class="n">i</span>
  <span class="k">else</span> <span class="n">searchFrom</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">i</span> <span class="k">=</span> <span class="n">searchFrom</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.17 - Рекурсивна альтернатива до циклів з <code>var</code>.</p></div>
<div class="paragraph"><p>Версія в Лістингу 7.17 дає змістовне ім'я тому, що робить функція, та вона використовує рекурсію для заміни циклу. Кожне <code>continue</code> замінюється рекурсивним викликом з аргументом <code>i + 1</code>, що ефективно просуває до наступного аргументу. Багато людей знаходять, що цей стиль програмування простіший для розуміння, як тільки вони переходять до використання рекурсії.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Компілятор Scala насправді не видасть рекурсивну функцію для коду, показаному на Лістингу 7.17. Оскільки всі рекурсівні виклики в позиції хвостового-виклику, компілятор буде генерувати код, подібний до циклу <code>while</code>. Кожний рекурсивний виклик буде реалізований як стрибок в зворотньому напрямку на початок функції. Оптимізація хвостового виклику обговорюється в Розділі 8.9.</td>
</tr></table>
</div>
<div class="paragraph"><p>Якщо після всієї цієї дискусії ви все ще потребуєте використовувати <code>break</code>, існує допомого з боку стандартної бібліотеки Scala. Клас <code>Breaks</code> в пакунку <code>scala.util.control</code> пропонує метод <code>break</code>, що може бути використаний для виходу з оточуючого блоку, що відмічений як <code>breakable</code>. Ось приклад, як може бути застосований цей наданий бібліотекою метод <code>break</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.util.control.Breaks._</span>
<span class="k">import</span> <span class="nn">java.io._</span>

<span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">in</span><span class="o">))</span>

<span class="n">breakable</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;? &quot;</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="n">readLine</span><span class="o">()</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="o">)</span> <span class="n">break</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде читати непусті рядки зі стандартного входу. Коли користувач введе порожній рядок, керування потоком вийде з оточуючого  <code>breakable</code>, і разом з цім з циклу <code>while</code>. Клас <code>Breaks</code> реалізує  <code>break</code> через закидання виключення, що перехоплюється оточуючим застосуванням метода <code>breakable</code>. Таким чином, виклик до <code>break</code> не обов'язково повинен бути в тому самому методі, що викликає <code>breakable</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_7___">7.7 Поле зору змінної</h2>
<div class="sectionbody">
<div class="paragraph"><p>Тепер, коли ви бачили вбудовані керівні структури Scala, ми будемо використовувати їх в цьому розділі для пояснення, як поле зору робить в Scala.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____java_">Швидкий шлях для Java програмістів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Якщо ви Java програміст, ви знайдете, що правила поля зору в Scala майже ідентичні до Java. Одна різниця між Java та Scala в тому, що  Scala дозволяє вам визначати змінні з тим самим ім'ям у вкладених блоках. Так що якщо ви Java програміст, ви маєте щанайменьше передивитись цей розділ.</p></div>
<div class="paragraph"><p>Декларації змінинх в Scala програмах мають поле зору, яке визначає, де ви можете використовувати ім'я. Найбільш загальни приклад поля зору полягаеє в тому, що фігурні дужки загалом вводять нове поле зору, так що будь-що, визначене в фігурних дужках виходить з поля зору після закриваючої фігурної дужки.<span class="footnote"><br />[Є декілька виключень з цього правила, оскільки в Scala ви іноді використовуєте фігурні дужки замість дужок. Один приклад цього різновиду використання фігурних дужок альтернативний синтаксис виразу <code>for</code>, описаний в Розділі 7.3.]<br /></span> Як ілюстрацію розгліянемо функцію, показану в Лістингу  7.18.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">printMultiTable</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>

  <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">1</span>
<span class="c1">// в полі зору тільки i</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="mi">1</span>
<span class="c1">// в полі зору i та j</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">j</span><span class="o">).</span><span class="n">toString</span>
<span class="c1">// в полі зору  i, j, prod</span>
      <span class="k">var</span> <span class="n">k</span> <span class="k">=</span> <span class="n">prod</span><span class="o">.</span><span class="n">length</span>
<span class="c1">// в полі зору i, j, prod, k</span>
      <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">print</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">print</span><span class="o">(</span><span class="n">prod</span><span class="o">)</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
 <span class="c1">// в полі зору i та j; prod та k вийшли</span>
  <span class="o">}</span>
  <span class="n">println</span><span class="o">()</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c1">// в полі зору все ще i; j, prod, k вийшли</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 7.18 - Поле зору змінних при друкуванні таблиці множення.</p></div>
<div class="paragraph"><p>Функція <code>printMultiTable</code>, показана в Лістингу 7.18, друкує таблицю множення.<span class="footnote"><br />[Функція <code>printMultiTable</code>, показана в Лістингу 7.18 написана в імперативному стилі. Ми зробимо її рефактор в функціональному стилі в наступному розділі.]<br /></span> Перше твердження цієї функції вводить змінну на ім'я <code>i</code>, та ініціалізує її цілим <code>1</code>. Потім ви можете використовувати ім'я <code>i</code> в залишку функції.</p></div>
<div class="paragraph"><p>Наступне твердження в <code>printMultiTable</code> є цикл <code>while</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="o">)</span> <span class="o">{</span>
<span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете використовутати тут <code>i</code> також, бо вона все ще в полі зору. В першому твердженні в циклі <code>while</code> ви вводите іншу змінну, не цей раз з назвою <code>j</code>, та знову ініціалізуємо її в <code>1</code>. Оскільки змінна <code>j</code> була визначена в відкритих фігурних дужках циклу <code>while</code>, вона може бути вкористана тільки в циклі <code>while</code>. Якщо ви спробуєте зробити щось з <code>j</code> після зачинення фігурних дужок цикла <code>while</code>, після коментаря, що каже, що <code>j</code>, <code>prod</code>, та <code>k</code> за полем зору, ваша програма не буде компілюватись.</p></div>
<div class="paragraph"><p>Всі змінні, визначені в цьому прикладі — <code>i</code>, <code>j</code>, <code>prod</code>, <code>k</code> — є локальними змінними. Такі змінні "локальні" для функції, в якій вони визначені. Кожного разу, коли функція викликається, використовується новий набір локальних змінних.</p></div>
<div class="paragraph"><p>Коли змінна визначена, ви не можете визначити нову змінну з тим самим ім'ям в тому ж самому полі зору. Наприклад, наступний скрипт з двома змінними на ім'я <code>a</code> в тому ж полі зору не буде компілюватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span>
<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// Не компілюється</span>
<span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З іншого боку ви можете визначити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. Наступний скрипт буде компілюватись та виконуватись:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span> <span class="c1">// Чудово компілюється</span>
  <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
<span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>При виконанні показаний перед цім скрипт буде друкувати 2, та потім 1, оскільки <code>a</code> визначене в фігурних дужках, є іншою змінною, яка в полі зору доки не будуть закриті фігурні дужки.<span class="footnote"><br />[Доречі, в цьому випадку крапка з комою є необхідними після першого визначення <code>a</code>, оскільки механізм виводу крапки з комою Scala не буде ставити її в цьому випадку.]<br /></span> Одна різниця між Scala та Java в тому, що Java не дозволить вам створити змінну у внутрішньому полі зору, що має те саме ім'я, що і змінна в зовнішньому полі зору. В програмі Scala внутрішня змінна, як кажуть, <em>затінює</em> змінну з таким же ім'ям, оскільки зовнішня змінна стає невидимою у внутрішньому полі зору.</p></div>
<div class="paragraph"><p>Ви могли вже зазначити в інтерпретаторі дещо, що виглядає як затінення, :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span>
<span class="n">a</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
<span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>В інтерпретаторі ви можете повторно використовувати імена змінних за покликом вашого серця. Поміж інших речей, це дозволяє вам змінити вашу думку, якщо ви зробили помилку, коли перший раз визначали змінну в інтерпретаторі. Ви можете робити це, бо інтерпретатор відкриває нове вкладене поле зору для кожного нового твердження, яке ви набираєте. Таким чином, ви можете віалізувати попередній інтерпретований код так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">{</span>
  <span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">2</span><span class="o">;</span>
  <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код буде компілюватись та виконуватись як Scala скрипт, та, як і код, набраний в інтерпретаторі, буде друкувати 2. Майте на увазі, що такий код буде дуже бентежливий для читачів, оскільки імена змінних приймають нові значення у вкладених полях зору. Зазвичай краще створити нове, осмислене ім'я, ніж затінювати зовнішню змінну.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_8_____">7.8 Рефакторинг коду в імперативному стилі</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб допомогти вам отримати уявлення про функціональний стиль, в цьому розділі ми зробимо рефакторинг імперативного підходу до друку таблиці множеннчя, показаного в Лістингу 7.18. Наша функціональна альтернатива показана на Лістингу 7.19.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Повертає рядок як послідовність</span>
<span class="k">def</span> <span class="n">makeRowSeq</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">col</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span> <span class="k">yield</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">prod</span> <span class="k">=</span> <span class="o">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">col</span><span class="o">).</span><span class="n">toString</span>
    <span class="k">val</span> <span class="n">padding</span> <span class="k">=</span> <span class="s">&quot; &quot;</span> <span class="o">*</span> <span class="o">(</span><span class="mi">4</span> <span class="o">-</span> <span class="n">prod</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
    <span class="n">padding</span> <span class="o">+</span> <span class="n">prod</span>
  <span class="o">}</span>

<span class="c1">// Повертає рядок як рядок</span>
<span class="k">def</span> <span class="n">makeRow</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">makeRowSeq</span><span class="o">(</span><span class="n">row</span><span class="o">).</span><span class="n">mkString</span>

<span class="c1">// Повертає таблицю як рядок</span>
<span class="k">def</span> <span class="n">multiTable</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">tableSeq</span> <span class="k">=</span> <span class="c1">// послідовність сирих рядків</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">row</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span><span class="o">)</span>
      <span class="k">yield</span> <span class="n">makeRow</span><span class="o">(</span><span class="n">row</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="n">tableSeq</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;\n&quot;</span><span class="o">)</span><span class="nc">Listing</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>7.19 - Функціональний спосіб створити таблицю множення.</p></div>
<div class="paragraph"><p>Імперативний стиль виявляє себе в Лістинуг 7.18 в два способи. Перше, виклик <code>printMultiTable</code> має побічний ефект: друк таблиці множення на стандартний вивід. В Лістингу 7.19 ми зробили рефакторинг функції, так що вона повертає таблицю множення як рядок. Оскільки функція більше не друкує, ми переіменували її на <code>multiTable</code>. Як зазначалось до цього, одна з переваг функцій, вільних від побічних ефектів, в тому, що їх легче тестувати. Щоб протестувати <code>printMultiTable</code>, вам знадобиться якось перевизначити <code>print</code> та <code>println</code>, так що ви зможете перевірити вивід на коректність. Ви можете тестувати <code>multiTable</code> більш просто, перевіряючи рядок її результата.</p></div>
<div class="paragraph"><p>Інший промовистий знак імперативного стилю в <code>printMultiTable</code> є її цикл <code>while</code> та <code>var</code>. Для контрасту, функція <code>multiTable</code> використовує <code>val</code>, вирази <code>for</code>, допоміжні функції та виклики до <code>mkString</code>.</p></div>
<div class="paragraph"><p>Ми виділили дві допоміжні функції, <code>makeRow</code> та <code>makeRowSeq</code>, щоб спростити читанян кода. Функція <code>makeRowSeq</code> використовує вираз <code>for</code>, чий генератор ітерує по номерах стовпчиків від 1 до 10. Тіло цього <code>for</code> обчислює добуток рядка та стовпчика, визначає відступ для результату, та видає результат конкатенації рядків відступу та добутку. Результатом виразу <code>for</code> буде послідовність (деякий субклас <code>scala.Seq</code>), до міститиме ці отримані рядки як елементи. Інша допоміжна функція, <code>makeRow</code>, просто викликає <code>mkString</code> на результаті, повернутому <code>makeRowSeq</code>. <code>mkString</code> буде конкатенувати рядки в послідовності, та поверне їх як один рядок.</p></div>
<div class="paragraph"><p>Метод <code>multiTable</code> зпочатку ініціалізує <code>tableSeq</code> результатом виразу <code>for</code>, чий генератор ітерує по номерах рядків від 1 до 10, та для кожного викликає <code>makeRow</code>, щоб отримати рядок. Цей рядок отримається через <code>yield</code>; так що результатом виразу буде послідовність рядків. Єдине завдання, що залишилось, це конвертувати рядки в один рядок. Це робить виклик <code>mkString</code>, та оскільки ми передаємо <code>"\n"</code>, ми отримуємо символ нового рядка між кожним рядком. Якщо ви передасте рядок, повернутий <code>multiTable</code>, до <code>println</code>, ви побачите той самий вивід, що продукує і виклик <code>printMultiTable</code>.</p></div>
<div class="literalblock">
<div class="content">
<pre><code> 1  2  3  4  5  6  7  8  9 10
 2  4  6  8 10 12 14 16 18 20
 3  6  9 12 15 18 21 24 27 30
 4  8 12 16 20 24 28 32 36 40
 5 10 15 20 25 30 35 40 45 50
 6 12 18 24 30 36 42 48 54 60
 7 14 21 28 35 42 49 56 63 70
 8 16 24 32 40 48 56 64 72 80
 9 18 27 36 45 54 63 72 81 90
10 20 30 40 50 60 70 80 90 100</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_7_9_">7.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Вбудовані керівні структури Scala є мінімальними, але вони роблять свою справу. Вони роблять подібно до своїх імперативних еквівалентів, але оскільки вони схильні повертати значення, вони також підтримують функціональний стиль. Що також важливо, вони уважні щодо того, що вони оминають, таким чином лишаючи простір для однієї з найбільш потужних можливостей Scala, функціональних літералів, що будуть описані в наступній главі.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-03 10:45:35 EET
</div>
</div>
</body>
</html>
