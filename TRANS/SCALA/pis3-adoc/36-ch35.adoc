include::headers.adoc[]

Глава 35
--------

Електронна таблиця SCells
=========================

В попередніх главах ви бачили багато різних конструкцій мови програмування Scala. В цій главі ви побачите, як ці конструкції грають разом в реалізації розширюваного застосування. Задачею буде написати застосування електронної таблиці, що матиме назву `SCells`.

Є багато причин, чому це завдання може бути цікавим. Для початку, кожний знає електронні таблиці, так що просто зрозуміти, що повинно робити застосування. Друге, електронні таблиці є програмами, що виконують великий диапазон різних обчислювальних завдань. Присутній візуальний аспект, де електронна таблиця є багатим GUI застосуванням. Існує символічний аспект, що має відношення до формул, та того, як розбирати та інтерпретувати їх. Є ообчислювальний аспект, що має справу з тим, як оновлювати можливо великі таблиці інкрементально. Існує реактивний аспект, коли таблиці розглядаються як програми, що реагують в інтерактивний спосіб на події. Нарешті існує компонентний аспект, коли застосування сконструйоване як набір компонентів повторного застосування. Всі ці аспекти будуть розглядатись в деталях в цій главі.

Малюнок 35.1 - Проста електронна таблиця.

35.1 Візуальний фреймворк
-------------------------
Ми почнемо з написання базового візуального фреймворка застосування. Малюнок 35.1 показує першу ітерацію користувацького інтерфейсу. Ви можете бачити, що електронна таблиця є прокручуваною таблицею. Вона має рядки від 0 до 99, та стовпчики від A до Z. Ви виражаєте це в Swing через визначення таблиці як `ScrollPane` що містить `Table`. Лістинг 35.1 показує код.
[source,scala]
----
package org.stairwaybook.scells
import swing._

class Spreadsheet(val height: Int, val width: Int)
    extends ScrollPane {

  val table = new Table(height, width) {
    rowHeight = 25
    autoResizeMode = Table.AutoResizeMode.Off
    showGrid = true
    gridColor = new java.awt.Color(150, 150, 150)
  }

  val rowHeader =
      new ListView((0 until height) map (_.toString)) {
    fixedCellWidth = 30
    fixedCellHeight = table.rowHeight   
  }

  viewportView = table
  rowHeaderView = rowHeader
}
----
Лістинг 35.1 - Код для електронної таблиці на Малюнку Figure 35.1.

Компонент електронної таблиці, показаний на Лістингу 35.1 визначений в пакунку `org.stairwaybook.scells`, що буде містити всі класи, трейти та об'єкти, що треба для застосування. Він імпортує з пакунка `scala.swing` основні елементи огортки Scala Swing. Сама таблиця є класом, що приймає як параметри висоту та ширину (в числі клітин). Клас розширює `ScrollPane`, що дає дві полоси прогрутки знизу та зправа на Малюнку 35.1. Він містить два субкомпонента на ім'я `table` та `rowHeader`.

Компонент `table` є примірником анонімного субкласа від класа `scala.swing.Table`. Чотири рядкі в його тілі встановлюють деякі атрибути: `rowHeight` для висоти рядка таблиці в пікселях, `autoResizeMode` для вимкнення авто-розміру таблиці, `showGrid` для показу решітки між клітинами, та `gridColor` для встановлення кольору решітки в темно сірий.

Компонент `rowHeader`, що містить заголовки стовпчиків зліва таблиці на Малюнку 35.1, є `ListView`, що відображує свої елементи з рядками від 0 до 99. Два рядка в його тілі фіксують ширину клітини до 30 пікселів, та висоту таку саму, як `rowHeight` таблиці.

Вся таблиця зібрана у встановлення двох полів в `ScrollPane`. Поле `viewportView` встановлене в `table`, та `rowHeaderView` встановлене в список `rowHeader`. Різниця між двома переглядами в тому, що поле перегляду панелі прокрутки є область, що прокручується двома лінійками, тоді як заголовки рядків зліва залишаються фіксованими коли ви рухаєте горизонтальну прокрутку. Через якусь примху Swing завжди надає по замовчанню заголовки стовпчиків зверху таблиці, так що немає потреби визначати їх явно.
[source,scala]
----
package org.stairwaybook.scells
import swing._

object Main extends SimpleSwingApplication {
  def top = new MainFrame {
    title = "ScalaSheet"
    contents = new Spreadsheet(100, 26)
  }
}
----
Лістинг 35.2 - Головна програма для застосування електронної таблиці.

Щоб спробувати рудиментарну таблицю, показану в Лістингу 35.1, вам тільи треба визначити головну програму, що створює компонент `Spreadsheet`. Така програма показана в Лістингу 35.2.

Програма `Main` наслідує від `SimpleSwingApplication`, що турбується про всі низькорівневі деталі, що мають бути встановлені перед тим, як Swing застосування може бути запущеним. Вам треба тільки визначити вікно вищого рівня для застосування в методі `top`. В нашому прикладі `top` є `MainFrame`, що має два визначених елементи: його заголовок, встановлений в `"ScalaSheet"`, та його `contents`, встановлений в клас `Spreadsheet` з 100 рядками та 26 стовпчиками. Це все. Якщо ви запустите це застосування зі `scala org.stairwaybook.scells.Main`, ви маєте побачити таблицю з Малюнка 35.1.

35.2 Роз'єднання вводу даних та відображення
--------------------------------------------
Якщо ви трохи пограєте з тільки що написаною таблицею, ви швидко помітите, що вивід, який вона продукує в клітині, завжди такий самий , який ви ввели в клітину. Справжня таблиця так не поводиться. В реальній електронній таблиці вам треба ввести формулу, і ви побачите значення. Так що те, що введено, відрізняється від того, що відображується.
[source,scala]
----
package org.stairwaybook.scells
import swing._

class Spreadsheet(val height: Int, val width: Int)
    extends ScrollPane {

  val cellModel = new Model(height, width)
  import cellModel._
  
  val table = new Table(height, width) {
  
  // як раніше...

  override def rendererComponent(isSelected: Boolean,
      hasFocus: Boolean, row: Int, column: Int): Component =
    if (hasFocus) new TextField(userData(row, column))
    else
      new Label(cells(row)(column).toString) {
        xAlignment = Alignment.Right
      }
    def userData(row: Int, column: Int): String = {
      val v = this(row, column)
      if (v == null) "" else v.toString
    }
  }
// решта як раніше...
}
----
Лістинг 35.3 - Електронна таблиця з методом `rendererComponent`.

Як перший крок до справжнього застосування електронної таблиці вам слідує сконцентруватись на розділенні елементу даних та відображення. Базовий механізм для відображення міститься в методі  `rendererComponent` класу `Table`. По замовчанню `rendererComponent` завжди відображує те, що введене. Якщо ви бажаєте змінити це, вам треба перекрити `rendererComponent` на щось інше. Лістинг 35.3 показує нову версію `Spreadsheet` з методом `rendererComponent`.

Метод `rendererComponent` перекриває метод по замовчанню в класі `Table`. Він приймає чотири параметри. Параметри `isSelected` та `hasFocus` є `Boolean`, що вказують, чи клітина була вибрана, та чи вона має фокус, що означає, що ввод клавіатури пійде в клітину. Інші два параметри, `row` та `column`, дають координати клітини.

Новий метод `rendererComponent` перевіряє, чи клітина має фокус вводу. Якщо `hasFocus` є `true`, клітина використовується для редагування. В цьому випадку ви бажаєте відображати редагуємий `TextField`, що містить дані, що користувач ввів останнього разу. Ці дані повертаються допоміжним методом `userData`, що відображує вміст таблиці за наданим рядком та стовпчиком. Вміст отримується викликом  `this(row, column)`.footnote:[Хоча `this(row, column)` може виглядати подібно до виклику конструктора, в цьому випадку це виклик метода `apply` на поточному примірнику `Table`.] Метод `userData` також турбується про відображення елемента `null` як порожнього рядка замість `"null"`.

Докі все добре. Але що має відображатись, якщо клітина не має фокуса? В реальній таблиці це має бути значення клітини. Таким чином, насправді тут роблять дві таблиці. Перша на ім'я `table` містить те, що ввів користувач. Друга "тіньова" таблиця містить внутрішню репрезентацію клітин, та що має бути відображено. В прикладі електронної таблиці ця таблиця є двовимірним масивом на ім'я `cells`. Якщо клітина на заданому рядку та стовпчику не має фокусу редагування, метод `rendererComponent` буде відображувати елемент `cells(row)(column)`. Елемент не може бути відредагований, так що він буде відображатись в `Label` замість `editableTextField`.

Залишається визначити внутрішній масив клітин. Ви можете зробити цце напряму в класі `Spreadsheet`, але загалом бажано розділяти перегляд GUI компонент від їх внутрішньої моделі. Ось чому в прикладі вище масив клітин визначений в окремому класі на ім'я `Model`. Модель інтегрована в `Spreadsheet` через визначення значення `cellModel` з типом `Model`. Твердження `import`, що слідує за цім визначенням `val`, робить члени `cellModel` доступні без потреби ставити префікс. Лістинг 35.4 показує першу, спрощену версію класу `Model`. Клас визначає внутрішній клас `Cell`, та двовимірний масив `cells` з елементів `Cell`. Кожний елемент ініціалізований як новий примірник `Cell`.
[source,scala]
----
package org.stairwaybook.scells

class Model(val height: Int, val width: Int) {

  case class Cell(row: Int, column: Int)

  val cells = Array.ofDim[Cell](height, width)

  for (i <- 0 until height; j <- 0 until width)
    cells(i)(j) = new Cell(i, j)
}
----
Лістинг 35.4 - Перша версія класу `Model`.

Малюнок 35.2 - Клітини відображують себе.

Ось і все. Якщо ви скомпілюєте модифікований клас `Spreadsheet` з класом `Model`, та запустите застосування `Main`, ви повинні побачити вікно як на Малюнку 35.2. 

Ціллю цього розділу було отримати дизайн, де відображене значення клітини відрізняється від тексту, що був в неї введений. Ця ціль очевидно була досягнута, хоча і в дуже сирий спосіб. В новій таблиці ви можете ввести будь-що в клітину, але вона буде завжди відображувати тільки свої координати, коли втратить фокус. Ясно, що ми ще не закінчили.

35.3 Формули
------------
В реальності електронна таблиця містить дві речі: поточне значення та формулу для обчислення цього значення.

Існує три типи формул в електронних таблицях:

1. Числові значення, як `1.22`, `-3` або `0`.

2. Текстові мітки, як `"Річний звіт"`, `"Амортизація"` або `"Загалом"`.

3. Формули, що обчислюють нові значення від вмісту клітин, як `=add(A1,B2)` або `=sum(mul(2, A2), C1:D16)`

Формула, що обчислює значення, завжди починається зі знаку рівняння, за яким слідує арифметичний вираз. Електронна таблиця `SCells` має виключно просту та уніформну угоду щодо арифметичних виразів: кожний вираз є застосуванням деякої функції до списку аргументів. Ім'я функції є ідентифікатор, такий як `add` для двомісного додавання, або `sum` для підсумку довільного числа операндів. Аргументом функції може бути число, посилання на клітину, посилання на диапазон клітин, такий як `C1:D16`, або інше застосування функції. Ви побачите пізніше, що `SCells` має відкриту архитектуру, що спрощує встановлення ваших власних функцій через композицію міксінів.

Перший крок до обробки формул є написання типів, що будуть їх представляти. Як ви можете очікувати, різні типи формул представлені кейс класами. Лістинг 35.5 показує вміст файла на ім'я `Formulas.scala`, де ці класи представлені:
[source,scala]
----
package org.stairwaybook.scells

trait Formula

case class Coord(row: Int, column: Int) extends Formula {
  override def toString = ('A' + column).toChar.toString + row
}
case class Range(c1: Coord, c2: Coord) extends Formula {
  override def toString = c1.toString + ":" + c2.toString
}
case class Number(value: Double) extends Formula {
  override def toString = value.toString
}
case class Textual(value: String) extends Formula {
  override def toString = value
}
case class Application(function: String,
    arguments: List[Formula]) extends Formula {
  override def toString =
    function + arguments.mkString("(", ",", ")")
}

object Empty extends Textual("")
----
Лістинг 35.5 - Класи, що представляють формули.

Трейт `Formula`, показаний в Лістингу 35.5, має п'ять кейс класів в якості дітей:

`Coord` для координат клітин, як `A3`,
`Range` для диапазонів клітин, як `A3:B17`,
`Number` для чисел з плаваючою комою, як `3.1415`,
`Textual` для текстуальних міток, як `"Амортизація"`,
`Application` для застосувань функцій, як `sum(A1,A2)`.

Кожний кейс клас перекриває метод `toString`, так що він відображує свій різновид формули в стандартний спосіб, показаний вище. Для зручності також є об'єкт `Empty`, що представляє вміст порожньої клитини. Об'єкт `Empty` є примірником класу `Textual` з порожнім аргументом рядка.

35.4 Розбір формул
------------------
В попередньому розділі ви бачили різні різновиди формул, та як вони виглядають в вигляді рядків. В цьому розділі ви побачите, як обернути цей процес: як трансформувати рядок користувацького ввооду в дерево  `Formula`. Решта цього розділу пояснює один по одному різні елементи класу `FormulaParsers`, що містить парсери, що виконують перетворення. Клас побудований на фреймворку комбінаторів, наданому в Главі 33. А саме, парсери формул є примірниками класу `RegexParsers`, поясненому в тій главі:
[source,scala]
----
package org.stairwaybook.scells
import scala.util.parsing.combinator._

object FormulaParsers extends RegexParsers {
----
Перші два елементи об'єкта `FormulaParsers` є додатковими парсерами для ідентифікаторів та десятичних чисел:
[source,scala]
----
def ident: Parser[String] = """[a-zA-Z_]\w*""".r
def decimal: Parser[String] = """-?\d+(\.\d*)?""".r
----
Як ви можете бачити з першого регулярного виразу вище, ідентифікатор починається з літери або підкреслення. За цім іде довільна кількість "словних" символів, представлених кодом регулярного виразу `\w`, що розпізнає літери, цифри та підкреслення. Другий регулярний вираз описує десятичні числа, що складаються з опціонального знаку мінусу, однієї або більше цифри, що представлені кодом регулярного виразу `\d`, та опціонально десяткової частини, що складається з крапки, за якою іде одна або більше цифр.

Наступний елемент об'єкта `FormulaParsers` є парсер клітин, що розпізнає координати клітини, такі як `C11` або `B2`. Спочатку він викликає парсер регуляних виразів, що визначає форму координат: одна літера та одна або більше цифр. Повернутий з цього парсера рядок потім перетворюється на координати клітини, через відділення літери від числової частини, та перетворення обох частин на індекси для клітини, для отримання стовпчика та рядка клітини:
[source,scala]
----
def cell: Parser[Coord] =
  """[A-Za-z]\d+""".r ^^ { s =>
    val column = s.charAt(0).toUpper - 'A'
    val row = s.substring(1).toInt
    Coord(row, column)
  }
----
Зауважте, що парсер клітини є дещо обмежувальним в тому, що він дозволяє координати стовпчика тільи з однієї літери. Таким чином число стовпчиків таблиць ефективно обмежене до щонайбільше 26, оскількі подальші стовпчики не можуть бути розібрані. Є гарною ідеєю узагальнити парсер так, щоб він сприймав клітини з декільками ведучими літерами. Це залишається вам як практична вправа. 

Парсер диапазонів розпізнає диапазон клітин. Такий диапазон складається з двох координат клітин з двокрапкою між ними:
[source,scala]
----
def range: Parser[Range] =
  cell~":"~cell ^^ {
    case c1~":"~c2 => Range(c1, c2)
}
----
Парсер чисел розпізнає десятичні числа, що конвертуються до `Double` та огортаються в примірник класу `Number`:
[source,scala]
----
def number: Parser[Number] =
  decimal ^^ (d => Number(d.toDouble))
----
Парсер застосувань розпізнає застосування функції. Таке застосування складається з ідентифікатора, за яким іде список виразів аргументів в дужках:
[source,scala]
----
def application: Parser[Application] =
  ident~"("~repsep(expr, ",")~")" ^^ {
    case f~"("~ps~")" => Application(f, ps)
  }
----
Парсер `expr` розпізнає вираз формули — або високорівневу формулу, що іде за `=`, або аргумент до функції. Такий формульний вираз визначений бути клітиною, диапазоном клітин, числом або застосуванням:
[source,scala]
----
def expr: Parser[Formula] =
  range | cell | number | application
----
Це визначення парсера `expr` містить надспрощення, оскільки диапазони клітин повинні з'являтись тільки як аргументи функцій; вони не повинні бути дозволені як високорівневі формули. Ви можете змінити граматику формули так, щоб в ній два використання виразів було розділені, та диапазони синтаксично були видалені з високорівневих формул. В представленій тут електронній таблиці замість цього така помилка детектується при обчисленні виразу.

Текстуальний парсер розпізнає довільний вхідний рядок, докі він не починається зі знака рівності (нагадаємо, що рядки, що посинаються з `=` розглядаються як формули):
[source,scala]
----
def textual: Parser[Textual] =
  """[^=].*""".r ^^ Textual
----
Парсер формул розпізнає всі різновиди легального вводу в клітину. Формула є або число, або текстуальний елемент, або формула, що починається з рядка рівності:
[source,scala]
----
def formula: Parser[Formula] =
  number | textual | "="~>expr
----  
Це складає граматику для клітин електронної таблиці. Фінальний метод `parse` використовує цю граматику в методі, що конвертує вхідні рядкі в дерево `Formula`:
[source,scala]
----
def parse(input: String): Formula =
  parseAll(formula, input) match {
    case Success(e, _) => e
    case f: NoSuccess => Textual("[" + f.msg + "]")
  }
} // кінець FormulaParsers
----
Метод `parse` розбирає весь вхід за допомогою парсера формул. Якщо він успішний, повертається результуюча формула. Якщо він схибить, замість цього буде повертатись об'єкт `Textual` з повідомлення про помилку.
[source,scala]
----
package org.stairwaybook.scells
import swing._
import event._

class Spreadsheet(val height: Int, val width: Int) ... {
  val table = new Table(height, width) {
    ...
    reactions += {
      case TableUpdated(table, rows, column) =>
        for (row <- rows)
          cells(row)(column).formula =
            FormulaParsers.parse(userData(row, column))
    }
  }
}
----
Лістинг 35.6 - Таблиця, що парсить формули.

Це все, що треба для парсинга формул. Єдина річ, що залишається - це інтегрувати парсер в таблицю. Щоб зробити це, ви маєте збагатити клас `Cell` в класі `Model` полем `formula`:
[source,scala]
----
case class Cell(row: Int, column: Int) {
  var formula: Formula = Empty
  override def toString = formula.toString
}
----
В новій версії класу `Cell` метод `toString` визначений для відображення формули клітини. Такім чином ви можете перевірити, чи були формули розібрані коректно.

Останній крок в цьому розділі є інтеграція парсера в таблицю. Розбір формули відбувається як реакція на користувацький ввод в клітину. Завершений ввод в клітину моделюється в бібліотеці Swing подією `TableUpdated`. Клас `TableUpdated` міститься в пакунку `scala.swing.event`. Подія має форму:
[source,scala]
----
TableUpdated(table, rows, column)
----
Вона містить таблицю, що була змінена, так само як набір координат задіяних клітин, наданих як `rows` та `column`. Параметр `rows` є значенням диапазону типу `Range[Int]`.footnote:[Range[Int\] є також типом Scala виразу, такого як "1 to N". Це має на увазі, що між клітинами немає циклічних залежностей. Ми обговоримо відкидання цього припущення в кінці цієї глави.] Параметр `column` є цілим. Так що загалом подія `TableUpdated` може посилатись на декілька задіяних клітин, але вони можуть бути на послідовному диапазоні рядків, та поділяти той самий стовпчик.

Малюнок 35.3 - Клітини, що відображують свої формули.

Як тільки таблиця зміниться, відповідні клітини мають бути пере-розбрані. Щоб реагувати на подію `TableUpdated`, ви додаєте `case` до значення `reactions` компонента таблиці, як показано в Лістингу 35.6. Тепер, коли таблиця відредагована, формули всіх задіяних клітин будуть оновлені через парсинг відповідних користувацьких даних. Коли скомпілювати класи, що описані дотепер, та запустити застосування `scells.Main`, ви маєте застосування електронної таблиці, таке як показане на Малюнку 35.3. Ви можете редагувати клітини вводячи в них текст. Після завершення редагування клітина відображує формулу, яку вона містить. Ви також можете спробувати ввести якісь нелегальний ввод, наприклад `=add(1, X)` в поле, що має фокус редагування на Малюнку 35.3. Нелегальний ввоод покаже повідомлення про помилку. Наприклад, як тільки ви залишите редаговане поле на Малюнку 35.3, ви повинні побачити в клітині повідомлення `"['(' expected]"` (щоб побачити все повідомлення про помилку вам може знадобитись розширити стовпчик через перетаскування роздільника між заголовками стовпчиків вправо).

35.5 Обчислення
---------------
Звичайно, в кінці електронна таблиця повинна обчислити формули, а не тільки відображати їх. Щоб досягти цього в цьому розділі ми додамо потрібні компоненти.

Що нам треба, це метод `evaluate`, що приймає формулу, та повертає значення формули в поточній електронній таблиці, представлене як `Double`. Ми покладемо цей метод в новий трейт `Evaluator`. Методу буде потрібно отримувати доступ до полей клітин в класі `Model`, що з'ясувати поточні значення клітин, на які є посилання в формулі. З іншого боку, клас `Model` має викликати `evaluate`. Таким чином є взаємна залежність між `Model` та `Evaluator`. Гарний спосіб виразити таку взаємну залежність між класами показаний в Главі 29: ви використовуєте наслідування в одному напрямуку, та типи `self` в іншому.

В прикладі електронної таблиці клас `Model` наслідує від `Evaluator`, і таким чином отримує доступ до метода `evaluation`. Щоб пійти в іншому напрямку, клас `Evaluator` визначає свій тип `self` як `Model`, ось так:
[source,scala]
----
package org.stairwaybook.scells
trait Evaluator { this: Model => ...
----
Таким чином значення `this` в класі `Evaluator` вважається `Model` , та масив клітин доступні через писання або в `cells` або в `this.cells`.

Тепер, коли підключення зроблене, ми сконцентруємось на визначенні вмісту класу `Evaluator`. Лістинг 35.7 показує реалізацію метода `evaluate`. Як ви можете очікувати, метод містить порівняння шаблонів по різних типах формул. Для координати `Coord(row, column)` він повертає значення масиву `cells` в цій координаті. Для числа `Number(v)` він повертає значення `v`. Для текстуальної мітки `Textual(s)` він повертає нуль. Нарешті для застосування `Application(function, arguments)` він обчислює значення для всіх аргументів, отримує об'єкт функції, відповідний до назви функції, з таблиці операцій, та застосовує цю функцію до всіх значень аргументів.
[source,scala]
----
def evaluate(e: Formula): Double = try {
  e match {
    case Coord(row, column) =>
      cells(row)(column).value
    case Number(v) =>
      v
    case Textual(_) =>
      0
    case Application(function, arguments) =>
      val argvals = arguments flatMap evalList
      operations(function)(argvals)
  }
} catch {
  case ex: Exception => Double.NaN
}
----
Лістинг 35.7 - Метод `evaluate` трейта `Evaluator`.

Таблиця `operations` відображує імена функцій на об'єкти функцій. Вона визначена таким чином:
[source,scala]
----
type Op = List[Double] => Double
val operations = new collection.mutable.HashMap[String, Op]
----
Як ви можете бачити з цього визначення, операціх змодельовані як функції від списків значень на значення.

Тип `Op` вводить зручний псевдоним для типу операції.

Обчислення в `evaluate` огорнутий в `try-catch` для захисту проти помилок вводу. Насправді є декілька речей, що можуть пійти не так при обчисленні формули клітини: координати можуть бути за межами; імена функцій можуть бути невизначені; функції можуть мати невірне число аргументів; арифметичні операції можуть бути нелегальні або викликати переповнення. Реакція на любу з ціх помилок така сама: повертається значення "not-a-number". Повернуте значення `Double.NaN` є IEEE репрезентацією для обчислення, що не має відповідного значення з плаваючою комою. Це може статись через переповнення або ділення на ноль, як приклад. Метод `evaluate` з Лістинга 35.7 обирає повертати те саме значення для всіх різновидів помилок. Перевага цієї схеми в тому, що її просто зрозуміти, та вона не потребує багато коду для реалізації. Її недолік в тому, що всі помилки зліплені докупи, так що користувач на має жодного детального зворотнього зв'язка по тому, що пішло не так. Якщо ви бажаєте, ви можете поекспериментувати з більш покращеними способами представляти помилки в застосуванні `SCells`.

Обчислення аргументів відрізняється від обчислення високорівневих формул. Аргументи можуть бути списками, тоді як високорівневі функції ні. Наприклад, вираз аргументів `A1:A3` в `sum(A1:A3)` повертає значення рядків `A1`, `A2`, `A3` в списку. Цей список потім передається в операцію `sum`. Можливо міксувати списки та окремі значення в виразах аргументів, наприклад, як робить операція `sum(A1:A3, 1.0, C7)`, що підраховує суму п'яти елементів. Щоб обробляти аргументи, що можуть бути обчислені як списки, є інша функція обчислення, `evalList`, що приймає формулу та повертає список значень:
[source,scala]
----
private def evalList(e: Formula): List[Double] = e match {
  case Range(_, _) => references(e) map (_.value)
  case _ => List(evaluate(e))
}
----
Якщо аргумент формула, передана до `evalList` є `Range`, повертається значення-список, що містить список всіх значень, представлених диапазоном. Для кожної іншої формули результат буде список, що складається з єдиного значення результату цієї формули. `cells`, на який посилається формула, обчислюється третьою функцією, `references`. Ось її визначення:
[source,scala]
----
def references(e: Formula): List[Cell] = e match {
  case Coord(row, column) =>
    List(cells(row)(column))
  case Range(Coord(r1, c1), Coord(r2, c2)) =>
    for (row <- (r1 to r2).toList; column <- c1 to c2)
      yield cells(row)(column)
  case Application(function, arguments) =>
    arguments flatMap references
  case _ =>
    List()
}
} // кінець Evaluator
----
Метод `references` насправді більш загальний, ніж треба прямо зараз, в тому, що він обчислює список клітин, на який посилається любий різновид формули, не тільки формула `Range`. Пізніше з'ясується, що додана функціональність потрібна для обчислення наборів клітин, що мають бути оновлені. Тіло метода є прямолінійним співпадінням шаблонів на різних типах формул. Для координати `Coord(row, column)` він повертає одноелементний список, що містить клітину з такими координатами. Для виразів диапазону `Range(coord1, coord2)` він повертає всі клітини між ціма двома координатами, обчислені `for` виразом. Для застосування функції `Application(function, arguments)` він повертає клітини, на які посилається кожний вираз аргументів, сконкатеновані через `flatMap` в єдиний список. Для двох інших типів формул, `Textual` та `Number`, він повертає порожній список.

35.6 Бібліотеки операцій
------------------------
Клас `Evaluator` сам не визначає операцій, що можуть бути виконані на клітинах: його таблиця `operations` спочатку порожня. Ідея полягає в визначення таких операцій в інших трейтах, що потім міксуються в клас `Model`. Лістинг 35.8 показує приклад трейта, що реалізує загальні арифметичні операції:
[source,scala]
----
package org.stairwaybook.scells
trait Arithmetic { this: Evaluator =>
  operations += (
    "add" -> { case List(x, y) => x + y },
    "sub" -> { case List(x, y) => x - y },
    "div" -> { case List(x, y) => x / y },
    "mul" -> { case List(x, y) => x * y },
    "mod" -> { case List(x, y) => x % y },
    "sum" -> { xs => (0.0 /: xs)(_ + _) },
    "prod" -> { xs => (1.0 /: xs)(_ * _) }
  )
}
----
Лістинг 35.8 - Бібліотека для арифметичних операцій.

Цікаво, що цей трейт не має експортованих членів. Єдина річ, що він робить, це заповнює таблицю під час ініціалізації. Він отримує доступ до цієї таблиці через використання типу `self` `Evaluator`, тобто через ту саму техніку, яку використовує клас `Arithmetic` для доступу до моделі. З сіми операцій, що визначені в трейті `Arithmetic`, п'ять є двомісними операціями, та дві приймають довільне число аргументів. Всі двомісні операції слідують тій самій схемі. Наприклад, операція додавання `add` визначена виразом:
[source,scala]
----
{ case List(x, y) => x + y }
----
Тобто вона очікує список аргументів, що складається з двох елементів `x` та `y`, та повертає суму `x` та `y`. Якщо аргумент списку містить кількість елементів, що не дорівнює двом, закидається `MatchError`. Це відповідає до загальної філософії `"let it crash"` моделі обчислення `SCell`, де некоректний ввод очікувано приводить до виключення часу виконання, що потім перехоплюється в `try-catch` метода `evaluation`.

Дві останні операції, `sum` та `prod`, приймають список аргументва довільної довжини та вставляють двомісну операцію між послідовними елементами. Так що вини є примірниками схеми "лівої згортки", що в класі `List` виражається операцією `/:`. Наприклад, щоб підсумувати список чисел `List(x, y, z)`, операція обчислює `0 + x + y + z`. Перший операнд, 0, є результатом, якщо список порожній.

Ви можете інтегрувати цю бібліотеку операцій в електронну таблицю через міксування трейта `Arithmetic` в клас `Model`, таким чином:
[source,scala]
----
package org.stairwaybook.scells

class Model(val height: Int, val width: Int)
    extends Evaluator with Arithmetic {

  case class Cell(row: Int, column: Int) {
    var formula: Formula = Empty
    def value = evaluate(formula)
    override def toString = formula match {
      case Textual(s) => s
      case _ => value.toString
    }
  }
}
... // решта як раніше
----
Інша зміна в класі `Model` стосується шляху, як клітини відображують себе. В новій версії відображувані значення клітини залежать від її формули. Якщо формула є полем `Textual`, вміст поля відображується буквально. У всіх інших випадках вормула обчислюється та відображується результуюче значення ціх обчислень.

Малюнок 35.4 - Клітини, що обчислюються.

Якщо ви скомпілюєте змінені трейти та класи, та перезапустите програму `Main`, ви отримаєте дещо, що починає скидатись на електронну таблицю. Ви можете ввести формули в клітини та отримати їх переобчисленими. Наприклад, як тільки ви закриєте фокус вводу на клітині `C5` з Малюнка 35.4, в побачите `86.0`, результат обчислення формули `sum(C1:C4)`.

Однак досі відсутній ключовий момент. Якщо ви зміните значення клітини `C1` на Малюнку 35.4 з `20` на `100`, сума в клітині `C5` не буде автоматично оновленою до `166`. Вам буде треба клацнути на `C5` вручну, щоб побачити зміну в її значенні. Ось чого бракує, це способа мати переобчислення значень клітин автоматично після змін.

35.7 Змінене просування
-----------------------
Якщо значення клітини змінилось, всі клітини, що залежать від її значення, мають перерахувати та висвітити своє значення. Найпростіший шлях зробити це буде переобчислити значення кожної клітини в таблиці після кожної зміни. Але такий підхід не дуже гарно маштабується по мірі того, як таблиця зростатиме в розмірі.

Кращий підхід є переобчислити значення тільки тих клітин, що посилаються на змінену клітину в своїх формулах. Ідея є використати базований на подіях фреймворк `publish/subscribe` для зміни просування: як тільки клітина отримує формулу, вона підписується на повідомлення від всіх змін значень в клітинах, до яких посилається формула. Зміна значення в одній з ціх клітин буде перемикати переобчислення клітини підписчика. Якщо таке переобчислення спричинить зміну значення клітини, вона в свою чергу повідомить всі клітини, що залежать від неї. Цей процес продовжиться, доки всі значення клітин не стабілізуються, тобто не буде змін в значеннях любої з клітин.footnote:[Це вважає, що немає циклічних залежностей між клітинами. Ми обговоримо це припущення в кінці цієї глави.]

Фреймворк публікації/підписки реалізований в класі `Model` з використанням стандартного механізму подій фреймворка Scala Swing. Ось нова (і фінальна) версія цього класу:
[source,scala]
----
package org.stairwaybook.scells
import swing._

class Model(val height: Int, val width: Int)
    extends Evaluator with Arithmetic {
----
Порівняно з попередньою версією `Model`, ця версія додає новий `import swing._`, що робить абстракцію подій Swing безпосередньо доступною.

Головна модифікація класу `Model` стосується вкладеного класу `Cell`. Клас `Cell` тепер наслідує від `Publisher`, так що ми можемо публікувати події. Логіка обробки подій повністю міститься в сеттерах двох властивостей: `value` та `formula`. Ось нова версія `Cell`:
[source,scala]
----
case class Cell(row: Int, column: Int) extends Publisher {
  override def toString = formula match {
    case Textual(s) => s
    case _ => value.toString
  }
----
Зовні виглядає, що `value` та `formula` є дві змінні класу `Cell`. Їх справжня реалізація є в термінах двох приватних полів, що обладнані публічними геттерами `value` та `formula`, та сеттерами, `value_=` та `formula_=`. Ось визначення, що реалізують властивість `value`:
[source,scala]
----
private var v: Double = 0
def value: Double = v
def value_=(w: Double) = {
  if (!(v == w || v.isNaN && w.isNaN)) {
    v = w
    publish(ValueChanged(this))
  }
}
----
Сеттер `value_=` присвоює нове значення `w` приватному полю `v`. Якщо нове значення відрізняється від старого, він також публікує подію `ValueChanged` з самою клітиною в якості аргумента. Зауважте, що перевірка, чи значення змінилось, є трохи заплутаним, бо включає значення `NaN`. Специфікація Java каже, що `NaN` є відмінним від любого іншого значення, включаючи себе! Таким чином, перевірка чи два значення є такі самі має трактувати `NaN` особливо: два значення `v`, `w` є такі самі, якщо вони рівні з точки зору `==`, або вони обоє є `NaN`, тобто `v.isNaN` та `w.isNaN` обоє дають `true`.

Кожного разу, коли сеттер `value_=` виконує публікацію в фреймворці `publish/subscribe`, сеттер `formula_=` виконує підписку:
[source,scala]
----
private var f: Formula = Empty
def formula: Formula = f
def formula_=(f: Formula) = {
  for (c <- references(formula)) deafTo(c)
  this.f = f
  for (c <- references(formula)) listenTo(c)
  value = evaluate(f)
}
----
Якщо клітинці присвоєна нова формула, вона спочатку відписується за допомогою `deafTo` від усіх клітин, на які посилалась попередня формула. Потім вона зберігає нову формулу в приватній змінній `f` та підписується за допомогою `listenTo` на всі клітини, на які посилається. Нарешті вона переобчислює значення використовуючи нову формулу.

Остання частина коду в переглянутому класі `Cell` вказує, як реагувати на подію:
[source,scala]
----
reactions += {
  case ValueChanged(_) => value = evaluate(formula)
}
} // кінець класу Cell
----
Клас ValueChanged також міститься в класі `Model`:
[source,scala]
----
case class ValueChanged(cell: Cell) extends event.Event
----
Решта класу `Model` як раніше:
[source,scala]
----
  val cells = Array.ofDim[Cell](height, width)
  for (i <- 0 until height; j <- 0 until width)
    cells(i)(j) = new Cell(i, j)
} // кінець класу Model

package org.stairwaybook.scells
import swing._, event._

class Spreadsheet(val height: Int, val width: Int)
    extends ScrollPane {
  val cellModel = new Model(height, width)
  import cellModel._
  val table = new Table(height, width) {
... // без змін

  override def rendererComponent(
      isSelected: Boolean, hasFocus: Boolean,
      row: Int, column: Int) =
... // без змін

  def userData(row: Int, column: Int): String =
... // без змін

  reactions += {
    case TableUpdated(table, rows, column) =>
      for (row <- rows)
        cells(row)(column).formula =
          FormulaParsers.parse(userData(row, column))
    case ValueChanged(cell) =>
      updateCell(cell.row, cell.column)
  }

  for (row <- cells; cell <- row) listenTo(cell)
}

val rowHeader = new ListView(0 until height) {
  fixedCellWidth = 30
  fixedCellHeight = table.rowHeight
}
viewportView = table
rowHeaderView = rowHeader
}
----
Лістинг 35.9 - Завершений компонент електронної таблиці.

Код електронної таблиці майже готовий. Остання відсутня частина є перемальовка модифікованих клітин. Досі всі просування значень стосувались тільки внутрішніх значень `Cell`; видима таблиця не зазнавала впливу. Один спосіб змінити це буде додати команду `redraw` до сеттера `value_=`. Однак це може підірвати пряму сеперацію між моделлю та переглядом, що ми бачили до цього. Більш модульне рішення є повідомити таблицю про всі події `ValueChanged`, та дати їх перемалювати себе. Лістинг 35.9 показує фінальний компонент електронної таблиці, що реалізує цю схему.

Клас `Spreadsheet` на Лістингу 35.9 має тільки дві нові ревізії. Перше, компонент `table` тепер підписується за допомогою `listenTo` на всі клітини в `model`. Друге, є новий `case` в `table` `reactions`: якщо він нотифікований подією `ValueChanged(cell)`, він потребує перемалювати відповідну клітину через виклик `updateCell(cell.row, cell.column)`.

35.8 Висновок
-------------
Електронна таблиця, розроблена в цій главі, є повністю функціональною, навіть якщо в деяких моментах вона адаптує простіші рішення для реалізації, ніж найбільш зручні для користувача. Таким чином, вона змогла бути написаною лише в меньше 200 рядків коду. Тим не менше, архитектура електронної таблиці робить модифікації та розширення простими. В випадку, якщо ви хочете поекспериментувати з кодом трохи більше, ось деякі поради, що ви можете змінити або додати:

1. В можете зробити таблицю змінного розміру, так що число рядків або стовпчиків може бути змінене інтерактивно.

2. Ви можете додати нові типи формул, наприклад бінарні операції або інші функції.

3. Ви можете подумати що робити, коли клітини рекурсивно посилаються самі на себе. Наприклад, якщо клітина `A1` містить формулу `add(B1, 1)`, та `B1` містить формулу `mul(A1, 2)`, переобчислення любої з ціх клітин буде викликати переповнення стеку. Зрозуміло, що це не дуже гарне рішення. Як альтернатива, ви можете або заборонити таку ситуацію, або просто обчислювати одну ітерацію кожного разу, коли клітини змінюються.

4. Ви можете розширити обробку помилок, даячи більш детальне описання того, що пішло не так.

5. Ви можете додати поле вводу формул зверху таблиці, так що довгі формули можуть бути введені більш зручно.

На початку цієї книги ми зробили наголос на аспекті маштабованосі Scala. Ми стверджували, що комбінація об'єктної орієнтованості  Scala, та функціональних конструкцій робить її підходящою для програм в диапазоні від малих скриптів до дуже великих систем. Електронна таблиця, представлена тут, все ще є малою системою, навіть якщо вона робить значно більше, ніж 200 рядків в більшості інших мов. Тим не менш, ви бачите багато з деталей, що робить Scala маштабованою в цьому застосуванні.

Електронна таблиця використовує Scala класи та трейти з їх міксин композицією, щоб комбінувати компоненти в гнучкий спосіб. Рекурсіивні залежності між компонентами виражені через використання типів `self`. Потреба в статичному стані повністю прибрана — тільки високорівневі компоненти, що не є класами, є дерева формул та парсери парсерів, та обоє є повністю функціональними. Застосування також екстенсивно використовує функції вищих порядків та порівняння шаблонів, однаково, для доступу до формул та обробки подій. Так що це гарний приклад того, як функціональне та об'єктно орієнтовне прорамування може бути успішно зкомбіновано.

Одна з важливих причин, чому застосування електронної таблиці таке стисле, є те, що воно базується на потужних бібліотеках. Бібліотека парсерного комбінатора провадить фактично внутрішню домен-специфічну мову для написання парсерів. Без неї розбір формул міг бути значно більш складним. Обробка подій в бібліотеках Scala Swing є гарним прикладом потужності керівних абстракцій. Якщо ви знаєте бібліотеки Java Swing, ви можливо оцінили стислість Scala концепції `reactions`, особливо коли порівнювати до тонкощів написання методів повідомлень та реалізації інтерфейсів слухачів в класичному шаблоні дизайну publish/subscribe. Так що електронна таблиця демонструє переваги розширюваності, коли високорівневі бібліотеки можуть бути зроблені так, щоб виглядати як розширення мови.