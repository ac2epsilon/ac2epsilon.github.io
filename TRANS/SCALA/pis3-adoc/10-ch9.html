<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="paragraph"><p>Chapter 9
Control Abstraction
In Chapter 7, we pointed out that Scala doesn&#8217;t have many built-in control abstractions because it gives
you the ability to create your own. In the previous chapter, you learned about function values. In this
chapter, we&#8217;ll show you how to apply function values to create new control abstractions. Along the way,
you&#8217;ll also learn about currying and by-name parameters.
9.1 REDUCING CODE DUPLICATION
All functions are separated into common parts, which are the same in every invocation of the function,
and non-common parts, which may vary from one function invocation to the next. The common parts
are in the body of the function, while the non-common parts must be supplied via arguments. When
you use a function value as an argument, the non-common part of the algorithm is itself some other
algorithm! At each invocation of such a function, you can pass in a different function value as an
argument, and the invoked function will, at times of its choosing, invoke the passed function value.
These higher-order functions—functions that take functions as parameters—give you extra
opportunities to condense and simplify code.
One benefit of higher-order functions is they enable you to create control abstractions that allow you to
reduce code duplication. For example, suppose you are writing a file browser, and you want to provide
an API that allows users to search for files matching some criterion. First, you add a facility to search
for files whose names end in a particular string. This would enable your users to find, for example, all
files with a ".scala" extension. You could provide such an API by defining a public filesEnding method
inside a singleton object like this:
object FileMatcher {
private def filesHere = (new java.io.File(".")).listFiles
}
def filesEnding(query: String) =
for (file &#8592; filesHere; if file.getName.endsWith(query))
yield file
The filesEnding method obtains the list of all files in the current directory using the private helper
method filesHere, then filters them based on whether each file name ends with the user-specified query.
Given filesHere is private, the filesEnding method is the only accessible method defined
in FileMatcher, the API you provide to your users.
So far so good, and there is no repeated code yet. Later on, though, you decide to let people search
based on any part of the file name. This is good for when your users cannot remember if they named a
file phb-important.doc, stupid-phb-report.doc, may2003salesdoc.phb, or something entirely different;
they just know that "phb" appears in the name somewhere. You go back to work and add this function
to your FileMatcher API:def filesContaining(query: String) =
for (file &#8592; filesHere; if file.getName.contains(query))
yield file
This function works just like filesEnding. It searches filesHere, checks the name, and returns the file if
the name matches. The only difference is that this function uses contains instead ofendsWith.
The months go by, and the program becomes more successful. Eventually, you give in to the requests of
a few power users who want to search based on regular expressions. These sloppy guys have immense
directories with thousands of files, and they would like to do things like find all "pdf" files that have
"oopsla" in the title somewhere. To support them, you write this function:
def filesRegex(query: String) =
for (file &#8592; filesHere; if file.getName.matches(query))
yield file
Experienced programmers will notice all of this repetition and wonder if it can be factored into a
common helper function. Doing it the obvious way does not work, however. You would like to be able
to do the following:
def filesMatching(query: String, null) =
for (file &#8592; filesHere; if file.getName.null(query))
yield file
This approach would work in some dynamic languages, but Scala does not allow pasting together code
at runtime like this. So what do you do?
Function values provide an answer. While you cannot pass around a method name as a value, you can
get the same effect by passing around a function value that calls the method for you. In this case, you
could add a matcher parameter to the method whose sole purpose is to check a file name against a
query:
def filesMatching(query: String,
matcher: (String, String) &#8658; Boolean) = {
for (file &#8592; filesHere; if matcher(file.getName, query))
yield file
}
In this version of the method, the if clause now uses matcher to check the file name against the query.
Precisely what this check does depends on what is specified as the matcher. Take a look, now, at the
type of matcher itself. It is a function, and thus has a &#8658; in the type. This function takes two string
arguments—the file name and the query—and returns a boolean, so the type of this function
is (String, String) &#8658; Boolean.
Given this new filesMatching helper method, you can simplify the three searching methods by having
them call the helper method, passing in an appropriate function:
def filesEnding(query: String) =
filesMatching(query, <em>.endsWith(</em>))def filesContaining(query: String) =
filesMatching(query, <em>.contains(</em>))
def filesRegex(query: String) =
filesMatching(query, <em>.matches(</em>))
The function literals shown in this example use the placeholder syntax, introduced in the previous
chapter, which may not as yet feel very natural to you. So here&#8217;s a clarification of how placeholders are
used: The function literal <em>.endsWith(</em>), used in the filesEnding method, means the same thing as:
(fileName: String, query: String) &#8658; fileName.endsWith(query)
Because filesMatching takes a function that requires two String arguments, you need not specify the
types of the arguments; you could just write(fileName, query) &#8658; fileName.endsWith(query). Since the
parameters are each used only once in the body of the function (i.e., the first parameter, fileName, is
used first in the body, and the second parameter, query, is used second), you can use the placeholder
syntax: <em>.endsWith(</em>). The first underscore is a placeholder for the first parameter, the file name, and
the second underscore a placeholder for the second parameter, the query string.
This code is already simplified, but it can actually be even shorter. Notice that the query gets passed
to filesMatching, but filesMatching does nothing with the query except to pass it back to the
passed matcher function. This passing back and forth is unnecessary because the caller already knew
the query to begin with! You might as well remove the query parameter
fromfilesMatching and matcher, thus simplifying the code as shown in Listing 9.1.
object FileMatcher {
private def filesHere = (new java.io.File(".")).listFiles
private def filesMatching(matcher: String &#8658; Boolean) =
for (file &#8592; filesHere; if matcher(file.getName))
yield file
def filesEnding(query: String) =
filesMatching(<em>.endsWith(query))
def filesContaining(query: String) =
filesMatching(</em>.contains(query))
}
def filesRegex(query: String) =
filesMatching(<em>.matches(query))
Listing 9.1 - Using closures to reduce code duplication.
This example demonstrates the way in which first-class functions can help you eliminate code
duplication where it would be very difficult to do so without them. In Java, for example, you could
create an interface containing a method that takes one String and returns a Boolean, then create and
pass anonymous inner class instances that implement this interface tofilesMatching. Although this
approach would remove the code duplication you are trying to eliminate, it would, at the same time,
add as much or more new code. Thus the benefit is not worth the cost, and you may as well live with
the duplication.Moreover, this example demonstrates how closures can help you reduce code duplication. The function
literals used in the previous example, such as _.endsWith(</em>) and <em>.contains(</em>), are instantiated at
runtime into function values that are not closures because they don&#8217;t capture any free variables. Both
variables used in the expression, <em>.endsWith(</em>), for example, are represented by underscores, which
means they are taken from arguments to the function. Thus, <em>.endsWith(</em>) uses two bound variables,
and no free variables. By contrast, the function literal <em>.endsWith(query), used in the most recent
example, contains one bound variable, the argument represented by the underscore, and one free
variable named query. It is only because Scala supports closures that you were able to remove
the query parameter fromfilesMatching in the most recent example, thereby simplifying the code even
further.
9.2 SIMPLIFYING CLIENT CODE
The previous example demonstrated that higher-order functions can help reduce code duplication as
you implement an API. Another important use of higher-order functions is to put them in an API itself
to make client code more concise. A good example is provided by the special-purpose looping methods
of Scala&#8217;s collection types.<span class="footnote"><br />[These special-purpose looping methods are defined in trait Traversable, which is extended by List, Set, and Map. See Chapter 17 for a discussion.]<br /></span> Many of these are listed inTable 3.1 in Chapter 3, but take a look at just
one example for now to see why these methods are so useful.
Consider exists, a method that determines whether a passed value is contained in a collection. You
could, of course, search for an element by having a var initialized to false, looping through the
collection checking each item, and setting the var to true if you find what you are looking for. Here&#8217;s a
method that uses this approach to determine whether a passedList contains a negative number:
def containsNeg(nums: List[Int]): Boolean = {
var exists = false
for (num &#8592; nums)
if (num &lt; 0)
exists = true
exists
}
If you define this method in the interpreter, you can call it like this:
scala&gt; containsNeg(List(1, 2, 3, 4))
res0: Boolean = false
scala&gt; containsNeg(List(1, 2, -3, 4))
res1: Boolean = true
A more concise way to define the method, though, is by calling the higher-order functionexists on the
passed List, like this:
def containsNeg(nums: List[Int]) = nums.exists(</em> &lt; 0)
This version of containsNeg yields the same results as the previous:
scala&gt; containsNeg(Nil)
res2: Boolean = falsescala&gt; containsNeg(List(0, -1, -2))
res3: Boolean = true
The exists method represents a control abstraction. It is a special-purpose looping construct provided
by the Scala library, rather than built into the Scala language like while or for. In the previous section,
the higher-order function, filesMatching, reduces code duplication in the implementation of
the object FileMatcher. The exists method provides a similar benefit, but because exists is public in
Scala&#8217;s collections API, the code duplication it reduces is client code of that API. If exists didn&#8217;t exist,
and you wanted to write a containsOdd method to test whether a list contains odd numbers, you might
write it like this:
def containsOdd(nums: List[Int]): Boolean = {
var exists = false
for (num &#8592; nums)
if (num % 2 == 1)
exists = true
exists
}
If you compare the body of containsNeg with that of containsOdd, you&#8217;ll find that everything is
repeated except the test condition of an if expression. Using exists, you could write this instead:
def containsOdd(nums: List[Int]) = nums.exists(_ % 2 == 1)
The body of the code in this version is again identical to the body of the
correspondingcontainsNeg method (the version that uses exists), except the condition for which to
search is different. Yet the amount of code duplication is much smaller because all of the looping
infrastructure is factored out into the exists method itself.
There are many other looping methods in Scala&#8217;s standard library. As with exists, they can often shorten
your code if you recognize opportunities to use them.
9.3 CURRYING
In Chapter 1, we said that Scala allows you to create new control abstractions that "feel like native
language support." Although the examples you&#8217;ve seen so far are indeed control abstractions, it is
unlikely anyone would mistake them for native language support. To understand how to make control
abstractions that feel more like language extensions, you first need to understand the functional
programming technique called currying.
A curried function is applied to multiple argument lists, instead of just one. Listing 9.2 shows a regular,
non-curried function, which adds two Int parameters, x and y.
scala&gt; def plainOldSum(x: Int, y: Int) = x + y
plainOldSum: (x: Int, y: Int)Int
scala&gt; plainOldSum(1, 2)
res4: Int = 3Listing 9.2 - Defining and invoking a "plain old" function.
By contrast, Listing 9.3 shows a similar function that&#8217;s curried. Instead of one list of two Intparameters,
you apply this function to two lists of one Int parameter each.
scala&gt; def curriedSum(x: Int)(y: Int) = x + y
curriedSum: (x: Int)(y: Int)Int
scala&gt; curriedSum(1)(2)
res5: Int = 3
Listing 9.3 - Defining and invoking a curried function.
What&#8217;s happening here is that when you invoke curriedSum, you actually get two traditional function
invocations back to back. The first function invocation takes a single Int parameter named x, and
returns a function value for the second function. This second function takes theInt parameter y. Here&#8217;s a
function named first that does in spirit what the first traditional function invocation
of curriedSum would do:
scala&gt; def first(x: Int) = (y: Int) &#8658; x + y
first: (x: Int)Int &#8658; Int
Applying the first function to 1—in other words, invoking the first function and passing in 1—yields
the second function:
scala&gt; val second = first(1)
second: Int &#8658; Int = &lt;function1&gt;
Applying the second function to 2 yields the result:
scala&gt; second(2)
res6: Int = 3
These first and second functions are just an illustration of the currying process. They are not directly
connected to the curriedSum function. Nevertheless, there is a way to get an actual reference
to curriedSum&#8217;s "second" function. You can use the placeholder notation to usecurriedSum in a partially
applied function expression, like this:
scala&gt; val onePlus = curriedSum(1)_
onePlus: Int &#8658; Int = &lt;function1&gt;
The underscore in curriedSum(1)_ is a placeholder for the second parameter list.<span class="footnote"><br />[In the previous chapter, when the placeholder notation was used on traditional methods, like println <em>, you had to leave a space between the name and the underscore. In this case you don&#8217;t, because whereas println</em> is a legal identifier in Scala, curriedSum(1)_ is not.]<br /></span> The result is a
reference to a function that, when invoked, adds one to its sole Int argument and returns the result:
scala&gt; onePlus(2)
res7: Int = 3
And here&#8217;s how you&#8217;d get a function that adds two to its sole Int argument:
scala&gt; val twoPlus = curriedSum(2)_
twoPlus: Int &#8658; Int = &lt;function1&gt;
scala&gt; twoPlus(2)
res8: Int = 49.4 WRITING NEW CONTROL STRUCTURES
In languages with first-class functions, you can effectively make new control structures even though the
syntax of the language is fixed. All you need to do is create methods that take functions as arguments.
For example, here is the "twice" control structure, which repeats an operation two times and returns the
result:
scala&gt; def twice(op: Double &#8658; Double, x: Double) = op(op(x))
twice: (op: Double &#8658; Double, x: Double)Double
scala&gt; twice(_ + 1, 5)
res9: Double = 7.0
The type of op in this example is Double &#8658; Double, which means it is a function that takes
oneDouble as an argument and returns another Double.
Any time you find a control pattern repeated in multiple parts of your code, you should think about
implementing it as a new control structure. Earlier in the chapter you saw filesMatching, a very
specialized control pattern. Consider now a more widely used coding pattern: open a resource, operate
on it, and then close the resource. You can capture this in a control abstraction using a method like the
following:
def withPrintWriter(file: File, op: PrintWriter &#8658; Unit) = {
val writer = new PrintWriter(file)
try {
op(writer)
} finally {
writer.close()
}
}
Given such a method, you can use it like this:
withPrintWriter(
new File("date.txt"),
writer &#8658; writer.println(new java.util.Date)
)
The advantage of using this method is that it&#8217;s withPrintWriter, not user code, that assures the file is
closed at the end. So it&#8217;s impossible to forget to close the file. This technique is called the loan pattern,
because a control-abstraction function, such as withPrintWriter, opens a resource and "loans" it to a
function. For instance, withPrintWriter in the previous example loans a PrintWriter to the function, op.
When the function completes, it signals that it no longer needs the "borrowed" resource. The resource
is then closed in a finally block, to ensure it is indeed closed, regardless of whether the function
completes by returning normally or throwing an exception.
One way in which you can make the client code look a bit more like a built-in control structure is to use
curly braces instead of parentheses to surround the argument list. In any method invocation in Scala in
which you&#8217;re passing in exactly one argument, you can opt to use curly braces to surround the argument
instead of parentheses.For example, instead of:
scala&gt; println("Hello, world!")
Hello, world!
You could write:
scala&gt; println { "Hello, world!" }
Hello, world!
In the second example, you used curly braces instead of parentheses to surround the arguments
to println. This curly braces technique will work, however, only if you&#8217;re passing in one argument.
Here&#8217;s an attempt at violating that rule:
scala&gt; val g = "Hello, world!"
g: String = Hello, world!
scala&gt; g.substring { 7, 9 }
&lt;console&gt;:1: error: <em>;</em> expected but <em>,</em> found.
g.substring { 7, 9 }
^
Because you are attempting to pass in two arguments to substring, you get an error when you try to
surround those arguments with curly braces. Instead, you&#8217;ll need to use parentheses:
scala&gt; g.substring(7, 9)
res12: String = wo
The purpose of this ability to substitute curly braces for parentheses for passing in one argument is to
enable client programmers to write function literals between curly braces. This can make a method call
feel more like a control abstraction. Take the withPrintWritermethod defined previously as an example.
In its most recent form, withPrintWriter takes two arguments, so you can&#8217;t use curly braces.
Nevertheless, because the function passed towithPrintWriter is the last argument in the list, you can use
currying to pull the first argument, the File, into a separate argument list. This will leave the function as
the lone parameter of the second argument list. Listing 9.4 shows how you&#8217;d need to
redefine withPrintWriter.
def withPrintWriter(file: File)(op: PrintWriter &#8658; Unit) = {
val writer = new PrintWriter(file)
try {
op(writer)
} finally {
writer.close()
}
}
Listing 9.4 - Using the loan pattern to write to a file.
The new version differs from the old one only in that there are now two parameter lists with one
parameter each instead of one parameter list with two parameters. Look between the two parameters. In
the previous version of withPrintWriter, shown here, you see &#8230;File, op&#8230;. But in this version, you
see &#8230;File)(op&#8230;. Given the above definition, you can call the method with a more pleasing syntax:val file = new File("date.txt")
withPrintWriter(file) { writer &#8658;
writer.println(new java.util.Date)
}
In this example, the first argument list, which contains one File argument, is written surrounded by
parentheses. The second argument list, which contains one function argument, is surrounded by curly
braces.
9.5 BY-NAME PARAMETERS
The withPrintWriter method shown in the previous section differs from built-in control structures of the
language, such as if and while, in that the code between the curly braces takes an argument. The
function passed to withPrintWriter requires one argument of typePrintWriter. This argument shows up
as the "writer &#8658;" in:
withPrintWriter(file) { writer &#8658;
writer.println(new java.util.Date)
}
But what if you want to implement something more like if or while, where there is no value to pass into
the code between the curly braces? To help with such situations, Scala provides by-name parameters.
As a concrete example, suppose you want to implement an assertion construct called myAssert.
<span class="footnote"><br />[You&#8217;ll call this myAssert, not assert, because Scala provides an assert of its own, which will be described in Section 14.1.]<br /></span> The myAssert function will take a function value as input and consult a flag to decide what to do. If
the flag is set, myAssert will invoke the passed function and verify that it returns true. If the flag is
turned off, myAssert will quietly do nothing at all.
Without using by-name parameters, you could write myAssert like this:
var assertionsEnabled = true
def myAssert(predicate: () &#8658; Boolean) =
if (assertionsEnabled &amp;&amp; !predicate())
throw new AssertionError
The definition is fine, but using it is a little bit awkward:
myAssert(() &#8658; 5 &gt; 3)
You would really prefer to leave out the empty parameter list and &#8658; symbol in the function literal and
write the code like this:
myAssert(5 &gt; 3) // Won&#8217;t work, because missing () &#8658;
By-name parameters exist precisely so that you can do this. To make a by-name parameter, you give the
parameter a type starting with &#8658; instead of () &#8658;. For example, you could
changemyAssert&#8217;s predicate parameter into a by-name parameter by changing its type, "() &#8658; Boolean",
into "&#8658; Boolean". Listing 9.5 shows how that would look:def byNameAssert(predicate: &#8658; Boolean) =
if (assertionsEnabled &amp;&amp; !predicate)
throw new AssertionError
Listing 9.5 - Using a by-name parameter.
Now you can leave out the empty parameter in the property you want to assert. The result is that
using byNameAssert looks exactly like using a built-in control structure:
byNameAssert(5 &gt; 3)
A by-name type, in which the empty parameter list, (), is left out, is only allowed for parameters. There
is no such thing as a by-name variable or a by-name field.
Now, you may be wondering why you couldn&#8217;t simply write myAssert using a plain old Booleanfor the
type of its parameter, like this:
def boolAssert(predicate: Boolean) =
if (assertionsEnabled &amp;&amp; !predicate)
throw new AssertionError
This formulation is also legal, of course, and the code using this version of boolAssert would still look
exactly as before:
boolAssert(5 &gt; 3)
Nevertheless, one difference exists between these two approaches that is important to note. Because the
type of boolAssert&#8217;s parameter is Boolean, the expression inside the parentheses inboolAssert(5 &gt; 3) is
evaluated before the call to boolAssert. The expression 5 &gt; 3 yields true, which is passed to boolAssert.
By contrast, because the type of byNameAssert&#8217;s predicate parameter is&#8658; Boolean, the expression
inside the parentheses in byNameAssert(5 &gt; 3) is not evaluated before the call to byNameAssert.
Instead a function value will be created whose apply method will evaluate 5 &gt; 3, and this function
value will be passed to byNameAssert.
The difference between the two approaches, therefore, is that if assertions are disabled, you&#8217;ll see any
side effects that the expression inside the parentheses may have in boolAssert, but not
in byNameAssert. For example, if assertions are disabled, attempting to assert on "x / 0 == 0" will yield
an exception in boolAssert&#8217;s case:
scala&gt; val x = 5
x: Int = 5
scala&gt; var assertionsEnabled = false
assertionsEnabled: Boolean = false
scala&gt; boolAssert(x / 0 == 0)
java.lang.ArithmeticException: / by zero
&#8230; 33 elided
But attempting to assert on the same code in byNameAssert&#8217;s case will not yield an exception:
scala&gt; byNameAssert(x / 0 == 0)9.6 CONCLUSION
This chapter has shown you how to build on Scala&#8217;s rich function support to build control abstractions.
You can use functions within your code to factor out common control patterns, and you can take
advantage of higher-order functions in the Scala library to reuse control patterns that are common
across all programmers' code. We also discussed how to use currying and by-name parameters so that
your own higher-order functions can be used with a concise syntax.
In the previous chapter and this one, you have seen quite a lot of information about functions. The next
few chapters will go back to discussing more object-oriented features of the language.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-28 00:16:50 EET
</div>
</div>
</body>
</html>
