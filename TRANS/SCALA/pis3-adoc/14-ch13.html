<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__13">Глава 13</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="___">Пакунки та імпорти</h1>
<div class="paragraph"><p>Коли ви робите над програмою, особливо над великою, є важливим мінімізувати зчеплення — міру, в якій різні частини програми попокладаються одна на одну.Низьке зчеплення зменьшує ризик що малі, виглядаючі невинними зміни в одній частині програми, будуть мати руйнівні наслідки для іншої частини. Одним з шляхів зменшити зчеплення є писати в модулярному стилі. Ви поділяєте програму на декілька меньших модулів, кожна з яких має інутнішнє та зовнішнє. Коли робите всередині модуля, його реалізації, вам треба координуватись тільки з програмістами, що роблять тільки з тим самим модулем. Тільки коли ви маєте змінити зовнішність модуля, його інтерфейси, потрібно скоординувати дії з розробниками, що роблять з іншими модулями.</p></div>
<div class="paragraph"><p>Ця глава показує декілька конструкцій, що допомагають вам програмувати в модульному стилі. Він показує, як покласти речі в пакунок, зробити імена видимі через імпорт, та контролювати видимість через модифікатори доступу. Конструкції подібні по духу до конструкцій Java, але є деякі відмінності, звичайно щоб зробити речі дещо узгодженими, так що має сенс прочитати цю главу, навіть якщо ви вже знаєте Java.</p></div>
<div class="sect1">
<h2 id="_13_1____">13.1 Покладання коду в пакунки</h2>
<div class="sectionbody">
<div class="paragraph"><p>Код Scala розташовується в глобальній ієрархії пакунків Java. Приклад коду, що ви бачили дотепер в цій книзі, знаходився в безіменному пакунку. Ви можете покласти код в іменовані пакунки в Scala в два способи. Перше, ви можете покласти вміст цілого файлу в пакунок, поставивши твердження <code>package</code> зверху файла, як показано в Лістингу 13.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets.navigation</span>
<span class="k">class</span> <span class="nc">Navigator</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.1 - Покладання вмісту цілого файла в пакунок.</p></div>
<div class="paragraph"><p>Твердження <code>package</code> в Лістингу 13.1 покладає клас <code>Navigator</code> в пакунок на ім'я <code>bobsrockets.navigation</code>. Імовірно, це програмне забезпечення навігації, розроблене Bob&#8217;s Rockets, Inc.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Оскільки код Scala є частиною екосистеми Java, рекомендовано слідувати домовленості Java щодо реверсно-доменного іменування для пакунків Scala, які ви випускаєте на публіку. Таким чином, краще ім'я для пакунку <code>Navigator</code> може бути <code>com.bobsrockets.navigation</code>. Однак в цій главі ми полишимо частку <code>com.</code>, щоб зробити приклади простіші до розуміння.</td>
</tr></table>
</div>
<div class="paragraph"><p>Інший спосіб покласи код в пакунок в Scala більш подібний на простори імен C#. Ви ставите за твердженням <code>package</code> розділ в фігурних дужках, що містить визначення, які підуть до пакунка. Цей синтаксис називається пакуванням. Пакування, показане в Лістингу 13.2, має той самий ефект, що і код в Лістингу 13.1:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets.navigation</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Navigator</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.2 - Довга форма для простої декларації пакунку.</p></div>
<div class="paragraph"><p>Для такого простого прикладу ви можете також використовувати синтаксичний цукор, показаний в Лістингу 13.1. Однак, одне використання більш загальної нотації є мати різні частині файлу в різних пакунках. Наприклад, ви можете вставити тести класа в той самий файл, що і оригінальний код, але покласти тести в окремі пакунки, як показано в Лістингу 13.3.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
<span class="c1">// В пакунку bobsrockets.navigation</span>
    <span class="k">class</span> <span class="nc">Navigator</span>

    <span class="k">package</span> <span class="nn">tests</span> <span class="o">{</span>
      <span class="c1">// В пакунку bobsrockets.navigation.tests</span>
      <span class="k">class</span> <span class="nc">NavigatorSuite</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.3 - Декілька пакунків в тому самому файлі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
    <span class="k">class</span> <span class="nc">Navigator</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.navigation.StarMap</span>
      <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StarMap</span>
    <span class="o">}</span>
    <span class="k">class</span> <span class="nc">StarMap</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Ship</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.navigation.Navigator</span>
    <span class="k">val</span> <span class="n">nav</span> <span class="k">=</span> <span class="k">new</span> <span class="n">navigation</span><span class="o">.</span><span class="nc">Navigator</span>
  <span class="o">}</span>
<span class="k">package</span> <span class="nn">fleets</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Fleet</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.Ship</span>
    <span class="k">def</span> <span class="n">addShip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Ship</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.4 - Скорочений доступ до класів та пакунків.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Ship</span>
<span class="o">}</span>
<span class="k">package</span> <span class="nn">bobsrockets.fleets</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Fleet</span> <span class="o">{</span>
<span class="c1">// Doesn&#39;t compile! Ship is not in scope.</span>
    <span class="k">def</span> <span class="n">addShip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Ship</span> <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.5 - Символи в оточуючих пакунках не доступні автоматично.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// В файлі launch.scala</span>
<span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Booster3</span>
<span class="o">}</span>

<span class="c1">// В файлі bobsrockets.scala</span>
<span class="k">package</span> <span class="nn">bobsrockets</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
    <span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
      <span class="k">class</span> <span class="nc">Booster1</span>
    <span class="o">}</span>
    <span class="k">class</span> <span class="nc">MissionControl</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">booster1</span> <span class="k">=</span> <span class="k">new</span> <span class="n">launch</span><span class="o">.</span><span class="nc">Booster1</span>
      <span class="k">val</span> <span class="n">booster2</span> <span class="k">=</span> <span class="k">new</span> <span class="n">bobsrockets</span><span class="o">.</span><span class="n">launch</span><span class="o">.</span><span class="nc">Booster2</span>
      <span class="k">val</span> <span class="n">booster3</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">_root_</span><span class="o">.</span><span class="n">launch</span><span class="o">.</span><span class="nc">Booster3</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
    <span class="k">class</span> <span class="nc">Booster2</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.6 - Доступ до прихованих імен пакунків.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_2______">13.2 Стислий доступ до пов'язаного коду</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли код поділений на ієрархію пакунків, це не тільки допомагає людям переглядати код. Це також каже компілятору, що код в тому самому пакунку пов'язаний в деякий спосіб один з одним. Scala отримує перевагу від цієї пов'язаності, дозволяючі короткі, некваліфіковані імена при доступу до кода, що знаходиться в тому самому пакунку.</p></div>
<div class="paragraph"><p>Лістинг 13.4 надає три прості приклади. Перше, як ви можете очікувати, клас може бути доступний зі свого власного пакунку без потреби вказання префіксу. Ось чому <code>new StarMap</code> компілюється. Клас <code>StarMap</code> знаходиться в тому самому пакунку, <code>bobsrockets.navigation</code>, що і вираз <code>new</code>, що отримує доступ, так що ім'я пакунка не треба ставити в якості префікса.</p></div>
<div class="paragraph"><p>Друге, сам пакунок може бути доступний зі свого містячого пакунку без потреби в префіксі. В Лістингу 13.4 подивіться, як створюється примірник класу <code>Navigator</code>. Вираз <code>new</code> з'являється в пакунку <code>bobsrockets</code>, що містить пакунок <code>bobsrockets.navigation</code>. Таким чином, він може отримати доступ до пакунку <code>bobsrockets.navigation</code> через просту навігацію.</p></div>
<div class="paragraph"><p>Третє, коли використовуються синтаксис пакування з фігурними дужками, всі імена, доступні в полі зору за межами пакування також доступні всередині його. Приклад в Лістингу 13.4 є спосіб, як <code>addShip()</code> створює новий <code>Ship</code>. Метод визначений в двох пакунках: зовнішній для <code>bobsrockets</code>, та внутрішній для <code>bobsrockets.fleets</code>. Оскільки <code>Ship</code> доступний в зовнішньому пакуванні, на нього можна посилатись всередині <code>addShip()</code>.</p></div>
<div class="paragraph"><p>Зауважте, що цей різновид доступу можливий тільки якщо ви явно вкладете пакування. Якщо ви пристанете на один пакунок на файл, тоді, як в Java, єдині доступні імена будуть ті, що визначені в поточному пакунку. В Лістингу 13.5 пакування <code>bobsrockets.fleets</code> було пересунуте на вищий рівень. Оскільки воно більше не оточене в пакуванні для <code>bobsrockets</code>,імена з <code>bobsrockets</code> не є безпосередньо в полі зору. Як результат, <code>new Ship</code> дає помилку компіляції. Якщо вкладання пакунків з фігурними дужками незручно зсуває ваш код вправо, ви можете також використовувати декілька тверджень <code>package</code> без дужок.<span class="footnote"><br />[Цей стиль декількох тверджень <code>package</code> без дужок називається зціпленими твердженнями <code>package</code>.]<br /></span> Наприклад, код нижче також визначає клас <code>Fleet</code> в двох вкладених пакунках, <code>bobrockets</code> та <code>fleets</code>, саме як ви бачили в Лістингу 13.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span>
<span class="k">package</span> <span class="nn">fleets</span>
<span class="k">class</span> <span class="nc">Fleet</span> <span class="o">{</span>
<span class="c1">// Не треба казати bobsrockets.Ship</span>
  <span class="k">def</span> <span class="n">addShip</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="k">new</span> <span class="nc">Ship</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Один заключний трюк, про який важливо знати. Іноді ви закінчуєте кодування в дуже захащеному полі зору, де імена пакунків затіняють один одне. В Лістингу 13.6 поле зору класу <code>MissionControl</code> включає три окремі пакунки на ім'я <code>launch</code>! Існує один <code>launch</code> в <code>bobsrockets.navigation</code>, один в <code>bobsrockets</code>, та один на вищому рівні. Як ви будете посилатись на кожний з <code>Booster1</code>, <code>Booster2</code> та <code>Booster3</code>?</p></div>
<div class="paragraph"><p>Доступ до першого найпростіший. Посилання на <code>launch</code> само по собі перенесе вас до пакунку <code>bobsrockets.navigation.launch</code>, оскільки він в пакунку <code>launch</code>, визначеному в найближчому оточуючому полі зору. Таки чином ви можете посилатись на перший клас прискорювача просто як на <code>launch.Booster1</code>. Посилання на другий також не дуже заплутаний. Ви можете написати <code>bobrockets.launch.Booster2</code>, і буде зрозуміло, на який саме ви посилаєтесь. Це залишає питання третього класу прискорювача: як ви отримаєте доступ до <code>Booster3</code>, зважаючи, що вкладений пакунок <code>launch</code> затінює високорівневі об'єкти?</p></div>
<div class="paragraph"><p>Щоб допомогти в цій ситуації Scala провадить пакунок на ім'я <code>_root_</code>, який знаходиться за межами любого пакунку, що може написати користувач. Підходячи з іншого боку, кожний високорівневий пакунок, що ви можете написати, розглядається як член пакунку <code>_root_</code>. Наприклад, обоє, <code>launch</code> та <code>bobsrockets</code> з Лістингу 13.6 є членами пакунку <code>_root_</code>. Як результат, <code>_root_.launch</code> дає вам пакунок самого вищого рівня, та <code>_root_.launch.Booster3</code> позначає самий зовнішній клас прискорювача.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_3_">13.3 Імпорти</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala пакунки та їх члени можуть бути імпортовані з використанням твердження <code>import</code>. Імпортовані елементи потім можуть бути досяжні через просте ім'я, як <code>File</code>, на протилежність до вимоги кваліфікованого імені, як <code>java.io.File</code>. Наприклад, розглянемо код, показаний в Лістингу 13.7.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsdelights</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">String</span>
<span class="o">)</span>

<span class="k">object</span> <span class="nc">Fruits</span> <span class="o">{</span>
  <span class="k">object</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">,</span> <span class="s">&quot;red&quot;</span><span class="o">)</span>
  <span class="k">object</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Fruit</span><span class="o">(</span><span class="s">&quot;orange&quot;</span><span class="o">,</span> <span class="s">&quot;orange&quot;</span><span class="o">)</span>
  <span class="k">object</span> <span class="nc">Pear</span> <span class="k">extends</span> <span class="nc">Fruit</span><span class="o">(</span><span class="s">&quot;pear&quot;</span><span class="o">,</span> <span class="s">&quot;yellowish&quot;</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">menu</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Pear</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.7 - Улюблені фрукти Боба, готові до імпорту.</p></div>
<div class="paragraph"><p>Твердження <code>import</code> робить члени пакунку або об'єкта доступними за саме своїми іменами, без потреби ставити префікс з імені пакунку або об'єкта. Ось деякі прості приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// простий довтуп до Fruit</span>
<span class="k">import</span> <span class="nn">bobsdelights.Fruit</span>

<span class="c1">// простий довтуп до всіх членів з bobsdelights</span>
<span class="k">import</span> <span class="nn">bobsdelights._</span>

<span class="c1">// простий довтуп до всіх членів Fruits</span>
<span class="k">import</span> <span class="nn">bobsdelights.Fruits._</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший з ціх відповідає до імпорту поодинокого класу Java, та другий до імпорту Java на-потребу. Одна різниця в тому, що в Scala імпорти на-потребу записуються з кінцевим підкресленням (<code>_</code>) замість зірочки (<code>*</code>). (Кінец кінцем, <code>*</code> є валідним ідентифікатором в Scala!) Третє твердження <code>import</code> вище відповідає до Java імпорту статичних полів класа.</p></div>
<div class="paragraph"><p>Ці три імпорту дають вам смак того, що можуть робити імпорти, але імпорти в Scala насправді значно більш загальні. Для початку, імпорти в Scala можуть з'являтись будь-де, не тільки на початку одиниці компіляції. Також вони можуть посилатись на довільні значення. Наприклад, є можливим імпорт, показаний в Лістингу 13.8:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="k">:</span> <span class="kt">Fruit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">fruit._</span>
  <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;s are &quot;</span> <span class="o">+</span> <span class="n">color</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.8 - Імпортування членів звичайного (не синглтон) об'єкта.</p></div>
<div class="paragraph"><p>Метод <code>showFruit</code> імпортує все члени свого параметру <code>fruit</code>, що є типу <code>Fruit</code>. Наступне твердження <code>println</code> може посилатись на ім'я і колір напряму. Ці два посилання еквівалентні до <code>fruit.name</code> та <code>fruit.color</code>. Цей синтаксис є зокрема корисним, коли ви використовуєте об'єкти як модулі, що буде описане в Главі 29.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____scala">Гнучкі імпорти в Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Твердження імпорту в Scala трохи більш гнучкі, ніж в Java. Є три принципові відмінності. В Scala імпорти:</p></div>
<div class="ulist"><ul>
<li>
<p>
можуть з'являтись будь-де
</p>
</li>
<li>
<p>
можуть посилатись на об'єкти (синглтони або звичайні), на додаток до пакунків
</p>
</li>
<li>
<p>
дозволяють вам переіменувати та приховати деякі з імпортованих членів
</p>
</li>
</ul></div>
<div class="paragraph"><p>Інший спосіб, в який імпорти Scala є гнучкими, є те, що вони можуть імпортувати самі пакунки, не тільки члени не-пакунки. Це просто природно, якщо ви думаєте про вкладені пакунки, які вкладені в їх оточуючих пакунках. Наприклад, в Лістингу 13.9  пакунок <code>java.util.regex</code> є імпортований. Це робить <code>regex</code> корисним як просте ім'я. Щоб отримати доступ до об'єкта синглтона <code>Pattern</code> з пакунку <code>java.util.regex</code>, ви можете просто сказати <code>regex.Pattern</code>, як показано в Лістингу 13.9:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.util.regex</span>
<span class="k">class</span> <span class="nc">AStarB</span> <span class="o">{</span>
<span class="c1">// Доступ до java.util.regex.Pattern</span>
  <span class="k">val</span> <span class="n">pat</span> <span class="k">=</span> <span class="n">regex</span><span class="o">.</span><span class="nc">Pattern</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="s">&quot;a*b&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.9 - Імпортування імені пакунку.</p></div>
<div class="paragraph"><p>Імпорти в Scala також можуть переіменовувати та приховувати члени. Це робиться через селектор імпорту, оточений в фігурні дужки, що слідує за об'єктом, з якого імпортуються члени. Ось декілька прикладів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці імпорти прості члени <code>Apple</code> та <code>Orange</code> з об'єкта <code>Fruits</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="nc">McIntosh</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує два члени, <code>Apple</code> та <code>Orange</code> з об'єкта <code>Fruits</code>. Однак, об'єкт <code>Apple</code> переіменований на <code>McIntosh</code>, так що цей об'єкт доступний як <code>Fruits.Apple</code> або <code>McIntosh</code>. Твердження переіменування завжди має форму <code>&lt;оригінальне-ім'я&gt; =&gt; &lt;нове-ім'я&gt;</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.sql.</span><span class="o">{</span><span class="nc">Date</span> <span class="k">=&gt;</span> <span class="nc">SDate</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує клас дати SQL як <code>SDate</code>, так що ви можете одночасно імпортувати звичайний клас дати Java, просто як <code>Date</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.</span><span class="o">{</span><span class="n">sql</span> <span class="k">=&gt;</span> <span class="n">S</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує пакунок <code>java.sql</code> як <code>S</code>, так що ви можете писати речі як <code>S.Date</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує всі члени з об'єкта <code>Fruits</code>. Це означає ту саму річ, що і <code>import Fruits._</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="nc">McIntosh</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує всі члени з об'єкта <code>Fruits</code>, але параіменовує <code>Apple</code> на <code>McIntosh</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Pear</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це імпортує всі члени з <code>Fruits</code>, за винятком <code>Pear</code>. Твердження в формі <code>&lt;оригінальне-ім'я&gt; =&gt; _</code> виключає <code>&lt;оригінальне-ім'я&gt;</code> з імен, що імпортовані. В певному сенсі переіменування дечого на <code>_</code> означає одночасне його приховування. Це корисне для уникнення неоднозначностей. Скажімо, ви маєте два пакунки, <code>Fruits</code> та <code>Notebooks</code>, що обоє визначають клас <code>Apple</code>. Якщо ви бажаєте отриати лише ноутбук на ім'я <code>Apple</code>, але не фрукт, ви все ще можете використовувати обоє імпорти на-потребу, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Notebooks._</span>
<span class="k">import</span> <span class="nn">Fruits.</span><span class="o">{</span><span class="nc">Apple</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде імпортувати всі <code>Notebooks</code> та всі <code>Fruits</code>, за винятком <code>Apple</code>.</p></div>
<div class="paragraph"><p>Ці приклади демонструють значну гнучкість, що пропонує Scala, коли доходить до імпорту членів вибірково, або навіть під іншими іменами. В підсумку, селектор імпорту може складатись з наступного:</p></div>
<div class="ulist"><ul>
<li>
<p>
Просте ім'я <code>x</code>. Це включає <code>x</code> в набір імпортованих імен.
</p>
</li>
<li>
<p>
Твердження переіменування <code>x =&gt; y</code>. Це робить член на ім'я <code>x</code> відомим під ім'ям <code>y</code>.
</p>
</li>
<li>
<p>
Твердження приховування <code>x =&gt; _</code>. Це виключає <code>x</code> з набору імпортованих імен.
</p>
</li>
<li>
<p>
Спіймати-всі <code>_</code>. Це імпортує всі члени, за винятком членів, зазначених в попередньому твердженні. Якщо надається символ спіймати-все, він має іти останнім в списку селекторів імпорту.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Простіші твердження імпорту, показані на початку цього розділу, можуть розглядатись як особливі скорочення тверджень імпорту з твердженням селектора. Наприклад, <code>import p._</code> еквівалентне до <code>import p.{_}</code>, та <code>import p.n</code> еквівалентне до <code>import p.{n}</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_4__">13.4 Неявні імпорти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala додає імпорти неявно до кожної програми. В основі, це виглядає так, якби три твердження імпорту були додані нагорі кожного джерельного файлу з розширенням <code>.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.lang._</span>  <span class="c1">// все в пакунку java.lang</span>
<span class="k">import</span> <span class="nn">scala._</span>      <span class="c1">// все в пакунку scala</span>
<span class="k">import</span> <span class="nn">Predef._</span>     <span class="c1">// все в об&#39;єкті Predef</span>
</pre></div></div></div>
<div class="paragraph"><p>Пакунок <code>java.lang</code> містить стандартні класи Java. Вони завжди неявно імпортовані в джерельні файли Scala.<span class="footnote"><br />[Scala також в оригіналі мала реалізацію на .NET, де замість цього був імпортований простір імен <code>System</code>, .NET аналог пакунку <code>java.lang</code>.]<br /></span> Оскільки <code>java.lang</code> імпортований неявно, ви можете писати, наприклад, <code>Thread</code>  замість <code>java.lang.Thread</code>.</p></div>
<div class="paragraph"><p>Як ви вже безсумнівно здогадались, пакунок <code>scala</code> містить стандартну бібліотеку Scala, з багатьма загальними класами та об'єктами. Оскільки <code>scala</code> імпортована неявно, ви можете писати, наприклад, <code>List</code> замість <code>scala.List</code>.</p></div>
<div class="paragraph"><p>Об'єкт <code>Predef</code> містить визначення типів, методів та неявних перетворень, що загально використовуються в програмах Scala. Наприклад, завдяки неявно імпортованому <code>Predef</code>, ви можете писати <code>assert</code> замість <code>Predef.assert</code>.</p></div>
<div class="paragraph"><p>Ці три твердження <code>import</code> розглядаються трохи особливо, в тому, що пізніші імпорти затінюють ранішні. Наприклад, клас <code>StringBuilder</code> визначений одночасно в пакунку <code>scala</code>, та, починаючи з Java версії 1.5, також в пакунку <code>java.lang</code>. оскільки імпорт <code>scala</code> затінює імпорт <code>java.lang</code>, просте ім'я <code>StringBuilder</code> буде посилатись на  <code>scala.StringBuilder</code>, не на <code>java.lang.StringBuilder</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_5__">13.5 Модифікатори доступу</h2>
<div class="sectionbody">
<div class="paragraph"><p>Члени пакунків, класів або об'єктів, можуть бути помічені можифікаторами доступу <code>private</code> та <code>protected</code>. Ці модифікатори обмежують доступ до членів для окремих регіонів коду. Трактування Scala модифікаторів доступу приблизно слідує Java, але існують деякі важливі відмінності, що пояснюються в цьому розділі.</p></div>
<div class="sect2">
<h3 id="__">Приватні члени</h3>
<div class="paragraph"><p>Приватні члени в Scala розглядаються подібно до Java. Член, відмічений <code>private</code> є видимі тільки всередині класу або об'єкту, що містить визначення члена. В Scala це правило стосується тільки внутрішніх класів. Ця трактовка більш узгоджена, але відрізняється від Java. Розглянемо приклад, показаний в Лістингу 13.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Inner</span> <span class="o">{</span>
    <span class="k">private</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;f&quot;</span><span class="o">)</span> <span class="o">}</span>
    <span class="k">class</span> <span class="nc">InnerMost</span> <span class="o">{</span>
      <span class="n">f</span><span class="o">()</span> <span class="c1">// OK</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="o">(</span><span class="k">new</span> <span class="nc">Inner</span><span class="o">).</span><span class="n">f</span><span class="o">()</span> <span class="c1">// помилка: f недоступна</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.10 - Як приватний доступ відрізняється в Scala та Java.</p></div>
<div class="paragraph"><p>В Scala доступ до <code>(new Inner).f()</code> є нелегальним, оскільки <code>f</code> декларована приватною в <code>Inner</code>, та доступ відбувається не зсередини класу <code>Inner</code>. Для контрасту, перший доступ до <code>f</code> в класі <code>InnerMost</code> є OK, оскільки цей доступ міститься в тілі класу <code>Inner</code>. Java буде дозволяти обоє доступи, оскільки вона дозволяє зовнішнім класам мати доступ до приватних членів інутрішніх класів.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Захищені члени</h3>
<div class="paragraph"><p>Доступи до захищених членів в Scala також трохи більш обмежувані, ніж в Java. В Scala захицений член доступний тільки з субкласів класа, в якому він визначений. В Java такий доступ також можливий з інших класів в тому ж пакунку. В Scala існує інший метод досягти такого самого ефекту,<span class="footnote"><br />[Використовуючи кваліфікатори, описані в "Поле зору захищеності".]<br /></span> так що <code>protected</code> можна залишити як є. Приклад, показаний в Лістингу 13.11, ілюструє захищений доступ.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">p</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Super</span> <span class="o">{</span>
    <span class="k">protected</span> <span class="k">def</span> <span class="n">f</span><span class="o">()</span> <span class="k">=</span> <span class="o">{</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;f&quot;</span><span class="o">)</span> <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Sub</span> <span class="k">extends</span> <span class="nc">Super</span> <span class="o">{</span>
    <span class="n">f</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="k">class</span> <span class="nc">Other</span> <span class="o">{</span>
    <span class="o">(</span><span class="k">new</span> <span class="nc">Super</span><span class="o">).</span><span class="n">f</span><span class="o">()</span> <span class="c1">// error: f is not accessible</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.11 - Як захищений доступ відрізняється в Scala та Java.</p></div>
<div class="paragraph"><p>В Лістингу 13.11 доступ до <code>f</code> в класі <code>Sub</code> є OK, оскільки <code>f</code> декларована як <code>protected</code> в <code>Super</code>, та <code>Subis</code> є субкласом <code>Super</code>. По контрасту, доступ до <code>f</code> в <code>Other</code> не дозволений, оскільки <code>Other</code> не наслідує від <code>Super</code>. В Java останній доступ також буде дозволений, бо <code>Other</code> в тому ж пакунку, що і <code>Sub</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Публічні члени</h3>
<div class="paragraph"><p>Scala не має явного модифікатора для публічних членів: любий член, не відмічений <code>private</code> або <code>protected</code> є публічним. Публічні методи можуть бути доступні будь-де.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">bobsrockets</span>

<span class="k">package</span> <span class="nn">navigation</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">bobsrockets</span><span class="o">]</span> <span class="k">class</span> <span class="nc">Navigator</span> <span class="o">{</span>
    <span class="k">protected</span><span class="o">[</span><span class="kt">navigation</span><span class="o">]</span> <span class="k">def</span> <span class="n">useStarChart</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
    <span class="k">class</span> <span class="nc">LegOfJourney</span> <span class="o">{</span>
      <span class="k">private</span><span class="o">[</span><span class="kt">Navigator</span><span class="o">]</span> <span class="k">val</span> <span class="n">distance</span> <span class="k">=</span> <span class="mi">100</span>
    <span class="o">}</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">speed</span> <span class="k">=</span> <span class="mi">200</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="k">package</span> <span class="nn">launch</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">navigation._</span>
  <span class="k">object</span> <span class="nc">Vehicle</span> <span class="o">{</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">launch</span><span class="o">]</span> <span class="k">val</span> <span class="n">guide</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Navigator</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.12 - Гнучка видимість захищеності з модифікаторами доступа.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Поле зору захищеності</h3>
<div class="paragraph"><p>Модифікатори доступу в Scala можуть бути доповнені за допомогою кваліфакаторів. Модифікатор в форматі <code>private[X]</code> або <code>protected[X]</code> означає, що доступ приватний або захищений "в межах" <code>X</code>, де <code>X</code> позначає деякий оточуючий пакунок, клас або об'єкт синглтон.</p></div>
<div class="paragraph"><p>Кваліфіковані модифікатори доступу надають вам гарний контроль над видимістю. Зокрема, вони дозволяють вам виражати варіанти досяжності Java, такі як приватний в пакунку, захищений в пакунку, або приватний в межах зовнішнього класу, що напряму не виражається простими модифікаторами в Scala. Але вони також дозволяють вам виражати правила доступності, що не можуть бути виражені в Java.</p></div>
<div class="paragraph"><p>Лістинг 13.12 представляє приклад з багатьма вжитими кваліфікаторами доступа. І цьому лістингу клас <code>Navigator</code> помічений як <code>private[bobsrockets]</code>. Це означає, що цей клас видимий у всіх класах та об'єктах, що містяться в пакунку <code>bobsrockets</code>. Зокрема, досутп до <code>Navigator</code> в об'єкті <code>Vehicle</code> дозволений, оскільки <code>Vehicle</code> міститься в пакунку <code>launch</code>, що міститься в <code>bobsrockets</code>. З іншого боку, весь код за межами пакунку <code>bobsrockets</code> не має доступу до класу <code>Navigator</code>.</p></div>
<div class="paragraph"><p>Цей прийом досить корисний в великих проектах, що обіймають декілька пакунків. Він дозволяє визначати речі, що видимі в декількох суб-пакунках, але залишаються приховані для клієнтів, зовнішніх відносно вашого проекту. Той самий прийом неможливий в Java. Там, коли визначення залишає межі свого безпосереднього пакунку, він стає видимий для загального світу.</p></div>
<div class="paragraph"><p>Зазвичай, кваліфікатор <code>private</code> може також бути безпосередньо оточуючим пакунком. Прикладом є модифікатор доступу <code>guide</code> в об'єкті <code>Vehicle</code> з Лістингу 13.12. Такий модифікатор доступу еквівалентний до пакунок-приватного доступу в Java.</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Таблиця 13.1 Ефекти приватних кваліфікаторів на LegOfJourney.distance</caption>
<col width="16%" />
<col width="83%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">немає модифікатора доступу</p></td>
<td align="left" valign="top"><p class="table">публічний доступ</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[bobsrockets]</p></td>
<td align="left" valign="top"><p class="table">доступ в зовнішньому пакунку</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[navigation]</p></td>
<td align="left" valign="top"><p class="table">те саме, що видимість в пакунку в Java</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[Navigator]</p></td>
<td align="left" valign="top"><p class="table">те саме, що <code>private</code> в Java</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[LegOfJourney]</p></td>
<td align="left" valign="top"><p class="table">те саме, що <code>private</code> в Scala</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">private[this]</p></td>
<td align="left" valign="top"><p class="table">доступ тільки в тому самому об'єкті</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Всі кваліфікатори також можуть бути застосовані до <code>protected</code>, з тим же значенням, що і <code>private</code>. Тобто, модифікатор <code>protected[X]</code> в класі <code>C</code> дозволяє доступ до відміченого визначення в усіх субкласах <code>C</code>, та також з оточуючому пакунку, класі, або об'єкті <code>X</code>. Наприклад, метод <code>useStarChart</code> в Лістингу 13.12 доступний в усіх субкласах <code>Navigator</code>, а також у всьому коді, що міститься в оточуючому пакунку <code>navigation</code>. Таким чином це в точності відповідає значенню <code>protected</code> в Java.</p></div>
<div class="paragraph"><p>Кваліфікатори <code>private</code> також можуть посилатись на оточуючий клас або об'єкт. Наприклад, змінна <code>distance</code> в класі <code>LegOfJourney</code> з Лістингу 13.12 помічений як <code>private[Navigator]</code>, так що він видимий будь-де в класі <code>Navigator</code>. Це надає ті самі можливості доступу, що приватні члени внутрішніх класів в Java. Модифікатор <code>private[C]</code>, де <code>C</code> є зовнішінй оточуючий клас, є те саме, що простий <code>private</code> в Java.</p></div>
<div class="paragraph"><p>Нарешті, Scala також має модифікатор доступу, що навіть більш обмежуючий, ніж <code>private</code>. Визначення, помічене <code>private[this]</code>, доступне тільки з того самого об'єкту, що містить визначення. Таке визначення називається об'єкт-приватне. Наприклад, визначення <code>speedin</code> в класі <code>Navigator</code> з Лістингу 13.12 є об'єкт-приватним. Це означає, що любий доступ має не тільки бути в класі <code>Navigator</code>, він має бути зроблений саме з того самого примірника <code>Navigator</code>. таким чином, доступ до <code>speed</code> та <code>this.speed</code> будуть легальними в межах <code>Navigator</code>.</p></div>
<div class="paragraph"><p>Наступний доступ, однак, не буде дозволено, навіть якщо він з'являється в класі  <code>Navigator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">other</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Navigator</span>
<span class="n">other</span><span class="o">.</span><span class="n">speed</span> <span class="c1">// цей рядок не буде компілюватись</span>
</pre></div></div></div>
<div class="paragraph"><p>Помітка члена як <code>private[this]</code> є гарантією, що він не буде видимий з інших об'єктів того самого класу. Це може бути корисно для документації. Це також інколи дозволяє вам писати більш загальні анотації варіантності (дивіться Розділ 19.7 щодо деталей).</p></div>
<div class="paragraph"><p>Щоб підсумувати, Таблиця 13.1 перелічує ефекти від приватних кваліфікаторів. Кожний рядок показує кваліфікований приватний модифікатор, і що він буде означати, якщо такий модифікатор буде приєднаний до змінної <code>distance</code>, декларованої в класі <code>LegOfJourney</code> в Лістингу 13.12.</p></div>
</div>
<div class="sect2">
<h3 id="_____">Видимість та об'єкт компанйон</h3>
<div class="paragraph"><p>В Java статичні члени та члени примірників належать до того самого класу, так що модифікатори доступу застосовуються до них одноманітно. Ви вже мали бачити, що в Scala немає статичних членів; замість ви можете створити об'єкт компанйон, що містить члени, що існують в одній копії. Наприклад, в Лістингу 13.13 об'єкт <code>Rocket</code> є компанйоном класу <code>Rocket</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Rocket</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Rocket.fuel</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">canGoHomeAgain</span> <span class="k">=</span> <span class="n">fuel</span> <span class="o">&gt;</span> <span class="mi">20</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Rocket</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">fuel</span> <span class="k">=</span> <span class="mi">10</span>
  <span class="k">def</span> <span class="n">chooseStrategy</span><span class="o">(</span><span class="n">rocket</span><span class="k">:</span> <span class="kt">Rocket</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rocket</span><span class="o">.</span><span class="n">canGoHomeAgain</span><span class="o">)</span>
      <span class="n">goHome</span><span class="o">()</span>
    <span class="k">else</span>
      <span class="n">pickAStar</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">goHome</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
  <span class="k">def</span> <span class="n">pickAStar</span><span class="o">()</span> <span class="k">=</span> <span class="o">{}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.13 - Доступ до приватних членів класу компанйона та об'єктів.</p></div>
<div class="paragraph"><p>Правила доступу Scala надають привелей об'єктам компанйонам та класам, коли ідеться про приватний або захищений доступ. Клас поділяє всі свої права доступу зі своїм об'єктом компанйоном, та навпаки. Зокрема, об'єкт може отримувати доступ до всіх приватних членів свого класу компанйона, так само, як клас може отримувати доступ до приватних членів об'єкта компанйона.</p></div>
<div class="paragraph"><p>Наприклад, клас <code>Rocket</code> з Лістингу 13.13 може отримати доступ до метода <code>fuel</code>, що декларований приватним в об'єкті <code>Rocket</code>. Аналогічно, об'єкт <code>Rocket</code> може отримати доступ до приватного метода <code>canGoHomeAgain</code> в класі <code>Rocket</code>.</p></div>
<div class="paragraph"><p>Одне виключення, де подібність між Scala та Java ламається, стосується захищених статичних членів. Захицені статичні члени в Java класі <code>C</code> може бути доступним у всіх субкласах <code>C</code>. Для контрасту, захищений член в об'єкті компанйоні не має сенсу, оскікльи об'єкт синглтон не має жодних субкласів.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_13_6___">13.6 Об'єкти пакунків</h2>
<div class="sectionbody">
<div class="paragraph"><p>Доки єдиний код, що ми бачили доданим до пакунків, були класи, трейти та окремі об'єкти. Це найбільш загальні визначення, що розташовуються на верхньому рівні пакунка. Але Scala не обмежує вас лише цім — любий різновид визначення, що ви можете покласти в клас, також може бути на вищому рівні пакунка. Якщо ви маєте деякий допоміжний метод, що ви хочете помістити в поле зору цілого пакунку, дійте, та покладіть його прямо на верхній рівень пакунка.</p></div>
<div class="paragraph"><p>Щоб зробити це, покладіть визначення в об'єкті пакунка. Кожному пакунку дозволяється мати один об'єкт пакунку. Любі визначення, покладені в об'єкт пакунку, розглядаються як члени самого пакунку.</p></div>
<div class="paragraph"><p>Приклад показаний в Лістингу 13.14. Файл <code>package.scala</code> утримує об'єкт пакунку для пакунку <code>bobsdelights</code>. Синтаксично об'єкт пакунку виглядає більш подібно до пакуванян в фігурних дужках, показаних раніше в цій главі. Одна різниця в тому, що він включає ключеве слово <code>object</code>. Це об'єкт пакунку, не пакунок. Вміст фігурних дужок може включати любі визначення за вашим бажанням. В цьому випадку об'єкт пакунку включає допоміжний метод <code>showFruit</code> з Лістингу 13.8.</p></div>
<div class="paragraph"><p>Маючи це визначення, любий інший код в любому пакунку може імпортувати метод, так само, як він може імпортувати клас. Наприклад, Лістинг 13.14 також показує окремий об'єкт <code>PrintMenu</code>, що розміщений в окремому пакунку. <code>PrintMenu</code> може імпортувати допоміжний метод <code>showFruit</code> в той самий спосіб, як він може імпортувати клас <code>Fruit</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// В файлі bobsdelights/package.scala</span>
<span class="k">package</span> <span class="nn">object</span> <span class="n">bobsdelights</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="k">:</span> <span class="kt">Fruit</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">fruit._</span>
    <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;s are &quot;</span> <span class="o">+</span> <span class="n">color</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// В файлі PrintMenu.scala</span>
<span class="k">package</span> <span class="nn">printmenu</span>
<span class="k">import</span> <span class="nn">bobsdelights.Fruits</span>
<span class="k">import</span> <span class="nn">bobsdelights.showFruit</span>

<span class="k">object</span> <span class="nc">PrintMenu</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">fruit</span> <span class="k">&lt;-</span> <span class="nc">Fruits</span><span class="o">.</span><span class="n">menu</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">showFruit</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 13.14 - Об'єкт пакунку.</p></div>
<div class="paragraph"><p>Заглядаючи наперед, існують інші використання об'єктів пакунку для різновидів визначень, які ви ще не бачили. Об'єкти пакунку часто використовуються для пакет-поширених псевдонимів типів (Глава 20) та неявних перетворень (Глава 21). Пакунок <code>scala</code> вищого рівня має об'єкт пакунка, та його визначення доступні для всього Scala кода.</p></div>
<div class="paragraph"><p>Об'єкти пакунка компілюються до файлів класів на ім'я <code>package.class</code>, що розміщені в директорії пакунку, які вони доповнюють. Це корисно для утримання тієї ж домовленості для джерельних файлів. Так що ви типово можете покласти джерельний файл об'єкту пакунка <code>bobsdelights</code> з Лістингу 13.14 в файл на ім'я <code>package.scala</code>, що розташований в директорії <code>bobsdelights</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_13_7_">13.7 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили базові конструкції для поділу вашого коду на пакунки. Це дає вам простий та корисний різновид модульності, так що ви можете робити з дуже великим тілом кода, без того, щоб різні частини коду налазили один на одний. Система Scala є за духом така сама, що і пакунки Java, але існують деякі відмінності, де Scala обирає бути більш узгодженою або більш загальною.</p></div>
<div class="paragraph"><p>Заглядаючи наперед, Глава 29 описує більш гнучку модульну систему, ніж поділення на пакунки. На додаток до надання вам поділу коду на на декілька просторів імен, цей підхід дозволяє модулям бути параметризованими, та наслідувать один від одного. В наступній главі ми звернемо нашу увагу на твердження та юніт тести.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-17 00:38:08 EET
</div>
</div>
</body>
</html>
