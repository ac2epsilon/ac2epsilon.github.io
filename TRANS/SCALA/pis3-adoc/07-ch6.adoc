include::headers.adoc[]

Глава 6
-------

Функціональні об'єкти
=====================

З розумінням основ Scala, яке ви отримали від попередніх глав, ви готові до розробки більш наповнених можливістями класів в Scala. В цій главі ми зробимо наголос не класах, що визначають функціональні об'єкти, або об'єкти, що не мають жодного змінного стану. В якості роблячого прикладу, ми створимо декілька варіантів класу, що моделює раціональні числа як незмінні об'єкти. По ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного програмування в Scala: параметри класів та конструктори, методи та оператори, приватні члени, перекриття, перевірку передумов, перевантаження та посилання на себе.

6.1 Специфікація класа Rational
-------------------------------
_Раціональне число_ є таке, що може бути виражене як відношеня `n/d`, де `n` та `d` є цілі, за винятком того, що `d` не може бути нулем. `n` називається чисельником, та `d` знаменником. Приклади раціональних чисел є 1/2, 2/3, 112/239, та 2/1. Порівняно з числами з плаваючою крапкою, раціональні числа мають перевагу в тому, що дробі представлені точно, без округлення або апроксимації.

Клас, який ми будемо розробляти в цей главі, має моделювати поведінку раціональних чисел, включаючи можливіть додавати їх, віднімати, множити та ділити. Щоб додати двоє раціональних числа, вам треба зпочатку отримати загальний знаменник, потім додати два чисельника. Наприклад, щоб додати `1/2 + 2/3`, ви множите обі частини лівого операнда на 3, та обі частини правого операнда на 2, що дає вам `3/6 + 4/6`. Додавання двох чисельників дає вам результат, `7/6`. Щоб помножити два раціональні числа, ви просто множите їх чисельники, та множите їх займенники. Таким чином, `1/2 * 2/5` дає `2/10`, що може бути представлено більш компактно в "нормалізованій" формі як `1/5`. Ви ділите обмінюючи чисельник та займенник правого операнда, та потім виконуєте множення. Наприклад, `1/2 / 3/5` є те саме, що `1/2 * 5/3`, або `5/6`.

Одне, можливо тривіальне, спостереження полягає в тому, що раціональні числа не мають змінного стану. Ви можете дадати одне раціональне до іншого, але результат буде новим раціональним числом. Оригінальні числа не будуть "змінені". Незмінний клас `Rational`, що ми будемо розробляти в цій главі, буде мати ту саму властивість. Кожне раціональне число буде представлене одним об'єктом `Rational`. Коли ми додаємо два об'єкти `Rational`, ви будете створювати новий об'єкт `Rational` щоб утримувати суму. Ця глава надасть вам  побіжне враження, як Scala дозволяє вам писати бібліотеки, що відчуваються як природна підтримка мови. Наприклад, в кінці цієї глави ви будете в змозі зробити це з класом `Rational`:
[source,scala]
----
scala> val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2

scala> val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3

scala> (oneHalf / 7) + (1 - twoThirds)
res0: Rational = 17/42
----
6.2 Конструювання Rational
--------------------------
Гарне місце почати розробку класа `Rational` є вирішити, як програмісти клієнти будуть створювати новий об'єкт `Rational`. Зважаючи, що ми приняли рішення зробити об'єкти `Rational` незмінними, ми потребуємо, щоб клієнти надали всі дані, що треба для примірника (в цьому випадку чисельник та займенник), коли вони конструюють примірник. Таким чином, ми почнемо розробку з такого:
[source,scala]
----
class Rational(n: Int, d: Int)
----
Одна з перших речей, що треба зауважити щодо цього рядка кода, це те, що якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча ви можете, звичайно, якщо бажаєте). Ідентифікатори `n` та `d` в дужках після імені класу `Rational`, називаються параметрами класу. Компілятор Scala збере докупи ці параметри класу, та створить первинний конструктор, що матиме саме два параметри.

Компроміс незмінних об'єктів
----------------------------
Незмінні об'єкти пропонують декілька переваг над змінним об'єктами, та один потенційний недолік. Перше, незмінні об'єкти часто простіше продумуються, ніж змінні, бо вони не мають складних просторів стану, що змінюються з часом. Друге, ви можете передавати незмінні об'екти довкола досить вільно, тоді як вам може знадобитись робити захисні копії змінних об'єктів, перед тим, як передаватий їх в інший код. Третє, немає способу для двох потоків, що одночасно отримують доступ до незмінного об'єкту, пошкодити його стан, коли він вже відповідно створений, бо потік взагалі не може змінити стан незмінного. Четверте, незмінні об'єкти роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт зміниться після того, як він покладений, наприклад, в `HashSet`, цей об'єкт може бути не знайдений наступний раз, коли ви шукаєте в `HashSet`.

Головний недолік незмінних об'єктів в тому, що вони іноді потребують копіювання великого об'єктного графа, тоді як оновлення може бути зроблене на місці. В деяких випадках це може бути незручно виразити, і також може стати вузьким місцем продуктивності. Як результат, не нє рідкістю для бібліотек провадити змінні альтернативи до незмінних класів. Наприклад, клас `StringBuilder` є змінною альтернативою до незмінного  `String`. Ми надамо вам більше інформації щодо розробки змінних класів в Scala в Главі 18.

NOTE: Цей початковий приклад `Rational` підкреслює різницю між Java та Scala. В Java класи мають конструктори, що можуть приймати параметри; тоді як в Scala класи самі можуть приймати параметри. Нотація Scala більше стисла — параметри класу можуть бути використані напряму в тілі класу; немає потреби визначати поля та писати присвоєння, що копіюють параметри конструктора в поля. Це може дати значну економію в шаблонному коді, особливо для малих класів.

Компілятор Scala буде компілювати любий код, який ви покладете в тіло класа, що не є частиною поля або визначення метода, в первинний конструктор. Наприклад, ви можете надрукувати повідомлення зневадження таким чином:
[source,scala]
----
class Rational(n: Int, d: Int) {
  println("Created " + n + "/" + d)
}
----
Беручи цей код, компілятор Scala покладе виклик до `println` в первинний конструктор `Rational`. Таким чином, виклик `println` буде друкувати своє повідолениня зпевадження, коли ви будете створювати новий примірник `Rational`:
[source,scala]
----
scala> new Rational(1, 2)
Created 1/2
res0: Rational = Rational@2591e0c9
----
6.3 Реалізація метода toString
------------------------------
Коли ви створили примірник `Rational` в попередньому прикладі, інтерпретатор надрукував `Rational@90110a`. Інтерпретатор отримав цей, дещо дивно вигладаючий, рядок викликаючи `toString` на об'єкті `Rational`. По замовченню клас `Rational` наслідує реалізацію `toString`, визначену в класі `java.lang.Object`, що просто друкує ім'я класу, символ `@`, та шістнадцятирічне число. Метод `toString` початково призначений для допомоги програмістам, провадячи інформацію, що може використовуватись для друкування повідомлень зневадження, журналювання повідомлень, звітів про збій тестів, та виводу інтерпретатора та знаваджувача. Результат, що наразі провадиться `toString`, не особливо корисний, бо він не надає жодного натяку щодо значення раціонального числа. Більш корисна реалізація `toString` може друкувати значення чисельника та займенника Rational. Ви можете _перекрити_ реалізацію по замовчанню, через додавання метода `toString` до класу `Rational`, ось так:
[source,scala]
----
class Rational(n: Int, d: Int) {
  override def toString = n + "/" + d
}
----
Модифікатор `override` попереду визначення метода сигналить, що попереднє визначення перекривається (більше про це в Главі 10). Оскільки числа `Rational` тепер будуть гарно відображатись, ми видалили твердження  `println`, що ми поклали в тіло попередньої версії класа `Rational`. Ви можете протестувати нову поведінку  `Rational` в інтерпретаторі:
[source,scala]
----
scala> val x = new Rational(1, 3)
x: Rational = 1/3

scala> val y = new Rational(5, 7)
y: Rational = 5/7
----
6.4 Перевірка передумов
-----------------------
Як наступний крок, ми звернемо нашу увагу на проблему з поточною поведінкою первинного конструктора. Як зазначалось на початку цієї глави, раціональні числа не можуть мати нуль в якості займенника. Однак зараз первинний конструктор приймає нуль, переданий для `d`:
[source,scala]
----
scala> new Rational(5, 0)
res1: Rational = 5/0
----
Одна з переваг об'єктно-орієнтовного програмування є те, що воно дозволяє вам інкапсулювати дані в об'єкті, так що ви можете бути впевнені, що дані валідні на протязі його життя. В випадку незмінних об'єктів, таких як `Rational`, це означає, що вам треба переконатись, що дані валідні при конструюванні об'єкта. Зважаючи, що нульовий займенник є невілідним станом для числа Rational, вам не слідує дозволити конструювання  `Rational`, якщо нуль передається в параметрі `d`.

Кращий шлях підійти до цієї проблеми є визначити передумову в первинному конструкторі, що `d` не має бути нулем. Передумова є обмеження на значення, передані в метод або конструктор, вимога, якій має задовільняти вікликаюча сторона. Один спосіб зробити це є використанян `require`,footnote:[Метод `require` визначений в окремому об'єкті `Predef`. Як зазначено в Главі 4.4, члени `Predef` імпортуються автоматично в кожний файл Scala.] таким чином:
[source,scala]
----
class Rational(n: Int, d: Int) {
  require(d != 0)
  override def toString = n + "/" + d
}
----
Метод `require` приймає один логічний параметр. Якщо передане значення є `true`, `require` поверне керування звичайно. Інакше `require` буде запобігати створенню об'єкта, через виклик `IllegalArgumentException`.

6.5 Додавання полів
-------------------
Тепер, коли первинний конструктор відповідно перевіряє виконання передумови, ми звернемо нашу увагу на підтримку додавання. Щоб зробити це, ми визначимо публічний метод `add` на класі `Rational`, що приймає інше `Rational` як параметр. Щоб утримувати `Rational` незмінним, метод `add` не має додавати передане раціональне число до себе. Скоріше, він має створити та повернути нове `Rational`, що міститиме суму. Ви можете подумати, що можете написати `add` таким чином:
[source,scala]
----
class Rational(n: Int, d: Int) { // Не буде компілюватись
  require(d != 0)
  override def toString = n + "/" + d
  def add(that: Rational): Rational =
    new Rational(n * that.d + that.n * d, d * that.d)
}
----
Однак, маючи цей код, компілятор буде скаржитись:
----
<console>:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^
<console>:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
^
----
Хоча параметри класу `n` та `d` в полі зору коду вашого метода `add`, ви можете отримувати доступ до їх значень тільки для об'єкта, на якому був викликаний метод `add`. Таким чином, коли ви кажете `n` або `d` в реалізцаії `add`, компілятор буде щасливий провадити значення для ціх параметрів класу. Але він не дає вам казати `that.n` або `that.d`, оскільки це не посилається на об'єкт `Rational`, на якому був визваний `add`.footnote:[Насправді, ви можете додати Rational до себе, в якому випадку це буде посилатись на об'єкт, на якому викликається `add`. Але оскільки ви можете передати любий об'єкт `Rational` до `add`, компілятор все ще не дає вам сказати `that.n`.] Щоб отримати чисельник та займенник на `that`, вам треба перетворити їх на поля. Лістинг 6.1 показує, як ви можете додати ці поля до класу `Rational`.footnote:[В Розділі 10.6 ви прочитаєте щодо параметричних полів, що провадять скорочення для написання того самого кода.]
[source,scala]
----
class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  override def toString = numer + "/" + denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}
----
Лістинг 6.1 - Rational з полями.

В версії `Rational`, показаній в Лістингу 6.1 ми дадали два поля на ім'я `numer` та `denom`, та ініціалізували їх значеннями параметрів класу, `n` та `d`.footnote:[Навіть якщо `n` та `d` використовуються в тілі класу, виходячи з того, що вони використовуються тільки в конструкторах, компілятор Scala не буде створювати поля для них. Таким чином, маючи цей код компілятор Scala буде генерувати клас з двома полями `Int`, одне для `numer` та одне для `denom`.] Ми змінили реалізацію `toString` та `add`, так що вони використовують поля, а не параметри класу. Ця версія `Rational` компілюється. Ви можете протестувати її, додавши деякі раціональні числа:
[source,scala]
----
scala> val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2

scala> val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3

scala> oneHalf add twoThirds
res2: Rational = 7/6
----
Інша річ, яку ви можете зробити тепер, але не могли раніше, є доступ до значень чисельника та займенника з поза меж об'єкта. Просто отримайте доступ до публічних полів `numer` та `denom`, ось так:
[source,scala]
----
scala> val r = new Rational(1, 2)
r: Rational = 1/2

scala> r.numer
res3: Int = 1

scala> r.denom
res4: Int = 2
----
6.6 Посилання на себе
---------------------
Ключове слово `this` посилається на примірник об'єкту, на якому був визваний метод, який наразі виконується, або в випадку конструктора - примірник об'єкта, що створюється. Як приклад, розглянемо додавання метода  `lessThan`, що перевіряє, що дане Rational меньше ніж параметр:
[source,scala]
----
def lessThan(that: Rational) =
  this.numer * that.denom < that.numer * this.denom
----
Тут `this.numer` посилається на чисельник об'єкта, на якому викликане `lessThan`. Ви також можете облишити цей префікс, та записати тільки `numer`; дві нотифікації є еквівалентними. Як приклад того, що ви не можете робити без `this`, розглянемо додавання метода `max` до класу `Rational`, що повертає більше з даного раціонального та аргумента:
[source,scala]
----
def max(that: Rational) =
  if (this.lessThan(that)) that else this
----
Тут перше `this` є надлишковим. Ви можете відкинути його, та записати: `lessThan(that)`. Але друге `this` представляє результат метода, в випадку, коли перевірка поверне `false`; коли ми оминемо його, нам нічого не залишиться повертати!

6.7 Додаткові конструктори
--------------------------
Іноді вам треба декілька конструкторів класу. В Scala конструктори, крім первинного, називаються додатковими конструкторами. Наприклад, раціональне число з займенником 1 може бути записане більш лаконічно як один чисельник. Наприклад, замість `5/1`, ви можете записати лише 5. Таким чином, це було б гарно, якщо замість запису `Rational(5, 1)`, програмісти клієнти могли просто писати `new Rational(5)`. Це буде потребувати додавання додаткового конструктора до `Rational`, що приймає лише один аргумент, чисельник, з займенником передвизначеним як 1. Лістинг 6.2 показує, на що це може бути схоже.
[source,scala]
----
class Rational(n: Int, d: Int) {
  require(d != 0)

  val numer: Int = n
  val denom: Int = d

  def this(n: Int) = this(n, 1) // додатковий конструктор

  override def toString = numer + "/" + denom

  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}
----
Лістинг 6.2 - Rational з додатковим конструктором.

Додаткові конструктори в Scala починаються з `def this(...)`. Тіло додаткового конструктора `Rational` просто викликає первинний конструктор, передаючи йому всій єдиний аргумент, `n`, як чисельник, та 1 як займенник. Ви можете бачити додатковий конструктор в дії, написавши таке в інтерпретаторі:
[source,scala]
----
scala> val y = new Rational(3)
y: Rational = 3/1
----
В Scala кожний зовнішінй конструктор має викликати інший конструктор того самого класу в якості першої дії. Іншими словами, перше твердження в кожному додатковому конструкторі кожного класа Scala буде мати форму `this(...)`. Викликаний конструктор є або первинним конструктором (як в прикладі `Rational`), або інший додатковий конструктор, що текстуально іде перед викликаючим конструктором. Нетто ефект з цього правила в тому, що кожний виклик конструктора в Scala згодом буде закінчувати викликом первинного конструктора класу. Первинний конструктор, таким чином, є єдиною точкою входу класу.

NOTE: Якщо ви знакомі з Java, ви можете здивуватись, чому правила Scala для конструкторів трохи більш обмежуючі, ніж в Java. В Java конструктор в якості першой дії має або викликати інший конструктор того самого класу, або напряму викликати конструктор суперкласу. В класах Scala тільки первинний конструктор може викликати конструктор суперкласу. Збільшення обмеження в Scala насправді є компроміс дизайну, який треба заплатити за більшу стислість та простоту констуркторів Scala, порівняно з Java. Суперкласи та деталі, як взаємодіють виклики конструкторів та наслідування, пояснені в Главі 10.

6.8 Приватні поля та методи
---------------------------
В попередній версії `Rational` ми просто ініціалізували `numer` як `n` та `denom` як `d`. Як результат, чисельник та займенник `Rational` можуть бути більші, ніж треба. Наприклад, дріб `66/42` може бути нормалізована до екввалентної скороченої форми, `11/7`, але первинний конструктор `Rational` наразі не робить цього:
[source,scala]
----
scala> new Rational(66, 42)
res5: Rational = 66/42
----
Щоб нормалізувати число і такий спосіб, нам треба розділити чисельник та займенник на їх спільний дільник. Наприклад, найбільший дільник для `66` та `42` є `6`. (Іншими словами, 6 є більшим цілим, що рівно ділить обоє, 66 та 42.) Ділення обох, чисельника та займенника `66/42` на `6` дає скорочену форму, 11/7. Лістинг 6.3 показує спосіб, як зробити це:
[source,scala]
----
class Rational(n: Int, d: Int) {
  
  require(d != 0)

  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g

  def this(n: Int) = this(n, 1)

  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
  )

  override def toString = numer + "/" + denom

  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}
----
Лістинг 6.3 - Rational з приватним полем та методом.

В цій версії Rational ми додали приватне поле `g`, та модифікували ініціалізатори для `numer` та `denom`. (Ініціалізатор є код, що ініціалізує змінну; наприклад, `n / g`, що ініціалізує `numer`.) Оскільки `g` є приватним, доступ до неї може відбуватись тільки з тіла класу, але не ззовні. Ми також додали приватний метод, `gcd`, що обчислює найбільший загальний дільник двох переданих `Int`. Наприклад, `gcd(12, 8)` є `4`. Як ви бачили в Розділі 4.1, щоб зробити поле або метод приватними, ви просто можете покласти ключове слово `private` перед його визначенням. Призначення приватного "допоміжного метода" `gcd` є виділити код, потрібний для якоїсь іншої частини класу, в цьому випадку первинному конструктору. Щоб переконатись, що `g` завжди додатнє, ми передаємо абсолютні значення `n` та `d`, що ми отримали через виклик на них метода `abs`, метод, що ви можете викликати на кожному `Int` щоб отримати його абсолютне значення.

Компілятор Scala буде покладати код для ініціалізаторів трьох полів `Rational` в первинний конструктор, в порядку як вони з'являються в джерельному коді. Таким чином, ініціалізатор `g`, `gcd(n.abs, d.abs)`, буде виконуватись перед іншими двома, оскільки він іде першим в тексті. Поле `g` буде ініціалізоване результатом, найбільшим загальним дільником абсолютних значень параметрів класу, `n` та `d`. Поле `g` потім використовується в ініціалізаторах `numer` та `denom`. Після ділення `n` та `d` на їх найбільший загальний дільник, `g`, кожний `Rational` буде сконструйований в його нармалізованій формі:
[source,scala]
----
scala> new Rational(66, 42)
res6: Rational = 11/7
----
6.9 Визначення операцій
-----------------------
Поточна реалізація додавання `Rational` є OK, але може бути зроблене зручнішим в роботі. Ви можете спитати себе, чому ви можете записати:
[source,scala]
----
x + y
----
якщо `x` та `y` є цілі або з плаваючою крапкою, але ви маєте писати:
[source,scala]
----
x.add(y)
----
або щонайменше:
[source,scala]
----
x add y
----
якщо вони раціональні числа. Немає переконливої причини, чому має бути саме так. Раціональні числа є числами, як любі інші числа. В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з плаваючою крапкою.

Чому ми не повинні використовувати природні арифметичні оператори для них? В Scala ви можете робити це. В залишку глави ми покажемо вам як.

Перший крок є замінити `add` на звичайний математичний символ. Це прямолінійне, бо `+` є легальним ідентифікатором в Scala. Ми можемо просто визначили метод з `+` в якості імені. Поки ми вже в цьому, ми можемо також реалізувати метод на ім'я `*`, що виконує множення. Результат показаний в Лістингу 6.4:
[source,scala]
----
class Rational(n: Int, d: Int) {

  require(d != 0)

  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / gdef this(n: Int) = this(n, 1)

  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )

  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  
  override def toString = numer + "/" + denom
  
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}
----
Лістинг 6.4 - Rational з операторними методами.

Коли клас `Rational` визначений в цей спосіб, тепер ви можете записати:
[source,scala]
----
scala> val x = new Rational(1, 2)
x: Rational = 1/2

scala> val y = new Rational(2, 3)
y: Rational = 2/3

scala> x + y
res7: Rational = 7/6
----
Як завжди, операторний синтаксис в останньому рядку еквівалентний до викликуу метода. Ви можете також записати:
[source,scala]
----
scala> x.+(y)
res8: Rational = 7/6
----
але це не читабельне.

Інша річ, що треба зауважити, є приймаючи до уваги правила Scala для преоритетів операторів, описані в Розділі 5.9, метод `*` буде притулятись більш тісно, ніж метод `+` для `Rationals`. Іншими словами, вираз, що включає операції `+` та `*` на `Rationals` буде поводитись як очікується. Наприклад, `x + x * y` буде виконуватись як `x + (x * y)`, не `(x + x) * y`:
[source,scala]
----
scala> x + x * y
res9: Rational = 5/6

scala> (x + x) * y
res10: Rational = 2/3

scala> x + (x * y)
res11: Rational = 5/66.10 
----
Ідентифікатори в Scala
----------------------
Тепер ви бачили два найбільш важливі способи сформувати ідентифікатор в Scala: алфавітно-цифрові та оператори. Scala має дуже гнучки правила для формування ідентифікаторів. Кірм двох форм ви також бачили тут дві інші. Всі чотири форми створенні ідентифікатоірв описані і цьому розділі. Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення, за яким можуть далі слідувати літери, цифри або підкреслення. Символ `$` також рахується як літера; однак, вона зарезервована для ідентифікатором, згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах по повинні містити символи `$`, навіть якщо це і буде компілюватись; якщо вони будуть, це може призвести до стикання імен з ідентифікаторами, згенерованих компілятором Scala.

Scala слідує домовленості Java використання кемел-кейсу в ідентифікаторах,footnote:[Цей стиль іменування ідентифікаторів названий кемел-кейс (верблюжий реєстр), оскільки ідентифікатори HaveHumps мають вбудовані великі літери.] такі як `toString` та `HashSet`. Хоча підкреслення є легальні в ідентифікаторах, вони не використовуються так часто в Scala програмах, частково щоб бути узгодженою з Java, але також оскільки підкреслення мають багато інших не-ідентифікаторних використань в Scala коді. Як результат, накраще уникати ідентифікаторів, як `to_string`, `__init__`, або `name_`.

Кемел-кейс імена полів, параметрів методів, локальних змінних та функцій повинні починатись з літери в нижньому реєстрі, наприклад: `length`, `flatMap` та `s`. Кемел-кейс імена класів та трейтів повинні починатись з літери в верхньому реєстрі, наприклад: `BigInt`, `List` та `UnbalancedTreeMap`.footnote:[В Розділі 16.5 ви побачите, що іноді ви бажаєте надати спеціальному типу класу, відомому як кейс клас, ім'я, що повністю складається з символів операторів. Наприклад, Scala API має клас на ім'я `::`, що спрощує співпадіння шаблонів для List.]

NOTE: Один наслідок з використання заключного підкреслення в ідентифікаторі є в тому, що якщо ви спробуєте, наприклад, написати декларацію, як цю: `val name_: Int = 1`, ви отримаєте помилку компілятора. Компілятор буде думати, що ви намагаєтесь декларувати `val` на ім'я `name_:`. Щоб змісити це компілюватись, вам треба вставити додатковий проміжок перед двокрапкою, як тут: `val name_ : Int = 1`.

Один шлях, в який домовленості Scala відходять від Java включають імена констант. В Scala слово `constant` означає на просто `val`. Навіть якщо `val` має залишатись сталою після ініціалізації, це все ще змінна. Наприклад, параметри методів є `vals`, але кожний раз, коли визивається метод, ці `val` може містити різні значення. `constant` більш стійкі. Наприклад, `scala.math.Pi` визначена щоб бути значенням подвійної точності, найближчим до дійсного значення `π`, відношення довжини кола до його диаметру. Це значення навряд чи зміниться будь-коли; таким чином, `Pi` явно є константою. Ви можете також використовувати константи для надання імен значенням, що інакше були б магічними числами в коді: літеральні значення без пояснення, що в гіршому випадку з'являються в декількох місцях. Ви можете також побажати визначити константи для використання в співпадінні шаблонів, приклади використання яких описані в Розділі 15.2. В Java домовленість полягає в використанні імен констант з великих літер, з підкресленнями в якості роздільнииків слів, таких як `MAX_VALUE` або `PI`. В Scala домовленість просто така, щоб перша літера була великою. Таким чином, константи, названі в стилі Java, такі як `X_OFFSET`, будуть робити як Scala константи, але домовленість Scala використовувати кемел-кейс для констант, такі як `XOffset`.

Операторний ідентифікатор складається з одного або більше операторних символів. Операторні символи є друковані ASCII символи, такі як `+`, `:`, `?`, `~` або `#`.footnote:[Більш точно, операторний символ належить до множини Unicode математичних символів (Sm) або інших символів (So), або до 7-бітних ASCII символів, що не є літерами, цифрами, дужками, прямокутними дужками, фігурними дужками, поодинокими та подвійними лапками, або підкресленням, крапкою, крапкою з комою, комою, або апострофом.] Ось деякі приклади операторних ідентифікаторів:
[source,scala]
----
+
++
::: <?>
:->
----
Компілятор Scala буде всредині "колдувати" з операторними ідентифікаторами, щоб перетворити їх на легальні  Java ідентифікатори з вбудованими символами `$`. Наприклад, ідентифкатор `:->` внутрішньо буде представлений як `$colon$minus$greater`. Якщо ви колись побажаєте отримати доступ до цього ідентифікатора з Java кода, вам знадобиться використовувати цю внутрішню репрезентацію.

Оскільки операторні ідентифікатори в Scala можуть стати довільно довгі, існує мала різниця між Java та Scala. В Java ввод `x<-y` буде розібране як чотири лексичні символі, так що це буде еквівалентне до `x < - y`. В Scala `<-` буде розібране як єдиний ідентифікатор, даючи `x <- y`. Якщо ви бажаєте першу інтерпретацію, вам треба відокремити символи `<` та `-` проміжками. Це навряд чи буде проблемою на практиці, бо дуже мало людей пишуть `x<-y` в Java, без вставлення проміжків або дужок між операторами.

Змішений ідентифікатор складається з алфавітно-цифрового ідентифікатора, за яким слідує підкреслення, та операторний ідентифікатор. Наприклад, `unary_+` використовується як ім'я метода, що визначає унарний оператор `+`. Або `myvar_=`, що використовується як ім'я метода, що визначає оператор присвоєння. На додаток, змішані ідентифікатори в формі `myvar_=` генеруються компілятором Scala для підтримки властивостей (більше про це в Главі 18).

Літеральний ідентифікатор є довільним рядком, оточений зворотніми апострофами \`...\`. Деякі приклади літеральних ідентифікатоірв:
[source,scala]
----
`x`
`<clinit>`
`yield`
----
Ідея в тому, що ви покладаєте любий рядок, що допустимий під час виконання, як ідентифікатор між апострофами. Результат завжди є Scala ідентифікатор. Це робить навіть якщо ім'я в апострофах буде зарезервованим словом Scala. Типове використання є доступ до статичного метода `yield` в класі Java Thread. Ви не можете писати `Thread.yield()`, оскільки `yield` є зарезервованим словом Scala. Однак ви можете все ще назвати метод в апострофах, тобто `Thread.`yield`()`.

6.11 Перевантаження методів
---------------------------
Повернемось до класу `Rational`. З останніми змінами ви тепер можете робити операції додавання та множення в природний спосіб на раціональних числах. Але одна річ все ще відсутня - це змішана арифметика. Наприклад, ви не можете множити раціональне число на ціле, оскільки операнди `*` завжди мають бути `Rational`. Так що для раціонального числа `r` ви не можете написати `r * 2`. Ви маєте писати `r * new Rational(2)`, що не таке гарне.

Щоб зробити `Rational` навіть ще зручнішим, ми додаємо методи до класу, що виконують змішане додавання та множення на раціональних числах та цілих. Доки ми тут, ми також додаємо методи для віднімання та ділення. Результат показаний на Лістингу 6.5.
[source,scala]
----
class Rational(n: Int, d: Int) {
  
  require(d != 0)

  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  
  def this(n: Int) = this(n, 1)

  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )

  def + (i: Int): Rational =
    new Rational(numer + i * denom, denom)
  
  def - (that: Rational): Rational =
    new Rational(
      numer * that.denom - that.numer * denom,
      denom * that.denom
    )

  def - (i: Int): Rational =
    new Rational(numer - i * denom, denom)
  
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)

  def * (i: Int): Rational =
    new Rational(numer * i, denom)

  def / (that: Rational): Rational =
    new Rational(numer * that.denom, denom * that.numer)

  def / (i: Int): Rational =
    new Rational(numer, denom * i)

  override def toString = numer + "/" + denom
  
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}
----
Лістинг 6.5 - Rational з перевантаженими методами.

Тепер є дві версії для кожного арифметичного метода: одна що приймає раціональне в якості аргумента, та інша, що приймає ціле. Іншими словами, ім'я кожного з ціх методів перевантажене, оскільки кожне ім'я може використовуватись для декількох методів. Наприклад, ім'я `+` використовується одним методом, що приймає `Rational`, та інший, що приймає `Int`. В виклику метода компілятор обирає версію перевантаженого методу, що коректно співпадає з типами аргументів. Наприклад, якщо аргумент `y` в `x.+(y)` є `Rational`, компілятор буде обирати метод `+`, що приймає параметр `Rational`. Але якщо аргумент є цілим, компілятор обере метод `+`, що приймає параметр `Int`. Якщо ви спробуєте це:
[source,scala]
----
scala> val x = new Rational(2, 3)
x: Rational = 2/3

scala> x * x
res12: Rational = 4/9

scala> x * 2
res13: Rational = 4/3
----
Ви побачите, що викликаний метод `*` визначений в кожному випадку по типу правого операнду.

NOTE: процес Scala з розрішення перевантажених методів дуже подібний до Java. В жодному разі обрана перевантажена версія є однією, що найкраще співпадає зі статичними типами аргументів. Іноді немає версії для унікального кращого співпадіння; в такому випадку компілятор видасть вам помилку "ambiguous reference".

6.12 Неявні перетворення
------------------------
Тепер, коли ви можете написати `r * 2`, ви можете також побажати обміняти операнди, як `2 * r`. Нажаль, це все ще не робить:
[source,scala]
----
scala> 2 * r
<console>:10: error: overloaded method value * with
alternatives:
(x: Double)Double <and>
(x: Float)Float <and>
(x: Long)Long <and>
(x: Int)Int <and>
(x: Char)Int <and>
(x: Short)Int <and>
(x: Byte)Int
cannot be applied to (Rational)
2 * r
^
----
Проблема тут в тому, що `2 * r` еквівалентне до `2.*(r)`, так що це виклик метода на числі 2, що є цілим. Але клас `Int` не містить метода множення, що приймає аргумент `Rational` — він не може, бо клас `Rational` не є стандартним класом в бібліотеці Scala.

Однак є інший шлях вирішити цю проблему в Scala: ви можете створити неявне перетворення, що автоматично конвертує цілі на раціональні числа в разі потреби. Спробуйте додавання цього рядка в інтерпретатор:
[source,scala]
----
scala> implicit def intToRational(x: Int) = new Rational(x)
----
Це викликає метод перетвоерння з `Int` до `Rational`. Модифікатор `implicit` попереду метода каже компілятору застосувати його автоматично в декількох ситуаціях. З визначеним перетворенням, ви можете повторити спробу приклада, що схибив до цього:
[source,scala]
----
scala> val r = new Rational(2,3)
r: Rational = 2/3

scala> 2 * r
res15: Rational = 4/3
----
Щоб неявне перетворення працювало, воно має бути в полі зору. Якщо ми покладемо визначення неявного метода в клас `Rational`, він не буде в полі зору інтерпретатора. Поки ви повинні визначати його прямо в інтерпретаторі. Як ви здогадались з цього приклада, неявні перетворення дуже потужний прийом, щоб зробити бібліотеки більш гнучкими та більш зручними для використання. Оскільки вони такі потужні, вони можуть бути легко невірно використані. Ви побачите більше щодо неявних перетворень, включаючи шляхи занести їх в поле зору коли треба, в Главі 21.

6.13 Слово попередження
-----------------------
Як демонструє ця глава, створення методів з іменами операторів та визначення неявних перетворень може допомогти вам розробляти бібліотеки, для яких клієнтськіій код є стислим та легко зрозумілим. Scala дає вам велику пропозицію щодо потужності, щоб розробляти такі прості-в-використанні бібліотеки. Але майте на увазі, що з силою іде відповідальність.

Використані без майстерності, обоє, операторні методи та неявні перетворення можуть дати поштовх клієнтському коду, що складно читати та розуміти. Оскільки неявні перетворення застосовуються неявно компілятором, не явно прописані в коді, може бути неочевидним для програмістів клієнтів, що невні перетворення були застосовані. Та хоча операторні методи будуть звичайно робити клієнтський код більш стислим, вони будуть робити його краще читаємим тільки в тій мірі, в якій програмісти клієнітв будуть здатні розпізнавати та запам'ятовувати значення кожного оператора. Ціль, яку ви маєте тримати в голові, коли розробляєте бібліотеки, це не просто зрообити можливим підвищити стислість клієнтського кода, але також читабельний, зрозумілий клієнтський код. Стислість часто буде великою часткою читабельності, але ви можете зайти в стислості дуже далеко. Розробляючі бібліотеки, що дозволяють стислість зі смаком, та в той же час зрозумілий клієнтський код, ви можете допомогти програмістам клієнтів робити продуктивно.

6.14 Висновок
-------------
В цій главі ви бачили багато аспектів класів в Scala. Ви бачили, як додавати параметри до класу, визначати декілька конструкторів, визначати оператори як методи, та налаштовувати класи, так щоб користування їми було природним. Можливо, більш важливо, ви побачили, що визначення та використання незмінних об'єктів є досить натуральним шляхом кодувати в Scala.

Хоча фінальна версія `Rational`, показана в цій главі, задовільняє всім вимогам, встановленим напочатку глави, він все ще може покращений. Ми будемо фактично повертатись до цього прикладу пізніше в цій книзі. Наприклад, в Главі 30 ми вивчемо, як перекривати `equals` та `hashcode`, щоб дозволити `Rationals` краще поводитись при порівнянні за допомогою `==` або покладаючись в хеш таблиці. В Главі 21 ви навчитесь, як покласти визначення неявних методів в об'єкт компанйон `Rational`, так що вони можуть бути більш легко покладені в поле зору, коли програмісти клієнтів роблять з `Rationals`.

