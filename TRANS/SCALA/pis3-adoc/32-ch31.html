<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__31">Глава 31</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__scala__java">Комбінування Scala та Java</h1>
<div class="paragraph"><p>Scala код часто використовується в тандемі з великими Java програмами та фреймворками. Оскільки Scala високо сумісна з Java, більшість часу ви можете комбінувати мови без великих турбот. Наприклад, стандартні фреймворки, такі як <code>Swing</code>, <code>Servlets</code> та <code>JUnit</code> відомо роблять досить гарно зі Scala. Тим не менше, час від часу ви будете натрапляти на якісь проблеми, комбінуючи Java та Scala.</p></div>
<div class="paragraph"><p>Ця глава описує два аспекти комбінування Java та Scala. Перше, вона описує, як Scala транслюється до Java, що особливо важливо, якщо ви викликаєте Scala код з Java. Друге, вона дискутує використання Java анотацій в Scala, важлива можливість, якщо ви бажаєте використовувати Scala з існуючим Java фреймворком.</p></div>
<div class="sect1">
<h2 id="_31_1__scala__java">31.1 Використання Scala з Java</h2>
<div class="sectionbody">
<div class="paragraph"><p>Більшість часу ви можете думати про Scala на рівні джерельного коду. Однак ви будете мати багатше розуміння того, як робить система, якщо ви будете дещо знати про її трансляцію. Більше того, якщо ви викликаєте Scala код з Java, вам буде треба знати, як Scala код виглядає з точки зору Java.</p></div>
<div class="sect2">
<h3 id="__">Загальні правила</h3>
<div class="paragraph"><p>Scala реалізована як трансляція до стандартного байткоду Java. Наскільки це можливо, можливості Scala відображуються напряму на еквівалентні Java можливості. Наприклад, Scala класи, методи, рядки та виключення всі компілюються до таких самих в Java байткоді, як і колеги з Java.</p></div>
<div class="paragraph"><p>Щоб зробити це можливим, знадобився подекуди непростий вибір дизайну Scala. Наприклад, це могло б бути гарним, щоб розрішувати перевантажені методи під час виконання, використовуючи типи часу виконання, скоріше ніж під час компіляції. Однак такий дизайн буде стикатись з аналогічним в Java, що зробить значно складнішим змішувати Java та Scala. В цьому випадку Scala залишається з розрішенням перевантаження від Java, і, таким чином, Scala методи та виклики методів можуть напряму відображатись на Java методи та виклики методів.</p></div>
<div class="paragraph"><p>Scala має власний дизайн для інших можливостей. Наприклад, трейти не мають еквівалента в Java. Подібно до цього, хоча обоє, Scala та Java мають дженерік типи, деталі обох систем конфліктують. Для можливостей мови, як ці, код Scala не може напряму відобразитись на Java конструкції, так що вони мають бути закодовані з використанням якоїсь комбінації структур, що має Java.</p></div>
<div class="paragraph"><p>Для ціх можливостей, що відображаються непрямо, кодування не фіксоване. Є постійне зусилля зробити трансляцію такою простою, як це можливо, так що на час, коли ви це читаєте, деякі деталі можуть бути різні, відносно часу написання. Ви можете знайти, яку трансляцію використовує ваш поточний компілятор Scala, продивившись <code>.class</code> файли за допомогою інструментів, як <code>javap</code>.</p></div>
<div class="paragraph"><p>Такі головні правила. Тепер розглянемо деякі особливі випадки.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Типи значень</h3>
<div class="paragraph"><p>Тип значення, як <code>Int</code>, може бути трансльований до Java в два різні способи. Коли можливо, компілятор транслює <code>Scala</code> <code>Int</code> до <code>Java</code> <code>int</code>, щоб отримати кращу продуктивність. Однак іноді це не можливо, оскільки компілято не впевнений, чи він транслює <code>Int</code>, або деякий інший тип даних. Наприклад, зокрема <code>List[Any]</code> може містити тільки <code>Int</code>, але компілятор не має способу бути впевненим.</p></div>
<div class="paragraph"><p>В таких випадках, коли компілятор невпевнений, чи об'єкт є значенням або ні, компілятор використовує об'єкти та покладається на класи огортки. Наприклад, класи огорток, такі як <code>java.lang.Integer</code> дозволяють типам значень бути огорнутими в Java об'єкт, і так оброблятись кодом, що потребує об'єктів.<span class="footnote"><br />[Реалізація типів значень була обговорена в деталях в Розділі 11.2.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="___">Синглтон об'єкти</h3>
<div class="paragraph"><p>Java не має точного еквіваленту до синглтон об'єктів, але вона має статичні методи. Трансляція Scala синглтон об'єктів використовує комбінацію статичних методів та методів примірника. Для кожного об'єкта синглтона Scala, компілятор буде створювати Java клас для об'єкта з доданим до нього в кінці знака долара. Для об'єкта синглтона на ім'я <code>App</code> компілятор продукує Java клас на ім'я <code>App$</code>. Цей клас має всі методи та поля об'єкта синглтона Scala. Клас Java також має єдине статичне поле та ім'я <code>MODULE$</code>, що зберігає один примірник класу, що створений під час виконання.</p></div>
<div class="paragraph"><p>Як повний приклад, уявімо, що ви компілюєте наступний синглтон об'єкт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, world!&quot;</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala буде генерувати Java клас <code>App$</code> з наступними полями та методами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javap</span> <span class="nc">App</span><span class="n">$</span>
<span class="n">public</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">App$</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span>
<span class="n">implements</span> <span class="n">scala</span><span class="o">.</span><span class="nc">ScalaObject</span><span class="o">{</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="nc">App</span><span class="n">$</span> <span class="nc">MODULE</span><span class="n">$</span><span class="o">;</span>
  <span class="n">public</span> <span class="n">static</span> <span class="o">{};</span>
  <span class="n">public</span> <span class="nc">App</span><span class="n">$</span><span class="o">();</span>
  <span class="n">public</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">[]);</span>
  <span class="n">public</span> <span class="n">int</span> <span class="nc">$tag</span><span class="o">();</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це трансляція для загального використання. Важливий особливий випадок коли ви маєте "самостійний" синглтон об'єкт, що не іде з класом з таким самим ім'ям. Наприклад, ви можете мати об'єкт синглтон на ім'я <code>App</code>, але не мати жодного класу на ім'я <code>App</code>. В цьому випадку компілятор буде створювати Java клас на ім'я <code>App</code>, що має статичний метод перенаправлювач для кожного метода об'єкта синглтоона Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javap</span> <span class="nc">App</span>
<span class="nc">Compiled</span> <span class="n">from</span> <span class="s">&quot;App.scala&quot;</span>
<span class="n">public</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">App</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span><span class="o">{</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">int</span> <span class="nc">$tag</span><span class="o">();</span>
  <span class="n">public</span> <span class="n">static</span> <span class="k">final</span> <span class="n">void</span> <span class="n">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">[]);</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Для контрасту, якщо ви мали клас на ім'я <code>App</code>, Scala буде ствоорювати відповідний Java клас <code>App</code> для зберігання всіх членів класу <code>App</code>, що ви визначили. В цьому випадку він не буде додавати жодних методів перенаправлення для так-само-названого об'єкта синглтона, та Java код буде мати доступ до синглтона через поле <code>MODULE$</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____2">Трейти як інтерфейси</h2>
<div class="sectionbody">
<div class="paragraph"><p>Компіляція любого трейта створює Java інтерфейс з тим самим ім'ям. Цей інтерфейс корисний як Java тип, та він дозволяє вам викликати методи на об'єктах Scala через змінні цього типу.</p></div>
<div class="paragraph"><p>Реалізація трейта в Java є інша історія. В загальному випадку це не принципово; однак один особливий випадок важливий. Якщо ви робите Scala трейт, що включає тільки абстрактні методи, тоді цей трейт буде трансльований напряму в Java інтерфейс, без іншого коду, про який треба турбуватись. В основному це означає, що ви можете написати Java інтерфейс в Scala синтаксисі, якщо побажаєте.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_31_2_">31.2 Анотації</h2>
<div class="sectionbody">
<div class="paragraph"><p>Система загальних анотацій Scala обговорювалась в Главі 27. Цей розділ обговорює Java-специфічні аспекти анотацій.</p></div>
<div class="sect2">
<h3 id="_____">Додаткові ефекти від стандартних анотацій</h3>
<div class="paragraph"><p>Декілька анотацій призводять до того, що компілятор видає додаткову інформацію, коли націлений на Java платформу. Коли компілятор бачить таку анотацію, він спочатку обробляє її відповідно до загальним правилам Scala, і потім він робить дещо додаткове для Java.</p></div>
<div class="paragraph"><p><strong>Застаріння</strong> Для любого метода або класа, відміченого як <code>@deprecated</code>, компілятор буде додавати власну анотацію Java до видаваємого коду. Завдяки цьому Java компілятори можуть видивати попередження, коли Java код отримує застарілі Scala методи.</p></div>
<div class="paragraph"><p><strong>Мінливі поля</strong> Подібним чином, любе поле, відмічене як <code>@volatile</code> в Scala отримує Java модифікатор <code>volatile</code> в виданому коді. Таким чином, мінливі поля в Scala поводяться точно у відповідності до Java сементики, та доступ до мінливих полів відбувається в послідовності точно відповідно до правил, заданих для мінливих полів в Java моделі пам'яті.</p></div>
</div>
<div class="sect2">
<h3 id="_">Сериалізація</h3>
<div class="paragraph"><p>Три стандартні анотації сериалізації Scala всі транслюються до Java еквівалентів.</p></div>
<div class="paragraph"><p>Клас <code>@serializable</code> має доданий до нього Java інтерфейс <code>Serializable</code>.</p></div>
<div class="paragraph"><p>Анотація <code>@SerialVersionUID(1234L)</code> конвертується на наступне визначення поля Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Маркер версії серіалізації Java</span>
<span class="k">private</span> <span class="k">final</span> <span class="n">static</span> <span class="n">long</span> <span class="nc">SerialVersionUID</span> <span class="k">=</span> <span class="mi">1234L</span>
</pre></div></div></div>
<div class="paragraph"><p>Люба змінна, відмічена <code>@transient</code> отримує Java модифікатор <code>transient</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Закидання виключень</h3>
<div class="paragraph"><p>Scala не перевіряє, що закинуті виключення перехоплюються. Таким чином Scala не має еквіваленту до Java декларації <code>throws</code> на методах. Всі Scala методи транслюються до Java методів, що не декларують закидання виключень.<span class="footnote"><br />[Причина, з якох все це робить, в тому, що перевіряч байткоду Java взагалі не перевіряє декларацій! Компілятор Java перевіряє, але не перевіряч.]<br /></span></p></div>
<div class="paragraph"><p>Причина, чому ця можливість видалена зі Scala в тому, що досвід Java з цім був не дуже позитивний. Оскільки анотовані методи зі <code>throws</code> спричиняли жорсткий безлад, дуже багато розробників писали код, що ковтає і відкидає виключення, тільки щоб зробити компіляцію коду без додавання ціх всіх тверджень <code>throws</code>. Можливо вони мали намір покращити обробку виключень пізніше, але досвід показує, що всі надто часто придушені строками програмісти ніколи не будуть повертатись та додавати потрібну обробку виключень. Перекручений результат в тому, що ця можливість з кращих намірів часто завершувалась створенням меньш надійного коду. Велика кількість промислового Java коду ковтає та приховує рантайм виключення, і причиною робити це є задоволення компілятора.</p></div>
<div class="paragraph"><p>Однак іноді, коли робиться інтерфейс до Java, вам може знадобитись написати Scala код, який має дружні до Java анотації, що описують, які виключення ваш метод буде закидати. Наприклад, кожний метод в віддаленому інтерфейсі RMI потребує зазначити <code>java.io.RemoteException</code> в твердженні <code>throws</code>. Таким чином, якщо ви бажаєте написати віддалений інтерфейс RMI як Scala трейт з абстрактними методами, вам знадобиться перелічити <code>RemoteException</code> в твердженні <code>throws</code> для ціх методів. Щоб досягти цього, все що вам треба зробити це відмітити ваші методи анотацією <code>@throws</code>. Наприклад, Scala клас, показаний в Лістингу 31.1 має метод, позначений що закидає <code>IOException</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">java.io._</span>
<span class="k">class</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">fname</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">in</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fname</span><span class="o">))</span>
  <span class="nd">@throws</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">IOException</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">read</span><span class="o">()</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">read</span><span class="o">()</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 31.1 - Метод Scala, що декларує Java твердження <code>throws</code>.</p></div>
<div class="paragraph"><p>Ось як це виглядає з боку Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javap</span> <span class="nc">Reader</span>
<span class="nc">Compiled</span> <span class="n">from</span> <span class="s">&quot;Reader.scala&quot;</span>
  <span class="n">public</span> <span class="k">class</span> <span class="nc">Reader</span> <span class="k">extends</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Object</span> <span class="n">implements</span>
<span class="n">scala</span><span class="o">.</span><span class="nc">ScalaObject</span><span class="o">{</span>
  <span class="n">public</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">String</span><span class="o">);</span>
  <span class="n">public</span> <span class="n">int</span> <span class="n">read</span><span class="o">()</span> <span class="n">throws</span> <span class="n">java</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="nc">IOException</span><span class="o">;</span>
<span class="n">public</span> <span class="n">int</span> <span class="nc">$tag</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">$</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що метод <code>read</code> вказує за допомогою твердження <code>Java</code> <code>throws</code>, що він може закидати <code>IOException</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_java_">Java анотації</h3>
<div class="paragraph"><p>Існуючі анотації з Java фреймворків можуть напряму використовуватись в Scala коді. Любий Java фреймворк буде бачити анотації, що ви пишете, так само, якби ви писали це в Java.</p></div>
<div class="paragraph"><p>Широка різноманіть Java пакунків використовує анотації. Як приклад, розглянемо JUnit 4. JUnit це фреймворк для написання та виконання автоматизованих тестів. Остання версія, JUnit 4, використовує анотації для вказання, які частини вашого коду є тестами. Ідея в тому, що ви пишете багато тестів для вашого коду, та потім ви використовуєте ці тести коли змінюєте свій код. Таким чином, якщо ваші зміни додають нову ваду, один з ціх тестів буде хибити, і ви безпосередньо це з'ясуєте.</p></div>
<div class="paragraph"><p>Написання тестів просте. Ви просто пишете метод в класі верхнього рівня, що виконує ваш код, та ви використовуєте анотацію для відмітки вашого метода як тесту. Це виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.junit.Test</span>
<span class="k">import</span> <span class="nn">org.junit.Assert.assertEquals</span>

<span class="k">class</span> <span class="nc">SetTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="k">def</span> <span class="n">testMultiAdd</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">set</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>testMultiAdd</code> є тестом. Цей тест дадає декілька елементів до множини, та переконується, що кожний доданий тільки один раз. Метод <code>assertEquals</code>, що іде як частина JUnit API, перевіряє, що два його аргументи рівні. Якщо вони різні тест схибить. В цьому випадку тест перевіряє, що повторюване додавання тих самих чисел не збільшує розмір множини.</p></div>
<div class="paragraph"><p>Тест відмічений з використанням анотації <code>org.junit.Test</code>. Зауважте, що ця анотація була імпортована, так що на неї посилається як просто <code>@Test</code>, замість більш заплутаного <code>@org.junit.Test</code>.</p></div>
<div class="paragraph"><p>Ось і все тут про це. Тест може бути виконаний з використанням любого виконувача JUnit. Ось як він виконується за допомогою виконувача з командного рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scala</span> <span class="o">-</span><span class="n">cp</span> <span class="n">junit</span><span class="o">-</span><span class="mf">4.3</span><span class="o">.</span><span class="mf">1.</span><span class="n">jar</span><span class="k">:</span><span class="kt">.</span> <span class="kt">org.junit.runner.JUnitCore</span> <span class="kt">SetTest</span>
<span class="nc">JUnit</span> <span class="n">version</span> <span class="mf">4.3</span><span class="o">.</span><span class="mi">1</span>
<span class="o">.</span>
<span class="nc">Time</span><span class="k">:</span> <span class="err">0</span><span class="kt">.</span><span class="err">023</span>
<span class="kt">OK</span> <span class="o">(</span><span class="err">1</span> <span class="kt">test</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____">Написання ваших власних анотацій</h3>
<div class="paragraph"><p>Щоб зробити анотацію, що видима для Java рефлексії, ви маєте використовувати Java нотацію та компілювати за допомогою <code>javac</code>. Для цього випадку написання анотацій в Scala не виглядає корисним, так що стандартний компілятор не підтримує його. Причина в тому, що підтримка Scala без сумніву швидко схибить на всіх можливостях анотацій Java, та більше, Scala буде мати одного дня власну рефлексію, в якому випадку ви будете бажати мати доступ до Scala анотацій через Scala рефлексію.</p></div>
<div class="paragraph"><p>Ось приклад анотації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span> <span class="c1">// Це Java</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Ignore</span> <span class="o">{</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Після компіляції цього за допомогою javac ви можете використовувати анотацію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Tests</span> <span class="o">{</span>
  <span class="nd">@Ignore</span>
  <span class="k">def</span> <span class="n">testData</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">test1</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">testData</span> <span class="o">==</span> <span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">testData</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">test2</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">head</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі <code>test1</code> та <code>test2</code> вважаються тестовими методами, але <code>testData</code> повинен бути проігнорований, навіть незважаючи що його ім'я починається на <code>"test"</code>. Щоб бачити, коли ці анотації присутні, ви можете використовувати Java API рефлексії. Ось код приклада, що показує, як це робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">{</span>
  <span class="n">method</span> <span class="k">&lt;-</span> <span class="nc">Tests</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getMethods</span>
  <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">startsWith</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">getAnnotation</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Ignore</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span>
<span class="o">}</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">&quot;found a test method: &quot;</span> <span class="o">+</span> <span class="n">method</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут рефлективні методи <code>getClass</code> та <code>getMethods</code> використовуються для інспекції всіх полів класу входящого об'єкту. Це звичайні методи рефлексії. Специфічна до анотацій частина в використанні метода <code>getAnnotation</code>. Багато об'єктів рефлексії мають метод <code>getAnnotation</code> для пошуку анотацій специфічного типу. В цьому випадку код шукає анотацію нашого нового типу <code>Ignore</code>. Оскільки це Java API, успіх вказує або що результат є <code>null</code>, або дійсний об'єкт анотації.</p></div>
<div class="paragraph"><p>Ось цей код в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">javac</span> <span class="nc">Ignore</span><span class="o">.</span><span class="n">java</span>
<span class="n">$</span> <span class="n">scalac</span> <span class="nc">Tests</span><span class="o">.</span><span class="n">scala</span>
<span class="n">$</span> <span class="n">scalac</span> <span class="nc">FindTests</span><span class="o">.</span><span class="n">scala</span>
<span class="n">$</span> <span class="n">scala</span> <span class="nc">FindTests</span>
<span class="n">found</span> <span class="n">a</span> <span class="n">test</span> <span class="n">method</span><span class="k">:</span> <span class="kt">public</span> <span class="kt">void</span> <span class="kt">Tests$.test2</span><span class="o">()</span>
<span class="kt">found</span> <span class="kt">a</span> <span class="kt">test</span> <span class="kt">method:</span> <span class="kt">public</span> <span class="kt">void</span> <span class="kt">Tests$.test1</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Побічно зауважте, що методи в класі <code>Tests$</code>, замість класу <code>Tests</code>, якщо дивитись через Java рефлексію. Як описане на початку глави, реалізація сенглтон об'єктів Scala, покладається в Java клас з доданим знаком долару в кінці імені. В цьому випадку реалізація Tests є в Java класі <code>Tests$</code>.</p></div>
<div class="paragraph"><p>Будьте уважні, коли ви використовуєте Java анотації, ви маєте робити з їх обмеженнями. Наприклад, ви можте використовувати тільки константи, не вирази, в аргументах анотацій. Ви можте підтримувати <code>@serial(1234)</code>, але не <code>@serial(x * 2)</code>, оскільки <code>x * 2</code> не є константою.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_31_3__">31.3 Підстановочні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Всі Java типи мають Scala еквівалент. Це потрібно, так щоб цей Scala код міг отримувати доступ до любих легальних Java класів. Більшість часу трансляція прямолінійна. <code>Pattern</code> в Java є <code>Pattern</code> в Scala, та <code>Iterator&lt;Component&gt;</code> в Java є <code>Iterator[Component]</code> в Scala. Однак для деяких випадків типів Scala, що ви бачили до цього, недостатньо. Що ви будете робити з підстановочними типами Java, як <code>Iterator&lt;?&gt;</code> або <code>Iterator&lt;? extends Component&gt;</code>? Що ми можемо робити щодо сирих типів, як <code>Iterator</code>, де параметр типу пропущений? Для підстановочних типів Java та сирих типів Scala використовує додатковий різновид типу, що також називається підстановочним типом.</p></div>
<div class="paragraph"><p>Підстановочні типи записуються з використання синтаксису замінника, так само як скорочені функціональні літерали, описані в Розділі 8.5. В скороченнях для функціональних літералів ви можете використовувати підкреслення (<code>_</code>) замість виразу; наприклад, <code>(_ + 1)</code> є те саме, що <code>(x =&gt; x + 1)</code>. Підстановочні типи використовують ту саму ідею, тільки для типів замість виразів. Якщо ви пишете <code>Iterator[_]</code>, тоді підкреслення заміняє тип. Такий тип представляє <code>Iterator</code>, де тип елементу невідомий.</p></div>
<div class="paragraph"><p>Ви також можете вставити верню та нижню межі, коли використовуєте цей синтаксис замінника. Просто додайте межу після підкреслення, використовуючи той самий <code>&lt;:</code> синтаксис, що використовується для параметрів типу (Розділ 19.8 та Розділ 19.5). Наприклад, тип <code>Iterator[_ &lt;: Component]</code> є ітератором, де елемент типу невідомий, але який би тип це не був, він має бути субтипом <code>Component</code>.</p></div>
<div class="paragraph"><p>Ось як ви пишете підстановочний тип, але як його використовувати? В простих випадках ви можете ігнорувати підстановку, та викликати методи на базовому типі. Наприклад, уявімо, що ви маєте наступний Java клас:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java клас з підстановками класів</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wild</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">contents</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stuff</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;see&quot;</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">stuff</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви отримаєте доступ до цього в Scala коді, ви побачите, що він має підстановочний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Wild</span><span class="o">).</span><span class="n">contents</span>
<span class="n">contents</span><span class="k">:</span> <span class="kt">java.util.Collection</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">a</span>, <span class="kt">b</span>, <span class="kt">see</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте з'ясувати, скільки елементів в цій колекції, ви можете просто ігнорувати підстановочну частину, та просто викликати метод <code>size</code> як звичайно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">contents</span><span class="o">.</span><span class="n">size</span><span class="o">()</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>В більш складних випадках підстановочні типи можуть бути більш незграбними. Оскільки підстановочний тип не має імені, немає способу використати його в двох різних місцях. Наприклад, уявімо, що ви бажаєте створити змінну множину Scala, та ініціалізувати її елементами <code>contents</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">iter</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Wild</span><span class="o">).</span><span class="n">contents</span><span class="o">.</span><span class="n">iterator</span>
<span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">???</span><span class="o">]</span> <span class="c1">// який тут тип?</span>
<span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="n">hasMore</span><span class="o">)</span>
  <span class="n">set</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Проблема виникає в третьому рядку. Немає способу назвати тип елементів в Java колекції, так що ви не можете написати задовільний тип для множини. Щоб обробити цей різновид проблем, ось два трюки, які ви можете розглянути:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Коли передаєте підстановочний тип в метод, дайте параметр до методу для замінника. Тепер ви маєте ім'я для типу, так що можете використовувати його багато разів, як вам треба.
</p>
</li>
<li>
<p>
Замість повертання підстановочного типу з методу, поверніть об'єкт, що має абстрактні члени для кожного з типів замінників. (Дивіться Главу 20 для інформації по абстрактних членах.)
</p>
</li>
</ol></div>
<div class="paragraph"><p>Використовуючи обоє ці трюки разом, попередній код може бути записаний наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">import</span> <span class="nn">java.util.Collection</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">SetAndType</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Elem</span>
  <span class="k">val</span> <span class="n">set</span><span class="k">:</span> <span class="kt">mutable.Set</span><span class="o">[</span><span class="kt">Elem</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">javaSet2ScalaSet</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">jset</span><span class="k">:</span> <span class="kt">Collection</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">SetAndType</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">sset</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="c1">// тепер T може бути названий!</span>
  <span class="k">val</span> <span class="n">iter</span> <span class="k">=</span> <span class="n">jset</span><span class="o">.</span><span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">iter</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
    <span class="n">sset</span> <span class="o">+=</span> <span class="n">iter</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nc">SetAndType</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">Elem</span> <span class="o">=</span> <span class="n">T</span>
    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">sset</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете бачити, чому Scala код звичайно не використовує підстановочні типи. Щоб зробити щось виключне з ними, ви скоріше перетворюєте їх на використання абстрактних членів. Так що так само гарно ви можете починати з абстрактних членів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_31_4__scala__java_">31.4 Компіляція Scala та Java разом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Звичайно, коли ви компілюєте Scala код, що залежить від Java коду, спочатку ви будуєте Java код до <code>class</code> файлів. Потім ви будуєте Scala код, покладаючи Java class файли на <code>classpath</code>. Однак цей підхід не працює, якщо Java код має посилання назад на Scala код. В такому випадку не має значення, в якому порядку ви компілюєте ваш код, одна сторона або інша буде мати незадовільнені зовнішні посилання. Ці ситуації не є рідкістю; це відбувається частіше всього в Java проекті, де ви заміняєте один джерельний Java файл на джерельний файл Scala.</p></div>
<div class="paragraph"><p>Щоб підтримувати такі побудови, Scala дозволяє компіляцію джерельного коду Java, так само, як Java <code>class</code> файлів. Все що вам треба зробити, це покласти Java файли на командний рядок, так само, як вони б були Scala файлами. Scala компілятор не буде компілювати ці Java файли, але він буде сканувати їх, щоб побачити, що вони містять. Щоб використати цю можливість, ви спочатку компілюєте Scala код з використанням джерельних файлів Java, та потім компілюєте Java код з використанням class файлів Scala.</p></div>
<div class="paragraph"><p>Ось типова послідовність команд:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="n">d</span> <span class="n">bin</span> <span class="nc">InventoryAnalysis</span><span class="o">.</span><span class="n">scala</span> <span class="nc">InventoryItem</span><span class="o">.</span><span class="n">java</span> <span class="o">\</span>
<span class="nc">Inventory</span><span class="o">.</span><span class="n">java</span>

<span class="n">$</span> <span class="n">javac</span> <span class="o">-</span><span class="n">cp</span> <span class="n">bin</span> <span class="o">-</span><span class="n">d</span> <span class="n">bin</span> <span class="nc">Inventory</span><span class="o">.</span><span class="n">java</span> <span class="nc">InventoryItem</span><span class="o">.</span><span class="n">java</span> <span class="o">\</span>
<span class="nc">InventoryManagement</span><span class="o">.</span><span class="n">java</span>

<span class="n">$</span> <span class="n">scala</span> <span class="o">-</span><span class="n">cp</span> <span class="n">bin</span> <span class="nc">InventoryManagement</span>
<span class="nc">Most</span> <span class="n">expensive</span> <span class="n">item</span> <span class="k">=</span> <span class="n">sprocket</span><span class="o">(</span><span class="n">$4</span><span class="o">.</span><span class="mi">99</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_31_5__java_8__scala_2_12">31.5 Інтеграція Java 8 в Scala 2.12</h2>
<div class="sectionbody">
<div class="paragraph"><p>Java 8 додає декілька покращень до мови Java та байткодів, з чого Scala отримує переваги в своєму релізі 2.12.<span class="footnote"><br />[Scala 2.12 потребує Java 8, так щоб вона могла отримувати переваги від можливостей Java 8.]<br /></span> Використовуючи нові можливості Java 8, компілятор Scala 2.12 може генерувати маньші класи та <code>jar</code> файли, та покращити бінарну сумісність трейтів.</p></div>
<div class="sect2">
<h3 id="____sam_">Лямбда вирази та "SAM" типи</h3>
<div class="paragraph"><p>З перспективи Scala програміста, найбільш помітне розширення в Scala 2.12, пов'язане з Java 8 є те, що функціональні літерали Scala можуть бути використані як лямбда вирази Java 8, як більш стисла форма для виразів примірників анонімних класів. Щоб передати поведінку до метода, до появи Java 8 Java програмісти часто визначали примірникі анонімних внутрішніх класів, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">JButton</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span><span class="o">();</span> <span class="c1">// Це Java</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">ActionListener</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="nc">ActionEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі анонімний примірник <code>ActionListener</code> створюється та передається до <code>addActionListener</code> в Swing <code>JButton</code>. Коли користувач клацає на кнопці, Swing буде викликати метод <code>actionPerformed</code> на цьому примірнику, що буде друкувати "pressed!".</p></div>
<div class="paragraph"><p>В Java 8 лямбда вираз може використовуватись будь-де, де потрібен примірник класу або інтерфейсу, що містить тільки один абстрактний метод (SAM). <code>ActionListener</code> є такий інтерфейс, оскільки він містить один абстрактний метод, <code>actionPerformed</code>. Таким чином може бути лямбда для реєстрації слухача дій на кнопці Swing. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">JButton</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span><span class="o">();</span> <span class="c1">// Це Java 8</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="n">event</span> <span class="o">-&gt;</span> <span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>В Scala ви можете також використовувати анонімний внутрішній клас в тій же ситуації, але ви можете краще використати функціональний літерал, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;pressed!&quot;</span><span class="o">)</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви вже бачили в Розділі 21.1, ви можете підтримувати такий стиль кодування, через визначення неявної конверсії від функціонального типу <code>ActionEvent =&gt; Unit</code> до <code>ActionListener</code>.</p></div>
<div class="paragraph"><p>Scala 2.12 дозволяє використання функціональних літералів в цьому випадку, навіть за відсутності такого неявного перетворення. Як з Java 8, Scala 2.12 буде дозволяти функціональні типи для використання там, де потрібен примірник класу або трейту, що декларує один абстрактний метод (SAM). Це робить з любим SAM в Scala 2.12. Наприклад, ви можете визначити трейт <code>Increaser</code> з одним абстрактним методом, <code>increase</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">trait</span> <span class="nc">Increaser</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">increase</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>
<span class="n">defined</span> <span class="k">trait</span> <span class="nc">Increaser</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ви можете визначити метод, що приймає <code>Increaser</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">increaseOne</span><span class="o">(</span><span class="n">increaser</span><span class="k">:</span> <span class="kt">Increaser</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
<span class="n">increaser</span><span class="o">.</span><span class="n">increase</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">increaseOne</span><span class="k">:</span> <span class="o">(</span><span class="kt">increaser:</span> <span class="kt">Increaser</span><span class="o">)</span><span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб викликати ваш новий метод, ви можете передати анонімний примірник до трейту <code>Increaser</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increaseOne</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">Increaser</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">increase</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span>
  <span class="o">}</span>
<span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак в Scala 2.12 ви можете альтернативно просто використати функціональний літерал, оскільки <code>Increaser</code> є SAM типом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">increaseOne</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">7</span><span class="o">)</span> <span class="c1">// Scala 2.12</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">8</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__java_8_stream__scala_2_12">Використання Java 8 Stream зі Scala 2.12</h3>
<div class="paragraph"><p>Java Stream є функціональною структурою даних, що пропонує метод, що сприймає <code>java.util.function.IntUnaryOperator</code>. Зі Scala ви можете викликати <code>Stream.map</code> для інкременту кожного елемента в <code>Array</code>, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.util.function.IntUnaryOperator</span>
<span class="k">import</span> <span class="nn">java.util.function.IntUnaryOperator</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.util.Arrays</span>
<span class="k">import</span> <span class="nn">java.util.Arrays</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">IntUnaryOperator</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">applyAsInt</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="o">}</span>
<span class="o">).</span><span class="n">toArray</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак завдяки тому, що <code>IntUnaryOperator</code> є SAM типом, ви можете в Scala 2.12 викликати його більш стисло за допомогою функціонального літерала:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">).</span><span class="n">toArray</span> <span class="c1">// Scala 2.12</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що тільки функціональні літерали будуть адаптовані до SAM типів, не довільні вирази, що мають функціональний тип. Наприклад, розглянемо наступну <code>val</code>, <code>f</code>, що має тип <code>Int =&gt; Int</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча <code>f</code> має той самий тип, що і функціональний літерал, переданий до <code>stream.map</code> до цього, ви не можете використовувати <code>f</code> там, де потрібний <code>IntUnaryOperator</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">toArray</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">16</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
<span class="n">found</span>   <span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span>
<span class="n">required</span><span class="k">:</span> <span class="kt">java.util.function.IntUnaryOperator</span>
      <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">toArray</span>
                 <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб використати <code>f</code>, ви можете явно викликати її як функціональний літерал, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="o">)).</span><span class="n">toArray</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ви можете анотувати <code>f</code> з <code>IntUnaryOperator</code>, типом, що очікує <code>Stream.map</code>, коли ви визначаєте <code>f</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">IntUnaryOperator</span> <span class="o">=</span> <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">f</span><span class="k">:</span> <span class="kt">java.util.function.IntUnaryOperator</span> <span class="o">=</span> <span class="o">...</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">stream</span> <span class="k">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="n">stream</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">stream</span><span class="k">:</span> <span class="kt">java.util.stream.IntStream</span> <span class="o">=</span> <span class="o">...</span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">stream</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">toArray</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зі Scala 2.12 та Java 8 ви також можете викликати методи, скомпільовані за допомогою Scala з Java, передаючи функціональні типи Scala з використанням лямбда виразів Java. Хоча функціональні типи Scala визначені як трейти, що включають суцільні методи, Scala 2.12 компілює трейти до Java інтерфейсів з методами по замовчанню, нова можливість Java 8. Як результат, функціональні типи Scala з'являються в Java як SAM.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_31_6_">31.6 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>Більшість часу ви можете ігнорувати, як реалізована Scala, і просто писати та виконувати ваш код. Але іноді гарно "подивитись за лаштунки", так що ця глава зайшла в три аспекти реалізації Scala на Java платформі: як виглядає трансляція, як анотації Scala та Java роблять разом, та як підстановочні типи Scala дозволяють вам отримати доступ до підстановочних типів Java. Також розглянуті використання примітивів конкурентності зі Scala, та компіляцію комбіновиних проектів Scala та Java. Ці теми важливі, чи ви використовуєте Scala та Java разом, чи ні.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-18 04:51:33 EEST
</div>
</div>
</body>
</html>
