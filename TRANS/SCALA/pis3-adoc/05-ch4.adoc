include::headers.adoc[]

Глава 4
-------

Класи та об'єкти
================
Тепер ви побачили основи класів та об'єетів Scala з попередніх двох символів. В цій главі ми проведемо вас трохи глибше. Ви навчитесь більше щодо класів, полів те методів, та отримаєте огляд виводу крапки з комою. Ми обсудимо об'єкти синглтонів, включаючи як їх використовувати для написання та виконання застосування Scala. Якщо ви знайомі з Java, ви знайдете, що концепції Scala є подібними, але не саме такі самі. Так що навіть якщо ви Java гуру, все одно це читання варте того.

4.1 Класи, поля та методи
-------------------------
Клас є проектом об'єкту. Коли ви визначаєте клас, ви можете створити об'єкти з проекту класу за допомогою ключового слова `new`. Наприклад, маючи визначення класа:
[source,scala]
----
class ChecksumAccumulator {
// class definition goes here
----
Ви можете створити об'єкти `ChecksumAccumulator` таким чином:
[source,scala]
----
new ChecksumAccumulator
----
Всередині визначення класа ви покладаєте поля та методи, що разом називаються членами. Поля, що ви визначаєте за допомогою `val` або `var`, є змінними, що посилаються на об'єкти. Методи, що ви визначаєте за допомогою `def`, містять виконавчий код. Поля зберігають стан, або дані об'єкта, тоді як методи використовують ці дані, щоб зробити обчислювальну роботу об'єкта. Коли ви створюєте примірник класу, середовище виконання відкладає деяку пам'ять для зберігання образу стану об'єкта (тобто вмісту його змінних). Наприклад, так ви визначаєте клас `ChecksumAccumulator`, та даєте йому поле `var` на ім'я `sum`:
[source,scala]
----
class ChecksumAccumulator {
  var sum = 0
}
----
та двічі створюєте його примірник:
[source,scala]
----
val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator
----
Зображення об'єктів в пам'яті може виглядати так:

Оскільки `sum`, поле, деклароване в класі `ChecksumAccumulator`, є `var`, не `val`, ви можете пізніше переприсвоїти `sum` інше значення  `Int`, таким чином:
[source,scala]
----
acc.sum = 3
----
Тепер картинка може виглядати ось так:

Одна річ, що треба зауважити щодо цього малюнка, в тому, що тут дві змінні `sum`, одна в об'єкті, не який посилається `acc`, та інша в об'єкті, на який посилається `csa`. Поля також відомі як взмінні примірника, бо кожний примірник отримує свій власний набір змінних. Колективно, змінні примірника-об'єкта складають образ пам'яті об'єкта. Ви бачите ілюстрацію цього тут, не тільки тому що ви бачите дві змінні `sum`, але і через те, що коли змінюєте одну, це не впливає на іншу.

Інша річ, на яку слід звернути увагу в цьому прикладі, це те, що ви були в змозі змінити об'єкт, на який посилається `acc`, навіть якщо сам `acc` `val`. Що ви не можете робити з `acc` (або csa), з гляду на те, що вони `val`, не `var`, це переприсвоїти їм інший об'єкт. Наприклад, наступна спроба схибить:
[source,scala]
----
// Не буде компілюватись, бо acc є val
acc = new ChecksumAccumulator
----
Таким чином, все, на що ви можете розраховувати, це що `acc` буде завжди посилатись на той самий об'єкт `ChecksumAccumulator`, яким його ініціалізували, але поля, що містяться всередині цього об'єкта, можуть змінюваться з часом.

Один важливий шлях досягти надійності об'єкта, є переконатись, що стан об'єкта — значення його змінних примірника — залишаються валідними під час цілого життєвого циклу. Перший крок є заборонити зовнішньому світу напряму отримувати доступ до полів, зробивши поля приватними. Оскільки приватні поля досяжні тільки з методів, визначених в тому ж класі, весь код, що може оновити стан, буде локалізований в класі. Щоб декларувати приватне поле, покладіть модифікатор доступу `private` перед полем, таким чином:
[source,scala]
----
class ChecksumAccumulator {
  private var sum = 0
}
----
Маючи таку декларацію `ChecksumAccumulator`, люба спроба отримати доступ до `sum` ззовні класу буде невдалою:
[source,scala]
----
val acc = new ChecksumAccumulator
acc.sum = 5 // Не буде компілюватись, оскільки `sum` є приватним
----
NOTE: Спосіб, в який ви робите члени публічними в Scala, це не вказувати явно жодного модифікатора доступу. Інакше кажучи, там, де ви кажете `public` в Java, ви просто нічого не кажете в Scala. Публічний рівень доступу в Scala обираєтьмя по замовчанню.

Тепер, коли `sum` є `private`, єдиний код, що може отримати доступ до `sum` є код, визначений всередині тіла самого класа. Таким чином, `ChecksumAccumulator` не буде дуже корисним, якщо ми не визначимо деякі методи для нього:
[source,scala]
----
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = {
    sum += b
  }
}
def checksum(): Int = {
  return ~(sum & 0xFF) + 1
}
----
Тепер `ChecksumAccumulator` має два методи, `add` та `checksum`, обоє з яких демонструють базову форму визначення функції, показану на Малюнку 2.1.

Любі параметри метода можуть бути використані всередині метода. Одна важлива характеристика пreasonараметрів метода в Scala в тому, що вони `val`, не `var`.footnote:[Причина, з якої параметри є val в тому, що про val простіше розмірковувати. Ви більше не дивитесь, щоб визначити, чи val було перепризначене, як ви маєте робити з var.] Таким чином, якщо ви спробуєте переприсвоїти параметр всередині метода в Scala, це не буде компілюватись:
[source,scala]
----
def add(b: Byte): Unit = {
  b = 1 // Не буде компілюватись, оскільки b є val
  sum += b
}
----
Хоча `add` та `checksum` в цій версії `ChecksumAccumulator` коректно реалізують бажану функціональність, ви можете виразити їх в більш стислому стилі. Перше, `return` в кінці метода `checksum` є надлишковим і може бути відкінуте. За відсутності явного твердження  `return`, метод Scala повертає останнє значення, обчислене методом.

Рекомендованим стилем для методів є, фактично, уникати мати явний, а особливо декілька, тверджень `return`. Замість цього думайте про кожний метод як про вираз, що видає одне значення, яке він повертає. Ця філософія буде надихати вас робити методи досіть малими, та ділити великі методи на декілька меньших. З іншого боку, вибір дизайну залежить від контексту, та Scala спрощує написання методів, що мають декілька явних `returns`, якщо це те, що ви задумали.

Оскільки все, що робить `checksum` це обчислення значення, він не потребує явного `return`. Інше скорочення для методів є те, що ви можете опустити фігурні дужки, якщо метод тільки обчислює одне результуюче значення. Якщо результуючий вираз короткий, його навіть можна покласи в той же рядок, що і сам `def`. Для виключної стислості ви можете відкинути тип результату, і Scala виведе його. З ціма змінами, клас `ChecksumAccumulator` виглядає так:
[source,scala]
----
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte) = sum += b
  def checksum() = ~(sum & 0xFF) + 1
}
----
Хоча компілятор Scala буде коректно виводити типи результату методів `add` та `checksum`, показаних в попередньому прикладі, читачам коду буде треба подумки вивести ці типи результату, через дослідження тіла методів. Як результат, часто краще явно провадити типи результату публічних методів, декларованих в класі, навіть якщо компілятор може вивести його за вас. Лістинг 4.1 показує цей стиль.
[source,scala]
----
// In file ChecksumAccumulator.scala
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = { sum += b }
  def checksum(): Int = ~(sum & 0xFF) + 1
}
----
Лістинг 4.1 - Фінальна версія класу ChecksumAccumulator.

Методи з типом результата Unit, такі як метод `add` в ChecksumAccumulator, виконуються заради своїх побочних ефектів. Побічний ефект в основному визначений як зміна стану десь зовні до метода, або виконання операції I/O. В випадку `add` побічний ефект полягає в переприсвоєнні змінної `sum`. Метод, що виконується виключно ради побічних ефектів, також відомий як процедура.

4.2 Вивід крапки з комою
------------------------
В Scala програмах крапка з комою в кінці твердження часто є опціональними. Ви можете ставити їх, якщо бажаєте, але не зобов'язані робити це, якщо рядок сам по собі розташований на одному рядку. З іншого боку, крапка з комою обов'язкові, якщо ви маєте декілька тверджень в одному рядку:
[source,scala]
----
val s = "hello"; println(s)
----
Якщо ви бажаєте ввести твердження, що займає декілька рядків, більшість часу ви можете просто покласти її, і Scala поділить тврдження в коректному місці. Наприклад, наступне трактується як однорядкове твердження:
[source,scala]
----
if (x < 2)
  println("too small")
else
  println("ok")
----
Однак часом Scala буде ділити твердження на дві частини проти вашого бажання:
[source,scala]
----
x
+ y
----
Це розбирається як два твердження, `x` та `+y`. Якщо вашим наміром було розібрати це як одне твердження `x + y`, ви завжди можете огорнути це в дужки:
[source,scala]
----
(x
+ y)
----
Альтернативно, ви можете покласти `+` в кінці рядка. Тільки з цієї причини, коли ви зціплююте інфіксні операції, такі як `+`, є загальним стилем Scala покладати оператор в кінці рядка, а не напочатку:
[source,scala]
----
x +
y +
z
----

Правила виводу крапок з комою
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Точні правила для розділення тверджень дивуюче прості, як для того, як гарно вони роблять. Коротко, кінці рядків трактуються як крапка з комою, за винятком коли вірне одна умова з наступних:

1. Розглядаємий рядок завершується на слово, яке не може бути легальним в кінці твердження, таке, як крапка або інфіксний оператор.
2. Наступний рядок починається зі слова, що не може починати твердження.
3. Рядок завершується, коли відкриті дужки (...) або [...], оскільки вони в жодному разі не можуть містити декілька тверджень.

4.3 Об'єкти синглтонів
----------------------
Як зазначалось в Главі 1, один спосіб, в який Scala більш об'єктно-орієнтована, ніж Java, це що класи в Scala. Замість цього,  Scala має об'єкти синглтонів. Визначення об'єкта синглтона виглядає як визначення класу, за винятком того, що замість ключового слова `class` ви використовуєте ключове слово `object`. Лістинг 4.2 показує приклад.

Об'єкт синглтона на цій фігурі названий `ChecksumAccumulator`, те саме, що і ім'я класу в попередньому прикладі. Коли сінглтон поділяє те саме ім'я з класом, він називається об'єктом компанйоном класа. Ви маєте обох, клас та його об'єкт компанйон в тому ж джерельному файлі. Клас називається компанйон класом об'єкта синглтона. Клас та його об'єкт компанйон можуть отримувати доступ до приватних членів один одного.
[source,scala]
----
// In file ChecksumAccumulator.scala
import scala.collection.mutable
object ChecksumAccumulator {
  private val cache = mutable.Map.empty[String, Int]
  def calculate(s: String): Int =
    if (cache.contains(s))
      cache(s)
    else {
      val acc = new ChecksumAccumulator
      for (c <- s)
        acc.add(c.toByte)
      val cs = acc.checksum()
      cache += (s -> cs)
      cs
  }
}
----
Лістинг 4.2 - Об'єкт компанйон для класа ChecksumAccumulator.

Об'єкт сінглтон `ChecksumAccumulator` має один метод з назвою `calculate`, що приймає `String`, та обчислює контрольну суму для символів в `String`. Він також має одне приватне поле, `cache`, змінну мапу, в якій кешуються попередньо обчислені контрольні суми.footnote:[Ми використовуємо тут кеш, щоб показати об'єкт синглтон з полем. Кеш, такий як цей, є оптимізацією продуктивності, що міняє пам'ять на час обчислення. Загалом, ви мали б використовувати такий архів, тільки якщо натрапили на проблему продуктивності, яку може вирішити кеш, та можливо використовувати слабку мапу, таку як `WeakHashMap` в `scala.collection.jcl`, так що елементи цього кеша підпали б під збирання сміття, коли з пам'ятю стало скрутно.] Перший рядок цього метода, `if (cache.contains(s))`, перевіряє кеш, чи переданий рядок вже існує як ключ в кеші. Якщо так, він просто повертає відображене значення, кеш(і). Інакше, він виконує варіант `else`, що обчислює контрольну суму. Перший рядок `else` визначає `val` на ім'я `acc`, та ініціалізує її новим примірником `ChecksumAccumulator`.footnote:[Оскільки ключове слово  `new` використовується тільки для створення класів, новий створений тут об'єкт є примірником класу `ChecksumAccumulator`, не об'єкта синглтона з тим самим іменем.] Наступний рядок є виразом `for`, що проходить по кожному символу в переданому рядку, конвертуючи символ на Byte, через виклик toByte на ньому, та передає його до метода  `add` примірника `ChecksumAccumulator`, на який посилається `acc`. Після завершення виразу `for`, наступний рядок метода викликає `checksum` на `acc`, що отримує контрольну суму для переданого `String`, та зберігає його в `val` на ім'я `cs`. В наступному рядку, `cache += (s -> cs)`, переданий рядок-ключ відзеркалюється на ціле значення контрольної суми, і ця пара ключ-значення додається до мапи `cache`. Останній вираз метода, `cs`, запевняє, що контрольна сума є результатом метода.

ЯКщо ви Java програміст, один спосіб щоб думати про об'єкт синглтон як про домівку для любих статичних методів, що ви могли написати в  Java. Ви можете викликати методи на об'єкті синглтоні, використовуючи подібний синтаксис: ім'я об'єкта синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати метод `calculate` об'єкта синглтона таким чином: 
[source,scala]
----
ChecksumAccumulator.calculate("Every value is an object.")
----
Однак об'єкт синглтон є більше, ніж утримувач статичних методів. Це першокласний об'єкт. Ви можете думати про ім'я об'єкта синглтона, таким чином, як про "тег імені", приєднаного до об'єкту:

Визначення об'єкта синглтона не визначає тип (на рівні абстракції Scala). Маючи тільки визначення об'єкту ChecksumAccumulator, ви не зможете створити змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator визначається через клас компанйон об'єкта синглтона. Однак, синглтон об'єкти розширюють суперклас, та можуть міксувати трейти. Беручи, що кожний об'єкт синглтон є примірником свого суперкласу та примішаних трейтів, ви можете викликати його методи через ці типи, посилатись на нього через змінні ціх типів, та передавати його методам, що очікують ці типи. Ми покажемо деякі приклади об'єктів синглтонів, що наслідують від класів та трейтів в Главі 13.

Одна відмінність між класами та об'єктами синглтонами в тому, що синглтон об'єкт не може приймати параметрів, тоді як клас може. Оскільки ви не можете створити примірник синглтон об'єкта за допомогою ключового слова `new`,ви не маєте способа передати йому параметри. Кожний синглтон об'єкт був реалізований як примірник синтетичного класу, на який посилається статична змінна, так що вони мають ту саму семантику ініціалізації, що і статики в Java.footnote:[Ім'я синтетичного класу є ім'я об'єкту, плюс знак долару. Таким чином, синтетичний клас для об'єкта синглтона на ім'я ChecksumAccumulator є ChecksumAccumulator$.] Зокрема, об'єкт синглтон буде ініціалізований, коли код отримає до нього доступ в перший раз.

Синглтон, що не поділяє те саме ім'я з класом компанйоном, називається окремим об'єктом. Ви можете використовувати окремі об'єкти для багатьох призначень, включаючи збір пов'язаних допоміжних методів, або визначення точки входу в застосування Scala. Цей випадок застосування показаний в наступному розділі.

4.4 Застосування Scala
----------------------
Щоб виконати Scala програму, ви маєте надати ім'я окремого об'єкта синглтона з методом `main`, що приймає один параметр, `Array[String]`, та має тип результата Unit. Любий окремий об'єкт з методом `main` відповідної сигнатури, може бути використаний як вхідна точка в застосування. Приклад показаний в Лістингу 4.3:
[source,scala]
----
// In file Summer.scala
import ChecksumAccumulator.calculate
object Summer {
  def main(args: Array[String]) = {
    for (arg <- args)
       println(arg + ": " + calculate(arg))
  }
}
----
Лістинг 4.3 - Застосування Summer.

Ім'я об'єкта синглтона в Лістенгу 4.3 є Summer. Його метод `main` має відповідну сигнатуру, так що ви можете використовувати його як застосування. Перше твердження в файлі є імпорт метода `calculate`, визначеного в об'єкті ChecksumAccumulator в попередньому прикладі. Це твердження `import` дозволяє вам використовувати просте ім'я метода в залишку файла.footnote:[Якщо ви Java програміст, ви можете думати про цей імпорт, як про можливість статичного імпорту, введену в Java 5. Однак в Scala є одна різниця, в тому, що ви можете імпортувати члени з любого об'єкта, не тільки з об'єктів синглтонів.] Тіло метода `main` просто друкує кожний аргумент, та контрольну суму для аргумена, відділену роздільником.

NOTE: Scala неявно імпортує члени пакунків `java.lang` та `scala`, так само, як члени об'єкта синглтона на ім'я `Predef`, в кожний джерельний файл Scala. `Predef`, що знаходиться в пакунку `scala`, містить багато корисних методів. Наприклад, коли ви кажете `println` в джерельному файлі Scala, насправді ви викликаєте `println` на `Predef`. (`Predef.println` обертається, та викликає `Console.println`, що робить реальну роботу). Коли ви кажете `assert`, ви викликаєте `Predef.assert`.

Щоб виконати застосування Summer, покладіть код з Лістинга 4.3 в файл з назвою Summer.scala. Оскільки `Summer` використовує `ChecksumAccumulator`, покладіть код для `ChecksumAccumulator`, обоє, клас, показаний в Лістингу 4.1, та його об'єкт компанйон, показаний в Лістингу 4.2, в файл на ім'я `ChecksumAccumulator.scala`.

Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви покладали публічні класи в файл з іменем класа — наприклад, ви поклали клас `SpeedRacer` в файл `SpeedRacer.java` — в Scala ви можете називати `.scala` файли як побажаєте, не важливо, які Scala класи або код ви покладете до них. Однак загалом, в випадку не-скриптів, є рекомендованим стилем називати файли по іменах класів, які вони містять, як це зроблено в Java, так що програмісти можуть більш просто знайти класи, шукаючи по іменах файлів. Цей підхід, що ми прийняли для двох файлів в цьому  прикладі, `Summer.scala` та `ChecksumAccumulator.scala`.

Ні `ChecksumAccumulator.scala`, ані `Summer.scala` не є скриптами, бо закінчуються на визначення. Скрипт, для контрасту, має завершуватись на вираз результату. Так що якщо ви спробуєте виконати `Summer.scala` як скрипт, інтерпретатор Scala буде скаржитись, що `Summer.scala` не завершується на вираз результату (вважаємо, звичайно, що ви не додали якийсь вираз після визначення об'єкта  `Summer`). Замість цього, вам буде треба насправді скомпілювати ці файли за допомогою Scala компілятора, та потім виконати отримані файли `class`. Один шлях зробити це є використання `scalac`, що є базовим компілятором Scala, ось так:
----
$ scalac ChecksumAccumulator.scala Summer.scala
----
Це компілює ваш джерельний файл, але може бути відчутна затримка перед завершенням компіляції. Причина в тому, що кожного разу, коли запускається компілятор, він витрачає час, скануючі вміст jar файлів, та роблячи іншу роботу з ініціалізації, перед тим, як він навіть тільки погляне не нові джерельні файли, яки ви надіслали йому. З цієї причини дистрибутив Scala також включає демон компіляції Scala з назвою `fsc` (fast Scala compiler). Ви використовуєте його таким чином:
----
$ fsc ChecksumAccumulator.scala Summer.scala
----
Перший раз, як ви запустите `fsc`, він створить локальний демон сервера, підключений до порту вашого комп'ютера. Потім він буде надсилати список файлів на компіляцію до демона через порт, і демон буде компілювати ці файли. Наступний раз, коли ви виконаєте `fsc`, демон вже буде запущений, так що `fsc` буде просто посилати список файлів до демона, що буде безпосередньо компілювати ці файли. Використовуючи `fsc`, вам треба чекати тільки щоб рантайм Java запустився в перший раз. Якщо ви колись побажаєте запинити демона `fsc`, ви можете зробити це за допомогою `fsc - shutdown`.

Виконання любого з них, команди `scalac` або `fsc`, буде продукувати файли класів Java, які ви потім можете виконати через команду `scala`, ту саму команду, що ви використовували для виклику інтерпретатора в попередніх прикладах. Оданак замість надання їй файла з розширенням `.scala`, що містить код Scala для інтерпретації, як ви робили в кожному попередньому прикладі,footnote:[Справжній механізм, який програма `scala` використовує для "інтерпретації" джерельного файлу Scala, є те, що вона компілює джерельний код Scala в байткоди Java, безпосередньо завантажує їх через завантажувач класів, та виконує їх.] в цьому випадку ви дасте їй ім'я окремого об'єкту, що має метод `main` з відповідною сигнатурою. Ви можете виконати застосування Summer, таким чином, набравши:
----
$ scala Summer of love
----
Ви побачите контрольні суми, роздруковані для двох аргументів командного рядка:
----
of: -213
love: -182
----

4.5 Трейт App
-------------
Scala провадить трейт `scala.App`, що може зберігти вам деякий час за друком. Хоча ми ще не розглянули все, що вам треба для розуміння саме як цей трейт робить, ми припускаємо, що ви бажаєте знати про це саме зараз, будь-що. Лістинг 4.4 показує приклад:
[source,scala]
----
import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends App {
  for (season <- List("fall", "winter", "spring"))
    println(season + ": " + calculate(season))
}
----
Лістинг 4.4 - Використання трейта App.

Щоб використати цей трейт, зпочатку ви пишете `extends App` після імені вашого синглтон об'єкта. Потім замість писати метод `main`, ви кладете код, що ви б мали покласти в метод `main`, прямо між фігурними дужками об'єкта синглтона. Ви можете отримати доступ до аргументів командного рядка через масив рядків на ім'я `args`. Це все. Ви можете компілювати та виконувати це застосування, так само як любе інше.

4.6 Висновок
------------
Ця глава надала вам основи класів та об'єктів в Scala, та показала вам, як компілювати та виконувати застосування. В наступній главі ми вивчимо базові типи Scala, та як їх використовувати.
