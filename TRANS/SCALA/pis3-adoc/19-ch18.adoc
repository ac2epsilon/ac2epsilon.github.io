include::headers.adoc[]

Глава 18
--------

Змінні об'єкти
==============

В попередньому розділі ми звернули увагу на функціональні (незмінні) об'єкти. Ми зробили це, оскільки ідея об'єктів без жодного змінного стану заслуговує бути краще відомою. Однак це також чудово можливо визначати в Scala об'єкти зі змінним станом. Такі змінні об'єкти часто спливають природно, коли ви бажаєте змоделювати об'єкти в реальному світі, що змінюються з часом.

Ця глава пояснює, що таке змінні об'єкти, та що провадить Scala в термінах синтаксису для їх вираження. Ми також введемо більше дослідження симуляції дискретних подій, що включатиме змінні об'єкти, так само, як побудову внутрішнього DSL для визначення цифрових схем для симуляції.

18.1 Що робить об'єкт змінним?
------------------------------
Ви можете спостерігати принципову різницю між чисто функціональним об'єктом і змінним об'єктом, навіть без погляду на реалізацію об'єкта. Коли ви викликаєте метод або отримуєте поле на деякому функціональному об'єкті, ви будете завжди отримувати один той самий результат.

Наприклад, беручи список символів:
[source,scala]
----
val cs = List('a', 'b', 'c')
----
застовування `cs.head` буде завжди повертати `'a'`. Це буде саме так, навіть якщо відбудеться довільне число операцій зі списком `cs` між місцем, де він визначений, та місцем, де відбувається доступ до `cs.head`.

З іншого боку, для зміноого об'єкту результат виклику метода або доступ до поля може залежати  від того, які операції до цього застосовувались до об'єкту. Гарний приклад змінного об'єкту є банківській рахунок. Лістинг 18.1 показує спрощену реалізацію банківського рахунку:
[source,scala]
----
class BankAccount {

  private var bal: Int = 0

  def balance: Int = bal

  def deposit(amount: Int) = {
    require(amount > 0)
    bal += amount
  }

  def withdraw(amount: Int): Boolean =
    if (amount > bal) false
    else {
      bal -= amount
      true
  }
}
----
Лістинг 18.1 - Змінний клас банківського рахунку.

Клас `BankAccount` визначає приватну змінну, `bal`, і три публічні методи: `balance` повертає поточний баланс; `deposit` додає сумму до `bal`; та `withdraw` намагається списати надану сумму з `bal`, при цьому вважаючи, що залишковий баланс не буде від'ємним. Значення, що повертає `withdraw`, є `Boolean`, вказуючи, чи запитані фонди були вдало списані.

Навіть якщо ми нічого не знаємо про внутрішню роботу класу `BankAccount`, ви все ще можете сказати, що `BankAccounts` є змінними об'єкти:
[source,scala]
----
scala> val account = new BankAccount
account: BankAccount = BankAccount@21cf775d

scala> account deposit 100

scala> account withdraw 80
res1: Boolean = true

scala> account withdraw 80
res2: Boolean = false
----
Зауважте, що два останні списання в попередній взаємодії повернули різні результати. Перша операція списання повернула `true`, оскільки банківський рахунок містив достатньо коштів, щоб дозволити списання. Друга операція, хоча така сама, як і перша, повертає `false`, оскільки баланс на рахунку було зменшено, так що він більше не покриває запитані кошти. Так що, як це зрозуміло, банківські рахунки мають змінній стан, оскільки та сама операція може повертати різні результати в різний час.

Ви можете подумати, що змінність `BankAccount` безпосередньо наочна, оскільки він містить визначення `var`. Змінність та `var` звичайно ідуть рука в руку, але речі не завжди так чітко окреслені. Наприклад, клас може бути змінним без визначення або наслідування любих `var`, оскільки він перенаправляє викликів методів до інших об'єктів, що мають змінний стан. Зворотнє також можливе: клас може містити `var`, та все одне залишатись чисто функціональним. Прикладом може бути клас, що кешує результат коштовної операції в полі для цілей оптимізації. Щоб зрозуміти приклад, розглянемо наступний неоптимізований клас `Keyed` з коштовною операцією `computeKey`:
[source,scala]
----
class Keyed {
  def computeKey: Int = ... // це займає деякий час
  ...
}
----
За умови, що `computeKey` не читає та не записує жодні `var`, ви можете зробити `Keyed` більш ефективним через додавання кешу:
[source,scala]
----
class MemoKeyed extends Keyed {
  private var keyCache: Option[Int] = None
  override def computeKey: Int = {
    if (!keyCache.isDefined) keyCache = Some(super.computeKey)
    keyCache.get
  }
}
----
Використання `MemoKeyed` замість `Keyed` може прискорити речі, бо коли результат операції `computeKey` запитується в  другий раз, замість виконання `computeKey` ще раз може бути повернене значення, збережене в полі `keyCache`. Але, за винятком цього прискорення, поведінка класу `Keyed` та `MemoKeyed` в точності така сама. Відповідно, якщо `Keyed` є чисто функціональним, так само буде `MemoKeyed`, навіть якщо він містить переприсвоювану змінну.

18.2 Переприсвоєння змінних та властивостей
-------------------------------------------
Ви можете виконати дві фундаментальні операції на переприсвоюваних змінних: отримати її значення, або встановити її в нове значення. В бібліотеках, таких, як JavaBeans, ці операції часто інкапсульовані в окремі методи геттера та сеттера, що повинні бути визначені явно.

В Scala кожна `var`, що є не-приватним членом деякого об'єкту, одночасно неявно визначає методи геттера та сеттера. Однак ці геттери та сеттери іменуються інакше, ніж за Java домовленістю. Геттер `var x` називається просто `x`, тоді як сеттер називається `x_=`.

Наприклад, якщо воно з'являється в класі, визначення `var`:
[source,scala]
----
var hour = 12
----
генерує геттер `hour`, та сеттер `hour_=`, на додаток до переприсвоюваного поля. Поле завжди маркується як `private[this]`, що означає, що воно може отримувати доступ тільки з об'єкта, що містить його. З іншого боку, геттер та сеттер отримують ту саму оглядовість, що і оригінальна `var`. Якщо визначення `var` є публічним, таким будуть його геттер та сеттер. Якщо воно `protected`, вони також будуть `protected`, і так далі.

Наприклад, розглянемо клас `Time`, показаний на Лістингу 18.2, що визначає дві публічні змінні, з назвами `hour` та `minute`:
[source,scala]
----
class Time {
  var hour = 12
  var minute = 0
}
----
Лістинг 18.2 - Клас з публічними `var`.

Ця реалізація в точності еквівалентна до визначення класу, показаному в Лістингу 18.3. В визначенні, показаному в Лістингу 18.3, імена локальних полів `h` та `m` обрані довільно, так щоб вони не стикались з любими іменами, що вже використовуються.
[source,scala]
----
class Time {
  private[this] var h = 12
  private[this] var m = 0
  
  def hour: Int = h
  def hour_=(x: Int) = { h = x }

  def minute: Int = m
  def minute_=(x: Int) = { m = x }
}
----  
Лістинг 18.3 - Як публічні `var` розширюються в методи геттерів та сеттерів.

Цікавий аспект щодо цього розширення `var` в геттери та сеттери в тому, що ви за бажанням також можете визначити геттери та сеттери напряму, замість визначення `var`. Через визначення ціх методів напряму ви можете інтерпретувати операції доступу до змінної, або присвоєння змінної, як вам завгодно. Наприклад, варіант класу `Time`, показаний в Лістингу 18.4, містить вимоги, щоб перехоплювати всі присвоєння до годин та хвилин з нелегальними значеннями.
[source,scala]
----
class Time {

  private[this] var h = 12
  private[this] var m = 0

  def hour: Int = h
  def hour_= (x: Int) = {
    require(0 <= x && x < 24)
    h = x
  }

  def minute = m
  def minute_= (x: Int) = {
    require(0 <= x && x < 60)
    m = x
  }
}
----
Лістинг 18.4 - Визначення методів геттера та сеттера напряму.

Деякі мови мають спеціальні синтаксичні конструкції для змінно-подібних кількостей, що не є звичайними змінними, де їх сеттери та геттери можуть бути перевизначені. Наприклад, C# має властивості, що виконують цю роль. Ефективно, довленість Scala завжди інтерпретувати змінну як пару з сеттера та геттера надає вам ті самі можливості, що і властивості C#, без потреби в спеціальному синтаксисі.

Властивості можуть служити для багатьох різних призначень. В прикладі, показаному в Лістингу 18.4, сеттери примушують виконання інваріантів, таким чином захищаючи змінну від присвоєння нелегальних значень. Також ви можете використовувати властивість для журналювання всіх доступів до сеттера та геттера змінної. Або ви можете інтегрувати змінні з подіями, наприклад, для нотифікації деяких методів підписчикив, кожного разу, коли змінна модифікується (ви побачите приклади цього в Главі 35).

Також можливо, і іноді корисно, визначити геттер та сеттер без асоційованого поля. Наприклад, Лістинг 18.5 показує клас `Thermometer`, що інкапсулює змінну `temperature`, що може бути прочитана та оновлена. Температури можуть бути виражені в градусах Цельсія або Фаренгейта. Цей клас дозволяє вам отримати та встановити температуру в будь-яких одиницях.
[source,scala]
----
class Thermometer {
  
  var celsius: Float = _

  def fahrenheit = celsius * 9 / 5 + 32

  def fahrenheit_= (f: Float) = {
    celsius = (f - 32) * 5 / 9
  }
  override def toString = fahrenheit + "F/" + celsius + "C"
}
----
Лістинг 18.5 - Визначення геттера та сеттера без асоційованого поля.

Перший рядок тіла цього класу визначає `var`, `celsius`, що буде містити температуру в градусах Цельсія. Змінна `celsius` напочатку встановлена в значення по замовчанню, через вказання `_` як "ініціалізуючого значення" змінної. Більш точно, ініціалізатор `= _` поля присвоює нульове значення до цього поля. Нульове значення залежить від типу поля. Це `0` для числових типів, `false` для логічних, `null` для типів посилань. Це те саме, якби та сама змінна була визначена в Java без ініціалізатора.

Зауважте, що ви не можете просто відкинути ініціалізатор `= _` в Scala. Якщо ви напишете:
[source,scala]
----
var celsius: Float
----
це декларує абстрактну змінну, не неініціалізовану зміну.footnote:[Абстрактні змінні будуть пояснені в Главі 20.]

За визначенням змінної `celsius` іде геттер, `fahrenheit`, та сеттер, `fahrenheit_=`, що отримує доступ до такої самої температури, але в градусах Фаренгейту. Немає окремого поля, що містить поточне значення температури в фаренгейтах. Замість цього, методи геттера та сеттера для значень фаренгейта автоматично конвертують з градусів Цельсія, відповідно. Ось приклад взаємодії з об'єктом `Thermometer`:
[source,scala]
----
scala> val t = new Thermometer
t: Thermometer = 32.0F/0.0C

scala> t.celsius = 100
t.celsius: Float = 100.0

scala> t
res3: Thermometer = 212.0F/100.0C

scala> t.fahrenheit = -40
t.fahrenheit: Float = -40.0

scala> t
res4: Thermometer = -40.0F/-40.0C
----
18.3 Дослідження: симуляція дескретних подій
--------------------------------------------
Залишок цієї глави, поміж іншим, показує розширений приклад, як змінні об'єкти можуть бути комбіновані зі значеннями першокласних функцій в цікавий спосіб. Ви побачите розробку та реалізацію симулятора для цифрових пристроїв. Це завдання розбите на декілька субпроблем, кожне з яких цікаві самі по собі.

Спочатку, ви побачите невелику мову для цифрових пристроїв. Визначення цієї мови буде висвічувати загальний метод для вбудованих домен-специфічних мов (DSL) в основній мові, як Scala. Друге, ми представимо простий, але загальний фреймворк для симуляції дискретних подій. Його головне завдання буде відстеження дій, що виконуються в симульованому часу. Нарешті, ми покажемо, як програми дискретної симуляції можуть бути структуровані та побудовані. Ідея такої симуляції є моделювання фізичних об'єктів через симульовані об'єкти, та використання фреймворка симуляції для моделювання фізичного часу.

Приклад взятий з класичного підручника _Structure and Interpretation of Computer Programs_ від Abelson та Sussman [Abe96]. Що тут відрізняється, це те, що мова реалізації є Scala замість Scheme, та що різні аспекти приклада структуровані в шари програмного забезпечення: один для фреймворка симуляції, інший для базового пакунку симуляції схем, третій для бібліотеки визначених користувачем пристроїв, та останній шар для кожного окремого симульованого пристрою. Кожний з рівнів виражений як клас, та більш специфічні шари наслідують від більш загальних.

Швидкий шлях
------------
Розуміння симуляції дескретних подій, представленої в цій главі, займе деякий час. Якщо ви відчуваєте, що замість цього бажаєте зайнятись вивченням Scala, безпечно перейти далі, до наступної глави.

Малюнок 18.1 - Базові ключі.

18.4 Мова для цифрових пристроїв
--------------------------------
Ми почнемо з "малої мови" для опису дискретних цифрових пристроїв. Цифровий пристрій побудований з дротів та функціональних блоків. Дроти передають сигнали, що перетворюються функціональними блоками. Сигнали представлені як логічні рівні: `true` для вімкненого сигналу, `false` для вимкненого.

Малюнок 18.1 показує базові функціональні блоки (або вентилі):

* _Інвертор_, що обертає свій сигнал.
* _ТА-вентиль_, що встановлює свій вихід в кон'юкцію своїх входів.
* _АБО-вентиль_, що встановлює свій вихід в діз'юкцію своїх входів.

Ці вентилі достатні для побудови всіх інших функціональних блоків. Ключі мають затримки, так що вихід з вентиля буде змінюватись тільки через деякий час після зміни входу.

Ми опишемо елементи цифрової схеми через наступний набір класів та функцій Scala. Перше, існує клас `Wire` для дротів. Ми можемо конструювати дроти таким чином:
[source,scala]
----
val a = new Wire
val b = new Wire
val c = new Wire
----
або, еквівалентно, але коротше, ось так:
[source,scala]
----
val a, b, c = new Wire
----
Друге, існують три процедури, що "виготовляють" базові вентилі, що нам знадобляться:
[source,scala]
----
def inverter(input: Wire, output: Wire)
def andGate(a1: Wire, a2: Wire, output: Wire)
def orGate(o1: Wire, o2: Wire, output: Wire)
----
Що є незвичним, беручи функціональну схильність Scala, це те, що ці процедури конструюють вентилі як побічний ефект, замість повернення сконструйованих вентилів в якості результата. Наприклад, виклик `inverter(a, b)` покладає інвертор між дротами `a` та `b`. З'ясовується, що таке побічно-ефектне конструювання спрощує конструювання складних пристроїв поступово. Також, хоча методи більш часто мають імена-дієслова, ці називаються як прикметники, що вказує на вентилі, що вони виробляють. Це відображує декларативну природу DSL: це має описувати схему, а не дії по їх створенню.

Більш складні функціональні блоки можуть бути побудовані з базових вентилів. Наприклад, метод, показаний в Лістингу 18.6, конструює напів-суматор. Метод `halfAdder` приймає два входи, `a` та `b`, та продукує суму, `s`, визначене як `s = (a + b) % 2` та перенос, `c`, визначене як `c = (a + b) / 2`. Діаграма напів-суматора показана на Малюнку 18.2.
[source,scala]
----
def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) = {
  val d, e = new Wire
  orGate(a, b, d)
  andGate(a, b, c)
  inverter(c, e)
  andGate(d, e, s)
}
----
Лістинг 18.6 - Метод `halfAdder`.

Малюнок 18.2 - Схема напів-суматора.

Зауважте, що `halfAdder` є параметризованим функціональним блоком, так само, як три методи, що конструюють примітивні вентилі. Ви можете використовувати метод `halfAdder` для побудови більш складних схем. Наприклад, Лістинг 18.7 визначає повний однобітний суматор, показаний на Малюнку 18.3, що приймає два входи, `a` та `b`, так само, як вхідний перенос, `cin`, та який продукує на виході `sum`, визначений як `sum = (a + b + cin) % 2`, та вихідний перенос, визначений як `cout = (a + b + cin) / 2`.
[source,scala]
----
def fullAdder(a: Wire, b: Wire, cin: Wire,
    sum: Wire, cout: Wire) = {

  val s, c1, c2 = new Wire
  halfAdder(a, cin, s, c1)
  halfAdder(b, s, sum, c2)
  orGate(c1, c2, cout)
}
----
Лістинг 18.7 - Метод `fullAdder`.

Клас `Wire` та функції `inverter`, `andGate`, та `orGate` представляють малу мову, за допомогою якої користувачі можуть визначати цифрові пристрої. Це гарний приклад визначення _внутрішнього_ DSL, домен-специфічної мови, визначеної як бібліотека в основній мові, замість бути реалізованій сама по собі.

Малюнок 18.3 - Схема повного суматора.

Реалізація DSL пристроїв все ще має бути пропрацьована. Оскільки призначення визначення пристрою в DSL є симуляція пристрою. має сенс базувати реалізацію DSL на загальному API для симуляції дескретних подій. Наступні два розділи будуть презентувати спочатку API симуляції, та потім реалізацію DSL пристроїв зверху нього.

18.5 API симуляції
------------------
API симуляції показаний в Лістингу 18.8. Він складається з класа `Simulation` в пакунку `org.stairwaybook.simulation`. Конкретна бібліотека симуляції наслідує цей клас, та додає до неї домен-специфічну функціональність. Елементи класу `Simulation` представлені в цьому розділі.
[source,scala]
----
abstract class Simulation {
  
  type Action = () => Unit
  
  case class WorkItem(time: Int, action: Action)

  private var curtime = 0
  def currentTime: Int = curtime
  
  private var agenda: List[WorkItem] = List()
  
  private def insert(ag: List[WorkItem],
      item: WorkItem): List[WorkItem] = {
  
    if (ag.isEmpty || item.time < ag.head.time) item :: ag
    else ag.head :: insert(ag.tail, item) 
  }

  def afterDelay(delay: Int)(block: => Unit) = {
    val item = WorkItem(currentTime + delay, () => block)
    agenda = insert(agenda, item)
  }

  private def next() = {
    (agenda: @unchecked) match {
      case item :: rest =>
        agenda = rest
        curtime = item.time
        item.action()
    }
  }

  def run() = {
    afterDelay(0) {
      println("*** simulation started, time = " +
        currentTime + " ***")
    }
    while (!agenda.isEmpty) next()
  }
}
----
Лістинг 18.8 - Клас `Simulation`.

Симуляція дискретних подій виконує визначені користувачем дії у вказаний час. Дії, що визначені в субкласі конкретної симуляції, всі поділяють єдиний тип:
[source,scala]
----
type Action = () => Unit
----
Це твердження визначає `Action` як псевдоним для типу процедури, що приймає порожній список параметрів, та повертає `Unit`. `Action` є _членом типу_ класу `Simulation`. Ви можуту думати про це, як про більш читаєме ім'я для типу `() => Unit`. Члени типів будуть описані в деталях в Розділі 20.6.

Час, в який виконується дія, є симульований час; він не має нічого спільного зі справжнім часом "годинника на стіні". Симульований час представлений просто як ціле. Поточний симульований час утримується як приватна змінніа:
[source,scala]
----
private var curtime: Int = 0
----
Змінна має публічний метод аксессора, що повертає поточний час:
[source,scala]
----
def currentTime: Int = curtime
----
Ця комбінація приватної змінної з публічним аксессором використовується для переконання, що поточний час не може бути модифікований за межами класу `Simulation`. Кінець кінцем, звичайно ви не бажаєте, щоб ваші об'єкти симуляції маніпулювали поточним часом, можливо, за винятком, якщо ваша модель симуляції подорожує в часі.

Дія, що має бути виконана у вказаний час, називається робочим елементом. Робочий елемент реалізований як наступний клас:
[source,scala]
----
case class WorkItem(time: Int, action: Action)
----
Ми робимо клас `WorkItem` кейс класом, оскільки є синтаксичні зручності, що витікають з цього: ви можете використовувати метод фабрики `WorkItem`, щоб створити примірники класу, та ви задурно отримуєте аксессори для параметрів конструктора `time` та `action`. Також зауважте, що клас `WorkItem` вкладений в клас `Simulation`. Вкладені класи в Scala розглядаються подібно до Java. Розділ 20.7 надасть більше деталей.

Клас `Simulation` утримує порядок денний з усіх залишених робочих елементів, що ще не були виконані. Робочі елементи впорядковані по симульованому часу, в який вони мають виконуватись:
[source,scala]
----
private var agenda: List[WorkItem] = List()
----
Список `agenda` буде підтримуватись в потрібному впорядкованому вигляді через метод `insert`, що оновлює його. Ви можете бачити `insert`, коли той викликається з `afterDelay`, що є єдиним шляхом додати робочий елемент до розкладу:
[source,scala]
----
def afterDelay(delay: Int)(block: => Unit) = {
  val item = WorkItem(currentTime + delay, () => block)
  agenda = insert(agenda, item)
}
----
Як натякає ім'я, цей метод вставляє дію (надану як `block`) в розклад, так що вона планується для виконання з затримкою в одиницях часу, після поточного часу симуляції. Наприклад, наступний виклик буде створювати новий робочий елемент, що буде виконаний в симульований час `currentTime + delay`:
[source,scala]
----
afterDelay(delay) { count += 1 }
----
Код, що буде виконаний, міститься в другому аргументі метода. Формальний параметр для цього аргумента має тип `=> Unit` (тобто, це обчислення типу `Unit`, що передається по імені). Згадайте, що параметри за-ім'ям не обчислюються коли передаються в метод. Так що в виклику вище `count` буде інкрементовано тільки коли фреймворк симуляції викликає дію, що зберігається в робочому елементі. Зауважте, що `afterDelay` є карованою функцією. Це гарний приклад принципу, викладеного в Розділі 9.5, що каровані функції можуть використовуватись, щоб зробити виклик метода більш схожим на вбудований синтаксис. Створений робочий елемент все ще потребує бути вставленим в розклад. Це робиться через метод `insert`, що підтримує інваріант, згідно якого `agenda` впорядкована за часом:
[source,scala]
----
private def insert(ag: List[WorkItem],
    item: WorkItem): List[WorkItem] = {
  if (ag.isEmpty || item.time < ag.head.time) item :: ag
  else ag.head :: insert(ag.tail, item)
}
----
Основа класу `Simulation` визначений методом `run`:
[source,scala]
----
def run() = {
  afterDelay(0) {
    println("*** simulation started, time = " +
      currentTime + " ***")
  }
  while (!agenda.isEmpty) next()
}
----
Цей метод постійно вибирає перший елемент в `agenda`, видаляє його з розкладу, та виконує його. Він робить це, доки в роскладі більше не залишиться елементів, що не були виконані. Кожний крок виконується через метод `next`, що визначений таким чином:
[source,scala]
----
private def next() = {
  (agenda: @unchecked) match {
    case item :: rest =>
      agenda = rest
      curtime = item.time
      item.action()
  }
}
----
Метод `next` декомпонує потоний розклад за допомогою порівняння шаблонів на перший елемент, `item`, та залишок списку робочих елементів, `rest`. Він видаляє передній елемент з поточного розкладу, встановлює симульований час `curtime` до часу робочого елементу, та виконує дію робочого елемента.

Зауважте, що `next` може бути викликаний тільки якщо розклад непорожній. Немає `case` для порожнього списку, так що ви будете отримувати виключення `MatchError`, якщо ви спробуєте викликати `next` на порожньому розкладі.

Фактично, компілятор Scala буде звичайно попереджати вас, що ви пропустили один з можливих шаблонів для списку:
[source,scala]
----
Simulator.scala:19: warning: match is not exhaustive!
missing combination     Nil

    agenda match {
    ^
one warning found
----
В цьому випадку, відсутній `case` не є проблемою, оскільки ви знаєте, що `next` викликається на непорожньому розкладі. Таким чином, ви можете побажати відключити попередження. Ви бачили в Розділі 15.5, що це може бути зроблене через додавання анотації `@unchecked` до виразу селектора в порівнянні шаблонів. Ось чому код `Simulation` використовує `(agenda: @unchecked) match`, не `agenda match`. Це все. Це може виглядати як дивовижно малий код для фреймворка симуляції. Ви можете здивуватись, як цей фреймворк може потенційно підтримувати цікаві симуляції, якщо все, що він робить, це виконує список робочих елементів? Фактично, потужність фреймворку симуляції походить від факту, що дії, що зберігаються в робочих елементах, самі можуть встановлювати подальші робочі елементи в розклад під час виконання. Це робить можливим мати довготриваючі симуляції, розвинені з простого початку.

18.6 Симуляція схеми
--------------------
Наступний крок є використання фреймворку симуляції для реалізації домен-специфічної мови для пристроїв, показаної в Розділі 18.4. Згадайте, що DSL пристроїв складається з класа для дротів, та методів, що створюють ТА-вентилі, АБО-вентилі та інвертори. Всі вони містяться в класі `BasicCircuitSimulation`, що розширює фреймворк симуляції. Цей клас показаний в Лістингах 18.9 та 18.10.
[source,scala]
----
package org.stairwaybook.simulation

abstract class BasicCircuitSimulation extends Simulation {

  def InverterDelay: Int
  def AndGateDelay: Int
  def OrGateDelay: Int

  class Wire {
    private var sigVal = false
    private var actions: List[Action] = List()

    def getSignal = sigVal

    def setSignal(s: Boolean) =
      if (s != sigVal) {
        sigVal = s
        actions foreach (_ ())
      }

    def addAction(a: Action) = {
      actions = a :: actions
      a()
    }
  }

  def inverter(input: Wire, output: Wire) = {
    def invertAction() = {
      val inputSig = input.getSignal
      afterDelay(InverterDelay) {
        output setSignal !inputSig
      }
    }
    input addAction invertAction
  }
// продовження в Лістингу 18.10...
----

Лістинг 18.9 - Перша половина класу `BasicCircuitSimulation`.

[source,scala]
----
// ...продовження з Лістингу 18.9
  def andGate(a1: Wire, a2: Wire, output: Wire) = {
    def andAction() = {
      val a1Sig = a1.getSignal
      val a2Sig = a2.getSignal
      afterDelay(AndGateDelay) {
        output setSignal (a1Sig & a2Sig)
      }
    }
    a1 addAction andAction
    a2 addAction andAction
  }

  def orGate(o1: Wire, o2: Wire, output: Wire) = {
    def orAction() = {
      val o1Sig = o1.getSignal
      val o2Sig = o2.getSignal
      afterDelay(OrGateDelay) {
        output setSignal (o1Sig | o2Sig)
      }
    }
    o1 addAction orAction
    o2 addAction orAction
  }

  def probe(name: String, wire: Wire) = {
    def probeAction() = {
      println(name + " " + currentTime +
          " new-value = " + wire.getSignal)
    }
    wire addAction probeAction
  }
}
----  
Лістинг 18.10 - Друга половина класу `BasicCircuitSimulation`.

Клас `BasicCircuitSimulation` декларує три абстрактні методи, що представляють затримки базових вентилів: `InverterDelay`, `AndGateDelay`, та `OrGateDelay`. Дійсні затримки невідомі на рівні цього класу, оскікльи вони залежать від технології пристроїв, що будуть симульовані. Ось чому затримки залишені абстрактними в класі `BasicCircuitSimulation`, так що їх суцільне визначення делеговано до субкласів.footnote:[Імена ціх методів затримки починаються з великої літери, оскільки вони представляють константи. Вони є методами, так що вони можуть бути перекриті в субкласах. Ви винайдете, як робити ті самі речі з `val` в Розділі 20.3.] Реалізація інших членів класу `BasicCircuitSimulation` описана далі.

Клас Wire
~~~~~~~~~
Дріт має підтримувати три базові дії:

* `getSignal: Boolean`: повертає поточний сигнал на дроті.
* `setSignal(sig: Boolean)`: встановлює сигнал на дроті в `sig`.
* `addAction(p: Action)`: приєднує вказану процедуру `p` до дій на дроті. Ідея полягає в тому, що всі процедури дій, приєднані до деякого дроту, будуть використовуватись кожний раз, коли сигнал на дроті змінюється. Типово акції додаються до дроту через компоненти, приєднані до дроту. Приєднана дія виконується один раз, коли вона додається до дроту, та після цього кожний раз, коли сигнал на дроті змінюється.

Ось реалізація класу `Wire`:
[source,scala]
----
class Wire {

  private var sigVal = false
  private var actions: List[Action] = List()

  def getSignal = sigVal

  def setSignal(s: Boolean) =
    if (s != sigVal) {
      sigVal = s
      actions foreach (_ ())
    }

  def addAction(a: Action) = {
    actions = a :: actions
    a()
  }
}
----
Дві приватні змінні складають стан дроту. Змінна `sigVal` представляє поточний сигнал, та змінна `actions` представляє процедури дій, наразі приєднані до дроту. Одна цікава реалізація метода є `setSignal`: коли сигнал на дроті змінюється, нове значення зберігається в змінній `sigVal`. Більше того, всі дії, приєднані до дроту, виконуються. Зауважте скорочений синтаксис для виконання цього: `actions foreach (_ ())` застосовує функцію `_ ()` до кожного елементу в списку `actions`. Як описане в Розділі 8.5, функція `_ ()` є скороченням до `f => f ()` — тобто, вона приймає функцію (назвемо її `f`), та застосовує її до порожнього списку параметрів.

Метод `inverter`
~~~~~~~~~~~~~~~~
Єдиний ефект від створення інвертора в тому, що на його вхідному дроті встановлюється дія. Ця дія викликається кожний раз, коли дія інсталюється, та потім кожного разу, коли сигнал на дроті змінюється. Ефект дії в тому, що значення на виході інвертора встановлюється (через `setSignal`) на протилежність вхідного значення. Оскільки вентилі інверторів мають затримки, ця зміна повинна набувати ефекту тільки після `InverterDelay` одиниць симульованого часу після того, як вхідне значення було змінене, та дія була виконана. Це підказує наступну реалізацію:
[source,scala]
----
def inverter(input: Wire, output: Wire) = {
  def invertAction() = {
    val inputSig = input.getSignal
    afterDelay(InverterDelay) {
      output setSignal !inputSig
    }
  }
  input addAction invertAction
}
----
Ефект метода `inverter` є додавання `invertAction` до вхідного дроту. Ця дія, коли викликана, бере вхідний сигнал, та встанавлює іншу дію, що інвертує вихідний сигнал в симульованому розкладі. Ця інша дія буде виконана через `InverterDelay` одиниць симульованого часу. Зауважте, як метод використовує метод `afterDelay` фреймворка симуляції для створення нового робочого елемента, що буде виконаний в майбутньому.

Методи `andGate` та `orGate`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Реалізація ТА-вентилів аналогічна реалізації інверторів. Призначення ТА-вентилів є вивід кон'юкції його вхідних сигналів. Це має відбуватись через `AndGateDelay` одиниць симульованого часу після зміни одного з його вхідних сигналів. З цього випливає наступна реалізація:
[source,scala]
----
def andGate(a1: Wire, a2: Wire, output: Wire) = {
  def andAction() = {
    val a1Sig = a1.getSignal
    val a2Sig = a2.getSignal
    afterDelay(AndGateDelay) {
      output setSignal (a1Sig & a2Sig)
    }
  }
  a1 addAction andAction
  a2 addAction andAction
}
----
Ефект метода `andGate` є додавання `andAction` до обох його вхідних дротів, `a1` та `a2`. Ця дія, коли викликається, отримує обоє вхідні сигнали, та інсталює іншу дію, що встанавлює вихідний сигнал в кон'юкцію обох вхідних сигналів. Ця інша дія буде виконана після `AndGateDelay` одиниць симульованого часу. Зауважте, що вихід буде перерахований, якщо любий з вхідних дротів зміниться. Ось чому та сама акція `andAction` інсталюється для обох вхідних дротів, `a1` та `a2`. Метод `orGate` реалізований подібно, за винятком того, що він виконує логічне АБО замість логічного ТА.

Вивід симуляції
~~~~~~~~~~~~~~~
Щоб виконати симулятор, вам треба спосіб інспектувати зміни сигналів на дротах. Щоб досягти цього, ви можете симулювати дію покладання проби на дріт:
[source,scala]
----
def probe(name: String, wire: Wire) = {
  def probeAction() = {
    println(name + " " + currentTime +
        " new-value = " + wire.getSignal)
  }
  wire addAction probeAction
}
----
Ефект процедури `probe` є встановити `probeAction` на обраний дріт. Як звичайно, встановлена дія виконується кожний раз, коли сигнал на дроті змінюється. В цьому випадку вона просто друкує ім'я дроту (що передається як перший параметр до `probe`), так само, як і поточний час симуляції, та нове значення на дроті.

Запуск симулятора
~~~~~~~~~~~~~~~~~
Після всіх ціх підготувань настав час побачити симулятор в дії. Щоб визначити суцільну симуляцію, вам треба наслідувати від класу фреймворка симуляції. Щоб побачити щось цікаве, ми створимо клас абстрактної симуляції, що розширює `BasicCircuitSimulation`, та містить визначення методів для напів-суматора та повного суматора, як вони були представлені раніше в цій главі в Лістингах 18.6 та 18.7, відповідно. Цей клас, що ми назвемо  `CircuitSimulation`, показаний на Лістингу 18.11.
[source,scala]
----
package org.stairwaybook.simulation

abstract class CircuitSimulation
  extends BasicCircuitSimulation {

  def halfAdder(a: Wire, b: Wire, s: Wire, c: Wire) = {
    val d, e = new Wire
    orGate(a, b, d)
    andGate(a, b, c)
    inverter(c, e)
    andGate(d, e, s)
  }

  def fullAdder(a: Wire, b: Wire, cin: Wire,
    sum: Wire, cout: Wire) = {
    val s, c1, c2 = new Wire
    halfAdder(a, cin, s, c1)
    halfAdder(b, s, sum, c2)
    orGate(c1, c2, cout)
  }
}
----
Лістинг 18.11 - Клас `CircuitSimulation`.

Суцільна симуляція пристрою буде об'єктом, що наслідує від класа `CircuitSimulation`. Об'єкт все ще потребує виправлення затримок вентилів відповідно до технології реалізації пристрою, яка симулюється. Нарешті, вам також треба буде визначити суцільний пристрій, що має бути симульований. Ви можете зробити ці кроки інтерактивно в інтерпретаторі Scala: 
[source,scala]
----
scala> import org.stairwaybook.simulation._ 
import org.stairwaybook.simulation._ 
----
Зпершу вирішимо затримки вентилів. Визначимо об'єкт (назвемо її `MySimulation`), що провадить деякі числа:
[source,scala]
----
scala> object MySimulation extends CircuitSimulation {
        def InverterDelay = 1
        def AndGateDelay = 3
        def OrGateDelay = 5
      }
defined module MySimulation
----
Оскільки ви збираєтесь постійно отримувати доступ до членів об'єкта `MySimulation`, імпортування об'єкту підтримує подальший код коротшим:
[source,scala]
----
scala> import MySimulation._
import MySimulation._
----
Далі - пристрій. Визначте чотири дроти, та покладіть проби на два з них:
[source,scala]
----
scala> val input1, input2, sum, carry = new Wire
input1: MySimulation.Wire =
BasicCircuitSimulation$Wire@111089b
input2: MySimulation.Wire =
BasicCircuitSimulation$Wire@14c352e
sum: MySimulation.Wire =
BasicCircuitSimulation$Wire@37a04c

carry: MySimulation.Wire =
BasicCircuitSimulation$Wire@1fd10fa

scala> probe("sum", sum)
sum 0 new-value = false

scala> probe("carry", carry)
carry 0 new-value = false
----
Зауважте, що проби безпосередньо друкують вивід. Це тому, що кожна дія, встановлена на дроті, перший раз виконується при встановленні дії.

Тепер визначимо напів-суматор, під'єднавши дроти:
[source,scala]
----
scala> halfAdder(input1, input2, sum, carry)
----
Нарешті, встановимо сигнали, один за одним, на двох вхідних дротах, та запустимо симуляцію:
[source,scala]
----
scala> input1 setSignal true

scala> run()
*** simulation started, time = 0 ***
sum 8 new-value = true

scala> input2 setSignal true

scala> run()
*** simulation started, time = 8 ***
carry 11 new-value = true
sum 15 new-value = false
----
18.7 Висновок
-------------
Ця глава поєднала дві техніки, що спочатку виглядають окремими: змінний стан та функції вищих порядків. Змінний стан був використаний для симуляції фізичних сутностей, чий стан змінюється з часом. Функції вищих порядків були використані в фреймворку симуляції, щоб виконувати дії у вказаних точках симульованого часу. Вони також були використані в симуляціях пристроїв, що асоціюють дії зі змінами стану. По дорозі ви бачили простий шлях для визначення домен-специфічної мови як бібліотеки. Це, можливо, досить для однієї глави!

Якщо ви хочете залишитись трохи довше, ви можете за бажанням спробувати більше прикладів симуляцій. Ви можете комбінувати напів-суматори та повні суматори для створення більших пристроїв, або розробити нові прилади з визначених досі базових вентилів, та симулювати їх. В наступній главі ми вивчимо щодо параметризації типів в Scala, і побачимо інший приклад, де комбінація функціонального та імперативного підходів дає гарні рішення.
