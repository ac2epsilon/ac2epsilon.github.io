<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Програмування на Scala 2ed Перекладено українською</title>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  <body>
    <address> Перекладено українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
    <h1 style="text-align: center;">Програмування на Scala</h1>
    <h1 style="text-align: center;">Друга редакція</h1>
    <p style="text-align: center;">Martin Odersky - Lex Spoon - Bill Venner</p>
    <h3>Глава 1</h3>
    <h2>Маштабована мова</h2>
    <p>Ім'я Scala означає "маштабована мова". Мова названа так, оскільки вона
      розроблена до зростання за потребами користувача. Ви можете застосувати <br>
      Scala до широкого диапазона програмних завдань, від написання малих
      скриптів, до побудови великих систем. </p>
    <p>До Scala легко дістатись. Вона робить на стандартній платформі Java, та
      взаємодіє без проблем з усіма бібліотеками Java. Це досить гарна мова для
      написання скриптів, що поєднують разом Java компоненти. Але вона може
      застосувати свої сильні сторони навіть більше, при побудові великих систем
      та фреймворків повторно застосованих компонент. </p>
    <p>Технічно, Scala є сумішшю об'єктно-орієнтовної, та функціональної
      концепції статично типізованої мови. Сплав об'єктно-орієнтованого та
      функціонального програмування проявляє себе в багатьох аспектах Scala; це,
      можливо, більш поширено, ніж в інших, широко застосованих, мовах. Два
      програмні стилі мають доповнюючу силу, коли доходить до маштабованості.
      Конструкції функціонального програмування Scala спрощують побудову цікавих
      речей швидко, з простих частин. Її об'єктно-орієнтовні конструкції
      спрощують структурування більших систем, та їх адаптацію до нових вимог.
      Комбінація обох стилів в Scala робить можливим виразити нові різновиди
      шаблонів програмування та абстракції компонент. Це також призводить до
      розбірливого та стислого стилю програмування. Та, оскільки це так
      піддатливе, програмування на Scala може буде дуже приємною. </p>
    <p>Перший розділ відповідає на питання "Чому Scala?". Він дає високорівневий
      погляд да дизайн Scala, та на міркування, що стоять за цім. Після читання
      глави, ви повинні отримати базове відчуття, для чого створена Scala, та що
      за типи завдань вона може допомогти вам вирішити. Хоча це книга є
      підручникок зі Scala, ця глава насправді не є частиною підручника. Якщо ви
      прагнете почати писати деякий Scala код, ви можете перейти до Глави 2.</p>
    <h3>1.1 Мова, що зростає разом з вами</h3>
    <p>Програми різного розміру мають схильність потребувати різних програмних
      конструкцій. Розглянемо, наприклад, наступну малу програму на Scala:</p>
    <pre class="prettyprint linenums language-scala"> var capital = Map("US" -&gt; "Washington", "France" -&gt; "Paris")
      capital += ("Japan" -&gt; "Tokyo")
      println(capital("France"))</pre>
    <p>Ця програма встановлює відображення між країнами, та їх столицями,
      модифікує мапу додаванням нової прив'язки ("Japan" -&gt; "Tokyo"), та
      друкує столицю, асоційовану з країною France. Нотація цього прикладу є
      високорівневою, та не захаращена додатковими крапка-комами, або анотаціями
      типів.Таким чином, вона відчувається як "скриптова" мова, як Perl, Python,
      або Ruby. Одна загальна характеристика ціх мов, що відноситься до прикладу
      вище, в тому, що вони всі підтримують конструкцію "асоціативної мапи" в
      синтаксисі самої мови. </p>
    <p>Аосціативні мапи дуже корисні, оскільки вони допомагають утримувати
      програми розбірливими та стислими. Однак, іноді ви можете на погодитись з
      їх філософією "один розмір для всіх", оскільки вам треба контролювати
      властивості мап, що ви використовуєте в вашій програмі, в більш
      гарно-гранульований спосіб. Scala надає вам дей гарно-гранульований
      контроль, якщо він вам потрібен, оскільки мапи в Scala не є синтаксисом
      мови. Вони є бібліотечними абстракціями, що можна розширити та адаптувати.
    </p>
    <p>В програмі вище ви отримаєте реалізацію Map по замовчанню, але ви можете
      легко змінити це. Ви можете, наприклад, вказати певну реалізацію, таку, як
      HashMap або TreeMap, або ви можете вказати, що мапа повинна бути
      потіко-безпечною, змішуючи трейт SynchronizedMap. Ви можете вказати
      значення по замовчанню для мапи, або ви можете перекрити любий інший метод
      мапи, що ви створюєте. В жодному разі, ви можете використовувати той же
      простий синтаксис доступу до мап, як в прикладі вище.</p>
    <p>Цей приклад показує, що Scala може дати вам обоє, зручність та гнучкість.
      Scala має набір зручних конструкцій, що допомагаються вам швидко
      розпочати, та дозволяє вам програмувати в приємно узгодженому стилі. В той
      же час, ви маєте гарантції, що ви не пеерростете мову. Ви завжди можете
      підкроїти програму до ваших вимог, оскільки все базується на бібліотечних
      модулях, що ви можете обирати та адаптувати, як вам треба.</p>
    <h3>Вирощування нових типів</h3>
    <p>Eric Raymond ввів собор та базар як дві метафори розробки програмного
      забезпечення. Собор є майже-досконалою будівлею, що дуже довго будувати.
      Коли побудований, він стоїть незмінний довгий час. Базар, на відміну,
      адаптується та розширюється кожного дня, людьми, що роблять на ньому. В
      роботі Raymond базар є метафорою для розробки софтверу з відкритим кодом.
      Guy Steele зауважив в розмові про "зростаючу мову", що ту ж відмінність
      можна застосувати до розробки мови. Scala є більше схожою на базар, ніж на
      собор, в тому сенсі, що вона розроблена бути розширеною та адаптованою
      людьми, що програмуються на ній. Замість провадження всіх конструкцій, що
      вам можуть будь-коли знадобитись в одній, "абсолютно повній" мові, Scala
      надає в ваші руки інструменти для побудови таких конструкцій.</p>
    <p>Ось приклад. Багато застосувань потребують тип цилого, що може ставати
      довільно великим, без переповнень та усічень арифметичних операцій. Scala
      визначає такий тип в бібліотечному типі scala.BigInt. Ось визначення
      методу, що використовує цей тип, що обчислює факторіал переданого цілого
      значення:</p>
    <pre class="prettyprint linenums language-scala">        def factorial(x: BigInt): BigInt =<br>	if (x == 0) 1 else x * factorial(x - 1)</pre>
        <p>Тепер, якщо ми викличемо factorial(30), ми отримаємо:</p>
        <pre class="prettyprint linenums language-scala">	265252859812191058636308480000000</pre>
        <p>BigInt виглядає як вбудований, оскільки ви можете використовувати цілі літерали та операції, такі як * та -зі значенями цього типу. Але це тільки клас, що був визначений в стандартній бібліотеці Scala. 
          Якщо б такого класу не було, було б доцільним кожному програмісту на Scala написати реалізацію, наприклад, огорнувши 
          Java клас java.math.BigInteger (фактично,&nbsp; це те, як реалізовано Scala BigInt).</p>
        <p>Звичайно, ви можете також використовувати Java клас напряму. Але результат і близько не такий приємний, 
          оскільки хоча Java дозволяє вам створити нові типи, вони не відчуваються як природно підтримувані мовою:</p>
        <pre class="prettyprint linenums language-scala">import java.math.BigInteger
def factorial(x: BigInteger): BigInteger =
  if (x == BigInteger.ZERO)
    BigInteger.ONE
  else
    x.multiply(factorial(x.subtract(BigInteger.ONE)))</pre>
        <p>BigInt є представником значно більшого переліку число-подібних типів — великих з десятичною крапкою, комплексних чисел, дійсних чисел, довірчих інтервалів, многочленів&nbsp; — це список можна продовжувати. Деякі мови програмування реалізують деякі з ціх типів природно. Наприклад, Lisp, Haskell, Python реалізують великі цілі; Fortran та Python реалізують комплексні числа. Але жодна мова, що намагалась реалізувати 
          всі ці абстракції одночасно буде просто завеликою, щоб бути керованою. Що найбільше, навіть, якщо застосування будуть напевне 
          мати вигоду від інших число-подібних типів, що не підтримуються. Так що підхід намагання провадити все в рамках мови не буде маштабуватись дуже гарно. </p><p>Замість цього, Scala дозволяє користувачам зростати та адаптувати мову в потрібному їм напрямку, визначаючи прості для використання бібліотеки, що відчуваються як природна підтримка мовою.</p><h3>Вирощування нових структур керування</h3><p>Попередній приклад демонструє, що Scala дозволяє вам додавати нові типи, що можуть бути використані&nbsp; як зручні вбудовані типи. Той же принцип розширення також стосуєтсья до структур керування. Цей різновид розширюваності проілюстровано в Scala API для “базованих-на-акторах” конкурентному програмуванні.</p><p>Позаяк мультиядерні процесори розповсюджуються в останні роки, досягнення прийнятної продуктивності може все більше потребувати, щоб ви використовували більше паралелізму в ваших застосуваннях. Часто це означає переписування вашого кода, так, щоб обчислення були розпорошені між декільками конкурентними потоками. На жаль, створення надійних багато-поточних застосувань на практиці було визнане неабияким викликом. Модель потоків&nbsp;Java побудована коло розділеної пам'яті та блокувань, модель, що часто складно продумати, особливо з тим, як система маштабується в розмірі та складності. Є складним впевнитись, що ви не маєте стану гонок або не притаївся грухий кут — іноді це не можливо показати під час тестувань, але може проявити себе під час використання. Спірно безпечнішою альтернативою є передача повідомлень, така, яку мова програмування Erlang використовує за допомогою "акторів".</p>Java іде з багатою, базованою на потоках, бібліотекою конкурентності. Програми Scala можуть використовувати її, як і інші Java API. <br>
        <br>Однак, Scala також пропонує додаткову бібліотеку, що в основному реалізує модель акторів Erlang.<p>
        Актори є&nbsp; абстракціями конкуренції, що можуть бути реалізовані зверху потоків. 
        Вони комунікіють, надсилаючи повідомлення один одному. 
        Актор може виконувати дві базові операції, надсилання та отримання повідомлення. 
        Операція надсиланя, що виглядає як наголос (!), надсилає повідомлення до актора. Ось приклад, в якому актор названий recipient:
        </p>
        <pre class="prettyprint linenums language-scala">recipient ! msg</pre>
        <p>Надсилання є асинхронним; тобто, відсилаючий актор може продовжувати безпосередньо,<br>без очікування, що повідомлення було отримане та оброблене. Кожний актор має поштову скриньку, де входящі повідомлення ставляться в чергу. Актор обробляє прибувше до поштової скриньки через блок receive:
        </p>
        <pre class="prettyprint linenums language-scala">receive {<br>case Msg1 =&gt; ... // handle Msg1
        case Msg2 =&gt; ... // handle Msg2<br>// ...
        }</pre>
        <p>Блок receive складається з декількох випадків, що ставить запити до поштової скриньки з шаблоном повідомлення. 
          Перше повідомлення в поштовій скриньці, що співпаде з любим з випадків, та відповідний актор, що виконує його. 
          Якщо поштова скринька не містить жодних повідомлень, що співпадають з наданою умовою, актор призупиняється, та 
          очікує на подальші входящі повідомлення.</p><p>Як приклад, ось простий актор Scala, що реалізує сервіс калькулятора 
        контрольної суми:</p>
        <pre class="prettyprint linenums language-scala">actor {
var sum = 0
loop {
  receive {
    case Data(bytes)
		  =&gt; sum += hash(bytes)<br>case GetSum(requester) =&gt; requester ! sum
    }
  }
}</pre><p>Цей актор спочатку визначає локальну змінну, на ім'я sum, з початковим значенням руль. Потім він постійно очікує в циклі надходження повідомлень, використовуючи твердження. Якщо він отримує повідомлення Data, він додає хеш надісланих байтів да змінної суми. Якщо він отримує повідомлення GetSum, 
        він надсилає поточне значення суми назад, до запитуючого, використовуючи повідомлення через requester ! sum. Поле requester вбудоване в повідомлення GetSum; воно звичайно посилається на актора, що зробив запит.</p><p>Ми не очікуємо, що ви повністю розумієте приклад з актором в цій точці. Скоріше, що важливе щодо цього приклада для теми маштабовності, це те, що ні актор, ні цикл, ні надсилання повідомлення (!) не є вбудованими операціями Scala. Навіть не зважаючи на те, що актор, цикл, та receive виглядають та діють як керівні вбудовані структури, як цикли while або for, вони, фактично, є методами, визначеними в бібліотеці акторів Scala. Таким же чином, навіть якщо ‘!’ виглядає як вбудований оператор, це також тільки метод, визначений в бібліотеці акторів. Всі ці чотири конструкції є повністю незалежні від мови програмування Scala.</p><p>Блок receive та синтаксис (!) виглядає в Scala більше як в Erlang, але в Erlang ці конструкції вбудовані в мову. Scala також реалізує більшість з інших конструкцій конкурентності Erlang, таких, як моніторинг схибівших акторів та тайм-аути. </p><p>Так чи інакше, актори перетворились на дуже приємні умови для вираженя конкурентних та розподілених обчислень. Навіть зважаючи, що вони визначені в бібліотеці, актори відчуваються як невід'ємна частина мови Scala.</p><p>Цей приклад ілюструє, що ми можете "зростити" мову Scala в нових напрямках, навіть таких специфічних, як конкурентне програмування. Щоб бути переконаним, вам знадобляться гарні архитектори та програмісти, щоб зробити це. Але наріжна річ в цьому є розробка та реалізація абстракцій в Scala, що адресують радикально нові домени застосування, що все ще відчуваються як природна підтримка мови.</p><h3>1.2&nbsp; Що робить Scala маштабованою?</h3><p>Маштабованість складається з бегетьох факторів, починаючи з деталей синтаксису, до конструктивів абстракції компонентів. Однак, якщо ви змушені назвати тільки один аспект Scala, що допомагає маштабованості, ми обираємо комбінацію з об'єктно-орієнтованого та функціонального програмування (гаразд, ми прибрехали, це насправді два аспекта, але вони пов'язані).</p><p>Scala іде далі, ніж всі інші, гарно відомі, мови, в сплавленні програмування в одноманітний дизайн мови. Наприклад, там, де інші мови можуть мати об'єкти та функції, як дві різні концепції, в Scala значення функції є об'єктом. Функціональне значення є об'єктом. Функціональні типи є класами, що можуть наслідуватись суб-класами. Це може виглядати як не більше, ніж академічна тонкість, але це має глибокі наслідки для маштабовності. Фактично, концепція акторів, показана раніше, не може бути реалізована без уніфікації функцій та об'єктів. Цей розділ дає огляд спсобу Scala змішування об'єктно-орієнтовної та функціональної концепцій. </p><h4>Scala є об'єктно-орієнтованою</h4><p>Об'єктно-орієнтовано програмування було дуже успішним. Починнаючи з Simula в середині 60х, та Smalltalk в 70х, тепер воно доступне для більшості мов. В деяких галузях об'єкти захопили все повністю. Хоча немає точного визначення, що значить об'єктно-орієнтований, напевне є щось щодо об'єктів, що приваблює програмістів. </p><p>В принципі, мотивація для об'єктно-орієнтованого програмування є дуже простою: всі, окрім найбільш тривіальних програм, потребують деякий різновид структури. Найбільш прямолінійний шлях зробити це, є покласти дані та операції в деяку форму контейнера. Велика ідея об'єктно-орієнтованого програмування є зробити ці контейнери повністю загальними, так що вони можуть містити операції, так само, як дані, та що вони сами по собі є значеннями, що можуть зберігатись в інших контейнарах, або передані як параметри до операцій. Такі контейнер називаются об'єктами. Alan Kay, розробник Smalltalk, зауважив, що, таким чином, простіший об'єкт має ту ж принципіальну конструкцію, що і цілий комп'ютер: він комбінує дані з операціями під формалізованим інтерфейсом. Так що об'єкти мають безпосереднє відношення до маштабованості мови: ті <br>ж прийоми стосуються до конструкції малих, так само як і великих, програм.</p>Навіть хоча о'бєктно-орієнтоване програмування було головним напрямком на протязі довгого часу, є відносно небагато мов, що послідували за Smalltalk в просуванні принципу побудови до його логічного завершення. Наприклад, багато мов визнають значення, що не є об'єктами, такі, як примітивні типи в Java. Або вони дозволяють статичні поля та методи, що не є членами жодного об'єкта. Ці відхилення від чистої ідеї об'єктно-орієнтованого програмування на перший погляд виглядають нешкідливими, але вони мають надокучливу тенденцію ускладнювать речі та обмежувать маштабованість.<p>На відмуну, Scala є об'єктно-орієнтованою мовою в чистій формі: кожне значення є об'єктом, та кожна операція є виклик метода. Наприклад, коли ви кажете 1 + 2 в Scala, ви, насправді, викликаєте метод&nbsp; +, визначений на класі Int. Ви можете визначити методи з іменами, схожими на оператори, що клієнти вашого API, потім можуть використовувать їх в операторній нотації. Це той спосіб, як API акторів Scala дозволяють вам використовувати вирази, такі як requester ! sum, показаний в попередньому прикладі: ‘!’ є методом класа Actor.</p><p>Scala є більш просунутою, ніж більшість інших мов, коли йдеться до компонування об'єктів. Прикладом є трейти Scala. Трейти як інтерфейси в Java, але вони також можуть мати реалізації методів, та навіть поля. Об'єкти конструюються через міксування композицій, що бере члени класа, та додає до них члени декількох трейтів. Таким чином, різні аспекти класів можуть бути інкапсульовані в різних трейтах. Це виглядає трохи подібним на множинне наслідування, але починає відрізнятись, коли доходить до деталей. на відміну від класа, трейт може додати деяку нову функціональність до невизначеного класа. Це робить трейт більш "плугабельним", ніж класи. Зокрема це виключає класичну проблему "діамантового наслідування" множинного наслідування, що постає, коли той же клас наслідується через декілька різних шляхів. </p><h4>Scala є функціональною</h4><p>На додаток до того, що це об'єктно-орієнтована мова, Scala є також повноцінною функціональною мовою. Ідеї функціонального програмування є старіші, ніж (електронні) комп'ютери. Їх основи були покладені в лямбда-численні Alonzo Church, що розроблене в 1930х. Перша функціональна мова програмування була Lisp, що датується пізніми 50ми. Інші популярні функціональні мови є Scheme, SML, Erlang, Haskell, OCaml, та F#. На протязі довгого часу, функціональне програмування було дещо на обочині, популярне в акадесічному середовищі, але не широко не використовувалось в індустрії. Однак, останні роки показують зростаючу зацікавленість в мовах функціонального програмування та технологіях.</p><p>Функціональне програмування керується двома ідеями. Перша ідея полягає в тому, що функції є першокласними значеннями. В функціональній мові функція є значенням з таким же статусом, що і, скажімо, цілі або рядки. Ви можете передати функцію як аргумент до інших функцій, повернути як результат з функції, або зберігти в змінінй. Ви також можете визначити функцію в іншій функції, так, як ви можете визначити ціле значення в функції. Та ви можете визначити функції, давши їм ім'я. Зрошування вашого кода функціональними літералами таке просте, як ви можете записати літерал 42. </p><p>Функції, що є першокласними значеннями, провадять зручний спосіб для абстрагування над операціями, та створення нових структур керування. Це узагальнення провадить величезну виразність, що часто приводить до дуже розбірливих та стислих програм. Це також грає важливу роль для маштабованості. Як приклад, конструкція receive, показана вище, в прикладі актора, є викликом метода, що приймає функцію як аргумент. Код всередині конструкції receive є функція, що передається без виконання в метод receive.</p><p>В більш традиційних мовах, на відміну від цього, функції не є значеннями. Мови, що мають значення функцій, часто зводять їх до другорядного статуса. Наприклад, вказівники на функцію в C та C++ не мають того ж статуса, що і не-функціональні значення в ціх мовах: вказівники на функції можуть посилатись лише на глобальні функції, вони не дозволяють вам визначати першокласні вкладені функції, що посилаються на деякі значення зі свого тотчення. Також вони не дозволяють вам визначати безіменні функціональні літерали.&nbsp;</p><p>Друга головна ідея функціонального програмування полягає в тому, що операції програми повинні відображати вхідні значення на вихідні значення, скоріше, ніж змінювати дані на місці. Щоб побачити різницю, розглянемо реалізацію рядків в Ruby та Java. В Ruby рядок є масивом символів. Символи в рядку можна змінити індивідуально. Наприклад, ви можете змінити символ крапки з комою в рядку та одну крапку, в тому ж об'єкті рядка. В Java та Scala, з іншого боку, рядок є послідовнясть символів в математичному сенсі. Заміна символа в рядку з використання виразу, як s.replace(';', '.') дає новий об'єкт рядка, що відрізняється від s. Інший шлях виразити це - сказати, що рядки є незмінні в Java, хоча вони змінні в Ruby. Так що дивлячись лише на рядки, Java є функціональною мовою, тоді як Ruby - ні. Незмінні структури даних є одним з наріжних каменів функціонального програмування. Бібліотеки Scala визначають багато незмінних типів даних, зверху тих, що можна знайти в Java API. Наприклад, Scala має незмінні списки, кортежі, мапи та набори.</p><p>Інший шлях викласти цю другу ідею функціонального програмування, це те, що метод не повинен мати жодних побічних ефектів. Вони мають комунікувати зі своїм оточенням, тільки приймаючи аргументи, та повертаючи результати. Наприклад, метод заміни в класі&nbsp; Java String підходить до цього критерію. Він приймає рядок та два символа, та дає новий рядок, де всі входження одного символа замінені на інший. Немає іншого ефекту при виклику replace. Методи, як replace, називаються рефертно прозорими, що означає, що кожний наданий вхід при виклику метода може бути замінений результатом, без валиву на семантику програми.</p><p>Функціональні мови заохочують незмінні структури даних та референтно прозорі методи. Деякі функціональні мови навіть потребують їх. Scala дає вам вибір. Коли ви бажаєте, ви можете писати в імперативному стилі, що є програмуванням зі змінним станом та побічними ефектами. Але Scala загалом робить легким уникати імперативних конструкцій, за вашим бажанням, оскільки існують гарні функціональні альтернативи. </p><h3>1.3 Чому Scala?</h3><p>Чи є Scala для вас? Ви можете зрозуміти та вирішити для себе. Ми винайшли, що насправді є багато причин, окрім маштабованості, щоб вподобати програмування на Scala. Ми в цьому розділі обсудимо чотири найбільш важливі акпекти: сумісність, краткість, високорівневі абстракції, та просунута статична типізація.</p><h4>Scala є сумісною</h4><p>Scala не потребує, щоб ви зістрибували з Java платформи, щоб піти далі від мови Java. Вона дозволяє вам додати вартість до існуючого кода — будувати на тому, що ви вже маєте — оскільки вона була розроблена для безтурботної взаємодії з Java. Програми Scala компілюються в байткоди JVM. Їх швидкість виконання звичайно на рівних з програмами Java. Код Scala може викликати методи Java, мати доступ до полів Java, наслідувати від класів Java, та реалізувати Java інтерфейси. Жодне з цього не потребує спеціального синтаксису, явних дескрипторів інтерфейсу або зкліючого коду. Фактично, майже весь код Scala потужно використовує біблиотеки Java, часто без того, щоб ставити до відома програміста про цей факт.</p><p>Інший аспект повної сумісності в тому, що Scala потужно використовує типи Java. Scala Int представлені як примітивні цілі Java типу int, Float представлені як float, Boolean як boolean, і так далі. Масиви Scala відображуються на масиви Java. Scala також використовує багато стандартних бібліотечних типів Java. Наприклад, тип рядка "abc" в Scala є java.lang.String, та викликане виключення має бути субкласом java.lang.Throwable.</p><p>Scala не тільки використовує типи Java, але також "принаряджає їх", щоб зробити їх кращими. Наприклад, рядки Scala підтримують методи, як toInt або toFloat, що конвертують рядок на ціле число або з число плаваючою крапкою. Так що ви можете писати str.toInt, замість Integer.parseInt(str). Як це може бути досягнуто без поломки сумісності? Клас Java String напевне ме має методу toInt! Фактично, Scala має дуже загальне рішення, щоб вирішити це напруження між просунутим дизайном бібліотеки, та сумісністю. Scala дозволяє вам визначити неявні перетворення, що завжди застосовуються, коли ти не співпадають звичайно, або коли обираються неіснуючі члени. В випадку вище, коли поглянете на метод toInt на рядкові, компілятор Scala не знайде такого члена в класі String, але він знайде неявне перетворення, що конвертує Java String в примірник класу Scala StringOps, що визначає такий член. Перетворення буде застосоване неявно перед викоранням операції toInt.</p><p>Код Scala може бути викликаний з кода Java. Це іноді трохи більш тонке, оскільки Scala є багатшою мовою, ніж Java, так що деякі з найбільш просунутих можливостей Scala повинні бути закодовані, перед тим, як вони можуть бути відображені на Java. Глава 31пояснює деталі.</p><h4>Scala є стислою</h4><p>Програми Scala схильні бути короткими. Програмісти Scala повідомляли про зменшення числа рідків до десяти разів, порівняно з&nbsp; Java. Це може бути екстремальним випадком. Більш консервативне очікування може полягати в тому, що типова програма на Scala повинна мати половину чила рядків, для тієї ж програми, написаної на Java. Менше рядків кода означає не тільки менше друку, але також менше зусиль при читанні та розумінні програм, та менше можливостей для дефектів. Є декілька факторів, що мають причетність до цього зменшення числа рядків.&nbsp;</p><p>Перше, синтаксис Scala уникає деяких шаблонів, що захаращують Java програми. Наприклад, крапка з комою опціональні в Scala, та, зазвичай, відкидаються. Є також декілька інших областей, де синтакис Scala менш шумний. Для прикладу порівняйте, як ви пашете класи та конструктори в Java та Scala. 
        В Java, клас з конструктором часто виглядає подібно до наступного:</p>
        <pre class="prettyprint linenums language-java">// це Java<br>class MyClass {
    private int index;
    private String name;
    public MyClass(int index, String name) {
        this.index = index;
        this.name = name;
    }
}</pre>В Scala, ви, напевне, замість цього напишите таке:
        <pre class="prettyprint linenums language-scala">class MyClass(index: Int, name: String)</pre>
        <p>Маючи цей код, компілятор Scala спродукує клас, що має дві приватних змінних примірника, Int з іменем index, String з іменем name, та конструктор, що приймає початкові значення для ціх змінних, в якості параметра. Код цього констректора буде ініціалізувати дві змінні екземпляра значеннями, переданими як параметри. Коротко кажучи, ви отримаєте в основному ту ж функціональність, що і більш балакуча версія на Java. Клас Scala швидше написати, простіше читати, та, що більше важливо, меньше схильний до помилок, ніж клас Java.</p><p>Вивід типів Scala є іншим фактором, що докладається до стислості. Повторювана інформація про типи може бути відкинута, так що програми стають менш захаращені, та біль читабельні.</p><p>Але, можливо, найбільш важливий ключ до компактного коду є те, що вам не треба писати, бо воно вже реалізоване в бібліотеці за вас. Scala дає вам багато інструментів для визначення потужних бібліотек, що дозволяють вам захопити та примножити загальну поведінку. Наприклад, різні аспекти бібліотечних класів можуть бути виділені в трейти, що потім можуть бути зміксовані разом в гнучкий спосіб . Або бібліотечні методи можуть бути параметризовані операціями, що дозволяє визначити конструкції, які ефективно є вашими структурами керування. Разом ці конструкції дозволяють визначати бібліотеки, що обоє, високорівневі, та гнучкі у використанні.</p><h4>Scala є високорівневою</h4><p>Програмісти постійно стикаються зі складністю. Для продуктивного програмування ви повинні розуміти код, з яким працюєте. Дуже складний код спричинив повалення багатьох софтверних проектів. На жаль, важливі програми часто мають складні вимоги. Такої складності можна уникнути; замість цього єю можна керувати. </p><p>Scala допомагає вам керувати складністю, дозволяючи вам підіймати рівень абстракцій в інтерфейсах, що ви розробляєте та використовуєте. Як приклад, уявіть, що ви маєте змінну String name, та ви бажаєте знайти, чи містить, чи ні, ця змінна типу String великі літери. В Java ви можете написати таке:</p>
        <pre class="prettyprint linenums language-java">// це Java
boolean nameHasUpperCase = false;
for (int i = 0; i &lt; name.length(); ++i) {
   if (Character.isUpperCase(name.charAt(i))) {
       nameHasUpperCase = true;
       break;
   }
}</pre>
        <p>На Scala це можна записати так:</p>
        <pre class="prettyprint linenums language-scala">val nameHasUpperCase = name.exists(_.isUpper)</pre>
        <p>Код Java сприймає рядки як низькорівневі сутності, що проходяться в циклі символ за символом. Код Scala трактує той же рядок як послідовність вищого порядку, що може бути опитаний за допомогою предикатів. Ясно, що код Scala більш короткий, та, для треновоного ока, простіший для розуміння, ніж код Java. Так що код Scala менше тисне на загальний бюджет складності. Він також дає вам менше можливостей зробити помилку.&nbsp;</p><p>Предикат _.isUpper є прикладом функціонального літерала в Scala. Він описує функцію, що приймає символьний аргумент (представлений символом підкреслення), та перевіряє, чи він є великою літерою.</p><p>В принципі, такі керівні абстракції також можливі і в Java. Вам треба визначити інтерфейс, що містить метод з абстрактною функіональністю. Наприклад, якщо ми бажаємо підтримувати запити до рядків, ви можете ввести інтерфейс, названий CharacterProperty, що має тільки один метод, hasProperty:</p>
        <pre class="prettyprint linenums language-java">// це Java
interface CharacterProperty {
   boolean hasProperty(char ch);
}</pre>
        <br>
        З таким інтерфейсом ви можете зформулювати на Java метод exists: він приймає рядок та CharacterProperty, та повертає true, якщо символ в рядку задовільняє властивості. Ви можете потім викликати exists наступним чином:
        <pre class="prettyprint linenums language-java">// це Java
exists(name, new CharacterProperty() {
    public boolean hasProperty(char ch) {
    	return Character.isUpperCase(ch);
    }
});</pre><p>Але все це, скоріше, заважке. Таке заважке, фактично, що більшість Java програмістів не будуть з цім поркатись. Вони тільки напишуть цикли, та полишать це з додатковою складністю кода. З іншого боку, літеральні функції в Scala є деж легковажними, так що вони часто використовуються. По мірі, як ви пізнаваємете Scala краще, ви винайдете більше і більше можливостей визначати та використовувати свої сласні абстракції керевання. Ви найдете, що це дозволяє уникати дублікації кода, і, таким чином, утримувати ваші програми коротшими та яснішими. </p><h4>Scala є статично типізованою</h4><p>Статична система тіпів класифікує змінні та вирази, відповідно до властивостей значень, що вони містять та обчислюють. Scala вирізняється, як мова з дуже просунутою системою статичних типів. Починаючи з системи вкладених типів класів, здебільшого як в Java, вона дозволяє параметризувати типи дженеріками, комбінувати типи з використанням перетинів, та приховувати деталі типів, використовуючи абстрактні типи. Це покладає сильне підгрунтя для побудови та компнування ваших власних типів, так що ви можете розробити інтерфейси, що, одночасно, безпечні, та гнучкі до використання.</p><p>Якщо ви вподобали динамічні мови, як Perl, Python, Ruby або Groovy, ви можете знайти це досить дивним, що система статичних типів Scala перелічується як одна з її сильних сторін.В кінці кінців, відсутність статичної системи типізації визначається деякими як найбільше перевага динамічних мов. Найбільш загальні аргументи проти статичних типів в тому, що вони роблять програми дуже балакучими, заважають програмістам виражати себе в бажаний спосіб, та роблять неможливим деякі шаблони динамічних модифікацій програмних систем. Однак, часто ці аргументи не ідуть в розріз з ідеєю статичними типами загалом, але проти окремих систем типів, що сприймаються як дуже балакучі та дуже негнучкі. Наприклад, Alan Kay, винахідник мови Smalltalk, колись зауважив: "Я не проти типів, вле я не знаю про жодну систему типів, що не є суцільною боллю, так що мені подобається динамічна типізація". Ми сподіваємось переконати вас в цій книзі, що система типів Scala є далекою від "суцільної болі". Фактично, вона гарно адресована до двох звичайних занепокоєнь щодо статичної типізації: галасливість уникається через вивід типів, та гнучкість досягається через співпадіння шаблонів, та декілька нових способів писати та компонувати типи. Коли прибрані ці перешкоди, класичні вигоди статичних систем типів можуть бути краще оценені. Серед найбільш важливих з ціх переваг є перевірка властивостей програмних абстракцій, безпечний рефакторинг, та краща документація.</p><p><em><strong>Перевірка властивостей. </strong></em>Статичні системи типів можуть довести відсутність окремих помилок часу виконання. наприклад, вони можуть підтвердити властивості, як: логічні ніколи не додаються до цілих; приватні змінні не отримуються доступ зза меж їхнього класу; функції застосовуються до вірно числа аргументів; до набору рядків додаються тільки рядки.</p><p>Інші типи помилок не визначаютьсь сучасними системами статичних типів. Наприклад, вони, звичайно, не помічають не-терміновані функції, порушення меж масиву, або ділення на нуль. Вони також не помічають, що ваша програма не відповідає своїй специфікації (будемо вважати, що така специфікація є!). Статичні системи типів мають, таким чином, розвінчані деякими, як ті, що не є дуже корисними. Аргумент, що слідує за цим, полягає в тому, що системи типів можуть детектувати тільки прості помилки, тоді як юніт тести провадять більш ексенсивне охоплення, то чому взагалі поратись зі статичними типами? Ми вважаємо, що ці аргументи не мають сенсу. Хоча статичні системи типів, безумовно, не можуть замінити юніт тести, мони можуть зменшити число потрібних юніт тестів, турбуючись про деякі властивості, що в іншому випадку потребували б тестування. Так само, як і юніт тести не можуть замінити статичні типи. В кінці кінців, як сказав Edsger Dijkstra, тестування може лише довести наявність помилок, але ніколи їх відсутність. Так що гарантії, що дає статична типізація, можуть бути простими, але це реальні гарантії, в формі, що не можуть дати купа тестів. </p><p><em><strong>Безпечний рефакторинг.</strong></em> Статична система типів провадить строховочну сітку, що дозволяє вам робити зміни в кодовій базі, з високою ступінню довіри. Уявімо, наприклад, рефакторинг, що додає додатковий параметр до метода. В статично типізованій мові ви можете зробити зміну, перекомпілювати вашу систему, та просто виправити всі рядки, що спричинили помилку. Коли ви скінчите з цім, ви будете впевнені, що знайшли всі місця, що потребували змін. Те ж вірно для багатьох інших простих рефакторингів, як зміна імені метода, або переміщення метода з одного класа до іншого. В усіх випадках перевірка статичного типу буде провадити досить страховки, що нова система буде робити, як стара.</p><p><em><strong>Documentation.</strong></em> Статичні типи є документацією програми, що перевірена компілятором на коректність. На відміну від звичайних коментарів, анотація типу ніколи не буде простроченою (щонайменьше, ні, якщо початковий файл, що містить її, був нещодавно проходив через компілятор). Більше того, компілятори та інтегровані середвища розробки можуть використовувати анотації типів, щоб провадити кращу контекстну допомогу. Наприклад, інтегроване середовище розробки може відображати всі члени, доступні для вибору, визначаючи статичний тип виразу, на якому зроблений вибір, та переглядаючи всі члени цього типу.</p><p>Навіть зважаючи, що статичні типи загалом корисні для документації програми, вони можуть іноді бути надокучливими, коли вони привносять безлад в програму. Типово, корисна документація є те, що читачі програми не можуть просто вивести самі. В визначені метода, як:</p>
<pre class="prettyprint linenums language-scala">def f(x: String) = ...</pre>
<p>є крисним знати, що аргументом f повинний бути String. З іншого боку, щонайменьше один з двох анотацій в наступному прикладі є надокучливим:</p>
<pre class="prettyprint linenums language-scala">val x: HashMap[Int, String] = new HashMap[Int, String]()</pre>
<p>Ясно, що достатно сказати тільки один раз, що x є HashMap, з Int в якості ключа, та Strings в якості значень; немає потреби повторювати те ж саме двічі.</p><p>Scala має дуже витончену систему виводу типів, що дозволяє вам уникати всієї інформації щодо типів, що звичайно здається надокучливою. В попередньому прикладі наступні дві менш надокучливі альтернативи також можуть виконувати свою справу:</p>
<pre class="prettyprint linenums language-scala">val x = new HashMap[Int, String]()
<br>val x: Map[Int, String] = new HashMap()</pre>
<p>Вивід типів в Scala може піти значно далі. Фактично, не є незвичним для користувацького кода не мати явних типів взагалі. Таким чином, програми Scala часто виглядають як написані на динамічно типізованій мові. Це вірно, зокрема, для клієнтського кода застосування, що зкліює разом попередньо написані бібліотечні компоненти. Це меньш вірно для самих бібліотечних компонент, оскільки вони часто використовують досить складні типи, що дозволяють гнучкі шаблони використання. Це просто природно. Кінець кінцем, всі сігнатури типів членів, що складають інтерфейс повторно використовуваних компонент, повинні бути надані явно, оскільки вони складають головну частину контракту між компонентами та їх клієнтами.</p><h3>1.4&nbsp; Витоки Scala</h3><p>На дизайн Scala вплинули багато мов програмування, та ідей розробки мов програмування. Фактично, тульки декілька можливостей Scala є чисто новими; більшість вже були застосовані в деякій формі в інших мовах. Іновації Scala походять в основному її конструкцій, що покладаються разом. В цьому розділі ми перелічимо головні джерела впливу на дизайн Scala. Цей список не може бути вичерпним — просто є дуже багато розумних ідей щодо дизайну мови програмування, щоб перелічити тут їх всіх.</p><p>На поверхні Scala адаптує широку частину синтаксису Java та C#, що, в свою чергу, запозичили більшість з їх синтксичних домовленостей з C та C++. Вирази, твердження, та блоки в основному як в Java, так само, як синтаксис класів, пакунків та імпортів. Окрім синтаксиса Scala переймає інші елементи Java, такі як базові типи, її бібліотеки типів, та її модель виконання.</p><p>Scala також багато запозичає з інших мов. ЇЇ однорідна об'єктна модель була освоєна в Smalltalk, та згодом розвинена в Ruby. Її ідея універсального вкладення (майже кожна конструкція в Scala може бути вкладена в любу іншу конструкцію) також присутня в Algol, Simula, та, останнім часом, в Beta та gbeta. Її принцип одноманітного досупу для викликів методів та вибору полів прийшов з Eiffel. Її підхід до функціонального програмування досить подібне по духу до свмейства мов ML, що включає SML, OCaml, та F# в якості помітних членів. Багато функцій вищого порядку в стандартній бібліотеці Scala, також присутні в ML або Haskell. Неявні параметри Scala&nbsp; були мотивовані класами типів Haskell; вони досягають аналогічних результатів в більш класичному, об'єктно-орієнтовному налаштуванні. Бібліотека базованої на акторах конкурентності Scala значною мірою надихалась Erlang.</p><p>Scala не є першою мовою, що робить наголос на маштабованості та розширюваності. Історичні корені розширюваних мов, що можуть перекривати різні області застосувань, є папір від Peter Landin 1966 "Наступні 700 мов програмування". (Мова, що описана в цьому документі, Iswim, стоїть разом з Lisp, як один з новаторських функціональних мов). Специфічну ідею трактувати інфіксні оператори, як функції, можна відслідити до Iswim та Smalltalk.</p><p>Інша важлива ідея є дозволити використання функціонального літерала (або блока) як параметра, що дозволяє бібліотекам визначати структури керування. Знову, це веде до Iswim та Smalltalk. Smalltalk та Lisp, обоє мали гнучкий синтаксис, що був екстенсивно застосований для побудови внутрішніх домен-специфічних мов.&nbsp; C++ є іншою мовою програмування, що може бути адаптований та розширений через перевантаження операторів, та систему шаблонів; порівняно з Scala вона побудована на низькорівневому, більш системно-орієнтованому ядрі.</p><p>Scala також не є першою мовою, що інтегрує функціональне та об'єктно-орієнтоване програмування, хоча вона, можливо, іде далі в цьому напрямку. Інші мови, що що інтегрували деякі елементи функціонального програмування в ООП включають Ruby, Smalltalk та Python. На платформі Java мови Pizza, Nice та Multi-Java розширюють Java-подібне ядро функціональними ідеями. Також є в основному функціональні мови, що отримали систему об'єктів; прикладами є OCaml, F# та PLT-Scheme.</p><p>Scala також докала деяких інновацій до області мов програмування. Наприклад, її абстрактні типи провадять більш об'єктно-орієнтовану альтернативу до загальних типів (дженеріків), її трейти дозволяють гнучке складання компонентів, та її екстрактори провадять незалежний від репрезентації шлях до співпадіння шаблонів. Ці інновації були представлені останніми роками в паперах на конференціях з мов програмування.</p><h3>1.5&nbsp; Висновок</h3><p>В цій главі ми надали вам побіжне враження, що таке Scala, та як вона може допомогти вам в вашому програмуванні. Будьте певні, що Scala не є срібною кулею, що магічним чином зробить вас більш продуктивним. Щоб просуватись, вам треба застосовувати <br>Scala мистецьки, та це потребуватиме деякого навчання та практики. Якщо ви прийшли до Scala з Java, найбільш складні аспекти вивчення Scala можуть включати систему типів Scala (що багатша, ніж в Java), та її підтримка функціонального програмування. Ціль цієї книги є лагідно провести вас по кривій засвоєння Scala, крок за кроком. Ми вважаємо, що ви отримаєте винагороду в вигляді інтелектуального досвіду, що розширисть ваші горизонти, то змусить вас думати інакше щодо розробки програм. На щастя, ви також отримаєте задоволення та натхнення від програмування на Scala. </p><p>В наступній главі ми з вами почнемо писати деякий код Scala.</p><h3>Глава 2</h3><h2>Перші кроки в Scala</h2><p>Прийшов час написати деякий код на Scala.Перед тим, як ми розпочнемо глибинне вивчення Scala, ми покладемо дві глави, що дадуть вам ширшу картину Scala, та, що більше важливо, почнемо писати код. Ми закликаємо вас насправді спробувати всі приклади кода, представлені в цій та наступній главах, по мірі просування. Кращий спосіб почати вивчати Scala - це програмувати на ній. </p><p>Щоб виконувати приклади, ви маєте встановити стандартну інсталяцію Scala. Щоб отримати її, завітайте на http://www.scala-lang.org/downloads, та слідуйте настановам для вашої платформи. Ви також можете використовувати плагін Scala для Eclipse, IntelliJ, або NetBeans, але для кроків в цій главі ми вважаємо, що ви використовуєте дистрибутив Scala зі scala-lang.org.</p><p>Якщо ви ветеран програмування, новий до Scala, наступні дві глави повинні дати вам досить розуміння, щоб ви змогли почати писати корисні програми на Scala. Якщо ви менш досвідчений, деякий з матеріала може здатись вам незбагненним. Але не турбуйтесь. Щоб ви швидко набрали швидкість, ми опустимо деякі деталі. Все буде пояснено в менш "пожежному" режимі в подальших главах. На додаток, ми вставили в наступні дві глави деякі примітки, щоб спрямувати вас на подальші розділи книги, де ви знайдете більш детальні пояснення.</p><h4>Крок 1. Навчимось використовувати інтерпретатор Scala</h4><p>Найлегший шлях почати зі Scala - це використати інтерпретатор Scala, інтерактивну "оболонку" для написання виразів та програм Scala. Просто наберіть вираз в інтерпретаторі, та він обчислить вираз та надрукує результуюче значення. Інтерактивна оболонка для Scala називається просто scala.</p><p>Ви можете використати її, набравши scala в командному рядку:</p>
<pre class="prettyprint linenums language-bash">$ scala
Welcome to Scala version 2.8.1.
Type in expressions to have them evaluated.
Type :help for more information.
scala&gt;</pre>
<p>Після цього надрукуйте вираз, такий, як 1 + 2, та нажміть Enter:</p>
<pre class="prettyprint linenums language-scala">scala&gt; 1 + 2</pre>
<p>The interpreter will print:</p>
<pre class="prettyprint linenums language-scala">res0: Int = 3</pre>
<p>Цей рядок включає:<br>• автоматично згенероване, або визначене користувачем ім'я, що посилається на обчислене значення (res0, що означає result 0),<br>• двокрапку (:), за якою слідує тип виразу (Int),<br>• Знак рівняння (=),<br>• значення результата від обчислення виразу (3).</p><p>Тип Int іменує клас Int в пакунку scala. Пакунки в Scala подібні до пакунків в Java: вони розділяють глобальний простір імен, та провадять механізм для приховуванні інформації. Значення класу Int відповідають значенням Java int. Більш загально, всі з примітивних типів Java мають відповідні класи в пакунку scala. Наприклад, scala.Boolean відповідає до Java boolean. scala.Float відповідає Java float. Та коли ви компілюєте ваш код Scala в байткоди Java, компілятор Scala буде використовувати примітивні типи Java, де це можливо, щоб надати вам переваги швидкості примітивних типів.</p><p>Ідентифікатор resX може використовуватись в наступних рядках. Наприклад, оскільки&nbsp; res0 було попередньо встановлено в&nbsp; 3, res0 * 3 буде 9:</p>
<pre class="prettyprint linenums language-scala">scala&gt; res0 * 3
res1: Int = 9</pre>
<p>Щоб надрукувати необхідне, але недостатнє Hello, world! greeting, надрукуйте:
</p><pre class="prettyprint linenums language-scala">scala&gt; println("Hello, world!")
Hello, world!</pre>Функція println друкує переданий рядок на стандартний вивід, подібно до&nbsp; System.out.println в Java.<br><br><h4>Крок 2. Визначимо деякі змінні</h4>Scala має два типи змінних, val та vars. val подібне до final змінних в Java. Після ініціалізації val не може бути повторно присвоєна. На відміну від цього, var подібна до не-final змінної в Java. var може бути повторно присвоєна на протяжі життєвого циклу. Ось визначення val:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val msg = "Hello, world!"
msg: java.lang.String = Hello, world!</pre>
Це твердження вводить msg як ім'я для рядка "Hello, world!". Типом msg є java.lang.String, оскільки рядки Scala ралізовані через Java String. Якщо ви декларували змінні в Java, ви помітили тут одну вражаючу відмінність: ні java.lang.String, ні String не з'являються ніде в визначенні val. Цей приклад ілюструє вивод типу, здатність Scala визначає типи, що ви не  вказали. І цьому випадку, оскільки ви ініціалізували msg літералом рядка, Scala виводить, що тип msg буде String. Коли інтерпретатор Scala (або компілятор) може вивести типи, часто краще дозволити йому зробити це, скоріше, ніж заповнювати код непотрібними явними анотаціями типу. Однак ви можете вказати тип явно, якщо бажаєте, та індоі ви, можливо, маєте це зробити. Явна анотація типу може як переконати компілятор Scala вивести потрібний вам тип, та також прислуговується як корисна документація для майбутніх читачів кода. На відміну від Java, де ви вказуєте тип змінної перед ім'ям, в Scala ви вказуєте тип змінної після імені, відокреплюючи двома крапками. Наприклад:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val msg2: java.lang.String = "Hello again, world!"
msg2: java.lang.String = Hello again, world!</pre>
Або, оскільки типи java.lang видімий зі своїми простими іменами в програмах Scala, просто:<br>
<pre class="prettyprint linenums language-scala">scala&gt; val msg3: String = "Hello yet again, world!"
msg3: String = Hello yet again, world!</pre>
Повертаючись до оригінального msg, тепер, коли вона визначена, ви можете використовувати її, як і очікували, наприклад:<br>
<pre class="prettyprint linenums language-scala">scala&gt; println(msg)
Hello, world!</pre>
Що ви не можете робити з msg, зважаючи що це val, а не var, це переприсвоїти її. Наприклад, подивіться, як буде скаржитись інтерпретатор, коли ви спробуєте наступне:<br>
<pre class="prettyprint linenums language-scala">scala&gt; msg = "Goodbye cruel world!"
:6: error: reassignment to val
msg = "Goodbye cruel world!</pre>ˆ
<br>Якщо перепризначення це те, що вам потрібне, вам треба var, як нижче:<br>
<pre class="prettyprint linenums language-scala">scala&gt; var greeting = "Hello, world!"
greeting: java.lang.String = Hello, world!</pre>
<br>Оскільки greeting є var, не val, ви можете переприсвоїти її пізніше. Якщо ви пізніше почуватиметесь буркотливим, наприклад, ви можете змінити ваше побажання світові:<br>
<pre class="prettyprint linenums language-scala">scala&gt; greeting = "Leave me alone, world!"
greeting: java.lang.String = Leave me alone, world!</pre>
<br>Щоб ввести дещо в інтерпретатор, що обіймає декілька рядків, просто продовжуйте набирати після першого рядка. Якщо код, що ви набрали до цього, ще не завершений, інтерпретатор буде відповідати вертикальним стовпчиком на наступному рядку.
<pre class="prettyprint linenums language-scala">scala&gt; val multiLine =
      | "This is the next line."
multiLine: java.lang.String = This is the next line.</pre>
<p>Якщо ви зрозумієте, що ви використали тип невірно, але інтерпретаор все ще очікує додаткового вводу, ви можете вийти, двічи нажавши enter:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oops =
   |
   |
You typed two blank lines.&nbsp;Starting a new command.
scala&gt;</pre>В решті цієї книги, ми відкидатимо вертикальні риски, щоб зробити код простішим для читання (та простішим для копіювання та вставки з електронної книги PDF eBook в інтерпретатор).<h4>Крок 3. Визначимо деякі функції</h4><p>Тепер, коли ми попрацювали зі змінними Scala, ви, можливо, бажаєте написати деякі функції. Ось як ви робите це в Scala:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def max(x: Int, y: Int): Int = {
  if (x &gt; y) x
  else y
  }
max: (x: Int,y: Int)Int</pre>
<p>Визначення функції починається з def, далі ім'я функції, в цьому випадку max, за яким іде розділений комами список параметрів в дужках. Кожний параметр функції має включати анотацію типу через дві крапки, оскільки компілятор Scala (та інтерпретатор, але від тепер ми казатимо тільки про компілятор) не виводить типи переметрів функції. В цьому прикладі функція з ім'ям max приймає два параметри, x та y, обоє типу Int. Після закриття дужок за списком параметрів max, ви знайдете іншу анотацію типу ": Int". Це визначає тип результата самої функції max. </p>
<pre class="prettyprint linenums language-scala">“def” починає визначення функції
 |  ім'я функції
 |   |  список параметрів в дужках
 |   |   |              тип результата функції
 |   |   |               |  знак рівності
 |   |   |               |   | тіло функції в фігурних дужках<br> |   |   |               |   |  |<br><br>def max(x: Int, y: Int): Int = {
  if (x &gt; y)
    x
  else
    y
}</pre>
<p>Малюнок 2.1 · Базова форма визначення функції в Scala.</p><p><br>Після типу результату функції іде знак рівності та пара фігурних дужок, що містять тіло функції. В цьому випадку тіло містить єдиний вираз if, що обирає x або y, більший з двох, в якості результата функції max. Як тут продемонстровано, вираз if в Scala може мати знечення результата, подібно до тернарного оператора Java. Наприклад, вираз Scala<br>"if (x &gt; y) x else y"&nbsp; поводиться подібно до "(x &gt; y) ? x : y" в Java. Знак рівності, що передує тілу функції, дає підказку, що, з точки зору функціонального світу, функція визначає вираз, що має закінчується значенням. Базова структура функції проілюстрована на Малюнку 2.1.</p>
<p>Іноді компілятор Scala буде потребувати, щоб ви вказали тип результату функції. Наприклад, якщо функція рекурсивна (викликає сама себе), ви мусите явно вказати тип результату функції. Однак в випадку max, ви можете відкинути тип результата, та компілятор виведе його. Також, якщо функція складається тільки з одного твердження, ви можете опіціонально відкинути фігурні дужки. Таким чином, ви можете альтернативно записати функцію max таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def max2(x: Int, y: Int) = if (x &gt; y) x else y
max2: (x: Int,y: Int)Int</pre>
<p>Коил ви визначили функцію, ви можете викликати її по імені, ось так:</p>
<pre class="prettyprint linenums language-scala">scala&gt; max(3, 5)<br>res4: Int = 5</pre>
<p>Ось визначення функції, що не приймає жодних параметрів, та не повертає ніякого цікавого результата:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def greet() = println("Hello, world!")
greet: ()Unit</pre>
<p>Коли ви визначаєте функцію greet(), інтерпретатор відповість<br>greet: ()Unit, де "greet" це, звичайно, ім'я функції. Пусті дужки вказують, що функція не сприймає параметрів. Та Unit є типом результата greet. Тип результата Unit вказує, що функція не повертає цікавого значення. Тип Scala Unit подібний до типу Java void, та, фактично, кожний метод, що повертає void в Java відзеркалюється на метод, що повертає Unit в Scala. Методи з типом результата Unit, таким чином, виконуються тільки заради побічних ефектів. В випадку greet(), побічний ефект є друк дружнього привітання на стандиртний вивід.</p><p>В наступному кроці, ви покладете код Scala в файл, та виконаєте його як скрипт. Якщо ви бажаєте вийти з інтерпретатора, ви можете зробити це, або ввівши:quit або :q.</p>
<pre class="prettyprint linenums language-scala">scala&gt;$<br>:quit</pre>
<h4>Крок 4. Напишемо деякі Scala скрипти</h4><p>Хоча Scala розроблена щоб допомогти програмістам будувати велико-маштабні системи, вона також гарно маштабується донизу, до скриптингу. Скрипт - це просто послідовність тверджень в файлі, що будуть виконуватись послідовно. Покладіть його в файл hello.scala:</p>
<pre class="prettyprint linenums language-scala">println("Hello, world, from a script!")</pre>
<p>потім виконайте:</p>
<pre class="prettyprint linenums language-scala">$ scala hello.scala</pre>
<p>Та ви отримаєте ще одне привітання:</p>
<pre class="prettyprint linenums language-scala">Hello, world, from a script!</pre>
<p>Аргументи командного рядка до скрипта Scala доступні через масив Scala на ім'я args. В Scala масиси починаються з нуля, та ви отримуєте доступ до елемента, вказуючи індекс в дужках. Так що перший елемент в масиві Scala на ім'я steps є steps(0), не steps[0], як в Java. Щоб спросувати це, неберіть наступне в новому файлі на ім'я helloarg.scala:</p>
<pre class="prettyprint linenums language-scala">// Скажіть hello першому аргументу<br>println("Hello, "+ args(0) +"!")</pre>
<p>потім виконайте:</p>
<pre class="prettyprint linenums language-scala">$ scala helloarg.scala planet</pre>В цій команді "planet" передається як аргумент командного рядка, що доступний в скрипті як args(0). Таким чином ви маєте побачити:
<pre class="prettyprint linenums language-scala">Hello, planet!</pre>
<p>Зауважте, що цей скрипт включає коментар. Компілятор Scala буде ігнорувати символи між // та наступним кінцем рядка, та всі символи між <br>/* та */. Цей приклад також показує Strings, конкатеновані за допомогою оператора +. Це робить як ви очікуєте. Вираз "Hello, "+"world!" завершиться рядком "Hello, world!".</p><p>Крок 5. Цикли while; рішення з if</p><p>Щоб спробувати while, наберіть наступне в файлі printargs.scala:</p>
<pre class="prettyprint linenums language-scala">var i = 0
while (i &lt; args.length) {<br>  println(args(i))
  i += 1
}</pre>
<h4>Зауваження. </h4><p>Хоча приклади в цьому розділі допомагають пояснити деякі цикли, вони не демонструють кращий стиль Scala. В наступному розділі ми побачимо кращі підходи, що уникають ітерації по масивам за допомогою індексів.</p><p>Цей скрипт стартує з визначення змінної, var i = 0. Вивід типу надає i тип scala.Int, оскільки це тип її початкового значення, 0. Конструкція while в наступному рядку спричиняє що блок (код між фігурними дужками) буде повторно виконуватись, доки логічний вираз i &lt; args.length буде фальшивим. args.length дає довжину масива args. Блок містить два твердження, кожний зсунутий на два проміжки, рекомендований стиль відступів для Scala. Перше твердження, println(args(i)), друкує i-й аргумент комадного рядка. Друге твердження, i += 1, інкрементує i на один. Зауважте, що Java ++i та i++ не роблять в Scala. Щоб інкрементувати в Scala, вам треба сказати або i = i + 1, або i += 1. Виконайте цей скрипт за допомогою наступної команди:</p>
<pre class="prettyprint linenums language-scala">$ scala printargs.scala Scala is fun</pre>
<p>Ви маєте побачити таке:</p>
<pre class="prettyprint linenums language-scala">Scala
is
fun</pre>Для ще більшої розваги наберіть наступний код в новий файл на ім'я echoargs.scala:<br>
<pre class="prettyprint linenums language-scala">var i = 0
while (i &lt; args.length) {
  if (i != 0)
    print(" ")
  print(args(i))
  i += 1
}
println()
</pre>
<p>І цій версії ви замінили виклик println на виклик call, так що всі аргументи будуть надруковані в одному рядку. Щоб зробити це читабельним ви вставили промідок перед кожним аргументом, за винятком першого, через конструкцію if (i != 0). Оскільки i != 0 буде false для першого оберту циклу while, проміжок не надрукується перед першим аргументом. В кінці ми додаємо ще один println, щоб отримати новий рядок після друку всіх аргументів. Ваш вивід буде дійсно дуже красивим. Якщо ви виконаєте цей скрипт за допомогою наступної команди:</p>
<pre class="prettyprint linenums language-scala">$ scala echoargs.scala Scala is even more fun</pre>
<p>Ви отримаєте:</p>
<pre class="prettyprint linenums language-scala">Scala is even more fun</pre>
<p>Зауважте, що в Scala, як і в Java, ви мусите покладати логічниі вирази для while або if в дужки. (Іншими словами, ви не можете сказати в Scala речі, як if i &lt; 10, як ви можете зробити в таких мовах, як Ruby. Ви мусите казати if (i &lt; 10) в Scala). Інша подібність до Java в тому, що якщо блок if має тільки одне твердження, ви можете опціонально відкинути фігурні дужки, як це демонструється в твердженні if в echoargs.scala. Та хоча ви не бачите жодних з них, Scala використовує крапку з комою для розділення тверджень, як в Java, за тим виключенням, що в Scala крапки з комою дуже часто опціональні, що надає полегшенню вашому правому мізинцю. Одже, якщо ви в дещо більш балакучому настрої, ви можете записати скрипт echoargs.scala наступним чином:</p>
<pre class="prettyprint linenums language-scala">var i = 0;
while (i &lt; args.length) {
  if (i != 0) {
    print(" ");
  }
  print(args(i));
  i += 1;
}
println();</pre>
<h4>Крок 6. Ітерація за допомогою foreach та for</h4><p>Хоча ви можете ще не розуміти цього, коли ви пишете цикл while на попередньому кроці, ви програмуєте в імперативному стилі. В імперативному стилі, що є стилем, який ви використовуєте в мовах як Java, C++ та C, ви отримуєте одну імперативну команду за раз, ітеруєте за допомогою циклів, та часто змінюєте стан, що розподілений між різними функціями. Scala дозволяє вам програмувати імперативно, але коли ви краще пізнаєте Scala, ви, вірогідно, винайдете, що почали програмувати в більш функціональному стилі. Фактично, однією з головних цілей цієї книги є допомогти вам стати настільки ж комфортабельним з функціональним стилем, як і з імперативним стилем.</p><p>Однією з головних характеристик функціональної мови є те, що функції є першокласними конструкціями, і це дуже вірно в Scala. Наприклад, інший, <br>(значно більш стислий) шлях надрукувати аргумент командного рядка, є:</p>
<pre class="prettyprint linenums language-scala">args.foreach(arg =&gt; println(arg))</pre>
<p>В цьому коді ви викликаєте метод foreach на args, та передаєте результат в фукнцію. В цьому випадку ви передаєте в функцію літерал, що приймає один аргумент на ім'я arg. Тіло функції є println(arg). Якщо ви наберете код вище в новому файлі на ім'я pa.scala, та виконаєте його за допомогою команди:</p>
<pre class="prettyprint linenums language-scala">$ scala pa.scala Concise is nice</pre>
<p>Ви побачите:</p>
<pre class="prettyprint linenums language-scala">Concise
is
nice</pre>
<p>В попередньому прикладі інтерпретатор Scala виводить тип arg як String, оскільки String є типом елементів масива, на якому ви викликаєте foreach. Якщо ви схильні бути більш явним, ви можете вказати ім'я типу, але тоді там треба огорнути артументи в дужки (що в жодному разі є нормальною формою синтаксиса):</p>
<pre class="prettyprint linenums language-scala">args.foreach((arg: String) =&gt; println(arg))</pre>Виконання цього скрипта має ту ж поведінку, що і попереднього. Якщо ви в настрої для більшої стислості, замість більшої відкритості, ви можете отримати вигоду спеціального скорочення в Scala. Якщо функціональний літерал складається з одного твердження, що приймає один аргумент, вам не треба явно називати та вказувати цей аргумент. Таким чином, наступний код також буде робити:<br>
<pre class="prettyprint linenums language-scala">args.foreach(println)</pre>
<p>параметри функції в дужках</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; стрілка<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; тіло функції<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>(x: Int, y: Int) =&gt; x + y</p><p>Малюнок 2.2 Синтаксис функціонального літерала в Scala.</p><p>Щоб підсумувати, синтаксис для функціонального літерала є списком поіменованих параметрів в дужках, права стрілка, та потім тіло функції. Цей синтаксис проілюстрована на Малюнку 2.2.</p><p>Тепер, в цій точці, ви можете здивуватись, що відбувається з тіма випробовуваними циклами for, що ви звикли використовувати в імперативних мовах, як Java або C. В спробі вести вас в фукнціональному напрямку, в Scala існує тільки функціональних родич імперативного for (що називається for виразом). Ви не побачите його повну потужність та виразність, доки не дійдете (або не перестрибнете) до Розділу 7.3, але ми дамо вам можливість поглянути вже тут. В новому файлі з назвою forargs.scala, наберіть наступне:</p>
<pre class="prettyprint linenums language-scala">for (arg &lt;- args)
  println(arg)</pre>
<p>Дужки після "for" містять arg &lt;- args. Зправа до символа &lt;- є знайомий масив args. Зліва від &lt;- стоїть “arg”, ім'я val, не var. (Оскільки це завжди val, ви просто пишете поодиноке "arg", не "val arg".) Хоча arg може виглядати як var, тому що вона отримуватиме нове значення на кожній ітерації, насправді це val: arg не може бути переприсвоєна в тілі for виразу. Замість цього, для кожного елементу масива args буде створена нова arg val, та ініціалізована значенням елемента, після чого буде виконане тіло for.</p><p>Якщо ви виконаєте скрипт forargs.scala за допомогою команди:</p>
<pre class="prettyprint linenums language-scala">$ scala forargs.scala for arg in args</pre>
<p>Ви побачите:
</p><pre class="prettyprint linenums language-scala">for
arg
in
args</pre>For вирази Scala можуть робити значно більше від цього, але цей приклад є достатнім для початку. Ми покажемо більше щодо for в Розділі 7.3 та Главі 23.<br><h3>Висновок</h3><p>В цій главі ви навчились деяким основам Scal, та, маємо надію, отримали перевагу від написання деякого кода Scala. В наступній главі ми продовжимо цей вступний огляд, та розглянемо більш просунуті теми.&nbsp;</p><h3>Глава 3</h3><h2>Наступні кроки в Scala</h2><p>Ця глава продовжує попередні вступ до Scala в попередніх главах. В цій главі ви введемо деякі більш просунуті можливості. Коли ви завершите цю главу, ви матемите досить знань, що дозволять вам почати писати корисні скрипти на Scala. Як і в попередній главі, ми рекомендуємо вам перевіряти приклади по мірі просування. Кращий шлях отримати відчуття Scala є почати писати код на Scala.</p><h4>Крок 7. Параметризація масивів за допомогою типів</h4><p>В Scala ви можете створювати об'єкти, або примірники класів, використовуючи new. Коли ви створюєте об'єкт в Scala, ви можете параметризувати його значеннями та типами. Параметризація означає "конфігурацію" примірника, коли ви створюєте його. Ви параметризуєте примірник за допомогою значень, що передаються об'єктам в конструктор в дужках. Наприклад, наступний код Scala створює примірник нового java.math.BigInteger, та параметризує його значенням "12345":</p>
<pre class="prettyprint linenums language-scala">val big = new java.math.BigInteger("12345")</pre>
<p>Ви параметризуєте примірник типом, через вказання одного або більше типів в квадратних дужках. Приклад показаний в Лістингу 3.1. В цьому прикладі greetStrings є значення типу Array[String] ("масив рядків"), що ініціалізований довжиною 3, що параметризує його в першому рядку кода значенням 3. Якщо ви виконаєте код з Лістингу 3.1 як скрипт, ви побачите інше привітання <br>Hello, world!. Зауважте, що ви параметризуєте примірник обоє, типом та значенням, тип іде першим в квадратних дужках, за чим слідує значення в дужках.</p>
<pre class="prettyprint linenums language-scala">val greetStrings = new Array[String](3)
greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"
for (i &lt;- 0 to 2)
  print(greetStrings(i))</pre>
<p>Лістинг 3.1 Параметризація масива типом.</p><h4><span style="font-weight: bold;">Зауваження<br></span></h4><p><span
style="font-weight: bold;"></span>Хоча код в Лістингу 3.1 демонструє важливі концепції, він не показує рекомендованих спосіб створювати та ініціалізувати масиви в Scala. Ви побачите кращий спосіб в Лістингу 3.2.</p><p>Якщо ви в дещо більш явному настрої, ви можете явно вказати тип greetStrings наступним чином:</p>
 <pre class="prettyprint linenums language-scala">val greetStrings: Array[String] = new Array[String](3)</pre>
 <p>Маючи вивід типів Scala, цей рядок кода семантично еквівалентний до справді першого рядка Лістингу 3.1. Але ця форма демонструє, що хоча чистина параметризації типу (імена типів в квадратних дужках) формує частину типу примірника, частина параметризації значення (значення в дужках) - ні. Тип greetStrings є Array[String], та не Array[String](3).</p><p>Наступні три рядка коду в Лістингу 3.1 ініціалізують кожний елемент масива <br>greetStrings:</p>
 <pre class="prettyprint linenums language-scala">greetStrings(0) = "Hello"
greetStrings(1) = ", "
greetStrings(2) = "world!\n"</pre>
 <p>Як ми вже зазначали, масиви в Scala отримують доступ, розміщуючи індекс в дужки, не в квадратні дужки, як в Java. Таким чином, нульовий елемент масива є greetStrings(0), не greetStrings[0].</p><p>Ці три рядка кода ілюструють важливу для розуміння концепцію щодо розуміння Scala значення val. Коли ви визначаєте змінну за допомогою val, змінна не може бути перепризначена, але об'єкт, на який вона посилається, потенційно все ще може бути змінений. Так що в цьому випадку ви не можете переприсвоїти greetStrings до іншого масиву; greetStrings буде завжди посилатись на той же примірник Array[String], яким він був ініціалізований. Але ви можете з часом змінювати елементи цього Array[String], так що сам масив є змінним.</p><p>Два заключні рядки Лістингу 3.1 містять вираз for, що друкує кожний елемент масиву greetStrings по порядку:</p>
 <pre class="prettyprint linenums language-scala">for (i &lt;- 0 to 2)
  print(greetStrings(i))</pre>
 <p>Перший рядок кода і цьому виразі ілюструє інше головне правило Scala: якщо метод приймає тільки один параметр, ви можете викликати його без крапки та дужок. Метод to в цьому прикладі насправді є методом, що приймає один аргумент Int. Код 0 to 2 перетворюється в виклик метода (0).to(2).1 Зауважте, що цей синтаксис робить тільки якщо ви вказали отримувача виклику метода. Ви не можете записати "println 10", але ви можете записати "Console println 10".</p><p>Scala технічно не має перевантаження операторів, оскільки вона не має операторів в традиційному сенсі. Замість цього такі символи, як +, -, *, та / можуть використовуватись як імена методів. Таким чином, коли ви друкуєте 1 + 2 в інтерпретаторі Scala на Кроці 1, ви насправді викликали метод з ім'ям + на Int об'єкті 1, передавши йому 2 в якості параметра. Як проілюстровано на Малюнку 3.1, ви можете альтернативно записати 1 + 2, використовуючи традиційний синтаксис виклику метода, (1).+(2).</p><p>Інша важлива ідея, проілюстрована в цьому прикладі, надасть вам погляд на те, чому доступ до масивів в Scala виконується за допомогою дужок. Scala має меньше особливих випадків, ніж Java. Масиви є просто примірниками класів, як любі ішні класи в Scala. Коли ви застосовуєте дужки, що оточують одне або більше значень до змінної, Scala перетворить код в виклик метода, що називається apply, до цієї змінної. Так що greetStrings(i) буде трансформовано в greetStrings.apply(i). Таким чином, доступ до елементів в масиві Scala є простим викликом метода, як любого іншого. Це принцип не обмежується масивами: любе застосування якого об'єкту до деяких аргументів в дужках буде трансформовано в виклик метода apply. Звичайно, це буде компілюватись, тільки якщо цей тип об'єкту дійсно визначає метод apply. Так що це не спеціальний випадок, а загальне правило.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1&nbsp;&nbsp; +&nbsp;&nbsp;&nbsp; 2</p><p>Об'єкт Int зі значенням 1 &nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; на 1 викликається метод ‘+’<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; якому передається параметр Int 2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (1).+(2)</p><p>Малюнок 3.1 В Scala всі оператори є викликами методів.</p><p>Подібно до цього, коли виконується присвоєння до змінної, до якої застосовуються дужки, та один або більше аргументів, компілятор трансформує це в виклик метода update, що приймає аргументи в дужках, а також об'єкт зправа від знаку присвоєння. Наприклад:</p>
 <pre class="prettyprint linenums language-scala">greetStrings(0) = "Hello"</pre>
 <p>буде трансформоване в:</p>
 <pre class="prettyprint linenums language-scala">greetStrings.update(0, "Hello")</pre>
 <p>Таким чином, наступне буде семантичним еквівалентом кода Лістинга 3.1:</p>
 <pre class="prettyprint linenums language-scala">val greetStrings = new Array[String](3)
 greetStrings.update(0, "Hello")
 greetStrings.update(1, ", ")
 greetStrings.update(2, "world!\n")
 for (i &lt;- 0.to(2))
   print(greetStrings.apply(i))</pre>
   <p>Scala досягає концептуальної простоти, розглядаючи все, від масивів до виразів, як об'єкти з методами. Вам не треба запам'ятовувати особливі випадки, такі як відмінності в Java між примітивами, та їх відповідними огортками, або між масивами та регулярними об'єктами. Більше того, ця одноманітність на стає в помітну ціну. Компілятор Scala використовує масиви Java, примітивні типи та природну арифметику, коли це можливе, в скомпільованому коді.</p><p>Хоча приклади, що ви бачили до тепер на цьому кроці, компілюються та виконуються досить гарно, Scala провадить більш стислий шлях створювати та ініціалізувати масиви, що ви будете зазвичй використовувати. Це виглядає як в Лістингу 3.2. Цей код створює новий масив довжиною три, та ініціалізує його переданими рядками, "zero", "one" та "two". Компілятор виводить тип масива як Array[String], оскільки ви передали йому рядки.</p>
   <pre class="prettyprint linenums language-scala">val numNames = Array("zero", "one", "two")</pre>
   <p>Лістинг 3.2 Створення та ініціалізація масива.</p><p>Що ви насправді робите в Лістингу 3.2, це виклик метода-фабрики, що називається apply, що створює та повертає новий масив. Цей метод apply приймає змінне число аргументів, та визначений на об'єкті-компанйоні Array. Ви пізнаєте більше про об'єкти-компанйони в Розділі 4.3. Якщо ви програміст на Java, ви можете думати про це як про виклик статичного метода з іменем apply на класі Array. Більш галасливий шлях викликати той же метод apply є наступним:</p>
   <pre class="prettyprint linenums language-scala">val numNames2 = Array.apply("zero", "one", "two")</pre>
   <h4>Крок 8. Використання списків</h4><p>Одна з великих ідей функціонального стилю програмування полягає в тому, що методи не повинні мати побічних ефектів. Єдиною дією повинне бути обчислення та повернення значення. Деякі вигоди, отримані при прийнятті цього підоходу, є те, що методи стають менш заплутані, та, таким чином, більш надійними та використовуваними. Інша вигода (в статично типізованій мові) є та, що все, що іде в, та з, метода, перевіряється контролем типу, так що логічні помилки більш вірогідно проявлять себе, як помилки типу. Застосовуючи цю функціональну філософію до світу об'єктів означає зробити об'єкти незмінними.</p><p>Як ви бачили, масиви Scala є змінними послідовостями об'єктів, що всі поділяють один тип. Наприклад, Array[String] містить тільки рядки. Хоча ви не можете змінити довжину масива, після того, як він був створений, ви можете змінити значення його елементів. Таким чином, масиви є змінними об'єктами.</p><p>Для незмінної послідовності об'єктів, що розділяють один тип, ви можете використовувати клас Scala List. Як і з масивами, List[String] містить тільки рядки. В Scala List, scala.List, відрізняється від типу java.util.List, в тій частині, що Scala List завжди незмінні (тоді як Java List може бути змінені). Більш загально, Scala List розроблений щоб дозволити функціональний стиль програмування. Створення списку просте. Лістинг 3.3 показує, як:<br>
</p><pre class="prettyprint linenums language-scala">val oneTwoThree = List(1, 2, 3)</pre>
<p>Лістинг 3.3 Створення та ініціалізація списка.</p><p>Код в Лістингу 3.3 встановлює нову val&nbsp; на ім'я oneTwoThree, ініціалізованою за допомогою new List[Int] з числовими елементами 1, 2 та 3. Оскільки списки Lists незмінні, вони поводяться трохи подібно до рядків Java: коли ви викликаєте метод на списку, що, згідно з ім'ям, виглядає як такий, що мав би змінювати список, він, замість цього, повертає нове значення. Наприклад, List має метод на ім'я ':::' для конкатенації списків. Ось як ви використовуєте його:</p>
<pre class="prettyprint linenums language-scala">val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
println(oneTwo +" and "+ threeFour +" were not mutated.")
println("Thus, "+ oneTwoThreeFour +" is a new list.")</pre>
<p>Якщо ви виконаєте цей список, ви побачите: </p>
<pre class="prettyprint linenums language-scala">List(1, 2) and List(3, 4) were not mutated.
Thus, List(1, 2, 3, 4) is a new list.</pre>
<p>Можливо, найбільш загальним оператором, що ви будете використовувати зі списками, є ‘::’, що вимовляється як "cons". Cons ствить новий елемент в початок існуючого списку, та повертає отриманий список. Наприклад, якщо ви виконаєте цей скрипт:</p>
<pre class="prettyprint linenums language-scala">val twoThree = List(2, 3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)</pre>
<p>Ви побачите:</p>
<pre class="prettyprint linenums language-scala">List(1, 2, 3)</pre>
<h4>Зауваження</h4><p>В виразі "1 :: twoThree", :: є методом свого правого операнда, списка twoThree. Ви можете запідозрити, що щось негарне з асоциативністю метода ::, але насправді це просте правило, що легко запам'ятати: якщо метод використовується в нотації оператора, такій, як a * b, метод викликається на лівому операнді, як в a.*(b) — за винятком, коли метод закінчується на дві крапки. Якщо це так, метод викликається на правому операнді. Таким чином, в 1 :: twoThree, метод :: викликається для twoThree, передаючи 1: </p>
<pre class="prettyprint linenums language-scala">twoThree.::(1).</pre>
<p>Асоциативність операторів буде описана більш детально в Розділі 5.8.</p><p>Зважаючи, що скорочений спосіб для вказання пустого списку є Nil, одним шляхом для ініціалізації нових списків є рядок елементів з оператором cons, та з Nil в якості останнього елемента. Наприклад, наступний скрипт буде продукувати той ж вивід, що і попередній, "List(1, 2, 3)":</p>
<pre class="prettyprint linenums language-scala">val oneTwoThree = 1 :: 2 :: 3 :: Nil
println(oneTwoThree)</pre>
<p>Scala List оздоблений корисними методвами, багато з яких перелічені в Таблиці 3.1. Повна потужність списків буде розкритою в Главі 16.</p><p><span
style="font-weight: bold;">Чому ми не додаємо до списків?</span><br>Клас List надає операцію "append" — вона записується як :+ та пояснюється в Главі 24 — але ця операція рідко використовується, оскільки час, що займає додавання до списку, зростає лінійно з розміром списку, тоді як додавання зпереду :: займає сталий час. Вашими опціями, якщо бажаєте побудувати список ефективно додаванням елементів, є ставити їх зпереду, та потім, коли скінчите, виконати реверс; або використовуйте ListBuffer, змінний список, що пропонує операцію додавання, та коли скінчите, виконайте toList. ListBuffer буде описаний в Розділі 22.2.</p><p>Таблиця 3.1 Деякі методи List та їх використання</p><table
style="width: 100%" border="0"><tbody><tr><td><span style="font-weight: bold;">Що це</span></td><td><span
style="font-weight: bold;">Що робить</span></td></tr><tr><td style="width: 269.717px;">List() or Nil</td><td
style="width: 382.25px;">Пустий список</td></tr><tr><td>List("Cool", "tools", "rule")</td><td>Створює новий List[String] з трьох значень, "Cool", "tools" та "rule"</td></tr><tr><td>val thrill = "Will" :: "fill" :: "until" :: Nil</td><td
style="margin-left: -27.7778px;">Створює новий List[String] з трьох елементів "Will", "fill" та "until"</td></tr><tr><td>List("a", "b") ::: List("c", "d")</td><td>Конкатенує два списки (повертає новий List[String] зі значень "a", "b", "c", "d")</td></tr><tr><td>thrill(2)</td><td>Повертає елемент з індексом 2 (від нуля) зі списку thrill ("until")</td></tr><tr><td>thrill.count(s =&gt; s.length == 4)</td><td>Рахує число рядків в thrill з довжиною 4 (повертає 2)</td></tr><tr><td>thrill.drop(2)</td><td>Повертає список thrill без перших двох елементів (List("until"))</td></tr><tr><td>thrill.dropRight(2)</td><td>Повертає список thrill без його двох правих елементів (List("Will"))</td></tr><tr><td>thrill.exists(s =&gt; s == "until")</td><td>Визначає, чи існує в thrill елемент-рядок "until" (true)</td></tr><tr><td>thrill.filter(s =&gt; s.length == 4)</td><td>Повертає список всіх елементів thrill, по порядку, з довжиною 4 (<br>List("Will", "fill"))</td></tr><tr><td>thrill.forall(s =&gt; s.endsWith("l"))</td><td>Вказує, чи всі елементи списка thrill завершуються на літеру "l"<br>(true)</td></tr><tr><td>thrill.foreach(s =&gt; print(s))</td><td>Виконує твердження print для кожного елемента в списку thrill (друкує "Willfilluntil")</td></tr><tr><td>thrill.foreach(print)</td><td>Те саме, але стисліше (друкує "Willfilluntil")</td></tr><tr><td>thrill.head</td><td>Повертає перший елемент в списку thrill ("Will")</td></tr><tr><td>thrill.init</td><td>Повертає список з усіх елементів списку, крім останнього (List("Will", "fill"))</td></tr><tr><td>thrill.isEmpty</td><td>Вказує, чи список thrill є пустим (false) </td></tr><tr><td>thrill.last</td><td>Повертає останній елемент списку thrill ("until")</td></tr><tr><td>thrill.length</td><td>Повертає число елементів в списку (3)</td></tr><tr><td>thrill.map(s =&gt; s + "y")</td><td>Повертає список, що утворений додаванням"y" до кожного елемента-рядка списка thrill (List("Willy", "filly", "untily"))</td></tr><tr><td>thrill.mkString(", ")</td><td>Робить рядок з елементів списку ("Will, fill, until")</td></tr><tr><td>thrill.remove(s =&gt; s.length == 4)</td><td>Повертає список з елементів, по порядку, окрім тих, що мають довжину 4 (List("until"))</td></tr><tr><td>thrill.reverse</td><td>Повертає список з усіх елементів, в зворотньому порядку (List("until", "fill", "Will"))</td></tr><tr><td>thrill.sort((s, t) =&gt; s.charAt(0).toLower &lt; t.charAt(0).toLower)</td><td>Повертає список, що містить всі елементи списку thrill list в алфавітному порядку за першою літерою в нижньому реєстрі (List("fill", "until", "Will"))</td></tr><tr><td>thrill.tail</td><td>Повертає список thrill без першого елемента (List("fill", "until"))</td></tr></tbody></table><h4>Крок 9. Використання кортежів</h4><p>Інший корисний контейнерний об'єкт є кортеж. Як і списки, кортежі незмінні, але на відміну від списків, кортежі можуть містити різні типи елементів. Тоді як список може бути List[Int] або List[String], кортеж може містити обоє, і цілі і рядки, одночасно. Кортежі є дуже корисними, наприклад, якщо ви бажаєте повернути незмінні об'єкти з метода. Тоді як в Java ви повинні часто створити JavaBean-подібний клас, щоб утримувати декілька повернутих значень, в Scala ви можете просто повернути кортеж. Та це просто: щоб створити новий кортеж, що містить декілька об'єктів, просто розмістіть об'єкти в дужках, розділивши їх комами. Коли ви маєте створений примірник кортежу, ви можете отримати доступ до його елементів за допомогою крапки, підкреслення, та базованому на одиниці індексу елементів. Приклад показаний в Лістингу 3.4:</p>
 <pre class="prettyprint linenums language-scala">val pair = (99, "Luftballons")
 println(pair._1)
 println(pair._2)</pre>
 <p>Лістинг 3.4 Створення та використання кортежу.</p><p>В першому рядку Лістингу 3.4, ви створюєте новий кортеж, що містить ціле 99, в якості першого елемента, та рядок "Luftballons", як другий елемент. Scala виводить тип кортежу як Tuple2[Int, String], та дає цей тип також і змінній pair. В другому рядку ви отримуєте доступ до поля _1, що поверне перший елемент, 99. “.” в другому рядку є тою ж крапкою, що ви використовували для доступу до полів, або викликали метод. В цьому випадку ви отримуєте доступ до поля на ім'я _1. Якщо ви виконаєте цей скрипт, ви побачите:</p><pre
class="prettyprint linenums language-scala">99<br>Luftballons</pre><p>Справжній тип кортежу залежить від числа елементів, що він містить, та типів ціх елементів. Таким чином, тип (99, "Luftballons") є Tuple2[Int, String]. Тип ('u', 'r', "the", 1, 4, "me") є Tuple6[Char, Char, String, Int, Int, String].</p><p><br><span
style="font-weight: bold;">Доступ до елементів кортежу</span></p><p>Ви можете зацікавитись, чому ви не можете отримати доступ до елементів кортежу як до елементів списку, наприклад, через "pair(0)". Причина в тому, що метод списку apply завжди повертає той самий тип, але кожний елемент кортежу може мати різний тип: _1 може мати один тип результату, _2 інший, і так далі. Ці _N чисел базуються на одиниці, замість нуля, оскільки починати з 1 є традицією, що встановлена іншими мовами зі статично типізованими кортежами, як Haskell та ML.</p><h4>Крок 10. Використання множин та мап</h4><p>Оскільки Scala націлена допомогти вам отримати переваги з обох, функціонального та імперативного стилю, його бібліотеки колекцій наголошують на різниці між змінними та незмінними колекціями. Наприклад, масиви є завжди змінними; списки завжди незмінні. Scala також провадить змінні та незмінні альтернативи для множин та мап, але використовує ті ж прості імена для обох версій. Для множин та мап Scala моделює змінність в ієрархії класів.&nbsp;</p><p>Наприклад, Scala API містить базовий трейт для множин, де трейт є дещо подібним до інтерфейсу Java. (Ви винайдете більше щодо трейтів в Главі 12). Потім Scala провадить два субтрейти, один для змінних наборів, інший для незмінних наборів. Як ви можете бачити на Малюнку 3.2, ці три трейти всі поіляють те ж просте ім'я, Set. Їх повністю кваліфіковані імена, однак, відрізняються, оскільки кожен знаходиться в окремому пакунку. Конкретні класи множин в Scala API, такі як класи HashSet, показані на Малюнку 3.2, розширюють або змінний, або незмінний трейт Set. (Хоча в Java ви "реалізуєте" інтерфейси, в Scala ви "розширююте" або "домішуєте" трейти). </p><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»<br>scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; «trait»<br><br><br>scala.collection.immutable&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashSet&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; HashSet<br><br>Малюнок 3.2 Ієрархія класів для множин Scala.<br>
</p><p>Таким чином, якщо ви бажаєте використати HashSet, ви можете обрати між змінними та незмінними різновидами, в залежності від ваших потреб. Спосіб по замовчанню для створення множини показаний в Лістингу 3.5:</p>
<pre class="prettyprint linenums language-scala">var jetSet = Set("Boeing", "Airbus")
jetSet += "Lear"
println(jetSet.contains("Cessna"))</pre>
<p>Лістинг 3.5 Створення, ініціалізація та використання незмінної множини.</p><p>В першому рядку кода Лістингу 3.5, ви визначаєте нову var на ім'я jetSet, та ініціалізуєте її незмінною множиною, що містить два рядки, "Boeing" та "Airbus". Як показує цей приклад, ви можете створити множини в Scala подібно до того, як ви створюєте масиви: викликаючи метод-фабрику на ім'я apply на об'єкті-компанйоні Set. В Лістингу 3.5 ви викликаєте apply на об'єкті-компанйоні для scala.collection.immutable.Set, що повертає примірник незмінного Set по замовчанню. Компілятор Scala виводить тип jetSet’s як незмінний Set[String].</p><p>Щоб додати новий елемент до множини ви викликаєте + на множині, передаючи новий елемент. Обоє, зминна та незмінна множина, пропонують метод +, але їх поведінка відрізняється. В той час, коли змінна множина буде додавати елемент до себе, незмінна множина створить, та поверне нову множину з доданим елементом. В Лістингу 3.5 ви робите з незмінною множиною, так що виклик + дасть повністю нову множину. Хоча змінні множини пропонують справжній метод +=, незмінні множини - ні. В цьому випадку, другий рядок коду, jetSet += "Lear", є в основі скороченням для:</p>
<pre class="prettyprint linenums language-scala">jetSet = jetSet + "Lear"</pre>
<p>Таким чином, другий рядок Лістингу 3.5 ви перевизначаєте var jetSet новою множиною, що містить "Boeing", "Airbus" та "Lear". Нарешті, останній рядок Лістингу 3.5 друкує те, чи множина містиь рядок "Cessna". (Як ви можете очікувати, вона друкує false). Якщо ви бажаєте змінну множину, вам треба використовувати імпорт, як показане в Лістингу 3.6:</p>
<pre class="prettyprint linenums language-scala">import scala.collection.mutable.Set
val movieSet = Set("Hitch", "Poltergeist")
movieSet += "Shrek"
println(movieSet)</pre>
<p>Лістинг 3.6 Створення, ініціалізація, та використання змінної множини.</p><p>В першому рядку Лістингу 3.6 ви імпортуєте змінний Set. Як і в Java, твердження імпорту дозволяє вам використовувати просте ім'я, як Set, замість довшого, повністю кваліфікованого імені. Як результат, коли ви кажете Set в третьому рядку, компілятор знає, що ви маєте на увазі scala.collection.mutable.Set. На цьому рядку ви ініціалізуєте movieSet за допомогою змінної множини, що містить рядки "Hitch" та "Poltergeist". Наступний рядок додає "Shrek" до змінної множини, викликаючи метод += на множині, та передаючи рядок "Shrek". Як вже зазначалось, += є насправді методом, визначеним на змінних множинах. Коли ви побажаєте, замість писати movieSet += "Shrek", ви можете записати movieSet.+=("Shrek").</p><p>Хоча показана реалізація множини по замовчанню, що продукується змінною та незмінною методом-фабрикою Set, показаною тут, вірогідно, буде достатньою для більшості ситуацій, іноді ви можете побажати явно задати клас. На щастя, синтаксис подібний. Просто імпортуйте клас, що вам потрібний, та використовуєте метод-фабрику на об'єкті-компанйоні. Наприклад, якщо вам треба незмінний HashSet, ви можете зробити таке:</p>
<pre class="prettyprint linenums language-scala">import scala.collection.immutable.HashSet
val hashSet = HashSet("Tomatoes", "Chilies")
println(hashSet + "Coriander")</pre>
<p>Іншим корисним класом колекції в Scala є Map. Як і з множинами, Scala провадить змінні та незмінні версії Map, використовуя ієрархію класів. Як ви можете бачити на Малюнку 3.3, ієрархія класів для мап виглядає здебільшого як така ж для множин. Є базовий трейт Map в пакунку scala.collection, та два субтрейта Map: змінний Map в scala.collection.mutable, та незмінний в <br>scala.collection.immutable.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; Map<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»<br>scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; «trait»<br><br>scala.collection.immutable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; scala.collection.mutable<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HashMap<br><br>Малюнок 3.3 Ієрархія класів для мап Scala.</p><p>Реалізації Map, такі як HashMap, показані в ієрархії класів на Малюнку 3.3, розширює або змінний, або незмінний трейт. Ви можете створити та ініціалізувати мапи, використовуючи методи-фабрики, подібні до тих, що використовуютсья для масивів, списків та множин. Наприклад, Лістинг 3.7 показує змінну мапу в дії.</p>
<pre class="prettyprint linenums language-scala">import scala.collection.mutable.Map
val treasureMap = Map[Int, String]()
treasureMap += (1 -&gt; "Go to island.")
treasureMap += (2 -&gt; "Find big X on ground.")
treasureMap += (3 -&gt; "Dig.")
println(treasureMap(2))</pre>
<p>Лістинг 3.7 Створення, ініціалізація та використання змінної мапи.</p><p>В першому рядку Лістингу 3.7 ви імпортуєте змінну Map. Потім ви визначаєте val з іменем treasureMap, та ініціалізуєте її пустою змінною Map, що має цілі ключі, та рядки як значення. Мапа порожня, бо ви нічого не передали в метод-фабрику (дужки в "Map[Int, String]()" порожні). В насупних трьох рядках ви додаєте пари ключ/значення до мапи, використовуючи методи -&gt; та +=. Як вже було проілюстровано, компілятор Scala трансформує двомісні вирази-оператори, як 1 -&gt; "Go to island." на (1).-&gt;("Go to island."). Таким чином, коли ви кажете 1 -&gt; "Go to island.", ви насправді викликаєте метод на ім'я -&gt; на цілому зі значенням 1, якому передається рядок зі значенням "Go to island.". Цей метод -&gt;, який ви можете викликати для любого об'єкта в програмі Scala, повертає двоелементий кортеж, що містить ключ та значення. Потім ви передаєте цей кортеж до метода += об'єкта мапи, на який посилається treasureMap. Нарешті, останній рядок друкує значення, що відповідає ключю 2 в treasureMap. Якщо ви виконаєте цей код, він надрукує:</p>
<pre class="prettyprint linenums language-scala">Find big X on ground.</pre>
<p>Якщо ви бажаєте незмінну мапу, вам не потрібен імпорт, оскільки незмінні мапи по замовчанню. Приклад показаний в Лістингу 3.8:</p>
<pre class="prettyprint linenums language-scala">val romanNumeral = Map(
  1 -&gt; "I", 2 -&gt; "II", 3 -&gt; "III", 4 -&gt; "IV", 5 -&gt; "V"
)
println(romanNumeral(4))</pre>
<p>Лістинг 3.8 Створення, ініціалізація та використання незмінної мапи.</p><p>Приймаючи до уваги, що ми не маємо імпортів, коли ми кажемо Map в першому рядку Лістинга 3.8, ви отримаєте по замовчанню scala.collection.immutable.Map. Ви передаєте п'ять кортежів ключ/значення до метода-фабрики мапи, що повертає незмінну Map, що містить передані пари ключ/значення. Якщо ви виконаєте код в Лістингу 3.8, він надрукує "IV”.</p><h4>Крок 11. Навчаемось розпізнавати функціональний стиль</h4><p>Як зазначено в Главі 1, Scala дозволяє вам програмувати в імперативному стилі, але заохочує вас адоптуватись до більш функціонального стилю. Якщо ви прийшли до Scala з імперативного підгрунтя — наприклад, якщо ви прогаміст на Java — один з найбільших викликів, на який ви можете натрапити при вивченні Scala, це зрозуміти, як програмувати в фукнціональному стилі. Ми розуміємо, що цей стиль спершу може здатись незвичним, але в цій книзі ми докладаємо зусиль, щоб провести вас через це перетворення. Це потребуватиме деякої роботи з вашого боку, та ми заохочуємо вам докласти зусуль. Якщо ви прийшли з імперативного підгрунтя, ми віримо, що навчання програмування в фукнціональному стилі не тільки зробить вас кращим програмістом на Scala, та також розширить ваші горизонти, та зробить вас кращим програмістом взагалі.</p><p>Перший крок до розпізнання різниці між двома стилями в коді. Одним натяком може бути, чи код містить будь-які var, він, можливо, є в імперативному стилі. Якщо код не містить жодних var взагалі — тобто, він містить тільки val — він, можливо, є в функціональному стилі. Одним шляхом просунутись далі в функціональному стилі, таким чином, є спробувати програмувати без var.</p><p>Якщо ви погодите з імперативного підгрунтя, такого, як Java, C++, або<br>C#, ви можете думати про var, як про звичайну змінну, та val як про спеціальний тип змінної. З іншого боку, якщо ви прийшли з функціонального підгрунтя, такого, як Haskell, OCaml, або Erlang, ви можете думати про val як про звичайні змінні, таvar як різновид богохульства. Точка зору Scala, однак, в тому, що val та var є тільки двома різними інструментами в вашому наборі, обоє корисні, та жодний не є природним злом. Scala заохочує вас вивчити щодо val, але кінець кінцем досягти обрати кращий інструмент для завдання, що вирішується. Однак, навіть коли ви згодні з цією збалансованою філософією, ви можете все ще знайти це спочатку складиним, визначитись, як подолати var в вашому коді.</p><p>Розлянемо, наприклад, такий приклад цикла while, адаптований з Глави 2, що використовує var, та є, таким чином, в імперативному стилі:</p>
<pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  var i = 0
  while (i &lt; args.length) {
    println(args(i))
    i += 1
  }
}</pre>
<p>Ви можете трансформувати цей шматок кода в більш функціональний стиль, прибравши var, наприклад, таким чином:</p>
<pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  for (arg &lt;&lt;- args)<br>    println(arg)
}</pre>
<p>або так:</p>
<pre class="prettyprint linenums language-scala">def printArgs(args: Array[String]): Unit = {
  args.foreach(println)
}</pre>
<br>Цей приклад ілюструє одну перевагу програмування з меньшим числом var. Рефакторений (більш функціональний) код більш чистий, більш стислий, та менш схильний до помилок, ніж оригінальний (більш імперативний) код. Причина, з якої Scala заохочує функціональний стиль, фактично, полягає в тому, що функціональний стиль може допомогти вам писати більш зрозумілий, менш схильний до помилок, код.<br><br>Ви можете навіть піти далі. Рефакторений метод printArgs не є повністю функціональним, оскільки він має побічний ефект&nbsp; — в цьому випадку його побічний ефект є друк в стандартний потік. Натякаячий знак фукнції з побічним ефектом є те, що тип, якій вона повертає, є Unit. Якщо функція не повертає ніякого цікавого значення, що саме те, що означає тип Unit, єдиним шляхом, яким функція може вплинути на цей світ, є деякий різновид побічного ефекту. Більш функціональний підхід може полягати в визначенні методів, що форматують передані аргументи для друку, але тільки повертають форматований рядок, як показано в Лістингу 3.9:<br><br>
<pre class="prettyprint linenums language-scala">def formatArgs(args: Array[String]) = args.mkString("\n")</pre>
<br>Лістинг 3.9 Функція без побічних ефектів або var.<br><br>Тепер вона дійсно функціональна: не має жодних споминів про побічні ефекти або var. Метод mkString, що ви можете викликати на любій ітерабельній колекції (включаючи масиви, списки, множини та мапи), повертаючи рядок, що складається з результата виклика toString на кожному елементі, розділених переданим рядком. Таким чином, якщо args містить три елементи, "zero", "one", та "two", formatArgs поверне "zero\none\ntwo". Звичайно, ця функція насправді нічого не друкує, як це робив метод printArgs, але ви можете просто передати його результат до println, щоб досягти цього:<br>
<pre class="prettyprint linenums language-scala">println(formatArgs(args))
</pre>
<br>Здається, кожна корисна програма має мати побічний ефект в деякій формі, оскільки інакше вона б не змогла запровадити значення до зовнішнього світу. Схиляння до методів без побічних ефектів заохочує вас розробляти програми, де код побічних ефектів мінімальний. Однією з переваг цього підходу є те, що він може допомогти зробити ваші програми простішими для тестування. Наприклад, щоб протестувати любий з трьох методів printArgs, показаних вище в цьому розділі, вам треба перевизначити println, захопити вивід кожнього з них, та переконатись, що він такий, як ви очікували. На відміну від цього, ви можете протестувати функцію formatArgs, просто перевіривши її результат:<br>
<pre class="prettyprint linenums language-scala">val res = formatArgs(Array("zero", "one", "two"))
assert(res == "zero\none\ntwo")</pre>
<br>Метод Scala assert перевіряє передане Boolean, та якщо це false, підіймає AssertionError. Якщо передане Boolean є true, assert просто тихо завершується. Ви вивчите більше про допущення в Главі 14.
<p>Кажучи це, майте на увазі, що ні var, ні побічні ефекти не є злом по суті. Scala не є чистою функціональною мовою, що змушує вас програмувати все в функціональному стилі. Scala є гіблидною, імперативно/функціональною мовою. Ви можете винайти, що в деяких ситуаціях імперативний стиль краще пасує до вирішуваних проблем, та в таких випадках ви не повинні вагатись, та використосувати його. Однак, щоб допомогти вам програмувати без var, ми покажемо багато специфічних прикладів коду з var, та як трансформувати ці var в val в Главі 7.</p><p><br><span
style="font-weight: bold;">Збалансована настанова для Scala програмістів</span></p><p>Схиляйтесь до val, незмінних об'єктів, та методів без побічних ефектів. Спочатку опануйте їх. Використовуйте var, змінні об'єкти ти методи з побічними ефектами, коли ви маєте особливі потреби, та можете це обгрунтувати. </p><h4>Крок 12. Читання рядків з файлу</h4><p>Скрипти, що виконують малі, щоденні завдання, часто потребують обробляти рядки в файлах. В цьому розділі ми побудуємо скрипт, що читає рядки з файлу, та друкує їх, ставлячи зпереду число символів в кожному рядку. Перша версія показана на Лістингу 3.10:</p>
 <pre class="prettyprint linenums language-scala">import scala.io.Source
if (args.length &gt; 0) {
  for ( line &lt;- Source.fromFile(args(0)).getLines())
    println(line.length +" "+ line)
}
else
  Console.err.println("Please enter filename")
</pre>
 <p>Лістинг 3.10 Читання рядків з файла.</p><p>Цей скрипт починається з імпорту класа на ім'я Source з пакунка scala.io. Потім він перевіряє, чи вказані додаткові аргументи в командному рядку. Якщо це так, перший аргумент інтерпретується як ім'я файла, що треба відкрити та обробтити. Вираз Source.fromFile(args(0)) намагається відкрити вказаний файл, та повертає об'єкт Source, на якому ви викликаєте. Метод getLines повертає Iterator[String], що провадить один рядок за ітерацію, за винятком символа нового рядка. Вираз for ітерує поціх рядках, та друкує для кожного довжину рядка, та сам рядок. Якщо немає аргументів, наданих в командному рядку, завершальне твердження else буде друкувати повідомлення на стандартний вивід помилок. Якщо ви покладете цей код в файл з назвою countchars1.scala, та виконаєте його з самим собою:</p>
 <pre class="prettyprint linenums language-scala">$ scala countchars1.scala countchars1.scala</pre>
 <p>Ви побачите:</p>
 <pre class="prettyprint linenums language-scala">22 import scala.io.Source
0
22 if (args.length &gt; 0) {
0
51&nbsp;&nbsp; for (line &lt;- Source.fromFile(args(0)).getLines())
35&nbsp;&nbsp;&nbsp;&nbsp; println(line.length +" "+ line)
1 }
4 else
46 &nbsp; Console.err.println("Please enter filename")</pre>
 <p>Хоча скрипт в його теперішній формі друкує потрібну інформацію, ви можете захотіти пронумеровати рядки, зробити праве вирівнювання, та додати символ стовпчика, так щоб вивід виглядав замість цього так:</p><p>22 | import scala.io.Source<br>0&nbsp;&nbsp; |<br>22 | if (args.length &gt; 0) {<br>0&nbsp;&nbsp; |<br>51 |&nbsp; for (line &lt;- Source.fromFile(args(0)).getLines())<br>35 |&nbsp;&nbsp;&nbsp;&nbsp; println(line.length +" "+ line)<br>1&nbsp;&nbsp; | }<br>4&nbsp;&nbsp; | else<br>46 |&nbsp;&nbsp; Console.err.println("Please enter filename")</p><p>Щоб досягти цього, вам треба ітерувати по рядках двічі. Перший раз ви визначатимите максимальну ширину, потрібну для лічильника символів. Другий раз ви будете друкувати вивід, використовуючи максимальну ширину, що була обчислена перед цім. Оскільки ви будете ітерувати по рядках двічі, ви можете також присвоїти їх до змінної:</p>
 <pre class="prettyprint linenums language-scala">val lines = Source.fromFile(args(0)).getLines().toList</pre>
 <p>Заключний toList потрібен, бо метод getLines повертає ітератор. Коли ви проітерували по ітератору, він вичерпався. Трансформуючи його на список через виклик toList, ви отримуєте можливість ітерувати стільки разів, скільки побажаєте, ціною зберігання всіх рядків з файла в пам'яті, одночасно. Змінна lines, таким чином, посилається на список рядків, що містить вміст файла, вказаного в командному рядку.</p><p>Далі, оскільки ми будемо обчислювати довжину лічильника символів кожного рядка двічі, один раз на ітерацію, ви можете виділити цей вираз в маленьку функцію, що обчислює довжину лічильника символів кожного наданого рядка:</p>
 <pre class="prettyprint linenums language-scala">def widthOfLength(s: String) = s.length.toString.length</pre>
 <p>З цією функцією ви можете обчислити максимальну довжину таким чином:</p>
 <pre class="prettyprint linenums language-scala">var maxWidth = 0
for (line &lt;- lines)
  maxWidth = maxWidth.max(widthOfLength(line))</pre>
 <p>Тут ви ітеруєте по кожному рядку за допомогою виразу for, обчислюєте довжину символів довжини рядка, та, якщо вона більша, ніж поточний максимум, присвоюєте її до maxWidth, var, що була ініціалізована як 0. (Метод max, що ви можете викликати для кожного Int, повертає більше значення, з того, на якому він викликаний, та того, який йому переданий). Альтернативно, якщо ви схильні знайти максимум без var, ви можете спочатку знайти найдовший рядок, ось так:</p>
 <pre class="prettyprint linenums language-scala">val longestLine = lines.reduceLeft(
  (a, b) =&gt; if (a.length &gt; b.length) a else b
)</pre><p>Метод reduceLeft застосовує передану функцію до перших двох елементів, та потім застосовує її до результату першого застосування, та наступного елемента в lines, в так далі, по всьому списку. На кожному такому застосуванні результатом буде найдовший зустрічний рядок, оскільки передана функція, (a, b) =&gt; if (a.length &gt; b.length) a else b, повертає найдовший з двох переданих рядків. "reduceLeft" поверне результат останнього застосування функції, що, в цьому випадку, буде найдовшим елементом рядка в lines.</p><p>Маючи цей результат, ви можете обчислити максимальну довжину, передаіши найдовший рядок до widthOfLength:</p>
<pre class="prettyprint linenums language-scala">val maxWidth = widthOfLength(longestLine)</pre>
<p>Все що залишається, це надрукувати рядкі в потрібному форматі. Ви можете зробити це так:</p>
<pre class="prettyprint linenums language-scala">for (line &lt;- lines) {
  val numSpaces = maxWidth - widthOfLength(line)
  val padding = " " * numSpaces
  println(padding + line.length +" | "+ line)
}</pre>
<p>В цьому прикладі ви ще раз ітеруєте по рядках. Для кожного рядка ви спочатку обчислюєте часло проміжків, потрібних перед довжиною рядка, та присвоюєте його до numSpaces. Тоді ви створюєте рядок, що містиь numSpaces проміжків, за допомогою виразу " " * numSpaces. Нарешті, ви роздруковуєте інформацію в бажаному форматі. Цілий скрипт виглядає, як показано в Лістингу 3.11:</p>
<pre class="prettyprint linenums language-scala">import scala.io.Source
def widthOfLength(s: String) = s.length.toString.length
if (args.length &gt; 0) {
  val lines = Source.fromFile(args(0)).getLines().toList
  val longestLine = lines.reduceLeft(
    (a, b) =&gt; if (a.length &gt; b.length) a else b
  )
  val maxWidth = widthOfLength(longestLine)
  for (line &lt;- lines) {
    val numSpaces = maxWidth - widthOfLength(line)
    val padding = " " * numSpaces
    println(padding + line.length +" | "+ line)
}}
else
  Console.err.println("Please enter filename")</pre>
<p>Лістинг 3.11 Друк форматованих підрахунків символів для рядків з файла.</p><h3>Висновок</h3><p>Зі знанням, що ви набули в цій главі, ви повинні вже бути в змозі починати використовувати Scala для малих завдань, особливо скриптів. В майбутньому ми заглибимось в більші деталі цієї теми, та введемо інші теми, з якими ми навіть не перетинались до тепер.</p><h3>Глава 4</h3><h2>Класи та об'єкти</h2><p>Ви вже бачили основи класів та об'єктів в Scala в попередніх двох главах. В цій главі ми підемо трохи глибше. Ви навчитесь більше щодо класів, полів та мметодів, та отримаєте огляд виводу краапки з комою. Ви більше навчитесь щодо об'єта-синглтона, включаючи, як їх використовувати для написання та виконання застосування Scala. Якщо ви добре знайомі з Java, ви винайдете концепції Scala подібними, але не точно такими. Так що, навіть якщо ви є Java гуру, варто прочитати це.</p><h3>4.1 Класи, поля і методи</h3><p>Клас є проектом для об'єктів. Коли ви визначаєте клас, ви можете створити об'єкти з цього класу-проекту, за допомогою ключового слова new. Наприклад, маючи таке визначення класу:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
// class definition goes here
}</pre>
<p>Ви можете створити об'єкти ChecksumAccumulator таким чином:</p>
<pre class="prettyprint linenums language-scala">new ChecksumAccumulator</pre>
<p>В визначенні класа ви розміщуєте поля та методи, що разом називаються членами. Поля. які ви визначаєте або за допомогою val, або var, є змінними, що посилаються на об'єкти. Методи, що визначені за допомогою def, містять виконавчий код. Поля містять стан, або дані, об'єкта, тоді як методи використовують ці дані&nbsp; для виконання обчислювальної роботи об'єкта. Коли ви створюєте примірники класу, середа виконання виділяє деяку пам'ять, щоб утримувати образ стану цього образу — тобто, вміст його змінних. Наприклад, якщо ви визначили клас ChecksumAccumulator, та надали йому поле var з назвою sum :</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  var sum = 0
}</pre>
<p>та потім створили два екземпляри:</p>
<pre class="prettyprint linenums language-scala">val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator</pre>
<br>Образ об'єктів в пам'яті може виглядати так:<br><br><br>acc&nbsp; -&gt;&nbsp; &nbsp;&nbsp; sum<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>csa&nbsp; -&gt; &nbsp;&nbsp;&nbsp; sum <br><br>Оскільки sum, поле, задеклароване в класі ChecksumAccumulator, є var, а не val, ви можете пізніше переприсвоїти sum інше значення Int, ось так:<br><br>acc.sum = 3<br><br>Тепер схема виглядатиме так:<br><br>acc&nbsp; -&gt;&nbsp; &nbsp;&nbsp; sum&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
csa&nbsp; -&gt; &nbsp;&nbsp;&nbsp; sum&nbsp;&nbsp;&nbsp;&nbsp; 0<br>
<br>Одна річ, що треба зауважити щодо цього малюнка, щоє є дві змінні sum, одна в об'єкті, на який посилається acc, та інша, в об'єкті, на який посилається csa. Поля також відомі як змінні примірника, оскільки кожний примірник отримує власний набір змінних. Всі разом, змінні примірника об'єкта складають його образ в пам'яті. Ви можете бачити це, проілюстроване тут, не тільки тому, що ви бачите дві змінні sum, але і тому, що коли ви змінюєте одну, це не впливає на іншу.
<p>Інша річ, яку варто зауважити щодо цього прикладу, є те, що ви в змозі змінити об'єкт, на який посилається acc, навіть коли acc є val. Що ви не зможете робити з acc (або csa ), зважаючи, що це val, а не var, це переприсвоїти їм інший об'єкт. Наприклад, наступна спроба не буде успішною:</p>
<pre class="prettyprint linenums language-scala">// Не буде компілюватись, бо  acc є val
acc = new ChecksumAccumulator</pre>
<p>Таким чином ви можете розраховувати на те, що acc буде завжди посилатись на той самий об'єкт ChecksumAccumulator, яким він був ініціалізований, але поля цього об'єкта можуть з часом змінюватись.</p><p>Один важливий спосіб досягти стійкості об'єкта - це переконатись, що стан об'єкта — значення змінних примірника — залишаються допустимі на протязі всього життєвого циклу. Першим кроком є запобігти безпосередньому доступу до полів ззовні, зробивши поля приватними. Оскільки приватні поля можуть отримати доступ тільки з методів того ж класа, весь код, що може оновлювати стан, буде локалізовано в класі. Щоб декларувати приватне поле ви розміщуєте модифікатор приватного доступу зпереду поля, таким чином:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
}</pre>
<p>Маючи таке визначення ChecksumAccumulator, кожне намагання отримати доступ до sum ззовні класа буде хибним:</p>
<pre class="prettyprint linenums language-scala">val acc = new ChecksumAccumulator
acc.sum = 5 // Не буде компілюватись, бо sum приватне</pre>
<h4>Зауваження</h4><p>Спосіб, як ви робите члени публічними в Scala - це просто не вказувати явно модифікатор доступу. Кажучи інакше, коли ви кажете "public" в Java, ви просто нічого не кажете в Scala. Публічний доступ стоїть в Scala по замовчанню.</p><p>Тепер, коли sum є приватним, єдиний код, що може отримати доступ до sum, є код, визначений в тілі самого класа. Таким чином, ChecksumAccumulator не може якось використовуватись будь-ким, якщо ми не визначимо в ньому деякі методи:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = {
    sum += b
  }
  def checksum(): Int = {
    return ~ (sum &amp; 0xFF) + 1
  }
}</pre>
<p>Тепер ChecksumAccumulator має два методи, add та checksum, обоє з яких демонструють базову форму визначення функції, показану на Малюнку 2.1. Любі параметри метода можуть бути використані в методі. Одна важлива характеристика параметрів метода в Scala в тому, що вони є val, не var. Таким чином, якщо ви спробуєте перепризначити параметр зсередини метода в Scala, це не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">def add(b: Byte): Unit = {
  b = 1
// Це не компілюється, оскільки b є val
  sum += b
}</pre>
<p>Хоча add та checksum в цій версії ChecksumAccumulator коректно реалізують бажану функціональність, ви можете виразити їх з використанням більш стислого стилю. Перше, return в кінці метода checksum є надлишковим, та може бути відкинутий. За відсутності явного твердження return метод Scala повертає останнє значення, обчислене методом.</p><p>Рекомендований стиль для методів фактично полягає в тому, щоб уникати явних, а тим більше декількох тверджень return. Замість цього думайте про кожний метод як про вираз, що видає одне значення, яке потім повертається. Ця філософія буде спонукати вас робити методи досить малими, щоб поділяти більші методи на декілька меньших. З іншого боку вибір дизайну залежить від контекста розробки, та Scala спрощує написання методів, що мають декілька явних return, якщо це те, що вам треба.</p><p>Оскількі все, що робить checksum, є обчислення значення, він не потребує явного return. Інше скорочення для методів є те, що ви можете вилучити фігурні дужки, якщо метод обчислює тільки єдиний вираз результата. Якщо отримуваний вираз короткий, він може навіть розташовуватись в тому ж рядку, що і сам def. З ціма змінами клас ChecksumAccumulator виглядає таким чином:</p>
<pre class="prettyprint linenums language-scala">class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = sum += b
  def checksum(): Int = ~ (sum &amp; 0xFF) + 1
}</pre>
<p>Методи з типом результата Unit, такі як метод ChecksumAccumulator add, виконуються заради своїх побічних ефектів. Побічний ефект загалом визначаєтся як зміна стану десь зовні метода, або виконання дії ввода-вивода. А випадку add, наприклад, побічний ефект полягає в тому, що перепризначується sum. Інший шлях виразити такі методи є відкинути тип результата та знак рівності, та замкнути тіло метода в фігурні дужки. В цій формі метод виглядає як процедура, тобто метод, що виконуєтся виключно для побічних ефектів. Метод add в Лістингу 4.1 ілюструє цей стиль:</p>
<pre class="prettyprint linenums language-scala">// In file ChecksumAccumulator.scala
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte) { sum += b }
  def checksum(): Int = ~ (sum &amp; 0xFF) + 1
}</pre>
<p>Лістинг 4.1 Остаточна версія класа ChecksumAccumulator.</p><p>Один підводний камень, за яким треба слідити, коли опускаєте знак рівняння перед тілом функції, це те, що тип її  результата в любому випадку буде Unit. Це буде так, і не важливо що міститиме тіло, оскікільки компілятор Scala може привести кожний тип до Unit. Наприклад, якщо результат метода є String , але тип результата метода задекларований як Unit, String буде перетворено на Unit, та його значення буде втрачене. Ось приклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def f(): Unit = "this String gets lost"
f: ()Unit</pre>
<p>В цьому прикладі String перетворюється на Unit, оскільки Unit є задекларованим результатом функції f. Компілятор Scala трактує функцію, визначену в процедурному стилі, тобто в фігурних дужках без знака рівняння, загалом так само, як функцію, що явно декларує свій тип результата як Unit :</p>
<pre class="prettyprint linenums language-scala">scala&gt; def g() { "this String gets lost too" }
g: ()Unit</pre>
<p>Таким чином, підводний камень виникає, якщо ви маєте намір повернути значення не-Unit, але забули знак рівняння. Щоб отримати те, що ви бажаєте, вам треба вставити пропущений знак рівняння:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def h() = { "this String gets returned!" }
h: ()java.lang.String
scala&gt; h
res0: java.lang.String = this String gets returned!</pre>
<h3>4.2 Виведення крапки з комою</h3><p>В програмі Scala крапка з комою в кінці твердження зазвичай є опціональною. Ви можете набирати її, коли бажаєте, але ви не маєте це робити, якщо твердження з'являється одне на рядку. З іншого боку крапка з комою потрібна, якщо ви записуєте декілька тверджень на одному рядку:</p>
<pre class="prettyprint linenums language-scala">val s = "hello"; println(s)</pre>
<p>Якщо ви бажаєте ввести твердження, що продовжується на декілька рядків, в більшості випадків ви можете просто ввести його, та Scala розділить твердження в потрібних місціях. Наприклад, наступне трактуєтсья як одне твердження на чотирьох рядках:</p>
<pre class="prettyprint linenums language-scala">if (x &lt; 2)
  println("too small")
else
  println("ok")</pre>
<p>Однак іноді, тим не менш, Scala буде розділяти твердження на дві частини супроти вашого бажання:</p>
<pre class="prettyprint linenums language-scala">x
+ y</pre>
<p>Це розглядається як два твердження, x та +y . Якщо ви мали на увазі розглядати це як одне твердження x + y , ви завжди можете огорнути його в дужки:</p>
<pre class="prettyprint linenums language-scala">(x
+ y)</pre>
<p>В якості альтернативи ви можете розмістити + в кінці рядка. Само з цієї причини, коли ви зціплюєте інфіксні операції, такі як +, є загальним в стилі Scala класти оператори в кінці рядка, але не в началі:</p>
<pre class="prettyprint linenums language-scala">x +
y +
z</pre>
<h4>Правила виводу крапки з комою</h4><p>Точні правила для розділення тверджень напрочуд прості, щодо того, як вони роблять. Коротко кажучи, кінець рядка розглядається як крапка з комою, тільки якщо не виконуються наступні умови:</p><p>1. Рядок, що розглядається, закінчується на терм, що не може бути легальним в кінці твердження, такий, як кома або інфіксний оператор.</p><p>2. Наступний рядок починається зі слова, що не може починати твердження.</p><p>3. Рядок завершується в дужках (...) або в прямокутних дужках [...], оскільки вони в жодному разі не можуть містити декілька тверджень.</p><h3>4.3 Об'єкти-синглтони</h3><p>Як зазначалось в Главі 1, один спосіб, як Scala є більш об'єктно-орієнтовною, ніж Java, є те, що класи Scala не можуть мати статичних членів. Замість цього Scala має об'єкти-синглтони. Визначення об'єкта-синглтона виглядає як визначення класа, за тим виключенням, що замість ключового слова class ви використовуєте ключове слово object. Лістинг 4.2 показує приклад.</p>
<pre class="prettyprint linenums language-scala">// В файлі ChecksumAccumulator.scala
import scala.collection.mutable.Map
object ChecksumAccumulator {
  private val cache = Map[String, Int]()
  def calculate(s: String): Int =
    if (cache.contains(s))
      cache(s)
    else {
      val acc = new ChecksumAccumulator
      for (c &lt;- s)
        acc.add(c.toByte)
      val cs = acc.checksum()
      cache += (s -&gt; cs)
      cs
    }
}</pre>
<p>Лістинг 4.2 Об'єкт-компанйон до класа ChecksumAccumulator.</p><p>Створений об'єкт-синглтон називається ChecksumAccumulator, тобто має те ж ім'я, що і клас в попередньому прикладі. Коли о'бєкт-синглтон поділяє те ж ім'я, що і клас, він називається об'єктом-компанйоном цього класа. Ви повинні визначата обоє, клас та його компанйон-об'єкт в тому ж файлі. Клас називаєтсья класом-компанйоном об'єкта синглтона. Клас та об'єкт-компанйон можуть отримувати доступ до приватних членів один одного. Синглтон-об'єкт ChecksumAccumulator має один метод з назвою calculate, що приймає String, та обчислює контрольну суму для символів в String. Він також має одне приватне поле, змінну мапу, в якій кешуються попередньо обчислені контрольні суми. Перший рядок метода, " if (cache.contains(s))", перевіряє кеш, щоб побачити, чи переданий рядок вже є як ключ в мапі. Якщо це так, він повертає збережене значення з кешу. Інакше він виконує твердження else, що обчислює контрольну суму. Перший рядок твердження else визначає val на ім'я acc, та ініціалізує її новим примірником ChecksumAccumulator. Наступний рядок є вираз for, що в циклі проходить по кожному символу в переданому рядку, перетворює символи на Byte, викликаючи toByte, та передає це до метода add примірника ChecksumAccumulator, на який посилається acc. Після завершення виразу for, наступний рядок метода викликає checksum на acc, що повертає контрольну суму для переданого String, та зберігає її в val на ім'я cs. В наступному рядку, cache += (s -&gt; cs), переданий рядок в якості ключа відображуєтся на ціле значення контрольної суми, та ця пара додається до мапи кешу. Останній вираз метода, cs, повертає контрольну суму як результат метода.</p><p>Якщо ви Java програміст, ви можете мислити про об'єкти-синглтони як про домівку для статичних методів, що ви писали в Java. Ви можете викликати ці методи на об'єктах синглтона, використовуючи подібний синтаксис: ім'я об'єкта-синглтона, крапка, та ім'я метода. Наприклад, ви можете викликати метод calculate об'єкта-синглтона ChecksumAccumulator таким чином:</p>
<pre class="prettyprint linenums language-scala">ChecksumAccumulator.calculate("Every value is an object.")</pre>
<p>Об'єкт-синглтон є більше, ніж утримувач для статичних методів. Це першокласний об'єкт. Ви можете думати про ім'я об'єкта-синглтона як про "тег імені", приєднаний до об'єкта:</p><p>ChecksumAccumulator - - - &gt; cache - - - &gt; змінна мапа<br><br>Визначення об'єкта-синглтона не визначає тип (на рівні абстракції Scala). Маючи тільки визначення об'єкта ChecksumAccumulator, ви не можете створити змінну типу ChecksumAccumulator. Скоріше, тип з назвою ChecksumAccumulator визначений класом-компанйоном об'єкта-синглтона. Однак об'єкти-синглтони розширюють суперклас та можуть домішувати трейти. Зважаючи, що кожний об'єкт-синглтон є примірником своїх суперкласів та домішаних трейтів, ви можете викликати його методи через ці типи, посилаючись на них зі змінних ціх типів, та передаючи його до методів, що очікують ці типи. Ми покажемо деякі приклади о'бєктів-синглтонів, що походять від класів та трейтів, в Главі 13.</p><p>Одна відмінність між класами та об'єктами-синглтонами полягає в тому, що ці об'єкти-синглтони не можуть сприймати параметрів, тоді як класи можуть. Оскільки ви не можете створити примірник об'єкта-синглтона за допомогою ключового слова new, ви не маєте способа передати йому параметри. Кожний об'єкт-синглтон реалізований як примірник синтетичного класу, що посилається зі статичної змінної, так що вони мають ту ж симантику ініціалізації, що і статичні в Java. Зокрема, об'єкт-синглтон ініціалізується тоді, коли деякий код вперше отримує до нього доступ. </p><p>Об'єкт-синглтон, що не поділяє те є ім'я з класом-компанйоном, називаєтся окремим об'єктом. Ви можете використовувати окремі о'бєкти для багатьох цілей, включаючи збирання пов'язаних допоміжних методів разом, або визначення точки входу до застосування Scala. Цей випадок використання показаний в наступному розділі.</p><h3>4.4 Застосування Scala</h3><p>Щоб виконати програму Scala, ви повинні надати ім'я окремого об'єкта-синглтона з методом main, що приймає один параметр, Array[String], та має тип результата Unit. Кожний окремий об'єкт з методом main відповідної сигнатури може бути використаний як точка входу в ваше застосування. Приклад показаний в Лістингу 4.3:</p>
<pre class="prettyprint linenums language-scala">// В файлі Summer.scala
import ChecksumAccumulator.calculate
object Summer {
  def main(args: Array[String]) {
    for (arg &lt;- args)
      println(arg +": "+ calculate(arg))
  }
}</pre>
<p>Лістинг 4.3 Застосування Summer.</p><p>Ім'я об'єкта-синглтона в Лістингу 4.3 є Summer. Його метод main ває відповідну сигнатуру, так що ви можете використовувати його як застосування. Перше твердження в файлі є імпорт метода calculate, визначеного в об'єкті ChecksumAccumulator з попереднього приклада. Це твердження import дозволяє вам використовувати прості імена методів в залишку файла. Тіло метода main просто роздруковує кожний аргумент, та контрольну суму для аргумента, розділяючи їх двома крапками.</p><h4>Зауваження</h4><p>Scala неявно імпортує члени пакунків java.lang та scala, так само, як члени об'єкта синглтона на ім'я Predef, в кожний початковий файл кода Scala. Predef, що знаходиться в пакунку scala, містить багато корисних методів. Наприклад, коли ви кажете println в коді Scala, ви насправді викликаєте println з Predef. (Predef.println обертається, та викликає Console.println, що робить справжню роботу). Коли ви кажете assert, ви викликаєте Predef.assert.</p><p>Щоб викликати застосування Summer, розмістіть код з Лістингу 4.3 в файлі з назвою Summer.scala. Оскільки Summer використовує ChecksumAccumulator, помістіть код для ChecksumAccumulator, обоє, клас, показаний в Лістингу 4.1, та його об'єкт-компанйон, показаний в Лістингу 4.2, в файл з назвою ChecksumAccumulator.scala.</p><p>Одна різниця між Scala та Java в тому, що коли Java вимагає, щоб ви покладали публічний клас у файл за назвою класа — наприклад, ви кладете клас SpeedRacer в файл SpeedRacer.java — в Scala ви можете іменувати файли <br>.scala будь-як, як забажаєте, не важливо, які класи Scala або код ви розміщуєте в них. Однак, загалом, в випадку не-скриптів, рекомендованим стилем іменування файлів є називати їх за ім'ям класа, як це робить в Java, так що програмісти можуть більш швидко знаходити класи, переглядаючи імена файлів. Це підхід, що ми приймемо для двох файлів нашого приклада, Summer.scala та ChecksumAccumulator.scala .</p><p>Ані ChecksumAccumulator.scala, ані Summer.scala не є скриптами, оскільки вони закінчуються визначенням. Скрипт, навпаки, повинен завершуватись виразом результата. Таким чином, якщо ви спробуєте виконати Summer.scala як скрипт, інтерпретатор Scala буде скаржитись, що Summer.scala не зваершується заключним виразом (вважаємо, що ви не додали своїх власних виразів після визначення о'бєкта Summer). Замість цього вам буде потрібно насправді скомпілювати ці файли за допомогою компілятора Scala, та потім виконати отримані файли класів. Одним способом зробити це є використання scalac, що є основним компілятором Scala, таким чином:</p>
<pre class="prettyprint linenums language-scala">$ scalac ChecksumAccumulator.scala Summer.scala</pre>
<p>Це скомпілює ваші файли коду, але може бути помітна затримка перед тим, як компіляція завершиться. Причина в тому, що кожного разу, коли компілятор стартує, він витрачає час, скануючи вміст jar файлів, та роблячи іншу роботу з ініціалізації, перед тим, як він навіть погляне на ваші файли, що ви йому надіслали.&nbsp; З цієї причини дистрибутив Scala також включає демон компілятора Scala, що називається fsc (fast Scala compiler). Ви використовуєте його таким чином:</p>
<pre class="prettyprint linenums language-scala">$ fsc ChecksumAccumulator.scala Summer.scala</pre>
<p>Перший раз, коли ви виконуєте fsc, він створить демон локального сервера, приєднаний до порта на вашому комп'ютері. Потім він надішле список файлів для коспіляції демону через порт, і демон буде компілювати ці файли. Наступного разу, коли виконуєтсья fsc, демон вже буде працювати, так що fsc просто надішле список файлів демону, що беспосередньо скомпілює ці файли. Використовуючи fsc, вам треба зачекати, тільки коли Java стартує перший раз. Якщо вам колись знадобиться зупинити демон fsc, ви можете зробити це командою fsc -shutdown.</p><p>Виконання ціх команд, scalac або fsc, спродукує файли класів Java, що ви потім можете виконати через команду scala, ту ж команду, що ви викликали інтерпретатор в попередніх прикладах. Однак замість надавати ім'я файла з розширенням .scala, що містить код Scala, до інтерпретатора, що ви робили в попередньому прикладі, в цьому випадку ви даєте йому ім'я окремого об'єкта, що містить метод main відповідної сигнатури. Таким чином, ви можете виконати застосування Summer, набравши:</p>
<pre class="prettyprint linenums language-scala">$ scala Summer of love</pre>
<p>Ви побачите контрольні суми, роздруковані для двох аргументів командного рядка:</p>
<pre class="prettyprint linenums language-scala">of: -213
love: -182</pre>
<h3>4.5 Трейт Application</h3><p>Scala провадить трейт scala.Application, що може зберігти деякий набір тексту. Хоча ми не охопили все, що вам треба для розуміння, як саме воно робить, ми дійшли висновку, що в любому випадку вам треба знати про це  саме зараз. Лістинг 4.4 показує приклад:</p>
<pre class="prettyprint linenums language-scala">import ChecksumAccumulator.calculate
object FallWinterSpringSummer extends Application {
  for (season &lt;- List("fall", "winter", "spring"))
    println(season +": "+ calculate(season))
}</pre>
<p>Лістинг 4.4 Використання трейта Application.</p><p>Щоб використати трейт, ви спочатку пишете "extends Application" після імені вашого об'єкта-синглтона. Потім, замість щоб писати метод main, ви розташовуєте код, що ви мали б покласти у метод main, напряму між фігурними дужками о'бєкта-синглтона. Ісь і все. Ви можете скомпілювати та виконати це застосування, як і любе інше.</p><p>Спосіб, яким це робить, полягає в тому, що трейт Application декларує метод main з відповідною сигнатурою, що наслідує ваш об'єкт-синглтон, роблячи його придатним в якості застосування Scala. Код між фігурними дужками збирається в первинний конструктор об'єкта-синглтона, та виконується, коли об'єкт ініціалізуєтся. Не турбуйтесь, якщо ви не розумієте, що все це означає. Все буде пояснене в наступних главах, і поки ви зможете використовувати трейт без повного розуміння деталей.</p><p>Наслідування від Application коротше, ніж написання явного метода main, але є і деякі обмеження. Перше, ви не можете використовувати цей трейт, якщо вам треба доступ до аргументів командного рядка, оскільки масив args не доступний. Наприклад, оскільки застосування Summer використовує аргументи командного рядка, воно має бути напиисане з явним методом main, як показано в Лістингу 4.3. Друге, завдяки деяким обмеженням моделі потоків JVM, вам потрібен явний метод main, якщо ваше застосування багатопоточне. Нарешті, деякі реалізації JVM не оптимізують код ініціалізації об'єкта, що виконується трейтом Application. Так що ви повинні наслідувати від Application тільки коли ваша програма відносно проста та однопоточна.</p><h4>Висновок</h4><p>Ця глава надала вам основи щодо класів та об'єктів в Scala, та показала, як компілювати та виконувати застосування. В наступній главі ви навчитесь базовим типам Scala, та як їх використовувать.</p><h3>Глава 5</h3><h2>Базові типи та операції</h2><p>Тепер, коли ми побачили класи та об'єкти в дії, настав гарний час поглянути на базові типи та операції Scala більш глибоко. Якщо ви добре знайомі з Java, ви будете раді винайти, що базові типи та оператори Java мають те ж значення в Scala. Однак є деякі цікаві відмінності, що роблять цю главу варту читання, навіть якщо ви досвідчений Java розробник. Оскільки деяки з аспектів Scala, охоплені в цій главі, є в основі такі самі, як в Java, ми вставили зауваження, що вказують, що Java розробники можуть безпечно пропустити, щоб прискорити ваш прогрес. </p><p>В цьому розділі ви отримаєте огляд базових типів Scala, включаючи String та значення типів Int, Long, Short, Byte, Float, Double, Char та Boolean. Ви навчитесь операціям, які ви можете виконувати з ціма типами, включаючи, як робить старшинство операторів в виразах Scala. Ви також навчитесь, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи вам додаткові операції, за межами тих, що підтримуються Java.</p><h3>5.1 Деякі базові типи</h3><p>Декілька фундаментальних типів Scala, разом з диапазонами значень примірників ціх типів, яки вони можуть мати, показані в Таблиці 5.1. Загалом, типи Byte, Short, Int, Long та Char називають цілими, або інтегральними, типами. Інтегральні типи, плюс Float та Double, називають числовими типами. Окрім String, що міститься в пакунку java.lang&nbsp; всі з типів, що показані в Таблиці 5.1, є членами пакунку scala. </p><p>
</p><p>Таблиця 5.1 Деякі базові типи</p><table style="width: 672px; height: 142px;"
border="0"><tbody><tr><td style="width: 142.85px; text-align: center;"><h5>Значення типу</h5></td><td
style="width: 519.15px; text-align: center;"><h5>Диапазон</h5></td></tr><tr><td>Byte<br>
</td><td>8-біт зі знаком двокомпонентне ціле</td></tr><tr><td>Short</td><td>16-біт зі знаком двокомпонентне ціле</td></tr><tr><td>Int</td><td>32-біт зі знаком двокомпонентне ціле
</td></tr><tr><td>Long</td><td>64-біт зі знаком двокомпонентне ціле</td></tr><tr><td>Char</td><td>16-біт деззнаковий символ Unicode</td></tr><tr><td>String</td><td>Послідовність Char</td></tr><tr><td>Float</td><td>32-біт IEEE 754 з плаваючою крапкою одинарної точності</td></tr><tr><td>Double</td><td>
64-біт IEEE 754 з плаваючой крапкою подвійної точності</td></tr><tr><td>Boolean</td><td>true або false</td></tr></tbody></table><p>Наприклад, повне ім'я Int є scala.Int. Однак, зважаючи на те, що всі члени пакунку scala та java.lang автоматично імпортується в кожний файл Scala, ви можете просто використовувати прості імена (тобто, імена як Boolean, Char або String) будь-де.</p><p>Уважні Java розробники помітять, що базові типи Scala мають точно такі ж диапазони, що і відповідні типи в Java. Це дозволяє компілятору Scala трансформувати в байткодах примірники значення типів Scala, такі як Int або Double, в примітивні типи Java.</p><h3>5.2 Літерали</h3><p>Всі базові типи, перелічені в Таблиці 5.1, можуть бути записані за допомогою літералів. Літерал є спосіб записати значення-константу напряму в коді. </p><h4>Швидке орієнтування для Java програмістів</h4><p>Синтаксис більшості літералів, показаних в цьому розділі, точно таке, як в Java, так що якщо ви майстер Java, ви можете безпечно пропустити більшість цього розділу. Дві розбіжності, про які вам треба прочитати, є літерали Scala для необроблених рядків та символів, що описане десь нижче.</p><h4>Цілі літерали</h4><p>Цілі літерали для типіів Int, Long, Short та Byte, ідуть в трьох формах: десятичні, шіснадцятирічні та восьмирічні. Те, як починається літерал, визначає його основу. Якщо число починається з 0x або 0X, це шіснадцятиричне (основа 16), та може містити символи від 0 до 9, а також від A до F, в нижньому або верхньому реєстрі . Деякі приклади:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val hex = 0x5
hex: Int = 5
scala&gt; val hex2 = 0x00FF
hex2: Int = 255
scala&gt; val magic = 0xcafebabe
magic: Int = -889275714</pre>
<p>Зауважте, що Scala буде завжди друкувати цілі по основі 10, не важливо, яку літеральну форму ви використовуєте для ініціалізації. Таким чином, інтерпретатор відображує значення змінної hex2, що ви ініціалізували літералом 0x00FF, як десятичне 255. (Звичайно, вам не треба сприймати це на слово. Гарний спосіб почати відчувати мову є спробувати ці твердження в інтерпретаторі по ходу читання цієї глави). Якщо число починається з нуля, воно є восьмиричним (основа 8), та може, таким чином, містити цифри від 0 до 7 . Деякі приклади цього:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oct = 035
// (35 восьмиричне є 29 десятичне)
oct: Int = 29
scala&gt; val nov = 0777
nov: Int = 511
scala&gt; val dec = 0321
dec: Int = 209</pre>
<p>Якщо число починається з не-нульової цифри, та не ще будь-як не декорована, це десятичне (основа 10). Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val dec1 = 31
dec1: Int = 31
scala&gt; val dec2 = 255
dec2: Int = 255
scala&gt; val dec3 = 20
dec3: Int = 20</pre>
<p>Якщо цілий літерал завершується на L або l, це є Long, інакше це Int. Деякі приклади цілих літералів Long:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val prog = 0XCAFEBABEL
prog: Long = 3405691582
scala&gt; val tower = 35L
tower: Long = 35
scala&gt; val of = 31l
of: Long = 31</pre>
<p>Якщо літерал Int присвоєний типу Short або Byte, літерали трактуються як вони б були типу Short або Byte, докі значення літералу належить до диапазону цього типу. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val little: Short = 367
little: Short = 367
scala&gt; val littler: Byte = 38
littler: Byte = 38</pre>
<h4>Літерали з плаваючою крапкою</h4><p>Літерали з плаваючою крапкою зроблені з десятичних цифер, опціонально містять десятичну крапку, та опціонально за ними слідує E або e, та значення експоненти. Деякі приклади літералів з плаваючою крапкою:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val big = 1.2345
big: Double = 1.2345
scala&gt; val bigger = 1.2345e1
bigger: Double = 12.345
scala&gt; val biggerStill = 123E45
biggerStill: Double = 1.23E47</pre>
<p>Зауважте, що частина експоненти означає ступіть десяти, на яку домножується друга частина. Таким чином, 1.2345e1 є 1.2345 разів по 10, що є 12.345. </p><p>Якщо літерал з плаваючою крапкою закінчується на F або f, це є Float , інакше це Double. Опціонально, літерали з плаваючою крапкою Double можуть завершуватись на D або d. Деякі приклади літералів Float:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val little = 1.2345F
little: Float = 1.2345
scala&gt; val littleBigger = 3e5f
littleBigger: Float = 300000.0</pre>
<p>Останнє значення, представлене як Double, може приймати ці (та інші) форми:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val anotherDouble = 3e5
anotherDouble: Double = 300000.0
scala&gt; val yetAnother = 3e5D
yetAnother: Double = 300000.0</pre>
<h4>Символьні літерали</h4><p>Character literals are composed of any Unicode character between single<br>quotes, such as:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val a = 'A'
a: Char = A</pre>
<p>На додаток до провадження явного символа між одинарними лапками, ви можете надати восьмиричне або шіснадцятиричне число для кодової точки символа після зворотньої косої. Восьмиричне число має бути від '\0' до '\377'. Наприклад кодова точка Unicode для літери A є восьмиричне 101. Таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val c = '\101'
c: Char = A</pre>
<p>Символьний літерал також може бути наданий як загальний символ Unicode, що складається з чотирьох шіснадцятеричних цифер, якім передує \u , як тут:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val d = '\u0041'
d: Char = A
scala&gt; val f = '\u0044'
f: Char = D</pre>
<p>Фактично, такі символи Unicode можуть з'являтись будь-де в програмі Scala. Наприклад, ви можете також записати ідентифікатор таким чином:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val B\u0041\u0044 = 1
BAD: Int = 1</pre>
<p>Ідентифікатор трактується як ідентичний до BAD, результат розширення двох символів Unicode в коді нижче. Загалом, це є поганою ідеєю іменувати ідентифікатори таким чином, оскільки їх важче читати. скоріше цей синтаксис призначений для того, щоб дозволити первинним файлам Scala, що містять не-ASCII символи Unicode бути представленими в ASCII.</p>Нарешті, є також декілька символьних літералів, представлених спеціальними екранованими послідовностями, показаними в Таблиці 5.2. <br><p>Таблиця 5.2 Спеціальні літеральні екрановані послідовності
</p><table style="width: 100%;" border="0">
<tbody><tr><td style="width: 116.817px; text-align: center;">Літерал</td><td style="width: 519.3px; text-align: center; background-color: white;">Значення</td></tr><tr><td>\n</td><td>новий рядок ( \u000A )</td></tr><tr><td>\b</td><td>забій ( \u0008 )</td></tr><tr><td
style="height: 20.35px;">\t</td><td>табуляція ( \u0009 )</td></tr>
  <tr>
    <td>\f</td>
    <td>нова сторінка ( \u000C )</td>
  </tr>
<tr><td>\r</td><td>на початок рядка ( \u000D )</td></tr><tr><td>\"</td><td>подвійні лапки ( \u0022 )</td></tr>
  <tr>
    <td>\'</td>
    <td>одиночні лапки ( \u0027 )</td>
  </tr>
  <tr>
    <td>\\</td>
    <td>зворотня коса ( \u005C )</td>
  </tr>
</tbody></table>
<p>Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val backslash = '\\'
backslash: Char = \</pre>
<h4>Рядкові літерали</h4><p>Рядкові літерали складаються з символів, оточених подвійними лапками:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val hello = "hello"
hello: java.lang.String = hello</pre>
<p>Синтаксис символів в лапках є такий же, як і для символьних літералів. Наприклад:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val escapes = "\\\"\'"
escapes: java.lang.String = \"'</pre>
<p>Оскільки синтаксис для рядків з багатьма екранованими послідовностями або для рядків на декількох рядках є незграбним, Scala сключає спеціальний синтаксис для чистих рядків. Ви починаєте та закінчуєте чистий рядок трьома подвійними лапками поспіль ( """ ). В середині чистого рядка може міститсь будь-що, включаючи повністю довільні символи, включаючи нові рядки, знаки лапок та спеціальні символи, зрозуміло, за винятком потрійних лапок поспіль. Наприклад, наступна програма роздруковує повідомлення з використанням чистого рядка:</p>
<pre class="prettyprint linenums language-scala">println("""Welcome to Ultamix 3000.
           Type "HELP" for help.""")</pre>
<p>Однак, виконання цього кода не видасть саме того, що було бажано:</p>
<pre class="prettyprint linenums language-scala">Welcome to Ultamix 3000.
           Type "HELP" for help.</pre>
<p>Проблема в тому, що проміжки на початку другого рядка включені в рядок! Щоб допомоготи в цій загальній ситуації, ви можете викликати stripMargin для рядка. Щоб виконати цей метод, покалдіть сивол стовпчика ( | ) на початку кожного рядка, та потім викличте stripMargin на цілому рядку:</p>
<pre class="prettyprint linenums language-scala">println("""|Welcome to Ultamix 3000.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |Type "HELP" for help.""".stripMargin)</pre>
<p>Тепер код поводиться як було задумано:</p>
<pre class="prettyprint linenums language-scala">Welcome to Ultamix 3000.
Type "HELP" for help.</pre>
<h4>Символічні літерали</h4><p>Символічні літерали записуються як 'ident, де ident може бути любим літерно-числовим ідентифікатором. Такі літерали відзеркалюються на примірники попередньо визначеного класа scala.Symbol. Точніше, літерал&nbsp; 'cymbal буде розширений компілятором до виклику метода-фабрики: Symbol("cymbal"). Символічні літерали типово використовуються в ситуаціях, коли ви використувуєте просто ідентифікатор в динамічно типізованій мові. Наприклад, ви можете побажати визначити метод, що оновлює запис в базі даних:</p>
<pre class="prettyprint linenums language-scala">scala&gt; def updateRecordByName(r: Symbol, value: Any) {
// code goes here
}
updateRecordByName: (Symbol,Any)Unit</pre>
<p>Метод сприймає в якості параметрів символ, що вказує на ім'я запису поля, та значення, з яким поле повинне бути оновлене в запису. В динамічно типізованих мовах ви можете викликати цю операцію, передавши незадекларований ідентифікатор поля до методу, але в Scala це не буде компілюватись:</p>
<pre class="prettyprint linenums language-scala">scala&gt; updateRecordByName(favoriteAlbum, "OK Computer")
:6: error: not found: value favoriteAlbum
&nbsp;&nbsp;&nbsp;&nbsp; updateRecordByName(favoriteAlbum, "OK Computer")
&nbsp;&nbsp;&nbsp;&nbsp; ^</pre>
<p>Замість цього, і при тому майже так же стисло, ви можете передати символічний літерал:</p>
<pre class="prettyprint linenums language-scala">scala&gt; updateRecordByName('favoriteAlbum, "OK Computer")</pre>
<p>С символами немає чого багато робити, окрім з'ясувати його ім'я:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val s = 'aSymbol
s: Symbol = 'aSymbol
scala&gt; s.name
res20: String = aSymbol</pre>
<p>Інша річ, що варто зауважити, це те, що символи інтерновані. Якщо ви запишете той же літерал двічі, обоє вирази будуть посилатись на той самий об'єкт Symbol.</p><h4>Логічні літерали</h4><p>Лолгічний тип Boolean має два літерала, true та false :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val bool = true
bool: Boolean = true
scala&gt; val fool = false
fool: Boolean = false</pre>
<p>Це все що потрібно знати. Тепер ви, літерально, є експертом в Scala.</p><h3>5.3 Оператори ти методи</h3><p>Scala провадить багатий набір операторів для своїх базових типів. Як зазначалось в попередніх главах, ці оператори насправді є тільки милим синтаксисом для звичайних викликів методів. Наприклад, 1 + 2 насправді означає те ж, що і (1).+(2). Іншими словами, клас Int містить метод з ім'ям&nbsp; +, що сприймає Int, та повертає Int як результат. Цей метод + викликається, коли ви додаєте два Int:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val sum = 1 + 2
// Scala викликає (1).+(2)
sum: Int = 3</pre>
        <p>Щоб самому перевірити це, ви можете записати вираз явно, як виклик метода:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val sumMore = (1).+(2)
sumMore: Int = 3</pre>
        <p>Фактично, Int містить декілька перевантажених методів +, що сприймають різні типи параметрів. Наприклад, Int має інший метод, також з назвою +, що приймає та повертає Long. Якщо ви додасте Long до Int, буде визваний цей альтернативний метод +:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val longSum = 1 + 2L
// Scala викликає (1).+(2L)
longSum: Long = 3</pre>
        <p>Символ + є оператором — точніше, інфіксним оператором. Операторна нотація не обмежується методами як +, що виглядають як оператори в інших мовах. Ви можете використовувати любий метод в операторній нотації. Наприклад, клас String має метод indexOf, що приймає один параметр Char. Метод indexOf шукає перше входження вказаного символу в рядку, та повертає його індекс, або -1, якщо він не може знайти символ. Ви можете використовувати indexOf як оператор, таким чином:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!
scala&gt; s indexOf 'o'
// Scala викликає s.indexOf(’o’)
res0: Int = 4</pre>
        <p>На додаток String пропонує перевантажений метод indexOf, що приймає два параметри, символ, що треба шукати, та індекс, з якого потрібно починати пошук. (Інший метод indexOf, показаний раніше, починає з індекса ноль, тобто, з початку String). Навіть не зважаючи, що цей метод indexOf приймає два аргументи, ви можете використовувати його в операторній нотації. Але коли ви викликаєте метод, що приймає декілька аргументів, використовуючи операторну нотацію, ви маєте покласти ці аргументи в дужки. Наприклад, ось як ви використовуєте цю іншу форму indexOf як оператор (продовження попереднього приклада):</p>
        <pre class="prettyprint linenums language-scala">scala&gt; s indexOf ('o', 5) // Scala викликає s.indexOf(’o’, 5)
res1: Int = 8</pre>
        <h4>Кожний метод є оператором</h4><p>В Scala не є окремим синтаксисом мови: кожний метод може бути оператором. Що робить метод оператором, це те, як ви його використовуєте. Коли в и пишете “ s.indexOf('o') ”, indexOf не є оператором. Але коли ви пишете “ s indexOf 'o' ”, indexOf є оператором, тому що ви використовуєте його в операторній нотації.</p><p>До сих пір ви бачили приклади операторів в інфіксній нотації, що означає, що метод сидить між об'єктом, та параметром або параметрами, що ви бажаєте передати в метод, як в “ 7 + 2 ”. Scala також має інші операторні нотації: префіксну та постфіксну. В рефіксній нотації ви ставите ім'я метода перед об'єктом, на якому ви виконуєте метод, наприклад, ‘ - ’ в -7. В постфіксній нотації ви ставите метод після об'єкта, наприклад, “ toLong ” в “7 toLong ”.</p><p>На відміну від інфіксної операторної нотації — в якій оператори мають два операнди, один зліва та інший зправа — префіксні та постфіксні оператори є унарними: вони сприймають тільки один операнд. В префіксній нотації операнд є зправа від оператора. Деякі приклади префіксних операторів є&nbsp; -2.0, !found , та ~0xFF. Як і з інфіксними операторами, ці префіксні оператори є скороченим шляхом виклику методів. Однак в цьому випадку ім'я метода має “unary_” перед символом оператора. Наприклад, Scala трансформує вираз -2.0 в виклик метода “(2.0).unary_-”. Ви можете продемонструмати це собі, набравши виклик метода через операторну нотацію, та напряму:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; -2.0
// Scala викликає (2.0).unary_-
res2: Double = -2.0
scala&gt; (2.0).unary_-
res3: Double = -2.0</pre>
        <p>Єдині ідентифікатори, що можуть бути використані як префіксні оператори, це + , - , ! та ~. Таким чином, якщо ви визначаєте метод на ім'я unary_!, ви можете викликати цей метод на значенні або на змінній відповідного типу з використанням префіксної операторної нотації, такої, як !p. Але якщо ви визначите метод з назвою unary_*, ви не будете в змозі використовувати префіксну операторну нотацію, оскільки * не є одним з чотирьох ідентифікаторів, що можуть бути використані як префіксні оператори. Ви можете викликати метод звичаним чином, як p.unary_*, яле якщо ви спробуєте викликати його через *p, Scala розбере це як би ви написали *.p, що, можливо, не те, що ви мали на увазі!</p><p>Постфіксні оператори є методами, що не приймають аргументів, коли вони викликаються без клапки або дужок. В Scala ви можете відкинути пусті дужки на викликах методів. За домовленістю ви включаєте дужки, якщо метод має побічні ефекти, такі, як println(), але ви можете відкинути їх, якщо метод не має побічних ефектів, як в toLowerCase, викликаному на String:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val s = "Hello, world!"
s: java.lang.String = Hello, world!
scala&gt; s.toLowerCase
res4: java.lang.String = hello, world!</pre>
        <p>В цьому останньому випадку методу, що не потребує аргументів, ви можете альтернативно відкинути крапку, та використовувати постфіксну операторну нотацію:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; s toLowerCase
res5: java.lang.String = hello, world!</pre>
        <p>В цьому випадку toLowerCase використовується як постфіксний оператор на операнді s. Таким чином, щоб побачити, які оператори ви можете використовувати з базовими типами Scala, все що вам потрібно, це подивитись на методи, задекларовані в класах типів в документації Scala API. Однак приймаючи до уваги, що це Scala туторіал, ми зробимо швидкий тур по більшості з ціх методів в декількох наступних розділах.</p><h4>Швидке орієнтування для Java програмістів</h4><p>Багато аспектів Scala, описаних в залишку цієї глави такі ж самі, що і в Java. Якщо ви є Java гуру, що поспішає, ви можете безпечно пропустити все до Розділу 5.7, що описує, як Scala відрізняється від Java стосовно рівності об'єктів.</p><h3>5.4 Алгебраїчні оператори</h3><p>Ви можете визивати алгебраїчні методи через інфіксну операторну нотацію для додавання ( + ), віднімання ( - ), множення ( * ), ділення ( / ), та отримання залишку (%), на любому числовому типі. Ось деякі приклади:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1.2 + 2.3
res6: Double = 3.5
scala&gt; 3 - 1
res7: Int = 2
scala&gt; 'b' - 'a'
res8: Int = 1
scala&gt; 2L * 3L
res9: Long = 6
scala&gt; 11 / 4
res10: Int = 2
scala&gt; 11 % 4
res11: Int = 3
scala&gt; 11.0f / 4.0f
res12: Float = 2.75
scala&gt; 11.0 % 4.0
res13: Double = 3.0</pre><p>Коли обоє, лівий та правий операнди є цілими (інтегральними) типами ( Int, Long, Byte, Short або Char), оператор / буде повертати цілу частину без залишку. Оператор % вказує залошок від цілого ділення. Залишок з плаваючою крапкою, отриманий за допомогою %, не є таким, що визначений в стандарті IEEE 754. Залишок IEEE 754 використовує округлене ділення, не ділення з відкиданням при обчисленні залишку, так що це досить різне з операцією знаходження цілого залишку. Якщо ви дійсно бажаєте залишок IEEE 754, ви можете викликати IEEEremainder зі scala.math:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; math.IEEEremainder(11.0, 4.0)
res14: Double = -1.0</pre>
        <p>Числові типи також пропонують унарні префіксні оператори + (метод unary_+), та - (метод unary_- ), що дозволяє вам вказувати літеральні числа як позитивні або негативні, як -3 або +4.0. Якщо ви не вкажете унарний + або -, літеральне число розглядається як позитивне. Унарний + існує виключно для симетрії з унарним -, але не має ефекту. Унарний - також може використовуватись для обернення змінної. Ось приклади:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val neg = 1 + -3
neg: Int = -2
scala&gt; val y = +3
y: Int = 3
scala&gt; -neg
res15: Int = 2</pre>
        <h3>5.5 Операції відношення та логічні операції</h3><p>Ви можете порівняти числові типи за допомогою методів відношення: бульше ніж ( &gt; ), меньше ніж ( &lt; ), більше або дорівнює ( &gt;= ), та меньше або дорівнює ( &lt;= ), що дає логічній результат типу Boolean. На додаток ви можете використовувати унарний оператор ‘ ! ’ (метод unary_!) для обернення значення Boolean. Ось декілька прикладів:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 &gt; 2
res16: Boolean = false
scala&gt; 1 &lt; 2
res17: Boolean = true
scala&gt; 1.0 &lt;= 1.0
res18: Boolean = true
scala&gt; 3.5f &gt;= 3.6f
res19: Boolean = false
scala&gt; 'a' &gt;= 'A'
res20: Boolean = true
scala&gt; val thisIsBoring = !true
thisIsBoring: Boolean = false
scala&gt; !thisIsBoring<br>res21: Boolean = true</pre>
        <p>Логічні методи, ТА ( &amp;&amp; ) та АБО ( || ), приймають операнди Boolean в інфіксній нотації, та дають результат Boolean. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; val toBe = true
toBe: Boolean = true
scala&gt; val question = toBe || !toBe
question: Boolean = true
scala&gt; val paradox = toBe &amp;&amp; !toBe
paradox: Boolean = false</pre>
        <p>Логічні операції ТА та АБО обчислюються за скороченою схемою, як в Java: вирази, побудовані з ціх операторів, обчислюються тільки доти, доки треба для визначення результата. Іншими словами, права сторона виразу логічного ТА, та логічного АБО не буде обчислюватись, якщо ліва сторона визначає результат. Наприклад, якщо ліва сторона логічного виразу ТА обчислюється як false, результат виразу буде однозначно false, так що права сторона не буде обчислюватись. Подібно, якщо ліва сторона логічного АБО обчислюється як true, результат виразу буде однозначно true, так що права сторона не обчислюється. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; def salt() = { println("salt"); false }
salt: ()Boolean
scala&gt; def pepper() = { println("pepper"); true }
pepper: ()Boolean
scala&gt; pepper() &amp;&amp; salt()
pepper
salt
res22: Boolean = false
scala&gt; salt() &amp;&amp; pepper()
salt
res23: Boolean = false</pre>
        <p>В першому виразі викликаються pepper та salt, але в другому викликається тільки salt. Зважаючи, що salt повертає false, немає потреби викликати pepper.</p><h4>Зауваження</h4><p>Ви можете здивуватись, як коротке обчислення може робити, якщо оператори є тільки методами. Звичайно, всі аргументи обчислюються до входу в метод, то як може метод уникнути обчислення другого аргументу? Відповідь в тому, що всі методи Scala мають змогу відкласти обчислення своїх аргументів, або навіть зовсім відмовитись від їх обчислення. Ця можливість названа викликом параметрів за ім'ям, та обговорюється в Розділі 9.5.</p><h3>5.6 Побітові операції</h3><p>Scala дозволяє вам виконувати операції на окремих бітах цілих типів, за допомогою декількох побітових методів. Побітові методи такі: побітове-ТА ( &amp; ), побітове-АБО ( | ), та побітове-АБО_НІ ( ˆ ). Унарний оператор доповнення НІ ( ~, метод unary_ ~ ), інвертує кожний біт в операнді. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 &amp; 2
res24: Int = 0
scala&gt; 1 | 2
res25: Int = 3
scala&gt; 1 ˆ 3
res26: Int = 2
scala&gt; ~ 1
res27: Int = -2</pre>
        <p>Перший вираз, 1 &amp; 2, робить побітове-ТА кожного біта 1 (0001) та 2 (0010), що дає 0 (0000). Другий вираз, 1 | 2, робить побітове-АБО кожного біта тих самих операндів, що дає 3 (0011). Третій вираз, 1 ˆ 3 , робить побітове-АБО_НІ кожного біта 1 (0001) та 3 (0011), що дає 2 (0010). Останній вираз, ~ 1, інвертує кожний біт 1 (0001), даючи -2, що в двоїчній системі виглядає як&nbsp;11111111111111111111111111111110.</p><p>Цілі типи Scala також пропонують три методи зсувів: зсув вліво ( &lt;&lt; ), зсув вправо ( &gt;&gt; ), та беззнаковий зсув вправо ( &gt;&gt;&gt; ). Методи зсувів, коли використовуються в інфіксній операторній нотації, зсувають ціле значення зліва операнда на число біт, вказане цілим числом зправа. Зсув вліво та беззнаковий зсув вправо заповнюють біти нулями по мірі зсуву. Зсув вправо заповнює старший біт (знаковий біт) значенням самого лівого біта по мірі зсуву. Ось деякі приклади:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; -1 &gt;&gt; 31
res28: Int = -1
scala&gt; -1 &gt;&gt;&gt; 31
res29: Int = 1
scala&gt; 1 &lt;&lt; 2
res30: Int = 4</pre>
        <p>-1 в двоїчній системі буде 11111111111111111111111111111111. В першому прикладі -1 &gt;&gt; 31 , -1 зсувається вправо на 31 бітових позицій. Оскільки Int має 32 біти, ця операція ефективно пересуває самий лівий біт, доки він не стане самим правим. Оскільки метод &gt;&gt; заповню одиницями по мірі зсуву вправо, бо найлівішій біт -1 є 1, результат ідентичний до оригінального операнад, 32 біт одиниць, або -1. В другому прикладі&nbsp; -1 &gt;&gt;&gt; 31, найлівіший біт знову зсувається вправо, доки не стане самим правим, але цього разу заповнення іде нулями. Таким чином цього разу отримаємо двоїчне 00000000000000000000000000000001, або 1. В останньому прикладі, 1 &lt;&lt; 2, лівий операнд, 1, зсувається вліво на дві позиції (та заповнює нулями), даючи двоїчне 00000000000000000000000000000100, або 4.</p><h3>5.7 Рівність об'єктів</h3><p>Якщо ви бажаєте порівняти два об'єкти на рівність, ви можете використовувати або == , або його протилежність, !=. Ось декілька прикладів:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 == 2
res31: Boolean = false
scala&gt; 1 != 2
res32: Boolean = true
scala&gt; 2 == 2
res33: Boolean = true</pre>
<p>Ці оператори насправді стосуються до всіх об'єктів, не тільки до базових типів. Наприклад, ви можете використовувати == для порівняння списків:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) == List(1, 2, 3)
res34: Boolean = true
scala&gt; List(1, 2, 3) == List(4, 5, 6)
res35: Boolean = false</pre>
        <p>Ідучі далі, ви можете порівняти два об'єти, що мають різні типи:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 1 == 1.0
res36: Boolean = true
scala&gt; List(1, 2, 3) == "hello"
res37: Boolean = false</pre>
        <p>Ви можете порівняти навіть з null, або з речами, що можуть бути null. Виключення не виникне:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; List(1, 2, 3) == null
res38: Boolean = false
scala&gt; null == List(1, 2, 3)
res39: Boolean = false</pre>
        <p>Як ви бачите, == було змайстровано на славу, так що якщо вам треба порівняння на еквівалентність, ви отримаєте його в більшості випадків. Це досягається за допомогою дуже простого правила: зпершу перевіряєтося плава частина на null, та якщо це не null, викликається метод equals. Оскільки equals є методом, точне порівняння, що ви отримаєте, залежить від типу аргументу з лівої сторони. Оскількі існує автоматична перевірка на null, ви на маєте робити це самому.</p><p>Цей тип порівняння даватиме true на різних об'єктах, доки їх вміст той же самий, та їхній метод equals написаний так, щоб базуватись на вмісті. Наприклад, ось порівняння двох рядків, що мають ті ж самі&nbsp; п'ять літер:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; ("he"+"llo") == "hello"
res40: Boolean = true</pre>
        <h4>Як Scala == відрізняється від Java</h4><p>В Java ви можете використовувати == для порівняння обох, примітивних та об'єктних типів. На примітивних типах Java == порівнює еквівалентність значень, як і в Scala. Однак, на об'єктних типах, Java == порівнює еквівалентність посилань, що означає, що дві змінні вказують на той же об'єкт в купі JVM. Scala також провадить здатність порівнювати еквівалентність посилань, під ім'ям eq. Однак, eq, та його антонім, ne, стосуються тільки до об'єктів, що напряму відзеркалюються на Java об'єкти. Всі деталі щодо eq та ne надані в Розділах 11.1 та 11.2. Також дивіться Главу 30, щодо того, як писати гарні методи equals.</p><h3>5.8 Преоритети на асоціативність операторів</h3><p>Преоритетність операторів визначає, які частини виразу обчислюються перед іншими чистинами. Наприклад, вираз 2 + 2 * 7 обчислюється до 16, не до 28, оскільки оператор * має вищий преоритет, ніж оператор +. Таким чином, частина виразу множення обчислюється перед додаванням. Ви можете, звичайно, використовувати дужки для прояснення порядку обчислення, або для зміни преоритетності. Наприклад, якщо ви дійсно бажаєте, щоб результат обчислень виразу вище склав 28, ви можете записати вираз таким чином:</p>
        <pre class="prettyprint linenums language-scala">(2 + 2) * 7</pre>
        <p>Зважаючи на те, що Scala не має операторів, як таких, та тільки методіи в операторній нотації, ви можете здивуватись, як робить преоритетність операторів. Scala визначає преоритет на основі першого символа метода, що використовується в операторній нотації (є одне виключення з цього правила, що буде обговорене нижче). Якщо ім'я починається на * , наприклад, воно буде мати більший преоритет, ніж метод, що починається на + .Таким чином, 2 + 2 * 7 буде обчислюватись як 2 + (2 * 7) , та +++ b *** c (де a, b, c є змінними, а +++ та *** є методами) буде обчислюватись як a +++ (b *** c), оскільки метод *** має вищий преоритет, ніж метод +++.</p><p>Таблиця 5.3 Преоритети операторів</p><table
style="width: 100%" border="1"><tbody><tr><td>(інші спец.символи)</td><td>*/% </td><td> +-</td><td> :</td><td>=!</td><td>&lt;&gt;</td><td>&amp;</td><td>ˆ</td><td> |</td><td>(всі літери)</td><td>(всіприсвоєння)</td><td><br></td></tr></tbody></table><p>Таблиця 5.3 показує преоритетність на основі першого символа метода, в порядку зменшення преоритета, де згруповані разом оператори мають однаковий преоритет. Чим лівіший символ в таблиці, тим вищий преоритет методів, що починається з цього символа. Ось приклад, що ілюструє іплив преоритетів:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 2 &lt;&lt; 2 + 2
res41: Int = 32</pre>
        <p>Метод &lt;&lt; починається з символа &lt;, що виявляється нижче за преоритетом, ніж символ +, що є першим та єдиним символом метода +. Таким чином &lt;&lt; буде мати нижчий преоритет, ніж +, та вираз буде обчислюватись, спочатку викликаючи метод +, ніж метод &lt;&lt;, як в <br>2 &lt;&lt; (2 + 2) . За нашими підрахунками 2 + 2 є 4 , та 2 &lt;&lt; 4 дає 32. Ось інший приклад:</p>
        <pre class="prettyprint linenums language-scala">scala&gt; 2 + 2 &lt;&lt; 2
res42: Int = 16</pre>
        <p>Оскільки перші символи такі ж самі, як і в попередньому прикладі, методи будуть викликатись в тому ж порядку. Перший буде викликаний метод +, потім метод &lt;&lt;. Так що 2 + 2 знову дає 4 , та 4 &lt;&lt; 2 буде 16. </p><p>Одним виключенням до правила преоритетів, що озвучені вище, стосуєтсья операторів присвоєння, що закінчуються на символ знака рівності&nbsp; (=) , та це не один з операторів порівняння &lt;= , &gt;= , == , або !=. Тоді преоритет оператора той самий, що і простого присвоєння (=). Тобто, воно менше, ніж преоритет любого іншого оператора. Наприклад:</p>
        <pre class="prettyprint linenums language-scala">x *= y + 1</pre>
        <p>означає те саме, що і:</p>
        <pre class="prettyprint linenums language-scala">x *= (y + 1)</pre>
        <p>оскільки *= класифікується як оператор присвоєння, чий преоритет ніжчий, ніж +, не зважаючи, що перший символ оператора є *, що вказує на більший преоритет, ніж у +.</p><p>Коли декілька операторів з однаковим преоритетом з'являють пліч-о-пліч в виразі, тоді групування операторів визначається асоциативністю. Асоциативність операторів визначається останнім символом. Як зазначалось в Главі 3, якщо метод завершується на символ ‘:’, він викликається на правому операнді, передаючи лівий операнд. Методи, що закінчуються на любий інший символ, роблять все навпаки. Вони викликаються на лівому операнді, передаючи правий операнд. Так що a * b дає a.*(b), але a ::: b дає b.:::(a) .</p><p>Однак не мажливо, що за асоціативність в операторів, та їх операнди завжди обчислюються зліва направо. Так що якщо вираз, що не є простим посиланням на незмінне значення, тоді a ::: b біль точно трактується як наступний блок:</p>
        <pre class="prettyprint linenums language-scala">{ val x = a; b.:::(x) }</pre>
			  <p>В цьому блоці a все ще обчислюється перед b, та потім результат цього обчислення передається як операнд в метод b :::.</p><p>Це правило асоціативності також грає роль, коли декілька операторів тієї ж процедури стоять поряд. Якщо метод завершується на ‘:’, вону групуються зправа наліво; інакше, вони групуються зліва направо. Наприклад, a ::: b ::: c трактується як a ::: (b ::: c). Але a * b * c, навпаки, трактується як (a * b) * c.</p><p>Преоритети операторів є частиною мови Scala. Вам не треба боятися використовувати їх. Тим не менш є гарним стилем використовувати дужки для прояснення, які операнди оперують з якими виразами. Можливо, єдиний преоритет, на який ви можете розраховувати, що його без підказок розуміють інші розробники, це преоритет мультиплікативних операторів: * , / , %, над аддитивними + та&nbsp; -. Таким чином, навіть якщо вам зрозуміло, що a + b &lt;&lt; c дає потрібний результат без дужок, додаткова ясність від написання (a + b) &lt;&lt; c може зменшити частоту, з якою ваші колеги будуть споминати ваше ім'я в операторній нотації, наприклад, плюючи з огидою, “bills !*&amp;ˆ % ~ code!”.</p><h3>5.9 Збагачені огортки</h3><p>Ви можете викликати значно більше методів на базових типах Scala, ніж описано в попередніх розділах. Декілька прикладів надаються в Таблиці 5.4.</p><p>Таблиця 5.4 Деякі збагачені операції
</p><table style="width: 100%;" border="0">
<tbody><tr><td style="text-align: center;">Код</td><td style="text-align: center;">Результат</td></tr><tr><td>0 max 5</td><td>5</td></tr><tr><td>0 min 5</td><td>0</td></tr>
  <tr>
    <td>-2.7 abs</td>
    <td>2.7</td>
  </tr>
  <tr>
    <td>-2.7 round</td>
    <td>-3L</td>
  </tr>
  <tr>
    <td>1.5 isInfinity</td>
    <td>false</td>
  </tr>
  <tr>
    <td>(1.0 / 0) isInfinity</td>
    <td>true</td>
  </tr>
  <tr>
    <td>4 to 6</td>
    <td>Range(4, 5, 6)</td>
  </tr>
  <tr>
    <td>"bob" capitalize</td>
    <td>"Bob"</td>
  </tr>
  <tr>
    <td>"robert" drop 2 5</td>
    <td>"bert"</td>
  </tr>
</tbody></table>
<br>Ці методи також доступні через неявні приведення типів, прийом, що буде детально описаний в Главі 21. Все що вам треба знати, це що для кожного базового типа, описаного в цій главі, є також “збагачена огортка”, що провадить декілька додаткових методів. Таким чином, щоб побачити всі доступні методи для базових типів, ви маєте поглянути на документацію API до збагаченого типу кожного базового типу. Ці класи перелічені в Таблиці 5.5.<br><br>Таблиця 5.5 Збагачені класи-огортки<br>

<table style="width: 100%;" border="0">
<tbody><tr><td style="text-align: center;">Базовий тип</td><td style="text-align: center;">Збагачена огортка</td></tr><tr><td>Byte</td><td>scala.runtime.RichByte</td></tr>
  <tr>
    <td>Short</td>
    <td>scala.runtime.RichShort</td>
  </tr>
  <tr>
    <td>Int</td>
    <td>scala.runtime.RichInt</td>
  </tr>
  <tr>
    <td>Char</td>
    <td>scala.runtime.RichChar</td>
  </tr>
  <tr>
    <td>Float</td>
    <td>scala.runtime.RichFloat</td>
  </tr>
  <tr>
    <td>Double</td>
    <td>scala.runtime.RichDouble</td>
  </tr>
  <tr>
    <td>Boolean</td>
    <td>scala.runtime.RichBoolean</td>
  </tr>
  <tr>
    <td>String </td>
    <td>scala.collection.immutable.StringOps</td>
  </tr>
</tbody></table>
<br><h3>5.10 Висновок</h3><p>Головне, що треба взяти з цієї глави, це те, що оператори в Scala є викликами методів, та існують неявні перетворення до збагачених варіантів для базових типів Scala, що додає навіть більше корисних методів. В наступній главі ми покажемо вам, що означає розробляти об'єкти в функціональному стилі, та як це дає нові реалізації деяких з операторів, що ми бачили в цій главі. </p><h3>Глава 6</h3><h2>Функціональні об'єкти</h2><p>З розумінням основ Scala, які ви отримали в попередніх главах, ви вже готові побачити, як розробляти більш дієздатні класи в Scala. Наголос в цій главі стоїть на класах, що визначають функціональні об'єкти, тобто, об'єкти, що не мають жодного змінного стану. В якості нагального прикладу ми створимо клас, що моделює раціональні числа, як незмінні об'єкти. По ходу дії ми покажемо вам більше аспектів об'єктно-орієнтовного програмування в Scala: параметри та конструктори класів, перекриття, перевірку передумов, перевантаження та посилання на себе.</p><h3>6.1 Специфікація класу Rational</h3><p>Раціональне число є таким, що може бути виражене як відношення d/n, де n та d є цілими, за тим винятком, що d не може бути нулем. n називається чисельником, d називаєтсья знаменником. Прикладами раціональних чисел є 1/2, 2/3, 112/239, та 2/1.</p><p>В порівнянні з числами з плававючою крапкою, раціональні числа мають перевагу в тому, що дріб представлена точно, без округлень та апроксимації. Клас, що ми розробляємо в цій главі повинен моделювати поведінку раціонального числа, включаючи додавання, віднимання, множення та ділення. Щоб додати два раціональні числа спочатку вам треба знайти загальний дільник, та потів додати два чисельника. Наприклад, щоб додати 1/2 + 2/3, ви множите обі частини лівого операнда на 3, та обі частини правого операнда на 2, що дає 3/6 + 4/6. Додавання двох чисельників дає 7/6. Щоб помножити два раціональні числа, ви просто множите чисельники та знаменники. Таким чином, 2/1 ∗ 2/5 дає 2/10, що може бути представлене більш компактно в “нормалізованій” формі як 5/1. Ви ділите, переставляючи чисельник та займенник правого операнда, та поті виконуючи множення. Наприклад, 1/2 / 3/5 те ж саме, що і 1/2 ∗ 5/3, або 6/5.</p><p>Одне, можливо досить тривіальне, дослідження цієї метаматики, дає те, що раціональні числа не мають змінного стану. Ви можете додати одне раціональне до іншого, але результат буде новим раціональним числом. Оригінальні числа не будуть “змінені”. Незмінний клас Rational, що ми розробляємо в цій главі, буде мати ти ж властивості. Кожне раціональне число буде представлене одним об'єктом Rational. Коли ви додаєте два об'єкта Rational, ви створюєте новий об'єкт Rational, що міститиме суму.</p><p>Ця глава дасть вам побіжне враження щодо шляхів, як Scala дозволяє вам писати бібліотеки, що виглядають як природна підтримка мови. Наприклад, наприкінці цієї глави ви будете в змозі зробити наступне з класом Rational :</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; (oneHalf / 7) + (1 - twoThirds)
res0: Rational = 17/42</pre>
        <h3>6.2 Побудова Rational</h3><p>Гарним місцем для початку розробки класа Rational є прийняти рішення, як програмісти клієнтів будуть створювати новий об'єкт Rational. Приймаючи до уваги, що ми прийняли незмінність об'єктів Rational, нам буде треба, щоб клієнти провадили всі дані, потрібні для примірника (в цьому випадку чисельник да займенник) при створенні примірника. Таким чином, ми почнемо розробляти з такого:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int)</pre>
        <p>Одна з перших речей, що треба зазначити щодо цього рядка кода, це те, що якщо клас не має тіла, вам не треба вказувати порожні фігурні дужки (хоча ви можете, звичайно, якщо бажаєте). Ідентифікатори n та d в дужках після імені класа, Rational, називаються параметрами класа. Компілятор Scala збере ці два параметри класа, та створить первинний конструктор, що приймає саме два параметри.</p><h4>Недоліки незмінних об'єктів</h4><p>незмінні об'єкти пропонують декілька переваг над змінними об'єктами, та один потенційний недолік. Перше, незмінні об'єкти часто простіші до промислення, ніж змінні, оскільки вони не мають складних просторів стану, що змінюється з часом. Друге, ви можете передавати незмінні об'єкти будь-куди досить вільно, тоді як вам може знадобитись захисні копії змінних об'єктів перед передачею їх в інший код. Третє, немає способу для двох потоків конкурентно мати доступ до незмінного об'єкту, щоб зіпсувати його стан після того, як він був відповідно сконструйований, оскільки жодний потік не може змінити стан незмінного. Четверте, незмінні об'єкти роблять безпечними ключі хеш таблиць. Якщо змінний об'єкт змінюється після того, як він покладений, наприклад, в HashSet, цей об'єкт може бути не знайдений наступного разу, коли ви будете його шукати в HashSet .</p><p>Головний недолік незмінних об'єктів в тому, що вони часом потребують копіювання великого об'єктного графу, там, де в іншому випадку може знадобитись тільки оновлення на місці. В деяких випадках це може бути незграбним під час реалізації, та також може призвести до вузьких місць продуктивності. Як результат, не є незвичним для бібліотек провадити змінні альтернативи до незмінних класів. Наприклад, клас StringBuilder є змінною альтернативою до незмінного String. Ми надамо вам більше інформації щодо розробки змінних об'єктів в Scala в Главі 18.</p><h4>Зауваження</h4><p>Цей початковий приклад Rational підкреслює різницю між Java та<br>Scala. В Java класи мають конструктори, що можуть мати параметри, тоді як в Scala класи можуть приймати параметри напряму. Нотація Scala є більш стислим — параметри класа можуть використовуватись напряму в тілі класів; немає потреби визначати поля та писати присвоєння, що копіюють параметри клнструктора в поля. Це може дати значні збереження в шаблонному коді, особливо для малих класів.</p><p>Компілятор Scala буде компілювати любий код, що ви розмістите в тілі класа, що не є частиною визначення поля або метода в первинний конструктор. Наприклад, ви можете надрукувати повідомлення таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  println("Created "+ n +"/"+ d)
}</pre>
<p>Маючи цей код, компілятор Scala буде розміщувати виклик println в первинний конструктор Rational. Виклик println буде, таким чином друкувати його повідомлення налаштування при створенні нового примірника Rational:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(1, 2)
Created 1/2
res0: Rational = Rational@90110a</pre>
        <h3>6.3 Перевизначення метода toString</h3><p>Коли ми створили примірник Rational в попередньому прикладі, інтерпретатор друкує “Rational@90110a”. Інтерпретатор отримує дещо дивно виглядаючий рядок, викликаючи метод toString об'єкта Rational. По замовчанню клас Rational наслідує реалізацію toString, визначений для класа class java.lang.Object, що тільки друкує ім'я класа, знак @, та шіснадцятиричне число. Результат toString призначений в першу чергу допомагати програмістам, провадячи інформацію, що може використовуватись для налаштування тверджень друку, журнальний повідомлень, тестових звітів про збої, та вивід інтерпретатора та налагодження. Результат, що наразі провадиться toString, не є особливо корисним, оскільки він не дає жодної підказки щодо значення раціонального значення. Більш корисна реалізація toString буде друкувати значення чисельника та займенника Rational. Ви можете переписати реалізацію по замовченню, додаючи метод toString до класа Rational, наприклад, таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  override def toString = n +"/"+ d
}</pre>
        <p>Модифікатор override на початку визначення метода сигналізує, що попереднє визначення метода буде перекрите; більше щодо цього в Главі 10. Оскільки число Rational тепер буде відображуватись досить мило, ми видалимо твердження println, що ми поклали в тіло попередньої версії класа Rational. Ви можете протестувати нову поведінку Rational в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(1, 3)
x: Rational = 1/3
scala&gt; val y = new Rational(5, 7)
y: Rational = 5/7</pre>
        <h3>6.4 Перевірка передумов</h3><p>В якості наступного кроку ми перемикнемо нашу увагу на проблему поточної поведінки первинного конструктора. Як зазначалось на початку цієї глави, раціональні числа не можуть мати нуль в якости займенника. Однак наразі первинний конструктор приймає нуль в якості d :</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(5, 0)
res1: Rational = 5/0</pre>
        <p>Одна з переваг об'єктно-орієнтовного програмування в тому, що воно дозволяє вам інкапсулювати дані в об'єктах, так що ви можете переконатись, що дані коректні на протязі їх життя. В випадку незмінного об'єкта, такого, як Rational, це означає, що ви повинні переконатись в валідності даних при конструюванні об'єкта. Маючи на увазі, що нульовий займенник є неприпустимим станом для числа Rational, ви не повинні дозволити конструювання Rational, якщо в параметрі d переданий нуль.</p><p>Кращим шляхом у підході до цієї проблеми, це визначити передумову в первинному конструкторі, що d не повинне бути нулем. Передумова є обмеження на значення, передані в метод або конструктор, яким повинні задовільняти викликаючі. Одним з шляхів зробити це можна таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  override def toString = n +"/"+ d
}</pre>
        <p>Метод require приймає одне логічне значення. Якщо передане значення є<br>true, require повернеться нормально. Інакше require запобігатиме об'єкт від створення, викликаючи виключення IllegalArgumentException.</p><h3>6.5 Додавання полів</h3><p>Тепер, коли первинний конструктор відповідним чином накладає передумову, ми перенесемо нашу увагу на реалізацію додавання. Щоб зробити це, ми визначимо публічний метод add на класі Rational, що приймає інше Rational в якості параметра. Щоб утримувати Rational незмінним, метод add не повинен додавати передане раціональне число до себе. Скоріше, він повинен новий Rational, що міститиме суму. Ви можете думати про це, записавши add таким чином:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) { // Це не буде компілюватись
  require(d != 0)
  override def toString = n +"/"+ d
  def add(that: Rational): Rational =
  new Rational(n * that.d + that.n * d, d * that.d)
}</pre>
        <p>Однак надання цього кода призведе до скарги компілятора:</p>
<pre class="prettyprint linenums language-scala">&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
                      ˆ
&lt;console&gt;:11: error: value d is not a member of Rational
new Rational(n * that.d + that.n * d, d * that.d)
                                               ˆ</pre>
<p>Хоча параметри класа n та d є в полі зору кода вашого метода add, ви можете отримувати доступ до них на об'єкті, на якому він викликається. Таким чином, коли ви кажете n або d в реалізації add, компілятор щасливий провадити вам значення для параметрів цього класа. Але він не дозволить вам казати that.n або that.d, оскільки це не посилається на об'єкт Rational, на якому він викликаєтсья. Щоб отримати доступ до чисельника та займенника на ньому, нам треба перетворити їх на поля. Лістинг 6.1 показує, як ви можете додати ці поля до класа Rational. </p><p>В увц ваерсії Rational, показаній в Лістингу 6.1 ми додаємо два поля з іменами numer та denom, та ініціалізуємо їх значеннями параметрами класів n та d. Ми також змінюємо реалізацію toString та add, так що вини використовують поля, не параметри класа. Ця версія класа Rational буде компілюватись. Ви можете протестувати його, додаючи деякі раціональні числа:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  override def toString = numer +"/"+ denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}</pre>
        <p>Лістинг 6.1 Rational з полями.</p>
<pre class="prettyprint linenums language-scala">scala&gt; val oneHalf = new Rational(1, 2)
oneHalf: Rational = 1/2
scala&gt; val twoThirds = new Rational(2, 3)
twoThirds: Rational = 2/3
scala&gt; oneHalf add twoThirds
res3: Rational = 7/6</pre>
        <p>Одна інша річ, що ви можете зробити прямо зараз, та що ви не могли до цього, це доступ до значень чисельника та займенника за межами об'єкта. Просто отримуйте доступ до полів numer та denom:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val r = new Rational(1, 2)
r: Rational = 1/2
scala&gt; r.numer
res4: Int = 1
scala&gt; r.denom
res5: Int = 2</pre>
        <h3>6.6 Посилання на себе</h3><p>Ключове слово this посилається на примірник об'єкта, на якому наразі викликається метод, або, якщо використовується в конструкторі, примірник об'єкта, що створюється. В якості приклада розглянемо новий метод, lessThan, що перевіряє, чи даний Rational меньше, ніж параметр:</p>
<pre class="prettyprint linenums language-scala">def lessThan(that: Rational) =
&nbsp; this.numer * that.denom &lt; that.numer * this.denom</pre>
        <p>Тут this.numer посилається на чисельник об'єкта, на якому викликається lessThan. Ви також можете облишити цей префікс, та просто записати numer; дві нотації є еквівалентними. В якості приклада, як ви можете це зробити без цього, розгляньте додавання метода max до класа, що повертає більше з наданого раціонального числа, та аргумента:</p>
<pre class="prettyprint linenums language-scala">def max(that: Rational) =
&nbsp; if (this.lessThan(that)) that else this</pre>
        <p>Тут перше this є зайвим. Ви можете точно таким же чином опустити ліву частину, та записати lessThan(that). Але другий this представляє результат метода в випадку, коли перевірка дає false; коли ви опустите і його, вам просто не буде що повертати!</p><h3>6.7 Додаткові конструктори</h3><p>Іноді вам треба декілька конструкторів для класа. В Scala конструктори, крім первинного, називають додатковими конструкторами. Наприклад, раціональне число з займенником 1 може бути записане більш стисло, як один чисельник. Наприклад, замість 1/5, ви можете записати просто 5. Таким чином, це може бути милим, якщо замість писати new Rational(5, 1), програмісти клієнтів можуть просто записати new Rational(5). Це може потребувати створення додаткового конструктора Rational, що приймає тільки один аргумент, чисельник, та вважате займенник рівним 1. Лістинг 6.2 демонструє, як це може виглядати.</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  val numer: Int = n
  val denom: Int = d
  def this(n: Int) = this(n, 1) // додатковий конструктор
  override def toString = numer +"/"+ denom
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
}
</pre><p>Лістинг 6.2 Rational з додатковим конструктором.</p>
<p>Додаткові конструктори в Scala починаються з def this(...). Тіло зовнішнього конструктора Rational просто викликає первинний конструктор, передаючи йому свій один аргумент, n, в якості чисельника, та 1 в яксті займенника. Ви можете бачити додатковий конструктор в дії, набравши наступне в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val y = new Rational(3)
y: Rational = 3/1 </pre>
        <p>В Scala кожний зовнішній конструктор має викликати інший конструктор того ж класа в якості першої дії. Іншими словами, перше твердження кожного зовнішнього конструктора кожного класа Scala буде мати форму “this( . . . ) ”. Викликаний конструктор є або первинним конструктором (як в прикладі Rational), або іншим додатковим конструктором, що текстуально іде перед викликаючого конструктора. Нетто-ефект цього правила полягає в тому, що кожний виклик конструктора в Scala раніше чи пізніше завершиться викликом первинного конструктора класа. Первинний конструктор, таким чином, є єдиною точкою входу в клас.</p><h4>Зауваження</h4><p>Якщо ви добре знайомі з Java, ви можете здивуватись, чому правила Scala для конструкторів є дещо більш обмеженними, ніж в Java. В Java конструктор має або викликати інший конструктор того ж класа, або напряму викликати конструктор для суперкласа, в якості першої дії. В класі Scala тільки первинний конструктор може викликати конструктор суперкласа. Підвищене обмеження в Scala насправді є компромісом, на який треба піти, а обмін на більшу стислість та простоту конструкторів Scala, у порівнянні з Java. Суперкласи, та деталі щодо того, як виклик конструктора та наслідування взаємодіють муж собою, буде пояснене в Главі 10.</p><h3>6.8 Приватні поля та методи</h3><p>В попередній версії Rational ми просто ініціалізуєте numer за допомогою n, та denom за допомогою d. Як результат чисельник та займенник Rational можуть бути більші, ніж треба. Наприклад, дріб 66/42 може бути нормалізований до нормалізованої скороченої форми 11/7, але первинний конструктор Rational наразі не робить цього:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(66, 42)
res6: Rational = 66/42</pre>
        <p>Щоб нормалізувати число таким чином, вам треба роділити чисельник та займенник на найбільший загальний дільник. Наприклад, найбільший загальний дільник для 66 та 42 є 6. (Іншими словами, 6 є більшим цілим, що нарівно ділить 66 та 42). Поділівши обоє, чисельник та займенник на 6&nbsp; дасть скорочену форму, 11/7. Лістинг 6.3 показує один зі шляхів, як це зробити:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def add(that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
        <p>Лістинг 6.3 Rational з приватними полем та методом.</p><p>В цій версії Rational ми додаємо приватне поле g, та модифікуємо ініціалізатори numer та denom. (Ініціалізатор є код, що ініціалізує змінну, наприклад, “n / g”, що ініціалізує numer). Оскільки g є приватним, д онього є доступ з середини тіла класа, але не зовні. Ми також додаємо приватний метод, gcd, що обчислює найбільший загальний дільник двох переданих Int. Наприклад, gcd(12, 8) дає 4. Як ви бачили в Розділі 4.1, щоб зробити поле або метод приватними, ви просто ставите ключове слово private перед визначенням. Призначення приватного “допоміжного метода” gcd є виділення кода, що потрібен для деякої іншої частини класа, в данному випадку первинного конструктора. Щоб переконатись, що g є завжди позитивним, ми передає абсолютні значення n та d, що ми отримуємо, викликаючи abs, метод, що ви можете викликати для любого Int для отримання абсолютного значення.</p><p>Компілятор Scala буде розміщувати код для ініціалізаторів трьох полів Rational в первинний конструктор, в тому порядку, як вони з'являються в коді. Таким чином, ініціалізатор g, gcd(n.abs, d.abs), буде викликаний пере іншими двома, оскільки він з'являється першим в початковому коді. В результаті поле g буде ініціалізоване більшим загальним дільником абсолютного значення параметрів класа, n and d. Потім поле g використовується в ініціалізаторів numer та denom. Ділячі n та d на їх більший загальний дільник, g, кожне Rational буде сконструйоване в нормалізованій формі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; new Rational(66, 42)
res7: Rational = 11/7</pre>
        <h3>6.9 Визначення операторів</h3><p>Поточна реалізація додавання Rational є пристойним, але може бути зроблене більш зручним для застосування. Ви можете запитати, чому ми можемо просто записати:</p>
<pre class="prettyprint linenums language-scala">x + y</pre>
        <p>якщо x та y є цілими числами, чи з плаваюсою крапкою, але ми маємо писати:</p>
<pre class="prettyprint linenums language-scala">x.add(y)</pre>
        <p>або щонайменьше:</p>
<pre class="prettyprint linenums language-scala">x add y</pre>
        <p>якщо вони є раціональними числами. Немає переконливого пояснення, чому це має бути саме так. Раціональні числа є числами, так само як будь-які інші. В математичному сенсі вони навіть більш природні, ніж, скажімо, числа з плаваючою крапкою. Чому ви не можете використовувати арифметичні операції з ними? В Scala ви можете це робити. В залишку цієї глави ми покажемо вам, як саме. </p><p>Перший крок є заміна add на звичайний математичний спосіб. Це робиться прямолінійно, бо + є легальним ідентифікатором в Scala. Ми можемо просто визначити метод з + в якості імені. Та коли ми вже беремось до цього, ми також можемо реалізувати метод на ім'я *, що виконує множення. Результат показаний в Лістингу 6.4:</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
      denom * that.denom
    )
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre>
        <p>Лістинг 6.4 Rational з методами-операторами.</p><p>Коил клас Rational визначений в такий спосіб, ви тепер можете записати:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(1, 2)
x: Rational = 1/2
scala&gt; val y = new Rational(2, 3)
y: Rational = 2/3
scala&gt; x + y
res8: Rational = 7/6</pre>
        <p>Як і завжди операторний синтаксис в останньому рядку еквівалентний до виклику метода. Ви також можете записати:</p>
<pre class="prettyprint linenums language-scala">scala&gt; x.+(y)
res9: Rational = 7/6</pre>
        <p>але це не читабельне.</p><p>Інша річ, що треба занотувати, це надані правила Scala до преоритетів операторів, що були описані в Розділі 5.8, метод * буде асоціюватись більш тісно, ніж метод + для Rational. Іншими словами, вирази, що включають оператори + та * над Rational будуть поводитись, як очікується. Наприклад, x + x * y буде виконуватись як x + (x * y), не як (x + x) * y:</p>
<pre class="prettyprint linenums language-scala">scala&gt; x + x * y
res10: Rational = 5/6
scala&gt; (x + x) * y
res11: Rational = 2/3
scala&gt; x + (x * y)
res12: Rational = 5/6</pre>
        <h3>6.10 Ідентифікатори в Scala</h3><p>Тепер ви побачили два найбільш важливі способи сформувати ідентифікатор в Scala: алфавітно-цифровий, та оператори. Scala має дуже гнучки правила для формування ідентифікаторів. Окрім двох форм ви бачили ще два інші. Всі чотири форми формування ідентифікаторів описані в цьому розділі.</p><p>Алфавітно-цифрові ідентифікатори починаються з літери або підкреслення, за якими можуть слідувати літери, цифри або підкреслення. Сивол ‘$’ також вважається за літеру, однак він зарезервований для ідентифікаторів, згенерованих компілятором Scala. Ідентифікатори в користувацьких програмах не повинні містити символи ‘$’, навіть якщо вони компілюються; не дотримання цього може призвести до конфліктів імен з ідентифікаторами, згенерованими компілятором Scala.</p><p>Scala слідує домовленостім Java щодо використання ідентифікаторів в верблюжому реєстрі, таких ,як toString та HashSet. Хоча підкреслення допустимі в ідентифікаторах, вони не так часто використовуються в програмах Scala, частково для узгодженості з Java, але також оскільки підкреслення має багато інших, не-індефікаторних використань в коді Scala. Як результат, краще уникати ідентифікаторів як to_string , __init__ , або name_. Верблюжий реєстр для полів, параметрів методів, локлаьних змінних та функцій повинні починатись з малої літери, наприклад: length , flatMap, та s. Верблюжий реєстр імен класів та трейтів повинні починатись з літери в верхньому реєстрі, наприклад: BigInt , List , та UnbalancedTreeMap.</p><h4>Зауваження</h4><p>Одне зі слідоцтв використання підкреслення в кінці ідентифікатора є те, що коли ви спробуєте написати декларацію такого гатунку<br>“val name_: Int = 1”, ви отримаєте помилку компілятора. Компілятор буде думати, що ви намагаєтесь задекларувати val на ім'я “name_:”. Щоб примусити це компілюватись, вам треба вставити додатковий проміжок перед двома крапками: “val name_ : Int = 1”.</p><p>Одним шляхом, як домовленості Scala відрізняються від Java, включають імена констант. В Scala ключове слово constant означає не тільки val. Навіть зважаючи на те, що val залишаєтся незмінним після ініціалізації, це все ще змінна. Наприклад, параметри метода є val, але кожного разу, коли викликається метод, ці val може містити різні значення. Константи є більш сталими. Наприклад, scala.math.Pi визначене є бути значенням double, найближчим до дійсного значення π, відношення довжини кола до деаметру. Це значення чи навряд колись зміниться, і, таким чином, Pi є дійсною константою. Також ви можете використовувати константи для іменування значень, що в іншому випадку були б магічними числами в вашому коді: літеральні значення без пояснень, що в гіршому випадку з'являються в декількох місцях. Також ви можете побажати визначити константи для використання в співпадіння шаблонів, випадок використання, що буде описаний в Розділі 15.2. В Java по домовленості імена констант отримують імена з великих літер, з підкресленнями для розділення слів, як в MAX_VALUE або PI. В Scala за домовленостю тільки перший символ має бути великою літерою. Таким чином, константи, що названі в стилі Java, такі як X_OFFSET, будуть робити як константи в Scala, але домовленість Scala використовувати верблюжий реєстр для констант, такі як XOffset .</p><p>Ідентифікатори-оператори складаються з одного або більше операторних символів. Операторні символи є друкуємі символи ASCII, такі як + , : , ? , ~ або #. Ось деякі приклади операторних ідентифікаторів:</p>
<pre class="prettyprint linenums language-scala">+
++
:::
&lt;?&gt;
:-&gt;</pre>
        <p>Компілятор Scala буде внутрішньо “підмальовувати” операторні ідентифікатори, щоб перетворити їх на звичайні ідентифікатори Java з вбудованими символвами $. Наприклад, ідентифікатор :-&gt; врутрішньо буде представлений як $colon$minus$greater. Якщо ви бажаєте отримати доступ до такого ідентифікатора з кода Java, вам буде треба використовувати інутрішнє представлення.</p><p>Оскільки операторні ідентифікатори в Scala можуть мати довільну довжину, є мала різниця між Java та Scala. В Java x&lt;-y буде розібране як чотири лексичні символи, так що це буде еквівалентне до x &lt; - y. В Scala <br>&lt;- буде розібране як один ідентифікатор, даючи x &lt;- y. Якщо ви бажаєте першу інтерпретацію, вам треба розділити символи &lt; та - за допомогою проміжка. Це навряд чи буде проблемою на практиці, бо дуже мало людей будуть писати x&lt;-y в Java, без вставки проміжків або дужок між операторами.</p><p>Змішані ідентифікатори складаються з алфавітно-цифрового ідентифікатора, за яким іде підкреслення та операторний ідентифікатор. Наприклад, unary_+використовується як ім'я метода, що визначає оператор +. Або myvar_= використовується як ім'я метода, що визначає оператор присвоєння. На додаток, змішані ідентифікатори в формі myvar_= генеруються компілятором Scala для підтримки властивостей; більше про це ви знайдете в Главі 18.</p><p>Літеральний ідентифікатор є довільним рядком, що заточений в зворотні лапки ( ` . . . ` ). Деякі приклади літеральних ідентифікаторів:</p>
<pre class="prettyprint linenums language-scala">`x`
`&lt;clinit&gt;`
`yield`</pre>
        <p>Ідея полягає в тому, що ви можете покласти любий рядок, що доступний під час виконання, як ідентифікатор між зворотніми лапками. Результатом завжди є ідентифікатор Scala. Це робить навіть якщо ідентифікатор в зворотніх лапках буде зарезервованим словом Scala. Типовий приклад використання є доступ до статичного метода yield в класі Java Thread. Ви не можете написати Thread.yield(), оскільки yield є зарезервованим словом в Scala. Однак ви все ще можете назвати метод в зворотніх лапках, тобтоThread.`yield`() .</p><h3>6.11 Перевантаження методів</h3><p>Повернемось до класа Rational. З останніми змінами тепер ви можете виконувати додавання та множення в природний спосіб на раціональних числах. Але одна річ, що нам бракує, є змішана арифметика. Наприклад, ви не можете множити раціональне число на ціле, оскільки операнди * мають бути Rational. Доки для раціонального числа r ви не можете записати r * 2. Ви маєте записати r * new Rational(2), що не є гарним. Щоб зробити Rational навіть більш зручним, ми додамо нові методи до класа, що виконують змішені додавання та множення на раціональних числах та цілих. Доки ми розглядаємо це, ми додамо методи для віднімання та ділення. Результат показаний в Лістингу 6.5.</p>
<pre class="prettyprint linenums language-scala">class Rational(n: Int, d: Int) {
  require(d != 0)
  private val g = gcd(n.abs, d.abs)
  val numer = n / g
  val denom = d / g
  def this(n: Int) = this(n, 1)
  def + (that: Rational): Rational =
    new Rational(
      numer * that.denom + that.numer * denom,
        denom * that.denom
    )
  def + (i: Int): Rational =
    new Rational(numer + i * denom, denom)
  def - (that: Rational): Rational =
    new Rational(
      numer * that.denom - that.numer * denom,
      denom * that.denom
    )
  def - (i: Int): Rational =
    new Rational(numer - i * denom, denom)
  def * (that: Rational): Rational =
    new Rational(numer * that.numer, denom * that.denom)
  def * (i: Int): Rational =
    new Rational(numer * i, denom)
  def / (that: Rational): Rational =
    new Rational(numer * that.denom, denom * that.numer)
  def / (i: Int): Rational =
    new Rational(numer, denom * i)
  override def toString = numer +"/"+ denom
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}</pre><p>Лістинг 6.5 Rational з перевантаженими методами.</p>

<p>Тепер є дві версії кожної арифметичної операції: одна, що приймає раціональний аргумент, та інший, що приймає ціле. Іншими словами, кожне з ціх імен методів є перевантаженими, оскільки кожне ім'я тепер використовується декількома методами. Наприклад, ім'я + використовується одним методом, що приймає Rational, та інше, що приймає Int. Коли викликається метод компілятор обирає версію перевантаженого метода, що коректно співпадає з типами аргументів. Наприклад, якщо аргумент y в x.+(y) є Rational, компілятор обере метод +, що приймає параметр Rational. Але якщо аргумент ціле, компілятор обере метод, що приймає параметр Int. Якщо ви спробуєте таке:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val x = new Rational(2, 3)
x: Rational = 2/3
scala&gt; x * x
res13: Rational = 4/9
scala&gt; x * 2
res14: Rational = 4/3</pre>
        <p>Ви побачите, що метод *, що викликається в кожному випадку, буде відповідати до типу операнду.</p><h4>Зауваження</h4><p>Процес Scala обробки розрішення перевантажених методів дуже подібний до Java. В жодному випадку обрана перевантажена версія буде та, що найкраще співпадає зі статичними типами аргументів. Іноді немає унікальної кращої співпадаючої версії; в цьому випадку компілятор видасть вам помилку “неоднознозначного посилання”.</p><h3>6.12 Неявні перетворення</h3><p>Тепер, коли ви можете записати&nbsp; r * 2, ви також можете побажати переставити операнди, як в 2 * r. На жаль, це доки не працює:</p>
<pre class="prettyprint linenums language-scala">scala&gt; 2 * r
&lt;console&gt;:7: error: overloaded method value * with
alternatives (Double)Double &lt;and&gt; (Float)Float &lt;and&gt;
(Long)Long &lt;and&gt; (Int)Int &lt;and&gt; (Char)Int &lt;and&gt; (Short)Int
&lt;and&gt; (Byte)Int cannot be applied to (Rational)
2 * r<br>ˆ</pre>
        <p>Тут проблема в тому, що 2 * r еквівалентне до 2.*(r), так що метод викликається на числі 2, яке є цілим. Вле клас Int не має метода множення, що приймає аргумент Rational — він і не може, бо клас Rational не є стандартним класом бібліотеки Scala. </p><p>Але є інший шлях до вирішення цієї проблеми в Scala: ви можете створити неявне перетворення, що автоматично конвертує цілі в раціональні в разі необхідності. Спробуйте додати такий рядок в інтерпретаторі:</p>
<pre class="prettyprint linenums language-scala">scala&gt; implicit def intToRational(x: Int) = new Rational(x)</pre>
        <p>Це додасть метод конвертації з Int до Rational. Модифікатор implicit попереду метода каже компілятору автоматично застосовувати його в деяких ситуаціях. З визначеним перетворенням тепер ви можете спробувати приклад, що раніше давав збій:</p>
<pre class="prettyprint linenums language-scala">scala&gt; val r = new Rational(2,3)
r: Rational = 2/3
scala&gt; 2 * r
res16: Rational = 4/3</pre>
        <p>Зауважте, щоб неявне перетворення робило, воно має бути в полі зору. Якщо ви покладете визначення неявного метода в клас Rational, він не буде в полі зору компілятора. Покі ви маєте визначати його напряму в інтерпретаторі. </p><p>Як може промайнути з цього приклада, неявні перетворення є дуже потужним прийомом, щоб зробити бібліотеки більш гручкими та більш зручними в використанні. Оскільки вони такі потужні, вони можуть бути легко невірно застосовуватись. Ви знайдете більше щодо неявних перетворень, включаючи шляхи по занесенню їх в поле зору, в Главі 21.</p><h3>6.13 Слово попередження</h3><p>Як демонструє ця глава, створення методів з операторними іменами та визначення неявних перетворень можуть допомогти вам розробити бібліотеки, для яких клієнтський код буде стислим та простим для розуміння. Scala надає вам велику потужність розробляти такі прості для використання бібліотеки, але майте на увазі, що ці потужність супроводжується відповідальністю. </p><p>При незграбному використанні обоє, операторні методи та неявні перетворення можуть дати життя клієнтському коду, що буде важко читати та розуміти. Оскільки неявні перетворення неявно застосовуються компілятором, а не явно прописані в коді, може бути неочевидним для програмістів клієнтськох частини, які неявні перетворення будуть застосовані. Та хоча операторні методи будуть звичайно робити клієнтський код більш стислим, вони будуть робити його більш читабельним тільки в тій мірі, доки програмісти будуть розпізнавати та пам'ятати значення кожного оператора.</p><p>Ціль, що ви маєте утримувати на увазі при розробці бібліотек, це не тільки давати стислість клієнтського кода, але також сприяти читабельності та розумінню клієнтського кода. Стислість значною мірою буде частиною цієї читабельності, але ви можете завести цю стислість надто далеко. Розроблюючи бібліотеки, що надають витончено стислий, та, в той же час, зрозумілий клієнтський код, ви можете допомогти продуктивній роботі програмістам клієнтської частини.</p><h3>6.14 Висновок</h3><p>В цій главі ви побачили більше аспектів класів в Scala. Ви побачили, як додавати параметри до класу, визначати декілька конструкторів, визначати оператори як методи, та налаштовувати класи, щоб їх було природно використовувати. Можливо, найбільш важливо, ви побачили, що визначення та використання незмінних об'єктів є досить природним способом кодування в Scala.</p><p>Хоча заключна версія Rational, показана в цьому розділі, задовільняє вимогам, сформульованим на початку цієї глави, вона все ще може бути покращена. Фактично, ми будем оповертатись до цього приклада пізніше в цій книзі. Наприклад, в Главі 30 в инавчитесь, як перекривати equals та hashcode, щоб Rational краще поводились при порівнянні за допомогою ==, або при розміщенні в хеш таблицях. В Главі 21 ви навчитесь, як розміщувати визначення неявних методів в об'єкті-компанйоні Rational, так що ви більш просто зможете заносити його в поле зору, коли програмісти клієнтів будуть робити з Rationals.</p><h4>Глава 7</h4><h3>Built-in Control Structures</h3><p>Scala has only a handful of built-in control structures. The only control struc-<br>tures are if , while , for , try , match , and function calls. The reason Scala<br>has so few is that it has included function literals since its inception. Instead<br>of accumulating one higher-level control structure after another in the base<br>syntax, Scala accumulates them in libraries. Chapter 9 will show precisely<br>how that is done. This chapter will show those few control structures that are<br>built in.</p><p>One thing you will notice is that almost all of Scala’s control structures<br>result in some value. This is the approach taken by functional languages, in<br>which programs are viewed as computing a value, thus the components of a<br>program should also compute values. You can also view this approach as the<br>logical conclusion of a trend already present in imperative languages. In im-<br>perative languages, function calls can return a value, even though having the<br>called function update an output variable passed as an argument would work<br>just as well. In addition, imperative languages often have a ternary operator<br>(such as the ?: operator of C, C++, and Java), which behaves exactly like<br>if , but results in a value. Scala adopts this ternary operator model, but calls<br>it if . In other words, Scala’s if can result in a value. Scala then continues<br>this trend by having for , try , and match also result in values.<br>Programmers can use these result values to simplify their code, just as<br>they use return values of functions. Without this facility, the programmer<br>must create temporary variables just to hold results that are calculated inside<br>a control structure. Removing these temporary variables makes the code a<br>little simpler, and it also prevents many bugs where you set the variable in<br>one branch but forget to set it in another.</p><p>Overall, Scala’s basic control structures, minimal as they are, are suffi-<br>cient to provide all of the essentials from imperative languages. Further, they<br>allow you to shorten your code by consistently having result values. To show<br>you how all of this works, this chapter takes a closer look at each of Scala’s<br>basic control structures.</p><h3>7.1 If expressions</h3><p>Scala’s if works just like in many other languages. It tests a condition and<br>then executes one of two code branches depending on whether the condition<br>holds true. Here is a common example, written in an imperative style:</p><p>var filename = "default.txt"<br>if (!args.isEmpty)<br>filename = args(0)</p><p>This code declares a variable, filename , and initializes it to a default value.<br>It then uses an if expression to check whether any arguments were supplied<br>to the program. If so, it changes the variable to hold the value specified in<br>the argument list. If no arguments were supplied, it leaves the variable set to<br>the default value.</p><p>This code can be written more nicely, because as mentioned in Step 3<br>in Chapter 2, Scala’s if is an expression that results in a value. Listing 7.1<br>shows how you can accomplish the same effect as the previous example, but<br>without using any var s:</p><p>val filename =<br>if (!args.isEmpty) args(0)<br>else "default.txt"</p><p>Listing 7.1 · Scala’s idiom for conditional initialization.</p><p>This time, the if has two branches. If args is not empty, the initial<br>element, args(0) , is chosen. Else, the default value is chosen. The if ex-<br>pression results in the chosen value, and the filename variable is initialized<br>with that value. This code is slightly shorter, but its real advantage is that it<br>uses a val instead of a var . Using a val is the functional style, and it helps<br>you in much the same way as a final variable in Java. It tells readers of the code that the variable will never change, saving them from scanning all code<br>in the variable’s scope to see if it ever changes.</p><p>A second advantage to using a val instead of a var is that it better sup-<br>ports equational reasoning. The introduced variable is equal to the expres-<br>sion that computes it, assuming that expression has no side effects. Thus,<br>any time you are about to write the variable name, you could instead write<br>the expression. Instead of println(filename) , for example, you could just<br>as well write this:</p><p>println(if (!args.isEmpty) args(0) else "default.txt")</p><p>The choice is yours. You can write it either way. Using val s helps you safely<br>make this kind of refactoring as your code evolves over time.<br>Look for opportunities to use val s. They can make your<br>code both easier to read and easier to refactor.</p><h3>7.2 While loops</h3><p>Scala’s while loop behaves as in other languages. It has a condition and a<br>body, and the body is executed over and over as long as the condition holds<br>true. Listing 7.2 shows an example:</p><p>def gcdLoop(x: Long, y: Long): Long = {<br>var a = x<br>var b = y<br>while (a != 0) {<br>val temp = a<br>a = b % a<br>b = temp<br>}<br>b<br>}</p><p>Scala also has a do - while loop. This works like the while loop except<br>that it tests the condition after the loop body instead of before. Listing 7.3<br>shows a Scala script that uses a do-while to echo lines read from the stan-<br>dard input, until an empty line is entered:</p><p>var line = ""<br>do {<br>line = readLine()<br>println("Read: "+ line)<br>} while (line != "")</p><p>Listing 7.3 · Reading from the standard input with do-while .</p><p>The while and do-while constructs are called “loops,” not expressions,<br>because they don’t result in an interesting value. The type of the result is<br>Unit . It turns out that a value (and in fact, only one value) exists whose type<br>is Unit . It is called the unit value and is written () . The existence of () is<br>how Scala’s Unit differs from Java’s void . Try this in the interpreter:</p><p>scala&gt; def greet() { println("hi") }<br>greet: ()Unit<br>scala&gt; greet() == ()<br>hi<br>res0: Boolean = true</p><p>Because no equals sign precedes its body, greet is defined to be a procedure with a result type of Unit . Therefore, greet returns the unit value, () .<br>This is confirmed in the next line: comparing the greet ’s result for equality<br>with the unit value, () , yields true .</p><p>One other construct that results in the unit value, which is relevant here,<br>is reassignment to var s. For example, were you to attempt to read lines in<br>Scala using the following while loop idiom from Java (and C and C++),<br>you’ll run into trouble:</p><p>var line = ""<br>while ((line = readLine()) != "") // This doesn’t work!<br>println("Read: "+ line)</p><p>When you compile this code, Scala will give you a warning that comparing<br>values of type Unit and String using != will always yield true. Whereas<br>in Java, assignment results in the value assigned, in this case a line from<br>the standard input, in Scala assignment always results in the unit value, () .<br>Thus, the value of the assignment “ line = readLine() ” will always be ()<br>and never be "" . As a result, this while loop’s condition will never be false,<br>and the loop will, therefore, never terminate.</p><p>Because the while loop results in no value, it is often left out of pure<br>functional languages. Such languages have expressions, not loops. Scala<br>includes the while loop nonetheless, because sometimes an imperative solu-<br>tion can be more readable, especially to programmers with a predominantly<br>imperative background. For example, if you want to code an algorithm that<br>repeats a process until some condition changes, a while loop can express it<br>directly while the functional alternative, which likely uses recursion, may be<br>less obvious to some readers of the code.</p><p>For example, Listing 7.4 shows an alternate way to determine a greatest<br>common divisor of two numbers. 1 Given the same two values for x and<br>y , the gcd function shown in Listing 7.4 will return the same result as the<br>gcdLoop function, shown in Listing 7.2. The difference between these two<br>approaches is that gcdLoop is written in an imperative style, using var s and<br>and a while loop, whereas gcd is written in a more functional style that<br>involves recursion ( gcd calls itself) and requires no var s.</p><p>def gcd(x: Long, y: Long): Long =<br>if (y == 0) x else gcd(y, x % y)</p><p>Listing 7.4 · Calculating greatest common divisor with recursion.</p><p>In general, we recommend you challenge while loops in your code in the<br>same way you challenge var s. In fact, while loops and var s often go hand<br>in hand. Because while loops don’t result in a value, to make any kind of<br>difference to your program, a while loop will usually either need to update<br>var s or perform I/O. You can see this in action in the gcdLoop example<br>shown previously. As that while loop does its business, it updates var s a<br>and b . Thus, we suggest you be a bit suspicious of while loops in your code. If there isn’t a good justification for a particular while or do-while loop,<br>try to find a way to do the same thing without it.</p><h3>7.3 For expressions</h3><p>Scala’s for expression is a Swiss army knife of iteration. It lets you combine<br>a few simple ingredients in different ways to express a wide variety of itera-<br>tions. Simple uses enable common tasks such as iterating through a sequence<br>of integers. More advanced expressions can iterate over multiple collections<br>of different kinds, can filter out elements based on arbitrary conditions, and<br>can produce new collections.</p><h4>Iteration through collections</h4><p>The simplest thing you can do with for is to iterate through all the elements<br>of a collection. For example, Listing 7.5 shows some code that prints out<br>all files in the current directory. The I/O is performed using the Java API.<br>First, we create a java.io.File on the current directory, "." , and call its<br>listFiles method. This method returns an array of File objects, one per<br>directory and file contained in the current directory. We store the resulting<br>array in the filesHere variable.</p><p>val filesHere = (new java.io.File(".")).listFiles<br>for (file &lt;- filesHere)<br>println(file)</p><p>Listing 7.5 · Listing files in a directory with a for expression.</p><p>With the “ file &lt;- filesHere ” syntax, which is called a generator, we<br>iterate through the elements of filesHere . In each iteration, a new val<br>named file is initialized with an element value. The compiler infers the<br>type of file to be File , because filesHere is an Array[File] . For each<br>iteration, the body of the for expression, println(file) , will be executed.<br>Because File ’s toString method yields the name of the file or directory, the<br>names of all the files and directories in the current directory will be printed.<br>The for expression syntax works for any kind of collection, not just<br>arrays. 2 One convenient special case is the Range type, which you briefly saw in Table 5.4 on page 138. You can create Range s using syntax like “1 to 5” and can iterate through them with a for . Here is a simple example:</p><p>scala&gt; for (i &lt;- 1 to 4)<br>println("Iteration "+ i)<br>Iteration 1<br>Iteration 2<br>Iteration 3<br>Iteration 4</p><p>If you don’t want to include the upper bound of the range in the values that<br>are iterated over, use until instead of to :</p><p>scala&gt; for (i &lt;- 1 until 4)<br>println("Iteration "+ i)<br>Iteration 1<br>Iteration 2<br>Iteration 3</p><p>Iterating through integers like this is common in Scala, but not nearly as<br>much as in other languages. In other languages, you might use this facility<br>to iterate through an array, like this:</p><p>// Not common in Scala...<br>for (i &lt;- 0 to filesHere.length - 1)<br>println(filesHere(i))</p><p>This for expression introduces a variable i , sets it in turn to each integer<br>between 0 and filesHere.length - 1 , and executes the body of the for<br>expression for each setting of i . For each setting of i , the i ’th element of<br>filesHere is extracted and processed.</p><p>The reason this kind of iteration is less common in Scala is that you can<br>just as well iterate over the collection directly. If you do, your code becomes<br>shorter and you sidestep many of the off-by-one errors that can arise when<br>iterating through arrays. Should you start at 0 or 1? Should you add -1, +1,<br>or nothing to the final index? Such questions are easily answered, but easily<br>answered wrongly. It is safer to avoid such questions entirely.</p><h4>Filtering</h4><p>Sometimes you do not want to iterate through a collection in its entirety. You<br>want to filter it down to some subset. You can do this with a for expression<br>by adding a filter: an if clause inside the for ’s parentheses. For example,<br>the code shown in Listing 7.6 lists only those files in the current directory<br>whose names end with “ .scala ”:</p><p>val filesHere = (new java.io.File(".")).listFiles<br>for (file &lt;- filesHere if file.getName.endsWith(".scala"))<br>println(file)<br>Listing 7.6 · Finding .scala files using a for with a filter.<br>You could alternatively accomplish the same goal with this code:<br>for (file &lt;- filesHere)<br>if (file.getName.endsWith(".scala"))<br>println(file)</p><p>This code yields the same output as the previous code, and likely looks more<br>familiar to programmers with an imperative background. The imperative<br>form, however, is only an option because this particular for expression is<br>executed for its printing side-effects and results in the unit value () . As<br>will be demonstrated later in this section, the for expression is called an<br>“expression” because it can result in an interesting value, a collection whose<br>type is determined by the for expression’s &lt;- clauses.<br>You can include more filters if you want. Just keep adding if clauses.<br>For example, to be extra defensive, the code in Listing 7.7 prints only files<br>and not directories. It does so by adding a filter that checks the file ’s<br>isFile method.</p><p>for (<br>file &lt;- filesHere<br>if file.isFile<br>if file.getName.endsWith(".scala")<br>) println(file)</p><p>Listing 7.7 · Using multiple filters in a for expression.</p><h4>Nested iteration</h4><p>If you add multiple &lt;- clauses, you will get nested “loops.” For exam-<br>ple, the for expression shown in Listing 7.8 has two nested loops. The<br>outer loop iterates through filesHere , and the inner loop iterates through<br>fileLines(file) for any file that ends with .scala .</p><p><br>def fileLines(file: java.io.File) =<br>scala.io.Source.fromFile(file).getLines().toList<br>def grep(pattern: String) =<br>for (<br>file &lt;- filesHere<br>if file.getName.endsWith(".scala");<br>line &lt;- fileLines(file)<br>if line.trim.matches(pattern)<br>) println(file +": "+ line.trim)<br>grep(".*gcd.*")</p><p>Listing 7.8 · Using multiple generators in a for expression.</p><p>If you prefer, you can use curly braces instead of parentheses to surround<br>the generators and filters. One advantage to using curly braces is that you can<br>leave off some of the semicolons that are needed when you use parentheses,<br>because as explained in Section 4.2, the Scala compiler will not infer semi-<br>colons while inside parentheses.</p><h4>Mid-stream variable bindings</h4><p>Note that the previous code repeats the expression line.trim . This is a<br>non-trivial computation, so you might want to only compute it once. You<br>can do this by binding the result to a new variable using an equals sign ( = ).<br>The bound variable is introduced and used just like a val , only with the val<br>keyword left out. Listing 7.9 shows an example.<br>In Listing 7.9, a variable named trimmed is introduced halfway through<br>the for expression. That variable is initialized to the result of line.trim .<br>The rest of the for expression then uses the new variable in two places, once<br>in an if and once in println .</p><p>def grep(pattern: String) =<br>for {<br>file &lt;- filesHere<br>if file.getName.endsWith(".scala")<br>line &lt;- fileLines(file)<br>trimmed = line.trim<br>if trimmed.matches(pattern)<br>} println(file +": "+ trimmed)<br>grep(".*gcd.*")</p><p>Listing 7.9 · Mid-stream assignment in a for expression.</p><h4>Producing a new collection</h4><p>While all of the examples so far have operated on the iterated values and then<br>forgotten them, you can also generate a value to remember for each iteration.<br>To do so, you prefix the body of the for expression by the keyword yield .<br>For example, here is a function that identifies the .scala files and stores<br>them in an array:</p><p>def scalaFiles =<br>for {<br>file &lt;- filesHere<br>if file.getName.endsWith(".scala")<br>} yield file</p><p>Each time the body of the for expression executes it produces one value,<br>in this case simply file . When the for expression completes, the result<br>will include all of the yielded values contained in a single collection. The<br>type of the resulting collection is based on the kind of collections processed<br>in the iteration clauses. In this case the result is an Array[File] , because<br>filesHere is an array and the type of the yielded expression is File .<br>Be careful, by the way, where you place the yield keyword. The syntax<br>of a for - yield expression is like this:</p><p>for clauses yield body</p><p>The yield goes before the entire body. Even if the body is a block sur-<br>rounded by curly braces, put the yield before the first curly brace, not before the last expression of the block. Avoid the temptation to write things<br>like this:</p><p>for (file &lt;- filesHere if file.getName.endsWith(".scala")) {<br>yield file<br>// Syntax error!<br>}</p><p>For example, the for expression shown in Listing 7.10 first transforms<br>the Array[File] named filesHere , which contains all files in the current<br>directory, to one that contains only .scala files. For each of these it gen-<br>erates an Iterator[String] (the result of the fileLines method, whose<br>definition is shown in Listing 7.8). An Iterator offers methods next and<br>hasNext that allow you to iterate over a collection of elements. This ini-<br>tial iterator is transformed into another Iterator[String] containing only<br>trimmed lines that include the substring "for" . Finally, for each of these, an<br>integer length is yielded. The result of this for expression is an Array[Int]<br>containing those lengths.</p><p>val forLineLengths =<br>for {<br>file &lt;- filesHere<br>if file.getName.endsWith(".scala")<br>line &lt;- fileLines(file)<br>trimmed = line.trim<br>if trimmed.matches(".*for.*")<br>} yield trimmed.length</p><p>Listing 7.10 · Transforming an Array[File] to Array[Int] with a for .</p><p>At this point, you have seen all the major features of Scala’s for ex-<br>pression. This section went through them rather quickly, however. A more<br>thorough coverage of for expressions is given in Chapter 23.</p><h3>7.4 Exception handling with try expressions</h3><p>Scala’s exceptions behave just like in many other languages. Instead of re-<br>turning a value in the normal way, a method can terminate by throwing an<br>exception. The method’s caller can either catch and handle that exception, or it can itself simply terminate, in which case the exception propagates to the caller’s caller. The exception propagates in this way, unwinding the call stack, until a method handles it or there are no more methods left.</p><h4>Throwing exceptions</h4><p>Throwing an exception looks the same as in Java. You create an exception<br>object and then you throw it with the throw keyword:<br>throw new IllegalArgumentException<br>Although it may seem somewhat paradoxical, in Scala, throw is an ex-<br>pression that has a result type. Here is an example in which that result type<br>matters:</p><p>val half =<br>if (n % 2 == 0)<br>n / 2<br>else<br>throw new RuntimeException("n must be even")</p><p>What happens here is that if n is even, half will be initialized to half of n .<br>If n is not even, an exception will be thrown before half can be initialized<br>to anything at all. Because of this, it is safe to treat a thrown exception as<br>any kind of value whatsoever. Any context that tries to use the return from a<br>throw will never get to do so, and thus no harm will come.<br>Technically, an exception throw has type Nothing . You can use a throw<br>as an expression even though it will never actually evaluate to anything. This<br>little bit of technical gymnastics might sound weird, but is frequently useful<br>in cases like the previous example. One branch of an if computes a value,<br>while the other throws an exception and computes Nothing . The type of<br>the whole if expression is then the type of that branch which does compute<br>something. Type Nothing is discussed further in Section 11.3.</p><h4>Catching exceptions</h4><p>You catch exceptions using the syntax shown in Listing 7.11 The syntax for<br>catch clauses was chosen for its consistency with an important part of Scala:<br>pattern matching. Pattern matching, a powerful feature, is described briefly<br>in this chapter and in more detail in Chapter 15.</p><p>import java.io.FileReader<br>import java.io.FileNotFoundException<br>import java.io.IOException<br>try {<br>val f = new FileReader("input.txt")<br>// Use and close file<br>} catch {<br>case ex: FileNotFoundException =&gt; // Handle missing file<br>case ex: IOException =&gt; // Handle other I/O error<br>}</p><p>Listing 7.11 · A try-catch clause in Scala.</p><p>The behavior of this try - catch expression is the same as in other lan-<br>guages with exceptions. The body is executed, and if it throws an exception,<br>each catch clause is tried in turn. In this example, if the exception is of<br>type FileNotFoundException , the first clause will execute. If it is of type<br>IOException , the second clause will execute. If the exception is of neither<br>type, the try - catch will terminate and the exception will propagate further.</p><h4>Note</h4><p>One difference from Java that you’ll quickly notice in Scala is that unlike<br>Java, Scala does not require you to catch checked exceptions, or declare<br>them in a throws clause. You can declare a throws clause if you wish with<br>the @throws annotation, but it is not required. See Section 31.2 for more<br>information on @throws .</p><h4>The finally clause</h4><p>You can wrap an expression with a finally clause if you want to cause some<br>code to execute no matter how the expression terminates. For example, you<br>might want to be sure an open file gets closed even if a method exits by<br>throwing an exception. Listing 7.12 shows an example.</p><p>import java.io.FileReader<br>val file = new FileReader("input.txt")<br>try {<br>// Use the file<br>} finally {<br>file.close()<br>// Be sure to close the file<br>}</p><p>Listing 7.12 · A try-finally clause in Scala.</p><h4>Note</h4><p>Listing 7.12 shows the idiomatic way to ensure a non-memory resource,<br>such as a file, socket, or database connection is closed. First you acquire<br>the resource. Then you start a try block in which you use the resource.<br>Lastly, you close the resource in a finally block. This idiom is the same<br>in Scala as in Java, however, in Scala you can alternatively employ a<br>technique called the loan pattern to achieve the same goal more concisely.<br>The loan pattern will be described in Section 9.4.</p><h4>Yielding a value</h4><p>As with most other Scala control structures, try - catch - finally results in<br>a value. For example, Listing 7.13 shows how you can try to parse a URL<br>but use a default value if the URL is badly formed. The result is that of<br>the try clause if no exception is thrown, or the relevant catch clause if an<br>exception is thrown and caught. If an exception is thrown but not caught, the<br>expression has no result at all. The value computed in the finally clause, if<br>there is one, is dropped. Usually finally clauses do some kind of clean up<br>such as closing a file; they should not normally change the value computed<br>in the main body or a catch clause of the try .<br>If you’re familiar with Java, it’s worth noting that Scala’s behavior differs<br>from Java only because Java’s try-finally does not result in a value. As<br>in Java, if a finally clause includes an explicit return statement, or throws<br>an exception, that return value or exception will “overrule” any previous one<br>that originated in the try block or one of its catch clauses. For example,<br>given this, rather contrived, function definition:</p><p>def f(): Int = try { return 1 } finally { return 2 }</p><p>import java.net.URL<br>import java.net.MalformedURLException<br>def urlFor(path: String) =<br>try {<br>new URL(path)<br>} catch {<br>case e: MalformedURLException =&gt;<br>new URL("http://www.scala-lang.org")<br>}</p><p>Listing 7.13 · A catch clause that yields a value.</p><p>calling f() results in 2. By contrast, given:</p><p>def g(): Int = try { 1 } finally { 2 }</p><p>calling g() results in 1. Both of these functions exhibit behavior that could<br>surprise most programmers, thus it’s usually best to avoid returning values<br>from finally clauses. The best way to think of finally clauses is as a way<br>to ensure some side effect happens, such as closing an open file.</p><h3>7.5 Match expressions</h3><p>Scala’s match expression lets you select from a number of alternatives, just<br>like switch statements in other languages. In general a match expression<br>lets you select using arbitrary patterns, which will be described in Chap-<br>ter 15. The general form can wait. For now, just consider using match to<br>select among a number of alternatives.</p><p>As an example, the script in Listing 7.14 reads a food name from the<br>argument list and prints a companion to that food. This match expression<br>examines firstArg , which has been set to the first argument out of the ar-<br>gument list. If it is the string "salt" , it prints "pepper" , while if it is the<br>string "chips" , it prints "salsa" , and so on. The default case is speci-<br>fied with an underscore ( _ ), a wildcard symbol frequently used in Scala as a<br>placeholder for a completely unknown value.</p><p>There are a few important differences from Java’s switch statement.<br>One is that any kind of constant, as well as other things, can be used in</p><p>val firstArg = if (args.length &gt; 0) args(0) else ""<br>firstArg match {<br>case "salt" =&gt; println("pepper")<br>case "chips" =&gt; println("salsa")<br>case "eggs" =&gt; println("bacon")<br>case _ =&gt; println("huh?")<br>}</p><p>Listing 7.14 · A match expression with side effects.</p><p>cases in Scala, not just the integer-type and enum constants of Java’s case<br>statements. In Listing 7.14, the alternatives are strings. Another difference<br>is that there are no break s at the end of each alternative. Instead the break<br>is implicit, and there is no fall through from one alternative to the next. The<br>common case—not falling through—becomes shorter, and a source of errors<br>is avoided because programmers can no longer fall through by accident.<br>The most significant difference from Java’s switch , however, may be<br>that match expressions result in a value. In the previous example, each al-<br>ternative in the match expression prints out a value. It would work just as<br>well to yield the value rather than printing it, as shown in Listing 7.15. The<br>value that results from this match expression is stored in the friend vari-<br>able. Aside from the code getting shorter (in number of tokens, anyway),<br>the code now disentangles two separate concerns: first it chooses a food, and<br>then it prints it.</p><p>val firstArg = if (!args.isEmpty) args(0) else ""<br>val friend =<br>firstArg match {<br>case "salt" =&gt; "pepper"<br>case "chips" =&gt; "salsa"<br>case "eggs" =&gt; "bacon"<br>case _ =&gt; "huh?"<br>}<br>println(friend)<br>Listing 7.15 · A match expression that yields a value.</p><h3>7.6 Living without break and continue</h3><p>You may have noticed that there has been no mention of break or continue .<br>Scala leaves out these commands because they do not mesh well with func-<br>tion literals, a feature described in the next chapter. It is clear what continue<br>means inside a while loop, but what would it mean inside a function literal?<br>While Scala supports both imperative and functional styles of programming,<br>in this case it leans slightly towards functional programming in exchange<br>for simplifying the language. Do not worry, though. There are many ways to<br>program without break and continue , and if you take advantage of function<br>literals, those alternatives can often be shorter than the original code.<br>The simplest approach is to replace every continue by an if and ev-<br>ery break by a boolean variable. The boolean variable indicates whether<br>the enclosing while loop should continue. For example, suppose you are<br>searching through an argument list for a string that ends with “ .scala ” but<br>does not start with a hyphen. In Java you could—if you were quite fond of<br>while loops, break , and continue —write the following:</p><p>int i = 0;<br>// This is Java<br>boolean foundIt = false;<br>while (i &lt; args.length) {<br>if (args[i].startsWith("-")) {<br>i = i + 1;<br>continue;<br>}<br>if (args[i].endsWith(".scala")) {<br>foundIt = true;<br>break;<br>}<br>i = i + 1;<br>}</p><p>To transliterate this Java code directly to Scala, instead of doing an if<br>and then a continue , you could write an if that surrounds the entire re-<br>mainder of the while loop. To get rid of the break , you would normally<br>add a boolean variable indicating whether to keep going, but in this case you<br>can reuse foundIt . Using both of these tricks, the code ends up looking as<br>shown in Listing 7.16.</p>var i = 0<br>var foundIt = false<br>while (i &lt; args.length &amp;&amp; !foundIt) {<br>if (!args(i).startsWith("-")) {<br>if (args(i).endsWith(".scala"))<br>foundIt = true<br>}<br>i = i + 1<br>}<br><br>Listing 7.16 · Looping without break or continue .<br><br>This Scala code in Listing 7.16 is quite similar to the original Java code.<br>All the basic pieces are still there and in the same order. There are two<br>reassignable variables and a while loop. Inside the loop, there is a test that<br>i is less than args.length , a check for "-" , and a check for ".scala" .<br>If you wanted to get rid of the var s in Listing 7.16, one approach you<br>could try is to rewrite the loop as a recursive function. You could, for exam-<br>ple, define a searchFrom function that takes an integer as an input, searches<br>forward from there, and then returns the index of the desired argument. Us-<br>ing this technique the code would look as shown in Listing 7.17:<br><br>def searchFrom(i: Int): Int =<br>if (i &gt;= args.length) -1<br>else if (args(i).startsWith("-")) searchFrom(i + 1)<br>else if (args(i).endsWith(".scala")) i<br>else searchFrom(i + 1)<br>val i = searchFrom(0)<br><br>Listing 7.17 · A recursive alternative to looping with var s.<br><br>The version in Listing 7.17 gives a human-meaningful name to what the<br>function does, and it uses recursion to substitute for looping. Each continue<br>is replaced by a recursive call with i + 1 as the argument, effectively skipping<br>to the next integer. Many people find this style of programming easier to<br>understand, once they get used to the recursion.<br><h4>Note</h4>The Scala compiler will not actually emit a recursive function for the code<br>shown in Listing 7.17. Because all of the recursive calls are in tail-call<br>position, the compiler will generate code similar to a while loop. Each<br>recursive call will be implemented as a jump back to the beginning of the<br>function. Tail-call optimization will be discussed in Section 8.9.<br>If after all this discussion you still feel the need to use break , there’s help<br>in Scala’s standard library. Class Breaks in package scala.util.control<br>offers a break method, which can be used to exit the an enclosing block<br>that’s marked with breakable . Here an example how this library-supplied<br>break method could be applied:<br><br>import scala.util.control.Breaks._<br>import java.io._<br>val in = new BufferedReader(new InputStreamReader(System.in))<br>breakable {<br>while (true) {<br>println("? ")<br>if (in.readLine() == "") break<br>}<br>}<br><br>This will repeatedly read non-empty lines from the standard input. Once the<br>user enters an empty line, control flow exits from the enclosing breakable ,<br>and with it the while loop. The Breaks class implements break by throwing an exception that is caught by an enclosing application of the breakable method. Therefore, the call to break does not need to be in the same method as the call to breakable .<br><h3>7.7 Variable scope</h3>Now that you’ve seen Scala’s built-in control structures, we’ll use them in<br>this section to explain how scoping works in Scala.<br><br><h4>Швидка орієнтація для Java програмістів</h4>If you’re a Java programmer, you’ll find that Scala’s scoping rules are<br>almost identical to Java’s. One difference between Java and Scala exists,<br>however, in that Scala allows you to define variables of the same name in<br>nested scopes. If you’re a Java programmer, therefore, you may wish to at<br>least skim this section.<br><br>Variable declarations in Scala programs have a scope that defines where<br>you can use the name. The most common example of scoping is that curly<br>braces generally introduce a new scope, so anything defined inside curly<br>braces leaves scope after the final closing brace. 3 As an illustration, consider<br>the function shown in Listing 7.18.<br><br>The printMultiTable function shown in Listing 7.18 prints out a mul-<br>tiplication table. 4 The first statement of this function introduces a variable<br>named i and initializes it to the integer 1. You can then use the name i for<br>the remainder of the function.<br><br>The next statement in printMultiTable is a while loop:<br><br>while (i &lt;= 10) {<br>var j = 1<br>...<br>}<br><br>You can use i here because it is still in scope. In the first statement inside that<br>while loop, you introduce another variable, this time named j , and again<br>initialize it to 1. Because the variable j was defined inside the open curly<br>brace of the while loop, it can be used only within that while loop. If you<br>were to attempt to do something with j after the closing curly brace of this<br>while loop, after the comment that says j , prod , and k are out of scope,<br>your program would not compile.<br><br>All variables defined in this example— i , j , prod , and k —are local vari-<br>ables. Such variables are “local” to the function in which they are defined.<br>Each time a function is invoked, a new set of its local variables is used.<br><br>def printMultiTable() {<br>var i = 1<br>// only i in scope here<br>while (i &lt;= 10) {<br>var j = 1<br>// both i and j in scope here<br>while (j &lt;= 10) {<br>val prod = (i * j).toString<br>// i, j, and prod in scope here<br>var k = prod.length<br>// i, j, prod, and k in scope here<br>while (k &lt; 4) {<br>print(" ")<br>k += 1<br>}<br>print(prod)<br>j += 1<br>}<br>// i and j still in scope; prod and k out of scope<br>println()<br>i += 1<br>}<br>// i still in scope; j, prod, and k out of scope<br>}<br><br>Listing 7.18 · Variable scoping when printing a multiplication table.<br><br>Once a variable is defined, you can’t define a new variable with the same<br>name in the same scope. For example, the following script with two variables<br>named a in the same scope would not compile:<br><br>val a = 1<br>val a = 2 // Does not compile<br>println(a)<br><br>You can, on the other hand, define a variable in an inner scope that has the<br>same name as a variable in an outer scope. The following script would com-<br>pile and run:<br><br>val a = 1;<br>{<br>val a = 2 // Compiles just fine<br>println(a)<br>}<br>println(a)<br><br>When executed, the script shown previously would print 2 then 1, because<br>the a defined inside the curly braces is a different variable, which is in scope<br>only until the closing curly brace. 5 One difference to note between Scala and<br>Java is that unlike Scala, Java will not let you create a variable in an inner<br>scope that has the same name as a variable in an outer scope. In a Scala<br>program, an inner variable is said to shadow a like-named outer variable,<br>because the outer variable becomes invisible in the inner scope.<br>You might have already noticed something that looks like shadowing in<br>the interpreter:<br><br>scala&gt; val a = 1<br>a: Int = 1<br>scala&gt; val a = 2<br>a: Int = 2<br>scala&gt; println(a)<br>2<br><br>In the interpreter, you can reuse variable names to your heart’s content.<br>Among other things, this allows you to change your mind if you made a<br>mistake when you defined a variable the first time in the interpreter. The rea-<br>son you can do this is that, conceptually, the interpreter creates a new nested<br>scope for each new statement you type in. Thus, you could visualize the<br>previous interpreted code like this:<br><br>val a = 1;<br>{<br>val a = 2;<br>{<br>println(a)<br>}<br>}<br><br>This code will compile and run as a Scala script, and like the code typed<br>into the interpreter, will print 2. Keep in mind that such code can be very<br>confusing to readers, because variable names adopt new meanings in nested<br>scopes. It is usually better to choose a new, meaningful variable name rather<br>than to shadow an outer variable.<br><br><h3>7.8 Refactoring imperative-style code</h3><br>To help you gain insight into the functional style, in this section we’ll refac-<br>tor the imperative approach to printing a multiplication table shown in List-<br>ing 7.18. Our functional alternative is shown in Listing 7.19.<br>The imperative style reveals itself in Listing 7.18 in two ways. First,<br>invoking printMultiTable has a side effect: printing a multiplication ta-<br>ble to the standard output. In Listing 7.19, we refactored the function so<br>that it returns the multiplication table as a string. Since the function no<br>longer prints, we renamed it multiTable . As mentioned previously, one<br>advantage of side-effect-free functions is they are easier to unit test. To<br>test printMultiTable , you would need to somehow redefine print and<br>println so you could check the output for correctness. You could test<br>multiTable more easily, by checking its string result.<br>The other telltale sign of the imperative style in printMultiTable is its<br>while loop and var s. By contrast, the multiTable function uses val s, for<br>expressions, helper functions, and calls to mkString .<br><br>// Returns a row as a sequence<br>def makeRowSeq(row: Int) =<br>for (col &lt;- 1 to 10) yield {<br>val prod = (row * col).toString<br>val padding = " " * (4 - prod.length)<br>padding + prod<br>}<br>// Returns a row as a string<br>def makeRow(row: Int) = makeRowSeq(row).mkString<br>// Returns table as a string with one row per line<br>def multiTable() = {<br>val tableSeq = // a sequence of row strings<br>for (row &lt;- 1 to 10)<br>yield makeRow(row)<br>tableSeq.mkString("\n")<br>}<br><br>Listing 7.19 · A functional way to create a multiplication table.<br><br>We factored out the two helper functions, makeRow and makeRowSeq , to<br>make the code easier to read. Function makeRowSeq uses a for expression<br>whose generator iterates through column numbers 1 through 10. The body of<br>this for calculates the product of row and column, determines the padding<br>needed for the product, and yields the result of concatenating the padding<br>and product strings. The result of the for expression will be a sequence<br>(some subclass of scala.Seq ) containing these yielded strings as elements.<br>The other helper function, makeRow , simply invokes mkString on the re-<br>sult returned by makeRowSeq . mkString will concatenate the strings in the<br>sequence and return them as one string.<br><br>The multiTable method first initializes tableSeq with the result of a<br>for expression whose generator iterates through row numbers 1 to 10, and<br>for each calls makeRow to get the string for that row. This string is yielded,<br>thus the result of this for expression will be a sequence of row strings. The<br>only remaining task is to convert the sequence of strings into a single string.<br>The call to mkString accomplishes this, and because we pass "\n" , we get<br>an end of line character inserted between each string. If you pass the string<br>returned by multiTable to println , you’ll see the same output that’s pro-<br>duced by calling printMultiTable:<br><br>1&nbsp; &nbsp; 2&nbsp;&nbsp; 3 &nbsp; 4 &nbsp; 5 &nbsp; 6 &nbsp; 7 &nbsp; 8 &nbsp; 9&nbsp; 10 <br>2&nbsp; &nbsp; 4 &nbsp; 6 &nbsp; 8&nbsp; 10 12 14 16 18 20<br>3 &nbsp;&nbsp; 6&nbsp;&nbsp; 9&nbsp; 12 15 18 21 24 27 30 &nbsp; <br>4&nbsp;&nbsp;&nbsp; 8&nbsp; 12 16 20 24 28 32 36 40 <br>5&nbsp;&nbsp; 10 15 20 25 <br>6 &nbsp; 12 18 24 30<br>7&nbsp;&nbsp; 14 21 28 35<br>8 &nbsp; 16 24 32 40<br>9&nbsp;&nbsp; 18 27 36 45 <br>10 20 30 40 50 60 70 80 90 100<br><h3>Conclusion</h3>Scala’s built-in control structures are minimal, but they do the job. They<br>act much like their imperative equivalents, but because they tend to result<br>in a value, they support a functional style, too. Just as important, they are<br>careful in what they omit, thus leaving room for one of Scala’s most powerful<br>features, the function literal, which will be described in the next chapter.</body></html>