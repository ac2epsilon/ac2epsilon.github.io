SCALA 3 Book
============
Перекладено: ac2epsilon@gmail.com

== Властивості Scala 3

Ім'я _Scala_ походить від _scalable_, маштабований, і виправдовуючи це ім'я, мова Scala використовується для підсилення завантажених веб сайтів та аналізу величезних обсягів даних. Цей розіділ знайомить вас з властивостями, що роблять Scala такою маштабованою мовою. Ці властивості поділені на три розділи:

* Високорівневі мовні властивості
* Низькорівневі мовні властивості
* Властивості екосистеми Scala

=== Високорівневі властивості

Дивлячись на Scala з уявного пташиного політу, ви можете зробити наступні зауваження щодо цієї мови:

* Це мова програмування високого рівня
* Вона має стислий та читаємий синтаксис
* Вона статично типізована (але відчувається як динамічно типізована)
* Вона має виразну систему типів
* Це функціо
нальна (FP) мова програмування
* Вона також є об'єктно орієнтовною (OOP) мовою програмування
* Вона підтримує поєднання FP та OOP
* Контекстуальні абстракції провадять ясний шлях для _виводу термів_
* Все виконується на JVM (або в браузері) 
* Забезпечена безшовна взаємодія з Java кодом
* Використовується для застосувань сервер-сайду (включаючи мікросервіси), застосувань біг-дейта, але також може застосовуватись в браузері через Scala.js.

Наступні розділи дають швидкий огляд ціх властивостей.

==== Мова високого рівня

Scala має бути визнана як мова високого рівня, щонайменьше через два аспекти. По перше, як Java та багато іншіх сучасних мов програмування, ви не маєте справу з низькорівневими концепціями, як вказівники та керування пам'яттю.

По друге, за допомогою лямбд та функцій вищого гатунку ви пишете ваш код на дуже високому рівні. Як здверджує прикизка функціональної мови, ви кажете _що_ ви бажаєте, а не _як_ цього досягти. Тобто ви не пишете імперативний код як наступний:
[source,scala]
----
def double(ints: List[Int]): List[Int] = {
  val buffer = new ListBuffer[Int]()
  for (i <- ints) {
      buffer += i * 2
  }
  buffer.toList
}
val newNumbers = double(oldNumbers)
----
Цей код інструктує компілятор що робити, крок за кроком. Замість цього ми пишемо на вищому рівні, функціональний код, використовуючи функції вищого гатунку та лямбди, як нижче, для отримання того самого результату: 
[source,scala]
----
val newNumbers = oldNumbers.map(_ * 2)
----
Як ви можете бачити, цей код значно більш стислий, простіший для читання та простіший для підтримки.

==== Стислий синтаксис

Scala має стислий, читабельний синтаксис. Наприклад, змінні створюються стисло, та їх тип зрозумілий:
[source,scala]
----
val nums = List(1,2,3)
val p = Person("Martin", "Odersky")
----
Функції вищого гатунку та лямбди створені для стислого коду, що можливо прочитати: 
[source,scala]
----
nums.map(i => i * 2)   // довга форма
nums.map(_ * 2)        // коротка форма

nums.filter(i => i > 1)
nums.filter(_ > 1)
----
Трейти, класи та методи визначені в стислому і прозорому синтаксисі: 
[source,scala]
----
trait Animal:
  def speak(): Unit

trait HasTail:
  def wagTail(): Unit

class Dog extends Animal, HasTail:
  def speak() = println("Woof")
  def wagTail() = println("⎞⎜⎛  ⎞⎜⎛")
----
Досліди показали, що час, який розробник витрачає на _читання_ коду до _написання_ коду складає щонайменьше 1/10, так що написання стислого та читабельного коду так важливе.

==== Відчуття динамічності

Scala є статично типізованою мовою, але завдячуючи її можливостям по виведенню типів, вона відчувається як динамічна. Всі ці вирази виглядають як динамічно-типізована мова, як Python або Ruby, але все це Scala: 
[source,scala]
----
val s = "Hello"
val p = Person("Al", "Pacino")
val sum = ints.reduceLeft(_ + _)
val y = for i <- nums yield i * 2
val z = nums.filter(_ > 100)
            .filter(_ < 10_000)
            .map(_ * 2)
----
Як стверджує Heather Miller, Scala визначено сильно, статично типізована мова, та ви можете отримати всі переваги статичних типів: 

* Коректність: ви відловлюєте більшість помилок під час компіляції
* Чудова підтримка IDE: 
** Надійне завершення коду
** Відловлення помилок під час компіляції означає перехоплення помилок по мірі набору
** Простий та надійний рефакторинг
* Ви можете впевнено рефакторити свій код
* Декларації типів методів  кажуть читачеві, що робить метод, та служить в якості документації
* Маштабованість та підтримуваність: типи допомагають переконатись в коректності між довільно великими застосуваннями та командами розробників
* Сильна типізація, в комбінації з чудовим виведенням, дозволяє механізми, як контекстуальна абстракція, що дозволяє вам уникати шаблонного коду. Часто цей шаблонний код може бути виведений компілятором, базуючись на визначенні типів та певному контексті.

==== Виразна система типів

Система типів Scala примушуе, під час компіляції, щоб абстракції використовувались в безпечний та узгоджений спосіб. Зокрема, система типів підтримує: 

* Виведені типи
* Дженерік класи
* Анотації варіантності
* Верхні і нижні межі типів
* Поліморфні методи
* Типи перетину
* Юніон типи
* Типові лямбди
* Примірники `given` та `using` класи
* Методи розширення
* Класи типів
* Мультиверсальне порівняння
* Прозорі псевдоніми типів
* Відкриті класи
* Класи порівнянь
* Типи залежної функції
* Типи поліморфної функції
* Межі контексту
* Функції контексту
* Внутрішні класи та абстрактні члени класів як члени об'єктів

В комбінації ці властивості провадять потужний базис для безпечного використання абстракцій програмування, та для типо-безпечного розширення програм.

==== Функціональна мова програмування

Scala є функціональною мовою програмування. Це означає: 

* Функції є значеннями, і можуть передаватись як будь-які значення
* Пряма підтримка функцій вищого гатунку
* Вбудовані лямбда
* Все в Scala э виразом, що повертає значення
* Синтаксично просте використання незмінних змінних, і їх використання заохочується
* Наявне різноманіття класів для незмінних колекцій в стандартній бібліотеці
* Ці класи колекцій ідуть з десятками функціональних методів: вони не змінюють колекцію, та замість цього повертають оновлену копію даних

==== Об'єктно-орієнтовна мова

Scala є об'єктно-орієнтовною мовою програмування (OOP). Кожне значення є примірником класу і кожний "оператор" є методом.

В Scala всі типи походять від кореневого класу `Any`, чиї безпосередні діти є `AnyVal` (_типи-значення_, такі як `Int` або `Boolean`), та `AnyRef` (_типи-посилання_, як в Java). Це означає, що різниця між примітивними типами, та боксованими типами (як `int` vs `Integer`), відсутня в Scala. Боксування та розбоксування повністю прозорі для користувача.

==== Підтримка змішування FP/OOP

Основою Scala є змішування функціонального програмування та об'єктно-орієнтовного програмування в прописній істині:

* Функції для логіки
* Об'єкти для модульності

Як стверджував Martin Odersky, "Scala була розроблена, щоб показати, що злиття функціонального та об'єктно-орієнтовного програмування є можливим та практичним".

==== Вивід термів, зроблене зрозумілішим

Слідуючи за Haskell, Scala була другою за популярністю мовою, що мала деяку форму _імплісітів_. В Scala 3 ці концепції були повністю переосмислені, і реалізовані більш зрозуміло.

Головна ідея є _вивід термів_: маючи тип, компілятор синтезує "канонічний" терм, що має такий тип. В Scala контекстний параметр прямо веде до виведеного терму аргументу, що також може бути записаний явно. 

Випадки застосування цієї концепції включають реалізацію класів типу, встановлення контексту, ін'єкція залежностей, вираження спроможностей, обчислення нових типів, та налагодження відносин між ними.

Scala 3 робить цей процесс більш прозорим, ніж будь-коли до цього. Читайте про контекстуальні абстракції в референсній документації.

==== Клієнт та сервер

Scala код виконується на Java Virtual Machine (JVM), так що ви отримуєте всі її переваги: 

* Безпеку
* Продуктивність
* Керування пам'ятю
* Портабельність та незалежність від платформи
* Здатність використовувати богатства існуючих бібліотек Java та JVM

На додаток до виконання на JVM, Scala також робить в браузері, за допомогою Scala.js (та бібліотек з відкритим кодом для інтеграції з популярними бібліотеками JavaScript), та нативними виконавчими файлами, що можуть бути побудовані з допомогою Scala Native та GraalVM.

==== Безшовна інтеграція з Java

Ви можете використовувати класи та бібліотеки Java в ваших Scala застосуваннях, та ви можете використовувати код Scala в ваших Java застосуваннях. Що до другого твердження, великі бібліотеки, як Akka та Play Framework, написані на Scala, та можуть бути використані в Java застосуваннях.

Відносно першого твердження, Java класи та бібліотеки використовуються в застосуваннях Scala кожний день. Наприклад, в Scala ви можете читати файли за допомогою Java `BufferedReader` та `FileReader`: 
[source,scala]
----
import java.io.*
val br = BufferedReader(FileReader(filename))
// читати файл через `br` ...
----
Використання Java коду в Scala є загалом безшовним.

Java колекції також можуть бути використані в Scala, та якщо ви бажаєте використати багаті класи колекцій Scala з ними, ви можете конвертувати їх в парі рядків кода: 
[source,scala]
----
import scala.jdk.CollectionConverters.*
val scalaList: Seq[Integer] = JavaClass.getJavaList().asScala.toSeq
----

==== Багатство бібліотек

Як ви побачите в третій частині цієї сторінки, Scala бібліотеки та фреймворки, як ці, були написані, щоб підсилити завантажені веб сайти, і робити з велетенськими базами даних: 

1. Play Framework - це легковажна, безстанова, дружня до розробника, дружня до веб архітектура для створення високо-маштабованих застосувань
2. Lagom - фреймворк мікросервісів, що допомагає роз'єднати ваш застарілий моноліт, та побудувати, протестувати, та розгорнути цілі системи реактивних мікросервісів
3. Apache Spark - уніфікований аналітичний рушій для обробки великих обсягів даних, з вбудованими модулями для стримінгу, SQL, машинним навчанням та обробкою графів

Список Awesome Scala показує десятки додаткових інструментів з відкритим кодом, що створені розробниками для побудови Scala застосувань.

На додаток до серверного програмування, Scala.js є сильно-типізованою заміною для написання JavaScript, з бібліотеками з відкритим кодом третіх сторін, що включають інструменти для інтергації з бібліотекою Facebook React, jQuery, тощо. 

=== Низькорівневі властивості мови

В той час, коли попередній розділ розповідав про високо-рівневі можливості Scala, цікаво зауважити, що на вищому рівні ви можете зробити ті самі зауваження щодо обох, Scala 2 та Scala 3. Десятиріччя тому Scala розпочинала з міцного фундаменту бажаних властивостей, і, як ви побачите в цьому розділі, ці переваги були покращені в Scala 3.

На "рівні моря" з погляду на деталі - тобто, на можливості мови, які програмісти використовують щодня - Scala 3 має значні переваги над Scala 3: 

* Здатність створювати алгебраїчні типи даних (ADT) більш стисло, за допомогою енумерацій
* Навіть ще більш стислий та читабельний синтаксис: 
** "Тихий" синтаксис керівних структур, що простіше читається
** Опціональні дужки
*** Менше символів в коді створює меньше візуального галасу, що легше читається
** Ключове слово `new` загалом більше не потрібне при створенні примірників класів
** Формальності об'єкта-пакунка були відкинуті на користь простіших визначень "вищого рівня"
* Зрозуміліша граматика
** Декілька різних використань ключового слова `implicit` були видалені; ці використання замінені на більш очевидні ключові слова, як `given`, `using`, `extension`, фокусуючись на призначенні замість механізмів (дивіться розділ Given)
** Методи розширення замінюють імплісіт-класи з яснішим та простішим механізмом
** Додавання модифікатора `open` до класів робить явними наміри розробника зробити клас відкритим для модифікацій, таким чином обмежуючи ad-hoc розширення кодової бази
** Мультиверсальна еквівалентність відкидає безглуздзі порівняння за допомогою `==` та `!=` (тобто, порівняння `Person` та `Planet`)
** Макроси реалізовані значно простіше
** Юніони та перетини пропонують гнучкий шлях моделювання типів
** Параметри трейтів замінюють та спрощують ранні ініціалізатори
** Прозорі псевдоніми типів замінюють більшість використань класів-значень, при цьому гарантуючи відсутність боксування
** Твердження експорту провадять простий та узагальнений спосіб вираження агрегації, що може замінити попередній паттерн фасаду наслідування об'єктів пакунку від класів
** Процедурний синтаксис був відкинутий, та синтаксис `varargs` був змінений, обоє щоб зробити мову більш узгодженою
** Анотація `@infix` робить очевидним, як ви бажаєте застосувати метод
** Анотація методу `@targetName` визначає альтернативне ім'я для методу, покращуючи взаємодію з Java, та провадячи псевдоніми для символічних операторів

Демонстрація всіх цих можливостей прямо тут заняла б багато місця, але слідуючи за посиланнями ви можете побачити можливості в дії. Всі ці можливості обговорюються на сторінках _Нове, змінене та відкинуте_ в оглядовій документації.

=== Екосистема Scala

Scala має вируючу екосистему, з бібліотеками та фреймворками для кожної потреби. Список _Awesome Scala_ провадить перелік сотен доступних розробникам проектів з відкритим кодом, та Scaladex провадить пошук Scala бібліотек. Деякі з самих помітних перелічені нижче. 

==== Веб розробка

* _Play Framework_ слідує за моделлю Ruby on Rails, щоб стати легковажною, безстановою, розробник-дружньою, веб-дружньою архітектурою для високо маштабованих застосувань
* _Scalatra_ є маленьким, високопродуктивним, асинхронним веб фреймворком, натхненим Sinatra
* _Finatra_ є Scala сервісами, побудованими на TwitterServer та Finagle
* _Scala.js_ - це сильно типізована заміна для JavaScript, що провадить безпечніший шлях для побудови надійнішого фронт-енду веб застосувань
* _ScalaJs-React_ підіймає бібліотеку Facebook React до Scala.js, та намагається зробити її настільки безпечною та Scala-дружньою, як це можливо
* _Lagom_ - фреймворк мікросервісів, що допомагає декомпозиції існуючих монолітів, та побудові, тестуванню, та розгортанню цілих систем реактивних мікросервісів

==== HTTP(S) бібліотеки

* akka-http
* Finch
* Http4s
* Sttp

==== JSON бібліотеки

* Argonaut
* Circe
* Json4s
* Play-JSON
* ScalaPB (серіалізіція)

==== Наукові обчислення та обробка даних

* Algebird
* Spire
* Squants

==== Big data

* Apache Spark
* Apache Flink

==== AI, машинне навчання

* BigDL (Distributed Deep Learning Framework) для Apache Spark
* TensorFlow Scala

==== Функціональне (та реактивне) програмування 

* Cats
* Zio
* fs2
* monix

==== Інструменти побудови 

* sbt
* Gradle
* Mill

=== Підсумок

Як показує ця сторінка, Scala має багато неймовірних властивостей мови на вищому рівні, на рівні щоденного програмування, та через екосистему розробників.

== Чому Scala 3?

Існує багато переваг використання Scala, зокрема Scala 3. Важко перелічити всі переваги Scala, але топ-10 може виглядати так: 

1. Scala обіймає злиття функціонального програмування (FP), та об'єктно-орієнтовного програмування (OOP)
2. Scala статично типізована, але часто відчувається як динамічно типізована мова
3. Синтаксис Scala стислий, але все ще зрозумілий; на нього часто посилаються як на _виразний_.
4. _Імплісіти_ в Scala 2 були визначальною можливыстю, і вони були покращені та спрощені в Scala 3
5. Scala безшовно інтегрується з Java, так що ви можете створювати змішані проекти на Scala та Java, та код Scala може легко використовувати тисячі існуючих Java бібліотек
6. Scala може використовуватись на сервері, але також в браузері, за допомогою Scala.js
7. Стандартна бібліотека Scala має десятки пре-побудованих, функціональних методів, щоб зберігти ваш час, та значно зменшити потребу писати власні `for` цикли та алгоритми
8. "Кращі практики" вбудовані в Scala, що надає перевагу незмінності, анонімних функцій, функцій вищого гатунку, порівняння шаблонів, класів, що не розширюються по замовчанню, та інше
9. Екосистема Scala пропонує найбільш сучасні FP бібліоеки в світі
10. Сильна система типів

=== 1) Злиття FP/OOP

Більше ніж будь-яка інша мова, Scala підтримує злиття парадігм FP та OOP. Як стверджував Мартін Одерскі, основа Scala в злитті функціонального та об'єктно-орієнтовного програмування в типовому оточенні: 

* Функції для логіки
* Об'єкти для модульності

Можливо, один з кращих прикладів модульності є класи в стандартній бібліотеці. Наприклад, `List` визначений як клас - технічно це абстрактний клас - і новий примірник створюється так: 
[source,scala]
----
val x = List(1, 2, 3)
----
Однак, для програміста виглядає так, що простий `List` насправді побудований як комбінація декількох спеціалізованих типів, включаючи трейти з назвами `Iterable`, `Seq` та `LinearSeq`. Ці типи подібним чином скомпоновані з інших, меньших, модульних одиниць коду.

На додаток до побудови типів як `List` з послідовності модульних трейтів, `List` API також складається з десятків інших методів, багато з яких є функціями вищого гатунку: 
[source,scala]
----
val xs = List(1, 2, 3, 4, 5)

xs.map(_ + 1)         // List(2, 3, 4, 5, 6)
xs.filter(_ < 3)      // List(1, 2)
xs.find(_ > 3)        // Some(4)
xs.takeWhile(_ < 3)   // List(1, 2)
----
В ціх прикладах значення в списку не може бути модифіковане, клас `List` є незмінним. Так що ці методи повертають нові значення, як показано в коментарях.

=== 2) Динамічне відчуття

_Вивід типів_ Scala часто робить відчуття мови динамічно типізованим, навіть хоча вона статично типізована. Це так для декларацій змінних: 
[source,scala]
----
val a = 1
val b = "Hello, world"
val c = List(1,2,3,4,5)
val stuff = ("fish", 42, 1_234.5)
----
Це також вірно, коли анонімна функція передається до функції вищого гатунку: 
[source,scala]
----
list.filter(_ < 4)
list.map(_ * 2)
list.filter(_ < 4)
    .map(_ * 2)
----
та при визначенні методів: 
[source,scala]
----
def add(a: Int, b: Int) = a + b
----
Це все ще більше вірно в Scala 3, як при використанні юніон типів: 
[source,scala]
----
// параметр юніон типу
def help(id: Username | Password) =
  val user = id match
    case Username(name) => lookupName(name)
    case Password(hash) => lookupPassword(hash)
  // тут код ...

// значення юніон типу
val b: Password | Username = if (true) name else password
----

=== 3) Стислий синтаксис

Scala - мова без церемоній, "стисла, але читабельна". Наприклад, декларація змінних стисла: 
[source,scala]
----
val a = 1
val b = "Hello, world"
val c = List(1,2,3)
----
Створення типів, як трейти, класи та енумерації, є стислим: 
[source,scala]
----
trait Tail:
  def wagTail(): Unit
  def stopTail(): Unit

enum Topping:
  case Cheese, Pepperoni, Sausage, Mushrooms, Onions

class Dog extends Animal, Tail, Legs, RubberyNose

case class Person(
  firstName: String,
  lastName: String,
  age: Int
)
----
Функції вищого гатунку також стислі: 
[source,scala]
----
list.filter(_ < 4)
list.map(_ * 2)
----

Всі ці вирази, і багато інших, є стислими, та при цьому все ще зрозумілі: ми називаємо це _виразність_.

=== 4) Імплісіти, спрощені

Імплісіти в Scala 2 були головною знаковою відмінністю дизайну. Вони репрезентували фундаментальний шлях абстрагуватись від контексту, з уніфікованою парадігмою, що служить багатому різноманіттю випадків. Серед них: 

* Реалізація класів типу
* Встановлення контексту
* Ін'єкція залежностей
* Вираз можливостей

З тих пір багато мов прийняли подібні концепції, всі з яких є варіантами головної ідеї _виводу термів_: маючи тип, компілятор синтезує "канонічний" терм, що має цей тип.

Хоча імплісіти були визначальною властивістю в Scala 2, їх дизайн був суттєво покращений в Scala 3: 

* Існує єдиний спосіб визначити `given` значення
* Існує єдиний спосіб ввести імплісіт параметри та аргументи
* Існує окремий шлях імпортувати `given`, що не дозволяє їм загубитись в морі звичайних імпортів
* Існує єдиний спосіб визначити імплісіт конверсію, яка зрозуміло помічена як така, і не потребує спеціального синтаксису

Переваги таких змін наступні: 

* Новий дизайн уникає взаємодії можливостей, та робить мову більш узгодженою
* Це робить імплісіти простішими для вивчання, та складнішими для невірного використання
* Це гарно підвищує прозорість 95% Scala програм, що використовують імплісіти
* Існує потенціал робити вивід термів в принциповий спосіб, що також доступний та дружній

Ці властивості детально описані в інших розділах. Дивіться вступ до Контекстуальної абстракції, та розділ про `given` та `using`.

=== 5) Безшовна Java інтеграція

Інтеграція Scala/Java є безшовною в багатьох сенсах. Наприклад: 

* Ви можете використовувати всі тисячі Java бібліотек в ваших Scala проектах
* Scala `String` в основі є Java `String`, з додатковими можливостями
* Scala безшовно використовує класи дати та часу в пакунку _java.time_.

Ви також можете використовувати Java колекції в Scala, і, щоб надати їм більше функціональності, Scala включає методи, так що ви можете трансформувати їх в Scala колекції.

Хоча майже кожна взаємодія є безшовною, глава _Взаємодія з Java_ демонструє, як використовувати деякі можливості разом, включаючи використання: 

* Java колекції в Scala
* Java `Optional` в Scala
* Java інтерфейси в Scala
* Scala колекції в Java
* Scala `Option` в Java
* Scala трейти в Java
* Scala методи, що закидають виключення, в Java
* Scala `varargs` параметри в Java

Дивіться відповідну главу для додаткової інформації по цім темам.

=== 6) Клієнт і сервер

Scala може бути використана з боку сервера за допомогою несамовитих фреймворків та мікросервісів: 

* _Play Framework_ дозволяє вам будувати високо маштабовані серверні застосування та мікросервіси
* _Akka Actors_ дозволяють використовувати модель акторів, щоб значно спростити розподілені та конкурентні софтверні застосування

Scala також може бути використана в браузері завдяки проекту Scala.js, що є типо-безпечною заміною JavaScript. Екосистема Scala.js має десятки бібліотек, що дозволяють використовувати React, Angular, jQuery, та багато інших бібліотек JavaScript та Scala в браузері.

На додаток до ціх інструментів проект Scala Native "є оптимізуючим ahead-of-time компілятором і легковажним керованим рантаймом, розробленим спеціально для Scala". Він дозволяє будувати бінарні застосування за допомогою звичайного коду Scala, а також дозволяє використовувати низькорівневі примітиви.

=== 7) Методи стандартної бібліотеки

Тепер вам рідко потрібно власноруч писати цикли `for`, тому що десятки функціональних методів в стандартній бібліотеці Scala одночасно зберігає ваш час, та допомагає робити код більш узгодженим між різними застосуваннями.

Наступні приклади демонструють деякі з вбудованих методів колекцій, і є багато ще інших. Хоча всі вони використовують клас `List`, ті самі методи методи роблять з іншими класами колекцій, як `Seq`, `LazyList`, `Set`, `Map`, `Array`, `ArrayBuffer`.

Ось деяки приклади: 
[source,scala]
----
List.range(1, 3)                          // List(1, 2)
List.range(start = 1, end = 6, step = 2)  // List(1, 3, 5)
List.fill(3)("foo")                       // List(foo, foo, foo)
List.tabulate(3)(n => n * n)              // List(0, 1, 4)
List.tabulate(4)(n => n * n)              // List(0, 1, 4, 9)

val a = List(10, 20, 30, 40, 10)          // List(10, 20, 30, 40, 10)
a.distinct                                // List(10, 20, 30, 40)
a.drop(2)                                 // List(30, 40, 10)
a.dropRight(2)                            // List(10, 20, 30)
a.dropWhile(_ < 25)                       // List(30, 40, 10)
a.filter(_ < 25)                          // List(10, 20, 10)
a.filter(_ > 100)                         // List()
a.find(_ > 20)                            // Some(30)
a.head                                    // 10
a.headOption                              // Some(10)
a.init                                    // List(10, 20, 30, 40)
a.intersect(List(19,20,21))               // List(20)
a.last                                    // 10
a.lastOption                              // Some(10)
a.map(_ * 2)                              // List(20, 40, 60, 80, 20)
a.slice(2, 4)                             // List(30, 40)
a.tail                                    // List(20, 30, 40, 10)
a.take(3)                                 // List(10, 20, 30)
a.takeRight(2)                            // List(40, 10)
a.takeWhile(_ < 30)                       // List(10, 20)
a.filter(_ < 30).map(_ * 10)              // List(100, 200, 100)

val fruits = List("apple", "pear")
fruits.map(_.toUpperCase)                 // List(APPLE, PEAR)
fruits.flatMap(_.toUpperCase)             // List(A, P, P, L, E, P, E, A, R)

val nums = List(10, 5, 8, 1, 7)
nums.sorted                               // List(1, 5, 7, 8, 10)
nums.sortWith(_ < _)                      // List(1, 5, 7, 8, 10)
nums.sortWith(_ > _)                      // List(10, 8, 7, 5, 1)
----

=== 8) Вбудовані кращі практики

Ідіоми Scala заохочують кращі практики в декілька способів. Для незмінності вас заохочують створювати незмінні `val` декларації: 
[source,scala]
----
val a = 1   // незмінна змінна
----
Вас також заохочують використовувати класи незмінних колекцій, як `List` та `Map`: 
[source,scala]
----
val b = List(1,2,3)       // List незмінний
val c = Map(1 -> "one")   // Map незмінний
----
Кейс класи загалом призначені для використання в доменному моделюванні, і їх параметри незмінні: 
[source,scala]
----
case class Person(name: String)
val p = Person("Michael Scott")
p.name           // Michael Scott
p.name = "Joe"   // помилка компілятора (переприсвоєння val)
----
Як показано в попередньому розділі, класи колекцій Scala підтримують функції вищого гатунку, і ви можете передавати до них методи (не показані) та анонімні функції: 
[source,scala]
----
a.dropWhile(_ < 25)
a.filter(_ < 25)
a.takeWhile(_ < 30)
a.filter(_ < 30).map(_ * 10)
nums.sortWith(_ < _)
nums.sortWith(_ > _)
----
Вирази `match` дозволяють використовувати порівняння шаблонів, і вони насправді є виразами, що повертають значення: 
[source,scala]
----
val numAsString = i match
  case 1 | 3 | 5 | 7 | 9 => "odd"
  case 2 | 4 | 6 | 8 | 10 => "even"
  case _ => "too big"
----
Оскільки вони повертають значення, вони часто використовуються як тіло функції: 
[source,scala]
----
def isTruthy(a: Matchable) = a match
  case 0 | "" => false
  case _ => true
----

=== 9) Бібліотеки екосистеми

Бібліотеки Scala для функціонального програмування (FP), як Cats та Zio, знаходяться на передньому фланзі бібліотек FP спільноти. Всі ці штампи, як високо-продуктивний, безпека типів, конкурентний, асинхронний, ресурсо-безпечний, тестовний, функціональний, модуларний, бінарно-сумісний, ефективний, та більше, що можна сказати про ці бібліотеки.

Ви можете перегорнути сотні бібліотек, але, на щастя, всі вони перелічені в одному місці: для деталей дивіться _Awesome Scala_.

=== 10) Сильна система типів

Scala має сильну систему типів, і вона була навіть ще більше покращена в Scala 3. Цілі Scala 3 були визначені на ранній стадії, і ті, що мають відношення до системи типів, включають: 

* Спрощення
* Уникнення неузгодженостей
* Безпека
* Ергономіка
* Продуктивність

_Спрощення_ досягається через десятки змінених та відкинутих можливостей. Наприклад, зміна від перевантаженого ключового слова `implicit` в Scala 2, до термів `given` та `using` в Scala 3, що робить мову більш зрозумілою, особливо для розробників-початківців.

_Уникнення неузгодженостей_ пов'язане з десятками відкинутих можливостей, змінених можливостей та доданих можливостей в Scala 3. Деякі з найбільш важливих можливостей в цій категорії: 

* Перетини типів
* Юніон типи
* Типи імплісіт функції
* Типи залежної функції
* Параметри трейтів
* Дженерік тапли

_Безпека_ пов'язана з новими та зміненими властивостями:  

* Мультіверсальна еквівалентність
* Обмеження імплісіт конверсій
* null-безпечність
* Безпечна ініціалізація

Гарні приклади _ергономіки_ є енумерації та методи розширення, що були додані в Scala 3 в дуже зрозумілий спосіб: 
[source,scala]
----
// енумерація
enum Color:
  case Red, Green, Blue

// методи розширення
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius
----
_Продуктивність_ відноситься до декількох речей. Одна з них є прозорі типи. В Scala 2 було декілька спроб вирішити питання дотримання практики Domain-driven design (DDD) надавати значенням більш осмислені типи. Ці спроби включають: 

* Псевдоніми типів
* Класи-значення
* Кейс класи

Нажаль, всі з ціх підходів мають свої вади, як описано в `Opaque Types SIP`. Навпаки, ціллю прозорих типів є, як описано в цьому SIP, щоб "операції на ціх типах-огортках не створювали додаткового навантаження під час виконання, при цьому провадячи безпеку типів рід час компіляції".

Більше щодо деталей системи типів дивіться відповідні посилання.

=== Інші значні властивості

Scala має багато гарних властивостей, та вибір Топ-10 може бути суб'єктиним. Декілька досліджень показали, що різні групи розробників люблять різні властивості. Маємо надію, що ви знайдете інші потужні можливості Scala по мірі використання мови.

== Смак Scala

Ця глава провадить карколомний тур по основним можливостям мови програмування Scala 3. Після цього початкового туру залишок книги провадить більше деталей по цім можливостям, та нарешті Референсна документація надає _значно_ быльше деталей.

На протязі цієї книги ми рекомендуємо експериментувати з прикладами на _Scastie_, або _Scala REPL_, які ми скоро побачимо.

== Hello, Wold!

Приклад "Hello, World!" на Scala 3 виглядає таким чином. Спочатку покладіть наступний код в файл _Hello.scala_: 
[source,scala]
----
 @main def hello = println("Hello, world!")
----
В цьому коді `hello` є метод. Він визначається за допомогою `def`, і задекларований як `main` за допомогою анотації `@main`. Він друкує _"Hello, world!"_ в стандартний вивід (STDOUT), використовуючи метод `println`.

Далі скомпілюйте код в `scalac`: 
[source,bash]
----
$ scalac Hello.scala
----
  Прим.перекл. Станом на 01 січня 2022 року компілятор та ланчер Scala 3 мали назву `scala3-compiler` та `scala3`, відповідно. Майте це на увазі, Scala 2 видасть помилку вже на першій декларації `@main`.

Якщо ви прийшли в Scala з Java, `scalac` такий саме, як `javac`, так що ця команда створить декілька файлів: 
[source,bash]
----
$ ls -1
Hello$package$.class
Hello$package.class
Hello$package.tasty
Hello.scala
hello.class
hello.tasty
----
Як і в Java, файли `.class` є файлами байткоду, і вони готові для виконання в JVM. 

Тепер ви можете виконати метод `hello` в команді ланчера `scala`: 
[source,bash]
----
$ scala hello
Hello, world!
----
Вважаючи, що все робить, прийміть поздоровлення. Ви тільки що скомпілювали та виконали ваше перше застосування на Scala.
  
  Більше інформації щодо _sbt_ та інших інструментів, що спрощують розробку на Scala, можна знайти в главі _Інструменти Scala_.

== REPL

Scala REPL (“Read-Evaluate-Print-Loop”) є інтерпретатором командного рядка, який ви використовуєте для перевірки вашого Scala коду. Ви запускаєте вашу REPL сессію, виконуючи команду `scala` в командному рядку операційної системи. Ви маєте побачити запрошення. подібне до наступного: 
[source,bash]
----
$ scala
Welcome to Scala 3.0.0 (OpenJDK 64-Bit Server VM, Java 11.0.9).
Type in expressions for evaluation.
Or try :help.

scala> _
----
REPL є інтерпретатором командного рядка, так що він очікує, доки ви введете будь-що. Тепер ви можете вводити вирази Scala, щоб побачити як вони роблять: 
[source,scala]
----
scala> 1 + 1
val res0: Int = 2

scala> 2 + 2
val res1: Int = 4
----
Як стверджує результат, якщо ви не присвоєте результат до змінної, REPL створить змінні з іменами `res1`, `res2`, тощо. Ви можете  використовувати ці имена в наступних виразах: 
[source,scala]
----
scala> val x = res0 * 10
val x: Int = 20
----
Зауважте, що REPL також відображужє результат обчислення ваших виразів.

Ви можете виконувати в REPL всі типи експериментів. Цей приклад показує, як створити та потім виконати метод `sum`: 
[source,scala]
----
scala> def sum(a: Int, b: Int): Int = a + b
def sum(a: Int, b: Int): Int

scala> sum(2, 2)
val res2: Int = 4
----
Якщо ви обираєте онлайн плейграунд, ви також можете використовувати http://scastie.scala-lang.org.

Якщо ви обираєте, замість підказки консолі, писати код в текстовому редакторі, ви можете використовувати _worksheet_.

== Змінні і типи даних

Цей розділ провадить погляд на змінні та типи даних Scala.

=== Два типи змінних

Коли ви створюєте нову змінну в Scala, ви декларуєте, чи буде змінна незмінною аба змінною: 

*Тип*  *Опис*
`val`   Створює _незмінну_ змінну, як `final` в Java. Ви завжди маєте створювати змінні за допомогою `val`, крім наявності причини створити змінну змінну.
`var`   створює _мінливу_ змінну, і має створюватись, тільки коли значення повинне змінюватись у часі.

Наступні приклади показують, як створювати змінні `val` та `var`: 
[source,scala]
----
// незмінна
val a = 0

// змінна
var b = 1
----
В застосуванні `val` не може бути переприсвоєна. Ви отримаєте помилку компілятора, якщо спробуєте зробити переприсвоєння: 
[source,scala]
----
val msg = "Hello, world"
msg = "Aloha"   // помилка; це не буде компілюватись
----
І навпаки, `var` мможе бути переприсвоєна: 
[source,scala]
----
var msg = "Hello, world"
msg = "Aloha"   // це скомпілюється, var може переприсвоюватись
----

=== Декларування типів змінних

Коли ви створюєте змінну, ви можете явно декларувати її тип, або дати компілятору вивести тип самостійно: 
[source,scala]
----
val x: Int = 1   // явний тип
val x = 1        // компілятор виводить тип неявно
----
Друга форма має назву _вивід типу_, і це чудовий спосіб підтримувати код стислим. Компілятор Scala загалом може вивести тип даних, як можна бачити з результатів роботи прикладів в REPL: 
[source,scala]
----
scala> val x = 1
val x: Int = 1

scala> val s = "a string"
val s: String = a string

scala> val nums = List(1, 2, 3)
val nums: List[Int] = List(1, 2, 3)
----
Ви завжди можете явно декларувати тип змінної, якщо бажаєте, але в простих випадках в цьому немає потреби: 
[source,scala]
----
val x: Int = 1
val s: String = "a string"
val p: Person = Person("Richard")
----
Зауважте, що при такому підході код виглядає більш галасливим, ніж потрібно. 

=== Вбудовані типи даних

Scala іде зі стандартними числовими типами, як ви можете очікувать, і вони є повноцінні примірники класів. в Scala будь-що є об'єктом.

Ці приклади показують, як декларувати змінні числових типів: 
[source,scala]
----
val b: Byte = 1
val i: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0
----
Оскільки `Int` та `Double` є числовими типами по замовчанню, ви зазвичай створюєте їх без явного декларування типу даних: 
[source,scala]
----
val i = 123   //  Int
val j = 1.0   //  Double
----
Також в своєму коді ви можете додати символи `L`, `D`, `F` (та їх прописні еквіваленти) до чисел, щоб вказати що це значення `Long`, `Double` або `Float`: 
[source,scala]
----
val x = 1_000L   // val x: Long = 1000
val y = 2.2D     // val y: Double = 2.2
val z = 3.3F     // val z: Float = 3.3
----
Якщо нам треба дійсно великі числа, використовуйте типи `BigInt` та `BigDecimal`: 
[source,scala]
----
var a = BigInt(1_234_567_890_987_654_321L)
var b = BigDecimal(123_456.789)
----
В той час, як `Double` та `Float` округлюють десяткові числа,`BigDecimal` використовують точну арифметику.

Scala також має типи даних `String` та `Char`: 
[source,scala]
----
val name = "Bill"   // String
val c = 'a'         // Char
----

==== Рядки

Рядки Scala подібні до рядків Java, але мають дві додаткові функції: 

* Вони підтримують інтерполяцію рядків
* Легко створювати багаторядкові рядки

===== Інтерполяція рядків

Інтерполяція рядків провадить дуже наочний шлях для використання змінних в рядках. Наприклад, візьмемо наступні три рядка: 
[source,scala]
----
val firstName = "John"
val mi = 'C'
val lastName = "Doe"
----
Ви можете скомпонувати ці змінні в один рядок таким чином: 
[source,scala]
----
println(s"Name: $firstName $mi $lastName")   // "Name: John C Doe"
----
Просто поставьте перед рядком літеру `s`, та покладіть символ `$` перед ім'ям іменами ваших змінних всередині рядка.

Щоб вбудувати в рядок довільний вираз, заточіть його в фігурні дужки: 
[source,scala]
----
println(s"2 + 2 = ${2 + 2}")   // друкує "2 + 2 = 4"

val x = -1
println(s"x.abs = ${x.abs}")   // друкує "x.abs = 1"
----
Літера `s` перед рядком є лише одним можливим інтерполятором. Якщо замість `s` ви поставите `f`, ви отримаєте `printf`-подібний синтаксис в рядку. Більше того, інтерполятор є лише спеціальним методом, і ви можете визначати власні. Наприклад, деякі бібліотеки баз даних визначають дуже потужний інтерполятор `sql`.

===== Багаторядкові рядки

Багаторядкові рядки створюються оточенням рядка в потрійні подвійні лапки: 
[source,scala]
----
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""
----
  Додактові деталі щодо інтерполяції рядків та багаторядкові рядки дивіться главу _Перший погляд на типи_.

=== Керівні структури

Scala має керівні структури, які ви можете знайти в інших мовах, але також має потужні вирази `for` та `match`: 

* `if/else`
* `for` цикли та вирази
* `match` вирази 
* `while` цикли
* `try/catch`

Ці структури продемонстровані в наступних прикладах.

==== if/else

В Scala керівіна структура `if/else` виглядає подібно до інших мов: 
[source,scala]
----
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")
----
Зауважте, що це насправді _вираз - не твердження_. Це означає, що це повертає значення, так що ви можете присвоїти його змінній: 
[source,scala]
----
val x = if a < b then a else b
----
Як ви побачите в цій книжці, в Scala _всі_ контрольні структури можуть використовуватись як вирази.

  Вираз повертає результат, тоді як твердження - ні. Твердження типово використовуються для своїх побічних ефектів, таких, як використання `println` для друку на консолі.

==== for цикли  та вирази

Ключове слово `for` використовується для створення `for` циклу. Приклад показує, як надрукувати всі елементи в `List`: 
[source,scala]
----
val ints = List(1, 2, 3, 4, 5)

for i <- ints do println(i)
----
Код `i <- ints` відомий як _генератор_, а код після `do` складає _тіло_ циклу.

Старий синтаксис для цієї структури виглядав так: 
[source,scala]
----
for (i <- ints) println(i)
----

==== Охоронці

Ви можете також використовувати один або більше `if` в своєму циклі `for`. Це відоме як _охоронці_. Приклад друкує всі числа в `ints`, що більше ніж 2: 
[source,scala]
----
for
  i <- ints
  if i > 2
do
  println(i)
----
Ви можете використовувати декілька генераторів та охоронців. Цей цикл ітерує по числах від 1 до 3, і для кожного ітерує по символах від `a` до `c`. Однак ми також маємо два охоронці, так що друкується тільки рядок, коли `i` дорівнює 2, а `j` - символу `b`: 
[source,scala]
----
for
  i <- 1 to 3
  j <- 'a' to 'c'
  if i == 2
  if j == 'b'
do
  println(s"i = $i, j = $j")   // друкує: "i = 2, j = b"
----

==== for вирази

Ключове слово `for` має ще більші можливості: якщо ви, замість `do` використати `yeld`, ви створите _вираз_ `for`, що обчислює та видає результати.

Декілька прикладів демонструють це. Використовуючи той самий список `ints`, що і в попередньому прикладі, цей код генерує новий список, де кожне значення елементу в новому списку є подвоєне значення в оригінальному списку: 
[source,scala]
----
scala> val doubles = for i <- ints yield i * 2
val doubles: List[Int] = List(2, 4, 6, 8, 10)
----
Синтаксис керівних структур Scala гнучкий, і той самий вираз `for` може бути записаний різними шляхами, за вашим вподобанням: 
[source,scala]
----
val doubles = for i <- ints yield i * 2 // стиль, показаний вище
val doubles = for (i <- ints) yield i * 2
val doubles = for (i <- ints) yield (i * 2)
val doubles = for { i <- ints } yield (i * 2)
----
Наступний приклад показує, як капіталізувати кожний рядок зі списку: 
[source,scala]
----
val names = List("chris", "ed", "maurice")
val capNames = for name <- names yield name.capitalize
----
Нарешті, цей `for` вираз ітерує по списку рядків, та повертає довжину кожного рядка, але тільки якщо ця довжина більше чотирьох: 
[source,scala]
----
val fruits = List("apple", "banana", "lime", "orange")

val fruitLengths = for
  f <- fruits
  if f.length > 4
yield
  // тут може бути більше рядків
  f.length

// fruitLengths: List[Int] = List(5, 6, 6)
----
Цикли та вирази `for` розглядаються більш детально в розділі _Керівні структури_ та в референсній документації.

==== `match` вирази

Scala має вираз `match`, який в простіший формі використання подібний до Java `switch`: 
[source,scala]
----
val i = 1

// далі в коді ...
i match
  case 1 => println("one")
  case 2 => println("two")
  case _ => println("other")
----
Однак, насправді `match` є виразом, що означає, що він повертає результат на основі порівняння шаблонів, що може бути прикріплене до змінної: 
[source,scala]
----
val result = i match
  case 1 => "one"
  case 2 => "two"
  case _ => "other"
----
`match` не обмежений робити з цілими значеннями, він може використовуватись з любими типами даних: 
[source,scala]
--------
val p = Person("Fred")

// далі в коді
p match
  case Person(name) if name == "Fred" =>
    println(s"$name says, Yubba dubba doo")

  case Person(name) if name == "Bam Bam" =>
    println(s"$name says, Bam bam!")

  case _ => println("Watch the Flintstones!")
--------
Фактично, вираз `match` може бути використаний для перевірки змінної по багатьом різним типам шаблонів. Приклад показує, (а) як використовувати вираз `match` в якості тіла метода, та (б) як порівнювати різні типи: 
[source,scala]
----
// getClassAsString - метод, що приймає любий тип
def getClassAsString(x: Matchable): String = x match
  case s: String => s"'$s' is a String"
  case i: Int => "Int"
  case d: Double => "Double"
  case l: List[_] => "List"
  case _ => "Unknown"

// приклади
getClassAsString(1)             // Int
getClassAsString("hello")       // 'hello' типу String
getClassAsString(List(1, 2, 3)) // List
----
Метод `getClassAsString` приймає як параметр значення типу `Matchable`, що може бути любим типом, що підтримує порівняння шаблонів (деякі типи не підтримують порівняння, бо це може зламати енкапсуляцію).

Є ще _дуже багато_ чого стосовно порівнянь шаблонів в Scala. Шаблони можуть бути вкладені, результати шаблонів можуть бути захоплені, і саме порівняння може визначатись власним кодом. Дивіться приклади порівнянь в главі Структури керування.

==== try/catch/finally

Керівна структура `try/catch/finally` в Scala дозволяє вам перехоплювати виключення. Це подібне до Java, але синтаксис узгоджений з виразами `match`: 
[source,scala]
----
try
  writeTextToFile(text)
catch
  case ioe: IOException => println("Got an IOException.")
  case nfe: NumberFormatException => println("Got a NumberFormatException.")
finally
  println("Clean up your resources here.")
----

==== `while` цикли

Scala також має конструкцію циклу `while`. Його одно-рядковий синтаксис виглядає так: 
[source,scala]
----
while x >= 0 do x = f(x)
----
Scala 2 має дещо інший синтаксис: умова була оточена дужками, та не було ключового слова `do`: 
[source,scala]
----
while (x >= 0) { x = f(x) }
----
Scala 3 все ще підтримує синтаксис Scala 2 в цілях сумісності.

Багато-рядковий синтаксис циклу `while` має наступний вигляд: 
[source,scala]
----
var x = 1

while
  x < 3
do
  println(x)
  x += 1
----

==== Власні керівні структури

Завдяки таким можливостям, як `by-name` параметри, інфіксна нотація, гнучки інтерфейси, опціональні дужки, методи розширення та функції вищого гатунку, ви можете створити ваш власний код, що робитиме як керівна структура. Ви найдете більше про це в _Керівні структури_.


== Доменне моделювання

Scala підтримує обоє, функціональне програмування (FP) та об'єктно-орієнтовне програмування (OOP), так само, як і суміш обох парадигм. Цей розділ провадить швидкий огляд моделювання даних в OOP та FP.

=== Доменне моделювання OOP

Коли ви пишете код в OOP стилі, ваші два основні інструменти для енкапсуляції - це _трейти_ та _класи_.

==== Трейти

Трейти Scala можуть використовуватись як прості інтерфейси, але вони також можуть містити абстрактні і конкретизовані методи і поля, і вони можуть мати параметри, так само, як класи. Вони провадять вам гарний спосіб організувати поведінку в малі, модулярні юніти. Пізніше, коли ви побажаєте створити конкретизовані реалізації атрибутів та поведінок, класи та об'єкти можуть розширювати трейти по мірі необхідності, міксуючи так багато трейтів, як потрібно, щоб отримати бажану поведінку.

В якості приклада, як використовувати трейти як інтерфейси - ось три трейти, що визначають гарно організовану і модульну поведінку для тварин, як собаки та кішки: 
[source,scala]
----
trait Speaker:
  def speak(): String  // абстрактне, без тіла

trait TailWagger:
  def startTail(): Unit = println("tail is wagging")
  def stopTail(): Unit = println("tail is stopped")

trait Runner:
  def startRunning(): Unit = println("I’m running")
  def stopRunning(): Unit = println("Stopped running")
----
Маючи ці трейти, ось клас `Dog`, що розширює всі ці трейти, та також провадить поведінку абстрактного метода `speak`: 
[source,scala]
----
class Dog(name: String) extends Speaker, TailWagger, Runner:
  def speak(): String = "Woof!"
----
Зверніть увагу, як клас розширює трейти за допомогою ключового слова `extends`.

Подібно до цього, ось клас `Cat`, що реалізує ті самі трейти, та переписує два конкретизованих методів, який він наслідує: 
[source,scala]
----
class Cat(name: String) extends Speaker, TailWagger, Runner:
  def speak(): String = "Meow"
  override def startRunning(): Unit = println("Yeah ... I don’t run")
  override def stopRunning(): Unit = println("No need to stop")
----
Ось приклад, як ці класи можуть бути використані: 
[source,scala]
----
val d = Dog("Rover")
println(d.speak())      // "Woof!"

val c = Cat("Morris")
println(c.speak())   // "Meow"
c.startRunning()     // "Yeah ... I don’t run"
c.stopRunning()      // "No need to stop"
----
Якщо цей код має сенс - добре, ви знайомі з трейтами в якості інтерфейсів. Якщо ні - не турбуйтесь, ми пояснимо краще в главі _Доменне модулювання_.

==== Класи 

Scala _класи_ використовуються в OOP стилі програмування. Ось приклад класа, що модулює "персону". В OOP поля типово змінні, так що `firstName` та `lastName` декларовані як `var`: 
[source,scala]
----
class Person(var firstName: String, var lastName: String):
  def printFullName() = println(s"$firstName $lastName")

val p = Person("John", "Stephens")
println(p.firstName)   // "John"
p.lastName = "Legend"
p.printFullName()      // "John Legend"
----
Зауважте, що декларація класу створює конструктор: 
[source,scala]
----
// тут використовується конструктор
val p = Person("John", "Stephens")
----
Конструктори та інші пов'язані з класами теми розкриті в главі _Доменне моделювання_.

=== Доменне моделювання в FP

Коли ви пишете код в FP стилі, ви будете використовувати такі конструкції: 

* Енумерації для визначення ADT
* Кейс класи
* Трейти

==== Енумерації

Конструкція `enum` є чудовим шляхом моделювати алгебраїчні типи даних (ATD) в Scala 3. Наприклад, піцца має три головні атрибути: 

* Розмір коржа
* Товщина коржа
* Приправи (опції)

Це стисло моделюється таким чином: 
[source,scala]
----
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions
----
Як тільки ви маєте енумерейшин, ви можете використовувати його як трейт, клас або об'єкт: 
[source,scala]
----
import CrustSize.*
val currentCrustSize = Small

// енумерація в `match` виразі
currentCrustSize match
  case Small => println("Small crust size")
  case Medium => println("Medium crust size")
  case Large => println("Large crust size")

// енумерація в `if` твердженні
if currentCrustSize == Small then println("Small crust size")
----
Ось інший приклад того, як створити і використовувати ADT в Scala: 
[source,scala]
----
enum Nat:
  case Zero
  case Succ(pred: Nat)
----
Енумерейшини розкриваються в деталях в розділі _Доменне моделювання_ цієї книжки, а також в референсній документації.

==== Кейс класи

В Scala `case` класи дозволяють моделювати концепції з незмінними структурами даних. Кейс клас має всю функціональність звичайного класу, та також додаткові вбудовані можливості, що робить їх корисними для функціонального програмування. Коли компілятор бачить ключове слово `case` перед `class`, це має наступні ефекти та переваги: 

* Конструктор кейс класа має параметри - публічні `val` по замовчанню, так що поля незмінні, та для кожного параметру генерується метод аксессора
* Генерується метод `upapply`, що дозволяє використовувати кейс класи в `match` додатковими шляхами
* В класі генерується метод `copy`. Це провадить шлях створювати оновленні копії об'єктів, не змінюючи оригінальний об'єкт
* Генеруються методи `equals` та `hashCode` для реалізації структурної еквівалентності
* Генерується дефолтний метод `toString`, корисний для дебагінгу

Ви _можете_ вручну додати всі ці методи до класу власноруч, але завдяки тому, що вони так загально використовуються в функціональному програмуванні, використання `case` класів виглядає значно зручнішим.

Цей код демонструє декілька можливостей `case` класів: 
[source,scala]
----
// визначення case class
case class Person(name: String, vocation: String)

// створення примірника case class
val p = Person("Reginald Kenneth Dwight", "Singer")

// гарний метод toString
p // : Person = Person(Reginald Kenneth Dwight,Singer)

// доступ до незмінних полів
p.name         // "Reginald Kenneth Dwight"
p.name = "Joe" // error: can’t reassign a val field

// створення зміненої копії
val p2 = p.copy(name = "Elton John")
p2  // : Person = Person(Elton John,Singer)
----
Дивіться _Доменне модулювання_ для значно більших деталей щодо кейс класів.

=== Методи в Scala

Scala класи, кейс класи, трейти, енумерації, об'єкти - всі можуть мати методи. Синтаксис простого метода може виглядати таким чином: 
[source,scala]
----
def methodName(param1: Type1, param2: Type2): ReturnType =
  // тіло метода
----
Ось декілька прикладів: 
[source,scala]
----
def sum(a: Int, b: Int): Int = a + b
def concatenate(s1: String, s2: String): String = s1 + s2
----
Вам не треба вказувати тип результату методів, тому за бажанням ви можете записати ті самі методи таким чином: 
[source,scala]
----
def sum(a: Int, b: Int) = a + b
def concatenate(s1: String, s2: String) = s1 + s2
----
Ось як ви виклиаєте ці методи: 
[source,scala]
----
val x = sum(1, 2)
val y = concatenate("foo", "bar")
----
Ось приклад багато-рядкового методу: 
[source,scala]
----
def getStackTraceAsString(t: Throwable): String =
  val sw = new StringWriter
  t.printStackTrace(new PrintWriter(sw))
  sw.toString
----
Параметри методыв можуть мати дефолтні значення по замовчанню. В наступному прикладі параметр `timeout` має дефолтне значення `5000`: 
[source,scala]
----
def makeConnection(url: String, timeout: Int = 5000): Unit =
  println(s"url=$url, timeout=$timeout")
----
Оскільки надане дефолтне значення для `timeout`, метод можна викликати в два способи: 
[source,scala]
----
makeConnection("https://localhost")         // url=http://localhost, timeout=5000
makeConnection("https://localhost", 2500)   // url=http://localhost, timeout=2500
----
Scala також підтримує _іменовані параметри_ при виклику методів, так що за бажанням ви можете викликати цей метод таким чином: 
[source,scala]
----
makeConnection(
  url = "https://localhost",
  timeout = 2500
)
----
Іменовані параметри зокрема корисні, коли декілька параметрів метода мають однаковий тип. З першого погляду на цей метод ви можете тільки здогадуватись, які з параметрів  встановлені в `true` або `false`: 
[source,scala]
----
engage(true, true, true, false)
----
Без допомоги IDE цей код важко читати, але наступний код значно очевидніший: 
[source,scala]
----
engage(
  speedIsSet = true,
  directionIsSet = true,
  picardSaidMakeItSo = true,
  turnedOffParkingBrake = false
)
----

=== Методи розширення

_Методи розширення_ дозволяють вам додавати нові методи до зачинених класів. Наприклад, якщо ви бажаєте додати два методи з назвами `hello` та `aloha` до класу `String`, задекларуйте їх як методи розширення: 
[source,scala]
----
extension (s: String)
  def hello: String = s"Hello, ${s.capitalize}!"
  def aloha: String = s"Aloha, ${s.capitalize}!"

"world".hello    // "Hello, World!"
"friend".aloha   // "Aloha, Friend!"
----
Ключове слово `extension` декларує, що ви маєте намір визначити один або більше методів розширення на параметрі, що стоїть в дужках. Як показано в прикладі, параметр `s` типу `String` потім може бути використаний в тілі методів розширення.

Наступний приклад показує, як додати метод `makeInt` до класу `String`. Тут `makeInt` приймає параметр на ім'я `radix`. Код не враховує можливої помилки перетворення рядок-в-ціле, але, оминаючи ці деталі, приклади показують, як це робить: 
[source,scala]
----
extension (s: String)
  def makeInt(radix: Int): Int = Integer.parseInt(s, radix)

"1".makeInt(2)      // Int = 1
"10".makeInt(2)     // Int = 2
"100".makeInt(2)    // Int = 4
----

==== Дивіться також

Методи Scala можуть бути значно потужніші: вони можуь приймати параметри типів та контекстні параметри. Вони детально описані в розділі _Доменне моделювання_.

=== Функції першого класу

Scala має більшість можливостей, які ви очікуєте від функціональної мови програмування, включаючи: 

* Лямбди (анонимні функції)
* Функції вищого гатунку (HOFs)
* Незмінні колекції в стандартній бібліотеці

Лябмди, також відомі як _анонімні функції_, є багатою частиною того, що дозволяє робити ваш код стислим і розумілим.

Метод `map` класу `List` є типовим прикладом функції вищого гатунку - функції, що приймає іншу функцію в якості параметра.

Ці два приклади еквівалентні, і показують, як помножити кожне число в списку на 2, передаючи лямбду в метод `map`: 
[source,scala]
----
val a = List(1, 2, 3).map(i => i * 2)   // List(2,4,6)
val b = List(1, 2, 3).map(_ * 2)        // List(2,4,6)
----
Ці приклади також еквівалентні до наступного коду, що використовує метод `double` замість лямбди: 
[source,scala]
----
def double(i: Int): Int = i * 2

val a = List(1, 2, 3).map(i => double(i))   // List(2,4,6)
val b = List(1, 2, 3).map(double)           // List(2,4,6)
----
  Якщо ви не бачили метод `map` до цього, він застосовує надану функцію до кожного елемента списку, видаючи новий список з отриманими результатами.

Передача лямбда до функцій вищого гатунку на класах колекцій (як `List`), є частиною досвіду Scala, дещо, що ви робитимете кожен день.

=== Незмінні колекції

Коли ви робите з незмінними колекціями, `List`, `Vector`, незмінними класами `Map` та `Set`, важливо знати, що ці функції не змінюють колекцію, на якій вони викликаються. Замість цього вони повертають нову колекцію з оновленнями. Як результат, досить загальним є зчеплювати їх разом в "гнучкому" стилі, для вирішення проблем.

Наприклад, цей приклад показує, як фільтрувати колекцію двічі, та потім помножити кожний елемент в тому, що залишилось: 
[source,scala]
----
// приклад списку
val nums = (1 to 10).toList   // List(1,2,3,4,5,6,7,8,9,10)

// методи можуть бути зціплені
val x = nums.filter(_ > 3)
            .filter(_ < 7)
            .map(_ * 10)

// result: x == List(40, 50, 60)
----
На додаток до функцій вищого гатунку, які використовуються в стандартній бібліотеці, ви також можете створити власні.

=== Об'єкти-синглтони

В Scala ключове слово `object` створює об'єкт-синглтон. Інакше кажучи, `object` визначає клас, що має рівно один примірник.

Об'єкти мають декілька застосувань: 

* Вони використовуються для створення колекцій допоміжних методів-утіліт
* _Об'єкт-компанйон_ - це об'єкт , що має те саме ім'я, що і клас, з яким він поділяє один файл. В такій ситуації клас також називається _класом-компанйоном_
* Вони використовуються для реалізації трейтів, щоб створити _модулі_

==== Допоміжні методи-утіліти

Оскільки `object` є синглтоном, його методи можуть бути досяжними, як методи `static` в Java класі. Наприклад, цей об'єкт `StringUtils` містить невелику колекцію методів, пов'язаних з рядками: 
[source,scala]
----
object StringUtils:
  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty
  def leftTrim(s: String): String = s.replaceAll("^\\s+", "")
  def rightTrim(s: String): String = s.replaceAll("\\s+$", "")
----
Оскільки `StringUtils` є синглтоном, його методи можуть бути викликані на об'єкті: 
[source,scala]
----
val x = StringUtils.isNullOrEmpty("")    // true
val x = StringUtils.isNullOrEmpty("a")   // false
----

==== Об'єкти-компанйони

Компанйон-клас або компанйон-об'єкт можуть отримувати доступ до приватних членів свого компанйона. Використовуйте компанйон-об'єкт для методів, що не є специфічними для примірників компанйон-класа.

Цей приклад демонструє, як метод `area` в компанйон класі має доступ до приватного метода `calculateArea` в компанйон-об'єкті: 
[source,scala]
----
import scala.math.*

class Circle(radius: Double):
  import Circle.*
  def area: Double = calculateArea(radius)

object Circle:
  private def calculateArea(radius: Double): Double =
    Pi * pow(radius, 2.0)

val circle1 = Circle(5.0)
circle1.area   // Double = 78.53981633974483
----

==== Створення модулів з трейтів

Об'єкти також можуть використовуватись для реалізації трейтів, щоб створити модулі. Цей прийом бере два трейти, і комбінує їх, щоб створити конкретний `object`: 
[source,scala]
----
trait AddService:
  def add(a: Int, b: Int) = a + b

trait MultiplyService:
  def multiply(a: Int, b: Int) = a * b

// реалізація трейтів в якості об'єкта
object MathService extends AddService, MultiplyService

// використання об'єкту
import MathService.*
println(add(1,1))        // 2
println(multiply(2,2))   // 4
----

=== Колекції

Бібліотека Scala має багатий набір класів колекцій, і ці класи мають багатий набір методів. Класи колекцій доступні в змінній та незмінній формі.

==== Створення списків

Щоб дати вам відчути смак того, як це робить, ось деякі приклади, що використовують клас `List`, що є незмінним класом зв'язаного списку. Ці приклади показують різні шляхи створити заповнений `List`: 
[source,scala]
----
val a = List(1, 2, 3)           // a: List[Int] = List(1, 2, 3)

// Диапазони
val b = (1 to 5).toList         // b: List[Int] = List(1, 2, 3, 4, 5)
val c = (1 to 10 by 2).toList   // c: List[Int] = List(1, 3, 5, 7, 9)
val e = (1 until 5).toList      // e: List[Int] = List(1, 2, 3, 4)
val f = List.range(1, 5)        // f: List[Int] = List(1, 2, 3, 4)
val g = List.range(1, 10, 3)    // g: List[Int] = List(1, 4, 7)
----

==== Методи списків

Коли ви вже маєте заповнений список, наступні приклади показують деяки з етодів, які ви можете викликати на ньому. Зауважте, що всі вони є функціональними, тобто всі вони не змінюють колекцію, на якій викликаються. Замість цього вони повертають нову колекцію з оновленими елементами. Результати кожної такої операції показані в коментарях: 
[source,scala]
----
// деякий список
val a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)

a.drop(2)                             // List(30, 40, 10)
a.dropWhile(_ < 25)                   // List(30, 40, 10)
a.filter(_ < 25)                      // List(10, 20, 10)
a.slice(2,4)                          // List(30, 40)
a.tail                                // List(20, 30, 40, 10)
a.take(3)                             // List(10, 20, 30)
a.takeWhile(_ < 30)                   // List(10, 20)

// flatten
val a = List(List(1,2), List(3,4))
a.flatten                             // List(1, 2, 3, 4)

// map, flatMap
val nums = List("one", "two")
nums.map(_.toUpperCase)               // List("ONE", "TWO")
nums.flatMap(_.toUpperCase)           // List('O', 'N', 'E', 'T', 'W', 'O')
----
Ці приклади показують, як методи `foldLeft` та `reduceLeft` використовуються для підсумку значень в послідовності цілих: 
[source,scala]
----
val firstTen = (1 to 10).toList    // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

firstTen.reduceLeft(_ + _)         // 55
firstTen.foldLeft(100)(_ + _)      // 155 (100 is a “seed” value)
----
Є багато інших методів, доступних для класів колекцій в Scala, і вони описані в главі _Колекції_, та в документації по API.

=== Тапли

_Тапли_ в Scala є типом, що дозволяє вам просто покласти колекцію різних типів в той самий контейнер. Наприклад, ми маємо такий кейс клас `Person`: 
[source,scala]
----
case class Person(name: String)
----
Ось як ми створюємо тапл, що містить значення `Int`, `String` та власний тип `Person`: 
[source,scala]
----
val t = (11, "eleven", Person("Eleven"))
----
Як тільки ми маємо тапл, ви можете отримати значення через прикріплення їх до змінних, або отримати їх за порядковими номерами: 
[source,scala]
----
t(0)   // 11
t(1)   // "eleven"
t(2)   // Person("Eleven")
----
Ви також можете використати підхід _екстрактора_, щоб призначити поля тапла до імен змінних: 
[source,scala]
----
val (num, str, person) = t

// val num: Int = 11
// val str: String = eleven
// val person: Person = Person(Eleven)
----
Тапли гарні для тих випадків, коли ви бажаєте покласти колекцію гетерогенних типів в малу колекціє-подібну структуру. Дивіться референсну документацію щодо деталей по таплам.

=== Контекстуальні абстракції

За певних обставин ви можете уникнути деяких параметрів у викликах методів, які можна вважати повторюваннями.

Такі параметри називаються _контекстуальними параметрами_, оскільки вони виводяться компілятором з контексту, що оточує виклик методу.

Наприклад, розглянемо програму, що сортує список адрес за двома критеріями: назва міста, та потім назва вулиці.
[source,scala]
----
val addresses: List[Address] = ...

addresses.sortBy(address => (address.city, address.street))
----
Метод `sortBy` приймає функцію, що для кожної адреси повертає значення, по якому треба порівнювати адреси один з одним. В цьому випадку ми передаємо функцію, що повертає пару, яка містить назву міста та назву вулиці.

Зауважте, що ми тольки вказуємо, _що_ треба порівняти, але не _як_ виконувати порівняння. Як алгоритм сортування знає, як порівнюються пари `String`?

Насправді, метод `sortBy` приймає другий параметр, параметр `context`, який виводиться компілятором. Він не з'являється в попередньому прикладі, бо він надається компілятором.

Цей другий параметр реалізує _як_ порівнювати. Зручно уникати його, оскільки ми загалом знаємо, що `String` порівнюються в алфавітному порядку. 

Однак, також завжди можливо передати параметр явно: 
[source,scala]
----
addresses.sortBy(address => (address.city, address.street))(using Ordering.Tuple2(Ordering.String, Ordering.String))
----
В цьому випадку примірник `Ordering.Tuple2(Ordering.String, Ordering.String)` є саме той, що інакше буде виведений компілятором. Інакше кажучи, обоє приклади спродукують ту саму програму.

_Контекстуальні абстракції_ використовуються, щоб уникнути повторюваного коду. Вони допомагають розробникам писати частини коду, що є розширювані і стислі в той самий час.

Для додаткових деталей дивіться главу Контекстуальні абстракції в цій книзі, та також референсну документацію.

=== Визначння вищого рівня

В Scala 3 всі типи визначень можуть бути записані на "верхньому рівні" ваших файлів з кодом. Наприклад, ви можете створити файл з назвою `MyCoolApp.scala` і покласти в нього такий зміст: 
[source,scala]
----
import scala.collection.mutable.ArrayBuffer

enum Topping:
  case Cheese, Pepperoni, Mushrooms

import Topping.*
class Pizza:
  val toppings = ArrayBuffer[Topping]()

val p = Pizza()

extension (s: String)
  def capitalizeAllWords = s.split(" ").map(_.capitalize).mkString(" ")

val hwUpper = "hello, world".capitalizeAllWords

type Money = BigDecimal

// інші визначення ...

@main def myApp =
  p.toppings += Cheese
  println("show me the code".capitalizeAllWords)
----
Як показано, немає потреби класти ці визначення в `package`, `class`, або іншу конструкцію.

==== Заміна для об'єктів пакунку

Якщо ви знайомі зі Scala 2, цей підхід замінює _об'єкти пакунків_. Але хоча це значно простіше в використанні, вони роблять подібним чином: коли ви кладете визначення в пакунок на ім'я `foo`, ви можете потім отримати доступ до визначення в усіх пакунках під пакунком `foo`, як в пакунку `foo.bar` в прикладі нижче: 
[source,scala]
----
package foo {
  def double(i: Int) = i * 2
}

package foo {
  package bar {
    @main def fooBarMain =
      println(s"${double(1)}")   // це робить
  }
}
----
Фігурні дужки використані в цьому прикладі щоб зробити наголос на вкладенні пакунків: 

Переваги цього підходу в тому, що ви можете покласти визначення в пакунок на ім'я `com.acme.myapp`, та потім посилатись на них з `com.acme.myapp.model` та `com.acme.myapp.controller`.

=== Підсумок

В попередніх розділах ви побачили: 

* Як використовувати Scala REPL
* Як створювати змінні `val` та `var`
* Деякі загальні типи даних
* Керівні структури
* Як моделювати реальний світ в стилі OOP та FP
* Як створювати та використовувати методи
* Як використовувати лямбди (анонімні функції) та функції вищого гатунку
* Як використовувати об'єкти для різних цілей
* Вступ до контекстуальних абстракцій

Ми також згадали, що якщо ви бажаєте замість REPL використовувати плейграунд в браузері, ви можете використовувати `Scastie.scala-lang.org` або `ScalaFiddle.io`.

=== Перший погляд на типи 

==== Всі значення мають тип

В Scala всі значення мають тип, включаючи числові значення та функції. Диаграма знизу ілюструє підмножину ієрархії типів:

image::https:docs.scala-lang.org/resources/images/scala3-book/hierarchy.svg[]

`Any` є супертипом всіх типів, і також має назву _верхнього типу_. Він визначає деякі універсальні методи, як `equals`, `hashCode`, `toString`.

Тип `Any` має підтип `Matchable`, що використовується для відмітки всіх типів, на яких ми можемо виконувати порівняння з шаблонами. Важливо гарантувати виклик властивості "_parametricity_". Ми не будемо тут заглиблюватись в деталі, але в підсумку це означає, що ми не можемо виконувати порівняння шаблонів на значеннях тпу `Any`, але тільки на значеннях, що є підтипами `Matchable`. Референсна документація містить більше інформації щодо `Matchable`.

`Matchable` має два важливих субтипи: `AnyVal` та `AnyRef`.

`AnyVal` представляє типи значень. Є декілька перед-визначених типів значень, і всі вони не-порожні (non-nullable): `Double`, `Float`, `Long`, `Int`, `Short`, `Byte`, `Char`, `Unit`, `Boolean`. `Unit` є тип значення, що не несе осмсисленої інформації. Є рівно один примірник `Unit`, на який можна посилатись як `()`.

`AnyRef` представляє типи посилань. Всі типи не-значення визначаються як типи посилань. Кожний власно-визначений тип в Scala є субтипом `AnyRef`. Якщо Scala використовується в контексті Java rintime, `AnyRef` відповідає `java.lang.Object`.

В мовах на основі тверждень для методів, що не повертають значення, використовується `void`. Якщо ви пишете на Scala метод, що не повертає значення, як наступний метод, для тієї ж цілі використовується `Unit`: 
[source,scala]
----
def printIt(a: Any): Unit = println(a)
----
Ось приклад того, що рядки, цілі, символи, логічні значення та функції всі є примірниками `Any`, і можуть розглядатись так само, як будь-який інший об'єкт: 
[source,scala]
----
val list: List[Any] = List(
  "a string",
  732,  // ціле
  'c',  // символ
  true, // логічне
  () => "анонімна функція, що повертає рядок"
)

list.foreach(element => println(element))
----
Код визнначає значення `list` типу `List[Any]`. Список ініціалізований елементами різних типів, але кожний є примірником `scala.Any`, так що ми можемо додати їх до списку. 

Ось вивід програми: 
[source,scala]
----
a string
732
c
true
<function>
----

==== Типи-значення в Scala

Як показано вище, числові типи в Scala розширюють `AnyVal`, і вони є повноцінними об'єктами. Ці приклади показують, як декларувати змінні ціх числових типів: 
[source,scala]
----
val b: Byte = 1
val i: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0
----
В перших чотирьох прикладах, якщо ви не вкажете тип явно, число 1 буде по замовчанню `Int`, так що якщо ви бажаєте інший тип, `Int`, `Long`, або `Short`, вам треба вказати його явно, як це показано. Числа з крапкою (як 2.0) по замовчанню відповідають `Double`, так що яко вам треба отримати `Float`, вам теба вказати це явно, як показано вище.

Оскільки `Int` та `Double` є типами по замовчанню, ви зазвичай створюєте їх без явного декларування типу: 
[source,scala]
----
val i = 123   // Int
val x = 1.0   // Double
----
В вашому коді ви також можете додавати до чисел символи `L`, `D`, `F`, та еквіваленти в нижньому реєстрі, щоб вказати, що це значення `Long`, `Double` або `Float`: 
[source,scala]
----
val x = 1_000L   // val x: Long = 1000
val y = 2.2D     // val y: Double = 2.2
val z = 3.3F     // val z: Float = 3.3
----
Scala також має типи `String` та `Char`, що загалом можна декларувати в неявній формі: 
[source,scala]
----
val s = "Bill"
val c = 'a'
----
Як було показане, рядки оточуються подвійними лапками - або трьома-подвійними для багатьох рядків - та символи оточуються в одинарні лапки.

Ось типи даних та відповідні диапазони значень: 
[cols="1,10"]
|===
|Тип даних|Можливі значення

|`Boolean`|`true` або `false`
|`Byte`|8 бітове знакове ціле, -128 до 127
|`Short`|16 бітове знакове ціле, -32,768 до 32,767
|`Int`|32 бітове знакове ціле, ~2e9 
|`Long`|64 бітове знакове ціле, ~2e18
|`Float`|IEEE 754 single-precision float
|`Double`|IEEE 754 double-precision float
|`Char`|16 бітовий цілий символ Unicode
|`String`|послідовність `Char`
|===

==== BigInt та BigDecimal

Коли вам потрібні справді великі числа, використовуйте типи `BigInt` та `BigDecimal`: 
[source,scala]
----
val a = BigInt(1_234_567_890_987_654_321L)
val b = BigDecimal(123_456.789)
----
Тоді, як `Double` та `Float` представляють приблизні десяткові значення, `BigDecimal` використовується для точної арифметики, як коли маємо справу з грошима.

Гарна новина щодо `BigInt` та `BigDecimal` в тому, що вони підтримують всі оперції, які ми застосовуємо з числовими типами: 
[source,scala]
----
val b = BigInt(1234567890)   // scala.math.BigInt = 1234567890
val c = b + b                // scala.math.BigInt = 2469135780
val d = b * b                // scala.math.BigInt = 1524157875019052100
----

==== Два зауваження щодо рядків

Scala рядки подібні до Java рядків, але вони мають дві великі додаткові можливості: 

* Вони підтримують інтерполяцію рядків
* Також легко створити багаторядкові конструкції

==== Інтерполяція рядків 

Інтерполяція рядків провадить дуже наочний спосіб використовувати змінні в рядках. Наприклад, маючи такі три змінні: 
[source,scala]
----
val firstName = "John"
val mi = 'C'
val lastName = "Doe"
----
Ви можете зкомбінувати ці три змінні в рядок, як цей: 
[source,scala]
----
println(s"Name: $firstName $mi $lastName")   // "Name: John C Doe"
----
Тільки поставьте перед рядком літеру `s`, та символ `$` перед ім'ям вашої змінної в рядку.

Щоб підставити потенційно більші вирази в рядку, заточіть їх в фігурні дужки: 
[source,scala]
----
println(s"2 + 2 = ${2 + 2}")   // prints "2 + 2 = 4"
val x = -1
println(s"x.abs = ${x.abs}")   // prints "x.abs = 1"
----

===== Інші інтерполятори

Символ `s`, що ви ставите перед рядком, є тільки одним з можливих інтерполяторів. Якщо ви підставите `f` замість `s`, ви зможете використовувати `printf`-подібний синтаксис в рядку. Більше того, інтерполятор рядка є тільки особливий метод, і можливо визначити ваш власний. Наприклад, деякі бібліотеки бази даних визначають дуже потужний інтерполятор `sql`.

==== "Багаторядковий" рядок

Багаторядковий рядок створюється, включаючи рядок в потрійні подвійні лапки: 
[source,scala]
----
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""
----
Один з недоліків цього базового підходу в тому, що всі рядки після першого рядка зсунуті, і це виглядає так: 
[source,scala]
----
"The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."
----
Коли проміжки важливі, покладіть символ `|` перед всіма рядками після першого, та викличте метод `stripMargin` після рядка: 
[source,scala]
----
val quote = """The essence of Scala:
               |Fusion of functional and object-oriented
               |programming in a typed setting.""".stripMargin
----
Тепер всі рядки вирівняні по лівому краю: 
[source,scala]
----
"The essence of Scala:
Fusion of functional and object-oriented
programming in a typed setting."
----

=== Приведення типів 

Типи значень можуть приводитись наступним чином: 

image::https://docs.scala-lang.org/resources/images/tour/type-casting-diagram.svg[]

Наприклад: 
[source,scala]
----
val x: Long = 987654321
val y: Float = x  // 9.8765434E8 (зауважте, що при чьому дещо втрачається точність)

val face: Char = '☺'
val number: Int = face  // 9786
----
Приведення типів діє в один бік. Наступне не скомпілюється: 
[source,scala]
----
val x: Long = 987654321
val y: Float = x  // 9.8765434E8
val z: Long = y   // не пійде
----
Ви також можете привести тип посилання до субтипу. Це розглядається далі.

=== Nothing та null

`Nothing` є субтипом всіх типів, і також має назву _нижнього типу_. Немає значення, яке б мало тип `Nothing`. Його загальне використання - вказати на не-завершенісь, таке як виклик виключення, вихід з програми, або нескінчений цикл - тобто, це тип виразу, що не обчислюється до значення, або метода, що не повертається нормально.

`Null` є субтипом всіх типів посилань (тобто любого субкласу `AnyRef`). Він має єдине значення, ідентифіковане ключовим літералом `null`. Наразі використання `null` розглядається як погана практика. Він повинен використовуватись в основному для взаємодії з іншими мовами на JVM. Додаткова опція компілятора змінює статус `Null`, щоб полагодити специфіку його використання. Ця опція може стати по замовчанню в майбутніх версіях Scala. Ви можете прочитати про це в документації по нових можливостях.

В осяжному майбутньому `null` повинен зовсім ніколи не використовуватись в Scala. Альтернативи до використання `null` обговорюються в главі Функціональне програмування цієї книжки, та в документації з API.

=== Керівні структури

Scala має керівні структури, які ви очікуєте побачити в мовах програмування, включаючи: 

* `if / then / else`
* `for` цикли
* `while` цикли
* `try / catch / finally`

Також мова має дві інші потужні конструкції, які ви, можливо, не бачили до цього, в залежності від вашого бекграунду програмування: 

* `for` вирази (також відомі як _for осяжності_)
* `match` вирази

Всі вони демонструються в наступних розділах.

==== Конструкція if/then/else

Однорядне твердження `if` виглядає в Scala так: 
[source,scala]
----
if x == 1 then println(x)
----
Якщо вам треба виконати декілька рядків після порівняння `if`, використовуйте цей синтаксис: 
[source,scala]
----
if x == 1 then
  println("x is 1, as you can see:")
  println(x)
----
Синтаксис `if / else` виглядає так: 
[source,scala]
----
if x == 1 then
  println("x is 1, as you can see:")
  println(x)
else
  println("x was not 1")
----
І ось так виглядає `if / else if / else`: 
[source,scala]
----
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")
----
Ви можете опціонально включити твердження `end if` в кінці кожного виразу, за вашим бажанням: 
[source,scala]
----
if x == 1 then
  println("x is 1, as you can see:")
  println(x)
end if
----

===== Вирази if / else завжди повертають значення

Зауважте, що порівняння `if/else` формують _вирази_, що означає, що вони повертають значення, яка можна зберегти в змінній. Через це немає потреби в окремому тернарному операторі:
[source,scala]
----
val minValue = if a < b then a else b
----
Оскільки вони повертають значення, ви можете використовувати вирази `if/else` в якості тіла метода: 
[source,scala]
----
def compare(a: Int, b: Int): Int =
  if a < b then
    -1
  else if a == b then
    0
  else
    1
----

===== Окремо: вираз-орієнтовне програмування

Як коротке зауваження щодо програмування загалом, коли кожний вираз, який ви пишете, повертає значення, на цей стиль посилаються як на _вираз-орієнтовне програмування_, або EOP. Наприклад, це _вираз_: 
[source,scala]
----
val minValue = if a < b then a else b
----
Навпаки, рядки коду, що не повертають значень,називають _твердженнями_, і вони застосовуються заради своїх _побічних ефектів_. Наприклад, ці рядки коду не повертають значень, так що використовуються заради побічних ефектів: 
[source,scala]
----
if a == b then action()
println("Hello")
----
Перший приклад виконує метод `action`, як побічний ефект того, що `a` дорівнює `b`. Другий приклад використовується для побічного ефекту, друку рядка на `STDOUT`. По мірі того, як ви будете більше вивчати Scala, ви почнете більше використовувати _вирази_, і меньше _твердження_.

=== Цикли for

В своєму найпростішому вигляді цикл Scala `for` може використовуватись для ітерації по елементах колекції. Наприклад, маючи послідовність цілих, ви можете пройти по елементах, та надрукувати їх значення: 
[source,scala]
----
val ints = Seq(1, 2, 3)
for i <- ints do println(i)
----
Вираз `i <- ints` відомий як _генератор_, і якщо ви відкидаєте дужкі в генераторі, потрібно ставити `do` перед кодом за ним. Інакше ви можете записати те саме таким чином: 
[source,scala]
----
for (i <- ints) println(i)
----
Не зважаючи, який підхід ви обираєте, ось як це виглядатиме в Scala REPL: 
[source,scala]
----
scala> val ints = Seq(1,2,3)
ints: Seq[Int] = List(1, 2, 3)

scala> for i <- ints do println(i)
1
2
3
----
Коли вам треба декілька рядків в блоці після `for` генератора, використовуйте наступний синтаксис: 
[source,scala]
----
for
  i <- ints
do
  val x = i * 2
  println(s"i = $i, x = $x")
----

==== Декілька генераторів

Цикли `for` можуть мати декілька генераторів, як показано в цьому прикладі: 
[source,scala]
----
for
  i <- 1 to 2
  j <- 'a' to 'b'
  k <- 1 to 10 by 5
do
  println(s"i = $i, j = $j, k = $k")
----
Цей приклад друкує наступне: 
[source,scala]
----
i = 1, j = a, k = 1
i = 1, j = a, k = 6
i = 1, j = b, k = 1
i = 1, j = b, k = 6
i = 2, j = a, k = 1
i = 2, j = a, k = 6
i = 2, j = b, k = 1
i = 2, j = b, k = 6
----

==== Охоронці

Цикли `for` також можуть містити `if`-твердження, що відомі як _охоронці_: 
[source,scala]
----
for
  i <- 1 to 5
  if i % 2 == 0
do
  println(i)
----
Вивід цього циклу: 
[source,scala]
----
2
4
----
Цикл `for` може мати стільки охоронців, скільки треба. Цей приклад друкує число 4 в певний спосіб: 
[source,scala]
----
for
  i <- 1 to 10
  if i > 3
  if i < 6
  if i % 2 == 0
do
  println(i)
----

===== Використання for з Map

Ви можете використовувати цикли `for` з `Map`. Наприклад, маємо `Map` зі скорочених та повних назв штатів: 
[source,scala]
----
val states = Map(
  "AK" -> "Alaska",
  "AL" -> "Alabama", 
  "AR" -> "Arizona"
)
----
Ви можете роздрукувати ключі та значення в циклі `for`: 
[source,scala]
----
for (abbrev, fullName) <- states do println(s"$abbrev: $fullName")
----
Ось як це виглядатиме в REPL: 
[source,scala]
----
scala> for (abbrev, fullName) <- states do println(s"$abbrev: $fullName")
AK: Alaska
AL: Alabama
AR: Arizona
----
По мірі того, як цикл `for` ітерує по мапі, кожна пара ключ/значення буде прив'язана до пари змінних, `fullName` та `abbrev`, що є таплом: 
[source,scala]
----
(abbrev, fullName) <- states
----
По мірі виконання циклу змінній `abbrev` буде присвоєне поточне значення _ключа_ мапи, та `fullName` отримає поточне _значення_ мапи.

==== for вирази

В попередніх прикладах циклу `for` ці цикли виконувались заради _побічних ефектів_, зокрема друку в STDOUT за допомогою `println`.

Важливо знати, що ви також можете створити `for` _вирази_, що повертають значення. Ви утворюєте `for` вираз, додаючи ключове слово `yield`, та вираз, що повертається: 
[source,scala]
----
val list =
  for
    i <- 10 to 12
  yield
    i * 2

// list: IndexedSeq[Int] = Vector(20, 22, 24)
----
Після виконання циклу `for` змінна `list` міститиме `Vector` з показаними значеннями. Ось як працює цей вираз: 

1. Вираз `for` починає ітерувати по значенням диапазону `(10,11,12)`. Спочатку обробляється значення 10, множиться за 2, і цей результат `yield` (видається) як значення 20.
2. Далі обробляється 11 - друге число з диапазона. Воно множиться на 2, і видається число 22. Ви можете вважати, що ці отримані результати зберігаються в тимчасовому сховищі.
3. Нарешті, обробляється число 12 з диапазону, множиться на 2, видаючи число 24. Цикл завершується в цій точці, видаючи остаточний результат, вектор `Vector(20,22,24)`.

Хоча ціль цього розділу - продемонструвати `for` вирази, може бути корисним розуміти, що показаний вираз `for` еквівалентний до цього виклику метода `map`: 
[source,scala]
----
val list = (10 to 12).map(i => i * 2)
----
`for` вирази можуть використовуватись кожний раз, коли вам треба обійти всі елементи колекції, та застосувати для кожного елементу алгоритм для утворення нового списку. 

Цей приклад показує, як використовувати блок коду після `yield`: 
[source,scala]
----
val names = List("_olivia", "_walter", "_peter")

val capNames = for name <- names yield
  val nameWithoutUnderscore = name.drop(1)
  val capName = nameWithoutUnderscore.capitalize
  capName

// capNames: List[String] = List(Olivia, Walter, Peter)
----

===== Використання for виразів як тіла метода

Оскільки `for` вираз видає результат, він може бути використаний як тіло метода, що повертає корисне значення. Цей метод повертає всі значення наданого списку цілих, між 3 та 10: 
[source,scala]
----
def between3and10(xs: List[Int]): List[Int] =
  for
    x <- xs
    if x >= 3
    if x <= 10
  yield x

between3and10(List(1, 3, 7, 11))   // : List[Int] = List(3, 7)
----

=== while цикли

Синтаксис циклу `while` в Scala виглядає таким чином: 
[source,scala]
----
var i = 0

while i < 3 do
  println(i)
  i += 1
----
Якщо ви використовуєте дужки для перевірки умови, тоді це записується таким чином: 
[source,scala]
----
var i = 0

while (i < 3) {
  println(i)
  i += 1
}
----

=== match вирази

Порівняння шаблонів є головною властивістю функціональних мов програмування, і Scala включчає вирази `match` з багатьма можливостями. 

В найбільш простому випадку ви використовуєте вираз `match` як твердження `switch` в Java, порівнюючи випадки на основі цілих значень. Зауважте, що це вираз, оскільки він обчислює результат: 
[source,scala]
----
import scala.annotation.switch

val i = 5
val day = i match
  case 0 => "Sunday"
  case 1 => "Monday"
  case 2 => "Tuesday"
  case 3 => "Wednesday"
  case 4 => "Thursday"
  case 5 => "Friday"
  case 6 => "Saturday"
  case _ => "invalid day"   // the default, catch-all

  println(day)
----
В цьому прикладі змінна `i` перевіряється на рівнісь з переліченими значеннями. Якщо число в межах від 0 до 6, `day` отримує значення рядка, що представляє назву одного з днів тижня. Якщо ні - спрацьовує випадок перехоплення, представлений символом підкреслення `_`, і `day` отримує рядок `"invalid day"`.

  Коли пишете простий вираз `match`, як цей, рекомендовано використовувати анотацію `@switch` для змінної `i`. Анотація провадить попередження, якщо `switch` не може скомпілюватись як `tableswitch` або `lookupswitch`, що є кращими за продуктивністю.

==== Використання значення по замовчанню

Якщо вам треба отримати значення по замовчанню в `match` виразі, просто надайте ім'я змінної в лівій частині `case` твердження, та потім використовуйте це ім'я в правій частині твердження: 
[source,scala]
----
val i = 2
val digit = i match
  case 0 => "0"
  case 1 => "1"
  case what => s"You gave me: $what"

  println(digit)
----
В цьому прикладі змінна має назву `what`, щоб показати, що тут може бути довільне ім'я. Ви також можете використати підкреслення, щоб проігнорувати це значення.

==== Обробка декількох співпадінь в одному рядку 

Як вже згадувалось, вирази `match` мають багато можливостей. Цей приклад показує, як використовувати декілька можливих співпадінь в кожному твердженні `case`:
[source,scala]
----
val evenOrOdd = i match
  case 1 | 3 | 5 | 7 | 9 => "odd"
  case 2 | 4 | 6 | 8 | 10 => "even"
  case _ => "some other number"

println(evenOdd)
----

==== Використання if охоронців в case конструкціях

Ви також можете використовувати `if` охоронців в порівняннях `match`. В цьому прикладі другий та третій `case` використовують охоронців для порівняння декількох цілих значень: 
[source,scala]
----
val i = 3
val result = i match
  case 1 => "one, a lonely number"
  case x if x == 2 || x == 3 => "two’s company, three’s a crowd"
  case x if x > 3 => "4+, that’s a party"
  case _ => "i’m guessing your number is zero or less"

println(result)
----
Це інший приклад, який показує, як `match` порівнює значеення з диапазонами значень: 
[source,scala]
----
val i = 15
val result = i match
  case a if 0 to 9 contains a => s"0-9 range: $a"
  case b if 10 to 19 contains b => s"10-19 range: $b"
  case c if 20 to 29 contains c => s"20-29 range: $c"
  case _ => "Hmmm..."

println(result)
----

==== Case класи та match вирази

Також ви можете вилучити поля з `case` класів, або класів, що сумлінно реалізують методи `apply`/`unapply`, та використовувати їх в умовах охоронців. Ось приклад з використанням простого `case` классу `Person`: 
[source,scala]
----
case class Person(name: String)

def speak(p: Person) = p match
  case Person(name) if name == "Fred" => println(s"$name says, Yubba dubba doo")
  case Person(name) if name == "Bam Bam" => println(s"$name says, Bam bam!")
  case _ => println("Watch the Flintstones!")

speak(Person("Fred"))      // "Fred says, Yubba dubba doo"
speak(Person("Bam Bam"))   // "Bam Bam says, Bam bam!"
----

=== Використання match виразу як тіла методу

Оскільки `match` вирази повертають значення, вони можуть використовуватись як тіло методів. Цей метод приймає значення `Matchable` як вхідний параметр, та повертає `Boolean` на основі результата `match`: 
[source,scala]
----
def isTruthy(a: Matchable) = a match
  case 0 | "" | false => false
  case _              => true
----
Вхідний параметр `a` визначений з типом `Matchable`, що є коренем для усіх типів Scala, на яких можливо виконувати порівняння. Метод реалізований порівнянням параметру, що має два випадки. Перший перевіряє, чи отримане значення є цілим 0, порожнім рядком або `false`, і повертає `false` в цьому випадку. По замовчанню ми повертаємо `true` для кожного іншого випадку. Ці приклади показують як робить цей метод: 
[source,scala]
----
isTruthy(0)      // false
isTruthy(false)  // false
isTruthy("")     // false
isTruthy(1)      // true
isTruthy(" ")    // true
isTruthy(2F)     // true
----
Використання виразу `match` як тіла методу є дуже загальним прикладом використання.

==== Match вирази підтримують багато різних типів шаблонів

Існує багато різних форм шаблонів, що можна використать для `match` виразів. Приклади включають: 

* Константи-шаблони (такі як `case 3 => `)
* Шаблони послідовностей (такі як `case List(els : _*) => `)
* Шаблони-тапли (такі як `case (x, y) => `)
* Шаблон-конструктори (такі як `case Person(first, last) => `)
* Шаблони порівняння типів (`case p: Person => `)

Всі ці різновиди шаблонів показані в наступному методі `pattern`, що приймає вхідний параметр типу `Matchable`, та повертає `String`: 
[source,scala]
----
def pattern(x: Matchable): String = x match

  // шаблон-константа
  case 0 => "zero"
  case true => "true"
  case "hello" => "you said 'hello'"
  case Nil => "an empty List"

  // шаблон-послідовність
  case List(0, _, _) => "a 3-element list with 0 as the first element"
  case List(1, _*) => "list, starts with 1, has any number of elements"
  case Vector(1, _*) => "vector, starts w/ 1, has any number of elements"

  // шаблон-тапл
  case (a, b) => s"got $a and $b"
  case (a, b, c) => s"got $a, $b, and $c"

  // шаблон-конструктор
  case Person(first, "Alexander") => s"Alexander, first name = $first"
  case Dog("Zeus") => "found a dog named Zeus"

  // шаблон перевірки типів
  case s: String => s"got a string: $s"
  case i: Int => s"got an int: $i"
  case f: Float => s"got a float: $f"
  case a: Array[Int] => s"array of int: ${a.mkString(",")}"
  case as: Array[String] => s"string array: ${as.mkString(",")}"
  case d: Dog => s"dog: ${d.name}"
  case list: List[?] => s"got a List: $list"
  case m: Map[?, ?] => m.toString

  // шаблон по замовчанню
  case _ => "Unknown"
----

=== try/catch/finally

Як і Java, Scala має конструкцію `try/catch/finally`, що дозволяє вам перехоплювати та обробляти виключення. Для узгодженності Scala використовує той самий синтаксис, що використовує `match` для підтримки порівняння шаблонів, на різних можливих виключеннях, що можуть виикнути. 

В наступному прикладі `openAndReadAFile` є метод, який робить те що і обіцяє: відкриває файл та читає текст з нього, отримуючи результат в змінній `text`: 
[source,scala]
----
var text = ""
try
  text = openAndReadAFile(filename)
catch
  case fnf: FileNotFoundException => fnf.printStackTrace()
  case ioe: IOException => ioe.printStackTrace()
finally
// закриття ресурсів
println("Came to the 'finally' clause.")
----
Вважаючи, що метод `openAndReadAFile` використовує Java класи `java.io.*` для читання файлу та не перехоплює виключень, спроба відкриття та читання файлів може призвести до `FileNotFoundException` або `IOException`, і обоє перехоплюються в блоці `catch` в прикладі.

== Доменне моделювання

Ця глава показує, як за допомогою Scala 3 ви можете моделювати оточуючий світ: 

* Розділ Інструменти представляє доступні вам інструменти, включаючи класи, трейти, енумерейшини, тощо.
* Розділ ООП моделювання розглядає моделювання атрибутів та поведінки в стилі об'єктно-орієнтовного програмування (ООП).
* Розділ ФП моделювання розглядає моделювання в стилі функціонального програмування (ФП).

=== Інструменти

Scala 3 провадить багато різних конструкцій для моделювання навколішнього світу: 

* класи
* об'єкти
* компанйон-об'єкти
* трейти
* абстрактні класи
* енуми
* кейс класи
* кейс об'єкти

=== Класи

Так само, як і в інших мовах, _клас_ в Scala - це шаблон для створення примірників об'єктів. Ось декілька прикладів классів: 
[source,scala]
----
class Person(var name: String, var vocation: String)
class Book(var title: String, var author: String, var year: Int)
class Movie(var name: String, var director: String, var year: Int)
----
Ці приклади показують, що Scala має дуже легковажний синтаксис для декларування класів.

Всі параметри наших класів в прикладі визначені як `var` поля, що означає, що вони змінні: ви можете читати, але також і модифікувати їх. Якщо ви бажаєте зробити їх незмінними, замість цього визначте їх як `val` поля, або використовуйте кейс клас.

До Scala 3 ви використовували ключове слово `new` для створення нового примірника класу: 
[source,scala]
----
val p = new Person("Robert Allen Zimmerman", "Harmonica Player")
----
Тепер з застосуванням створювача в Scala 3 це вже не потрібно: 
[source,scala]
----
val p = Person("Robert Allen Zimmerman", "Harmonica Player")
----
Як тільки ви отримали примірник класу, такий як `p`, ви можете отримувати доступ до полів, які в цьому прикладі всі є параметрами конструктора: 
[source,scala]
----
p.name       // "Robert Allen Zimmerman"
p.vocation   // "Harmonica Player"
----
Як було зазначено, всі ці параметри були створені як `var` поля, так що ви можете змінювати їх: 
[source,scala]
----
p.name = "Bob Dylan"
p.vocation = "Musician"
----

==== Поля і методи

Класи також можуть мати методи та додаткові поля, що не є частиною конструкторів. Вони визначаються в тілі класа. Тіло ініціалізується, як частина конструктора по замовчанню: 
[source,scala]
----
class Person(var firstName: String, var lastName: String):

  println("initialization begins")
  val fullName = firstName + " " + lastName

  // метод класу
  def printFullName: Unit =
    // поле `fullName` створене вище
    println(fullName)

  printFullName
  println("initialization ends")
----
Наступна REPL сессія показує, як створити новий примірник цього класу: 
[source,scala]
----
scala> val john = Person("John", "Doe")
initialization begins
John Doe
initialization ends
val john: Person = Person@55d8f6bb

scala> john.printFullName
John Doe
----
Класи також можуть розширювати трейти та абстрактні класи, що розкривається в окремому розділі нижче.

==== Значення параметрів по замовчанню

В якості швидкого погляду на нові можливості, параметри конструктора класу також можуть мати значення по замовчанню: 
[source,scala]
----
class Socket(val timeout: Int = 5_000, val linger: Int = 5_000):
  override def toString = s"timeout: $timeout, linger: $linger"
----
Чудова річ щодо цієї можливості в тому, що споживач вашого класу створює примірники різними способами, так, якби клас мав альтернативні конструктори: 
[source,scala]
----
val s = Socket()                  // timeout: 5000, linger: 5000
val s = Socket(2_500)             // timeout: 2500, linger: 5000
val s = Socket(10_000, 10_000)    // timeout: 10000, linger: 10000
val s = Socket(timeout = 10_000)  // timeout: 10000, linger: 5000
val s = Socket(linger = 10_000)   // timeout: 5000, linger: 10000
----
Коли створюється новий примірник класу, ви також можете використовувати іменовані параметри. Це, зокрема, корисно, коли багато параметрів мають однаковий тип, як показано в цьому порівнянні: 
[source,scala]
----
// option 1
val s = Socket(10_000, 10_000)

// option 2
val s = Socket(
  timeout = 10_000,
  linger = 10_000
)
----

==== Додаткові конструктори

Ви можете визначити класс, що матиме декілька конструкторів, так що споживачі вашого класу можуть будувати його в різний спосіб. Наприклад, уявімо, що вам треба написати код для моделювання студентів в системі реєстрації коледжу. Під час аналізу вимог ви бачите, що вам знадобиться конструювати примірники `Student` в три способи: 

* Маючи ім'я та офіційний ID при початковій реєстрації.
* Маючи ім'я, офіційний ID, та додаткові дані щодо подання, коли вони подають заявку.
* Ім'я, офіційний ID та ID студента, після того, як подання отримує схвалення.

Одним зі способів подолати цю ситуацію в ООП стилі є наступне: 
[source,scala]
----
import java.time.*

// [1] первинний конструктор
class Student(var name: String, var govtId: String):
  private var _applicationDate: Option[LocalDate] = None
  private var _studentId: Int = 0

  // [2] конструктор коли студент надав подання
  def this(name: String, govtId: String, 
    applicationDate: LocalDate
  ) =
    this(name, govtId)
    _applicationDate = Some(applicationDate)

  // [3] конструктор коли студент вже має id 
  def this(name: String, govtId: String, studentId: Int) =
    this(name, govtId)
    _studentId = studentId
----
Клас має три конструктори, пронумеровані в джерельному коді: 

1. Первинний конструктор, що має `name` та `govId` в визначенні класу.
2. Додатковий конструктор з параметрами `name`, `govId`, `applicationDate`.
3. Інший конструктор з параметрами `name`, `govId`, `studentId`.

Ці конструктори можуть бути викликані таким чином: 
[source,scala]
----
val s1 = Student("Mary", "123")
val s2 = Student("Mary", "123", LocalDate.now)
val s3 = Student("Mary", "123", 456)
----
Хоча можна застосувати цей прийом, пам'ятайте, що параметри конструктора можуть мати значення по замовчанню, що виглядає так, ніби клас має декілька конструкторів. Це показане в попередньому прикладі з `Socket`.

=== Об'єкти

Об'єкт є класом, що має рівно один примірник. Він ініціюється ліниво, коли є посилання на члени, так само, як `lazy val`. Об'єкти в Scala дозволяють групіювати методи і поля під одним простором імен, подібно як ви використовуєте `static` члени в класах Java, Javascript (ES6), або `@staticmethod` в Python.

Декларація `object` подібна до декларації `class`. Ось приклад об'єкта "рядкових утіліт", що містить набір методів для роботи з рядками: 
[source,scala]
----
object StringUtils:
  def truncate(s: String, length: Int): String = s.take(length)
  def containsWhitespace(s: String): Boolean = s.matches(".*\\s.*")
  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty
----
Ми можемо використовувати об'єкт наступним чином: 
[source,scala]
----
StringUtils.truncate("Chuck Bartowski", 5)  // "Chuck"
----
Імпоротування в Scala дуже гнучке, та дозволяє імпортувати _всі_ члени об'єкту: 
[source,scala]
----
import StringUtils.*
truncate("Chuck Bartowski", 5)       // "Chuck"
containsWhitespace("Sarah Walker")   // true
isNullOrEmpty("John Casey")          // false
----
Або тільки _деякі_:
[source,scala]
----
import StringUtils.{truncate, containsWhitespace}
truncate("Charles Carmichael", 7) // "Charles"
containsWhitespace("Captain Awesome") // true
isNullOrEmpty("Morgan Grimes") // Not found: isNullOrEmpty (error)
----
Об'єкт також може мати поля, які так само доступні як статичні члени: 
[source,scala]
----
object MathConstants:
  val PI = 3.14159
  val E = 2.71828

println(MathConstants.PI)   // 3.14159
----

=== Об'єкти-компанйони

Об'єкт, що має ту саму назву, що і клас, та визначений в тому самому файлі, що і клас, має назву _об'єкта-компанйона_. Подібно до цього клас називається класом-компанйоном об'єкта. 

Об'єкти-компанйони використовуються для методів і значень, що не є специфічними для примірника класа-компанйона. Наприклад, в наступному прикладі клас `Circle` має член з назвою `area`, що специфічне для кожного примірника, і його об'єкт-компанйон має метод з назвою `calculateArea`, що не є специфічним до примірника,і доступний в кожному примірнику: 
[source,scala]
----
import scala.math.*

case class Circle(radius: Double):
  def area: Double = Circle.calculateArea(radius)

object Circle:
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)

val circle1 = Circle(5.0)
circle1.area
----
В прикладі метод `area`, що доступий для кожного примірника, використовує метод `calculateArea`, що визначений в об'єкті-компанйоні. Ще раз: `calculateArea` подібний до статичних методів в Java. Також, оскільки `calculateArea` є приватним, він недосяжний з іншого коду, але, як показано, його видно в примірнику класу `Circle`.

==== Інші використання

Об'єкти-компанйони можуть використовуватись для декількох призначень: 

* Як було показано, вони можуть використовуватись для групіювання "статичних" методів в одному просторі імен.
** Методи можуть бути публічні або приватні.
** Якщо б `calculateArea` був приватний, від був би досяжний як `Circle.calculateArea`.
* Вони можуть мати методи `apply`, які, завдяки синтаксичному цукру, роблять як методи-фабрики для побудови нових примірників.
* Вони можуть містити метод `upapply`, що служить для деконструкції об'єктів, як в порівнянні шаблонів.

Ось зверхній погляд на те, яе методи `apply` можуть використовуватись в якості методів-фабрик для створення нових об'єктів: 
[source,scala]
----
class Person:
  var name = ""
  var age = 0
  override def toString = s"$name is $age years old"

object Person:

  // одно-параметрична фабрика
  def apply(name: String): Person =
    var p = new Person
    p.name = name
    p

  // дво-параметрична фабрика
  def apply(name: String, age: Int): Person =
    var p = new Person
    p.name = name
    p.age = age
    p

end Person

val joe = Person("Joe")
val fred = Person("Fred", 29)

//val joe: Person = Joe is 0 years old
//val fred: Person = Fred is 29 years old
----
Метод `unapply` тут не пояснюється, але він описаний в референсній документації.

=== Трейти

Якщо ви знайоиі з Java, трейт Scala подібний до інтерфейса в Java 8+. Трейт може містити абстрактні методи та поля, так само як звичайні методи та поля. В базовому використанні трейт може використовуватись як інтерфейс, визначаючи лише абстрактні члени, що будуть реалізовані в інших классах: 
[source,scala]
----
trait Employee:
  def id: Int
  def firstName: String
  def lastName: String
----
Однак трейт може містити звичайні члени. Наприклад, наступний трейт визначає два абстрактні методи, `numLegs` та `walk()`, а також має реалізацію звичайного методу `stop()`: 
[source,scala]
----
trait HasLegs:
  def numLegs: Int
  def walk(): Unit
  def stop() = println("Stopped walking")
----
Ось інший трейт з абстрактним членом і двома реалізованими звичайними методами: 
[source,scala]
----
trait HasTail:
  def tailColor: String
  def wagTail() = println("Tail is wagging")
  def stopTail() = println("Tail is stopped")
----
Зауважте, як кожний трейт обробляє дуже специфічні атрибути та поведінки: `HasLegs` має справу тільки з кінцівками, `HasTail` має справу тільки з функціональністю хвоста. Трейти дозволяють вам будувати такі малі модулі, як ці.

Далі в вашому коді класи можуть міксувати декілька трейтів для побудови більших компонент: 
[source,scala]
----
class IrishSetter(name: String) extends HasLegs, HasTail:
  val numLegs = 4
  val tailColor = "Red"
  def walk() = println("I’m walking")
  override def toString = s"$name is a Dog"
----
Зауважте, що клас `IrishSetter` реалізує абстрактні методи, що визначені в `HasLegs` та `HasTail`. Тепер ви можете створити нові примірники `IrishSetter`: 
[source,scala]
----
val d = IrishSetter("Big Red")   // "Big Red is a Dog"
----
Це тільки присмак того, що можливо робити з трейтами. Для додаткових деталей дивіться залишок ціх уроків моделювання.

=== Абстрактні класи

Коли ви бажаєте написати клас, але знаєте, що він матиме абстрактні методи, ви можете або створити трейт, або абстрактний клас. В більшості ситуацій ви будете використовувати трейти, але історично існує дві ситуації, коли краще використовувати абстрактний клас, ніж трейт: 

* Ви хочете створити базовий клас, що приймає аргументи конструктора.
* Код буде викликаний з Java коду.

==== Базовий клас, що приймає аргументи конструктора

До Scala 3, коли базовий клас потребував аргументи конструктора, ви декларували його як `abstract class`: 
[source,scala]
----
abstract class Pet(name: String):
  def greeting: String
  def age: Int
  override def toString = s"My name is $name, I say $greeting, and I’m $age"

class Dog(name: String, age: Int) extends Pet(name):
  val greeting = "Woof"

val d = Dog("Fido", 1)
----
Але тепер трейти можуть мати параметри, так що ви можете використовувати трейти в тій самій ситуації: 
[source,scala]
----
trait Pet(name: String):
  def greeting: String
  def age: Int
  override def toString = s"My name is $name, I say $greeting, and I’m $age"

class Dog(name: String, var age: Int) extends Pet(name):
  val greeting = "Woof"

val d = Dog("Fido", 1)
----
Трейти більш гнучкі в компоновці, ви можете зміксувати декілька трейтів, але розширити лише один клас, і трейти зазвичай переважають класи та абстрактні класи. Загальне правило є використання класів, коли ви бажаєте створювати примірники певного типу, і трейти - коли бажаєте декомпонувати і повторно використати поведінку.

=== Перелічення (енуми)

Перелічення (енуми) можуть використовуватись для визначення типів, що складаються з обмеженого визначеного переліку іменованих значень (в розділі про ФП моделювання ми побачимо, що енуми значно гнучкіші, ніж це). Базові перелічення використовуються для визначення наборів констант, як місяці року, дні тижня, напрямки Північ-Південь-Захід-Схід, тощо.

В якості прикладу ці перелічення визначають набори атрибутів, що мають відношення до піци: 
[source,scala]
----
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions
----
Щоб використати їх в іншому коді, спочатку імпортуйте їх, та потім використовуйте: 
[source,scala]
----
import CrustSize.*
val currentCrustSize = Small
----
Значення енумів можуть бути порівняні з використанням `==`, а також з порівнянням шаблонів: 
[source,scala]
----
// if/then
if (currentCrustSize == Large)
  println("You get a prize!")

// match
currentCrustSize match
  case Small => println("small")
  case Medium => println("medium")
  case Large => println("large")
----

==== Додаткові можливості енумів

Перелічення можуть бути параметризовані: 
[source,scala]
----
enum Color(val rgb: Int):
  case Red   extends Color(0xFF0000)
  case Green extends Color(0x00FF00)
  case Blue  extends Color(0x0000FF)
----
Вони також можуть мати члени (поля та методи): 
[source,scala]
----
enum Planet(mass: Double, radius: Double):
  private final val G = 6.67300E-11
  def surfaceGravity = G * mass / (radius * radius)
  def surfaceWeight(otherMass: Double) =
    otherMass * surfaceGravity

  case Mercury extends Planet(3.303e+23, 2.4397e6)
  case Earth   extends Planet(5.976e+24, 6.37814e6)
  // more planets here ...
----

==== Сумісність з Java енумами

Якщо ви бажаєте використовувати Scala енуми як Java енуми, ви можете зробити це, розширюючи клас `java.lang.Enum` (що імпортований по замовчанню), таким чином: 
[source,scala]
----
enum Color extends Enum[Color] { case Red, Green, Blue }
----
Параметр типу походить від визначення Java `enum`, і має бути таким же, як тип енума. Немає потреби провадити аргументи конструктора (як зазначено в документації Java API) до `java.lang.Enum` при розширенні, компілятор генерує їх автоматично.

Після визначення `Color` подібним чином, ви можете використовувати його як ви робите це в Java: 
[source,scala]
----
scala> Color.Red.compareTo(Color.Green)
val res0: Int = -1
----
Розділ про алгебраїчні типи та референсна документація розповідає про перелічення більш детально.

=== Кейс класи

Кейс класи використовуються для моделювання незмінних структур даних. Візьмемо наступний приклад: 
[source,scala]
----
case class Person(name: String, relation: String)
----
Оскільки ми декларуємо `Person` як кейс клас, поля `name` та `relation` є публічними та незмінними по замовчанню. Ми можемо створити примірники кейс класу таким чином: 
[source,scala]
----
val christina = Person("Christina", "niece")
----
Зауважте, що поля не можуть бути змінені: 
[source,scala]
----
christina.name = "Fred"   // error: reassignment to val
----
Оскільки поля кейс класу вважаються незмінними, компілятор Scala може згенерувати для вас багато корисних методів: 

* Генерується метод `unapply`, що дозволяє вам виконувати порівняння шаблонів на кейс класах (тобто, `case Person(n,r) => ...`).
* Генерується метод `copy`, що дуже корисний для створення модифікованих копій примірника.
* Генеруються методи `equals` та `hashCode`, на основі структурної еквівалентності, що дозволяє використовувати примірники кейс класів в `Map`.
* Генерується метод по замовчанню `toString`, що корисний для налагодження.

Ці додаткові можливості демонструються в прикладі нижче: 
[source,scala]
----
// Кейс клас може виступати як шаблон
christina match
  case Person(n, r) => println("name is " + n)

// згенеровані методи `equals` та `hashCode`
val hannah = Person("Hannah", "niece")
christina == hannah       // false

// метод `toString`
println(christina)        // Person(Christina,niece)

// вбудований метод `copy`
case class BaseballTeam(name: String, lastWorldSeriesWin: Int)
val cubs1908 = BaseballTeam("Chicago Cubs", 1908)
val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)
// результат:
// cubs2016: BaseballTeam = BaseballTeam(Chicago Cubs,2016)
----

==== Підтримка функціонального програмування

Як вже згадувалось, кейс класи підтримують функціональне програмування: 

* В ФП ви намагаєтесь уникати зміни структур даних. Так що має сенс, щоб поля конструктора по замовчанню були `val`. Оскільки примірники кейс класу не можуть бути змінені, вони можуть легко бути поширені, без остраху зміни або стану гонки.
* Замість зміни примірника ви можете використовувати метод `copy`, як шаблон для створення нового (потенційно зміненого) примірника. Цей процес відомий як "оновлення при копіюванні".
* Маючи авто-згенерований метод `unapply` ви також дозволяєте використання кейс класів в просунутих випадках порівнянь шаблонів.

=== Кейс об'єкти

Кейс об'єкти до об'єктів те саме, що кейс класи для класів: вони надають декілька авто-згенерованих методів, що робить їх більш потужними. Зокрема вони корисні, коли вам треба об'єкт-синглтон з трохи більшою функціональністю, як спроможність бути порівняним в конструкції `match` виразу.

Кейс об'єкти корисні, коли вам треба передати незмінні повідомлення. Наприклад, коли ви робите з проектом музичного плеєра, ви створюєте набір команд або повідомлень, десь так: 
[source,scala]
----
sealed trait Message
case class PlaySong(name: String) extends Message
case class IncreaseVolume(amount: Int) extends Message
case class DecreaseVolume(amount: Int) extends Message
case object StopPlaying extends Message
----
Потім, в іншій частині вашого коду, ви можете писати наступні методи, що використовують порівняння шаблонів для обробки повідомлень (вважаємо, що методи `playSong`, `changeVolume`, `stopPlayingSong` визначені в іншому місці): 
[source,scala]
----
def handleMessages(message: Message): Unit = message match
  case PlaySong(name)         => playSong(name)
  case IncreaseVolume(amount) => changeVolume(amount)
  case DecreaseVolume(amount) => changeVolume(-amount)
  case StopPlaying            => stopPlayingSong()
----

== ООП моделювання

Ця глава провадить вступ в доменне моделювання з використанням об'єктно-орієнтовного програмування ООП в Scala 3.

=== Вступ

Scala провадить всі необхідні інструменти для об'єктно-орієнтовної розробки: 

* *Трейти* дозволяють вам задавати (абстрактні) інтерфейси, так само як і реалізації.
* *Композиція міксінів* надає вам інструменти для компонування компонент з меньших частин.
* *Класи* можуть реалізовати інтерфейсси, задані в трейтах.
* *Примірники класів* можуть мати власний приватний стан.
* *Субтипи* дозволяють вам використовувати примірник класу там, де очікується примірник суперкласу.
* *Модифікатори доступу* дозволяють вам контролювати, які члени класу матимуть доступ якою частиною кода.

=== Трейти

Важлива відмінність від інших об'єктних мов, таких як Java, в тому, що основний інструмент декомпозиції в Scala є не класи, а трейти. Вони можуть служити для опису абстрактного інтерфейсу: 
[source,scala]
----
trait Showable:
  def show: String
----
Але також можуть надавати і реалізацію: 
[source,scala]
----
trait Showable:
  def show: String
  def showHtml = "<p>" + show + "</p>"
----
Ви можете бачити, що ми визначаємо метод `showHtml` _в термінах_ абстрактного метода `show`.

Odersky та Zender представили _сервісно-орієнтовну модель компонентів_ та вью:

* *абстрактні члени* як _запитувані_ сервіси: вони все ще мають бути реалізовані в субкласі.
* *конкретні члени* як _проваджені_ сервіси: вони провадяться для субкласу.

Ми вже бачили це в нашому прикладі `Showable`: визначаючи клас `Document`, що розширює `Showable`, ми все ще маємо визначити `show`, але вже маємо `showHtml`: 
[source,scala]
----
class Document(text: String) extends Showable:
  def show = text
----

==== Абстрактні члени

Абстрактні методи не є єдиними речами, що можна залишити абстрактним в трейті. Трейт може містити: 

* абстрактні методи (`def m(): T`)
* абстрактні визначення значень (`val x: T`)
* абстрактні члени типів (`type T`), потенційно з обмеженнями (`type T <: S`)
* абстрактні гівени (`given t: T`)

Кожна з ціх можливостей може бути використана для вказання певних вимог до реалізатора трейта.

=== Композиція міксінів

Трейти не тільки можуть містити абстрактні та конкретні визначення. Scala також провадить потужний спосіб скомпонувати декілька трейтів: можливість, на яку часто посилаються як на _композицію міксінів_.

Уявімо, що є наступні два (потенційно незалежно визначені) трейти: 
[source,scala]
----
trait GreetingService:
  def translate(text: String): String
  def sayHello = translate("Hello")

trait TranslationService:
  def translate(text: String): String = "..."
----
Щоб скомпонувати два сервіси, ми просто створюємо новий трейт, що розширює обоє: 
[source,scala]
----
trait ComposedService extends GreetingService, TranslationService
----
Абстрактні члени одного трейту (такі як `translate` та `GreetingService`) автоматично підходять до конкретних членів іншого трейта. Це робить не тільки з методами, як в цьому прикладі, та також з усіма іншими типами абстрактних членів, переліченими раніше (тобто, типами, визначеннями значень тощо).

=== Класи 

Трейти є чудовими для модуляризації компонент і опису інтерфейсів (потрібні та проваджені). Але в деякий момент ми бажаємо створити їх примірники.  При розробці програм на Scala часто корисно розглянути використання класів як листів вашої моделі наслідування:
[cols="1,3"]
|===
|Трейти|`T1, T2, T3`
|Композиція трейтів|`S extends T1, T2, S extends T2, T3`
|Класи|`C extends S, T3`
|Примірники|`C()`
|=== 
Це все ще більш вірно в Scala 3, де трейти тепер можуть мати параметри, і, таким чином, ще більше уникаючи потребу в класах.

==== Визначення класів

Як і трейти, класи можуть розширювати декілька трейтів (але тільки один суперклас): 
[source,scala]
----
class MyService(name: String) extends ComposedService, Showable:
  def show = s"$name says $sayHello"
----

==== Субтипізація

Ми можемо створити примірник `MyService` таким чином: 
[source,scala]
----
val s1: MyService = MyService("Service 1")
----
Внаслідок субтипізації наш примірник `s1` може бути використаний будь-де, де очікується розширений трейт: 
[source,scala]
----
val s2: GreetingService = s1
val s3: TranslationService = s1
val s4: Showable = s1
// ... і так далі ...
----

==== Планування для розширення

Як зазначалось раніше, можливо розширити інший клас: 
[source,scala]
----
class Person(name: String)
class SoftwareDeveloper(name: String, favoriteLang: String)
  extends Person(name)
----
Однак, оскільки основним інструментом декомпозиції є _трейти_, клас, визначений в одному файлі, _не може_ бути розширений в іншому файлі. Щоб дозволити це, базовий клас треба помітити як `open`: 
[source,scala]
----
open class Person(name: String)
----
Зробити клас `open` є новою можливістю Scala 3. Маркування класів як відкритих уникає багатьох пасток ООП. Зокрема, це вимагає 
від розробників бібліотек явно планувати розширення і документувати класи, помічені як відкриті, за допомогою додаткових контрактів розширення.

=== Примірники та приватний змінний стан

Як і інші мови, що підтримують ООП, трейти та класи в Scala можуть визначати змінні поля: 
[source,scala]
----
class Counter:
  // може досліджуватись тільки через метод `count`
  private var currentCount = 0

  def tick(): Unit = currentCount += 1
  def count: Int = currentCount
----
Кожний примірник класу `Counter` має свій власний приватний стан, що може досліджуватись лише через метод `count`, як ілюструє наступна послідовність: 
[source,scala]
----
val c1 = Counter()
c1.count // 0
c1.tick()
c1.tick()
c1.count // 2
----

==== Модифікатори доступу

По замовчанню всі члени, визначені в Scala, є публічно видимі. Щоб приховати деталі реалізації, можливо визначати члени (методи, поля, типи тощо), щоб зробити їх `private` або `protected`. Таким чином ви можете контролювати, як отримується доступ або перекриття. Приватні члени видимі для самого класу/трейту та його компанйон об'єкта. Захищені члени також видимі в субкласі класу.

=== Просунутий приклад: сервіс-орієнтовний дизайн

Далі ми ілюструємо деякі просунуті можливості Scala, та покажемо, як вони можуть використовуватись для структурування більших софтверних компонент. Приклади адаптовані з папіру "Маштабовані компонентні абстракції" від Martin Odersky та Matthias Zenger. Не хвилюйтесь, якщо ви не розумієте деталей прикладу. Він призначений для демонстрації, як використовувати декілька можливостей для побудови більших компонент.

Наша ціль - визначити програмний компонент з _сім'єю типів_, так що він може бути уточнений пізніше в реалізації компонент. Конкретніше, наступний код визначає компонент `SubjectObserver` як трейт з двома абстрактними членами, `S` (від subjects) та `O` (від observers): 
[source,scala]
----
trait SubjectObserver:

  type S <: Subject
  type O <: Observer

  trait Subject { self: S =>
    private var observers: List[O] = List()
    def subscribe(obs: O): Unit =
      observers = obs :: observers
    def publish() =
      for obs <- observers do obs.notify(this)
  }

  trait Observer {
    def notify(sub: S): Unit
  }
----
Є декілька речей, що потребують пояснення.

==== Абстрактні члени типів

Декларація `type S <: Subject` каже, що в трейті `SubjectObserver` ми можемо посилатись на деякий _невідомий_ (тобто абстрактний) тип з назвою `S`. Однак цей тип не повністю невідомий: про нього відомо, що він є _деяким підтипом_ трейту `Subject`. Любі класи, що розширюють `SubjectObserver` вільні обирати любий тип для `S`, доки цей тип є субтипом для `Subject`. Частина `<: Subject` також відома як _верхня межа для S_.

==== Вкладені трейти

_Всередині_ трейту `SubjectObserver` ми визначаємо два інші трейти. Давайте почнемо з трейту `Observer`, що визначає тільки абстрактний метод `notify`, що приймає аргумент типу S. Як ми швидко побачимо, це важливо, що аргумент має тип `S`, а не `Subject`.

Другий трейт, `Subject`, визначає приватне поле `observers`, щоб зберігати всіх спостерігачів (обсервери), що підписані на деяку подію. Підпис на подію просто зберігає об'єкт в списку. І знову, тип параметра `obs` є `O` а не `Observer`.

==== Само-типова анотація

Нарешті, тепер ми можемо поцікавитись, що означає `self: S =>` на трейті `Subject`. Це має назву _само-типова анотація_. Це вимагає,щоб підтипи `Subject` також були підтипами `S`. Це потрібно, щоб мати змогу викликати `obs.notify` з `this` як аргументом, оскільки він потребує тип `S`. Коли `S` буде _конкретним_ типом, само-типова анотація може бути замінена на `trait Subject extends S`.

=== Реалізація компонента

Тепер ми можемо реалізувати компонент та визначити абстрактні члени типів як конкретні типи: 
[source,scala]
----
object SensorReader extends SubjectObserver:
  type S = Sensor
  type O = Display

  class Sensor(val label: String) extends Subject:
    private var currentValue = 0.0
    def value = currentValue
    def changeValue(v: Double) =
      currentValue = v
      publish()

  class Display extends Observer:
    def notify(sub: Sensor) =
      println(s"${sub.label} has value ${sub.value}")
----
Маючи в своєму розпорядженні всі ці утіліти об'єктного програмування, в наступному розділі ми продемонструємо, як розробляти програми в функціональному стилі.

== ФП моделювання

Ця глава провадить вступ до доменного моделювання з використанням функціонального програмування в Scala 3. Коли моделюєте навколішний світ за допомогою ФП, ви типово використовуєте ці конструкції Scala: 

* Переліки (енуми)
* Кейс класи
* Трейти

  Якщо ви не знайомі з алгебраїчними типами даних (ADT) і їх узагальненням (GADT), ви можете прочитати розділ https://docs.scala-lang.org/scala3/book/types-adts-gadts.html[Algebraic Data Types] перед тим, як просуватись далі.

=== Вступ

В ФП _дані_ та _операції над тими даними_ є дві окремі речі. Вам не треба інкапсулювати їх разом, як ви робите це в ООП.

Концепція подібна до числової алгебри. Коли ви думаєте про цілі числа, чиї значення більші або дорівнюють нулю, ви маєте _множину_ можливих значень, що виглядає так: 

_0, 1, 2 ... Int.MaxValue_

Ігноруючи ділення цілих чисел, можливі _операції_ з ціма значеннями: 

_+, -, *_

ФП дизайн реалізований в подібний спосіб:

* Ви визначаєте набір значень (ваші дані).
* Ви описуєте операції, що роблять з ціма значеннями (ваші функції).

  Як ми побачимо, міркування щодо програм в цьому стилі досить відрізняється від об'єктно-орієнтовного. Дані в ФП просто _є_. Відділення функціональності від даних дозволяють вам перевіряти ваші дані, не турбуючись про поведінку.

В цій главі ми змоделюємо дані та операції, пов'язані з піцою. Ви побачите, як реалізувати частину "дані" моделі ФП в Scala 3, і потім ви побачите декілька різних шляхів, як ви можете організувати операції з ціма даними.

=== Моделювання даних

В Scala опис моделі даних для проблеми програмування є простим: 

* Якщо ви бажаєте моделювати дані в вигляді декількох альтернатив, використовуйте конструкцію `enum`.
* Якщо ви бажаєте лише згрупіювати речі (або треба кращий контроль), використовуйте `case` класи.

==== Опис альтернатив

Дані, що просто складаються з різних альтернатив, як розмір коржів або різні начінки, моделюються в Scala 3 конструкцією `enum`:

[source,scala]
----
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions
----
  Типи даних, що описують різні альтернативи (як `CrustSize`) також часом називають типи суми.

=== Опис складних даних

Піца може розглядатись як _складний контейнер_ з різних атрибутів. Ми можемо використати `case` клас, щоб описати `Pizza`, що складається з `crustSize`, `crustType`, та потенційно декількох `Topping`: 
[source,scala]
----
import CrustSize.*
import CrustType.*
import Topping.*

case class Pizza(
  crustSize: CrustSize,
  crustType: CrustType,
  toppings: Seq[Topping]
)
----
  Типи даних, що _агрегують декілька компонентів_ (як `Pizza`) також іноді називають _типами множення_.

І це все. Це модель даних для піци в стилі ФП. Рішення дуже стисле, бо воно не потребує операцій над піцами, які треба інтегрувати з моделлю даних. Модель даних легко читати, як декларацію реляційної бази даних. Також дуже легко створити значення моделі даних та перевірити її: 
[source,scala]
----
val myFavPizza = Pizza(Small, Regular, Seq(Cheese, Pepperoni))
println(myFavPizza.crustType) // prints Regular
----

==== Ще про модель даних

Ми можемо продовжувати в тому ж дусі для моделювання цілої системи замовлення піци. Ось декілька інших `case` класів, що використовуються для моделювання такої системи: 
[source,scala]
----
case class Address(
  street1: String,
  street2: Option[String],
  city: String,
  state: String,
  zipCode: String
)

case class Customer(
  name: String,
  phone: String,
  address: Address
)

case class Order(
  pizzas: Seq[Pizza],
  customer: Customer
)
----

==== "Худі доменні об'єкти"

В своїй книзі _Функціональне і реактивне доменне моделювання_ Debasish Ghosh стверджує, що в той час, коли практикуючі ООП розробники описують свої класи як "багаті доменні моделі", що інкапсулюють дані та поведінку, ФП моделі даних можна розглядати як "худі доменні об'єкти". Це тому, як показує цей урок, що моделі даних визначені як `case` класи з атрибутами, але без поведінки, що дає короткі і стислі структури даних.

=== Моделювання операцій

Все це веде до цікавого питання: оскільки ФП відділяє дані від операцій над ціма даними, як реалізувати ці операції в Scala?

Відповідь, насправді, дуже проста: ви просто пишете функції (або методи), що оперують зі значеннями даних, які ми щойно змоделювали. Наприклад, ми можемо визначити функцію, що обчислює вартість піци.
[source,scala]
----
def pizzaPrice(p: Pizza): Double = p match
  case Pizza(crustSize, crustType, toppings) =>
    val base  = 6.00
    val crust = crustPrice(crustSize, crustType)
    val tops  = toppings.map(toppingPrice).sum
    base + crust + tops
----
Ви можете зауважити, як реалізація функції просто слідує за формою даних: оскільки `Pizza` є кейс класом, ми використовуємо порівняння шаблонів для отримання компонентів, і викликаємо допоміжні функції для обчислення окремої вартості.
[source,scala]
----
def toppingPrice(t: Topping): Double = t match
  case Cheese | Onions => 0.5
  case Pepperoni | BlackOlives | GreenOlives => 0.75
----
Аналогічно, оскільки `Topping` є переліком, ми використовуємо порівняння шаблонів для розрізнення різних варіантів. Так, сир та цибуля коштують 50 центів, а інше - 75.
[source,scala]
----
def crustPrice(s: CrustSize, t: CrustType): Double =
  (s, t) match
// якщо корж малий або середній його тип не важливий
    case (Small | Medium, _) => 0.25
    case (Large, Thin) => 0.50
    case (Large, Regular) => 0.75
    case (Large, Thick) => 1.00
----
Щоб обчислити вартість коржа ми одночасно порівнюємо шаблони по розміру та типу коржа.

  Важливе зауваження щодо всіх показаних функцій: вони всі _чисті_ функції, вони не змінюють будь-які дані і не мають жодних побічних ефектів (як закидання виключень або запис в файл). Все що вони роблять, це отримують значення та отримують результат.

=== Як організувати функціональність

Коли ми реалізували `pizzaPrice`, ми не казали, _де саме_ треба визначати її. В Scala 3 є чудово прийнятним визначити її на верхньому рівні вашого файла. Однак, мова надає вам багато чудових інструментів, щоб організувати нашу логіку в різних просторах імен та модулях.

Існують декілька різних шляхів реалізувати та впорядкувати поведінку: 

* Визначити функції в об'єкті-компанйоні.
* Використовувати модулярний стиль програмування.
* Використати підхід "функціональних об'єктів".
* Визначити функціональність в методах розширення.

Ці різні рішення показані в залишку розділа.

=== Об'єкти-компанйони

Перший підхід є визначення поведінки, тобто функцій, в об'єкті-компанйоні.

  Як обговорювалось в _Інструменти доменного моделювання_, _об'єкт-компанйон_ є `object`, що має ту саму назву, що і клас, та декларований в тому самому файлі, що і клас.

За цім підходом, на додаток до перелічень та кейс класів ви визначаєте так само названі об'єкти-компанйони, що містять поведінку.
[source,scala]
----
case class Pizza(
  crustSize: CrustSize,
  crustType: CrustType,
  toppings: Seq[Topping]
)

// об'єкт-компанйон до класу Pizza
object Pizza:
  // реалізація `pizzaPrice` 
  def price(p: Pizza): Double = ...

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions

// об'єкт-компанйон до енума Topping
object Topping:
  // реалізація `toppingPrice`
  def price(t: Topping): Double = t match
    case Cheese | Onions => 0.5
    case Pepperoni | BlackOlives | GreenOlives => 0.75
----
За цім підходом ви можете створити `Pizza` та обчислити вартість:
[source,scala]
----
val pizza1 = Pizza(Small, Thin, Seq(Cheese, Onions))
Pizza.price(pizza1)
----
Групування функціональності таким чином має декілька переваг:

* Це асоціює функціональність з даними, і спрощує пошук одного і другого, як для програмістів, так і для компілятора.
* Створоюється простір імен, і, наприклад, дозволяє використовувати `price` як ім'я методу, без необхідності посилання на перевантаження.
* Реалізація `Topping.price` (наприклад) може мати доступ до членів енуму `Cheese` без необхідності його імпорту.

Але також є декілька недоліків, про які варто пам'ятати: 

* Це тісно пов'язує функціональність з вашою моделлю даних. Зокрема, об'єкт-компанйон має бути визначений в тому самому файлі, що і кейс клас.
* Іноді може бути незрозумілим, де визначати функції як `crustPrice`, що однаково можуть розташовуватись в компанйон-об'єктах `CrustSize` та `CrustType`.

=== Модулі

Другий шлях організувати поведінку - використати "модулярний" підхід. Книжка _Programming in Scala_ визначає _модуль_ як "менший програмний шматок з гарно визначеним інтерфейсом і прихованою реалізацією". Поглянемо що це означає.

==== Створення інтерфейсу PizzaService

Перша річ, про яку треба подумати, це "поведінки" `Pizza`. При цьому ми накидуємо трейт `PizzaServiceInterface`: 
[source,scala]
----
trait PizzaServiceInterface:

  def price(p: Pizza): Double

  def addTopping(p: Pizza, t: Topping): Pizza
  def removeAllToppings(p: Pizza): Pizza

  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza
  def updateCrustType(p: Pizza, ct: CrustType): Pizza
----
Як видно, кожний метод приймає `Pizza` як вхідний параметр - разом з іншими параметрами - і потім повертає `Pizza` як результат.

Коли ви пишете чистий інтерфейс, як цей, ви можете думати про нього як про контракт, який стверджує "всі не-абстрактні класи, що розширюють цей трейт, _мають_ провадити реалізацію ціх сервісів". 

Що ви також маєте уявляти в цей момент - це поставити себе на місце користувача цього API. Це допоможе створити деякий "споживаючий" код, щоб переконатись, що воно виглядає як потрібно: 
[source,scala]
----
val p = Pizza(Small, Thin, Seq(Cheese))

// як буде використовуватись PizzaServiceInterface
val p1 = addTopping(p, Pepperoni)
val p2 = addTopping(p1, Onions)
val p3 = updateCrustType(p2, Thick)
val p4 = updateCrustSize(p3, Large)
----
Коли все виглядає як треба, ви типово переходите до інших API, таких як API рахунків, але поки обмежимось піцами. Тепер закінчимо з інтерфейсами, і перейдемо до конкретної реалізації цього інтерфейсу.

  Зауважте, що це зазвичай дво-кроковий процес. На першому кроці ми робимо ескіз контракту API, як інтерфейсу. В деяких випадках ми в результаті створимо декілька конкретних реалізацій базового інтерфейсу.

==== Створення конкретної реалізації

Тепер, коли ми знаємо, як виглядає `PizzaServiceInterface`, ви можете створити його конкретну реалізацію, написавши тіло всіх методів, яки ви визначили в інтерфейсі:
[source,scala]
----
object PizzaService extends PizzaServiceInterface:

  def price(p: Pizza): Double =
    ... // те саме, що і раніше

  def addTopping(p: Pizza, t: Topping): Pizza =
    p.copy(toppings = p.toppings :+ t)

  def removeAllToppings(p: Pizza): Pizza =
    p.copy(toppings = Seq.empty)

  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza =
    p.copy(crustSize = cs)

  def updateCrustType(p: Pizza, ct: CrustType): Pizza =
    p.copy(crustType = ct)

end PizzaService
----
Хоча дво-кроковий процес створення інтерфейсу та його реалізації не завжди потрібний, окремо промислити API та його застосування є гарним підходом.

Коли все готове, ви можете використати ваш клас `Pizza` та `PizzaService`: 
[source,scala]
----
import PizzaService.*

val p = Pizza(Small, Thin, Seq(Cheese))

// використання методів PizzaService
val p1 = addTopping(p, Pepperoni)
val p2 = addTopping(p1, Onions)
val p3 = updateCrustType(p2, Thick)
val p4 = updateCrustSize(p3, Large)

println(price(p4)) // друкує 8.75
----

==== Функціональні об'єкти

В книжці _Programming in Scala_ автор визначає термін "функціональний об'єкт" як "об'єкт, що не має жодного змінного стану". Це також стосується типів в `scala.collection.immutable`. Наприклад, методи `List` не змінюють внутрішній стан, замість цього створюючи копію `List` в якості результата.

Ви можете думати про цей підхід як "гибридний ФП/ООП". Ви можете: 

* Моделювати дані з використанням `case` класів.
* Визначати поведінку (методи) в _тому самому типі_, що і дані.
* Реалізовати поведінку як чисті функції: вони не змінюють жодного внутрішнього стану. Замість цього вони повертають копії.

  Це насправді гібрідний підхід: як в ООП, методи є інкапсульованими в клас разом з даними, але, як в типовому ФП, методи реалізовані як чисті функції, що не змінюють дані.

==== Приклад

Використовуючи цей підхід, ви можете напряму реалізувати "функціональність піци":
[source,scala]
----
case class Pizza(
  crustSize: CrustSize,
  crustType: CrustType,
  toppings: Seq[Topping]
):

  // операції моделі даних
  def price: Double =
    pizzaPrice(this) // реалізація див. вище

  def addTopping(t: Topping): Pizza =
    this.copy(toppings = this.toppings :+ t)

  def removeAllToppings: Pizza =
    this.copy(toppings = Seq.empty)

  def updateCrustSize(cs: CrustSize): Pizza =
    this.copy(crustSize = cs)

  def updateCrustType(ct: CrustType): Pizza =
    this.copy(crustType = ct)
----
Зауважте, що, на відміну від попередніх підходів, оскільки це методи класу `Pizza`, вони не потребують посилання на `Pizza` в якості вхідного параметру. Замість цього вони мають власне посилання на поточний примірник, `this`.

Тепер ви можете використовувати цей новий дизайн: 
[source,scala]
----
Pizza(Small, Thin, Seq(Cheese))
  .addTopping(Pepperoni)
  .updateCrustType(Thick)
  .price
----

=== Методи розширення

Нарешті, ми покажемо підхід, що знаходиться між першим (визначення функцій в об'єкті-компанйоні), та останнім (визначення функцій як методів самого типу).

Методи розширення дозволяють вам створювати API, такі як функціональний об'єкт, без визначення функцій як методів самого типу. Це може мати декілька переваг: 

* Наша модель даних знову дуже _стисла_, і не включає жодної поведінки.
* Ми можемо оздобити типи додатковими методами _заднім числом_, без потреби змінювати оригінальне визначення.
* На відміну від об'єктів-компанйонів або прямих методів на типах, методи розширення можна визначати _ззовні_, в іншому файлі.

Давайте повернемось до нашого прикладу: 
[source,scala]
----
case class Pizza(
  crustSize: CrustSize,
  crustType: CrustType,
  toppings: Seq[Topping]
)

extension (p: Pizza)
  def price: Double =
    pizzaPrice(p) // що і раніше

  def addTopping(t: Topping): Pizza =
    p.copy(toppings = p.toppings :+ t)

  def removeAllToppings: Pizza =
    p.copy(toppings = Seq.empty)

  def updateCrustSize(cs: CrustSize): Pizza =
    p.copy(crustSize = cs)

  def updateCrustType(ct: CrustType): Pizza =
    p.copy(crustType = ct)
----
В цьому коді ми визначаємо різні методи як _зовнішні_ методи. В `extension (p: Pizza)` ми кажемо, що ми бажаємо додати методи до примірників `Pizza`, та посилатись далі на цей примірник як на `p`.

Таким чином, ми отримуємо такий самий API, як і раніше.
[source,scala]
----
Pizza(Small, Thin, Seq(Cheese))
  .addTopping(Pepperoni)
  .updateCrustType(Thick)
  .price
----
При цьому ми в змозі визначити розширення в любому іншому модулі. Типово, якщо ви розробник моделі даних, ви будете визначати ваші методи розширення в об'єкті-компанйоні. Таким чином вони вже доступні для всіх користувачів. Інакше методи розширення мають бути явно імпортовані, щоб бути корисними.

=== Підсумок різних підходів

Визначення моделі даних в Scala/FP схильне бути простим: просто моделюйте варіанти даних переліками, та складні дані `case` класами. Після цього для моделювання поведінки використовуються функції, що оперують на значеннях вашої моделі. Ми маємо декілька шляхів для організації наших функцій: 

* Ви можете покласти ваші методи в об'єкт-компанйон.
* Ви можете використовувати модулярний стиль програмування, розділяючи інтерфейс та реалізацію.
* Ви можете створити "функціональний об'єкт", та зберігати методи на визначеному типі даних.
* Ви можете використати методи розширення, щоб додати функціональність до вашої моделі даних.

== Методи

В Scala 2 _методи_ можуть бути визначені в класах, трейтах, об'єктах, кейс класах і кейс об'єктах. Але все на краще: в Scala 3 вони можуть бути визначені _ззовні_ всіх ціх конструкцій. Ми кажемо про визначення "вищого рівня", оскільки вони не вкладені в інші визначення. Коротко кажучи, методи тепер можуть бути визначені будь-де.

Багато можливостей методів будуть продемонстровані в наступних розділах. Оскільки метод `main` потребує додаткового пояснення, йому буде виділений окремий розділ.

=== Властивості методів

Цей розділ вводить в різні аспекти визначення та виклику методів в Scala 3.

=== Визначення методів

Scala методи мають багато властивостей, включаючи такі: 

* Дженерік параметри (параметри типів).
* Значення параметрів по замовчанню.
* Декілька груп параметрів.
* Параметри, надані контекстом.
* Параметри за ім'ям.
...

Деякі з ціх властивостей демонструються в цьому розділі. Але коли ви визначаєте "простий" метод, що не використовує додаткових можливостей, його синтаксис виглядає таким чином: 
[source,scala]
----
def methodName(param1: Type1, param2: Type2): ReturnType =
  // тіло метода
end methodName   // опціонально
----
В цьому синтаксисі: 

* Ключове слово `def` використовується для визначення методу.
* За стандартом Scala методи отримують назву за кемел-кейс домовленістю.
* Параметри методів завжди визначаються разом з типом.
* Декларування типу повернення метода є опціональним.
* Метод може складатись з багатьох рядків, або тільки з одного.
* Провадження частини `end methodName` після тіла метода також є опціональним, і рекомендоване лише для довгих методів.

Ось два приклади одно-рядкових методів з назвою `add`, що приймають два вхідні параметри типу `Int`. Перша версія ясно вказує тип результату `Int`, тоді як друга - ні.
[source,scala]
----
def add(a: Int, b: Int): Int = a + b
def add(a: Int, b: Int) = a + b
----
Рекомендовано анотувати публічно видимі методи типом повернення. Декларування типу повернення може спростити розуміння, коли ви повернетесь через місяць або рік, або коли ви дивитесь на код когось іншого.

=== Виклик методів

Виклик методів прямолінійний: 
[source,scala]
----
val x = add(1, 2)   // 3
----
Класи колекцій в Scala мають десятки вбудованих методів. Ці приклади показують, як їх викликати: 
[source,scala]
----
val x = List(1, 2, 3)
x.size          // 3
x.contains(1)   // true
x.map(_ * 10)   // List(10, 20, 30)
----
Зауваження: 

* `size` не приймає аргументів, та повертає число елементів в списку.
* `contains` приймає один аргумент, значення, що входить до списку або ні. Повертає логічне значення.
* `map` приймає один аргумент, деяку функцію, в дано випадку анонімну, та застосовує її до кожного елемента списку. Повертає новий список, що складається з результатів роботи функціі для кожного елементу.

=== Багаторядкові методи

Коли метод більше одного рядка в довжину, тіло метода починається з другого рядка, посунутого вправо: 
[source,scala]
----
def addThenDouble(a: Int, b: Int): Int =
  // уявімо, що це тіло потребує декілька рядків
  val sum = a + b
  sum * 2
----
В цьому методі: 

* `sum` є незмінна локальна змінна, до неї нема доступу ззовні.
* Останній рядок подвоює значення `sum`, це значення повертається як результат.

Коли ви покладете цей код в REPL, ви переконаєтесь, що він робить як очікувалось: 
[source,scala]
----
scala> addThenDouble(1, 1)
res0: Int = 4
----
Зауважте, що немає потреби в твердженні `return` в кінці метода. Оскільки все в Scala є виразом, що означає, що кожний рядок коду повертає (або _обчислюється до_) значення - тому потреби в `return` немає.

Це стає більш ясно, коли ви скорочуєте ваш метод, та записуєте його в один рядок: 
[source,scala]
----
def addThenDouble(a: Int, b: Int): Int = (a + b) * 2
----
Тіло метода може використовувати всі різноманітні можливості мови: 

* `if/else` вирази
* `match` вирази
* `while` цикли
* `for` цикли і `for` вирази
* призначення змінних
* виклик інших методів
* визначення інших методів

Як приклад метода з реального світу, розглянемо `getStackTraceString`, що конвертує параметр `Throwable` на вході в гарно-форматований `String`: 
[source,scala]
----
def getStackTraceAsString(t: Throwable): String =
  val sw = StringWriter()
  t.printStackTrace(PrintWriter(sw))
  sw.toString
----
В цьому методі: 

* Перший рядок присвоює змінній `sw` новий примірник `StringWriter`.
* Другий рядок зберігає вміст траси стеку в `StringWriter`.
* Третій видає рядкову репрезентацію стеку.

=== Параметри по замовчанню

Параметри методів можуть мати значення по замовчанню. В наступному прикладі значення по замовчанню маюють обоє параметрів, `timeout` та `protocol`: 
[source,scala]
----
def makeConnection(timeout: Int = 5_000, protocol: String = "http") =
  println(f"timeout = ${timeout}%d, protocol = ${protocol}%s")
  // інший код...
----
Оскількі параметри мають значення по замовчанню, метод може викликатись наступним чином: 
[source,scala]
----
makeConnection()                 // timeout = 5000, protocol = http
makeConnection(2_000)            // timeout = 2000, protocol = http
makeConnection(3_000, "https")   // timeout = 3000, protocol = https
----
Ось декілька ключових моментів щодо ціх прикладів:

* В першому прикладі аргументи не провадяться, так що метод використовує значення по замовчанню, `5_000` та `http`.
* В другому прикладі в якості `timeout` передане значення `2_000`, яке використовується разом зі значенням по замовчанню для `protocol`.
* В третьому випадку значення задані для обох параметрів.

Зауважте, що коли використовуються значення по замовчанню, для споживача це виглядає так, ніби метод має три перевантаження.

=== Іменовані параметри

Якщо бажаєте, ви можете також використовувати імена параметрів при виклику метода. Наприклад, `makeConnection` може викликатись таким чином: 
[source,scala]
----
makeConnection(timeout=10_000)
makeConnection(protocol="https")
makeConnection(timeout=10_000, protocol="https")
makeConnection(protocol="https", timeout=10_000)
----
В деяких фреймворках іменовані параметри використовуються дуже щільно. Вони також дуже корисні, коли декілька параметрів методів мають однаковий тип:
[source,scala]
----
engage(true, true, true, false)
----
Без допомоги з боку IDE цей код складно зрозуміти, але наступний код значно ясніший та очевидніший: 
[source,scala]
----
engage(
  speedIsSet = true,
  directionIsSet = true,
  picardSaidMakeItSo = true,
  turnedOffParkingBrake = false
)
----

=== Порада щодо методів, що не мають параметрів

Коли метод не має параметрів, кажуть, що він має _нульову арність_. Аналогічно, метод з одним параметром має арність 1, тощо. Коли ви створюєте метод нульової арності: 

* Якщо метод виконує побічні ефекти, такі як виклик `println`, декларуйте метод з порожніми дужками.
* Якщо метод не виконує побічних дій - наприклад, отримує розмір колекції, що подібне до доступу до поля колекції, тоді порожні дужки треба опустити. 

Наприклад, цей метод виконує побічний еффект, так що він визначається з порожніми дужками: 
[source,scala]
----
def speak() = println("hi")
----
Після цього викликач цього метода повинен вказувати порожні дужки при використанні метода: 
[source,scala]
----
speak     // error: "method speak must be called with () argument"
speak()   // prints "hi"
----
Хоча це тільки домовленість, слідування їй значно покращує зрозумілість коду: стає швидко зрозумілим, чи метод виконує побічні ефекти.

=== Використання if в якості тіла метода

Оскільки вирази `if/else` повертають значення, вони можуть використовуватись як тіло метода. Ось метод `isTruthy`, що використовує Perl визначення `true` та `false`: 
[source,scala]
----
def isTruthy(a: Any) =
  if a == 0 || a == "" || a == false then
    false
  else
    true
----
Ці приклади показують роботу цього метода: 
[source,scala]
----
isTruthy(0)      // false
isTruthy("")     // false
isTruthy("hi")   // true
isTruthy(1.0)    // true
----

=== Використання match як тіла метода 

Вираз `match` також може бути використаний як тіло метода, і це часто відбувається. Ось інша версія `isTruthy`, написана за допомогою вираза `match`: 
[source,scala]
----
def isTruthy(a: Matchable) = a match
  case 0 | "" | false => false
  case _ => true
----
Цей метод робить так само, як попередній, що використовує `if/else`. Ми використовуємо `Matchable` замість `Any` як тип параметра, щоб сприймати тільки значення, що підтримують порівняння шаблонів.

Більше про `Matchable` дізнайтесь в референсній документації.

=== Контроль видимості в класі

В класах, об'єктах, трейтах і енумах, методи Scala публічні по замовчанню, так що створений нижче примірник `Dog` відкриває свій метод `speak`: 
[source,scala]
----
class Dog:
  def speak() = println("Woof")

val d = new Dog
d.speak()   // prints "Woof"
----
Методи також можуть бути марковані як `private`. Це робить іх приватними щодо поточного класу, так що вони не можуть бути викликані або перекриті в субкласах: 
[source,scala]
----
class Animal:
  private def breathe() = println("I’m breathing")

class Cat extends Animal:
  // це не буде компілюватись
  override def breathe() = println("Yo, I’m totally breathing")
----
Якщо ви бажаєте зробити метод приватним для даного класу, але також дозволити субкласам викликати та перекривати його, позначте його як `protected`, як показано нижче в методі `speak`: 
[source,scala]
----
class Animal:
  private def breathe() = println("I’m breathing")
  def walk() =
    breathe()
    println("I’m walking")
  protected def speak() = println("Hello?")

class Cat extends Animal:
  override def speak() = println("Meow")

val cat = new Cat
cat.walk()
cat.speak()
cat.breathe()   // не скомпілюється
----
Власне `protected` означає наступне: 

* До поля або метода є доступ з інших екземплярів того самого класу.
* (Як слідоцтво) він доступний для субкласів.
* Його не видно з іншого коду в поточному пакунку.

=== Об'єкти можуть містити методи

Раніше ви бачили, що трейти та класи можуть мати методи. Ключове слово `object` в Scala служить для визначення класа синглтона, і об'єкт також може містити методи. Це гарний спосіб групувати "утілітарні" методи. Наприклад, цей об'єкт містить методи, що стосуються рядків: 
[source,scala]
----
object StringUtils:

  /**
   * Returns a string that is the same as the input string, but
   * truncated to the specified length.
   */
  def truncate(s: String, length: Int): String = s.take(length)

  /**
    * Returns true if the string contains only letters and numbers.
    */
  def lettersAndNumbersOnly_?(s: String): Boolean =
    s.matches("[a-zA-Z0-9]+")

  /**
   * Returns true if the given string contains any whitespace
   * at all. Assumes that `s` is not null.
   */
  def containsWhitespace(s: String): Boolean =
    s.matches(".*\\s.*")

end StringUtils
----

=== Методи розширення

Методи розширення обговорюються в главі Контекстуальні абстракції. Їх головне призначення - додзволити вам додавати нову функціональність до закритих класів. Як показане в розділі про розширення, уявімо, що ми маємо клас `Circle`, але не в змозі змінити джерельний код. Наприклад, він може бути визначений в сторонній бібліотеці таким чином: 
[source,scala]
----
case class Circle(x: Double, y: Double, radius: Double)
----
Якщо ви бажаєте додати методи до класу, ви можете зробити це через методи розширення: 
[source,scala]
----
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius
----
Тепер, якщо ви маєте примірник `Circle` на ім'я `aCircle`, ви можете викликати ці методи: 
[source,scala]
----
aCircle.circumference
aCircle.diameter
aCircle.area
----
Шукайте розділи про методи розширення в цій книзі та в референсній документації.

=== Та ще більше

Є ще багато чого, що треба знати про методи: 

* Виклик методів на суперкласах.
* Визначення і використання параметрів за-ім'ям.
* Методи, що приймають функціональні параметри.
* Створення інлайн методів.
* Обробка виключень.
* Використання вхідних параметрів `vararg`.
* Методи з декількома групами параметрів та частково застосовані функції.
* Методи з дженерік параметрами типів.

Все це висвітлене в референсній документації.

=== Main методи

Scala 3 пропонує новий шлях визначення програм, що можуть бути викликані з командного рядка: додавання анотації `@main` до метода перетвворює його на вхідну точку виконавчої програми: 
[source,scala]
----
@main def hello() = println("Hello, world")
----
Збережіть цей рядок коду в файлі, наприклад, _Hello.scala_ - ім'я файлу не повинно співпадати з назвою метода - і скомпілюйте та виконайте його (на момент компілятор та виконавець мають назви _scalac3_ та _scala3_ відповідно): 
[source,sh]
----
$ scalac Hello.scala
$ scala hello
Hello, world
----
Метод, що анотований як `@main`, може бути написаний на верхньому рівні (як показано), або в статично досяжному об'єкті. В обох випадках, ім'я програми є ім'я самого метода, без жодних префіксів об'єкта.

==== Аргументи командного рядка

З таким підходом ваш `@main` метод може обробляти аргументи командного рядка, і ці аргументи можуть мати різні типи. Наприклад, маємо `@main` метод, що приймає `Int`, `String`, та vararg `String*` параметри: 
[source,scala]
----
@main def happyBirthday(age: Int, name: String, others: String*) =
  val suffix = (age % 100) match
    case 11 | 12 | 13 => "th"
    case _ => (age % 10) match
      case 1 => "st"
      case 2 => "nd"
      case 3 => "rd"
      case _ => "th"

  val sb = StringBuilder(s"Happy $age$suffix birthday, $name")
  for other <- others do sb.append(" and ").append(other)
  sb.toString
----
Коли ви скомпілюєте цей код, він створить програму _happyBirthday_, яка викликається таким чином: 
[source,sh]
----
$ scala happyBirthday 23 Lisa Peter
Happy 23rd Birthday, Lisa and Peter!
----
Як показано, метод `@main` може мати довільне число параметрів. Для кожного параметру тип має бути примірником `scala.util.FromString`, що конвертує аргумент `String` в потрібний тип параметру. Також, як показано, список параметрів `@main` метода може завершуватись "поглинаючим" параметром, як `String*`, що приймає залишок параметрів, заданих до кінця рядка. 

Програма, реалізована через метод `@main`, перевіряє, чи достатньо аргументів в командному рядку, щоб заповнити всі параметри, і що рядки аргументів можуть бути конвертовані в потрібні типи. Якщо перевірка схибить, програма завершиться з помилкою: 
[source,sh]
----
$ scala happyBirthday 22
Illegal command line after first argument: more arguments expected

$ scala happyBirthday sixty Fred
Illegal command line: java.lang.NumberFormatException: For input string: "sixty"
----

==== Деталі 

